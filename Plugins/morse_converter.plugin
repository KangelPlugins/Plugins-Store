# сделала перевод интерфейса для пендосов

import re
from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook
from android_utils import run_on_ui_thread, log
from hook_utils import find_class, set_private_field
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch, Selector, Divider
from typing import Any

# --- метаданные ---
__id__ = "morse_converter"
__name__ = "Морзянка | Morse Code"
__description__ = """
★ конвертирует сообщения в азбуку морзе и обратно ★
——————————————————————————————
v1.4.0: настройки в ui, поддержка премиум-эмодзи и фикс багов с расшифровкой

[ исходящие ]
  .mon / .moff — автоперевод текста при отправке
  .m текст — перевести конкретное сообщение

[ входящие ]
  .dmon / .dmoff — локальная расшифровка сообщений
  .dlang ru / en — выбор языка декодера


★ converts messages to morse code and back ★ 
——————————————————————————————
v1.4.0: ui settings, premium emoji support, and decoding bug fixes

[ outgoing ]
  .mon / .moff — auto-encode outgoing messages
  .m text — one-time translation

[ incoming ]
  .dmon / .dmoff — local decoding of incoming morse
  .dlang ru / en — select decoder language
"""
__author__ = "@insonniiia"
__version__ = "1.4.0"
__icon__ = "hsrgustinex/21"
__min_version__ = "11.12.0"


# --- словари ---
MORSE_RU = {
    'а': '.-', 'б': '-...', 'в': '.--', 'г': '--.', 'д': '-..', 'е': '.', 
    'ж': '...-', 'з': '--..', 'и': '..', 'й': '.---', 'к': '-.-', 'л': '.-..', 
    'м': '--', 'н': '-.', 'о': '---', 'п': '.--.', 'р': '.-.', 'с': '...', 
    'т': '-', 'у': '..-', 'ф': '..-.', 'х': '....', 'ц': '-.-.', 'ч': '---.', 
    'ш': '----', 'щ': '--.-', 'ъ': '--.--', 'ы': '-.--', 'ь': '-..-', 'э': '..-..', 
    'ю': '..--', 'я': '.-.-',
    '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
    '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----',
    '.': '.-.-.-', ',': '--..--', '?': '..--..', '!': '-.-.--', 
    '-': '-....-', ':': '---...', '(': '-.--.', ')': '-.--.-'
}

MORSE_EN = {
    'a': '.-', 'b': '-...', 'c': '-.-.', 'd': '-..', 'e': '.', 'f': '..-.', 
    'g': '--.', 'h': '....', 'i': '..', 'j': '.---', 'k': '-.-', 'l': '.-..', 
    'm': '--', 'n': '-.', 'o': '---', 'p': '.--.', 'q': '--.-', 'r': '.-.', 
    's': '...', 't': '-', 'u': '..-', 'v': '...-', 'w': '.--', 'x': '-..-', 
    'y': '-.--', 'z': '--..',
    '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....',
    '6': '-....', '7': '--...', '8': '---..', '9': '----.', '0': '-----',
    '.': '.-.-.-', ',': '--..--', '?': '..--..', '!': '-.-.--', 
    '-': '-....-', ':': '---...', '(': '-.--.', ')': '-.--.-'
}

REVERSE_RU = {v: k for k, v in MORSE_RU.items()}
REVERSE_EN = {v: k for k, v in MORSE_EN.items()}

# --- java классы ---
SpannableStringBuilder = find_class("android.text.SpannableStringBuilder")

# --- хук для входящих сообщений ---
class IncomingMorseHook(MethodHook):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def before_hooked_method(self, param: Any):
        if not self.plugin.get_setting("decode_enabled", False):
            return

        try:
            message_object = param.args[0]
            if not message_object:
                return

            text_obj = None
            is_caption = False
            
            if hasattr(message_object, "caption") and message_object.caption is not None:
                text_obj = message_object.caption
                is_caption = True
            elif hasattr(message_object, "messageText") and message_object.messageText is not None:
                text_obj = message_object.messageText
            
            if not text_obj:
                return

            text_str = str(text_obj)

            if "\n(" in text_str and text_str.endswith(")"):
                return

            if self.plugin._is_morse(text_str):
                decoded = self.plugin._from_morse(text_str, strict=True)
                
                if not decoded.strip():
                    return
                    
                builder = SpannableStringBuilder(text_obj)
                builder.append(f"\n( {decoded} )")
                
                if is_caption:
                    message_object.caption = builder
                    if set_private_field:
                        set_private_field(message_object, "captionLayout", None)
                else:
                    try:
                        message_object.applyNewText(builder)
                    except Exception:
                        message_object.messageText = builder
                    
                    if set_private_field:
                        set_private_field(message_object, "textLayout", None)
                
                cell = param.thisObject
                run_on_ui_thread(lambda: cell.invalidate())

        except Exception as e:
            log(f"[Морзянка] Hook error: {e}")

# --- основной класс плагина ---
class MorsePlugin(BasePlugin):
    
    # --- словари переводов ---
    _translations = {
        "ru": {
            "settings_main": "Основные настройки",
            "encode_auto": "Переводить исходящие (автоматически)",
            "decode_local": "Локальный перевод входящих",
            "lang_header": "Язык расшифровки и интерфейса",
            "lang_select": "Выберите язык",
            "lang_ru": "Русский (RU)",
            "lang_en": "English (EN)",
            "msg_lang_ru": "язык плагина: русик",
            "msg_lang_en": "язык плагина: англисик",
            "msg_enc_on": "морзянка включена!! (˶ˆᗜˆ˵)",
            "msg_enc_off": "морзянка выключена!!",
            "msg_dec_on": "перевод входящей морзянки включен!!",
            "msg_dec_off": "перевод входящей морзянки выключен!!"
        },
        "en": {
            "settings_main": "Main settings",
            "encode_auto": "Encode outgoing (auto)",
            "decode_local": "Decode incoming locally",
            "lang_header": "Decoding & UI Language",
            "lang_select": "Select language",
            "lang_ru": "Русский (RU)",
            "lang_en": "English (EN)",
            "msg_lang_ru": "plugin language: russian",
            "msg_lang_en": "plugin language: english",
            "msg_enc_on": "morse code enabled!! (˶ˆᗜˆ˵)",
            "msg_enc_off": "morse code disabled!!",
            "msg_dec_on": "incoming morse translation enabled!!",
            "msg_dec_off": "incoming morse translation disabled!!"
        }
    }

    # --- утилиты перевода ---
    def _t(self, key: str) -> str:
        lang_idx = self.get_setting("decode_lang_index", 0)
        lang = "en" if lang_idx == 1 else "ru"
        return self._translations.get(lang, self._translations["ru"]).get(key, key)

    def _reload_plugin_settings(self):
        try:
            PC = find_class("com.exteragram.messenger.plugins.PluginsController")
            inst = PC.getInstance()
            try:
                inst.loadPluginSettings(self.id)
            except Exception:
                inst.loadPluginSettings()
        except Exception:
            pass

    def _on_lang_changed(self, index: int):
        self.set_setting("decode_lang_index", index)
        self._reload_plugin_settings()

    # --- инициализация ---
    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._install_hooks()

    def _install_hooks(self):
        try:
            ChatMessageCellClass = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if not ChatMessageCellClass:
                return

            for method in ChatMessageCellClass.getClass().getDeclaredMethods():
                if method.getName() == "setMessageContent":
                    self.hook_method(method, IncomingMorseHook(self), priority=30)
        except Exception as e:
            log(f"[Морзянка] Ошибка установки хука: {e}")

    # --- меню настроек ---
    def create_settings(self):
        return [
            Header(text=self._t("settings_main")),
            Switch(
                key="encode_enabled", 
                text=self._t("encode_auto"), 
                default=False, 
                icon="msg_edit"
            ),
            Switch(
                key="decode_enabled", 
                text=self._t("decode_local"), 
                default=False, 
                icon="msg_message"
            ),
            Divider(),
            Header(text=self._t("lang_header")),
            Selector(
                key="decode_lang_index", 
                text=self._t("lang_select"), 
                default=0, 
                items=[self._t("lang_ru"), self._t("lang_en")], 
                icon="msg_language",
                on_change=lambda val: self._on_lang_changed(val)
            )
        ]

    # --- логика перевода морзе ---
    def _to_morse(self, text: str) -> str:
        leading_spaces = len(text) - len(text.lstrip(' '))
        trailing_spaces = len(text) - len(text.rstrip(' '))
        
        words = text.lower().split()
        if not words:
            return text
            
        encoded_words = []
        for word in words:
            encoded_chars = []
            for char in word:
                morse_char = MORSE_RU.get(char) or MORSE_EN.get(char) or char
                encoded_chars.append(morse_char)
            encoded_words.append(" ".join(encoded_chars))
            
        result = " / ".join(encoded_words)
        return (" " * leading_spaces) + result + (" " * trailing_spaces)

    def _from_morse(self, text: str, strict: bool = False) -> str:
        if strict:
            text = re.sub(r'[^.\- /]', ' ', text)

        text = text.replace(' / ', '   ')
        words = text.split('   ')
        decoded_words = []
        
        lang_idx = self.get_setting("decode_lang_index", 0)
        active_dict = REVERSE_RU if lang_idx == 0 else REVERSE_EN
        
        for word in words:
            chars = word.split()
            decoded_chars = []
            for char in chars:
                if char in active_dict:
                    decoded_chars.append(active_dict[char])
                elif not strict:
                    decoded_chars.append(char)
            
            if decoded_chars:
                decoded_words.append("".join(decoded_chars))
                
        return " ".join(decoded_words)

    def _is_morse(self, text: str) -> bool:
        if not text: return False
        has_morse = any(c in ".-" for c in text)
        has_letters_or_digits = bool(re.search(r'[a-zA-Zа-яА-Я0-9]', text))
        return has_morse and not has_letters_or_digits

    # --- обработка текста с сохранением entities ---
    def _process_message_with_entities(self, text: str, entities: Any) -> tuple[str, Any]:
        if not entities or getattr(entities, 'isEmpty', lambda: True)():
            return self._to_morse(text), entities

        text_bytes = text.encode('utf-16-le')
        new_text_bytes = bytearray()
        
        entity_list = []
        for i in range(entities.size()):
            ent = entities.get(i)
            entity_list.append({
                'obj': ent,
                'offset': ent.offset,
                'length': ent.length
            })
            
        entity_list.sort(key=lambda x: x['offset'])
        
        current_orig_offset = 0
        current_new_offset = 0
        
        for ent_data in entity_list:
            ent = ent_data['obj']
            offset = ent_data['offset']
            length = ent_data['length']
            
            if offset > current_orig_offset:
                chunk_bytes = text_bytes[current_orig_offset*2 : offset*2]
                chunk_str = chunk_bytes.decode('utf-16-le')
                morsed_chunk = self._to_morse(chunk_str)
                morsed_bytes = morsed_chunk.encode('utf-16-le')
                
                new_text_bytes.extend(morsed_bytes)
                current_new_offset += len(morsed_bytes) // 2
                
            chunk_bytes = text_bytes[offset*2 : (offset+length)*2]
            
            ent.offset = current_new_offset
            ent.length = len(chunk_bytes) // 2
            
            new_text_bytes.extend(chunk_bytes)
            current_new_offset += ent.length
            
            current_orig_offset = offset + length
            
        if current_orig_offset * 2 < len(text_bytes):
            chunk_bytes = text_bytes[current_orig_offset*2 : ]
            chunk_str = chunk_bytes.decode('utf-16-le')
            morsed_chunk = self._to_morse(chunk_str)
            morsed_bytes = morsed_chunk.encode('utf-16-le')
            new_text_bytes.extend(morsed_bytes)
            
        return new_text_bytes.decode('utf-16-le'), entities

    # --- хук для исходящих сообщений ---
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not isinstance(params.message, str):
            return HookResult()

        msg = params.message.strip()

        if msg == ".dlang ru":
            self.set_setting("decode_lang_index", 0)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_lang_ru")))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".dlang en":
            self.set_setting("decode_lang_index", 1)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_lang_en")))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".mon":
            self.set_setting("encode_enabled", True)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_enc_on")))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".moff":
            self.set_setting("encode_enabled", False)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_enc_off")))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".dmon":
            self.set_setting("decode_enabled", True)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_dec_on")))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".dmoff":
            self.set_setting("decode_enabled", False)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("msg_dec_off")))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg.startswith(".m "):
            original_text = msg[3:]
            
            if hasattr(params, 'entities') and params.entities:
                for i in range(params.entities.size()):
                    ent = params.entities.get(i)
                    ent.offset = max(0, ent.offset - 3)
                    
            new_text, new_entities = self._process_message_with_entities(original_text, getattr(params, 'entities', None))
            params.message = new_text
            params.entities = new_entities
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if self.get_setting("encode_enabled", False) and not msg.startswith("."):
            new_text, new_entities = self._process_message_with_entities(params.message, getattr(params, 'entities', None))
            params.message = new_text
            params.entities = new_entities
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
            
        return HookResult()