"""
                            Ð”Ð˜Ð¡ÐšÐ›Ð•Ð™ÐœÐ•Ð 

ÐšÐ¾Ñ€Ð¾Ñ‡Ðµ , ÐµÑÐ»Ð¸ Ñ‚ÐµÐ±Ðµ Ð½ÑƒÐ¶ÐµÐ½ ÐºÑƒÑÐ¾Ðº ÐºÐ¾Ð´Ð° Ð¸Ð· ÑÑ‚Ð¾Ð³Ð¾ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° , Ñ‚Ð¾ Ð¿Ð¶
ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹ Ð² Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ð¸ Ð¸Ð»Ð¸ Ð³Ð´Ðµ-Ñ‚Ð¾ ÐµÑ‰Ðµ , Ñ‡Ñ‚Ð¾ Ð²Ð·ÑÐ» ÐºÐ¾Ð´ Ñ @KangelPlugins Ð¸ @Swagnonher
                              Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾
                        ðŸ™ Ð‘Ð›ÐÐ“ÐžÐ¡Ð›ÐÐ’Ð›Ð•ÐÐ˜Ð• ðŸ™

â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£€â£€â¡¤â ¤â£„â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£¤â¡¤â£¤â¡€â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£ â žâ ‰â¢€â£¤â ¶â ®â ·â£¤â£€â¡€â €â €â¢€â €â €â €â €â €â €â €â €â¢€â¡¼â ‹â ˆâ£½â£†â ¹â£¦â¡€â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£¤â ¶â ¶â ¶â ¶â£„â €â €â €â£žâ£â£ â ´â ¯â °â ¶â ¶â ¶â£¾â â ™â£¯â£³â£¥â žâ¢¹â €â €â €â €â €â €â¡¾â €â¢ â¡¾â â¢¹â €â¢»â£§â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â£ â â €â£Šâ£€â£â£€â¡ˆâ¢“â£¦â¡–â ‹â â €â¡°â ‚â €â €â €â €â£¹â¢ â£„â£½â ¬â£¾â ‰â¢¹â ³â¡„â €â €â €â¢¸â ‡â €â¢¸â €â¢€â¡¼â¡‡â¢ˆâ¡¾â¡¦â£„â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â¢°â¡â£ â¡¾â ‰â¢€â €â£€â¡½â ›â¢ƒâ¡„â €â €â¡œâ €â €â €â €â €â €â ™â ›â ›â¢§â¡€â ˆâ »â¢¾â¡„â ˆâ¢§â¡€â €â¢¸â €â €â¢¸â¡°â¡¿â ›â¡§â Šâ¡„â£¿â£®â ³â£„â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â¢¸â¡¾â¢¹â¡‡â €â €â£´â ›â €â¢€â Žâ €â €â£¼â €â €â €â €â €â €â €â €â €â €â¢¸â¡¹â£¦â¡€â €â£³â ¶â£¾â£³â¡„â£¸â €â €â¢¸â ƒâ¢€â£´â ƒâ €â¢¡â£§â£½â €â ¹â¡„â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â¢¸â¡‡â¢¸â¡‡â¢°â¡¾â “â €â €â¡Žâ €â €â¢ â£¿â €â €â €â €â €â €â €â €â €â €â¡žâ¡‰â¢ºâ£¯â£«â¡·â ¦â¡¿â ™â¢·â¡‡â €â¢€â¡â£ â ¿â¡Ÿâ €â¢ â£¾â¡–â¡Ÿâ¡†â €â¡‡â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â ˜â¢§â €â£³â¢¿â¡¾â €â €â£¼â â €â£€â£¾â£¿â €â €â¡„â €â €â €â €â €â¢°â €â ·â¢¿â¡Ÿâ â ˆâ »â£§â¡‡â£ â¢¾â£‡â£¤â žâ£´â ƒâ¡¾â â¢€â¡¿â ‰â ’â¢»â¡‡â €â¡‡â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â ˜â¢»â£§â¡¾â¢ â ƒâ¢€â¡‡â €â¢€â¡¾â â ¸â£¼â¡€â£‡â €â €â €â£†â €â¢¸â¡†â €â¢ â¢§â¡€â €â €â¡·â£žâ£¡â Žâ£‡â£¤â žâ â¡¼â â¢€â¡¿â â €â €â¢¹â â¢ â ‡â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â£€â¡ â €â¢€â£¿â£â¡‡â¢¸â¡€â €â¡‡â €â£¾â ƒâ €â €â ‰â »â â “â ¶â ¶â ¿â¢¤â£€â¡·â¢„â£¸â¢®â£¿â¡¦â£¤â¡Ÿâ ‰â£¿â¢¸â¡â â €â£¸â â¢€â¡žâ ƒâ €â €â ”â¡¿â €â¡¾â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â ¹â¡’â €â ˜â£¿â£¿â¡‡â ¸â£‡â¢°â¡‡â¢°â£§â£¶â£¶â£¶â¡†â €â €â €â €â£´â£–â£„â£’â£¦â£¼â£â£°â£¾â ¿â¢¾â£¯â£‰â£â£¾â¡‡â €â €â¡‡â €â£¼â â €â €â €â£°â ƒâ£¼â …â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â ™â ³â ›â ¶â£½â¡‡â €â£¿â¡„â¢»â£¸â£Žâ ‰â ‰â â €â €â €â €â €â €â ‰â ‰â ‰â ‰â â¢¹â¡â â €â£¸â¡â ™â¡¿â£»â ‘â¢„â €â£§â €â¡Ÿâ¡†â €â €â¢¨â â¡´â¡‡â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â£¿â¢·â €â£¿â¢¹â£„â£¿â ¿â¡‚â €â €â €â ‰â €â €â €â €â €â €â €â €â €â¢¾â â €â €â¡¿â£§â žâ£±â ‡â €â¡˜â ¦â¡½â£„â£¿â ¹â£„â¡´â¢‰â ”â â¢³â €â €â €â €â €â €
â €â €â €â €â €â €â €â¢€â£€â¡€â €â €â €â €â¢°â¡¿â¢¸â£§â ˜â£Ÿâ ™â£¿â¡„â €â €â¢€â¡€â €â €â €â €â €â €â €â €â €â¢ â£¯â –â €â¢°â£·â¢‡â¡¼â ƒâ¢€â žâ €â¡†â €â ™â£¿â¡¦â ™â¢¶â¡â €â €â €â â €â €â €â €â €
â €â €â €â €â ²â¢¿â ‹â ‰â ‰â ™â¢¦â£€â €â €â£¿â¡‡â¢¸â£¿â¡·â ¼â¢¶â ½â£¿â£†â €â ˆâ »â ¤â ¤â ¤â žâ €â €â €â €â¢´â£¿â ‡â €â €â£¸â¡¿â ‹â €â €â Žâ €â¡žâ €â£ â žâ¢â ½â¢¦â¡€â ™â¢¦â£€â €â €â €â €â €â €â €
â €â €â¢€â €â €â¢¸â£…â €â €â ˆâ ‰â ›â ‰â ”â£»â£¸â¢¸â£¿â ¿â£ â¡â£§â ™â¢¿â£§â£„â €â €â €â €â €â €â €â£€â£´â£¾â ƒâ €â €â¢°â ‡â €â €â €â €â €â €â£ â žâ¢â¡”â ƒâ €â â ‹â —â¢¦â£ˆâ ³â£„â €â €â €â €â €
â €â €â¢¿â£â¢¦â£¸â¡œâ£†â €â €â €â €â¡€â €â£§â¡‡â €â¡¿â €â €â €â ‰â â €â ‰â ›â¢·â£„â£€â£ â£´â žâ ‰â¢â¡¾â â €â €â£°â â €â €â €â €â €â¢ â£¾â ƒâ¢°â â €â €â €â €â €â €â €â ‰â ›â¢·â£µâ£„â €â €â €
â¢»â£Ÿâ£¿â¡»â£Žâ¢£â£³â¡˜â£†â €â¢ â¡žâ¡â €â£¾â£§â €â£§â €â €â €â €â €â €â €â €â €â¢ â¡Ÿâ£¿â €â£ â¢‚â£Ÿâ£¡â „â£ â¢¾â£‹â£€â£€â£€â¡€â €â¢°â£¿â ƒâ¢ â¡â €â €â €â €â €â €â €â €â €â €â €â ™â£¿â »â£„â €
â¡ˆâ¢»â£†â »â¡Ÿâ£†â¢»â£§â¢»â£„â¡¼â¢¸â¡‡â£¦â£¿â¡¼â£§â£½â¡„â €â €â €â €â €â €â¢€â£´â£‹â£¤â£¿â¢ˆâ Ÿâ¢¹â¡¿â£¡â¡žâ ‰â ‰â €â €â£°â£¶â£™â£·â£¯â¡â €â£¸â â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ£·â ˆâ¢§
â£–â ¦â£¾â£·â¡™â ¿â €â ™â €â¢»â¡‡â¢¸â¡‡â ˜â¢¿â£·â¡Œâ »â£¿â£¤â €â €â €â£ â£¶â¡¿â ‹â£±â£¿â Ÿâ â£ â£¿â¢ â¡â €â €â¢€â¡¾â Ÿâ ‹â â €â£¨â¢¿â¡‡â €â¡‡â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ£§â €
â ˜â¢¿â£Žâ¡™â ›â ‚â €â €â €â¡¼â ƒâ¢¸â ‡â ˜â¡„â ™â ›â €â ˆâ ‰â €â£ â£¾â¢â¡œâ¢¡â¡¾â ›â €â£ â¡¾â ‰â¢»â£¿â£„â£€â¡¾â ›â €â €â €â¡ â Šâ €â €â¢³â €â¢³â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â ˜â¡„
â €â €â ™â¢¿â£¦â¡€â €â €â €â â €â¢¸â£‡â €â €â €â €â €â €â¢€â£¾â£¿â ƒâ¡Žâ¢ â¡¿â ¥â£¤â žâ ‰â¢°â£¦â£€â¡½â ›â ›â €â €â €â¢ â Žâ €â €â €â €â ¸â£†â ˜â£‡â €â €â €â €â €â €â €â €â €â €â£„â¢‡â €â €â €â¢³
â €â €â €â €â£¿â¢¹â£†â¡€â €â €â¡€â£ˆâ£¿â¢»â¡€â €â €â €â¢€â£¾â¢¿â£‡â ˜â¢ â¡Ÿâ¢€â¡´â ‹â£€â£¸â£·â£¿â ‹â â €â €â €â €â¢€â¡‡â €â €â €â €â €â €â¢»â£·â£Œâ ³â£„â¡€â €â €â €â €â €â €â €â ˆâ ‰â €â €â €â¢¸
â €â €â €â €â ˆâ¢»â£™â ›â ›â ‰â ‰â ‰â €â£¾â£¾â¡€â €â¢€â£¾â¢â£¾â¡¾â¢€â¡žâ¢ â¡¾â£·â£¿â£¿â£¿â ‹â €â €â €â €â €â¡€â¢€â¡žâ €â €â €â €â €â €â €â¢˜â¡Œâ ™â ·â£¬â¡»â£—â ’â ’â ¦â ¤â ¤â ¤â¢¤â£„â£€â €â €â¢¸
â €â €â €â €â €â ¾â¢¯â¡â €â €â €â €â  â¢žâ£»â¢·â£¤â£¾â£â£¸â¢¹â£§â£¸â££â¢Ÿâ£¤â£¿â£¿â¡¿â ¥â¡„â €â €â €â €â €â£§â£¸â €â €â €â €â €â €â €â €â¢¸â¡‡â €â €â €â ‰â ™â ³â ¤â ¤â ¤â£„â£€â£€â €â ˆâ ‰â “â ¿
â €â €â €â €â â ¦â¡¼â ¥â ¤â ¤â¢„â¡¤â –â ‹â â ˜â¡Ÿâ €â ˆâ ³â£œâ£¿â£¿â££â£¾â Ÿâ ‹â â €â¢¸â¡‡â €â €â €â €â €â¢¸â ‡â €â €â €â €â €â €â €â €â €â¢³â €â €â €â €â €â €â €â €â €â €â €â ‰â ¹â£²â£¤â¡€â €
â €â €â €â €â €â €â¡‡â €â €â €â¢€â¡¬â£â ‚â €â €â¡‡â €â €â£¤â£™â¡Ÿâ ‰â¡¯â ¤â ¤â €â €â  â¡¿â €â €â €â €â €â €â ˆâ£‡â €â €â €â €â €â €â €â €â €â£¸â €â €â €â €â €â €â €â €â €â €â£ â ´â ›â â €â ™â£¦
â €â €â €â €â €â €â¡‡â €â €â €â ƒâ €â£¸â €â¢€â£´â¡Ÿâ €â  â ”â ’â£§â£¤â£·â¡¦â¡„â €â €â €â£§â €â €â €â €â €â €â €â¢¸â €â €â €â €â €â €â €â €â €â¡‡â €â €â €â €â €â €â €â¢€â£¤â žâ â €â €â¢€â¡¤â Žâ €
â €â €â €â €â €â¢ˆâ£¿â €â €â €â¢ â €â ƒâ¢ â â¡¼â €â €â €â£ â¡¼â£¿â£â¡â¢¿â¢„â €â €â €â¡â¢§â¡€â €â €â €â €â €â¢¸â¡†â €â €â €â €â €â €â €â €â¡‡â €â €â €â €â €â¢€â¡´â ‹â €â¢€â£¤â ´â Ÿâ ‰â €â €â €
â €â €â €â €â €â¢›â¡»â¡‡â €â €â ˆâ †â €â¢¸â¡„â §â ¤â ´â ›â ‰â£¸â£§â¢»â €â ˜â €â ›â ¦â ¼â ƒâ£€â£¹â †â €â €â €â €â ˆâ¡‡â €â €â €â €â €â €â €â €â¢£â €â €â €â¢€â¡´â ‹â¢€â£¤â žâ ‰â €â €â €â €â €â €â €
â €â €â €â €â ‰â €â ˜â£¿â¡„â €â €â €â €â €â¢»â¡€â €â €â¢€â¡¼â£»â¡½â¢¸â €â €â €â €â¢€â£ â£â â €â €â €â €â €â €â €â£³â €â €â €â €â €â €â €â €â ˜â¡†â €â¢ â¡Ÿâ¢€â¡´â ‹â €â €â €â €â €â €â €â €â €â €

                            DISCLAIMER

Anyway, if you need a piece of code from this plugin,
please mention in the description or somewhere else that you got it from @KangelPlugins and @Swagnonher.
                             Thanks.
                            ðŸ™BLESSðŸ™
"""



__id__ = "wall_feed"
__name__ = "Ð¡Ñ‚ÐµÐ½Ð°"
__description__ = "ðŸ‡·ðŸ‡º | ÐÐ³Ñ€ÐµÐ³Ð°Ñ‚Ð¾Ñ€ Ð¿Ð¾ÑÑ‚Ð¾Ð² ÐºÐ°Ð½Ð°Ð»Ð¾Ð²: Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ñ‡Ð°Ñ‚ ÑÐ²ÐµÑ€Ñ…Ñƒ, Ð¾Ñ„Ñ„Ð»Ð°Ð¹Ð½ Ð¸Ð· Ð‘Ð”, Ñ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ð¼.\n\nÐ¢Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ: exteraGram/AyuGram 11.12.1 Ð¸ Ð²Ñ‹ÑˆÐµ \n\nðŸ‡ºðŸ‡¸ | Aggregated posts from channels: top chat, offline from DB, with unread. \n\n Requirements: exteraGram/AyuGram 11.12.1 and above"
__author__ = "@Swagnonher & @KangelPlugins"
__version__ = "1.1"
__icon__ = "amechan_wakuwaku_by_fStikBot/9"
__min_version__ = "11.12.1"

import time
import threading
from typing import List, Dict, Any, Optional, Tuple

from base_plugin import BasePlugin
from android_utils import log, run_on_ui_thread, OnClickListener
from ui.settings import Input, Divider
from hook_utils import find_class, get_private_field, set_private_field
from client_utils import get_last_fragment, get_messages_storage, get_messages_controller

try:
    from mandre_lib import Mandre
    _MANDRE_AVAILABLE = True
except Exception:
    Mandre = None
    _MANDRE_AVAILABLE = False

from android.view import View, ViewGroup, Gravity
from android.widget import FrameLayout, LinearLayout, TextView
from android.graphics import Color
from android.graphics.drawable import GradientDrawable
from android.util import TypedValue

from org.telegram.messenger import (
    UserConfig, AndroidUtilities, MessageObject, ChatObject, NotificationCenter ,LocaleController
)

from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC
from org.telegram.ui.Cells import ChatMessageCell, DialogCell
from org.telegram.ui.Components import BackupImageView, AvatarDrawable
from java import jclass
from java.util import ArrayList as JArrayList


SETTINGS_KEY_SHOW_HEADER = "show_header_in_chats"
SETTINGS_KEY_BAN_LIST = "ban_list_csv"
SETTINGS_KEY_MAX_POSTS = "max_posts_per_sync"
SETTINGS_KEY_LANGUAGE = "language"
STORAGE_KEY_LAST_READ_DATE = "last_read_date"
STORAGE_KEY_LAST_SYNC = "last_sync_time"
STORAGE_KEY_LAST_WRITE_DATE = "last_write_date"
STORAGE_KEY_LAST_SYNTH_ID = "last_synth_id"
PERSIST_FILE_IGNORE = "ignore.json"
PERSIST_FILE_IDMAP = "idmap.json"

# Localization strings
LOCALES = {
    "ru": {
        "title": "Ð¡Ñ‚ÐµÐ½Ð° (Wall Feed)",
        "show_header": "ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ 'Ð¡Ñ‚ÐµÐ½Ð°' Ð²Ð²ÐµÑ€Ñ…Ñƒ ÑÐ¿Ð¸ÑÐºÐ° Ñ‡Ð°Ñ‚Ð¾Ð²",
        "sync_section": "Ð¡Ð¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ",
        "max_posts": "ÐœÐ°ÐºÑ. Ð¿Ð¾ÑÑ‚Ð¾Ð² Ð½Ð° ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸ÑŽ (Ð½Ð° ÐºÐ°Ð½Ð°Ð»)",
        "ban_list": "Ð˜ÑÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ñ‹Ðµ ÐºÐ°Ð½Ð°Ð»Ñ‹ (ID Ñ‡ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ)",
        "filters_section": "Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹",
        "channel_name": "Ð¡Ñ‚ÐµÐ½Ð°",
        "unread_msg": "â€¢ {count} Ð½ÐµÐ¿Ñ€Ð¾Ñ‡.",
    },
    "en": {
        "title": "Wall (Wall Feed)",
        "show_header": "Show 'Wall' at the top of chats list",
        "sync_section": "Synchronization",
        "max_posts": "Max posts per sync (per channel)",
        "ban_list": "Excluded channels (IDs comma-separated)",
        "filters_section": "Filters",
        "channel_name": "Wall",
        "unread_msg": "â€¢ {count} unread",
    }
}


class WallFeedPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.header_view_ref = None
        self.overlay_container = None
        self.messages_cache: List[Tuple[int, TLRPC.Message, int]] = []  # (dialog_id, message, date)
        self.unread_count = 0
        self.unread_divider_index = -1
        self.hook_create_view_ref = None
        self.hook_on_resume_ref = None
        # Synthetic chat id (positive chat id); dialog id is -WALL_CHAT_ID
        self.WALL_CHAT_ID = 777777777
        self.WALL_DIALOG_ID = -self.WALL_CHAT_ID
        # Sync control
        self._stop_sync = False
        self._sync_thread = None
        # Cache for chats (channel_id -> chat object)
        self._chat_cache: Dict[int, Any] = {}
        self._chat_cache_timestamp: Dict[int, float] = {}
        # DB query backoff and cache
        self._db_backoff: Dict[int, float] = {}
        self._db_empty_count: Dict[int, int] = {}

    def _get_lang(self) -> str:
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except:
            lang = "en"
        return "ru" if lang.startswith("ru") else "en"

    def _get_locale_text(self, key: str) -> str:
        lang_key = self._get_lang()
        locale = LOCALES.get(lang_key, LOCALES["en"])
        return locale.get(key, "")

    def _get_channel_name(self) -> str:
        return self._get_locale_text("channel_name")

    def _get_unread_msg(self, count: int) -> str:
        msg_template = self._get_locale_text("unread_msg")
        return msg_template.format(count=count)

    def get_settings_items(self):
        from ui.settings import Header, Switch, Text, Divider, Input
        
        def on_clear_cache(_):
            try:
                self._ignore_keys = {}
                self._id_map = {}
                self._last_synth_id = 0
                try:
                    self._sql_kv_delete_prefix("ignore:")
                    self._sql_kv_delete_prefix("idmap:")
                    self._sql_kv_set("meta:last_synth_id", 0)
                except Exception:
                    pass
                log(f"[{self.id}] Cache cleared! Ignore keys and ID map reset.")
            except Exception as e:
                log(f"[{self.id}] Error clearing cache: {e}")
        
        items = [
            Header(text=self._get_locale_text("title")),
            Switch(
                key=SETTINGS_KEY_SHOW_HEADER,
                text=self._get_locale_text("show_header"),
                default=False,
                icon="files_folder",
                on_change=lambda v: self._reapply_dialogs_hook()
            ),
            Divider(text=self._get_locale_text("sync_section")),
            Input(
                key=SETTINGS_KEY_MAX_POSTS,
                text=self._get_locale_text("max_posts"),
                icon="msg_download_solar",
                default="500",
                on_change=lambda v: self._set_max_posts(v or "500")
            ),
            Text(
                text="ðŸ—‘ï¸ ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ ÐºÑÑˆ Ð¿Ð¾ÑÑ‚Ð¾Ð²",
                icon="msg_delete",
                on_click=on_clear_cache
            )
        ]
        return items

    def create_settings(self):
        try:
            items = self.get_settings_items()
        except Exception:
            items = []
        try:
            # Inject ban list input if not present
            have_ban = False
            for it in items:
                try:
                    if getattr(it, 'key', None) == SETTINGS_KEY_BAN_LIST:
                        have_ban = True
                        break
                except Exception:
                    continue
            if not have_ban:
                items.insert(1, Input(
                    key=SETTINGS_KEY_BAN_LIST,
                    text=self._get_locale_text("ban_list"),
                    icon="filled_bot_decline_24",
                    default=str(self.get_setting(SETTINGS_KEY_BAN_LIST, "")),
                    on_change=lambda v: self._set_ban_list_csv(v or "")
                ))
                # Optional divider for readability
                items.insert(2, Divider(text=self._get_locale_text("filters_section")))
        except Exception:
            pass
        return items

    def on_plugin_load(self):
        # Check if MandreLib is available - plugin cannot work without it
        if not _MANDRE_AVAILABLE or Mandre is None:
            raise RuntimeError(f"[{self.id}] MandreLib is required but not installed. Please install mandre_lib.")
        
        try:
            if Mandre:
                Mandre.use_persistent_storage(self)
        except Exception:
            log(f"[{self.id}] MandreLib persistent storage unavailable")

        # Init SQL KV store and migrate JSON once; then load state from SQL
        try:
            self._sql_init_storage()
            self._migrate_json_to_sql_once()
            self._load_ignore_and_idmap_from_sql()
            self._last_synth_id = self._sql_kv_get_int("meta:last_synth_id", 0)
        except Exception:
            pass

        self._apply_dialogs_hook()
        self._apply_chat_activity_hooks()

        # Register synthetic chat via MandreLib helper with fallback
        try:
            if Mandre and hasattr(Mandre, "register_synthetic_channel"):
                Mandre.register_synthetic_channel(self.WALL_CHAT_ID, self._get_channel_name(), megagroup=False, broadcast=True)
            else:
                mc = get_messages_controller()
                chat = mc.getChat(self.WALL_CHAT_ID)
                if chat is None:
                    channel = TLRPC.TL_channel()
                    channel.id = int(self.WALL_CHAT_ID)
                    channel.title = self._get_channel_name()
                    channel.megagroup = False
                    channel.broadcast = True
                    mc.putChat(channel, True)
        except Exception as e:
            log(f"[{self.id}] putChat fallback error: {e}")

        try:
            # Start background sync scheduler once
            if not getattr(self, '_sync_thread', None):
                self._sync_thread = threading.Thread(target=self._sync_messages_background, daemon=True)
                self._sync_thread.start()
        except Exception as e:
            log(f"[{self.id}] Background sync thread error: {e}")

        log(f"[{self.id}] Ð¡Ñ‚ÐµÐ½Ð° Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð°")

    def on_plugin_unload(self):
        self._remove_dialogs_hook()
        self._remove_overlay()
        self._clear_chat_cache()
        try:
            self._stop_sync = True
        except Exception:
            pass
        log(f"[{self.id}] Ð¡Ñ‚ÐµÐ½Ð° Ð²Ñ‹Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð°")

    def _apply_dialogs_hook(self):
        try:
            DialogsActivityCls = find_class("org.telegram.ui.DialogsActivity")
            # Hook getDialogsArray to inject synthetic dialog (wrap primitives via java.lang)
            getDialogsArray = DialogsActivityCls.getClass().getDeclaredMethod(
                "getDialogsArray",
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Boolean').TYPE
            )
            getDialogsArray.setAccessible(True)
            self.hook_method(getDialogsArray, _GetDialogsArrayHook(self))

            log(f"[{self.id}] hooked DialogsActivity.getDialogsArray")
        except Exception as e:
            log(f"[{self.id}] dialogs hook error: {e}")

        # Hook DialogsActivity.createView and onResume to attach header and refresh
        try:
            ContextClass = find_class("android.content.Context")
            createView = DialogsActivityCls.getClass().getDeclaredMethod("createView", ContextClass)
            createView.setAccessible(True)
            self.hook_create_view_ref = self.hook_method(createView, _DialogsCreateViewHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs createView hook error: {e}")
        try:
            onResume = DialogsActivityCls.getClass().getDeclaredMethod("onResume")
            onResume.setAccessible(True)
            self.hook_on_resume_ref = self.hook_method(onResume, _DialogsOnResumeHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs onResume hook error: {e}")

        # Hook DialogsAdapter.onBindViewHolder to style our synthetic dialog
        try:
            DialogsAdapter = find_class("org.telegram.ui.Adapters.DialogsAdapter")
            target = None
            for m in DialogsAdapter.getClass().getDeclaredMethods():
                try:
                    if m.getName() == "onBindViewHolder" and len(m.getParameterTypes()) == 2:
                        target = m
                        break
                except Exception:
                    continue
            if target is not None:
                target.setAccessible(True)
                self._dialogs_on_bind_ref = self.hook_method(target, _DialogsOnBindHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs onBind hook error: {e}")

        # Hook MessagesController.getDialogs to ensure our dialog exists in arrays used across app (including some searches)
        # Do not hook MC.getDialogs globally to avoid polluting archives/folders

        # Hook ChatActivity to open Wall feed when the synthetic chat is opened
        # Do not hook ChatActivity; we want default chat UI

    def _remove_dialogs_hook(self):
        try:
            if self.hook_create_view_ref:
                self.unhook_method(self.hook_create_view_ref)
                self.hook_create_view_ref = None
            if self.hook_on_resume_ref:
                self.unhook_method(self.hook_on_resume_ref)
                self.hook_on_resume_ref = None
            if getattr(self, '_dialogs_on_bind_ref', None):
                self.unhook_method(self._dialogs_on_bind_ref)
                self._dialogs_on_bind_ref = None
        except Exception:
            pass

    def _reapply_dialogs_hook(self):
        self._remove_dialogs_hook()
        self._apply_dialogs_hook()

    def _ensure_header_in_dialogs(self, fragment):
        try:
            if not self.get_setting(SETTINGS_KEY_SHOW_HEADER, True):
                self._remove_header()
                return

            content_view = get_private_field(fragment, "fragmentView") or get_private_field(fragment, "contentView")
            list_view = get_private_field(fragment, "listView")
            if content_view is None or list_view is None:
                return

            if self.header_view_ref and self.header_view_ref.getParent() is not None:
                return

 
            cell = DialogCell(None, content_view.getContext(), True, False, UserConfig.selectedAccount, None)
            custom = DialogCell.CustomDialog()
            custom.name = self._get_channel_name()
            custom.message = self._get_unread_msg(0)
            try:

                pass
            except Exception:
                pass
            cell.setDialog(custom)

            def on_click(_):
                try:
                    self.open_wall_feed()
                except Exception as e:
                    log(f"[{self.id}] open_wall_feed error: {e}")

            cell.setOnClickListener(OnClickListener(on_click))

            # Ð’ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ ÐºÐ¾Ð½Ñ‚ÐµÐ¹Ð½ÐµÑ€Ð°
            try:
                header_height = AndroidUtilities.dp(72)
                parent_view = list_view.getParent()
                if parent_view is not None:
                    # Ð•ÑÐ»Ð¸ ÑÐ¿Ð¸ÑÐ¾Ðº Ð½Ð°Ñ…Ð¾Ð´Ð¸Ñ‚ÑÑ Ð² LinearLayout â€” Ð´Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð¿ÐµÑ€ÐµÐ´ Ð½Ð¸Ð¼ ÐºÐ°Ðº Ð¾Ð±Ñ‹Ñ‡Ð½ÑƒÑŽ ÑÑ‚Ñ€Ð¾ÐºÑƒ
                    from android.widget import LinearLayout as _LL
                    from android.widget import FrameLayout as _FL
                    if isinstance(parent_view, _LL):
                        # ÐÐ°Ð¹Ð´Ñ‘Ð¼ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸ÑŽ list_view
                        insert_index = 0
                        try:
                            count = parent_view.getChildCount()
                            for i in range(count):
                                if parent_view.getChildAt(i) is list_view:
                                    insert_index = i
                                    break
                        except Exception:
                            insert_index = 0
                        parent_view.addView(cell, insert_index, _LL.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height))
                    elif isinstance(parent_view, _FL):
                        # Ð”Ð»Ñ FrameLayout Ð´Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð¾Ð²ÐµÑ€Ð»ÐµÐ¹ ÑÐ²ÐµÑ€Ñ…Ñƒ Ð¸ ÑÐ´Ð²Ð¸Ð½ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð°Ð´Ð´Ð¸Ð½Ð³Ð¾Ð¼
                        lp = _FL.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                        lp.gravity = Gravity.TOP
                        parent_view.addView(cell, lp)
                        try:
                            list_view.setPadding(
                                list_view.getPaddingLeft(),
                                list_view.getPaddingTop() + header_height,
                                list_view.getPaddingRight(),
                                list_view.getPaddingBottom()
                            )
                        except Exception:
                            pass
                    else:
                        # Ð¤Ð¾Ð»Ð±ÑÐº â€” Ð´Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð² content_view ÑÐ²ÐµÑ€Ñ…Ñƒ
                        try:
                            from android.widget import LinearLayout as _LL2
                            if isinstance(content_view, _LL2):
                                content_view.addView(cell, 0, _LL2.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height))
                            else:
                                lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                                lp.gravity = Gravity.TOP
                                content_view.addView(cell, lp)
                                list_view.setPadding(list_view.getPaddingLeft(), list_view.getPaddingTop() + header_height, list_view.getPaddingRight(), list_view.getPaddingBottom())
                        except Exception:
                            pass
                else:
                    # ÐÐµÑ‚ Ñ€Ð¾Ð´Ð¸Ñ‚ÐµÐ»Ñ â€” Ð´Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð² content_view ÐºÐ°Ðº Ð¾Ð²ÐµÑ€Ð»ÐµÐ¹
                    lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                    lp.gravity = Gravity.TOP
                    content_view.addView(cell, lp)
                    try:
                        list_view.setPadding(list_view.getPaddingLeft(), list_view.getPaddingTop() + header_height, list_view.getPaddingRight(), list_view.getPaddingBottom())
                    except Exception:
                        pass
            except Exception as e:
                log(f"[{self.id}] header insert error: {e}")

            self.header_view_ref = cell
            self._update_unread_counter(None)

        except Exception as e:
            log(f"[{self.id}] ensure_header error: {e}")

    def _remove_header(self):
        try:
            if self.header_view_ref and self.header_view_ref.getParent() is not None:
                parent = self.header_view_ref.getParent()
                parent.removeView(self.header_view_ref)
            self.header_view_ref = None
        except Exception:
            pass

    def _sync_messages_background(self):
        try:
            # Initial sync: from yesterday to now
            now = int(time.time())
            start_ts = now - 24 * 60 * 60
            # Show lightweight floating overlay (like chikiexport)
            self._create_progress_overlay("Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¿Ð¾ÑÑ‚Ð¾Ð²â€¦", 0.05)
            self._sync_in_progress = True
            self._perform_sync_range(start_ts, now)
            self._sync_in_progress = False
            self._dismiss_progress_overlay()

            # Periodic sync every 1 minute until plugin unload
            def loop_sync():
                while not self._stop_sync:
                    try:
                        if getattr(self, '_sync_in_progress', False):
                            time.sleep(1)
                            continue
                        self._sync_in_progress = True
                        last_sync = self._get_last_sync_time()
                        now2 = int(time.time())
                        # sync new posts since last sync
                        self._perform_sync_range(last_sync or (now2 - 2 * 24 * 60 * 60), now2)
                    except Exception as e:
                        log(f"[{self.id}] periodic sync error: {e}")
                    # sleep 1 minute
                    for _ in range(1):
                        if self._stop_sync:
                            break
                        time.sleep(240)
                    self._sync_in_progress = False
            self._sync_thread = threading.Thread(target=loop_sync, daemon=True)
            self._sync_thread.start()
        except Exception as e:
            log(f"[{self.id}] sync error: {e}")

    def _perform_sync_range(self, start_ts: int, end_ts: int):
        try:
            self._create_progress_overlay(f"ðŸ” {self._get_locale_text('sync_section')}...", 0.05)
        except Exception:
            pass
        
        dialogs = self._get_channel_dialog_ids()
        log(f"[{self.id}] sync: scanning channels, found {len(dialogs)}")
        
        try:
            self._update_progress_overlay(f"ðŸ“‚ ÐšÐ°Ð½Ð°Ð»Ð¾Ð²: {len(dialogs)}")
        except Exception:
            pass
        
        max_posts = self._get_max_posts()
        msgs = self._load_channels_messages_from_db(dialogs, per_dialog_limit=max_posts, start_ts=start_ts, end_ts=end_ts)
        log(f"[{self.id}] sync: loaded {len(msgs)} posts from DB")
        
        try:
            self._update_progress_overlay(f"ðŸ“¥ Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾: {len(msgs)} Ð¿Ð¾ÑÑ‚Ð¾Ð²")
        except Exception:
            pass

        msgs.sort(key=lambda t: t[2])
        self.messages_cache = msgs

        try:
            self._update_progress_overlay(f"ðŸ’¾ Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð¿Ð¾ÑÑ‚Ð¾Ð²...")
            self._write_messages_to_wall(msgs)
        except Exception as e:
            log(f"[{self.id}] write-to-wall error: {e}")

        last_read = self._get_last_read_date()
        self.unread_count = sum(1 for _, _, d in msgs if d > last_read)
        self.unread_divider_index = -1
        if last_read > 0:
            for i, (_, _, d) in enumerate(msgs):
                if d > last_read:
                    self.unread_divider_index = i
                    break
        self._set_last_sync_time(int(time.time()))
        # Update dialog unread count in MessagesController
        try:
            mc = get_messages_controller()
            d = mc.dialogs_dict.get(self.WALL_DIALOG_ID)
            if d is None:
                d = TLRPC.TL_dialog()
                d.id = self.WALL_DIALOG_ID
            d.unread_count = int(self.unread_count)
            mc.dialogs_dict.put(self.WALL_DIALOG_ID, d)
        except Exception:
            pass
        
        # Dismiss progress overlay
        try:
            self._dismiss_progress_overlay()
        except Exception:
            pass

    def _write_messages_to_wall(self, msgs: List[Tuple[int, TLRPC.Message, int]]):
        try:
            if not msgs:
                return
            last_written = 0
            try:
                val = self._sql_kv_get("meta:last_write_date")
                if val is not None and str(val).strip().isdigit():
                    last_written = int(str(val).strip())
            except Exception:
                pass
            log(f"[{self.id}] write_messages_to_wall: processing {len(msgs)} messages, last_written={last_written}")
            log(f"[{self.id}] _ignore_keys size: {len(getattr(self, '_ignore_keys', {}))}")
            arr = JArrayList()
            skipped_count = 0
            skipped_by_ignore = 0
            seen_keys = set()
            for did, tl_msg, _ in msgs:
                try:
                    # Skip already written by ignore and date cutoff
                    orig_peer0 = getattr(tl_msg, 'peer_id', None)
                    orig_ch_id0 = None
                    if orig_peer0 and hasattr(orig_peer0, 'channel_id') and orig_peer0.channel_id:
                        orig_ch_id0 = int(orig_peer0.channel_id)
                    key = f"{orig_ch_id0 or did}:{tl_msg.id}"
                    if key in seen_keys:
                        skipped_count += 1
                        continue
                    seen_keys.add(key)
                    if getattr(self, '_ignore_keys', {}).get(key):
                        skipped_by_ignore += 1
                        skipped_count += 1
                        continue
                    # Redirect message to wall chat
                    old_peer = getattr(tl_msg, 'peer_id', None)
                    tl_msg.dialog_id = self.WALL_DIALOG_ID
                    peer = TLRPC.TL_peerChannel()
                    peer.channel_id = self.WALL_CHAT_ID
                    tl_msg.peer_id = peer
                    tl_msg.out = True
                    # Add forward header with original channel info
                    ch_id = None
                    if old_peer and hasattr(old_peer, 'channel_id') and old_peer.channel_id:
                        ch_id = int(old_peer.channel_id)
                    if ch_id:
                        try:
                            fwd = TLRPC.TL_messageFwdHeader()
                            fwd.channel_id = ch_id
                            fwd.date = tl_msg.date
                            chat = get_messages_controller().getChat(ch_id)
                            if chat and hasattr(chat, 'title'):
                                fwd.from_name = chat.title
                            # also set from_id for avatar resolution
                            try:
                                fpeer = TLRPC.TL_peerChannel()
                                fpeer.channel_id = ch_id
                                fwd.from_id = fpeer
                            except Exception:
                                pass
                            tl_msg.fwd_from = fwd
                        except Exception:
                            pass
                    # assign synthetic id and remember mapping + ignore
                    synth_id = getattr(self, '_last_synth_id', 0) + 1
                    self._last_synth_id = synth_id
                    try:
                        tl_msg.id = int(synth_id)
                    except Exception:
                        pass
                    if key:
                        self._id_map[key] = int(synth_id)
                        self._ignore_keys[key] = True
                except Exception:
                    pass
                arr.add(tl_msg)
            storage = get_messages_storage()
            # Use MessagesController-style variant to ensure dialog creation and proper indexing
            # putMessages(messages, dialogId, load_type, max_id, createDialog, mode, threadMessageId)
            to_write = arr.size()
            log(f"[{self.id}] write_messages_to_wall: skipped {skipped_count} (by_ignore={skipped_by_ignore}), writing {to_write} messages")
            if to_write > 0:
                try:
                    messagesRes = jclass('org.telegram.tgnet.TLRPC$TL_messages_messages')()
                    messagesRes.messages = arr
                    messagesRes.users = JArrayList()
                    messagesRes.chats = JArrayList()
                    storage.putMessages(messagesRes, self.WALL_DIALOG_ID, -1, 0, True, ChatActivity.MODE_SAVED, 0)
                except Exception:
                    # Fallback to simple put
                    storage.putMessages(arr, False, True, False, 0, False, 0, 0)
                log(f"[{self.id}] wrote {to_write} messages to wall storage")
            # Persist last write max date
            try:
                max_date = 0
                for _, tl_msg2, _ in msgs:
                    if tl_msg2.date > max_date:
                        max_date = tl_msg2.date
                if max_date:
                    self._sql_kv_set("meta:last_write_date", int(max_date))
            except Exception:
                pass
            # persist ignore/id maps and last synth id
            try:
                self._save_ignore_and_idmap_to_sql()
                self._sql_kv_set("meta:last_synth_id", int(getattr(self, '_last_synth_id', 0)))
            except Exception:
                pass
            # Notify UI to refresh dialogs
            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.dialogsNeedReload)
            except Exception:
                pass
        except Exception as e:
            log(f"[{self.id}] _write_messages_to_wall error: {e}")

    # --- Hook ChatActivity to set saved mode for wall and update last_read on exit ---
    def _apply_chat_activity_hooks(self):
        try:
            CA = find_class("org.telegram.ui.ChatActivity")
            ContextClass = find_class("android.content.Context")
            createView = CA.getClass().getDeclaredMethod("createView", ContextClass)
            createView.setAccessible(True)
            self.hook_method(createView, _ChatActivityCreateHook(self))

            onPause = CA.getClass().getDeclaredMethod("onPause")
            onPause.setAccessible(True)
            self.hook_method(onPause, _ChatActivityPauseHook(self))
        except Exception as e:
            log(f"[{self.id}] chat hooks error: {e}")

    def _get_channel_dialog_ids(self) -> List[int]:
        res = []
        try:
            mc = get_messages_controller()
            dialogs = mc.getDialogs(0)
            acc = UserConfig.selectedAccount
            ban = set(self._get_ban_list())
            # Convert to Python list to avoid index issues
            if hasattr(dialogs, 'toArray'):
                arr = list(dialogs.toArray())
            else:
                # Fallback: try iterating with get(i) safely
                arr = []
                try:
                    size = dialogs.size()
                    for i in range(size):
                        try:
                            arr.append(dialogs.get(i))
                        except Exception:
                            break
                except Exception:
                    arr = []
            for d in arr:
                try:
                    if isinstance(d, TLRPC.TL_dialog):
                        did = d.id
                        # Exclude wall itself and include only broadcast channels (exclude megagroups)
                        if did == self.WALL_DIALOG_ID:
                            continue
                        if ChatObject.isChannelAndNotMegaGroup(-did, acc):
                            ch_id = -int(did)
                            if ch_id in ban:
                                continue
                            res.append(did)
                except Exception:
                    continue
        except Exception as e:
            log(f"[{self.id}] get channel dialogs error: {e}")
        return res

    def _load_channels_messages_from_db(self, dialog_ids: List[int], per_dialog_limit: int = 300, start_ts: Optional[int] = None, end_ts: Optional[int] = None) -> List[Tuple[int, TLRPC.Message, int]]:
        agg: List[Tuple[int, TLRPC.Message, int]] = []
        try:
            storage = get_messages_storage()
            database = get_private_field(storage, "database")
            if not database:
                return []
            for did in dialog_ids:
                try:
                    # Backoff: skip frequent empty channels
                    now_ts = int(time.time())
                    next_ok = int(self._db_backoff.get(did, 0) or 0)
                    if next_ok and now_ts < next_ok:
                        continue
                    # Primary query (as in chikiexport): by uid (dialog id)
                    q = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {did} ORDER BY date DESC LIMIT {per_dialog_limit}"
                    cursor = database.queryFinalized(q)
                    loaded_for_did = 0
                    while cursor.next():
                        data = cursor.byteBufferValue(0)
                        if data:
                            msg = TLRPC.Message.TLdeserialize(data, data.readInt32(False), False)
                            if msg:
                                msg.id = cursor.intValue(1)
                                msg.date = cursor.intValue(2)
                                msg.dialog_id = cursor.longValue(3)
                                # Ensure message belongs to a channel (exclude user/group)
                                peer = getattr(msg, 'peer_id', None)
                                if not (peer and hasattr(peer, 'channel_id') and peer.channel_id):
                                    data.reuse()
                                    continue
                                # Apply time window filter in Python to avoid missing data due to DB schema differences
                                if start_ts and end_ts:
                                    if msg.date < start_ts or msg.date > end_ts:
                                        data.reuse()
                                        continue
                                agg.append((did, msg, msg.date))
                                loaded_for_did += 1
                            data.reuse()
                    # Fallback: some builds store uid with opposite sign; try positive channel id if nothing loaded
                    if loaded_for_did == 0:
                        try:
                            fallback_uid = -did
                            q2 = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {fallback_uid} ORDER BY date DESC LIMIT {per_dialog_limit}"
                            cursor2 = database.queryFinalized(q2)
                            while cursor2.next():
                                data2 = cursor2.byteBufferValue(0)
                                if data2:
                                    msg2 = TLRPC.Message.TLdeserialize(data2, data2.readInt32(False), False)
                                    if msg2:
                                        peer2 = getattr(msg2, 'peer_id', None)
                                        if not (peer2 and hasattr(peer2, 'channel_id') and peer2.channel_id):
                                            data2.reuse()
                                            continue
                                        if start_ts and end_ts and (msg2.date < start_ts or msg2.date > end_ts):
                                            data2.reuse()
                                            continue
                                        msg2.id = cursor2.intValue(1)
                                        msg2.date = cursor2.intValue(2)
                                        msg2.dialog_id = cursor2.longValue(3)
                                        agg.append((did, msg2, msg2.date))
                                        loaded_for_did += 1
                                data2.reuse()
                            if loaded_for_did == 0:
                                # Exponential backoff on empty result
                                empty = int(self._db_empty_count.get(did, 0) or 0) + 1
                                self._db_empty_count[did] = empty
                                delay = min(3600, 15 * (2 ** (empty - 1)))
                                self._db_backoff[did] = int(time.time()) + delay
                        except Exception:
                            pass
                    try:
                        if loaded_for_did > 0:
                            self._db_empty_count[did] = 0
                            self._db_backoff[did] = 0
                    except Exception:
                        pass
                except Exception as e:
                    log(f"[{self.id}] DB read error for {did}: {e}")
        except Exception as e:
            log(f"[{self.id}] DB access error: {e}")
        return agg

    def open_wall_feed(self):
        try:
            fragment = get_last_fragment()
            if fragment is None:
                return
            try:
                chat = ChatActivity.of(self.WALL_DIALOG_ID)
            except Exception:
                from android.os import Bundle
                b = Bundle()
                b.putLong("dialog_id", int(self.WALL_DIALOG_ID))
                chat = ChatActivity(b)
            fragment.presentFragment(chat)
        except Exception as e:
            log(f"[{self.id}] open_wall_feed error: {e}")

    def _remove_overlay(self):
        try:
            # ÐŸÐ¾Ð¼ÐµÑ‡Ð°ÐµÐ¼ ÐºÐ°Ðº Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ð¾Ðµ Ð´Ð¾ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ³Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ
            try:
                if self.messages_cache:
                    last_date = self.messages_cache[-1][2]
                    if last_date and last_date > 0:
                        self._set_last_read_date(last_date)
            except Exception:
                pass
            if self.overlay_container and self.overlay_container.getParent() is not None:
                parent = self.overlay_container.getParent()
                parent.removeView(self.overlay_container)
            self.overlay_container = None
        except Exception:
            pass

    def _build_unread_divider(self, ctx) -> View:
        row = LinearLayout(ctx)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER)
        row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
        tv = TextView(ctx)
        tv.setText("ÐÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ")
        tv.setTextColor(Color.LTGRAY)
        tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 13)
        row.addView(tv, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        return row

    def _build_feed_item(self, ctx, account: int, dialog_id: int, msg: TLRPC.Message) -> View:
        container = LinearLayout(ctx)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))

        header = LinearLayout(ctx)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER_VERTICAL)

        avatar = BackupImageView(ctx)
        ava_draw = AvatarDrawable()
        name = "ÐšÐ°Ð½Ð°Ð»"
        try:
            peer = getattr(msg, 'peer_id', None)
            if peer and hasattr(peer, 'channel_id') and peer.channel_id:
                cid = peer.channel_id
                # Use cache for faster lookup
                chat = self._get_chat_cached(cid)
                if chat:
                    if hasattr(chat, 'title'):
                        name = chat.title
                    try:
                        avatar.setForUserOrChat(chat, ava_draw)
                    except Exception:
                        ava_draw.setInfo(chat)
                else:
                    ava_draw.setInfo(0, name, None)
            else:
                ava_draw.setInfo(0, name, None)
        except Exception as e:
            log(f"[{self.id}] Error building feed item header: {e}")
            ava_draw.setInfo(0, name, None)
        try:
            # Fallback if image not resolved
            if getattr(avatar, 'getImageReceiver', None) and avatar.getImageReceiver() is None:
                avatar.setImageDrawable(ava_draw)
        except Exception:
            pass
        header.addView(avatar, LinearLayout.LayoutParams(AndroidUtilities.dp(36), AndroidUtilities.dp(36)))

        title = TextView(ctx)
        title.setText(name)
        title.setTextColor(Color.WHITE)
        title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
        p = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        p.leftMargin = AndroidUtilities.dp(8)
        header.addView(title, p)

        container.addView(header, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        try:
            cell = ChatMessageCell(ctx, account)
            mo = MessageObject(account, msg, False, False)
            cell.setMessageObject(mo, None, False, False, False)
            container.addView(cell, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        except Exception as e:
            fallback = TextView(ctx)
            try:
                text = getattr(msg, 'message', '') or "(Ð¼ÐµÐ´Ð¸Ð°)"
            except Exception:
                text = "(ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ)"
            fallback.setText(text)
            fallback.setTextColor(Color.WHITE)
            fallback.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
            fallback.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(6), AndroidUtilities.dp(8), AndroidUtilities.dp(6))
            container.addView(fallback, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        return container

    def _update_unread_counter(self, tv: TextView):
        try:
            count = self.unread_count
            # ÐžÐ±Ð½Ð¾Ð²Ð¸Ð¼ Ð¿Ð¾Ð´Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð´Ð¸Ð°Ð»Ð¾Ð³Ð°
            if isinstance(self.header_view_ref, DialogCell):
                custom = DialogCell.CustomDialog()
                custom.name = self._get_channel_name()
                custom.message = self._get_unread_msg(count)
                self.header_view_ref.setDialog(custom)
            elif tv is not None:
                tv.setText(self._get_unread_msg(count))
        except Exception:
            pass

    def _get_last_read_date(self) -> int:
        try:
            val = self._sql_kv_get("meta:last_read_date")
            if val is not None and str(val).strip().isdigit():
                return int(str(val).strip())
        except Exception:
            pass
        return 0

    def _set_last_read_date(self, ts: int):
        try:
            self._sql_kv_set("meta:last_read_date", int(ts))
        except Exception:
            pass

    def _get_last_sync_time(self) -> int:
        try:
            return self._sql_kv_get_int("meta:last_sync", 0)
        except Exception:
            pass
        return 0

    def _set_last_sync_time(self, ts: int):
        try:
            self._sql_kv_set("meta:last_sync", int(ts))
        except Exception:
            pass

    # --- Ban list helpers ---
    def _get_ban_list_csv(self) -> str:
        try:
            if Mandre:
                v = self.get_setting(SETTINGS_KEY_BAN_LIST, "") or ""
                return str(v)
        except Exception:
            pass
        return ""

    def _set_ban_list_csv(self, csv: str):
        try:
            self.set_setting(SETTINGS_KEY_BAN_LIST, csv or "")
        except Exception:
            pass

    def _get_ban_list(self) -> List[int]:
        try:
            csv = self._get_ban_list_csv()
            ids = []
            for part in str(csv).replace(";", ",").split(","):
                p = part.strip()
                if not p:
                    continue
                try:
                    ids.append(int(p))
                except Exception:
                    continue
            return ids
        except Exception:
            return []

    # --- Progress dialog helpers ---
    def _show_progress_dialog(self, message: str):
        try:
            from ui.alert import AlertDialogBuilder
            last_fragment = get_last_fragment()
            if not last_fragment:
                return
            def show():
                try:
                    builder = AlertDialogBuilder(last_fragment.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_LOADING)
                    builder.set_title(message)
                    builder.set_cancelable(False)
                    self.progress_dialog = builder
                    self.progress_dialog.show()
                except Exception:
                    pass
            run_on_ui_thread(show)
        except Exception:
            pass

    def _dismiss_progress_dialog(self):
        try:
            def dism():
                try:
                    if self.progress_dialog:
                        self.progress_dialog.dismiss()
                        self.progress_dialog = None
                except Exception:
                    pass
            run_on_ui_thread(dism)
        except Exception:
            pass

    # Floating overlay similar to chikiexport
    def _create_progress_overlay(self, text: str, progress: float = 0.0):
        try:
            from org.telegram.ui.ActionBar import Theme
            from android.content.res import ColorStateList
            from android.graphics.drawable import RippleDrawable
            fragment = get_last_fragment()
            if not fragment:
                return
            context = fragment.getParentActivity()
            if not context:
                return
            content_view_id = 0x01020002
            root_view = context.getWindow().getDecorView()
            container = root_view.findViewById(content_view_id) or root_view
            if not container:
                return
            if self.progress_overlay_container:
                try:
                    parent = self.progress_overlay_container.getParent()
                    if parent:
                        parent.removeView(self.progress_overlay_container)
                except Exception:
                    pass
            self.progress_overlay_container = FrameLayout(context)
            try:
                self.progress_overlay_container.setClickable(False)
                self.progress_overlay_container.setFocusable(False)
            except Exception:
                pass
            # Build chip
            chip = LinearLayout(context)
            chip.setOrientation(LinearLayout.HORIZONTAL)
            chip.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(22))
            try:
                from org.telegram.ui.ActionBar import Theme as _Theme
                bg.setColor(_Theme.getColor(_Theme.key_undo_background))
                textColor = _Theme.getColor(_Theme.key_undo_infoColor)
            except Exception:
                bg.setColor(Color.parseColor("#2B2B2B"))
                textColor = Color.WHITE
            chip.setBackground(bg)
            # spinner
            try:
                from org.telegram.ui.Components import RadialProgressView
                spinner = RadialProgressView(context)
                spinner.setProgressColor(textColor)
                spinner.setSize(AndroidUtilities.dp(20))
                chip.addView(spinner, LinearLayout.LayoutParams(AndroidUtilities.dp(20), AndroidUtilities.dp(20)))
            except Exception:
                spinner = None
            # text
            tv = TextView(context)
            tv.setTextColor(textColor)
            tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
            p = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            p.leftMargin = AndroidUtilities.dp(8)
            tv.setText(text)
            chip.addView(tv, p)
            # Non-interactive
            try:
                chip.setClickable(False)
                chip.setFocusable(False)
            except Exception:
                pass
            # assemble
            params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
            params.topMargin = AndroidUtilities.dp(80)
            self.progress_overlay_container.addView(chip, params)
            container.addView(self.progress_overlay_container, FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
            self.progress_overlay = chip
        except Exception:
            pass

    def _update_progress_overlay(self, text: str):
        try:
            if self.progress_overlay_container and self.progress_overlay:
                # Find and update TextView in the chip
                for i in range(self.progress_overlay.getChildCount()):
                    child = self.progress_overlay.getChildAt(i)
                    if isinstance(child, TextView):
                        child.setText(text)
                        break
        except Exception:
            pass

    def _dismiss_progress_overlay(self):
        try:
            if self.progress_overlay_container:
                parent = self.progress_overlay_container.getParent()
                if parent:
                    parent.removeView(self.progress_overlay_container)
            self.progress_overlay_container = None
            self.progress_overlay = None
        except Exception:
            pass

    # --- Synthetic ID generator ---
    def _next_synth_id(self) -> int:
        try:
            self._last_synth_id = int(self._last_synth_id) + 1
            return self._last_synth_id
        except Exception:
            self._last_synth_id = 1
            return 1

    # --- Chat cache methods for faster lookups ---
    def _get_chat_cached(self, channel_id: int) -> Optional[Any]:
        try:
            now = time.time()
            # Cache TTL: 5 minutes
            if channel_id in self._chat_cache:
                if now - self._chat_cache_timestamp.get(channel_id, 0) < 300:
                    return self._chat_cache[channel_id]
            # Fetch from MessagesController
            mc = get_messages_controller()
            chat = mc.getChat(channel_id)
            if chat:
                self._chat_cache[channel_id] = chat
                self._chat_cache_timestamp[channel_id] = now
            else:
                pass
            return chat
        except Exception as e:
            log(f"[{self.id}] Cache error for channel {channel_id}: {e}")
            return None

    def _clear_chat_cache(self):
        """Clear chat cache (useful on plugin reload)"""
        try:
            self._chat_cache.clear()
            self._chat_cache_timestamp.clear()
        except Exception:
            pass

    # --- SQL KV helpers ---
    def _get_database(self):
        return Mandre.sql_get_database()

    def _sql_init_storage(self):
        Mandre.sql_init_kv(self.id, "wallfeed_kv")

    def _sql_kv_set(self, key: str, value: Any):
        Mandre.sql_kv_set(self.id, key, value, "wallfeed_kv")

    def _sql_kv_get(self, key: str) -> Optional[str]:
        return Mandre.sql_kv_get(self.id, key, "wallfeed_kv")

    def _sql_kv_get_int(self, key: str, default: int = 0) -> int:
        return Mandre.sql_kv_get_int(self.id, key, default, "wallfeed_kv")

    def _sql_kv_delete_prefix(self, prefix: str):
        Mandre.sql_kv_delete_prefix(self.id, prefix, "wallfeed_kv")

    def _load_ignore_and_idmap_from_sql(self):
        try:
            db = self._get_database()
            self._ignore_keys = {}
            self._id_map = {}
            if not db:
                return
            cursor = db.queryFinalized(f"SELECT k, v FROM wallfeed_kv WHERE plugin = '{self.id}' AND (k LIKE 'ignore:%' OR k LIKE 'idmap:%')")
            try:
                while cursor.next():
                    try:
                        k = cursor.stringValue(0)
                    except Exception:
                        k = None
                    try:
                        v = cursor.stringValue(1)
                    except Exception:
                        try:
                            v = str(cursor.intValue(1))
                        except Exception:
                            v = None
                    if not k:
                        continue
                    if k.startswith("ignore:"):
                        orig_key = k[len("ignore:"):]
                        if orig_key:
                            self._ignore_keys[orig_key] = True
                    elif k.startswith("idmap:"):
                        orig_key = k[len("idmap:"):]
                        if orig_key:
                            try:
                                self._id_map[orig_key] = int(v) if v is not None else 0
                            except Exception:
                                pass
            finally:
                try:
                    cursor.dispose()
                except Exception:
                    pass
        except Exception:
            pass

    def _save_ignore_and_idmap_to_sql(self):
        try:
            for k in getattr(self, '_ignore_keys', {}).keys():
                self._sql_kv_set(f"ignore:{k}", 1)
            for k, v in getattr(self, '_id_map', {}).items():
                self._sql_kv_set(f"idmap:{k}", int(v))
        except Exception:
            pass

    def _migrate_json_to_sql_once(self):
        try:
            self._sql_init_storage()
            # If there are already records, skip migration
            db = self._get_database()
            if not db:
                return
            has_rows = False
            try:
                c = db.queryFinalized(f"SELECT COUNT(1) FROM wallfeed_kv WHERE plugin = '{self.id}' LIMIT 1")
                if c.next():
                    has_rows = c.intValue(0) > 0
                try:
                    c.dispose()
                except Exception:
                    pass
            except Exception:
                pass
            if has_rows:
                return
            # Import existing JSON state if available
            try:
                if Mandre:
                    ignore = None
                    idmap = None
                    last_synth = None
                    last_read = None
                    last_sync = None
                    last_write = None
                    try:
                        ignore = Mandre.Data.read_persistent_json(self.id, PERSIST_FILE_IGNORE, {}) or {}
                        idmap = Mandre.Data.read_persistent_json(self.id, PERSIST_FILE_IDMAP, {}) or {}
                    except Exception:
                        ignore = {}
                        idmap = {}
                    try:
                        last_synth = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_SYNTH_ID)
                    except Exception:
                        last_synth = None
                    try:
                        last_read = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_READ_DATE)
                    except Exception:
                        last_read = None
                    try:
                        last_sync = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_SYNC)
                    except Exception:
                        last_sync = None
                    try:
                        last_write = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_WRITE_DATE)
                    except Exception:
                        last_write = None
                    # Persist to SQL
                    try:
                        for k in (ignore or {}).keys():
                            self._sql_kv_set(f"ignore:{k}", 1)
                        for k, v in (idmap or {}).items():
                            try:
                                self._sql_kv_set(f"idmap:{k}", int(v))
                            except Exception:
                                pass
                        if last_synth is not None:
                            try:
                                self._sql_kv_set("meta:last_synth_id", int(last_synth) if str(last_synth).isdigit() else str(last_synth))
                            except Exception:
                                pass
                        if last_read is not None:
                            try:
                                self._sql_kv_set("meta:last_read_date", int(last_read) if str(last_read).isdigit() else str(last_read))
                            except Exception:
                                pass
                        if last_sync is not None:
                            try:
                                self._sql_kv_set("meta:last_sync", int(last_sync) if str(last_sync).isdigit() else str(last_sync))
                            except Exception:
                                pass
                        if last_write is not None:
                            try:
                                self._sql_kv_set("meta:last_write_date", int(last_write) if str(last_write).isdigit() else str(last_write))
                            except Exception:
                                pass
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass

    # --- Settings for max posts ---
    def _get_max_posts(self) -> int:
        """Get max posts per channel from settings"""
        try:
            val = self.get_setting(SETTINGS_KEY_MAX_POSTS, "500")
            if isinstance(val, str):
                val = val.strip()
                if val.isdigit():
                    return max(10, min(int(val), 5000))  # Clamp between 10 and 5000
            elif isinstance(val, int):
                return max(10, min(val, 5000))
        except Exception:
            pass
        return 500

    def _set_max_posts(self, val: str):
        """Set max posts per channel"""
        try:
            if isinstance(val, str):
                val = val.strip()
                if val.isdigit():
                    num = max(10, min(int(val), 5000))
                    self.set_setting(SETTINGS_KEY_MAX_POSTS, str(num))
                    log(f"[{self.id}] max_posts set to {num}")
        except Exception as e:
            log(f"[{self.id}] _set_max_posts error: {e}")


class _DialogsCreateViewHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        frag = param.thisObject
        try:
            self.plugin._ensure_header_in_dialogs(frag)
        except Exception as e:
            log(f"[wall_feed] after createView error: {e}")


class _DialogsOnResumeHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        frag = param.thisObject
        try:
            # Only ensure header; background sync runs on its own schedule
            self.plugin._ensure_header_in_dialogs(frag)
        except Exception as e:
            log(f"[wall_feed] after onResume error: {e}")


class _GetDialogsArrayHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            res = param.getResult()
            if res is None:
                return
            # res is java.util.ArrayList
            # Inject synthetic dialog at position 0 if not present
            try:
                # Only inject for main folder (folderId == 0)
                folderId = param.args[2]
                if folderId != 0:
                    return
                size = res.size()
                exists = False
                for i in range(size):
                    d = res.get(i)
                    if hasattr(d, 'id') and d.id == self.plugin.WALL_DIALOG_ID:
                        exists = True
                        break
                if not exists:
                    d = TLRPC.TL_dialog()
                    d.id = self.plugin.WALL_DIALOG_ID
                    d.peer = TLRPC.TL_peerChannel()
                    d.peer.channel_id = self.plugin.WALL_CHAT_ID
                    d.pinned = False
                    res.add(0, d)
                    param.setResult(res)
            except Exception as e:
                log(f"[{self.plugin.id}] inject dialog error: {e}")
        except Exception as e:
            log(f"[{self.plugin.id}] getDialogsArray hook error: {e}")


class _DialogsOnBindHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            adapter = param.thisObject  # org.telegram.ui.Adapters.DialogsAdapter
            holder = param.args[0]
            pos = param.args[1]
            itemView = holder.itemView
            # Only modify our synthetic dialog item
            try:
                getItem = adapter.getClass().getDeclaredMethod("getItem", jclass('java.lang.Integer').TYPE)
                getItem.setAccessible(True)
                item = getItem.invoke(adapter, jclass('java.lang.Integer').valueOf(pos))
            except Exception:
                item = None

            try:
                if item is not None and isinstance(item, TLRPC.Dialog) and getattr(item, 'id', 0) == self.plugin.WALL_DIALOG_ID:
                    if isinstance(itemView, DialogCell):
                        # Build custom dialog with proper avatar and title
                        custom = DialogCell.CustomDialog()
                        custom.name = self.plugin._get_channel_name()
                        custom.message = self.plugin._get_unread_msg(self.plugin.unread_count)
                        itemView.setDialog(custom)
                        try:
                            # Ensure MessagesController has chat with proper title
                            mc = get_messages_controller()
                            chat = mc.getChat(self.plugin.WALL_CHAT_ID)
                            if chat is None:
                                chat = TLRPC.TL_chat()
                                chat.id = self.plugin.WALL_CHAT_ID
                                chat.title = self.plugin._get_channel_name()
                                mc.putChat(chat, True)
                        except Exception:
                            pass

                        def on_click(_):
                            try:
                                self.plugin.open_wall_feed()
                            except Exception as e:
                                log(f"[{self.plugin.id}] open_wall_feed error: {e}")
                        itemView.setOnClickListener(OnClickListener(on_click))
            except Exception:
                pass
        except Exception as e:
            log(f"[{self.plugin.id}] onBind hook error: {e}")


class _GetDialogsHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            res = param.getResult()
            if res is None:
                return
            try:
                # Ensure dialogs list contains our dialog
                size = res.size()
                exists = False
                for i in range(size):
                    d = res.get(i)
                    if hasattr(d, 'id') and d.id == self.plugin.WALL_DIALOG_ID:
                        exists = True
                        break
                if not exists:
                    d = TLRPC.TL_dialog()
                    d.id = self.plugin.WALL_DIALOG_ID
                    d.peer = TLRPC.TL_peerChat()
                    d.peer.chat_id = self.plugin.WALL_CHAT_ID
                    d.pinned = True
                    res.add(0, d)
                    param.setResult(res)
            except Exception as e:
                log(f"[{self.plugin.id}] ensure MC.getDialogs wall: {e}")
        except Exception as e:
            log(f"[{self.plugin.id}] MC.getDialogs hook error: {e}")


class _ChatActivityCreateHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_act = param.thisObject
            did = 0
            try:
                did = get_private_field(chat_act, "dialog_id")
            except Exception:
                pass
            if did == self.plugin.WALL_DIALOG_ID:
                # Set saved-mode UI flags so avatars/titles render like saved forward view
                try:
                    set_private_field(chat_act, "mode", ChatActivity.MODE_SAVED)
                except Exception:
                    pass
                # Scroll to first unread based on last_read_date
                try:
                    last_read = self.plugin._get_last_read_date()
                    target_id = 0
                    for did2, msg, date in self.plugin.messages_cache:
                        if date > last_read:
                            orig_peer = getattr(msg, 'peer_id', None)
                            ch_id = None
                            if orig_peer and hasattr(orig_peer, 'channel_id') and orig_peer.channel_id:
                                ch_id = int(orig_peer.channel_id)
                            key = f"{ch_id or did2}:{msg.id}"
                            sid = self.plugin._id_map.get(key)
                            if sid:
                                target_id = int(sid)
                            break
                    if target_id:
                        try:
                            scrollToMessageId = chat_act.getClass().getDeclaredMethod(
                                "scrollToMessageId",
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Boolean').TYPE,
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Boolean').TYPE,
                                jclass('java.lang.Integer').TYPE
                            )
                            scrollToMessageId.setAccessible(True)
                            scrollToMessageId.invoke(chat_act,
                                jclass('java.lang.Integer').valueOf(target_id),
                                jclass('java.lang.Integer').valueOf(0),
                                jclass('java.lang.Boolean').valueOf(True),
                                jclass('java.lang.Integer').valueOf(0),
                                jclass('java.lang.Boolean').valueOf(True),
                                jclass('java.lang.Integer').valueOf(0)
                            )
                        except Exception:
                            pass
                except Exception:
                    pass
        except Exception as e:
            log(f"[{self.plugin.id}] ChatActivity createView hook error: {e}")

class _ChatActivityPauseHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_act = param.thisObject
            did = 0
            try:
                did = get_private_field(chat_act, "dialog_id")
            except Exception:
                pass
            if did == self.plugin.WALL_DIALOG_ID:
                # On leaving wall, mark last_read_date to max written date
                try:
                    storage_last = Mandre.Data.read_persistent(self.plugin.id, STORAGE_KEY_LAST_WRITE_DATE)
                    if isinstance(storage_last, int) and storage_last:
                        self.plugin._set_last_read_date(storage_last)
                except Exception:
                    pass
        except Exception as e:
            log(f"[{self.plugin.id}] ChatActivity onPause hook error: {e}")
