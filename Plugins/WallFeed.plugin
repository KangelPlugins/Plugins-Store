"""
                            –î–ò–°–ö–õ–ï–ô–ú–ï–†

–ö–æ—Ä–æ—á–µ , –µ—Å–ª–∏ —Ç–µ–±–µ –Ω—É–∂–µ–Ω –∫—É—Å–æ–∫ –∫–æ–¥–∞ –∏–∑ —ç—Ç–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ , —Ç–æ –ø–∂
—É–∫–∞–∑—ã–≤–∞–π –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ –∏–ª–∏ –≥–¥–µ-—Ç–æ –µ—â–µ , —á—Ç–æ –≤–∑—è–ª –∫–æ–¥ —Å @KangelPlugins –∏ @Swagnonher
                              –°–ø–∞—Å–∏–±–æ
                        üôè –ë–õ–ê–ì–û–°–õ–ê–í–õ–ï–ù–ò–ï üôè

‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚°§‚†§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚°§‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚†â‚¢Ä‚£§‚†∂‚†Æ‚†∑‚£§‚£Ä‚°Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°º‚†ã‚†à‚£Ω‚£Ü‚†π‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†∂‚†∂‚†∂‚†∂‚£Ñ‚†Ä‚†Ä‚†Ä‚£û‚£Å‚£†‚†¥‚†Ø‚†∞‚†∂‚†∂‚†∂‚£æ‚†Å‚†ô‚£Ø‚£≥‚£•‚†û‚¢π‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°æ‚†Ä‚¢†‚°æ‚†Å‚¢π‚†Ä‚¢ª‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†è‚†Ä‚£ä‚£Ä‚£ê‚£Ä‚°à‚¢ì‚£¶‚°ñ‚†ã‚†Å‚†Ä‚°∞‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚£π‚¢†‚£Ñ‚£Ω‚†¨‚£æ‚†â‚¢π‚†≥‚°Ñ‚†Ä‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚¢∏‚†Ä‚¢Ä‚°º‚°á‚¢à‚°æ‚°¶‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°è‚£†‚°æ‚†â‚¢Ä‚†Ä‚£Ä‚°Ω‚†õ‚¢É‚°Ñ‚†Ä‚†Ä‚°ú‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†õ‚†õ‚¢ß‚°Ä‚†à‚†ª‚¢æ‚°Ñ‚†à‚¢ß‚°Ä‚†Ä‚¢∏‚†Ä‚†Ä‚¢∏‚°∞‚°ø‚†õ‚°ß‚†ä‚°Ñ‚£ø‚£Æ‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°æ‚¢π‚°á‚†Ä‚†Ä‚£¥‚†õ‚†Ä‚¢Ä‚†é‚†Ä‚†Ä‚£º‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°π‚£¶‚°Ä‚†Ä‚£≥‚†∂‚£æ‚£≥‚°Ñ‚£∏‚†Ä‚†Ä‚¢∏‚†É‚¢Ä‚£¥‚†É‚†Ä‚¢°‚£ß‚£Ω‚†Ä‚†π‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°á‚¢∏‚°á‚¢∞‚°æ‚†ì‚†Ä‚†Ä‚°é‚†Ä‚†Ä‚¢†‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°û‚°â‚¢∫‚£Ø‚£´‚°∑‚†¶‚°ø‚†ô‚¢∑‚°á‚†Ä‚¢Ä‚°è‚£†‚†ø‚°ü‚†Ä‚¢†‚£æ‚°ñ‚°ü‚°Ü‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚†Ä‚£≥‚¢ø‚°æ‚†Ä‚†Ä‚£º‚†Å‚†Ä‚£Ä‚£æ‚£ø‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚†Ä‚†∑‚¢ø‚°ü‚†Å‚†à‚†ª‚£ß‚°á‚£†‚¢æ‚£á‚£§‚†û‚£¥‚†É‚°æ‚†Å‚¢Ä‚°ø‚†â‚†í‚¢ª‚°á‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚¢ª‚£ß‚°æ‚¢†‚†É‚¢Ä‚°á‚†Ä‚¢Ä‚°æ‚†Å‚†∏‚£º‚°Ä‚£á‚†Ä‚†Ä‚†Ä‚£Ü‚†Ä‚¢∏‚°Ü‚†Ä‚¢†‚¢ß‚°Ä‚†Ä‚†Ä‚°∑‚£û‚£°‚†é‚£á‚£§‚†û‚†Å‚°º‚†Å‚¢Ä‚°ø‚†Å‚†Ä‚†Ä‚¢π‚†Å‚¢†‚†á‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚°†‚†Ä‚¢Ä‚£ø‚£è‚°á‚¢∏‚°Ä‚†Ä‚°á‚†Ä‚£æ‚†É‚†Ä‚†Ä‚†â‚†ª‚†è‚†ì‚†∂‚†∂‚†ø‚¢§‚£Ä‚°∑‚¢Ñ‚£∏‚¢Æ‚£ø‚°¶‚£§‚°ü‚†â‚£ø‚¢∏‚°è‚†Å‚†Ä‚£∏‚†Å‚¢Ä‚°û‚†É‚†Ä‚†Ä‚†î‚°ø‚†Ä‚°æ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚°í‚†Ä‚†ò‚£ø‚£ø‚°á‚†∏‚£á‚¢∞‚°á‚¢∞‚£ß‚£∂‚£∂‚£∂‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚£¥‚£ñ‚£Ñ‚£í‚£¶‚£º‚£è‚£∞‚£æ‚†ø‚¢æ‚£Ø‚£â‚£è‚£æ‚°á‚†Ä‚†Ä‚°á‚†Ä‚£º‚†Å‚†Ä‚†Ä‚†Ä‚£∞‚†É‚£º‚†Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†≥‚†õ‚†∂‚£Ω‚°á‚†Ä‚£ø‚°Ñ‚¢ª‚£∏‚£é‚†â‚†â‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†â‚†â‚†â‚†Å‚¢π‚°è‚†Å‚†Ä‚£∏‚°è‚†ô‚°ø‚£ª‚†ë‚¢Ñ‚†Ä‚£ß‚†Ä‚°ü‚°Ü‚†Ä‚†Ä‚¢®‚†è‚°¥‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚¢∑‚†Ä‚£ø‚¢π‚£Ñ‚£ø‚†ø‚°Ç‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢æ‚†Å‚†Ä‚†Ä‚°ø‚£ß‚†û‚£±‚†á‚†Ä‚°ò‚†¶‚°Ω‚£Ñ‚£ø‚†π‚£Ñ‚°¥‚¢â‚†î‚†Å‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚°ø‚¢∏‚£ß‚†ò‚£ü‚†ô‚£ø‚°Ñ‚†Ä‚†Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£Ø‚†ñ‚†Ä‚¢∞‚£∑‚¢á‚°º‚†É‚¢Ä‚†û‚†Ä‚°Ü‚†Ä‚†ô‚£ø‚°¶‚†ô‚¢∂‚°Å‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†≤‚¢ø‚†ã‚†â‚†â‚†ô‚¢¶‚£Ä‚†Ä‚†Ä‚£ø‚°á‚¢∏‚£ø‚°∑‚†º‚¢∂‚†Ω‚£ø‚£Ü‚†Ä‚†à‚†ª‚†§‚†§‚†§‚†û‚†Ä‚†Ä‚†Ä‚†Ä‚¢¥‚£ø‚†á‚†Ä‚†Ä‚£∏‚°ø‚†ã‚†Ä‚†Ä‚†é‚†Ä‚°û‚†Ä‚£†‚†û‚¢Å‚†Ω‚¢¶‚°Ä‚†ô‚¢¶‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚¢∏‚£Ö‚†Ä‚†Ä‚†à‚†â‚†õ‚†â‚†î‚£ª‚£∏‚¢∏‚£ø‚†ø‚£†‚°è‚£ß‚†ô‚¢ø‚£ß‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£æ‚†É‚†Ä‚†Ä‚¢∞‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†û‚¢Å‚°î‚†É‚†Ä‚†Å‚†ã‚†ó‚¢¶‚£à‚†≥‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢ø‚£ù‚¢¶‚£∏‚°ú‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚£ß‚°á‚†Ä‚°ø‚†Ä‚†Ä‚†Ä‚†â‚†Å‚†Ä‚†â‚†õ‚¢∑‚£Ñ‚£Ä‚£†‚£¥‚†û‚†â‚¢Å‚°æ‚†Å‚†Ä‚†Ä‚£∞‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚†É‚¢∞‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†õ‚¢∑‚£µ‚£Ñ‚†Ä‚†Ä‚†Ä
‚¢ª‚£ü‚£ø‚°ª‚£é‚¢£‚£≥‚°ò‚£Ü‚†Ä‚¢†‚°û‚°è‚†Ä‚£æ‚£ß‚†Ä‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ü‚£ø‚†Ä‚£†‚¢Ç‚£ü‚£°‚†Ñ‚£†‚¢æ‚£ã‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚¢∞‚£ø‚†É‚¢†‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£ø‚†ª‚£Ñ‚†Ä
‚°à‚¢ª‚£Ü‚†ª‚°ü‚£Ü‚¢ª‚£ß‚¢ª‚£Ñ‚°º‚¢∏‚°á‚£¶‚£ø‚°º‚£ß‚£Ω‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£¥‚£ã‚£§‚£ø‚¢à‚†ü‚¢π‚°ø‚£°‚°û‚†â‚†â‚†Ä‚†Ä‚£∞‚£∂‚£ô‚£∑‚£Ø‚°è‚†Ä‚£∏‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£∑‚†à‚¢ß
‚£ñ‚†¶‚£æ‚£∑‚°ô‚†ø‚†Ä‚†ô‚†Ä‚¢ª‚°á‚¢∏‚°á‚†ò‚¢ø‚£∑‚°å‚†ª‚£ø‚£§‚†Ä‚†Ä‚†Ä‚£†‚£∂‚°ø‚†ã‚£±‚£ø‚†ü‚†Å‚£†‚£ø‚¢†‚°è‚†Ä‚†Ä‚¢Ä‚°æ‚†ü‚†ã‚†Å‚†Ä‚£®‚¢ø‚°á‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ß‚†Ä
‚†ò‚¢ø‚£é‚°ô‚†õ‚†Ç‚†Ä‚†Ä‚†Ä‚°º‚†É‚¢∏‚†á‚†ò‚°Ñ‚†ô‚†õ‚†Ä‚†à‚†â‚†Ä‚£†‚£æ‚¢è‚°ú‚¢°‚°æ‚†õ‚†Ä‚£†‚°æ‚†â‚¢ª‚£ø‚£Ñ‚£Ä‚°æ‚†õ‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚¢≥‚†Ä‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°Ñ
‚†Ä‚†Ä‚†ô‚¢ø‚£¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚¢∏‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚†É‚°é‚¢†‚°ø‚†•‚£§‚†û‚†â‚¢∞‚£¶‚£Ä‚°Ω‚†õ‚†õ‚†Ä‚†Ä‚†Ä‚¢†‚†é‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£Ü‚†ò‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ñ‚¢á‚†Ä‚†Ä‚†Ä‚¢≥
‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚¢π‚£Ü‚°Ä‚†Ä‚†Ä‚°Ä‚£à‚£ø‚¢ª‚°Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£æ‚¢ø‚£á‚†ò‚¢†‚°ü‚¢Ä‚°¥‚†ã‚£Ä‚£∏‚£∑‚£ø‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£∑‚£å‚†≥‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚†Ä‚†Ä‚†Ä‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ô‚†õ‚†õ‚†â‚†â‚†â‚†Ä‚£æ‚£æ‚°Ä‚†Ä‚¢Ä‚£æ‚¢è‚£æ‚°æ‚¢Ä‚°û‚¢†‚°æ‚£∑‚£ø‚£ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚¢Ä‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ò‚°å‚†ô‚†∑‚£¨‚°ª‚£ó‚†í‚†í‚†¶‚†§‚†§‚†§‚¢§‚£Ñ‚£Ä‚†Ä‚†Ä‚¢∏
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†æ‚¢Ø‚°Å‚†Ä‚†Ä‚†Ä‚†Ä‚††‚¢û‚£ª‚¢∑‚£§‚£æ‚£è‚£∏‚¢π‚£ß‚£∏‚££‚¢ü‚£§‚£ø‚£ø‚°ø‚†•‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ß‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†â‚†ô‚†≥‚†§‚†§‚†§‚£Ñ‚£Ä‚£Ä‚†Ä‚†à‚†â‚†ì‚†ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†¶‚°º‚†•‚†§‚†§‚¢Ñ‚°§‚†ñ‚†ã‚†Å‚†ò‚°ü‚†Ä‚†à‚†≥‚£ú‚£ø‚£ø‚££‚£æ‚†ü‚†ã‚†Å‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†π‚£≤‚£§‚°Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚¢Ä‚°¨‚£ù‚†Ç‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚£§‚£ô‚°ü‚†â‚°Ø‚†§‚†§‚†Ä‚†Ä‚††‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚†¥‚†õ‚†Å‚†Ä‚†ô‚£¶
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†É‚†Ä‚£∏‚†Ä‚¢Ä‚£¥‚°ü‚†Ä‚††‚†î‚†í‚£ß‚£§‚£∑‚°¶‚°Ñ‚†Ä‚†Ä‚†Ä‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚†û‚†Å‚†Ä‚†Ä‚¢Ä‚°§‚†é‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚†Ä‚†Ä‚†Ä‚¢†‚†Ä‚†É‚¢†‚†è‚°º‚†Ä‚†Ä‚†Ä‚£†‚°º‚£ø‚£è‚°è‚¢ø‚¢Ñ‚†Ä‚†Ä‚†Ä‚°è‚¢ß‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚†Ä‚¢Ä‚£§‚†¥‚†ü‚†â‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢õ‚°ª‚°á‚†Ä‚†Ä‚†à‚†Ü‚†Ä‚¢∏‚°Ñ‚†ß‚†§‚†¥‚†õ‚†â‚£∏‚£ß‚¢ª‚†Ä‚†ò‚†Ä‚†õ‚†¶‚†º‚†É‚£Ä‚£π‚†Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢£‚†Ä‚†Ä‚†Ä‚¢Ä‚°¥‚†ã‚¢Ä‚£§‚†û‚†â‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚†Ä‚†ò‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚°Ä‚†Ä‚†Ä‚¢Ä‚°º‚£ª‚°Ω‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£è‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£≥‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°Ü‚†Ä‚¢†‚°ü‚¢Ä‚°¥‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä

                            DISCLAIMER

Anyway, if you need a piece of code from this plugin,
please mention in the description or somewhere else that you got it from @KangelPlugins and @Swagnonher.
                             Thanks.
                            üôèBLESSüôè
"""



__id__ = "wall_feed"
__name__ = "–°—Ç–µ–Ω–∞"
__description__ = "üá∑üá∫ | –ê–≥—Ä–µ–≥–∞—Ç–æ—Ä –ø–æ—Å—Ç–æ–≤ –∫–∞–Ω–∞–ª–æ–≤: –æ—Ç–¥–µ–ª—å–Ω—ã–π —á–∞—Ç —Å–≤–µ—Ä—Ö—É, –æ—Ñ—Ñ–ª–∞–π–Ω –∏–∑ –ë–î, —Å –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–º.\n\n–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è: exteraGram/AyuGram 11.12.1 –∏ –≤—ã—à–µ \n\nüá∫üá∏ | Aggregated posts from channels: top chat, offline from DB, with unread. \n\n Requirements: exteraGram/AyuGram 11.12.1 and above"
__author__ = "@Swagnonher & @KangelPlugins"
__version__ = "1.1"
__icon__ = "amechan_wakuwaku_by_fStikBot/9"
__min_version__ = "11.12.1"

import time
import threading
from typing import List, Dict, Any, Optional, Tuple

from base_plugin import BasePlugin
from android_utils import log, run_on_ui_thread, OnClickListener
from ui.settings import Input, Divider
from hook_utils import find_class, get_private_field, set_private_field
from client_utils import get_last_fragment, get_messages_storage, get_messages_controller

try:
    from mandre_lib import Mandre
    _MANDRE_AVAILABLE = True
except Exception:
    Mandre = None
    _MANDRE_AVAILABLE = False

from android.view import View, ViewGroup, Gravity
from android.widget import FrameLayout, LinearLayout, TextView
from android.graphics import Color
from android.graphics.drawable import GradientDrawable
from android.util import TypedValue

from org.telegram.messenger import (
    UserConfig, AndroidUtilities, MessageObject, ChatObject, NotificationCenter ,LocaleController
)

from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC
from org.telegram.ui.Cells import ChatMessageCell, DialogCell
from org.telegram.ui.Components import BackupImageView, AvatarDrawable
from java import jclass
from java.util import ArrayList as JArrayList


SETTINGS_KEY_SHOW_HEADER = "show_header_in_chats"
SETTINGS_KEY_BAN_LIST = "ban_list_csv"
SETTINGS_KEY_MAX_POSTS = "max_posts_per_sync"
SETTINGS_KEY_LANGUAGE = "language"
STORAGE_KEY_LAST_READ_DATE = "last_read_date"
STORAGE_KEY_LAST_SYNC = "last_sync_time"
STORAGE_KEY_LAST_WRITE_DATE = "last_write_date"
STORAGE_KEY_LAST_SYNTH_ID = "last_synth_id"
PERSIST_FILE_IGNORE = "ignore.json"
PERSIST_FILE_IDMAP = "idmap.json"

# Localization strings
LOCALES = {
    "ru": {
        "title": "–°—Ç–µ–Ω–∞ (Wall Feed)",
        "show_header": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å '–°—Ç–µ–Ω–∞' –≤–≤–µ—Ä—Ö—É —Å–ø–∏—Å–∫–∞ —á–∞—Ç–æ–≤",
        "sync_section": "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "max_posts": "–ú–∞–∫—Å. –ø–æ—Å—Ç–æ–≤ –Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—é (–Ω–∞ –∫–∞–Ω–∞–ª)",
        "ban_list": "–ò—Å–∫–ª—é—á—ë–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª—ã (ID —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é)",
        "filters_section": "–§–∏–ª—å—Ç—Ä—ã",
        "channel_name": "–°—Ç–µ–Ω–∞",
        "unread_msg": "‚Ä¢ {count} –Ω–µ–ø—Ä–æ—á.",
    },
    "en": {
        "title": "Wall (Wall Feed)",
        "show_header": "Show 'Wall' at the top of chats list",
        "sync_section": "Synchronization",
        "max_posts": "Max posts per sync (per channel)",
        "ban_list": "Excluded channels (IDs comma-separated)",
        "filters_section": "Filters",
        "channel_name": "Wall",
        "unread_msg": "‚Ä¢ {count} unread",
    }
}


class WallFeedPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.header_view_ref = None
        self.overlay_container = None
        self.messages_cache: List[Tuple[int, TLRPC.Message, int]] = []  # (dialog_id, message, date)
        self.unread_count = 0
        self.unread_divider_index = -1
        self.hook_create_view_ref = None
        self.hook_on_resume_ref = None
        # Synthetic chat id (positive chat id); dialog id is -WALL_CHAT_ID
        self.WALL_CHAT_ID = 777777777
        self.WALL_DIALOG_ID = -self.WALL_CHAT_ID
        # Sync control
        self._stop_sync = False
        self._sync_thread = None
        # Cache for chats (channel_id -> chat object)
        self._chat_cache: Dict[int, Any] = {}
        self._chat_cache_timestamp: Dict[int, float] = {}
        # DB query backoff and cache
        self._db_backoff: Dict[int, float] = {}
        self._db_empty_count: Dict[int, int] = {}

    def _get_lang(self) -> str:
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except:
            lang = "en"
        return "ru" if lang.startswith("ru") else "en"

    def _get_locale_text(self, key: str) -> str:
        lang_key = self._get_lang()
        locale = LOCALES.get(lang_key, LOCALES["en"])
        return locale.get(key, "")

    def _get_channel_name(self) -> str:
        return self._get_locale_text("channel_name")

    def _get_unread_msg(self, count: int) -> str:
        msg_template = self._get_locale_text("unread_msg")
        return msg_template.format(count=count)

    def get_settings_items(self):
        from ui.settings import Header, Switch, Text, Divider, Input
        
        def on_clear_cache(_):
            try:
                self._ignore_keys = {}
                self._id_map = {}
                self._last_synth_id = 0
                try:
                    self._sql_kv_delete_prefix("ignore:")
                    self._sql_kv_delete_prefix("idmap:")
                    self._sql_kv_set("meta:last_synth_id", 0)
                except Exception:
                    pass
                log(f"[{self.id}] Cache cleared! Ignore keys and ID map reset.")
            except Exception as e:
                log(f"[{self.id}] Error clearing cache: {e}")
        
        items = [
            Header(text=self._get_locale_text("title")),
            Switch(
                key=SETTINGS_KEY_SHOW_HEADER,
                text=self._get_locale_text("show_header"),
                default=False,
                icon="files_folder",
                on_change=lambda v: self._reapply_dialogs_hook()
            ),
            Divider(text=self._get_locale_text("sync_section")),
            Input(
                key=SETTINGS_KEY_MAX_POSTS,
                text=self._get_locale_text("max_posts"),
                icon="msg_download_solar",
                default="500",
                on_change=lambda v: self._set_max_posts(v or "500")
            ),
            Text(
                text="üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à –ø–æ—Å—Ç–æ–≤",
                icon="msg_delete",
                on_click=on_clear_cache
            )
        ]
        return items

    def create_settings(self):
        try:
            items = self.get_settings_items()
        except Exception:
            items = []
        try:
            # Inject ban list input if not present
            have_ban = False
            for it in items:
                try:
                    if getattr(it, 'key', None) == SETTINGS_KEY_BAN_LIST:
                        have_ban = True
                        break
                except Exception:
                    continue
            if not have_ban:
                items.insert(1, Input(
                    key=SETTINGS_KEY_BAN_LIST,
                    text=self._get_locale_text("ban_list"),
                    icon="filled_bot_decline_24",
                    default=str(self.get_setting(SETTINGS_KEY_BAN_LIST, "")),
                    on_change=lambda v: self._set_ban_list_csv(v or "")
                ))
                # Optional divider for readability
                items.insert(2, Divider(text=self._get_locale_text("filters_section")))
        except Exception:
            pass
        return items

    def on_plugin_load(self):
        # Check if MandreLib is available - plugin cannot work without it
        if not _MANDRE_AVAILABLE or Mandre is None:
            raise RuntimeError(f"[{self.id}] MandreLib is required but not installed. Please install mandre_lib.")
        
        try:
            if Mandre:
                Mandre.use_persistent_storage(self)
        except Exception:
            log(f"[{self.id}] MandreLib persistent storage unavailable")

        # Init SQL KV store and migrate JSON once; then load state from SQL
        try:
            self._sql_init_storage()
            self._migrate_json_to_sql_once()
            self._load_ignore_and_idmap_from_sql()
            self._last_synth_id = self._sql_kv_get_int("meta:last_synth_id", 0)
        except Exception:
            pass

        self._apply_dialogs_hook()
        self._apply_chat_activity_hooks()

        # Register synthetic chat via MandreLib helper with fallback
        try:
            if Mandre and hasattr(Mandre, "register_synthetic_channel"):
                Mandre.register_synthetic_channel(self.WALL_CHAT_ID, self._get_channel_name(), megagroup=False, broadcast=True)
            else:
                mc = get_messages_controller()
                chat = mc.getChat(self.WALL_CHAT_ID)
                if chat is None:
                    channel = TLRPC.TL_channel()
                    channel.id = int(self.WALL_CHAT_ID)
                    channel.title = self._get_channel_name()
                    channel.megagroup = False
                    channel.broadcast = True
                    mc.putChat(channel, True)
        except Exception as e:
            log(f"[{self.id}] putChat fallback error: {e}")

        try:
            # Start background sync scheduler once
            if not getattr(self, '_sync_thread', None):
                self._sync_thread = threading.Thread(target=self._sync_messages_background, daemon=True)
                self._sync_thread.start()
        except Exception as e:
            log(f"[{self.id}] Background sync thread error: {e}")

        log(f"[{self.id}] –°—Ç–µ–Ω–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")

    def on_plugin_unload(self):
        self._remove_dialogs_hook()
        self._remove_overlay()
        self._clear_chat_cache()
        try:
            self._stop_sync = True
        except Exception:
            pass
        log(f"[{self.id}] –°—Ç–µ–Ω–∞ –≤—ã–≥—Ä—É–∂–µ–Ω–∞")

    def _apply_dialogs_hook(self):
        try:
            DialogsActivityCls = find_class("org.telegram.ui.DialogsActivity")
            # Hook getDialogsArray to inject synthetic dialog (wrap primitives via java.lang)
            getDialogsArray = DialogsActivityCls.getClass().getDeclaredMethod(
                "getDialogsArray",
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Integer').TYPE,
                jclass('java.lang.Boolean').TYPE
            )
            getDialogsArray.setAccessible(True)
            self.hook_method(getDialogsArray, _GetDialogsArrayHook(self))

            log(f"[{self.id}] hooked DialogsActivity.getDialogsArray")
        except Exception as e:
            log(f"[{self.id}] dialogs hook error: {e}")

        # Hook DialogsActivity.createView and onResume to attach header and refresh
        try:
            ContextClass = find_class("android.content.Context")
            createView = DialogsActivityCls.getClass().getDeclaredMethod("createView", ContextClass)
            createView.setAccessible(True)
            self.hook_create_view_ref = self.hook_method(createView, _DialogsCreateViewHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs createView hook error: {e}")
        try:
            onResume = DialogsActivityCls.getClass().getDeclaredMethod("onResume")
            onResume.setAccessible(True)
            self.hook_on_resume_ref = self.hook_method(onResume, _DialogsOnResumeHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs onResume hook error: {e}")

        # Hook DialogsAdapter.onBindViewHolder to style our synthetic dialog
        try:
            DialogsAdapter = find_class("org.telegram.ui.Adapters.DialogsAdapter")
            target = None
            for m in DialogsAdapter.getClass().getDeclaredMethods():
                try:
                    if m.getName() == "onBindViewHolder" and len(m.getParameterTypes()) == 2:
                        target = m
                        break
                except Exception:
                    continue
            if target is not None:
                target.setAccessible(True)
                self._dialogs_on_bind_ref = self.hook_method(target, _DialogsOnBindHook(self))
        except Exception as e:
            log(f"[{self.id}] dialogs onBind hook error: {e}")

        # Hook MessagesController.getDialogs to ensure our dialog exists in arrays used across app (including some searches)
        # Do not hook MC.getDialogs globally to avoid polluting archives/folders

        # Hook ChatActivity to open Wall feed when the synthetic chat is opened
        # Do not hook ChatActivity; we want default chat UI

    def _remove_dialogs_hook(self):
        try:
            if self.hook_create_view_ref:
                self.unhook_method(self.hook_create_view_ref)
                self.hook_create_view_ref = None
            if self.hook_on_resume_ref:
                self.unhook_method(self.hook_on_resume_ref)
                self.hook_on_resume_ref = None
            if getattr(self, '_dialogs_on_bind_ref', None):
                self.unhook_method(self._dialogs_on_bind_ref)
                self._dialogs_on_bind_ref = None
        except Exception:
            pass

    def _reapply_dialogs_hook(self):
        self._remove_dialogs_hook()
        self._apply_dialogs_hook()

    def _ensure_header_in_dialogs(self, fragment):
        try:
            if not self.get_setting(SETTINGS_KEY_SHOW_HEADER, True):
                self._remove_header()
                return

            content_view = get_private_field(fragment, "fragmentView") or get_private_field(fragment, "contentView")
            list_view = get_private_field(fragment, "listView")
            if content_view is None or list_view is None:
                return

            if self.header_view_ref and self.header_view_ref.getParent() is not None:
                return

 
            cell = DialogCell(None, content_view.getContext(), True, False, UserConfig.selectedAccount, None)
            custom = DialogCell.CustomDialog()
            custom.name = self._get_channel_name()
            custom.message = self._get_unread_msg(0)
            try:

                pass
            except Exception:
                pass
            cell.setDialog(custom)

            def on_click(_):
                try:
                    self.open_wall_feed()
                except Exception as e:
                    log(f"[{self.id}] open_wall_feed error: {e}")

            cell.setOnClickListener(OnClickListener(on_click))

            # –í—Å—Ç–∞–≤–ª—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
            try:
                header_height = AndroidUtilities.dp(72)
                parent_view = list_view.getParent()
                if parent_view is not None:
                    # –ï—Å–ª–∏ —Å–ø–∏—Å–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ LinearLayout ‚Äî –¥–æ–±–∞–≤–∏–º –ø–µ—Ä–µ–¥ –Ω–∏–º –∫–∞–∫ –æ–±—ã—á–Ω—É—é —Å—Ç—Ä–æ–∫—É
                    from android.widget import LinearLayout as _LL
                    from android.widget import FrameLayout as _FL
                    if isinstance(parent_view, _LL):
                        # –ù–∞–π–¥—ë–º –ø–æ–∑–∏—Ü–∏—é list_view
                        insert_index = 0
                        try:
                            count = parent_view.getChildCount()
                            for i in range(count):
                                if parent_view.getChildAt(i) is list_view:
                                    insert_index = i
                                    break
                        except Exception:
                            insert_index = 0
                        parent_view.addView(cell, insert_index, _LL.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height))
                    elif isinstance(parent_view, _FL):
                        # –î–ª—è FrameLayout –¥–æ–±–∞–≤–∏–º –æ–≤–µ—Ä–ª–µ–π —Å–≤–µ—Ä—Ö—É –∏ —Å–¥–≤–∏–Ω–µ–º —Å–ø–∏—Å–æ–∫ –ø–∞–¥–¥–∏–Ω–≥–æ–º
                        lp = _FL.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                        lp.gravity = Gravity.TOP
                        parent_view.addView(cell, lp)
                        try:
                            list_view.setPadding(
                                list_view.getPaddingLeft(),
                                list_view.getPaddingTop() + header_height,
                                list_view.getPaddingRight(),
                                list_view.getPaddingBottom()
                            )
                        except Exception:
                            pass
                    else:
                        # –§–æ–ª–±—ç–∫ ‚Äî –¥–æ–±–∞–≤–∏–º –≤ content_view —Å–≤–µ—Ä—Ö—É
                        try:
                            from android.widget import LinearLayout as _LL2
                            if isinstance(content_view, _LL2):
                                content_view.addView(cell, 0, _LL2.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height))
                            else:
                                lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                                lp.gravity = Gravity.TOP
                                content_view.addView(cell, lp)
                                list_view.setPadding(list_view.getPaddingLeft(), list_view.getPaddingTop() + header_height, list_view.getPaddingRight(), list_view.getPaddingBottom())
                        except Exception:
                            pass
                else:
                    # –ù–µ—Ç —Ä–æ–¥–∏—Ç–µ–ª—è ‚Äî –¥–æ–±–∞–≤–∏–º –≤ content_view –∫–∞–∫ –æ–≤–µ—Ä–ª–µ–π
                    lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, header_height)
                    lp.gravity = Gravity.TOP
                    content_view.addView(cell, lp)
                    try:
                        list_view.setPadding(list_view.getPaddingLeft(), list_view.getPaddingTop() + header_height, list_view.getPaddingRight(), list_view.getPaddingBottom())
                    except Exception:
                        pass
            except Exception as e:
                log(f"[{self.id}] header insert error: {e}")

            self.header_view_ref = cell
            self._update_unread_counter(None)

        except Exception as e:
            log(f"[{self.id}] ensure_header error: {e}")

    def _remove_header(self):
        try:
            if self.header_view_ref and self.header_view_ref.getParent() is not None:
                parent = self.header_view_ref.getParent()
                parent.removeView(self.header_view_ref)
            self.header_view_ref = None
        except Exception:
            pass

    def _sync_messages_background(self):
        try:
            # Initial sync: from yesterday to now
            now = int(time.time())
            start_ts = now - 24 * 60 * 60
            # Show lightweight floating overlay (like chikiexport)
            self._create_progress_overlay("–ó–∞–≥—Ä—É–∑–∫–∞ –ø–æ—Å—Ç–æ–≤‚Ä¶", 0.05)
            self._sync_in_progress = True
            self._perform_sync_range(start_ts, now)
            self._sync_in_progress = False
            self._dismiss_progress_overlay()

            # Periodic sync every 1 minute until plugin unload
            def loop_sync():
                while not self._stop_sync:
                    try:
                        if getattr(self, '_sync_in_progress', False):
                            time.sleep(1)
                            continue
                        self._sync_in_progress = True
                        last_sync = self._get_last_sync_time()
                        now2 = int(time.time())
                        # sync new posts since last sync
                        self._perform_sync_range(last_sync or (now2 - 2 * 24 * 60 * 60), now2)
                    except Exception as e:
                        log(f"[{self.id}] periodic sync error: {e}")
                    # sleep 1 minute
                    for _ in range(1):
                        if self._stop_sync:
                            break
                        time.sleep(240)
                    self._sync_in_progress = False
            self._sync_thread = threading.Thread(target=loop_sync, daemon=True)
            self._sync_thread.start()
        except Exception as e:
            log(f"[{self.id}] sync error: {e}")

    def _perform_sync_range(self, start_ts: int, end_ts: int):
        try:
            self._create_progress_overlay(f"üîç {self._get_locale_text('sync_section')}...", 0.05)
        except Exception:
            pass
        
        dialogs = self._get_channel_dialog_ids()
        log(f"[{self.id}] sync: scanning channels, found {len(dialogs)}")
        
        try:
            self._update_progress_overlay(f"üìÇ –ö–∞–Ω–∞–ª–æ–≤: {len(dialogs)}")
        except Exception:
            pass
        
        max_posts = self._get_max_posts()
        msgs = self._load_channels_messages_from_db(dialogs, per_dialog_limit=max_posts, start_ts=start_ts, end_ts=end_ts)
        log(f"[{self.id}] sync: loaded {len(msgs)} posts from DB")
        
        try:
            self._update_progress_overlay(f"üì• –ó–∞–≥—Ä—É–∂–µ–Ω–æ: {len(msgs)} –ø–æ—Å—Ç–æ–≤")
        except Exception:
            pass

        msgs.sort(key=lambda t: t[2])
        self.messages_cache = msgs

        try:
            self._update_progress_overlay(f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ—Å—Ç–æ–≤...")
            self._write_messages_to_wall(msgs)
        except Exception as e:
            log(f"[{self.id}] write-to-wall error: {e}")

        last_read = self._get_last_read_date()
        self.unread_count = sum(1 for _, _, d in msgs if d > last_read)
        self.unread_divider_index = -1
        if last_read > 0:
            for i, (_, _, d) in enumerate(msgs):
                if d > last_read:
                    self.unread_divider_index = i
                    break
        self._set_last_sync_time(int(time.time()))
        # Update dialog unread count in MessagesController
        try:
            mc = get_messages_controller()
            d = mc.dialogs_dict.get(self.WALL_DIALOG_ID)
            if d is None:
                d = TLRPC.TL_dialog()
                d.id = self.WALL_DIALOG_ID
            d.unread_count = int(self.unread_count)
            mc.dialogs_dict.put(self.WALL_DIALOG_ID, d)
        except Exception:
            pass
        
        # Dismiss progress overlay
        try:
            self._dismiss_progress_overlay()
        except Exception:
            pass

    def _write_messages_to_wall(self, msgs: List[Tuple[int, TLRPC.Message, int]]):
        try:
            if not msgs:
                return
            last_written = 0
            try:
                val = self._sql_kv_get("meta:last_write_date")
                if val is not None and str(val).strip().isdigit():
                    last_written = int(str(val).strip())
            except Exception:
                pass
            log(f"[{self.id}] write_messages_to_wall: processing {len(msgs)} messages, last_written={last_written}")
            log(f"[{self.id}] _ignore_keys size: {len(getattr(self, '_ignore_keys', {}))}")
            arr = JArrayList()
            skipped_count = 0
            skipped_by_ignore = 0
            seen_keys = set()
            for did, tl_msg, _ in msgs:
                try:
                    # Skip already written by ignore and date cutoff
                    orig_peer0 = getattr(tl_msg, 'peer_id', None)
                    orig_ch_id0 = None
                    if orig_peer0 and hasattr(orig_peer0, 'channel_id') and orig_peer0.channel_id:
                        orig_ch_id0 = int(orig_peer0.channel_id)
                    key = f"{orig_ch_id0 or did}:{tl_msg.id}"
                    if key in seen_keys:
                        skipped_count += 1
                        continue
                    seen_keys.add(key)
                    if getattr(self, '_ignore_keys', {}).get(key):
                        skipped_by_ignore += 1
                        skipped_count += 1
                        continue
                    # Redirect message to wall chat
                    old_peer = getattr(tl_msg, 'peer_id', None)
                    tl_msg.dialog_id = self.WALL_DIALOG_ID
                    peer = TLRPC.TL_peerChannel()
                    peer.channel_id = self.WALL_CHAT_ID
                    tl_msg.peer_id = peer
                    tl_msg.out = True
                    # Add forward header with original channel info
                    ch_id = None
                    if old_peer and hasattr(old_peer, 'channel_id') and old_peer.channel_id:
                        ch_id = int(old_peer.channel_id)
                    if ch_id:
                        try:
                            fwd = TLRPC.TL_messageFwdHeader()
                            fwd.channel_id = ch_id
                            fwd.date = tl_msg.date
                            chat = get_messages_controller().getChat(ch_id)
                            if chat and hasattr(chat, 'title'):
                                fwd.from_name = chat.title
                            # also set from_id for avatar resolution
                            try:
                                fpeer = TLRPC.TL_peerChannel()
                                fpeer.channel_id = ch_id
                                fwd.from_id = fpeer
                            except Exception:
                                pass
                            tl_msg.fwd_from = fwd
                        except Exception:
                            pass
                    # assign synthetic id and remember mapping + ignore
                    synth_id = getattr(self, '_last_synth_id', 0) + 1
                    self._last_synth_id = synth_id
                    try:
                        tl_msg.id = int(synth_id)
                    except Exception:
                        pass
                    if key:
                        self._id_map[key] = int(synth_id)
                        self._ignore_keys[key] = True
                except Exception:
                    pass
                arr.add(tl_msg)
            storage = get_messages_storage()
            # Use MessagesController-style variant to ensure dialog creation and proper indexing
            # putMessages(messages, dialogId, load_type, max_id, createDialog, mode, threadMessageId)
            to_write = arr.size()
            log(f"[{self.id}] write_messages_to_wall: skipped {skipped_count} (by_ignore={skipped_by_ignore}), writing {to_write} messages")
            if to_write > 0:
                try:
                    messagesRes = jclass('org.telegram.tgnet.TLRPC$TL_messages_messages')()
                    messagesRes.messages = arr
                    messagesRes.users = JArrayList()
                    messagesRes.chats = JArrayList()
                    storage.putMessages(messagesRes, self.WALL_DIALOG_ID, -1, 0, True, ChatActivity.MODE_SAVED, 0)
                except Exception:
                    # Fallback to simple put
                    storage.putMessages(arr, False, True, False, 0, False, 0, 0)
                log(f"[{self.id}] wrote {to_write} messages to wall storage")
            # Persist last write max date
            try:
                max_date = 0
                for _, tl_msg2, _ in msgs:
                    if tl_msg2.date > max_date:
                        max_date = tl_msg2.date
                if max_date:
                    self._sql_kv_set("meta:last_write_date", int(max_date))
            except Exception:
                pass
            # persist ignore/id maps and last synth id
            try:
                self._save_ignore_and_idmap_to_sql()
                self._sql_kv_set("meta:last_synth_id", int(getattr(self, '_last_synth_id', 0)))
            except Exception:
                pass
            # Notify UI to refresh dialogs
            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.dialogsNeedReload)
            except Exception:
                pass
        except Exception as e:
            log(f"[{self.id}] _write_messages_to_wall error: {e}")

    # --- Hook ChatActivity to set saved mode for wall and update last_read on exit ---
    def _apply_chat_activity_hooks(self):
        try:
            CA = find_class("org.telegram.ui.ChatActivity")
            ContextClass = find_class("android.content.Context")
            createView = CA.getClass().getDeclaredMethod("createView", ContextClass)
            createView.setAccessible(True)
            self.hook_method(createView, _ChatActivityCreateHook(self))

            onPause = CA.getClass().getDeclaredMethod("onPause")
            onPause.setAccessible(True)
            self.hook_method(onPause, _ChatActivityPauseHook(self))
        except Exception as e:
            log(f"[{self.id}] chat hooks error: {e}")

    def _get_channel_dialog_ids(self) -> List[int]:
        res = []
        try:
            mc = get_messages_controller()
            dialogs = mc.getDialogs(0)
            acc = UserConfig.selectedAccount
            ban = set(self._get_ban_list())
            # Convert to Python list to avoid index issues
            if hasattr(dialogs, 'toArray'):
                arr = list(dialogs.toArray())
            else:
                # Fallback: try iterating with get(i) safely
                arr = []
                try:
                    size = dialogs.size()
                    for i in range(size):
                        try:
                            arr.append(dialogs.get(i))
                        except Exception:
                            break
                except Exception:
                    arr = []
            for d in arr:
                try:
                    if isinstance(d, TLRPC.TL_dialog):
                        did = d.id
                        # Exclude wall itself and include only broadcast channels (exclude megagroups)
                        if did == self.WALL_DIALOG_ID:
                            continue
                        if ChatObject.isChannelAndNotMegaGroup(-did, acc):
                            ch_id = -int(did)
                            if ch_id in ban:
                                continue
                            res.append(did)
                except Exception:
                    continue
        except Exception as e:
            log(f"[{self.id}] get channel dialogs error: {e}")
        return res

    def _load_channels_messages_from_db(self, dialog_ids: List[int], per_dialog_limit: int = 300, start_ts: Optional[int] = None, end_ts: Optional[int] = None) -> List[Tuple[int, TLRPC.Message, int]]:
        agg: List[Tuple[int, TLRPC.Message, int]] = []
        try:
            storage = get_messages_storage()
            database = get_private_field(storage, "database")
            if not database:
                return []
            for did in dialog_ids:
                try:
                    # Backoff: skip frequent empty channels
                    now_ts = int(time.time())
                    next_ok = int(self._db_backoff.get(did, 0) or 0)
                    if next_ok and now_ts < next_ok:
                        continue
                    # Primary query (as in chikiexport): by uid (dialog id)
                    q = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {did} ORDER BY date DESC LIMIT {per_dialog_limit}"
                    cursor = database.queryFinalized(q)
                    loaded_for_did = 0
                    while cursor.next():
                        data = cursor.byteBufferValue(0)
                        if data:
                            msg = TLRPC.Message.TLdeserialize(data, data.readInt32(False), False)
                            if msg:
                                msg.id = cursor.intValue(1)
                                msg.date = cursor.intValue(2)
                                msg.dialog_id = cursor.longValue(3)
                                # Ensure message belongs to a channel (exclude user/group)
                                peer = getattr(msg, 'peer_id', None)
                                if not (peer and hasattr(peer, 'channel_id') and peer.channel_id):
                                    data.reuse()
                                    continue
                                # Apply time window filter in Python to avoid missing data due to DB schema differences
                                if start_ts and end_ts:
                                    if msg.date < start_ts or msg.date > end_ts:
                                        data.reuse()
                                        continue
                                agg.append((did, msg, msg.date))
                                loaded_for_did += 1
                            data.reuse()
                    # Fallback: some builds store uid with opposite sign; try positive channel id if nothing loaded
                    if loaded_for_did == 0:
                        try:
                            fallback_uid = -did
                            q2 = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {fallback_uid} ORDER BY date DESC LIMIT {per_dialog_limit}"
                            cursor2 = database.queryFinalized(q2)
                            while cursor2.next():
                                data2 = cursor2.byteBufferValue(0)
                                if data2:
                                    msg2 = TLRPC.Message.TLdeserialize(data2, data2.readInt32(False), False)
                                    if msg2:
                                        peer2 = getattr(msg2, 'peer_id', None)
                                        if not (peer2 and hasattr(peer2, 'channel_id') and peer2.channel_id):
                                            data2.reuse()
                                            continue
                                        if start_ts and end_ts and (msg2.date < start_ts or msg2.date > end_ts):
                                            data2.reuse()
                                            continue
                                        msg2.id = cursor2.intValue(1)
                                        msg2.date = cursor2.intValue(2)
                                        msg2.dialog_id = cursor2.longValue(3)
                                        agg.append((did, msg2, msg2.date))
                                        loaded_for_did += 1
                                data2.reuse()
                            if loaded_for_did == 0:
                                # Exponential backoff on empty result
                                empty = int(self._db_empty_count.get(did, 0) or 0) + 1
                                self._db_empty_count[did] = empty
                                delay = min(3600, 15 * (2 ** (empty - 1)))
                                self._db_backoff[did] = int(time.time()) + delay
                        except Exception:
                            pass
                    try:
                        if loaded_for_did > 0:
                            self._db_empty_count[did] = 0
                            self._db_backoff[did] = 0
                    except Exception:
                        pass
                except Exception as e:
                    log(f"[{self.id}] DB read error for {did}: {e}")
        except Exception as e:
            log(f"[{self.id}] DB access error: {e}")
        return agg

    def open_wall_feed(self):
        try:
            fragment = get_last_fragment()
            if fragment is None:
                return
            try:
                chat = ChatActivity.of(self.WALL_DIALOG_ID)
            except Exception:
                from android.os import Bundle
                b = Bundle()
                b.putLong("dialog_id", int(self.WALL_DIALOG_ID))
                chat = ChatActivity(b)
            fragment.presentFragment(chat)
        except Exception as e:
            log(f"[{self.id}] open_wall_feed error: {e}")

    def _remove_overlay(self):
        try:
            # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–µ –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
            try:
                if self.messages_cache:
                    last_date = self.messages_cache[-1][2]
                    if last_date and last_date > 0:
                        self._set_last_read_date(last_date)
            except Exception:
                pass
            if self.overlay_container and self.overlay_container.getParent() is not None:
                parent = self.overlay_container.getParent()
                parent.removeView(self.overlay_container)
            self.overlay_container = None
        except Exception:
            pass

    def _build_unread_divider(self, ctx) -> View:
        row = LinearLayout(ctx)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER)
        row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
        tv = TextView(ctx)
        tv.setText("–ù–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è")
        tv.setTextColor(Color.LTGRAY)
        tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 13)
        row.addView(tv, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        return row

    def _build_feed_item(self, ctx, account: int, dialog_id: int, msg: TLRPC.Message) -> View:
        container = LinearLayout(ctx)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))

        header = LinearLayout(ctx)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER_VERTICAL)

        avatar = BackupImageView(ctx)
        ava_draw = AvatarDrawable()
        name = "–ö–∞–Ω–∞–ª"
        try:
            peer = getattr(msg, 'peer_id', None)
            if peer and hasattr(peer, 'channel_id') and peer.channel_id:
                cid = peer.channel_id
                # Use cache for faster lookup
                chat = self._get_chat_cached(cid)
                if chat:
                    if hasattr(chat, 'title'):
                        name = chat.title
                    try:
                        avatar.setForUserOrChat(chat, ava_draw)
                    except Exception:
                        ava_draw.setInfo(chat)
                else:
                    ava_draw.setInfo(0, name, None)
            else:
                ava_draw.setInfo(0, name, None)
        except Exception as e:
            log(f"[{self.id}] Error building feed item header: {e}")
            ava_draw.setInfo(0, name, None)
        try:
            # Fallback if image not resolved
            if getattr(avatar, 'getImageReceiver', None) and avatar.getImageReceiver() is None:
                avatar.setImageDrawable(ava_draw)
        except Exception:
            pass
        header.addView(avatar, LinearLayout.LayoutParams(AndroidUtilities.dp(36), AndroidUtilities.dp(36)))

        title = TextView(ctx)
        title.setText(name)
        title.setTextColor(Color.WHITE)
        title.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
        p = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        p.leftMargin = AndroidUtilities.dp(8)
        header.addView(title, p)

        container.addView(header, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        try:
            cell = ChatMessageCell(ctx, account)
            mo = MessageObject(account, msg, False, False)
            cell.setMessageObject(mo, None, False, False, False)
            container.addView(cell, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        except Exception as e:
            fallback = TextView(ctx)
            try:
                text = getattr(msg, 'message', '') or "(–º–µ–¥–∏–∞)"
            except Exception:
                text = "(—Å–æ–æ–±—â–µ–Ω–∏–µ)"
            fallback.setText(text)
            fallback.setTextColor(Color.WHITE)
            fallback.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
            fallback.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(6), AndroidUtilities.dp(8), AndroidUtilities.dp(6))
            container.addView(fallback, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        return container

    def _update_unread_counter(self, tv: TextView):
        try:
            count = self.unread_count
            # –û–±–Ω–æ–≤–∏–º –ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–∏–∞–ª–æ–≥–∞
            if isinstance(self.header_view_ref, DialogCell):
                custom = DialogCell.CustomDialog()
                custom.name = self._get_channel_name()
                custom.message = self._get_unread_msg(count)
                self.header_view_ref.setDialog(custom)
            elif tv is not None:
                tv.setText(self._get_unread_msg(count))
        except Exception:
            pass

    def _get_last_read_date(self) -> int:
        try:
            val = self._sql_kv_get("meta:last_read_date")
            if val is not None and str(val).strip().isdigit():
                return int(str(val).strip())
        except Exception:
            pass
        return 0

    def _set_last_read_date(self, ts: int):
        try:
            self._sql_kv_set("meta:last_read_date", int(ts))
        except Exception:
            pass

    def _get_last_sync_time(self) -> int:
        try:
            return self._sql_kv_get_int("meta:last_sync", 0)
        except Exception:
            pass
        return 0

    def _set_last_sync_time(self, ts: int):
        try:
            self._sql_kv_set("meta:last_sync", int(ts))
        except Exception:
            pass

    # --- Ban list helpers ---
    def _get_ban_list_csv(self) -> str:
        try:
            if Mandre:
                v = self.get_setting(SETTINGS_KEY_BAN_LIST, "") or ""
                return str(v)
        except Exception:
            pass
        return ""

    def _set_ban_list_csv(self, csv: str):
        try:
            self.set_setting(SETTINGS_KEY_BAN_LIST, csv or "")
        except Exception:
            pass

    def _get_ban_list(self) -> List[int]:
        try:
            csv = self._get_ban_list_csv()
            ids = []
            for part in str(csv).replace(";", ",").split(","):
                p = part.strip()
                if not p:
                    continue
                try:
                    ids.append(int(p))
                except Exception:
                    continue
            return ids
        except Exception:
            return []

    # --- Progress dialog helpers ---
    def _show_progress_dialog(self, message: str):
        try:
            from ui.alert import AlertDialogBuilder
            last_fragment = get_last_fragment()
            if not last_fragment:
                return
            def show():
                try:
                    builder = AlertDialogBuilder(last_fragment.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_LOADING)
                    builder.set_title(message)
                    builder.set_cancelable(False)
                    self.progress_dialog = builder
                    self.progress_dialog.show()
                except Exception:
                    pass
            run_on_ui_thread(show)
        except Exception:
            pass

    def _dismiss_progress_dialog(self):
        try:
            def dism():
                try:
                    if self.progress_dialog:
                        self.progress_dialog.dismiss()
                        self.progress_dialog = None
                except Exception:
                    pass
            run_on_ui_thread(dism)
        except Exception:
            pass

    # Floating overlay similar to chikiexport
    def _create_progress_overlay(self, text: str, progress: float = 0.0):
        try:
            from org.telegram.ui.ActionBar import Theme
            from android.content.res import ColorStateList
            from android.graphics.drawable import RippleDrawable
            fragment = get_last_fragment()
            if not fragment:
                return
            context = fragment.getParentActivity()
            if not context:
                return
            content_view_id = 0x01020002
            root_view = context.getWindow().getDecorView()
            container = root_view.findViewById(content_view_id) or root_view
            if not container:
                return
            if self.progress_overlay_container:
                try:
                    parent = self.progress_overlay_container.getParent()
                    if parent:
                        parent.removeView(self.progress_overlay_container)
                except Exception:
                    pass
            self.progress_overlay_container = FrameLayout(context)
            try:
                self.progress_overlay_container.setClickable(False)
                self.progress_overlay_container.setFocusable(False)
            except Exception:
                pass
            # Build chip
            chip = LinearLayout(context)
            chip.setOrientation(LinearLayout.HORIZONTAL)
            chip.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(22))
            try:
                from org.telegram.ui.ActionBar import Theme as _Theme
                bg.setColor(_Theme.getColor(_Theme.key_undo_background))
                textColor = _Theme.getColor(_Theme.key_undo_infoColor)
            except Exception:
                bg.setColor(Color.parseColor("#2B2B2B"))
                textColor = Color.WHITE
            chip.setBackground(bg)
            # spinner
            try:
                from org.telegram.ui.Components import RadialProgressView
                spinner = RadialProgressView(context)
                spinner.setProgressColor(textColor)
                spinner.setSize(AndroidUtilities.dp(20))
                chip.addView(spinner, LinearLayout.LayoutParams(AndroidUtilities.dp(20), AndroidUtilities.dp(20)))
            except Exception:
                spinner = None
            # text
            tv = TextView(context)
            tv.setTextColor(textColor)
            tv.setTextSize(TypedValue.COMPLEX_UNIT_SP, 14)
            p = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            p.leftMargin = AndroidUtilities.dp(8)
            tv.setText(text)
            chip.addView(tv, p)
            # Non-interactive
            try:
                chip.setClickable(False)
                chip.setFocusable(False)
            except Exception:
                pass
            # assemble
            params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
            params.topMargin = AndroidUtilities.dp(80)
            self.progress_overlay_container.addView(chip, params)
            container.addView(self.progress_overlay_container, FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
            self.progress_overlay = chip
        except Exception:
            pass

    def _update_progress_overlay(self, text: str):
        try:
            if self.progress_overlay_container and self.progress_overlay:
                # Find and update TextView in the chip
                for i in range(self.progress_overlay.getChildCount()):
                    child = self.progress_overlay.getChildAt(i)
                    if isinstance(child, TextView):
                        child.setText(text)
                        break
        except Exception:
            pass

    def _dismiss_progress_overlay(self):
        try:
            if self.progress_overlay_container:
                parent = self.progress_overlay_container.getParent()
                if parent:
                    parent.removeView(self.progress_overlay_container)
            self.progress_overlay_container = None
            self.progress_overlay = None
        except Exception:
            pass

    # --- Synthetic ID generator ---
    def _next_synth_id(self) -> int:
        try:
            self._last_synth_id = int(self._last_synth_id) + 1
            return self._last_synth_id
        except Exception:
            self._last_synth_id = 1
            return 1

    # --- Chat cache methods for faster lookups ---
    def _get_chat_cached(self, channel_id: int) -> Optional[Any]:
        try:
            now = time.time()
            # Cache TTL: 5 minutes
            if channel_id in self._chat_cache:
                if now - self._chat_cache_timestamp.get(channel_id, 0) < 300:
                    return self._chat_cache[channel_id]
            # Fetch from MessagesController
            mc = get_messages_controller()
            chat = mc.getChat(channel_id)
            if chat:
                self._chat_cache[channel_id] = chat
                self._chat_cache_timestamp[channel_id] = now
            else:
                pass
            return chat
        except Exception as e:
            log(f"[{self.id}] Cache error for channel {channel_id}: {e}")
            return None

    def _clear_chat_cache(self):
        """Clear chat cache (useful on plugin reload)"""
        try:
            self._chat_cache.clear()
            self._chat_cache_timestamp.clear()
        except Exception:
            pass

    # --- SQL KV helpers ---
    def _get_database(self):
        return Mandre.sql_get_database()

    def _sql_init_storage(self):
        Mandre.sql_init_kv(self.id, "wallfeed_kv")

    def _sql_kv_set(self, key: str, value: Any):
        Mandre.sql_kv_set(self.id, key, value, "wallfeed_kv")

    def _sql_kv_get(self, key: str) -> Optional[str]:
        return Mandre.sql_kv_get(self.id, key, "wallfeed_kv")

    def _sql_kv_get_int(self, key: str, default: int = 0) -> int:
        return Mandre.sql_kv_get_int(self.id, key, default, "wallfeed_kv")

    def _sql_kv_delete_prefix(self, prefix: str):
        Mandre.sql_kv_delete_prefix(self.id, prefix, "wallfeed_kv")

    def _load_ignore_and_idmap_from_sql(self):
        try:
            db = self._get_database()
            self._ignore_keys = {}
            self._id_map = {}
            if not db:
                return
            cursor = db.queryFinalized(f"SELECT k, v FROM wallfeed_kv WHERE plugin = '{self.id}' AND (k LIKE 'ignore:%' OR k LIKE 'idmap:%')")
            try:
                while cursor.next():
                    try:
                        k = cursor.stringValue(0)
                    except Exception:
                        k = None
                    try:
                        v = cursor.stringValue(1)
                    except Exception:
                        try:
                            v = str(cursor.intValue(1))
                        except Exception:
                            v = None
                    if not k:
                        continue
                    if k.startswith("ignore:"):
                        orig_key = k[len("ignore:"):]
                        if orig_key:
                            self._ignore_keys[orig_key] = True
                    elif k.startswith("idmap:"):
                        orig_key = k[len("idmap:"):]
                        if orig_key:
                            try:
                                self._id_map[orig_key] = int(v) if v is not None else 0
                            except Exception:
                                pass
            finally:
                try:
                    cursor.dispose()
                except Exception:
                    pass
        except Exception:
            pass

    def _save_ignore_and_idmap_to_sql(self):
        try:
            for k in getattr(self, '_ignore_keys', {}).keys():
                self._sql_kv_set(f"ignore:{k}", 1)
            for k, v in getattr(self, '_id_map', {}).items():
                self._sql_kv_set(f"idmap:{k}", int(v))
        except Exception:
            pass

    def _migrate_json_to_sql_once(self):
        try:
            self._sql_init_storage()
            # If there are already records, skip migration
            db = self._get_database()
            if not db:
                return
            has_rows = False
            try:
                c = db.queryFinalized(f"SELECT COUNT(1) FROM wallfeed_kv WHERE plugin = '{self.id}' LIMIT 1")
                if c.next():
                    has_rows = c.intValue(0) > 0
                try:
                    c.dispose()
                except Exception:
                    pass
            except Exception:
                pass
            if has_rows:
                return
            # Import existing JSON state if available
            try:
                if Mandre:
                    ignore = None
                    idmap = None
                    last_synth = None
                    last_read = None
                    last_sync = None
                    last_write = None
                    try:
                        ignore = Mandre.Data.read_persistent_json(self.id, PERSIST_FILE_IGNORE, {}) or {}
                        idmap = Mandre.Data.read_persistent_json(self.id, PERSIST_FILE_IDMAP, {}) or {}
                    except Exception:
                        ignore = {}
                        idmap = {}
                    try:
                        last_synth = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_SYNTH_ID)
                    except Exception:
                        last_synth = None
                    try:
                        last_read = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_READ_DATE)
                    except Exception:
                        last_read = None
                    try:
                        last_sync = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_SYNC)
                    except Exception:
                        last_sync = None
                    try:
                        last_write = Mandre.Data.read_persistent(self.id, STORAGE_KEY_LAST_WRITE_DATE)
                    except Exception:
                        last_write = None
                    # Persist to SQL
                    try:
                        for k in (ignore or {}).keys():
                            self._sql_kv_set(f"ignore:{k}", 1)
                        for k, v in (idmap or {}).items():
                            try:
                                self._sql_kv_set(f"idmap:{k}", int(v))
                            except Exception:
                                pass
                        if last_synth is not None:
                            try:
                                self._sql_kv_set("meta:last_synth_id", int(last_synth) if str(last_synth).isdigit() else str(last_synth))
                            except Exception:
                                pass
                        if last_read is not None:
                            try:
                                self._sql_kv_set("meta:last_read_date", int(last_read) if str(last_read).isdigit() else str(last_read))
                            except Exception:
                                pass
                        if last_sync is not None:
                            try:
                                self._sql_kv_set("meta:last_sync", int(last_sync) if str(last_sync).isdigit() else str(last_sync))
                            except Exception:
                                pass
                        if last_write is not None:
                            try:
                                self._sql_kv_set("meta:last_write_date", int(last_write) if str(last_write).isdigit() else str(last_write))
                            except Exception:
                                pass
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass

    # --- Settings for max posts ---
    def _get_max_posts(self) -> int:
        """Get max posts per channel from settings"""
        try:
            val = self.get_setting(SETTINGS_KEY_MAX_POSTS, "500")
            if isinstance(val, str):
                val = val.strip()
                if val.isdigit():
                    return max(10, min(int(val), 5000))  # Clamp between 10 and 5000
            elif isinstance(val, int):
                return max(10, min(val, 5000))
        except Exception:
            pass
        return 500

    def _set_max_posts(self, val: str):
        """Set max posts per channel"""
        try:
            if isinstance(val, str):
                val = val.strip()
                if val.isdigit():
                    num = max(10, min(int(val), 5000))
                    self.set_setting(SETTINGS_KEY_MAX_POSTS, str(num))
                    log(f"[{self.id}] max_posts set to {num}")
        except Exception as e:
            log(f"[{self.id}] _set_max_posts error: {e}")


class _DialogsCreateViewHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        frag = param.thisObject
        try:
            self.plugin._ensure_header_in_dialogs(frag)
        except Exception as e:
            log(f"[wall_feed] after createView error: {e}")


class _DialogsOnResumeHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        frag = param.thisObject
        try:
            # Only ensure header; background sync runs on its own schedule
            self.plugin._ensure_header_in_dialogs(frag)
        except Exception as e:
            log(f"[wall_feed] after onResume error: {e}")


class _GetDialogsArrayHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            res = param.getResult()
            if res is None:
                return
            # res is java.util.ArrayList
            # Inject synthetic dialog at position 0 if not present
            try:
                # Only inject for main folder (folderId == 0)
                folderId = param.args[2]
                if folderId != 0:
                    return
                size = res.size()
                exists = False
                for i in range(size):
                    d = res.get(i)
                    if hasattr(d, 'id') and d.id == self.plugin.WALL_DIALOG_ID:
                        exists = True
                        break
                if not exists:
                    d = TLRPC.TL_dialog()
                    d.id = self.plugin.WALL_DIALOG_ID
                    d.peer = TLRPC.TL_peerChannel()
                    d.peer.channel_id = self.plugin.WALL_CHAT_ID
                    d.pinned = False
                    res.add(0, d)
                    param.setResult(res)
            except Exception as e:
                log(f"[{self.plugin.id}] inject dialog error: {e}")
        except Exception as e:
            log(f"[{self.plugin.id}] getDialogsArray hook error: {e}")


class _DialogsOnBindHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            adapter = param.thisObject  # org.telegram.ui.Adapters.DialogsAdapter
            holder = param.args[0]
            pos = param.args[1]
            itemView = holder.itemView
            # Only modify our synthetic dialog item
            try:
                getItem = adapter.getClass().getDeclaredMethod("getItem", jclass('java.lang.Integer').TYPE)
                getItem.setAccessible(True)
                item = getItem.invoke(adapter, jclass('java.lang.Integer').valueOf(pos))
            except Exception:
                item = None

            try:
                if item is not None and isinstance(item, TLRPC.Dialog) and getattr(item, 'id', 0) == self.plugin.WALL_DIALOG_ID:
                    if isinstance(itemView, DialogCell):
                        # Build custom dialog with proper avatar and title
                        custom = DialogCell.CustomDialog()
                        custom.name = self.plugin._get_channel_name()
                        custom.message = self.plugin._get_unread_msg(self.plugin.unread_count)
                        itemView.setDialog(custom)
                        try:
                            # Ensure MessagesController has chat with proper title
                            mc = get_messages_controller()
                            chat = mc.getChat(self.plugin.WALL_CHAT_ID)
                            if chat is None:
                                chat = TLRPC.TL_chat()
                                chat.id = self.plugin.WALL_CHAT_ID
                                chat.title = self.plugin._get_channel_name()
                                mc.putChat(chat, True)
                        except Exception:
                            pass

                        def on_click(_):
                            try:
                                self.plugin.open_wall_feed()
                            except Exception as e:
                                log(f"[{self.plugin.id}] open_wall_feed error: {e}")
                        itemView.setOnClickListener(OnClickListener(on_click))
            except Exception:
                pass
        except Exception as e:
            log(f"[{self.plugin.id}] onBind hook error: {e}")


class _GetDialogsHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            res = param.getResult()
            if res is None:
                return
            try:
                # Ensure dialogs list contains our dialog
                size = res.size()
                exists = False
                for i in range(size):
                    d = res.get(i)
                    if hasattr(d, 'id') and d.id == self.plugin.WALL_DIALOG_ID:
                        exists = True
                        break
                if not exists:
                    d = TLRPC.TL_dialog()
                    d.id = self.plugin.WALL_DIALOG_ID
                    d.peer = TLRPC.TL_peerChat()
                    d.peer.chat_id = self.plugin.WALL_CHAT_ID
                    d.pinned = True
                    res.add(0, d)
                    param.setResult(res)
            except Exception as e:
                log(f"[{self.plugin.id}] ensure MC.getDialogs wall: {e}")
        except Exception as e:
            log(f"[{self.plugin.id}] MC.getDialogs hook error: {e}")


class _ChatActivityCreateHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_act = param.thisObject
            did = 0
            try:
                did = get_private_field(chat_act, "dialog_id")
            except Exception:
                pass
            if did == self.plugin.WALL_DIALOG_ID:
                # Set saved-mode UI flags so avatars/titles render like saved forward view
                try:
                    set_private_field(chat_act, "mode", ChatActivity.MODE_SAVED)
                except Exception:
                    pass
                # Scroll to first unread based on last_read_date
                try:
                    last_read = self.plugin._get_last_read_date()
                    target_id = 0
                    for did2, msg, date in self.plugin.messages_cache:
                        if date > last_read:
                            orig_peer = getattr(msg, 'peer_id', None)
                            ch_id = None
                            if orig_peer and hasattr(orig_peer, 'channel_id') and orig_peer.channel_id:
                                ch_id = int(orig_peer.channel_id)
                            key = f"{ch_id or did2}:{msg.id}"
                            sid = self.plugin._id_map.get(key)
                            if sid:
                                target_id = int(sid)
                            break
                    if target_id:
                        try:
                            scrollToMessageId = chat_act.getClass().getDeclaredMethod(
                                "scrollToMessageId",
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Boolean').TYPE,
                                jclass('java.lang.Integer').TYPE,
                                jclass('java.lang.Boolean').TYPE,
                                jclass('java.lang.Integer').TYPE
                            )
                            scrollToMessageId.setAccessible(True)
                            scrollToMessageId.invoke(chat_act,
                                jclass('java.lang.Integer').valueOf(target_id),
                                jclass('java.lang.Integer').valueOf(0),
                                jclass('java.lang.Boolean').valueOf(True),
                                jclass('java.lang.Integer').valueOf(0),
                                jclass('java.lang.Boolean').valueOf(True),
                                jclass('java.lang.Integer').valueOf(0)
                            )
                        except Exception:
                            pass
                except Exception:
                    pass
        except Exception as e:
            log(f"[{self.plugin.id}] ChatActivity createView hook error: {e}")

class _ChatActivityPauseHook:
    def __init__(self, plugin: WallFeedPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_act = param.thisObject
            did = 0
            try:
                did = get_private_field(chat_act, "dialog_id")
            except Exception:
                pass
            if did == self.plugin.WALL_DIALOG_ID:
                # On leaving wall, mark last_read_date to max written date
                try:
                    storage_last = Mandre.Data.read_persistent(self.plugin.id, STORAGE_KEY_LAST_WRITE_DATE)
                    if isinstance(storage_last, int) and storage_last:
                        self.plugin._set_last_read_date(storage_last)
                except Exception:
                    pass
        except Exception as e:
            log(f"[{self.plugin.id}] ChatActivity onPause hook error: {e}")
