__id__ = "randomizer_plugin"
__name__ = "Universal Randomizer"
__description__ = "Генерирует указанное количество случайных элементов из списка, заданного в настройках. Поддерживает ID, username, адреса, числа, слова и т.д. Команды: .rnd, .set, .clr, .add"
__author__ = "Raitorinkus"
__version__ = "1.1.0"  # Updated commands and added success dialogs
__icon__ = "RTnKs/0"
__min_version__ = "11.12.0"

import random
import traceback
from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import send_message, log, get_last_fragment
from android_utils import run_on_ui_thread
from markdown_utils import parse_markdown
from ui.settings import Header, Text, Divider, Switch, Input
from org.telegram.tgnet import TLRPC
from java.util import ArrayList, Locale
from android.app import AlertDialog
from ui.alert import AlertDialogBuilder


class UniversalRandomizerPlugin(BasePlugin):
    def create_settings(self):
        settings = [
            Header(text="Настройки Universal Randomizer"),
            Text(text="Общие настройки", icon="msg_settings", create_sub_fragment=self.create_general_settings),
            Text(text="Параметры вывода", icon="filled_button_share_solar", create_sub_fragment=self.create_output_settings),
            Text(text="Настройки диалогов", icon="msg_info", create_sub_fragment=self.create_dialog_settings),
            Divider(text=(
                "Команды:\n"
                ".rnd — генерация случайных элементов\n"
                ".set — просмотр настроек\n"
                ".clr — очистка списка\n"
                ".add — добавление элементов\n"
                "Пример: .add @user1,@user2"
            ))
        ]
        log("Settings created successfully")
        return settings

    def create_general_settings(self):
        return [
            Input(
                key="item_list",
                text="Список элементов",
                default="",
                subtext="Введите элементы через запятую (например: @user1,123,New York). Без ограничений по количеству."
            ),
            Input(
                key="selection_count",
                text="Количество выборов",
                default="1",
                subtext="Укажите число от 1 до 10000."
            )
        ]

    def create_dialog_settings(self):
        return [
            Header(text="Настройки диалогов"),
            Switch(
                key="show_settings_in_dialog",
                text="Настройки .set в диалоге",
                icon="msg_info",
                subtext="Команда .set будет открывать диалоговое окно вместо отправки в чат",
                default=True
            ),
            Switch(
                key="show_errors_in_dialog",
                text="Ошибки в диалоге",
                icon="msg_help",
                subtext="Ошибки команд будут показываться в диалоговых окнах",
                default=True
            ),
            Switch(
                key="show_success_in_dialog",
                text="Успешные операции в диалоге",
                icon="msg_check",
                subtext="Сообщения об успешном добавлении и очистке будут показываться в диалоговых окнах",
                default=True
            ),
        ]

    def create_output_settings(self):
        return [
            Switch(
                key="sort_asc",
                text="Сортировка по алфавиту (А-Я)",
                default=False,
                subtext="Сортировать элементы от А до Я.",
                on_change=lambda value: self._update_sort_settings("sort_asc", value)
            ),
            Switch(
                key="sort_desc",
                text="Сортировка по алфавиту (Я-А)",
                default=False,
                subtext="Сортировать элементы от Я до А.",
                on_change=lambda value: self._update_sort_settings("sort_desc", value)
            ),
            Switch(
                key="sort_len_asc",
                text="Сортировка по длине (короткие первые)",
                default=False,
                subtext="Сортировать элементы от коротких к длинным.",
                on_change=lambda value: self._update_sort_settings("sort_len_asc", value)
            ),
            Switch(
                key="sort_len_desc",
                text="Сортировка по длине (длинные первые)",
                default=False,
                subtext="Сортировать элементы от длинных к коротким.",
                on_change=lambda value: self._update_sort_settings("sort_len_desc", value)
            ),
            Switch(
                key="use_blockquote",
                text="Выводить в цитате",
                default=False,
                subtext="Если включено, результат будет отображаться в цитате."
            )
        ]

    def _update_sort_settings(self, key, value):
        """Ensure only one sort option is enabled at a time."""
        if value:
            sort_keys = ["sort_asc", "sort_desc", "sort_len_asc", "sort_len_desc"]
            for other_key in sort_keys:
                if other_key != key:
                    self.set_setting(other_key, False)

    def _get_parsed_items(self):
        """Get parsed list of items, cached for performance."""
        item_list = self.get_setting("item_list", "").strip()
        if not item_list:
            return []
        return [item.strip() for item in item_list.split(",") if item.strip()]

    def on_plugin_load(self):
        log("on_plugin_load called")
        self.add_on_send_message_hook()
        log("add_on_send_message_hook called")
        log("Плагин Universal Randomizer загрузился успешно!")

    def show_smart_error_dialog(self, error_type, details=None):
        """Показывает умное диалоговое окно с анализом конкретной ситуации"""
        show_in_dialog = self.get_setting("show_errors_in_dialog", True)
        if show_in_dialog:
            run_on_ui_thread(lambda: self._show_smart_error_dialog_ui(error_type, details))

    def show_success_dialog(self, title, message):
        """Показывает диалоговое окно с сообщением об успешной операции"""
        show_in_dialog = self.get_setting("show_success_in_dialog", True)
        log(f"show_success_dialog called: title='{title}', message='{message}', show_in_dialog={show_in_dialog}")
        if show_in_dialog:
            log("Calling _show_success_dialog_ui on UI thread")
            run_on_ui_thread(lambda: self._show_success_dialog_ui(title, message))
        else:
            log("Success dialog disabled in settings")

    def _show_success_dialog_ui(self, title, message):
        """UI функция для диалога успешной операции"""
        log(f"_show_success_dialog_ui called: title='{title}', message='{message}'")
        try:
            fragment = get_last_fragment()
            log(f"Fragment: {fragment}")
            activity = fragment.getParentActivity() if fragment else None
            log(f"Activity: {activity}")

            if not activity:
                log("No activity found, cannot show dialog")
                return

            log("Creating AlertDialogBuilder")
            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_message(message)
            builder.set_positive_button("ОК", lambda b, w: b.dismiss())
            builder.set_cancelable(True)
            log("Showing dialog")
            builder.show()
            log("Dialog shown successfully")

        except Exception as e:
            log(f"Error showing success dialog: {e}")
            import traceback
            log(f"Traceback: {traceback.format_exc()}")
            # Fallback для старых версий Android
            pass

    def _show_smart_error_dialog_ui(self, error_type, details):
        """UI функция для умного диалога ошибки"""
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                return

            title, message = self._analyze_randomizer_error_situation(error_type, details)

            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_message(message)
            builder.set_positive_button("Понятно", lambda b, w: b.dismiss())
            builder.set_cancelable(True)
            builder.show()

        except Exception as e:
            log(f"Error showing error dialog: {e}")
            # Fallback для старых версий Android
            pass

    def _analyze_randomizer_error_situation(self, error_type, details):
        """Анализирует конкретную ситуацию и возвращает подходящее сообщение"""

        if error_type == "empty_list":
            title = "📝 Пустой список"
            message = (
                "Список элементов для рандомизации пуст.\n\n"
                "🔧 Как добавить элементы:\n"
                "• Используйте команду .add\n"
                "• Или зайдите в настройки плагина\n"
                "• Введите элементы через запятую\n\n"
                "💡 Примеры:\n"
                "• .add @user1,@user2,@user3\n"
                "• .add 1,2,3,4,5\n"
                "• .add Москва,Лондон,Париж"
            )

        elif error_type == "invalid_count":
            count = details or "???"
            title = "🔢 Неверное количество"
            message = (
                f"Количество '{count}' некорректно.\n\n"
                "✅ Правильные значения:\n"
                "• Положительные числа: 1, 2, 3...\n"
                "• Максимум: количество элементов в списке\n\n"
                "❌ Неправильно:\n"
                "• Отрицательные числа: -1, -5\n"
                "• Ноль: 0\n"
                "• Текст: abc, много\n"
                "• Больше элементов в списке\n\n"
                "💡 Проверьте настройки плагина"
            )

        elif error_type == "count_exceeds_list":
            count = details.get("count", "???") if details else "???"
            list_size = details.get("list_size", "???") if details else "???"
            title = "📊 Слишком много элементов"
            message = (
                f"Запрошено {count} элементов, но в списке только {list_size}.\n\n"
                "🔧 Варианты решения:\n"
                "• Уменьшите количество в настройках\n"
                "• Добавьте больше элементов в список\n"
                "• Используйте .add для пополнения\n\n"
                "💡 Текущий список можно посмотреть командой .set"
            )

        elif error_type == "invalid_add_format":
            title = "📝 Неверный формат добавления"
            message = (
                "Не удалось распознать элементы для добавления.\n\n"
                "✅ Правильный формат:\n"
                ".add элемент1,элемент2,элемент3\n\n"
                "💡 Примеры:\n"
                "• .add @user1,@user2\n"
                "• .add 100,200,300\n"
                "• .add Москва,Лондон\n"
                "• .add красный,синий,зелёный\n\n"
                "❌ Избегайте:\n"
                "• Пустых элементов между запятыми\n"
                "• Только пробелов"
            )

        elif error_type == "no_valid_elements":
            title = "🚫 Нет валидных элементов"
            message = (
                "После обработки не осталось валидных элементов.\n\n"
                "🔍 Возможные причины:\n"
                "• Все элементы состоят только из пробелов\n"
                "• Список содержит только запятые\n"
                "• Элементы были удалены при фильтрации\n\n"
                "💡 Проверьте содержимое списка в настройках"
            )

        else:  # unexpected_error
            title = "⚠️ Неожиданная ошибка"
            message = (
                "Произошла непредвиденная ошибка в рандомайзере.\n\n"
                "🔧 Попробуйте:\n"
                "• Повторить команду\n"
                "• Проверить настройки плагина\n"
                "• Очистить и заново заполнить список\n"
                "• Перезапустить приложение\n\n"
                "📝 Доступные команды:\n"
                "• .rnd — генерация\n"
                "• .set — просмотр настроек\n"
                "• .clr — очистка списка\n"
                "• .add — добавление элементов"
            )

        return title, message

    def _show_settings_dialog(self, settings_text):
        """Показывает настройки в диалоговом окне"""
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                return

            title = "Настройки Randomizer"
            ok_button = "ОК"

            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_message(settings_text)
            builder.set_positive_button(ok_button, lambda b, w: b.dismiss())
            builder.set_cancelable(True)
            builder.show()

        except Exception:
            pass  # Тихо игнорируем ошибки диалога

    def on_send_message_hook(self, account, params) -> HookResult:
        # Only process text messages that are valid commands
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult(strategy=HookStrategy.PASS)

        text = params.message.strip()
        if not text:
            return HookResult(strategy=HookStrategy.PASS)

        # Check if the message is a valid command
        if not (text.startswith(".rnd") or text == ".rnd" or
                text.startswith(".set") or text == ".set" or
                text.startswith(".clr") or text == ".clr" or
                text.startswith(".add") or text == ".add"):
            return HookResult(strategy=HookStrategy.PASS)

        # .set
        if text.startswith(".set") or text == ".set":
            item_list = self.get_setting("item_list", "").strip()
            selection_count = self.get_setting("selection_count", "1")
            sort_asc = self.get_setting("sort_asc", False)
            sort_desc = self.get_setting("sort_desc", False)
            sort_len_asc = self.get_setting("sort_len_asc", False)
            sort_len_desc = self.get_setting("sort_len_desc", False)
            use_blockquote = self.get_setting("use_blockquote", False)
            items = self._get_parsed_items()
            item_count = len(items)
            sort_type_display = (
                "По алфавиту (А-Я)" if sort_asc else
                "По алфавиту (Я-А)" if sort_desc else
                "По длине (короткие первые)" if sort_len_asc else
                "По длине (длинные первые)" if sort_len_desc else
                "Без сортировки"
            )
            settings_text = (
                f"⚙️ Текущие настройки:\n"
                f"- Количество элементов: {item_count}\n"
                f"- Количество выборов: {selection_count}\n"
                f"- Тип сортировки: {sort_type_display}\n"
                f"- Выводить в цитате: {'Включено' if use_blockquote else 'Выключено'}\n"
                f"- Первые 5 элементов: {', '.join(items[:5] + ['...'] if item_count > 5 else items) if items else 'Пусто'}"
            )
            # Проверяем настройку диалогов
            show_in_dialog = self.get_setting("show_settings_in_dialog", True)
            if show_in_dialog:
                run_on_ui_thread(lambda: self._show_settings_dialog(settings_text))
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                # Показываем в чате
                parsed = parse_markdown(settings_text)
                params.message = parsed.text
                params.entities = parsed.entities if parsed.entities else ArrayList()
                log("Settings displayed successfully")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        # .clr
        if text.startswith(".clr") or text == ".clr":
            log("Processing .clr")
            self.set_setting("item_list", "")

            # Показываем диалог или отправляем в чат
            success_message = "🧹 Список элементов очищен."
            show_in_dialog = self.get_setting("show_success_in_dialog", True)
            log(f"Clear command: show_in_dialog={show_in_dialog}")
            if show_in_dialog:
                log("Showing clear success dialog")
                self.show_success_dialog("Список очищен", success_message)
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                log("Sending clear success message to chat")
                params.message = success_message
                params.entities = ArrayList()
                log("List cleared successfully")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        # .add
        if text.startswith(".add") or text == ".add":
            new_items = text[len(".add"):].strip()
            if not new_items:
                self.show_smart_error_dialog("invalid_add_format")
                return HookResult(strategy=HookStrategy.CANCEL)
            current_items = set(self._get_parsed_items())
            new_items_list = [item.strip() for item in new_items.split(",") if item.strip()]
            added_items = [item for item in new_items_list if item not in current_items]
            if not added_items:
                error_message = "❌ Все указанные элементы уже есть в списке."
                show_in_dialog = self.get_setting("show_success_in_dialog", True)
                if show_in_dialog:
                    self.show_success_dialog("Элементы не добавлены", error_message)
                    return HookResult(strategy=HookStrategy.CANCEL)
                else:
                    params.message = error_message
                    params.entities = ArrayList()
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
            current_items.update(added_items)
            updated_list = ",".join(current_items)
            self.set_setting("item_list", updated_list)

            # Показываем диалог или отправляем в чат
            success_message = f"✅ Добавлено: {', '.join(added_items)}"
            show_in_dialog = self.get_setting("show_success_in_dialog", True)
            log(f"Add command: show_in_dialog={show_in_dialog}")
            if show_in_dialog:
                log("Showing add success dialog")
                self.show_success_dialog("Элементы добавлены", success_message)
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                log("Sending add success message to chat")
                params.message = success_message
                params.entities = ArrayList()
                log(f"Added items: {', '.join(added_items)}")
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        # .rnd
        items = self._get_parsed_items()
        sort_asc = self.get_setting("sort_asc", False)
        sort_desc = self.get_setting("sort_desc", False)
        sort_len_asc = self.get_setting("sort_len_asc", False)
        sort_len_desc = self.get_setting("sort_len_desc", False)
        use_blockquote = self.get_setting("use_blockquote", False)
        try:
            selection_count = int(self.get_setting("selection_count", "1"))
            if selection_count < 1 or selection_count > 10000:
                self.show_smart_error_dialog("invalid_count", str(selection_count))
                return HookResult(strategy=HookStrategy.CONTINUE)
        except ValueError:
            invalid_count = self.get_setting("selection_count", "1")
            self.show_smart_error_dialog("invalid_count", invalid_count)
            return HookResult(strategy=HookStrategy.CONTINUE)

        if not items:
            self.show_smart_error_dialog("empty_list")
            return HookResult(strategy=HookStrategy.CONTINUE)

        if selection_count > len(items):
            self.show_smart_error_dialog("count_exceeds_list", {
                "count": selection_count,
                "list_size": len(items)
            })
            return HookResult(strategy=HookStrategy.CONTINUE)

        try:
            selected_items = random.sample(items, selection_count)
            if sort_asc:
                selected_items.sort()
            elif sort_desc:
                selected_items.sort(reverse=True)
            elif sort_len_asc:
                selected_items.sort(key=len)
            elif sort_len_desc:
                selected_items.sort(key=len, reverse=True)

            result_text = f"🎲 Случайно выбрано {selection_count} элемент(ов):\n" + "\n".join([f"- {item}" for item in selected_items])
            parsed = parse_markdown(result_text)
            params.message = parsed.text
            params.entities = parsed.entities if parsed.entities else ArrayList()

            if use_blockquote:
                entity = TLRPC.TL_messageEntityBlockquote()
                entity.collapsed = True
                entity.offset = 0
                entity.length = len(params.message.encode("utf-16-le")) // 2
                params.entities.add(entity)

            log(f"Random selection successful: {len(selected_items)} items selected")
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        except Exception as e:
            self.show_smart_error_dialog("unexpected_error")
            log(f"Error in random selection: {traceback.format_exc()}")
            return HookResult(strategy=HookStrategy.CONTINUE)

    def send_response(self, peer, msg, entities=None):
        log(f"send_response called with peer={peer}, msg={msg}, entities={entities}")
        message_params = {
            "peer": peer,
            "message": msg
        }
        if entities:
            message_params["entities"] = entities
            log(f"Entities attached: {entities}")
        else:
            log("No entities attached")
        run_on_ui_thread(lambda: send_message(message_params))
        log(f"Response sent: {msg}")

    def send_error(self, peer, msg):
        run_on_ui_thread(lambda: send_message({
            "peer": peer,
            "message": f"❌ {msg}"
        }))
        log(f"Error sent: {msg}")