"""
Если вы при разработке своего плагина использовали готовые фрагменты кода из моего, пожалуйста,
укажите в описании своего плагина @zwylair в качестве благодарности за вклад в разработку. Спасибо ♥

If you used code snippets from my plugin in the development of your own, please credit @zwylair
in your plugin’s description as a thank you for the contribution. Thanks ♥


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⣀⣠⣤⣤⣤⣄⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠿⠛⠛⠛⠛⠛⢿⣷⣤⣾⠿⠛⠛⠙⠛⠛⠿⠗
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡿⠁⠀⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⠀⢀⣤⣀⠀⠀⢀⣤⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣧⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠀⣿⣷⣄⣀⣤⡄⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣁⣤⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠘⠛⠛⠛⠻⣿⣿⣿⠋⠉⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠹⣿⡟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠟⢙⠛⠛⠀⠀⠀⠀⠀⠀⣀⣴⡿⠓⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠈⠻⢿⣦⣄⠀⣠⣾⡿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀
"""

import traceback
from typing import Any, Dict, Callable, List

from ui.settings import Header, Switch, Text
from hook_utils import get_private_field, set_private_field
from client_utils import get_messages_controller
from base_plugin import BasePlugin, HookStrategy, HookResult, XposedHook

from java import jclass
from java.util import Locale, ArrayList
from java.lang import Boolean, Integer, Long
from android.view import View
from org.telegram.messenger import MessageObject
from org.telegram.tgnet import TLRPC, TLObject

__name__ = "NoForwardLimit"
__description__ = "Removes the limit of 100 forward messages (requires zwylib)"
__icon__ = "zwyPluginsIcons/6"
__id__ = "zwyNoForwardLimit"
__version__ = "1.1.2"
__author__ = "@zwylair"
__min_version__ = "11.12.1"


def get_selected_msgs_array_index(param):
    message_object = param.args[0]
    dialog_id = get_private_field(param.thisObject, "dialog_id")
    return int(message_object.getDialogId() != dialog_id)


def update_reply_button_visibility(chat_activity, selected_only_one_message: bool):
    logger.info("updating reply button visibility")
    reply_button = get_private_field(chat_activity, "replyButton")
    reply_button.setVisibility(View.VISIBLE if selected_only_one_message else View.GONE)


def update_select_button_visibility(chat_activity):
    logger.info("updating select button visibility")

    java_msgs = get_private_field(chat_activity, "selectedMessagesIds")
    java_msgs_main = java_msgs[0]
    messages = get_private_field(chat_activity, "messages")
    select_button = get_private_field(chat_activity, "selectButton")
    new_select_visibility = View.GONE

    if select_button is None:
        return

    if java_msgs_main.size() > 1:
        all_selected_msg_ids = get_sparsearray_keys(java_msgs_main) + get_sparsearray_keys(java_msgs[1])

        all_selected_msg_ids.sort()
        begin = all_selected_msg_ids[0]
        end = all_selected_msg_ids[-1]

        for i in range(messages.size()):
            msg = messages.get(i)
            msg_id = msg.getId()

            is_in_bounds = begin < msg_id < end
            is_selected = java_msgs_main.indexOfKey(msg_id) >= 0

            if is_in_bounds and not is_selected and msg.contentType == 0:
                new_select_visibility = View.VISIBLE
                break

    # FUCK ANIMATION YOYOUYOUYYUOYU
    select_button_animator = get_private_field(chat_activity, "selectButtonAnimation")
    if select_button_animator:
        select_button_animator.cancel()

    current_visibility = select_button.getVisibility()
    if current_visibility != new_select_visibility:
        if new_select_visibility == View.VISIBLE:
            select_button.setVisibility(View.VISIBLE)
            select_button.setAlpha(1.0)
            select_button.setScaleY(1.0)
        else:
            select_button.setAlpha(0.0)
            select_button.setScaleY(0.0)
            select_button.setVisibility(View.GONE)


def get_sparsearray_keys(sparse_array):
    return [sparse_array.keyAt(i) for i in range(sparse_array.size())]


def switch_debug_mode(new_value: bool):
    global debug_mode
    debug_mode = new_value


def cancel_selection_mode(chat_activity):
    clazz = chat_activity.getClass()

    hide_action_mode_method = clazz.getDeclaredMethod("hideActionMode")
    hide_action_mode_method.setAccessible(True)
    hide_action_mode_method.invoke(chat_activity)

    update_pinned_msg_view_method = clazz.getDeclaredMethod("updatePinnedMessageView", Boolean.TYPE)
    update_pinned_msg_view_method.setAccessible(True)
    update_pinned_msg_view_method.invoke(chat_activity, [True])


def split_list_into_chunks(lst: List[int], chunk_size: int) -> List[List[int]]:
    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]


def arraylist_to_list(array_list) -> list:
    return [array_list.get(i) for i in range(array_list.size())]


def list_to_arraylist(input_list: list) -> ArrayList:
    arr = ArrayList()
    for obj in input_list:
        arr.add(Integer(obj))
    return arr


def decrement_cant_forward_count(chat_activity):
    cant_forward_msgs_count = get_private_field(chat_activity, "cantForwardMessagesCount")
    cant_forward_msgs_count -= 2  # -2, cuz 1 was added when the message was added, and another 1 cuz it was added right before the current hook call

    logger.info(f"[after] decrementing cantForwardMessagesCount. new value: {cant_forward_msgs_count}")
    set_private_field(chat_activity, "cantForwardMessagesCount", Integer(cant_forward_msgs_count))

    if cant_forward_msgs_count == 0:
        forward_button = get_private_field(chat_activity, "forwardButton")
        forward_button.setEnabled(True)
        forward_button.setAlpha(1.0)


def decrement_cant_delete_count(chat_activity):
    cant_delete_messages_count = get_private_field(chat_activity, "cantDeleteMessagesCount")
    cant_delete_messages_count -= 2  # -2, cuz 1 was added when the message was added, and another 1 cuz it was added right before the current hook call

    logger.info(f"[after] decrementing cantDeleteMessagesCount. new value: {cant_delete_messages_count}")
    set_private_field(chat_activity, "cantDeleteMessagesCount", Integer(cant_delete_messages_count))

    if cant_delete_messages_count == 0:
        delete_item = get_private_field(chat_activity, "deleteItem")
        delete_item.setVisibility(View.VISIBLE)


class SelectorHook(XposedHook):
    def __init__(self):
        super().__init__()
        self.messages_array: Dict[int, MessageObject] = {}
        self.is_processing_msg_group = False
        self.is_last_in_group = False
        self.handle_end_of_select_msg_group_call = False

    def before_hooked_method(self, param):
        selected_msg_obj = param.args[0]
        tapped_outside: bool = param.args[1]
        is_last: bool = param.args[2]
        is_grouped = selected_msg_obj.getGroupId() != 0

        if self.is_processing_msg_group:
            self.is_last_in_group = is_last
            logger.info(f"[before] selected group member (msg_id={selected_msg_obj.getId()}, last={self.is_last_in_group})")
            return

        if tapped_outside and is_last and is_grouped:
            logger.info(f"[before] started selection of a group (with replaced array) (msg_id={selected_msg_obj.getId()})")
            self.is_processing_msg_group = True

        # replace selected messages array
        index = get_selected_msgs_array_index(param)
        java_msgs = get_private_field(param.thisObject, "selectedMessagesIds")
        java_msgs[index] = param.thisObject.SparseArrayWithTouch()
        set_private_field(param.thisObject, "selectedMessagesIds", java_msgs)

    def after_hooked_method(self, param):
        if self.handle_end_of_select_msg_group_call:
            self.handle_end_of_select_msg_group_call = False
            return

        if self.is_processing_msg_group:
            if not self.is_last_in_group:
                return

            logger.info("[after] ended selection of group")

            self.is_processing_msg_group = False
            self.is_last_in_group = False
            self.handle_end_of_select_msg_group_call = True

        chat_activity = param.thisObject
        # selected_msg_obj = param.args[0]
        # tapped_outside: bool = param.args[1]
        # is_last: bool = param.args[2]

        index = get_selected_msgs_array_index(param)
        selected_msgs_arrays = get_private_field(chat_activity, "selectedMessagesIds")
        selected_msgs_array = selected_msgs_arrays[index]
        # selected_msg_id = selected_msg_obj.getId()

        chat_mode = get_private_field(chat_activity, "chatMode")
        current_chat = get_private_field(chat_activity, "currentChat")
        is_in_schedule_mode = chat_mode == 1

        # logger.info(f"[after] message_id={selected_msg_id}, tapped_outside={tapped_outside}, is_last={is_last}")

        # add/remove new messages to/from local db
        for index in reversed(range(selected_msgs_array.size())):
            message_id = selected_msgs_array.keyAt(index)
            message_object = selected_msgs_array.get(message_id)

            if message_id in self.messages_array.keys():
                logger.info(f"[after] unselecting message id: {message_id}")

                if not message_object.canForwardMessage():
                    decrement_cant_forward_count(chat_activity)

                if not message_object.canDeleteMessage(is_in_schedule_mode, current_chat):
                    decrement_cant_delete_count(chat_activity)

                self.messages_array.pop(message_id)
            else:
                logger.info(f"[after] selecting message id: {message_id}")
                self.messages_array[message_id] = message_object

        # sort only to make the log output in the same order as the java array
        if debug_mode:
            self.messages_array = dict(sorted(self.messages_array.items()))

        # restore selected messages
        selected_msgs_array.clear()
        for k, v in self.messages_array.items():
            selected_msgs_array.put(k, v)

        # handle no messages selected case
        if len(self.messages_array) == 0:
            cancel_selection_mode(chat_activity)
            return

        logger.info(f"[after] local db: {self.messages_array}")
        logger.info(f"[after] java db: {selected_msgs_array}")

        # set full selected messages array
        set_private_field(chat_activity, "selectedMessagesIds", selected_msgs_arrays)
        update_reply_button_visibility(chat_activity, len(self.messages_array) == 1)
        update_select_button_visibility(chat_activity)

        # separator
        for _ in range(3):
            logger.info("[after] \n")

    def clear_message_storage(self):
        logger.info("clearing local select db")
        self.messages_array.clear()


class ClearSelectionHook(XposedHook):
    def before_hooked_method(self, param):
        selector_hook.clear_message_storage()


class MultiSelectorHook(XposedHook):
    def __init__(self, hook_method: Callable):
        super().__init__()
        self.hook_method = hook_method

    class BypassLimitReachedHook:
        def replace_hooked_method(self, _param):
            return False

    def after_hooked_method(self, param):
        chat_list_view = get_private_field(param.thisObject, "chatListView")
        selection_listener = get_private_field(chat_list_view, "multiSelectionListener")
        method = selection_listener.getClass().getMethod("limitReached")
        self.hook_method(method, self.BypassLimitReachedHook())


class DeleteMessagesHook(XposedHook):
    def before_hooked_method(self, param):
        first_msg_array = param.args[0]
        second_msg_array = param.args[1]

        if first_msg_array.size() > 0:
            java_msgs = first_msg_array
            selected_msg_array_arg_index = 0
        else:
            java_msgs = second_msg_array
            selected_msg_array_arg_index = 1

        messages: List[int] = arraylist_to_list(java_msgs)
        chunk_size = 100

        logger.info(f"got messages list (size={len(messages)})")

        if len(messages) <= chunk_size:
            logger.info(f"{len(messages)} <= {chunk_size}. split skipped.")

            # separator
            for _ in range(5):
                logger.info("")
            return

        message_ids_chunks: List[List[int]] = split_list_into_chunks(messages, chunk_size)
        last_chunk_index = len(message_ids_chunks) - 1

        logger.info(f"split to {len(message_ids_chunks)} chunks of ~{chunk_size}")

        for index, chunk in enumerate(message_ids_chunks):
            preview = ", ".join(map(str, chunk[:5]))
            logger.info(f"\t[chunk {index}] {preview}, ...")

            param.args[selected_msg_array_arg_index] = list_to_arraylist(chunk)

            if index < last_chunk_index:
                param.method.invoke(param.thisObject, param.args)

        # separator
        for _ in range(5):
            logger.info("")


class Locales:
    en = {
        "zwylib_was_not_found": "ZwyLib plugin required for this plugin is not found!",
        "install_bulletin_button": "Install",
        "debug_message_info": "Switch the debug mode off in plugin prefs",
        "debug_mode_label": "Debug mode",
        "debug_mode_hint": "Prints some info to logcat",
    }
    ru = {
        "zwylib_was_not_found": "Требуемый плагин ZwyLib не найден!",
        "install_bulletin_button": "Установить",
        "debug_message_info": "Отключите режим отладки в настройках плагина",
        "debug_mode_label": "Режим отладки",
        "debug_mode_hint": "Написывает всякую инфу в logcat",
    }
    uk = {
        "zwylib_was_not_found": "Не знайдено обов’язковий плагін ZwyLib!",
        "install_bulletin_button": "Встановити",
        "debug_message_info": "Вимкніть режим налагодження у налаштуваннях плагіна",
        "debug_mode_label": "Режим налагодження",
        "debug_mode_hint": "Написує всяку інформацію у logcat",
    }
    default = en


def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, key)


AUTOUPDATE_CHANNEL_ID = 2521243181
AUTOUPDATE_MSG_ID = 53
LOG_PREFIX = __name__
LOCALE = Locale.getDefault().getLanguage()

DEFAULT_DEBUG_MODE = False

try:
    import zwylib
except (ImportError, ModuleNotFoundError):
    raise Exception(localise("zwylib_was_not_found"))

selector_hook = SelectorHook()
debug_mode = bool(DEFAULT_DEBUG_MODE)
logger = zwylib.build_log(LOG_PREFIX)
BulletinHelper = zwylib.build_bulletin_helper(LOG_PREFIX)


class NoForwardLimit(BasePlugin):
    def on_plugin_load(self):
        global debug_mode
        debug_mode = self.get_setting("debug_mode", DEFAULT_DEBUG_MODE)

        zwylib.add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)

        self.add_on_send_message_hook()
        self.add_hook("TL_messages_forwardMessages")

        clazz = jclass("org.telegram.ui.ChatActivity").getClass()

        selector_method = clazz.getDeclaredMethod("addToSelectedMessages", MessageObject, Boolean.TYPE, Boolean.TYPE)
        selector_method.setAccessible(True)
        self.hook_method(selector_method, selector_hook)

        clear_selection_method = clazz.getDeclaredMethod("hideActionMode")
        clear_selection_method.setAccessible(True)
        self.hook_method(clear_selection_method, ClearSelectionHook())

        multi_selector_method = clazz.getDeclaredMethod("startMultiselect", Integer.TYPE)
        multi_selector_method.setAccessible(True)
        self.hook_method(multi_selector_method, MultiSelectorHook(self.hook_method))

        clazz = get_messages_controller().getClass()
        delete_messages_method = clazz.getDeclaredMethod("deleteMessages", ArrayList, ArrayList, TLRPC.EncryptedChat, Long.TYPE, Boolean.TYPE, Integer.TYPE, Boolean.TYPE, Long.TYPE, TLObject, Integer.TYPE, Boolean.TYPE, Integer.TYPE)
        self.hook_method(delete_messages_method, DeleteMessagesHook())

        logger.info("Loaded")

    def on_plugin_unload(self):
        zwylib.remove_autoupdater_task(__id__)
        logger.info("Unloaded")

    def create_settings(self):
        try:
            return [
                Header(text="Settings"),
                Switch(
                    key="debug_mode",
                    text=localise("debug_mode_label"),
                    subtext=localise("debug_mode_hint"),
                    icon="msg_log",
                    default=DEFAULT_DEBUG_MODE,
                    on_change=switch_debug_mode,
                ),
            ]
        except Exception:
            text = (
                f"An exception occurred on {self.__class__.__name__}.create_settings():\n"
                f"{traceback.format_exc().rstrip()}"
            )
            logger.info(text)
            return [Text(text)]

    def pre_request_hook(self, req_name, account, req):
        if req_name == "TL_messages_forwardMessages":
            selector_hook.clear_message_storage()
            return HookResult()
        return HookResult()

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not debug_mode or getattr(params, "message", "") != ".":
            return HookResult()

        for _ in range(60):
            logger.info("")

        BulletinHelper.show_info(localise("debug_message_info"))
        selector_hook.clear_message_storage()
        return HookResult(strategy=HookStrategy.CANCEL)
