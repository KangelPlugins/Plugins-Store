import requests
import base64
import os
import threading
import time
import uuid
import re
import hashlib
from urllib.parse import quote
from datetime import datetime
from io import BytesIO
from java.util import Locale, ArrayList
from java.io import File
from java.lang import Class as JClass, Float as JFloat
from PIL import Image, ImageFilter, ImageDraw, ImageFont, ImageOps
from android.content import Intent, ClipData, Context
from android.net import Uri
from org.telegram.messenger import ApplicationLoader
from org.telegram.ui.ActionBar import AlertDialog
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from client_utils import get_send_messages_helper, run_on_queue, get_last_fragment, get_user_config, get_messages_controller, send_request
from android_utils import run_on_ui_thread, log
from markdown_utils import parse_markdown
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from org.telegram.tgnet.tl import TL_account
from org.telegram.messenger import R
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
import json
import math
import random
from hook_utils import find_class

__id__ = "nowfy"
__name__ = "Nowfy"
__description__ = "Shows and controls the current playing track with a styled preview.\n\nSupported services:\n• Spotify (API)\n• Last.fm (scrobble)\n• Stats.fm (Spotify tracking)\n\nHow to use:\n• Use .now to show the current playing track (Spotify)\n• Use .fm to show the current scrobbling track (Last.fm)\n• Use .stats to show the current playing track (Stats.fm)\n• Use .etg to show the current playing track from exteraGram\n• Use .ayu to show the current playing track from AyuGram\n• Use .help to see all available commands\n• Use .guide for setup instructions"
__author__ = "@AGeekApple, @exteraDevPlugins"
__version__ = "1.0.9"
__min_version__ = "11.12.1"
__icon__ = "ApplePlugins/16"
__priority__ = 0

# Mapeamento de backgrounds para o tema Apple unificado
APPLE_BACKGROUNDS = {
    "Spotify": {
        "Light": "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
        "Dark":  "https://i.postimg.cc/d10qdJL1/appledark.png",
        "Red":   "https://i.postimg.cc/269phvZb/applered.png",
    },
    "YouTube": {
        "Light": "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png",
        "Dark":  "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png",
        "Red":   "https://i.postimg.cc/bvXjBnQ6/appleredyoutubered.png",
    },
    "YouTube Music": {
        "Light": "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png",
        "Dark":  "https://i.postimg.cc/C502GHp8/appledarkytmusic.png",
        "Red":   "https://i.postimg.cc/44vqJMpQ/appleredytmusic.png",
    },
    "exteraGram": {
        "Light": "https://i.postimg.cc/qvtSs7Cp/etglight.png",
        "Dark":  "https://i.postimg.cc/cJwzz5mj/etgdark.png",
        "Red":   "https://i.postimg.cc/6pDSYNdn/etgred.png",
    },
    "AyuGram": {
        "Light": "https://i.postimg.cc/2yR4VrBj/ayulight.png",
        "Dark":  "https://i.postimg.cc/ryx170vD/ayudark.png",
        "Red":   "https://i.postimg.cc/8cRLv9hR/ayured.png",
    },
    "SoundCloud": {
        "Light": "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png", # Manutenção
        "Dark":  "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png",
        "Red":   "https://i.postimg.cc/6p0NgnSh/appleredsoundcloud.png",
    },
    "Apple Music": {
        "Light": "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png",
        "Dark":  "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
        "Red":   "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
    },
    "Yandex Music": {
        "Light": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexlight.png",  # Usando background padrão por enquanto
        "Dark":  "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexdark.png",   # Usando background padrão por enquanto
        "Red":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandexred.png",    # Usando background padrão por enquanto
    },
    "Yandex Music": {
        "Light": "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
        "Dark":  "https://i.postimg.cc/d10qdJL1/appledark.png",
        "Red":   "https://i.postimg.cc/269phvZb/applered.png",
    },
}

# Mensagens do NowCast
NOWCAST_MESSAGES = {
    "music_detected": "Música detectada! Card será enviado nos próximos 2 minutos...",
    "card_sent": "Card enviado!",
    "card_updated": "Card atualizado!",
    "music_stopped": "Música parou. NowCast pausado.",
    "worker_started": "Worker iniciado",
    "worker_stopping": "Worker será parado na próxima verificação",
    "error_worker": "Erro no worker: {}",
    "error_check_music": "Erro ao verificar música: {}",
    "error_send_test": "Erro ao enviar mensagem de teste: {}",
    "nowcast_enabled": "NowCast ativado! Sistema monitorando música...",
    "nowcast_disabled": "NowCast desativado.",
    "nowcast_ready": "NowCast configurado e pronto para uso!",
    "nowcast_error": "Erro: Configure as credenciais e canal primeiro."
}

# Variantes de estilo (cores + exteraBar) por skin
APPLE_SKIN_STYLE = {
    0: {  # Light
        "playing_color": "#888888",
        "title_color": "#000000",
        "artist_color": "#888888",
        "exteraBar_fn": "exteraBarSeek_light_opposite",
    },
    1: {  # Dark
        "playing_color": "#DDDDDD",
        "title_color": "#FFFFFF",
        "artist_color": "#CCCCCC",
        "exteraBar_fn": "exteraBarSeek_dark_opposite",
    },
    2: {  # Red
        "playing_color": "#DDDDDD",
        "title_color": "#FFFFFF",
        "artist_color": "#CCCCCC",
        "exteraBar_fn": "exteraBarSeek_red_opposite",
    },
}

# Variantes de estilo para o tema Spotlight
SPOTLIGHT_SKIN_STYLE = {
    0: {  # Light
        "time_color": (0, 0, 0, 255),  # Preto
        "bar_bg_color": (200, 200, 200, 255),  # Cinza claro
        "bar_fill_color": (0, 0, 0, 255),  # Preto
        "bg_color": (255, 255, 255),  # Fundo branco
        "use_blur_bg": False,
    },
    1: {  # Dark
        "time_color": (255, 255, 255, 255),  # Branco
        "bar_bg_color": (60, 60, 60, 255),  # Cinza escuro
        "bar_fill_color": (255, 255, 255, 255),  # Branco
        "bg_color": (0, 0, 0),  # Fundo preto
        "use_blur_bg": False,
    },
    2: {  # Blur
        "time_color": (255, 255, 255, 255),  # Branco (cores invertidas do Dark)
        "bar_bg_color": (60, 60, 60, 255),  # Cinza escuro
        "bar_fill_color": (255, 255, 255, 255),  # Branco
        "bg_color": (255, 255, 255),  # Fundo será substituído pelo blur
        "use_blur_bg": True,
    },
}

# Traduções básicas (pode ser expandido)
TRANSLATIONS = {
    "client_id": {"pt": "Client ID", "en": "Client ID", "es": "Client ID", "fr": "Client ID", "ru": "Client ID"},
    "client_secret": {"pt": "Client Secret", "en": "Client Secret", "es": "Client Secret", "fr": "Client Secret", "ru": "Client Secret"},
    "refresh_token": {"pt": "Refresh Token", "en": "Refresh Token", "es": "Refresh Token", "fr": "Refresh Token", "ru": "Refresh Token"},
    "custom_command": {"pt": "Comando Personalizado", "en": "Custom Command", "es": "Comando Personalizado", "fr": "Commande personnalisée", "ru": "Пользовательская команда"},
    "custom_command_sub": {"pt": "Comando para mostrar o card (ex: .now)", "en": "Command to show card (e.g. .now)", "es": "Comando para mostrar la tarjeta (ej: .now)", "fr": "Commande pour afficher la carte (ex: .now)", "ru": "Команда для показа карточки (например, .now)"},
    "autobio": {"pt": "Atualizar bio automaticamente", "en": "Auto-update bio", "es": "Actualizar bio automáticamente", "fr": "Mise à jour automatique de la bio", "ru": "Автообновление био"},
    "autobio_sub": {"pt": "Atualiza a bio automaticamente com a música atual", "en": "Automatically updates bio with current track", "es": "Actualiza la bio automáticamente con la canción actual", "fr": "Met à jour automatiquement la bio avec la chanson en cours", "ru": "Автоматически обновляет био с текущей песней"},
    "autobio_text": {"pt": "Texto da bio", "en": "Bio text", "es": "Texto de la bio", "fr": "Texte de la bio", "ru": "Текст био"},
    "autobio_text_sub": {"pt": "Texto para atualizar a bio com a música atual", "en": "Text to update bio with current track", "es": "Texto para actualizar la bio con la canción atual", "fr": "Texte pour mettre à jour la bio avec la chanson en cours", "ru": "Текст для обновления био с текущей песней"},
    "playing": {"pt": "Tocando", "en": "Playing", "es": "Reproduciendo", "fr": "Lecture", "ru": "Сейчас играет"},
    "show_caption": {"pt": "Mostrar legenda", "en": "Show Caption", "es": "Mostrar leyenda", "fr": "Afficher la légende", "ru": "Показать подпись"},
    "show_caption_sub": {"pt": "Mostra a legenda com o card", "en": "Shows caption with the card", "es": "Muestra la leyenda con la tarjeta", "fr": "Affiche la légende avec la carte", "ru": "Показывать подпись с карточкой"},
    "caption_style": {"pt": "Estilo da legenda", "en": "Caption Style", "es": "Estilo de leyenda", "fr": "Style de légende", "ru": "Стиль подписи"},
    "caption_style_sub": {"pt": "Escolha o estilo da legenda do card", "en": "Choose the card caption style", "es": "Elige el estilo de leyenda de la tarjeta", "fr": "Choisissez le style de légende de la carte", "ru": "Выберите стиль подписи карточки"},
    "enable_cache": {"pt": "Ativar cache de imagem", "en": "Enable image cache", "es": "Activar caché de imagen", "fr": "Activer le cache d'image", "ru": "Включить кэш изображений"},
    "enable_cache_sub": {"pt": "Cache de imagens para melhor performance", "en": "Image cache for better performance", "es": "Caché de imágenes para mejor rendimiento", "fr": "Cache d'images pour de meilleures performances", "ru": "Кэш изображений для лучшей производительности"},
    "enable_compression": {"pt": "Ativar compressão de imagem", "en": "Enable image compression", "es": "Activar compresión de imagen", "fr": "Activer la compression d'image", "ru": "Включить сжатие изображений"},
    "enable_compression_sub": {"pt": "Comprimir imagens para economizar espaço", "en": "Compress images to save space", "es": "Comprimir imágenes para ahorrar espacio", "fr": "Compresser les images pour économiser de l'espace", "ru": "Сжимать изображения для экономии места"},
    "cache_ttl": {"pt": "TTL do cache (min)", "en": "Cache TTL (min)", "es": "TTL de caché (min)", "fr": "Durée de vie du cache (min)", "ru": "Время жизни кэша (мин)"},
    "cache_ttl_sub": {"pt": "Tempo de vida do cache em minutos", "en": "Cache lifetime in minutes", "es": "Tiempo de vida del caché en minutos", "fr": "Durée de vie du cache en minutes", "ru": "Время жизни кэша в минутах"},
    "performance_mode": {"pt": "Modo de Performance", "en": "Performance Mode", "es": "Modo de Rendimiento", "fr": "Mode de Performance", "ru": "Режим производительности"},
    "performance_mode_sub": {"pt": "Balanceamento entre velocidade e qualidade", "en": "Balance between speed and quality", "es": "Balance entre velocidad y calidad", "fr": "Équilibre entre vitesse et qualité", "ru": "Баланс между скоростью и качеством"},
    "enable_preload_sub": {"pt": "Pré-carregar próximas faixas da playlist", "en": "Preload next tracks from playlist", "es": "Precargar siguientes pistas de la lista", "fr": "Précharger les pistes suivantes de la playlist", "ru": "Предзагружать следующие треки из плейлиста"},
    "enhanced_cache": {"pt": "Cache Avançado", "en": "Enhanced Cache", "es": "Caché Avanzado", "fr": "Cache Avancé", "ru": "Расширенный кэш"},
    "enhanced_cache_sub": {"pt": "Sistema de cache otimizado para melhor performance", "en": "Optimized cache system for better performance", "es": "Sistema de caché optimizado para mejor rendimiento", "fr": "Système de cache optimisé pour de meilleures performances", "ru": "Оптимизированная система кэша для лучшей производительности"},
    "turbo_mode": {"pt": "Turbo", "en": "Turbo", "es": "Turbo", "fr": "Turbo", "ru": "Турбо"},
    "balanced_mode": {"pt": "Balanceado", "en": "Balanced", "es": "Equilibrado", "fr": "Équilibré", "ru": "Сбалансированный"},
    "quality_mode": {"pt": "Qualidade", "en": "Quality", "es": "Calidad", "fr": "Qualité", "ru": "Качество"},
    "enable_preload": {"pt": "Pré-carregar próximas faixas", "en": "Preload next tracks", "es": "Precargar próximas pistas", "fr": "Précharger les pistes suivantes", "ru": "Предзагрузка следующих треков"},
    "enhanced_cache_sub": {"pt": "Ativa otimizações avançadas de cache para melhor performance", "en": "Enables advanced cache optimizations for better performance", "es": "Activa optimizaciones avanzadas de caché para mejor rendimiento", "fr": "Active les optimisations de cache avancées pour de meilleures performances", "ru": "Включает расширенные оптимизации кэша для лучшей производительности"},
    "cache_performance_section": {"pt": "Otimizações de Performance", "en": "Performance Optimizations", "es": "Optimizaciones de Rendimiento", "fr": "Optimisations de Performance", "ru": "Оптимизации производительности"},
    "cache_management_section": {"pt": "Gerenciamento de Cache", "en": "Cache Management", "es": "Gestión de Caché", "fr": "Gestion du Cache", "ru": "Управление кэшем"},
    "bio_automation_section": {"pt": "Automação da Bio", "en": "Bio Automation", "es": "Automatización de Bio", "fr": "Automatisation de Bio", "ru": "Автоматизация биографии"},
    "bio_customization_section": {"pt": "Personalização da Bio", "en": "Bio Customization", "es": "Personalización de Bio", "fr": "Personnalisation de Bio", "ru": "Настройка биографии"},
    "bio_help_section": {"pt": "Ajuda e Informações", "en": "Help and Information", "es": "Ayuda e Información", "fr": "Aide et Informations", "ru": "Помощь и информация"},
    "theme_selection_section": {"pt": "Seleção de Tema", "en": "Theme Selection", "es": "Selección de Tema", "fr": "Sélection de Thème", "ru": "Выбор темы"},
    "appearance_options_section": {"pt": "Efeitos de Envio", "en": "Send Effects", "es": "Efectos de Envío", "fr": "Effets d’Envoi", "ru": "Эффекты при отправке"},
    "customization_section": {"pt": "Personalização", "en": "Customization", "es": "Personalización", "fr": "Personnalisation", "ru": "Настройка"},
    "help_info_section": {"pt": "Ajuda e Informações", "en": "Help and Information", "es": "Ayuda e Información", "fr": "Aide et Informations", "ru": "Помощь и информация"},
    "credentials_section": {"pt": "Credenciais e Autenticação", "en": "Credentials & Authentication", "es": "Credenciales y Autenticación", "fr": "Identifiants et Authentification", "ru": "Учетные данные и аутентификация"},
    "multi_resolution_cache": {"pt": "Cache Multi-Resolução", "en": "Multi-Resolution Cache", "es": "Caché Multi-Resolución", "fr": "Cache Multi-Résolution", "ru": "Многоразрешающий кэш"},
    "multi_resolution_cache_sub": {"pt": "Armazena imagens em múltiplas resoluções", "en": "Stores images in multiple resolutions", "es": "Almacena imágenes en múltiples resoluciones", "fr": "Stocke les images en plusieurs résolutions", "ru": "Сохраняет изображения в нескольких разрешениях"},
    "persistent_cache": {"pt": "Cache Persistente", "en": "Persistent Cache", "es": "Caché Persistente", "fr": "Cache Persistant", "ru": "Постоянный кэш"},
    "persistent_cache_sub": {"pt": "Mantém cache entre reinicializações", "en": "Keeps cache between restarts", "es": "Mantiene caché entre reinicios", "fr": "Conserve le cache entre les redémarrages", "ru": "Сохраняет кэш между перезапусками"},
    "setid": {"pt": "Salvando Client ID...", "en": "Saving Client ID...", "es": "Guardando Client ID...", "fr": "Enregistrement du Client ID...", "ru": "Сохранение Client ID..."},
    "setsecret": {"pt": "Salvando Client Secret...", "en": "Saving Client Secret...", "es": "Guardando Client Secret...", "fr": "Enregistrement du Client Secret...", "ru": "Сохранение Client Secret..."},
    "code": {"pt": "Trocando código...", "en": "Exchanging code...", "es": "Intercambiando código...", "fr": "Échange du code...", "ru": "Обмен кода..."},
    "exchanging_code": {"pt": "Trocando código de autorização...", "en": "Exchanging authorization code...", "es": "Intercambiando código de autorización...", "fr": "Échange du code d'autorisation...", "ru": "Обмен кода авторизации..."},
    "update": {"pt": "Gerar link de autorização", "en": "Generate auth link", "es": "Generar enlace de autorización", "fr": "Générer le lien d'autorisation", "ru": "Создать ссылку авторизации"},
    "check": {"pt": "Validando credenciais...", "en": "Validating credentials...", "es": "Validando credenciales...", "fr": "Validation des identifiants...", "ru": "Проверка учетных данных..."},
    "valid": {"pt": "Credenciais válidas!", "en": "Credentials are valid!", "es": "¡Credenciales válidas!", "fr": "Identifiants valides!", "ru": "Данные действительны!"},
    "client_id_or_secret_missing": {"pt": "Client ID ou Secret não configurados nas configurações!", "en": "Client ID or Secret not set in settings!", "es": "¡Client ID o Secret no configurados en la configuración!", "fr": "Client ID ou Secret non configurés dans les paramètres!", "ru": "Client ID или Secret не указаны в настройках!"},
    "error_missing_code": {"pt": "Use .code <código> para trocar o código de autorização.", "en": "Use .code <code> to exchange the authorization code.", "es": "Usa .code <código> para intercambiar el código de autorización.", "fr": "Utilisez .code <code> pour échanger le code d'autorisation.", "ru": "Используйте .code <код> для обмена кода авторизации."},
    "refresh_token_saved": {"pt": "Refresh Token salvo com sucesso", "en": "Refresh token saved successfully", "es": "Refresh token guardado con éxito", "fr": "Refresh token enregistré avec succès", "ru": "Токен обновления успешно сохранён"},
    "code_exchange_error": {"pt": "Erro ao trocar código", "en": "Error exchanging code", "es": "Error al intercambiar el código", "fr": "Erreur lors de l'échange du code", "ru": "Ошибка обмена кода"},
    "bio_updated": {"pt": "Bio atualizada!", "en": "Bio updated!", "es": "Bio actualizada!", "fr": "Bio mise à jour!", "ru": "Био обновлено!"},
    "bio_error": {"pt": "Erro ao atualizar bio.", "en": "Failed to update bio.", "es": "Error al actualizar la bio.", "fr": "Erreur lors de la mise à jour de la bio.", "ru": "Ошибка при обновлении био."},
    "cache_cleared": {"pt": "Cache limpo!", "en": "Cache cleared!", "es": "Caché limpiado!", "fr": "Cache vidé!", "ru": "Кэш очищен!"},
    "cache_cleared_mode": {"pt": "Cache limpo! Modo: {mode}", "en": "Cache cleared! Mode: {mode}", "es": "Caché limpiado! Modo: {mode}", "fr": "Cache vidé! Mode: {mode}", "ru": "Кэш очищен! Режим: {mode}"},
    "open_auth_link": {"pt": "Abra o link para autorizar: {url}", "en": "Open the link to authorize: {url}", "es": "Abre el enlace para autorizar: {url}", "fr": "Ouvrez le lien pour autoriser: {url}", "ru": "Откройте ссылку для авторизации: {url}"},
    "show_credentials": {"pt": "Configurações de Credenciais", "en": "Credentials Settings", "es": "Configuración de Credenciales", "fr": "Paramètres des identifiants", "ru": "Настройки учетных данных"},
    "show_credentials_sub": {"pt": "Expandir para configurar credenciais do Spotify", "en": "Expand to configure Spotify credentials", "es": "Expandir para configurar credenciales de Spotify", "fr": "Développer pour configurer les identifiants Spotify", "ru": "Развернуть для настройки учетных данных Spotify"},
    "spotify_credentials": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "spotify_credentials_sub": {"pt": "Configure as credenciais da API do Spotify", "en": "Configure Spotify API credentials", "es": "Configurar credenciales de la API de Spotify", "fr": "Configurer les identifiants de l'API Spotify", "ru": "Настроить учетные данные API Spotify"},
    "spotify_auth_toggle": {"pt": "Spotify Auth", "en": "Spotify Auth", "es": "Spotify Auth", "fr": "Spotify Auth", "ru": "Spotify Auth"},
    "spotify_auth_toggle_sub": {
        "pt": "Se ativado, o Client ID, Secret e Refresh Token serão exibidos. Se desativado, ficam ocultos para privacidade.",
        "en": "If enabled, Client ID, Secret and Refresh Token will be shown. If disabled, they remain hidden for privacy.",
        "es": "Si está activado, se mostrarán Client ID, Secret y Refresh Token. Si está desactivado, permanecen ocultos por privacidad.",
        "fr": "Si activé, le Client ID, Secret et Refresh Token seront affichés. Si désactivé, ils restent masqués pour la confidentialité.",
        "ru": "Если включено, будут показаны Client ID, Secret и Refresh Token. Если отключено, они остаются скрытыми для конфиденциальности."
    },
    "spotify_auth_hidden_notice": {
        "pt": "As credenciais estão ocultas.",
        "en": "Credentials are hidden.",
        "es": "Las credenciales están ocultas.",
        "fr": "Les identifiants sont masqués.",
        "ru": "Учетные данные скрыты."
    },
    "spotify_control": {"pt": "Spotify Control", "en": "Spotify Control", "es": "Spotify Control", "fr": "Spotify Control", "ru": "Spotify Control"},
    "spotify_control_dialog": {
        "pt": "Comandos principais da integração Spotify:\n\n• .now — mostra a faixa atual\n• .play [ID] — reproduz faixa\n• .pause — pausa reprodução\n• .skip — próxima faixa (requer Premium)\n• .back — faixa anterior (requer Premium)\n• .vol [0-100] — ajusta volume\n• .repeat [modo] — alterna repetição\n• .search [termo] — busca faixas\n• .like now — favorita a faixa atual\n• .connect — conecta sua conta\n\nObservação: ações de controle de reprodução (pular/voltar) podem exigir Spotify Premium, uma limitação da plataforma.",
        "en": "Main commands for Spotify integration:\n\n• .now — show current track\n• .play [ID] — play track\n• .pause — pause playback\n• .skip — next track (Premium required)\n• .back — previous track (Premium required)\n• .vol [0-100] — set volume\n• .repeat [mode] — toggle repeat\n• .search [term] — search tracks\n• .like now — like current track\n• .connect — connect your account\n\nNote: playback control actions (skip/back) may require Spotify Premium due to platform limitations.",
        "es": "Comandos principales de la integración de Spotify:\n\n• .now — muestra la pista actual\n• .play [ID] — reproduce pista\n• .pause — pausa reproducción\n• .skip — siguiente pista (requiere Premium)\n• .back — pista anterior (requiere Premium)\n• .vol [0-100] — ajustar volumen\n• .repeat [modo] — alternar repetición\n• .search [término] — buscar pistas\n• .like now — marcar como favorita la pista actual\n• .connect — conectar tu cuenta\n\nNota: las acciones de control de reproducción (saltar/volver) pueden requerir Spotify Premium por limitaciones de la plataforma.",
        "fr": "Commandes principales pour l'intégration Spotify:\n\n• .now — affiche le titre en cours\n• .play [ID] — lire le titre\n• .pause — mettre en pause\n• .skip — piste suivante (Premium requis)\n• .back — piste précédente (Premium requis)\n• .vol [0-100] — régler le volume\n• .repeat [mode] — basculer la répétition\n• .search [terme] — rechercher des titres\n• .like now — ajouter le titre actuel aux favoris\n• .connect — connecter votre compte\n\nRemarque: les actions de contrôle (suivant/précédent) peuvent nécessiter Spotify Premium en raison des limitations de la plateforme.",
        "ru": "Основные команды интеграции Spotify:\n\n• .now — показать текущий трек\n• .play [ID] — воспроизвести трек\n• .pause — пауза\n• .skip — следующий трек (требуется Premium)\n• .back — предыдущий трек (требуется Premium)\n• .vol [0-100] — установить громкость\n• .repeat [режим] — переключить повтор\n• .search [запрос] — искать треки\n• .like now — добавить текущий трек в избранное\n• .connect — подключить аккаунт\n\nПримечание: действия управления воспроизведением (вперед/назад) могут требовать Spotify Premium из‑за ограничений платформы."
    },
    "statsfm_credentials": {"pt": "Stats.FM", "en": "Stats.FM", "es": "Stats.FM", "fr": "Stats.FM", "ru": "Stats.FM"},
    "statsfm_credentials_sub": {"pt": "Configure as credenciais do Stats.FM", "en": "Configure Stats.FM credentials", "es": "Configurar credenciales de Stats.FM", "fr": "Configurer les identifiants Stats.FM", "ru": "Настроить учетные данные Stats.FM"},
    
    # NowCast Settings
    "nowcast_section": {"pt": "NowCast (Beta)", "en": "NowCast (Beta)", "es": "NowCast (Beta)", "fr": "NowCast", "ru": "NowCast (Beta)"},
    "nowcast_enable": {"pt": "Ativar NowCast", "en": "Enable NowCast", "es": "Activar NowCast", "fr": "Activer NowCast", "ru": "Включить NowCast"},
    "nowcast_enable_sub": {
        "pt": "Posta automaticamente o Now Playing no canal sempre que o NowCast estiver ativo (músicas em tempo real).",
        "en": "Automatically posts Now Playing in the channel whenever NowCast is active (real-time music).",
        "es": "Publica automáticamente el Now Playing en el canal siempre que NowCast esté activo (música en tiempo real).",
        "fr": "Publie automatiquement le Now Playing dans le canal chaque fois que NowCast est actif (musique en temps réel).",
        "ru": "Автоматически публикует Now Playing в канале, когда активен NowCast (музыка в реальном времени)."
    },
    "nowcast_bot_token": {"pt": "Bot Token", "en": "Bot Token", "es": "Bot Token", "fr": "Bot Token", "ru": "Bot Token"},
    "nowcast_channel_id": {"pt": "Channel ID", "en": "Channel ID", "es": "Channel ID", "fr": "Channel ID", "ru": "Channel ID"},
    "nowcast_post_interval": {"pt": "Intervalo de Postagem", "en": "Post Interval", "es": "Intervalo de Publicación", "fr": "Intervalle de Publication", "ru": "Интервал Публикации"},
    "test_nowcast_connection": {"pt": "Testar Conexão NowCast", "en": "Test NowCast Connection", "es": "Probar Conexión NowCast", "fr": "Tester la Connexion NowCast", "ru": "Тест соединения NowCast"},
    "clear_nowcast_history": {"pt": "Limpar Histórico NowCast", "en": "Clear NowCast History", "es": "Limpiar Historial NowCast", "fr": "Effacer l'Historique NowCast", "ru": "Очистить историю NowCast"},
    
    # NowCast Link Options
    "nowcast_link_option": {"pt": "Link da Música", "en": "Music Link", "es": "Enlace de Música", "fr": "Lien Musical", "ru": "Музыкальная ссылка"},
    "nowcast_link_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "nowcast_link_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "nowcast_link_songlink": {"pt": "song.link", "en": "song.link", "es": "song.link", "fr": "song.link", "ru": "song.link"},
    "statsfm_username": {"pt": "Usuário do Stats.fm", "en": "Stats.fm Username", "es": "Usuario de Stats.fm", "fr": "Nom d'utilisateur Stats.fm", "ru": "Имя пользователя Stats.fm"},
    "statsfm_username_sub": {"pt": "Seu nome de usuário do stats.fm", "en": "Your stats.fm username", "es": "Tu usuario de stats.fm", "fr": "Votre nom d'utilisateur stats.fm", "ru": "Ваше имя пользователя stats.fm"},
    "show_cache_settings": {"pt": "Configurações de Cache", "en": "Cache Settings", "es": "Configuración de Caché", "fr": "Paramètres du cache", "ru": "Настройки кэша"},
    "show_cache_settings_sub": {
        "pt": "Expandir para opções avançadas de cache, compressão e desempenho",
        "en": "Expand to advanced cache, compression and performance settings",
        "es": "Expandir para opciones avanzadas de caché, compresión y rendimiento",
        "fr": "Développer pour les paramètres avancés de cache, compression et performance",
        "ru": "Развернуть для доступа к расширенным настройкам кэша, сжатия и производительности"
    },
    "clear_cache": {"pt": "Limpar Cache", "en": "Clear Cache", "es": "Limpiar Caché", "fr": "Vider le cache", "ru": "Очистить кэш"},
    "show_advanced_options": {"pt": "Opções Avançadas", "en": "Advanced Options", "es": "Opciones Avanzadas", "fr": "Options avancées", "ru": "Дополнительные параметры"},
    "show_advanced_options_sub": {"pt": "Expandir para configurar opções avançadas", "en": "Expand to configure advanced options", "es": "Expandir para configurar opciones avançadas", "fr": "Développer pour configurer les options avancées", "ru": "Развернуть для настройки дополнительных параметров"},
    "thumbnail_cache_section": {"pt": "Cache de Thumbnails", "en": "Thumbnail Cache", "es": "Caché de Miniaturas", "fr": "Cache des vignettes", "ru": "Кэш миниатюр"},
    "quality_options_section": {"pt": "Opções de Qualidade", "en": "Quality Options", "es": "Opciones de Calidad", "fr": "Options de qualité", "ru": "Параметры качества"},
    "youtube_cache": {"pt": "YouTube Cache", "en": "YouTube Cache", "es": "Caché YouTube", "fr": "Cache YouTube", "ru": "Кэш YouTube"},
    "youtube_cache_sub": {"pt": "Armazena thumbnails do YouTube para acesso mais rápido", "en": "Stores YouTube thumbnails for faster access", "es": "Almacena miniaturas de YouTube para acceso más rápido", "fr": "Stocke les vignettes YouTube pour un accès plus rapide", "ru": "Сохраняет миниатюры YouTube для быстрого доступа"},
    "soundcloud_cache": {"pt": "SoundCloud Cache", "en": "SoundCloud Cache", "es": "Caché SoundCloud", "fr": "Cache SoundCloud", "ru": "Кэш SoundCloud"},
    "soundcloud_cache_sub": {"pt": "Cache otimizado para thumbnails do SoundCloud", "en": "Optimized cache for SoundCloud thumbnails", "es": "Caché optimizado para miniaturas de SoundCloud", "fr": "Cache optimisé pour les vignettes SoundCloud", "ru": "Оптимизированный кэш для миниатюр SoundCloud"},
    "quality_fallback": {"pt": "Fallback Qualidade", "en": "Quality Fallback", "es": "Respaldo Calidad", "fr": "Basculement Qualité", "ru": "Резерв качества"},
    "quality_fallback_sub": {"pt": "Tenta diferentes qualidades se a principal falhar", "en": "Tries different qualities if main one fails", "es": "Intenta diferentes calidades si la principal falla", "fr": "Essaie différentes qualités si la principale échoue", "ru": "Пробует разные качества, если основное не работает"},
    "url_cache": {"pt": "Cache de URLs", "en": "URL Cache", "es": "Caché de URLs", "fr": "Cache d'URLs", "ru": "Кэш URL"},
    "url_cache_sub": {"pt": "Armazena URLs válidas para evitar verificações repetidas", "en": "Stores valid URLs to avoid repeated checks", "es": "Almacena URLs válidas para evitar verificaciones repetidas", "fr": "Stocke les URLs valides pour éviter les vérifications répétées", "ru": "Сохраняет действительные URL, чтобы избежать повторных проверок"},
    "adaptive_compression": {"pt": "Compressão Adaptativa", "en": "Adaptive Compression", "es": "Compresión Adaptativa", "fr": "Compression Adaptative", "ru": "Адаптивное Сжатие"},
    "adaptive_compression_sub": {"pt": "Ajusta qualidade automaticamente baseada na velocidade de conexão", "en": "Automatically adjusts quality based on connection speed", "es": "Ajusta automáticamente la calidad según la velocidad de conexión", "fr": "Ajuste automatiquement la qualité selon la vitesse de connexion", "ru": "Автоматически настраивает качество в зависимости от скорости соединения"},
    "enable_youtube_thumbnail_cache": {"pt": "Cache de thumbnails do YouTube", "en": "YouTube thumbnail cache", "es": "Caché de miniaturas de YouTube", "fr": "Cache des vignettes YouTube", "ru": "Кэш миниатюр YouTube"},
    "enable_youtube_thumbnail_cache_sub": {"pt": "Armazena thumbnails do YouTube para acesso mais rápido", "en": "Stores YouTube thumbnails for faster access", "es": "Almacena miniaturas de YouTube para acceso más rápido", "fr": "Stocke les vignettes YouTube pour un accès plus rapide", "ru": "Сохраняет миниатюры YouTube для быстрого доступа"},
    # Backup System Translations
    "backup_export_success": {"pt": "Backup exportado com sucesso!", "en": "Backup exported successfully!", "es": "Backup exportado exitosamente!", "fr": "Sauvegarde exportée avec succès!", "ru": "Резервная копия успешно экспортирована!"},
    "backup_export_error": {"pt": "Erro ao exportar backup", "en": "Error exporting backup", "es": "Error al exportar backup", "fr": "Erreur lors de l'exportation de la sauvegarde", "ru": "Ошибка при экспорте резервной копии"},
    "backup_import_error": {"pt": "Erro ao importar backup", "en": "Error importing backup", "es": "Error al importar backup", "fr": "Erreur lors de l'importation de la sauvegarde", "ru": "Ошибка при импорте резервной копии"},
    "backup_list_error": {"pt": "Erro ao listar backups", "en": "Error listing backups", "es": "Error al listar backups", "fr": "Erreur lors de la liste des sauvegardes", "ru": "Ошибка при получении списка резервных копий"},
    "backup_location": {"pt": "Local", "en": "Location", "es": "Ubicación", "fr": "Emplacement", "ru": "Расположение"},
    "backup_date": {"pt": "Data", "en": "Date", "es": "Fecha", "fr": "Date", "ru": "Дата"},
    "backup_no_files_found": {"pt": "Nenhum arquivo de backup encontrado!", "en": "No backup files found!", "es": "No se encontraron archivos de backup!", "fr": "Aucun fichier de sauvegarde trouvé!", "ru": "Файлы резервных копий не найдены!"},
    "backup_check_directory": {"pt": "Verifique se há arquivos em", "en": "Check if there are files in", "es": "Verifique si hay archivos en", "fr": "Vérifiez s'il y a des fichiers dans", "ru": "Проверьте наличие файлов в"},
    "backup_select_title": {"pt": "Selecionar Backup", "en": "Select Backup", "es": "Seleccionar Backup", "fr": "Sélectionner la sauvegarde", "ru": "Выбрать резервную копию"},
    "backup_cancel": {"pt": "Cancelar", "en": "Cancel", "es": "Cancelar", "fr": "Annuler", "ru": "Отмена"},
    "backup_imported_success": {"pt": "Backup importado com sucesso! Reinicie o Telegram para aplicar todas as mudanças.", "en": "Backup imported successfully! Restart Telegram to apply all changes.", "es": "Backup importado exitosamente! Reinicia Telegram para aplicar todos los cambios.", "fr": "Sauvegarde importée avec succès! Redémarrez Telegram pour appliquer tous les changements.", "ru": "Резервная копия успешно импортирована! Перезапустите Telegram для применения всех изменений."},
    "backup_checking_directory": {"pt": "Verificando diretório de backup...", "en": "Checking backup directory...", "es": "Verificando directorio de backup...", "fr": "Vérification du répertoire de sauvegarde...", "ru": "Проверка директории резервных копий..."},
    "backup_listing_files": {"pt": "Listando arquivos de backup...", "en": "Listing backup files...", "es": "Listando archivos de backup...", "fr": "Liste des fichiers de sauvegarde...", "ru": "Получение списка файлов резервных копий..."},
    "backup_selecting_recent": {"pt": "Selecionando backup mais recente...", "en": "Selecting most recent backup...", "es": "Seleccionando backup más reciente...", "fr": "Sélection de la sauvegarde la plus récente...", "ru": "Выбор самой последней резервной копии..."},
    "backup_reading_file": {"pt": "Lendo arquivo de backup...", "en": "Reading backup file...", "es": "Leyendo archivo de backup...", "fr": "Lecture du fichier de sauvegarde...", "ru": "Чтение файла резервной копии..."},
    "backup_validating_structure": {"pt": "Validando estrutura do backup...", "en": "Validating backup structure...", "es": "Validando estructura del backup...", "fr": "Validation de la structure de sauvegarde...", "ru": "Проверка структуры резервной копии..."},
    "backup_preparing_import": {"pt": "Preparando importação das configurações...", "en": "Preparing settings import...", "es": "Preparando importación de configuraciones...", "fr": "Préparation de l'importation des paramètres...", "ru": "Подготовка импорта настроек..."},
    "backup_applying_settings": {"pt": "Aplicando configurações do backup...", "en": "Applying backup settings...", "es": "Aplicando configuraciones del backup...", "fr": "Application des paramètres de sauvegarde...", "ru": "Применение настроек из резервной копии..."},
    "backup_verifying_settings": {"pt": "Verificando configurações aplicadas...", "en": "Verifying applied settings...", "es": "Verificando configuraciones aplicadas...", "fr": "Vérification des paramètres appliqués...", "ru": "Проверка примененных настроек..."},
    "backup_cleaning_cache": {"pt": "Limpando cache...", "en": "Cleaning cache...", "es": "Limpiando caché...", "fr": "Nettoyage du cache...", "ru": "Очистка кэша..."},
    "backup_import_completed": {"pt": "Importação concluída!", "en": "Import completed!", "es": "Importación completada!", "fr": "Importation terminée!", "ru": "Импорт завершен!"},
    "backup_directory_not_found": {"pt": "Diretório de backup não encontrado", "en": "Backup directory not found", "es": "Directorio de backup no encontrado", "fr": "Répertoire de sauvegarde introuvable", "ru": "Директория резервных копий не найдена"},
    "backup_no_files_available": {"pt": "Nenhum arquivo de backup encontrado", "en": "No backup files found", "es": "No se encontraron archivos de backup", "fr": "Aucun fichier de sauvegarde trouvé", "ru": "Файлы резервных копий не найдены"},
    "backup_read_error": {"pt": "Erro ao ler arquivo de backup", "en": "Error reading backup file", "es": "Error al leer archivo de backup", "fr": "Erreur lors de la lecture du fichier de sauvegarde", "ru": "Ошибка чтения файла резервной копии"},
    "backup_invalid_structure": {"pt": "Estrutura de backup inválida", "en": "Invalid backup structure", "es": "Estructura de backup inválida", "fr": "Structure de sauvegarde invalide", "ru": "Неверная структура резервной копии"},
    "backup_file_not_found": {"pt": "Arquivo de backup não encontrado", "en": "Backup file not found", "es": "Archivo de backup no encontrado", "fr": "Fichier de sauvegarde introuvable", "ru": "Файл резервной копии не найден"},
    "backup_invalid_file": {"pt": "Arquivo de backup inválido ou corrompido!", "en": "Invalid or corrupted backup file!", "es": "Archivo de backup inválido o corrupto!", "fr": "Fichier de sauvegarde invalide ou corrompu!", "ru": "Недействительный или поврежденный файл резервной копии!"},
    "backup_confirm_restore": {"pt": "Confirmar Restauração", "en": "Confirm Restore", "es": "Confirmar Restauración", "fr": "Confirmer la restauration", "ru": "Подтвердить восстановление"},
    "backup_restore_title": {"pt": "Restaurar Backup", "en": "Restore Backup", "es": "Restaurar Backup", "fr": "Restaurer la sauvegarde", "ru": "Восстановить резервную копию"},
    "backup_file": {"pt": "Arquivo", "en": "File", "es": "Archivo", "fr": "Fichier", "ru": "Файл"},
    "backup_version": {"pt": "Versão", "en": "Version", "es": "Versión", "fr": "Version", "ru": "Версия"},
    "backup_settings_count": {"pt": "Configurações", "en": "Settings", "es": "Configuraciones", "fr": "Paramètres", "ru": "Настройки"},
    "error_fragment_not_found": {"pt": "Erro: Fragment não encontrado", "en": "Error: Fragment not found", "es": "Error: Fragment no encontrado", "fr": "Erreur: Fragment introuvable", "ru": "Ошибка: Фрагмент не найден"},
    "unknown": {"pt": "Desconhecido", "en": "Unknown", "es": "Desconocido", "fr": "Inconnu", "ru": "Неизвестно"},

    "backup_warning_replace": {"pt": "Suas configurações atuais serão substituídas!", "en": "Your current settings will be replaced!", "es": "Sus configuraciones actuales serán reemplazadas!", "fr": "Vos paramètres actuels seront remplacés!", "ru": "Ваши текущие настройки будут заменены!"},
    "backup_confirm_button": {"pt": "Confirmar", "en": "Confirm", "es": "Confirmar", "fr": "Confirmer", "ru": "Подтвердить"},
    "backup_restore_success": {"pt": "Backup restaurado com sucesso!", "en": "Backup restored successfully!", "es": "Backup restaurado exitosamente!", "fr": "Sauvegarde restaurée avec succès!", "ru": "Резервная копия успешно восстановлена!"},
    "backup_settings_applied": {"pt": "Configurações aplicadas", "en": "Settings applied", "es": "Configuraciones aplicadas", "fr": "Paramètres appliqués", "ru": "Настройки применены"},
    "backup_restart_app": {"pt": "Reinicie o app para aplicar todas as mudanças.", "en": "Restart the app to apply all changes.", "es": "Reinicie la app para aplicar todos los cambios.", "fr": "Redémarrez l'application pour appliquer tous les changements.", "ru": "Перезапустите приложение, чтобы применить все изменения."},
    "backup_apply_error": {"pt": "Erro ao aplicar configurações", "en": "Error applying settings", "es": "Error al aplicar configuraciones", "fr": "Erreur lors de l'application des paramètres", "ru": "Ошибка при применении настроек"},
    "backup_restore_error": {"pt": "Erro ao restaurar backup", "en": "Error restoring backup", "es": "Error al restaurar backup", "fr": "Erreur lors de la restauration", "ru": "Ошибка при восстановлении"},
    "backup_import_starting": {"pt": "Iniciando processo de importação", "en": "Starting import process", "es": "Iniciando proceso de importación", "fr": "Démarrage du processus d'importation", "ru": "Запуск процесса импорта"},
    "backup_using_recent": {"pt": "Usando backup mais recente", "en": "Using most recent backup", "es": "Usando backup más reciente", "fr": "Utilisation de la sauvegarde la plus récente", "ru": "Использование самой последней резервной копии"},
    "backup_directory_not_found": {"pt": "Diretório de backup não encontrado", "en": "Backup directory not found", "es": "Directorio de backup no encontrado", "fr": "Répertoire de sauvegarde introuvable", "ru": "Каталог резервных копий не найден"},
    "backup_restart_required": {"pt": "Algumas mudanças exigem reiniciar o app", "en": "Some changes require restarting the app", "es": "Algunos cambios requieren reiniciar la app", "fr": "Certains changements nécessitent le redémarrage de l'app", "ru": "Некоторые изменения требуют перезапуска приложения"},
    "backup_create_first": {"pt": "Use .export para criar seu primeiro backup!", "en": "Use .export to create your first backup!", "es": "Use .export para crear su primer backup!", "fr": "Utilisez .export pour créer votre première sauvegarde!", "ru": "Используйте .export для создания первой резервной копии!"},
    "backup_list_title": {"pt": "Backups Disponíveis", "en": "Available Backups", "es": "Backups Disponibles", "fr": "Sauvegardes disponibles", "ru": "Доступные резервные копии"},
    "backup_total_size": {"pt": "Tamanho total", "en": "Total size", "es": "Tamaño total", "fr": "Taille totale", "ru": "Общий размер"},
    "backup_use_import": {"pt": "Use .import para restaurar um backup", "en": "Use .import to restore a backup", "es": "Use .import para restaurar un backup", "fr": "Utilisez .import pour restaurer une sauvegarde", "ru": "Используйте .import для восстановления резервной копии"},
    "backup_use_export": {"pt": "Use .export para criar seu primeiro backup", "en": "Use .export to create your first backup", "es": "Use .export para crear su primer backup", "fr": "Utilisez .export pour créer votre première sauvegarde", "ru": "Используйте .export для создания первой резервной копии"},
    "backup_directory": {"pt": "Diretório", "en": "Directory", "es": "Directorio", "fr": "Répertoire", "ru": "Каталог"},
    "backup_and_more": {"pt": "e mais {} backups", "en": "and {} more backups", "es": "y {} backups más", "fr": "et {} sauvegardes de plus", "ru": "и еще {} резервных копий"},
    "backup_read_error": {"pt": "erro ao ler", "en": "read error", "es": "error de lectura", "fr": "erreur de lecture", "ru": "ошибка чтения"},
    "backup_no_backups_found": {"pt": "Nenhum backup encontrado", "en": "No backups found", "es": "No se encontraron backups", "fr": "Aucune sauvegarde trouvée", "ru": "Резервные копии не найдены"},
    "enable_soundcloud_thumbnail_cache": {"pt": "Sistema de cache específico para SoundCloud", "en": "SoundCloud specific cache system", "es": "Sistema de caché específico para SoundCloud", "fr": "Système de cache spécifique à SoundCloud", "ru": "Специальная система кэша для SoundCloud"},
    "enable_soundcloud_thumbnail_cache_sub": {"pt": "Cache otimizado para thumbnails do SoundCloud", "en": "Optimized cache for SoundCloud thumbnails", "es": "Caché optimizado para miniaturas de SoundCloud", "fr": "Cache optimisé pour les vignettes SoundCloud", "ru": "Оптимизированный кэш для миниатюр SoundCloud"},
    "enable_quality_fallback": {"pt": "Fallback entre diferentes qualidades", "en": "Fallback between different qualities", "es": "Respaldo entre diferentes calidades", "fr": "Basculement entre différentes qualités", "ru": "Переключение между разными качествами"},
    "enable_quality_fallback_sub": {"pt": "Tenta diferentes qualidades se a principal falhar", "en": "Tries different qualities if main one fails", "es": "Intenta diferentes calidades si la principal falla", "fr": "Essaie différentes qualités si la principale échoue", "ru": "Пробует разные качества, если основное не работает"},
    "enable_url_cache": {"pt": "Cache de URLs de thumbnails válidas", "en": "Cache of valid thumbnail URLs", "es": "Caché de URLs de miniaturas válidas", "fr": "Cache des URLs de vignettes valides", "ru": "Кэш действительных URL миниатюр"},
    "enable_url_cache_sub": {"pt": "Armazena URLs válidas para evitar verificações repetidas", "en": "Stores valid URLs to avoid repeated checks", "es": "Almacena URLs válidas para evitar verificaciones repetidas", "fr": "Stocke les URLs valides pour éviter les vérifications répétées", "ru": "Сохраняет действительные URL, чтобы избежать повторных проверок"},
    "enable_auto_bio_update": {"pt": "Ativar atualização automática da bio", "en": "Enable automatic bio update", "es": "Activar actualización automática de la bio", "fr": "Activer la mise à jour automatique de la bio", "ru": "Включить автообновление био"},
    "enable_auto_bio_update_sub": {"pt": "Atualiza a bio automaticamente a cada 2 minutos", "en": "Updates bio automatically every 2 minutes", "es": "Actualiza la bio automáticamente cada 2 minutos", "fr": "Met à jour automatiquement la bio toutes les 2 minutes", "ru": "Автоматически обновляет био каждые 2 минуты"},
    "theme_selector": {"pt": "Tema do Card", "en": "Card Theme", "es": "Tema de la Tarjeta", "fr": "Thème de la carte", "ru": "Тема карточки"},
    "theme_selector_sub": {"pt": "Escolha o tema para o card", "en": "Choose the theme for the card", "es": "Elige el tema para la tarjeta", "fr": "Choisissez le thème de la carte", "ru": "Выберите тему карточки"},
    "apple_skin": {"pt": "Variante Apple", "en": "Apple Skin", "es": "Variante Apple", "fr": "Variante Apple", "ru": "Вариант Apple"},
    "apple_skin_sub": {"pt": "Escolha a variante Light / Dark / Red para o fundo e estilo do tema Apple.", "en": "Choose Light / Dark / Red variant for the Apple theme background and style.", "es": "Elige la variante Light / Dark / Red para el fondo y estilo del tema Apple.", "fr": "Choisissez la variante Light / Dark / Red pour l'arrière-plan et le style du thème Apple.", "ru": "Выберите вариант Light / Dark / Red для фона и стиля темы Apple."},
    "apple_light": {"pt": "Apple Light", "en": "Apple Light", "es": "Apple Light", "fr": "Apple Light", "ru": "Apple Light"},
    "minimal": {"pt": "Minimal", "en": "Minimal", "es": "Minimal", "fr": "Minimal", "ru": "Minimal"},
    "custom_caption": {"pt": "Legenda Personalizada", "en": "Custom Caption", "es": "Leyenda Personalizada", "fr": "Légende personnalisée", "ru": "Пользовательская подпись"},
    "custom_caption_sub": {
        "pt": "Texto personalizado para a legenda do card. Suporte aos placeholders: {track}, {artist}, {album}, {spotify}, {song}",
        "en": "Custom text for card caption. Supports placeholders: {track}, {artist}, {album}, {spotify}, {song}",
        "es": "Texto personalizado para la leyenda de la tarjeta. Soporta marcadores: {track}, {artist}, {album}, {spotify}, {song}",
        "fr": "Texte personnalisé pour la légende de la carte. Prend en charge les variables: {track}, {artist}, {album}, {spotify}, {song}",
        "ru": "Пользовательский текст для подписи карточки. Поддерживаются плейсхолдеры: {track}, {artist}, {album}, {spotify}, {song}"
    },
    "bot_caption": {"pt": "Legenda do Bot", "en": "Bot Caption", "es": "Leyenda del Bot", "fr": "Légende du Bot", "ru": "Подпись Бота"},
    "bot_caption_sub": {"pt": "Texto personalizado para a legenda do NowCast (apenas para o bot)", "en": "Custom text for NowCast caption (bot only)", "es": "Texto personalizado para la leyenda del NowCast (solo para el bot)", "fr": "Texte personnalisé pour la légende NowCast (bot uniquement)", "ru": "Пользовательский текст для подписи NowCast (только для бота)"},
    "show_chat_menu": {"pt": "Mostrar no Menu do Chat", "en": "Show in Chat Menu", "es": "Mostrar en el menú del chat", "fr": "Afficher dans le menu du chat", "ru": "Показать в меню чата"},
    "show_chat_menu_sub": {"pt": "Mostrar configurações do exteraFy no menu do chat", "en": "Show exteraFy settings in chat menu", "es": "Mostrar la configuración de exteraFy en el menú del chat", "fr": "Afficher les paramètres exteraFy dans le menu du chat", "ru": "Показать настройки exteraFy в меню чата"},
    "show_bio_notification": {"pt": "Mostrar notificação de bio", "en": "Show bio notification", "es": "Mostrar notificación de bio", "fr": "Afficher la notification de bio", "ru": "Показывать уведомление о био"},
    "show_bio_notification_sub": {"pt": "Mostra notificação quando a bio é atualizada", "en": "Shows notification when bio is updated", "es": "Muestra notificación cuando la bio se actualiza", "fr": "Affiche une notification lors de la mise à jour de la bio", "ru": "Показывать уведомление при обновлении био"},
    "show_track_link": {"pt": "Mostrar link da música", "en": "Show track link", "es": "Mostrar enlace de la canción", "fr": "Afficher le lien de la chanson", "ru": "Показать ссылку на трек"},
    "show_track_link_sub": {"pt": "Mostra o link da música na legenda", "en": "Shows track link in caption", "es": "Muestra el enlace de la canción en la leyenda", "fr": "Affiche le lien de la chanson dans la légende", "ru": "Показывать ссылку на трек в подписи"},
    "no_track_playing": {"pt": "Nenhuma música tocando no Spotify.", "en": "No track playing on Spotify.", "es": "No hay música reproduciéndose en Spotify.", "fr": "Aucune musique en cours sur Spotify.", "ru": "Нет воспроизводимой музыки в Spotify."},
    "no_track_playing_generic": {"pt": "Nenhuma música tocando no momento.", "en": "No track playing at the moment.", "es": "No hay música reproduciéndose en este momento.", "fr": "Aucune musique en cours de lecture en ce moment.", "ru": "Нет воспроизводимой музыки в данный момент."},
    "now_spotify_only": {
        "en": "Unsupported player. Switch to Spotify.",
        "pt": "Player não suportado. Altere para Spotify.",
        "es": "Reproductor no compatible. Cambia a Spotify.",
        "fr": "Lecteur non pris en charge. Passez à Spotify.",
        "ru": "Неподдерживаемый плеер. Переключитесь на Spotify."
    },
    "no_track_lastfm": {"pt": "Nenhuma música tocando no Last.fm no momento.", "en": "No track currently playing on Last.fm", "es": "No hay música reproduciéndose en Last.fm en este momento.", "fr": "Aucune musique en cours de lecture sur Last.fm en ce moment.", "ru": "Нет воспроизводимой музыки на Last.fm в данный момент."},
    "bio_restored": {"pt": "Bio restaurada!", "en": "Bio restored!", "es": "Bio restaurada!", "fr": "Bio restaurée!", "ru": "Био восстановлено!"},
    "restore_bio_text": {"pt": "Bio padrão/restaurar", "en": "Restore Bio Text", "es": "Restaurar texto de bio", "fr": "Restaurer le texte de la bio", "ru": "Восстановить био"},

    "restore_bio_text_sub": {
        "pt": "Bio será restaurada automaticamente ao usar .now e não houver música tocando, ou ao usar .bio.",
        "en": "Bio will be restored automatically when you use .now and no music is playing, or when using .bio.",
        "es": "La bio se restaurará automáticamente al usar .now y no haya música, o al usar .bio.",
        "fr": "La bio sera restaurée automatiquement lors de l'utilisation de .now sans musique ou avec .bio.",
        "ru": "Био будет восстановлено автоматически при использовании .now без музыки или при использовании .bio."
    },
    "original_bio_captured": {
        "pt": "Bio original capturada automaticamente",
        "en": "Original bio captured automatically",
        "es": "Bio original capturada automáticamente",
        "fr": "Bio originale capturée automatiquement",
        "ru": "Оригинальная био захвачена автоматически"
    },
    "bio_command_info": {
        "pt": "Sobre a bio",
        "en": "About bio",
        "es": "Sobre la bio",
        "fr": "À propos de la bio",
        "ru": "О био"
    },
    "now_playing_section": {
    "pt": "Configurações do Now Playing",
    "en": "Now Playing Settings",
    "es": "Configuración de Now Playing",
    "fr": "Paramètres de Now Playing",
    "ru": "Настройки Now Playing"
    },
    "extra_section": {
        "pt": "Opções Extras",
        "en": "Extra Options",
        "es": "Opciones Extra",
        "fr": "Options Supplémentaires",
        "ru": "Дополнительные параметры"
    },
    "bio_command_info_dialog": {
        "pt": "Como usar os recursos da Bio\n\nEste painel permite automatizar e personalizar sua bio do Telegram com informações da música atual. Veja o que cada opção faz:\n\n• Ativar atualização automática da bio: liga/desliga a atualização automática da bio com a música em reprodução.\n• Mostrar notificação de bio: exibe uma notificação quando você executa um comando (como .now) e a bio é atualizada com uma música em reprodução.\n• Texto da bio: define o texto que será usado enquanto uma música estiver tocando. Você pode usar {track} e {artist} para inserir o nome da música e do artista.\n• Bio padrão/restaurar: define o texto que será restaurado na bio quando não houver música tocando ou ao usar o comando .bio.\n\nLimitações do Telegram:\n- A bio do Telegram tem limite de 70 caracteres. Textos maiores serão cortados.\n- Mudanças muito frequentes podem ser temporariamente bloqueadas.\n\nSobre o comando .bio:\n- O comando .bio restaura manualmente sua bio para o texto padrão.\n- Útil para remover rapidamente a música da bio.\n- Sempre exibe uma notificação ao restaurar.\n\nDica: personalize o texto da bio para deixar seu perfil mais interessante!\n\n• Smart Bio: permite atualizar a bio em tempo real com a música que você está ouvindo no Spotify.",

        "en": "How to Use Bio Features\n\nThis panel lets you automate and customize your Telegram bio with information about the current track. Here's what each option does:\n\n• Enable automatic bio update: turns automatic bio updates on or off based on the currently playing song.\n• Show bio notification: displays a notification when you run a command (like .now) and your bio is updated with a playing track.\n• Bio text: sets the text that will be used in your bio while a song is playing. You can use {track} and {artist} to insert the song title and artist name.\n• Restore bio text: sets the text that will be restored in your bio when no music is playing or when you use the .bio command.\n\nTelegram limitations:\n- Telegram limits the bio to 70 characters. Longer texts will be cut off.\n- Frequent changes may be temporarily blocked.\n\nAbout the .bio command:\n- The .bio command manually restores your bio to the default text.\n- Useful for quickly removing the song from your bio.\n- Always displays a notification when restoring.\n\nTip: customize your bio text to make your profile more interesting!\n\n• Smart Bio: allows real-time bio updates with the song you're currently listening to on Spotify.",

        "es": "Cómo usar las funciones de Bio\n\nEste panel te permite automatizar y personalizar tu biografía de Telegram con información sobre la canción en reproducción. Esto es lo que hace cada opción:\n\n• Activar actualización automática de la bio: activa o desactiva la actualización automática de la biografía con la canción en reproducción.\n• Mostrar notificación de bio: muestra una notificación cuando usas un comando (como .now) y se actualiza la biografía con la canción actual.\n• Texto de la bio: define el texto que se usará mientras haya una canción en reproducción. Puedes usar {track} y {artist} para insertar el nombre de la canción y el artista.\n• Restaurar texto de bio: define el texto que se restaurará en la biografía cuando no haya música o al usar el comando .bio.\n\nLimitaciones de Telegram:\n- Telegram limita la biografía a 70 caracteres. Los textos más largos serán cortados.\n- Cambios frecuentes pueden ser bloqueados temporalmente.\n\nSobre el comando .bio:\n- El comando .bio restaura manualmente tu biografía al texto predeterminado.\n- Útil para quitar rápidamente la canción de la biografía.\n- Siempre muestra una notificación al restaurar.\n\nConsejo: personaliza tu biografía para hacer tu perfil más interesante.\n\n• Smart Bio: permite actualizar la biografía en tiempo real con la canción que estás escuchando en Spotify.",

        "fr": "Comment utiliser les fonctions Bio\n\nCe panneau vous permet d'automatiser et de personnaliser votre bio Telegram avec les informations sur la musique en cours. Voici ce que fait chaque option :\n\n• Activer la mise à jour automatique de la bio : active ou désactive la mise à jour automatique de la bio avec la musique en cours.\n• Afficher la notification de bio : affiche une notification lorsque vous exécutez une commande (par exemple .now) et que la bio est mise à jour avec la musique en cours.\n• Texte de la bio : définit le texte utilisé dans votre bio pendant qu'une chanson est en cours de lecture. Vous pouvez utiliser {track} et {artist} pour insérer le nom du morceau et de l'artiste.\n• Restaurer le texte de la bio : définit le texte qui sera restauré dans la bio lorsque plus aucune musique ne joue ou lors de l'utilisation de la commande .bio.\n\nLimitations de Telegram :\n- La bio est limitée à 70 caractères. Les textes plus longs seront tronqués.\n- Les changements fréquents peuvent être temporairement bloqués.\n\nÀ propos de la commande .bio :\n- La commande .bio restaure manuellement votre bio au texte par défaut.\n- Utile pour retirer rapidement la musique de la bio.\n- Affiche toujours une notification lors de la restauration.\n\nAstuce : personnalisez votre bio pour rendre votre profil plus intéressant !\n\n• Smart Bio : permet de mettre à jour la bio en temps réel avec la musique que vous écoutez sur Spotify.",

        "ru": "Как использовать функции био\n\nЭтот раздел позволяет автоматизировать и настроить вашу био в Telegram с информацией о текущем треке. Вот что делает каждая опция:\n\n• Включить автообновление био: включает или отключает автоматическое обновление био в зависимости от текущей песни.\n• Показывать уведомление о био: показывает уведомление, когда вы выполняете команду (например, .now), и био обновляется с текущим треком.\n• Текст био: задаёт текст, который будет использоваться в био во время воспроизведения музыки. Можно использовать {track} и {artist} для вставки названия трека и исполнителя.\n• Восстановить био: задаёт текст, который будет восстановлен в био, если музыка не играет или при использовании команды .bio.\n\nОграничения Telegram:\n- Био ограничено 70 символами. Более длинные тексты будут обрезаны.\n- Частые изменения могут быть временно заблокированы.\n\nО команде .bio:\n- Команда .bio вручную восстанавливает био к стандартному тексту.\n- Полезно для быстрого удаления трека из био.\n- Всегда отображает уведомление при восстановлении.\n\nСовет: настройте текст био, чтобы сделать профиль более интересным!\n\n• Smart Bio: позволяет обновлять био в реальном времени с песней, которую вы слушаете в Spotify."
    }, 
    "bulletin_pausing": {"pt": "Pausando música...", "en": "Pausing music...", "es": "Pausando música...", "fr": "Pause de la musique...", "ru": "Пауза музыки..."},
    "bulletin_playing": {"pt": "Tocando música...", "en": "Playing music...", "es": "Reproduciendo música...", "fr": "Lecture de la musique...", "ru": "Воспроизведение музыки..."},
    "search_results": {"pt": "Resultados da busca:", "en": "Search results:", "es": "Resultados de la búsqueda:", "fr": "Résultats de la recherche:", "ru": "Результаты поиска:"},
    "font_selector_label": {"pt": "Fontes", "en": "Fonts", "es": "Fuentes", "fr": "Polices", "ru": "Шрифты"},
    "extera_bar_label": {"pt": "exteraBar", "en": "exteraBar", "es": "exteraBar", "fr": "exteraBar", "ru": "exteraBar"},
    "extera_bar_sub": {
        "pt": "Barra de progresso da música (funciona apenas com Spotify ou .fm usando Spotify).",
        "en": "Music progress bar (works only with Spotify or .fm using Spotify).",
        "es": "Barra de progreso de la música (funciona solo con Spotify o .fm usando Spotify).",
        "fr": "Barre de progression musicale (fonctionne uniquement avec Spotify ou .fm utilisant Spotify).",
        "ru": "Индикатор прогресса музыки (работает только со Spotify или .fm используя Spotify)."
    },
    "liked_success": {"pt": "Faixa curtida!", "en": "Liked!", "es": "¡Favorito!", "fr": "Favori!", "ru": "Понравилось!"},
    "unliked_success": {"pt": "Faixa removida dos curtidos!", "en": "Unliked!", "es": "¡Desfavorito!", "fr": "Désaimé!", "ru": "Не понравилось!"},
    "error_invalid_number": {"pt": "Número inválido.", "en": "Invalid number.", "es": "Número inválido.", "fr": "Nombre invalide.", "ru": "Неверный номер."},
    "queue_success": {"pt": "Adicionado à fila!", "en": "Added to queue!", "es": "Adicionado a la fila!", "fr": "Ajouté à la file d'attente!", "ru": "Добавлено в очередь!"},
    "error_premium_required": {"pt": "Requer Spotify Premium.", "en": "Requires Spotify Premium.", "es": "Requiere Spotify Premium.", "fr": "Requiert Spotify Premium.", "ru": "Требуется Spotify Premium."},
    "error_no_active_device": {"pt": "Nenhum dispositivo ativo encontrado.", "en": "No active device found.", "es": "No se encontró dispositivo activo.", "fr": "Aucun appareil actif trouvé.", "ru": "Активное устройство не найдено."},
    "exchanging_code": {
        "pt": "Trocando código de autorização...",
        "en": "Exchanging authorization code...",
        "es": "Intercambiando código de autorización...",
        "fr": "Échange du code d'autorisation...",
        "ru": "Обмен кода авторизации..."
    },
    "code_exchange_error": {
        "pt": "Erro ao trocar código.",
        "en": "Error exchanging code.",
        "es": "Error al intercambiar código.",
        "fr": "Erreur lors de l'échange du code.",
        "ru": "Ошибка при обмене кода."
    },
    "client_id_or_secret_missing": {
        "pt": "Client ID ou Secret não configurados nas configurações!",
        "en": "Client ID or Secret not set in settings!",
        "es": "¡Client ID o Secret no configurados en la configuración!",
        "fr": "Client ID ou Secret non configurés dans les paramètres!",
        "ru": "Client ID или Secret не указаны в настройках!"
    },
    "visual_effects_section": {
        "pt": "Efeitos Visuais",
        "en": "Visual Effects",
        "es": "Efectos Visuales",
        "fr": "Effets Visuels",
        "ru": "Визуальные эффекты"
    },
    "random_theme_mode": {
        "pt": "Modo Aleatório de Tema",
        "en": "Random Theme Mode",
        "es": "Modo de Tema Aleatorio",
        "fr": "Mode Thème Aléatoire",
        "ru": "Случайный режим темы"
    },
    "random_theme_mode_sub": {
        "pt": "Ative para usar um tema de card aleatório a cada vez",
        "en": "Enable to use a random card theme each time",
        "es": "Activa para usar un tema de tarjeta aleatorio cada vez",
        "fr": "Activez pour utiliser un thème de carte aléatoire à chaque fois",
        "ru": "Включите, чтобы использовать случайную тему карточки каждый раз"
    },
    "use_play_command": {
        "en": "To play a result, use .play followed by its number or ID",
        "pt": "Para tocar um resultado, use .play seguido do número ou ID",
        "es": "Para reproducir un resultado, usa .play seguido del número o ID",
        "fr": "Pour lire un résultat, utilisez .play suivi du numéro ou de l'ID",
        "ru": "Чтобы воспроизвести результат, используйте .play с номером или ID"
    },
    "bio_updated_short": {"pt": "Bio atualizada com música", "en": "Bio updated with song", "es": "Bio actualizada con música", "fr": "Bio mise à jour avec musique", "ru": "Био обновлено с треком"},
    "bio_restored_auto": {"pt": "Bio restaurada automaticamente", "en": "Bio restored automatically", "es": "Bio restaurada automáticamente", "fr": "Bio restaurée automatiquement", "ru": "Био восстановлено автоматически"},
    "bio_notification_disabled": {
        "pt": "Notificação ativada, mas auto-refresh desativado",
        "en": "Notification enabled, but auto-refresh disabled",
        "es": "Notificación activada, pero auto-actualización desactivada",
        "fr": "Notification activée, mais actualisation auto désactivée",
        "ru": "Уведомление включено, но автообновление отключено"
    },
    "lastfm_settings": {
        "pt": "Configurações do LastFM",
        "en": "LastFM Settings",
        "es": "Configuración de LastFM",
        "fr": "Paramètres LastFM",
        "ru": "Настройки LastFM"
    },
    "tg_command": {
        "pt": "Comando Telegram",
        "en": "Telegram Command",
        "es": "Comando Telegram",
        "fr": "Commande Telegram",
        "ru": "Команда Telegram"
    },
    "tg_command_sub": {
        "pt": "Mostra a música atual do Telegram/Exteragram/Ayugram",
        "en": "Shows current track from Telegram/Exteragram/Ayugram",
        "es": "Muestra la pista actual de Telegram/Exteragram/Ayugram",
        "fr": "Affiche la piste actuelle de Telegram/Exteragram/Ayugram",
        "ru": "Показывает текущий трек из Telegram/Exteragram/Ayugram"
    },
    "help_title": {
        "pt": "Comandos Disponíveis",
        "en": "Available Commands",
        "es": "Comandos Disponibles",
        "fr": "Commandes Disponibles",
        "ru": "Доступные команды"
    },
    "help_message": {
        "pt": "˪ Comandos disponíveis do nowFy:\n\n• .now - Mostra a música atual do Spotify\n• .fm - Mostra a música atual do LastFM\n• .stats - Mostra a música atual do Stats.fm\n• .etg - Mostra a música atual do exteraGram\n• .ayu - Mostra a música atual do AyuGram\n• .clear - Limpar cache do plugin\n• .list - Mostra as últimas 5 músicas tocadas\n• .play - Toca a música atual ou .play <número> para tocar da lista\n• .pause - Pausa a reprodução\n• .skip - Pula para a próxima música\n• .back - Volta para a música anterior\n• .vol - Mostra o volume atual ou .vol <valor> para definir\n• .repeat - Mostra o modo de repetição ou .repeat <modo> para definir\n• .like - Adiciona a música atual aos favoritos ou .like <track_id>\n• .bio - Restaura a bio padrão\n• .code - Mostra instruções para autenticação ou .code <código>\n• .setid <id> - Define o Client ID do Spotify\n• .setsecret <secret> - Define o Client Secret do Spotify\n• .check - Valida as credenciais do Spotify\n• .connect - Gera o link para conectar sua conta Spotify\n• .search <termo> - Busca músicas no Spotify\n• .like now - Adiciona a música atual aos favoritos\n\nBackup e Restauração:\n• .export - Exporta todas as configurações para backup\n• .import - Importa configurações de um backup\n• .backups - Lista todos os backups disponíveis\n\nLastFM:\n• .setuser <usuário> - Define o usuário do LastFM\n• .setkey <api_key> - Define a chave da API do LastFM",
        "en": "˪ Available nowFy Commands:\n\n• .now - Show current playing track from Spotify (or your custom command)\n• .fm - Show current track from LastFM\n• .stats - Show current track from Stats.fm\n• .etg - Show current track from exteraGram\n• .ayu - Show current track from AyuGram\n• .clear - Clear plugin cache\n• .list - Show last 5 played tracks\n• .play - Play current track or .play <number> to play from list\n• .pause - Pause playback\n• .skip - Skip to next track\n• .back - Go back to previous track\n• .vol - Show current volume or .vol <value> to set\n• .repeat - Show repeat mode or .repeat <mode> to set\n• .like - Add current track to favorites or .like <track_id>\n• .bio - Restore default bio\n• .code - Show authentication instructions or .code <code>\n• .setid <id> - Set Spotify Client ID\n• .setsecret <secret> - Set Spotify Client Secret\n• .check - Validate Spotify credentials\n• .connect - Generate link to connect your Spotify account\n• .search <term> - Search tracks on Spotify\n• .like now - Add current track to favorites\n\nBackup & Restore:\n• .export - Export all settings to backup\n• .import - Import settings from backup\n• .backups - List all available backups\n\nLastFM:\n• .setuser <username> - Set LastFM username\n• .setkey <api_key> - Set LastFM API key",
        "es": "˪ Comandos disponibles de nowFy:\n\n• .now - Muestra la pista actual de Spotify\n• .fm - Muestra la pista actual de LastFM\n• .list - Muestra las últimas 5 pistas reproducidas\n• .play - Reproduce la pista actual o .play <número> para reproducir de la lista\n• .pause - Pausa la reproducción\n• .skip - Salta a la siguiente pista\n• .back - Vuelve a la pista anterior\n• .vol - Muestra el volumen actual o .vol <valor> para definir\n• .repeat - Muestra el modo de repetición o .repeat <modo> para definir\n• .like - Añade la pista actual a favoritos o .like <track_id>\n• .bio - Restaura la bio por defecto\n• .code - Muestra instrucciones de autenticación o .code <código>\n• .setid <id> - Define el Client ID de Spotify\n• .setsecret <secret> - Define el Client Secret de Spotify\n• .check - Valida las credenciales de Spotify\n• .connect - Genera el enlace para conectar tu cuenta de Spotify\n• .search <término> - Busca pistas en Spotify\n• .like now - Añade la pista actual a favoritos\n\nCopia de Seguridad:\n• .export - Exporta todas las configuraciones\n• .import - Importa configuraciones desde copia\n• .backups - Lista todas las copias disponibles\n\nLastFM:\n• .setuser <usuario> - Define el usuario de LastFM\n• .setkey <api_key> - Define la clave API de LastFM",
        "fr": "˪ Commandes nowFy disponibles:\n\n• .now - Afficher la piste en cours de Spotify\n• .fm - Afficher la piste en cours de LastFM\n• .list - Afficher les 5 dernières pistes\n• .play - Lire la piste actuelle ou .play <numéro> pour lire depuis la liste\n• .pause - Mettre en pause la lecture\n• .skip - Passer à la piste suivante\n• .back - Revenir à la piste précédente\n• .vol - Afficher le volume actuel ou .vol <valeur> pour définir\n• .repeat - Afficher le mode répétition ou .repeat <mode> pour définir\n• .like - Ajouter la piste actuelle aux favoris ou .like <track_id>\n• .bio - Restaurer la bio par défaut\n• .code - Afficher les instructions d'authentification ou .code <code>\n• .setid <id> - Définir le Client ID Spotify\n• .setsecret <secret> - Définir le Client Secret Spotify\n• .check - Valider les identifiants Spotify\n• .connect - Générer le lien pour connecter votre compte Spotify\n• .search <terme> - Rechercher des pistes sur Spotify\n• .like now - Ajouter la piste actuelle aux favoris\n\nSauvegarde et Restauration:\n• .export - Exporter toutes les configurations\n• .import - Importer les configurations\n• .backups - Lister toutes les sauvegardes\n\nLastFM:\n• .setuser <utilisateur> - Définir le nom d'utilisateur LastFM\n• .setkey <api_key> - Définir la clé API LastFM",
        "ru": "˪ Доступные команды nowFy:\n\n• .now - Показать текущий трек Spotify\n• .fm - Показать текущий трек LastFM\n• .list - Показать последние 5 треков\n• .play - Воспроизвести текущий трек или .play <номер> для воспроизведения из списка\n• .pause - Пауза воспроизведения\n• .skip - Следующий трек\n• .back - Предыдущий трек\n• .vol - Показать текущую громкость или .vol <значение> для установки\n• .repeat - Показать режим повтора или .repeat <режим> для установки\n• .like - Добавить текущий трек в избранное или .like <track_id>\n• .bio - Восстановить био по умолчанию\n• .code - Показать инструкции по авторизации или .code <код>\n• .setid <id> - Установить Client ID Spotify\n• .setsecret <secret> - Установить Client Secret Spotify\n• .check - Проверить учетные данные Spotify\n• .connect - Сгенерировать ссылку для подключения аккаунта Spotify\n• .search <запрос> - Поиск треков в Spotify\n• .like now - Добавить текущий трек в избранное\n\nРезервное копирование:\n• .export - Экспорт всех настроек\n• .import - Импорт настроек из резервной копии\n• .backups - Список всех резервных копий\n\nLastFM:\n• .setuser <имя> - Установить имя пользователя LastFM\n• .setkey <api_key> - Установить API ключ LastFM"
    },
    "error_youtube_api_key": {
        "pt": "Chave da API do YouTube não configurada",
        "en": "YouTube API key not configured",
        "es": "Clave API de YouTube no configurada",
        "fr": "Clé API YouTube non configurée",
        "ru": "Ключ API YouTube не настроен"
    },
    "error_youtube_api": {
        "pt": "Erro na API do YouTube: {}",
        "en": "YouTube API error: {}",
        "es": "Error en la API de YouTube: {}",
        "fr": "Erreur API YouTube: {}",
        "ru": "Ошибка API YouTube: {}"
    },
    "about_plugin_header": {
        "en": "Support the Project",
        "pt": "Incentivo ao Projeto",
        "es": "Apoya el Proyecto",
        "fr": "Soutenir le projet",
        "ru": "Поддержать проект"
    },
    "about_plugin_donate": {
        "en": "Donate (PIX Brazil)",
        "pt": "Doar (PIX Brasil)",
        "es": "Donar (PIX Brazil)",
        "fr": "Faire un don (PIX Brazil)",
        "ru": "Донат (PIX Brazil)"
    },
    "about_plugin_donate_kofi": {
        "en": "Donate (Ko-fi)",
        "pt": "Doar (Ko-fi)",
        "es": "Donar (Ko-fi)",
        "fr": "Faire un don (Ko-fi)",
        "ru": "Донат (Ko-fi)"
    },
    "about_plugin_description": {
        "en": "This plugin was created to integrate Spotify and LastFM/StatsFM into exteraGram/AyuGram in a visual and functional way. It allows you to show what you're listening to with a stylish image and automatically updates your bio with the currently playing track.\n\nIt also offers multi-language support and simple configuration options to make it your own, without complication.",
        "pt": "Esse plugin foi criado para integrar Spotify e LastFM/StatsFM ao exteraGram/AyuGram de forma visual e funcional. Ele permite mostrar o que você está ouvindo com uma imagem estilizada e atualiza a bio automaticamente com a faixa em reprodução.\n\nTambém oferece suporte a múltiplos idiomas e opções simples de configuração para deixar do seu jeito, sem complicação.",
        "es": "Este plugin fue creado para integrar Spotify y LastFM/StatsFM en exteraGram/AyuGram de forma visual y funcional. Permite mostrar lo que estás escuchando con una imagen estilizada y actualiza la bio automáticamente con la pista en reproducción.\n\nTambién ofrece soporte multilingüe y opciones de configuración simples para dejarlo a tu gusto, sin complicaciones.",
        "fr": "Ce plugin a été créé pour intégrer Spotify et LastFM/StatsFM à exteraGram/AyuGram de manière visuelle et fonctionnelle. Il permet d'afficher ce que vous écoutez avec une image stylisée et met à jour automatiquement la bio avec la piste en cours de lecture.\n\nIl offre également la prise en charge de plusieurs langues et des options de configuration simples pour l'adapter à vos besoins, sans complication.",
        "ru": "Этот плагин создан для интеграции Spotify и LastFM/StatsFM в exteraGram/AyuGram визуально и функционально. Он позволяет показывать, что вы слушаете, с помощью стильного изображения и автоматически обновляет био с текущим треком.\n\nТакже поддерживает несколько языков и простые настройки, чтобы сделать всё по-своему, без лишних сложностей."
    },
    "error_youtube_quota": {
        "pt": "Cota da API do YouTube excedida",
        "en": "YouTube API quota exceeded",
        "es": "Cuota de la API de YouTube excedida",
        "fr": "Quota API YouTube dépassé",
        "ru": "Квота API YouTube превышена"
    },
    "backup_exported": {
        "pt": "Backup exportado com sucesso!",
        "en": "Backup exported successfully!",
        "es": "Backup exportado exitosamente!",
        "fr": "Sauvegarde exportée avec succès!",
        "ru": "Резервная копия успешно экспортирована!"
    },
    "backup_imported": {
        "pt": "Backup importado com sucesso!",
        "en": "Backup imported successfully!",
        "es": "Backup importado exitosamente!",
        "fr": "Sauvegarde importée avec succès!",
        "ru": "Резервная копия успешно импортирована!"
    },
    "backup_error": {
        "pt": "Erro no sistema de backup: {}",
        "en": "Backup system error: {}",
        "es": "Error en el sistema de backup: {}",
        "fr": "Erreur du système de sauvegarde: {}",
        "ru": "Ошибка системы резервного копирования: {}"
    },
    "no_backups_found": {
        "pt": "Nenhum backup encontrado",
        "en": "No backups found",
        "es": "No se encontraron backups",
        "fr": "Aucune sauvegarde trouvée",
        "ru": "Резервные копии не найдены"
    },
    "about_custom_fonts": {
        "pt": "Fontes Personalizadas",
        "en": "Custom Fonts",
        "es": "Fuentes Personalizadas",
        "ru": "Пользовательские шрифты",
        "fr": "Polices personnalisées"
    },
    "custom_fonts_help": {
        "pt": "Ajuda sobre fontes personalizadas",
        "en": "Custom Fonts Help",
        "es": "Ayuda de fuentes personalizadas",
        "fr": "Aide sur les polices personnalisées",
        "ru": "Справка по пользовательским шрифтам"
    },
    "how_to_use_premium_emoji": {
        "pt": "Premium Emoji",
        "en": "Premium Emoji",
        "es": "Emoji Premium",
        "fr": "Emoji Premium",
        "ru": "Премиум Эмодзи"
    },
    "premium_emoji_help_title": {
        "pt": "Como Usar Premium Emoji",
        "en": "How to Use Premium Emoji",
        "es": "Cómo Usar Emoji Premium",
        "fr": "Comment Utiliser les Emoji Premium",
        "ru": "Как Использовать Премиум Эмодзи"
    },
    "premium_emoji_help_content": {
    "pt": "Para usar emojis Premium personalizados, é obrigatório ser um usuário Premium do Telegram.\n\nPara adicionar um emoji Premium no custom caption, você deve usar o formato:\n\n \n\n(Substitua o ID pelo do seu emoji)\n\nVocê pode descobrir o ID de qualquer emoji Premium enviando o emoji para o bot @AdsMarkdownBot e copiando o ID retornado. O formato final sempre será assim: [emoji](id).",
    "en": "To use custom Premium emojis, you must be a Telegram Premium user.\n\nTo add a Premium emoji in the custom caption, use the format:\n\n \n\n(Replace the ID with your emoji's ID)\n\nYou can find the ID of any Premium emoji by sending it to the @AdsMarkdownBot and copying the returned ID. The final format will always be: [emoji](id).",
    "es": "Para usar emojis Premium personalizados, debes ser usuario Premium de Telegram.\n\nPara agregar un emoji Premium en el pie de foto personalizado, usa el formato:\n\n \n\n(Reemplaza el ID por el de tu emoji)\n\nPuedes encontrar el ID de cualquier emoji Premium enviándolo al bot @AdsMarkdownBot y copiando el ID devuelto. El formato final siempre será: [emoji](id).",
    "fr": "Pour utiliser des emojis Premium personnalisés, vous devez être utilisateur Telegram Premium.\n\nPour ajouter un emoji Premium dans la légende personnalisée, utilisez le format :\n\n \n\n(Remplacez l'ID par celui de votre emoji)\n\nVous pouvez trouver l'ID d'un emoji Premium en l'envoyant au bot @AdsMarkdownBot et en copiant l'ID retourné. Le format final sera toujours : [emoji](id).",
    "ru": "Чтобы использовать пользовательские премиум-эмодзи, вы должны быть пользователем Telegram Premium.\n\nЧтобы добавить премиум-эмодзи в пользовательскую подпись, используйте формат:\n\n \n\n(Замените ID на ID вашего эмодзи)\n\nВы можете узнать ID любого премиум-эмодзи, отправив его боту @AdsMarkdownBot и скопировав возвращённый ID. Итоговый формат всегда будет таким: [emoji](id)."
    },
    "custom_fonts_help_dialog": {
        "pt": "Para usar fontes personalizadas, coloque arquivos .ttf ou .otf na pasta:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nDepois, selecione a fonte desejada no seletor de fontes.",
        "en": "To use custom fonts, place .ttf or .otf files in the folder:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nThen select the desired font in the font selector.",
        "es": "Para usar fuentes personalizadas, coloque archivos .ttf o .otf en la carpeta:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nLuego seleccione la fuente deseada en el selector de fuentes.",
        "fr": "Pour utiliser des polices personnalisées, placez les fichiers .ttf ou .otf dans le dossier :\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nEnsuite, sélectionnez la police souhaitée dans le sélecteur de polices.",
        "ru": "Чтобы использовать пользовательские шрифты, поместите файлы .ttf или .otf в папку:\n/storage/emulated/0/Android/media/com.exteragram.messenger/fonts\nЗатем выберите нужный шрифт в селекторе шрифтов."
    },
    "client_id_missing": {
        "pt": "Client ID não configurado nas credenciais!",
        "en": "Client ID not set in credentials!",
        "es": "¡Client ID no configurado en las credenciales!",
        "fr": "Client ID non configuré dans les identifiants!",
        "ru": "Client ID не указан в учетных данных!"
    },
    "error_auth": {"pt": "Erro de autenticação", "en": "Authentication error", "es": "Error de autenticación", "fr": "Erreur d'authentification", "ru": "Ошибка авторизации"},
    "credentials_missing_title": {"pt": "Credenciais Ausentes", "en": "Missing Credentials", "es": "Credenciales Ausentes", "fr": "Identifiants Manquants", "ru": "Отсутствуют Учетные Данные"},
    "credentials_missing_message": {"pt": "As seguintes credenciais estão ausentes: {fields}. Configure-as nas configurações do plugin.", "en": "The following credentials are missing: {fields}. Configure them in the plugin settings.", "es": "Las siguientes credenciais están ausentes: {fields}. Configúralas en la configuración del plugin.", "fr": "Les identifiants suivants sont manquants : {fields}. Configurez-les dans les paramètres du plugin.", "ru": "Отсутствуют следующие учетные данные: {fields}. Настройте их в параметрах плагина."},
    "credentials_invalid_title": {"pt": "Credenciais Inválidas", "en": "Invalid Credentials", "es": "Credenciales Inválidas", "fr": "Identifiants Invalides", "ru": "Неверные Учетные Данные"},
    "credentials_invalid_message": {"pt": "As credenciais {fields} estão incorretas. Verifique se foram inseridas corretamente.", "en": "The credentials {fields} are incorrect. Please verify they were entered correctly.", "es": "Las credenciales {fields} son incorrectas. Verifica que se hayan ingresado correctamente.", "fr": "Les identifiants {fields} sont incorrects. Vérifiez qu'ils ont été saisis correctement.", "ru": "Учетные данные {fields} неверны. Проверьте правильность ввода."},
    "refresh_token_invalid_title": {"pt": "Token de Refresh Inválido", "en": "Invalid Refresh Token", "es": "Token de Refresh Inválido", "fr": "Token de Rafraîchissement Invalide", "ru": "Неверный Токен Обновления"},
    "refresh_token_invalid_message": {"pt": "O token de refresh expirou ou é inválido. Faça a autenticação novamente.", "en": "The refresh token has expired or is invalid. Please authenticate again.", "es": "El token de refresh ha expirado o es inválido. Autentica nuevamente.", "fr": "Le token de rafraîchissement a expiré ou est invalide. Veuillez vous authentifier à nouveau.", "ru": "Токен обновления истек или недействителен. Пожалуйста, пройдите аутентификацию снова."},
    "api_error_title": {"pt": "Erro da API do Spotify", "en": "Spotify API Error", "es": "Error de la API de Spotify", "fr": "Erreur de l'API Spotify", "ru": "Ошибка API Spotify"},
    "api_error_message": {"pt": "Ocorreu um erro na comunicação com a API do Spotify. Tente novamente mais tarde.", "en": "An error occurred while communicating with the Spotify API. Please try again later.", "es": "Ocurrió un error al comunicarse con la API de Spotify. Inténtalo de nuevo más tarde.", "fr": "Une erreur s'est produite lors de la communication avec l'API Spotify. Veuillez réessayer plus tard.", "ru": "Произошла ошибка при обращении к API Spotify. Попробуйте еще раз позже."},
    "connection_error_title": {"pt": "Erro de Conexão", "en": "Connection Error", "es": "Error de Conexión", "fr": "Erreur de Connexion", "ru": "Ошибка Соединения"},
    "connection_error_message": {"pt": "Não foi possível conectar com o Spotify. Verifique sua conexão com a internet.", "en": "Could not connect to Spotify. Please check your internet connection.", "es": "No se pudo conectar con Spotify. Verifica tu conexión a internet.", "fr": "Impossible de se connecter à Spotify. Vérifiez votre connexion internet.", "ru": "Не удалось подключиться к Spotify. Проверьте подключение к интернету."},
    "no_active_device": {
        "pt": "Nenhum dispositivo ativo encontrado.",
        "en": "No active device found.",
        "es": "No se encontró ningún dispositivo activo.",
        "fr": "Aucun appareil actif trouvé.",
        "ru": "Активное устройство не найдено."
    },
    "error_playback": {"pt": "Erro ao reproduzir", "en": "Error playing", "es": "Error al reproducir", "fr": "Erreur lors de la lecture", "ru": "Ошибка воспроизведения"},
    "error_no_device": {"pt": "Nenhum dispositivo encontrado", "en": "No device found", "es": "Ningún dispositivo encontrado", "fr": "Aucun appareil trouvé", "ru": "Устройство не найдено"},
    "error_token": {"pt": "Token inválido", "en": "Invalid token", "es": "Token no válido", "fr": "Token invalide", "ru": "Неверный токен"},
    "error_unknown": {"pt": "Erro desconhecido", "en": "Unknown error", "es": "Error desconocido", "fr": "Erreur inconnue", "ru": "Неизвестная ошибка"},
    "error_code": {"pt": "Erro de código", "en": "Code error", "es": "Error de código", "fr": "Erreur de code", "ru": "Ошибка кода"},
    "list_bulletin_title": {
        "pt": "Aqui está sua lista:",
        "en": "Here is your list:",
        "es": "Aquí está tu lista:",
        "fr": "Voici votre liste:",
        "ru": "Вот ваш список:"
    },
    "copy_button": {
        "pt": "Copiar",
        "en": "Copy",
        "es": "Copiar",
        "fr": "Copier",
        "ru": "Копировать"
    },
    "copied_bulletin": {
        "pt": "Copiado!",
        "en": "Copied!",
        "es": "¡Copiado!",
        "fr": "Copié!",
        "ru": "Скопировано!"
    },
    "copied_to_clipboard": {
        "pt": "{label} copiado para a área de transferência",
        "en": "Copied {label} to clipboard",
        "es": "{label} copiado al portapapeles",
        "fr": "{label} copié dans le presse-papiers",
        "ru": "{label} скопировано в буфер обмена"
    },
    "list_bulletin_short": {
        "pt": "Sua lista foi atualizada!\nClique em copiar para conferir.",
        "en": "Your list is ready!\nTap copy to check it.",
        "es": "¡Tu lista está pronta!\nPulsa copiar para ver.",
        "fr": "Votre liste est prête!\nAppuyez sur copier pour voir.",
        "ru": "Ваш список готов!\nНажмите копировать, чтобы посмотреть."
    },
    "recently_played_title": {
        "pt": "Suas músicas mais ouvidas recentemente:\n",
        "en": "Your recently played tracks:\n",
        "es": "Tus canciones reproducidas recientemente:\n",
        "fr": "Vos morceaux écoutés récemment :\n",
        "ru": "Ваши недавно прослушанные треки:\n"
    },
    "bulletin_paused": {
        "pt": "Música pausada!",
        "en": "Music paused!",
        "es": "¡Música pausada!",
        "fr": "Musique en pause!",
        "ru": "Музыка на паузе!"
    },
    "bulletin_resumed": {
        "pt": "Música retomada!",
        "en": "Music resumed!",
        "es": "¡Música retomada!",
        "fr": "Musique reprise!",
        "ru": "Музыка возобновлена!"
    },
    "bulletin_skipped": {
        "pt": "Faixa pulada!",
        "en": "Track skipped!",
        "es": "¡Canción saltada!",
        "fr": "Morceau passé!",
        "ru": "Трек пропущен!"
    },
    "bulletin_previous": {
        "pt": "Faixa anterior!",
        "en": "Previous track!",
        "es": "¡Canción anterior!",
        "fr": "Morceau précédent!",
        "ru": "Предыдущий трек!"
    },
    "bulletin_volume_set": {
        "pt": "Volume ajustado para {value}%!",
        "en": "Volume set to {value}%!",
        "es": "¡Volumen ajustado a {value}%!",
        "fr": "Volume réglé à {value}% !",
        "ru": "Громкость установлена на {value}%!"
    },
    "error_invalid_volume": {
        "pt": "Volume deve ser um número entre 0 e 100.",
        "en": "Volume must be a number between 0 and 100.",
        "es": "El volumen debe ser un número entre 0 y 100.",
        "fr": "Le volume doit être un nombre entre 0 et 100.",
        "ru": "Громкость должна быть числом от 0 до 100."
    },
    "bulletin_repeat_off": {
        "pt": "Repeat desativado!",
        "en": "Repeat off!",
        "es": "Repetición desactivada!",
        "fr": "Répétition désactivée!",
        "ru": "Повтор выключен!"
    },
    "bulletin_repeat_context": {
        "pt": "Repeat de playlist ativado!",
        "en": "Context repeat enabled!",
        "es": "Repetir contexto activado!",
        "fr": "Répétition du contexte activée!",
        "ru": "Повтор контекста включён!"
    },
    "bulletin_repeat_track": {
        "pt": "Repeat de faixa ativado!",
        "en": "Track repeat enabled!",
        "es": "Repetir faixa activado!",
        "fr": "Répétition de la piste activée!",
        "ru": "Повтор трека включён!"
    },
    "error_invalid_repeat": {
        "pt": "Modo repeat inválido. Use: off, context ou track.",
        "en": "Invalid repeat mode. Use: off, context or track.",
        "es": "Modo de repetición inválido. Use: off, context o track.",
        "fr": "Mode de répétition invalide. Utilisez : off, context ou track.",
        "ru": "Недопустимый режим повтора. Используйте: off, context или track."
    },
    "error_missing_volume": {
        "pt": "Use .vol <0-100> para definir o volume.",
        "en": "Use .vol <0-100> to set the volume.",
        "es": "Usa .vol <0-100> para ajustar el volumen.",
        "fr": "Utilisez .vol <0-100> pour régler le volume.",
        "ru": "Используйте .vol <0-100> для установки громкости."
    },
    "error_missing_repeat": {
        "pt": "Use .repeat <off|context|track> para definir o modo repeat.",
        "en": "Use .repeat <off|context|track> to set repeat mode.",
        "es": "Usa .repeat <off|context|track> para definir el modo de repetición.",
        "fr": "Utilisez .repeat <off|context|track> pour définir le mode de répétition.",
        "ru": "Используйте .repeat <off|context|track> для установки режима повтора."
    },
    "error_missing_code": {
        "pt": "Use .code <código> para trocar o código de autorização.",
        "en": "Use .code <code> to exchange the authorization code.",
        "es": "Usa .code <código> para intercambiar el código de autorización.",
        "fr": "Utilisez .code <code> pour échanger le code d'autorisation.",
        "ru": "Используйте .code <код> для обмена кода авторизации."
    },
    "error_missing_setid": {
        "pt": "Use .setid <client_id> para definir o Client ID.",
        "en": "Use .setid <client_id> to set the Client ID.",
        "es": "Usa .setid <client_id> para definir el Client ID.",
        "fr": "Utilisez .setid <client_id> pour définir le Client ID.",
        "ru": "Используйте .setid <client_id> для установки Client ID."
    },
    "error_missing_setsecret": {
        "pt": "Use .setsecret <client_secret> para definir o Client Secret.",
        "en": "Use .setsecret <client_secret> to set the Client Secret.",
        "es": "Usa .setsecret <client_secret> para definir el Client Secret.",
        "fr": "Utilisez .setsecret <client_secret> pour définir le Client Secret.",
        "ru": "Используйте .setsecret <client_secret> для установки Client Secret."
    },
    "bulletin_liked": {
        "pt": "Música adicionada aos favoritos!",
        "en": "Track added to favorites!",
        "es": "¡Canción añadida a favoritos!",
        "fr": "Morceau ajouté aux favoris!",
        "ru": "Трек добавлен в избранное!"
    },
    "advanced_options_title": {"pt": "Opções Avançadas", "en": "Advanced Options", "es": "Opciones Avanzadas", "fr": "Options Avancées", "ru": "Дополнительные Параметры"}, 
    "bulletin_already_liked": {
        "pt": "Esta música já está nos seus favoritos!",
        "en": "This track is already in your favorites!",
        "es": "¡Esta canción ya está en tus favoritos!",
        "fr": "Ce morceau est déjà dans vos favoris!",
        "ru": "Этот трек уже в избранном!"
    },
    "error_no_track_playing": {
        "pt": "Nenhuma música tocando no momento.",
        "en": "No track playing right now.",
        "es": "No hay música reproduciéndose ahora.",
        "fr": "Aucun morceau en cours de lecture.",
        "ru": "Сейчас ничего не играет."
    },
    "error_missing_like": {
        "pt": "Use .like <track_id> para curtir uma música.",
        "en": "Use .like <track_id> to like a track.",
        "es": "Usa .like <track_id> para marcar una canción como favorita.",
        "fr": "Utilisez .like <track_id> pour ajouter un morceau aux favoris.",
        "ru": "Используйте .like <track_id> чтобы добавить трек в избранное."
    },
    "error_missing_search": {
        "pt": "Use .search <termo> para buscar músicas, álbuns ou artistas.",
        "en": "Use .search <term> to search for tracks, albums or artists.",
        "es": "Usa .search <término> para buscar canciones, álbumes o artistas.",
        "fr": "Utilisez .search <terme> pour rechercher des morceaux, albums ou artistes.",
        "ru": "Используйте .search <запрос> для поиска треков, альбомов или исполнителей."
    },
    "dotted_credit": {"pt": "Dotted Plugins", "en": "Dotted Plugins", "es": "Dotted Plugins", "fr": "Dotted Plugins", "ru": "Dotted Plugins"},
    "lastfm_username": {
        "pt": "Usuário do LastFM",
        "en": "LastFM Username",
        "es": "Usuario de LastFM",
        "fr": "Nom d'utilisateur LastFM",
        "ru": "Имя пользователя LastFM"
    },
    "lastfm_username_sub": {
        "pt": "Seu nome de usuário do LastFM",
        "en": "Your LastFM username",
        "es": "Tu usuario de LastFM",
        "fr": "Votre nom d'utilisateur LastFM",
        "ru": "Ваше имя пользователя LastFM"
    },
    "lastfm_api_key": {
        "pt": "API Key do LastFM",
        "en": "LastFM API Key",
        "es": "Clave API de LastFM",
        "fr": "Clé API LastFM",
        "ru": "API-ключ LastFM"
    },
    "lastfm_api_key_sub": {
        "pt": "Sua API Key do LastFM (crie em last.fm/api)",
        "en": "Your LastFM API Key (create at last.fm/api)",
        "es": "Tu clave API de LastFM (crea en last.fm/api)",
        "fr": "Votre clé API LastFM (créez sur last.fm/api)",
        "ru": "Ваш API-ключ LastFM (создайте на last.fm/api)"
    },
    "lastfm_youtube_api_key": {
        "pt": "YouTube API Key",
        "en": "YouTube API Key",
        "es": "Clave API de YouTube",
        "fr": "Clé API YouTube",
        "ru": "API-ключ YouTube"
    },
    "lastfm_youtube_api_key_sub": {
        "pt": "Opcional: para buscar vídeos no YouTube",
        "en": "Optional: to search videos on YouTube",
        "es": "Opcional: para buscar videos en YouTube",
        "fr": "Optionnel : pour rechercher des vidéos sur YouTube",
        "ru": "Необязательно: для поиска видео на YouTube"
    },
    "error_lastfm_credentials": {"pt": "Credenciais do LastFM inválidas.", "en": "Invalid LastFM credentials.", "es": "Credenciales del LastFM no válidas.", "fr": "Identifiants LastFM invalides.", "ru": "Неверные учетные данные LastFM."},
    "lastfm_credentials": {"pt": "Last.FM", "en": "Last.FM", "es": "Last.FM", "fr": "Last.FM", "ru": "Last.FM"},
    "lastfm_user_subtext": {"pt": "Seu nome de usuário do Last.FM", "en": "Your Last.FM username", "es": "Tu usuario de Last.FM", "fr": "Votre nom d'utilisateur Last.FM", "ru": "Ваше имя пользователя Last.FM"},
    "lastfm_api_key_subtext": {"pt": "Chave da API do Last.FM (crie em last.fm/api)", "en": "Last.FM API Key (create at last.fm/api)", "es": "Clave API de Last.FM (crea en last.fm/api)", "fr": "Clé API Last.FM (créez sur last.fm/api)", "ru": "API-ключ Last.FM (создайте на last.fm/api)"},
    "lastfm_key_visibility": {"pt": "Exibir LastFM API Key", "en": "Show LastFM API Key", "es": "Mostrar clave API de Last.FM", "fr": "Afficher la clé API LastFM", "ru": "Показать API-ключ LastFM"},
    "lastfm_key_visibility_sub": {"pt": "Oculta/exibe o campo da API Key para proteger dados sensíveis.", "en": "Hide/show the API Key field to protect sensitive data.", "es": "Oculta/muestra el campo de la clave API para proteger datos sensibles.", "fr": "Masquer/afficher le champ de clé API pour protéger les données sensibles.", "ru": "Скрывать/показывать поле API-ключа для защиты конфиденциальных данных."},
    "youtube_api_key_subtext": {"pt": "Chave da API do YouTube (opcional)", "en": "YouTube API Key (optional)", "es": "Clave API de YouTube (opcional)", "fr": "Clé API YouTube (optionnel)", "ru": "API-ключ YouTube (необязательно)"},
    "show_lastfm_profile_subtext": {"pt": "Exibe o link do seu perfil Last.FM na legenda", "en": "Show your Last.FM profile link in the caption", "es": "Muestra el enlace de tu perfil Last.FM en la leyenda", "fr": "Affiche le lien de votre profil Last.FM dans la légende", "ru": "Показывать ссылку на профиль Last.FM в подписи"},
    "spotify_link_subtext": {"pt": "Usa o link oficial do Spotify na legenda", "en": "Use the official Spotify link in the caption", "es": "Usa el enlace oficial de Spotify en la leyenda", "fr": "Utilise le lien officiel Spotify dans la légende", "ru": "Использовать официальную ссылку Spotify в подписи"},
    "youtube_api_title": {"pt": "Configuração da API do YouTube", "en": "YouTube API Setup", "es": "Configuración de la API de YouTube", "fr": "Configuration de l'API YouTube", "ru": "Настройка API YouTube"},
    "youtube_api_guide": {"pt": "A API do YouTube é um complemento opcional que melhora a obtenção de dados mais eficientes das capas das músicas e vídeos. Para configurar, obtenha sua chave API seguindo o guia oficial.", "en": "YouTube API is an optional complement that improves obtaining more efficient data from music and video covers. To set up, get your API key by following the official guide.", "es": "La API de YouTube es un complemento opcional que mejora la obtención de datos más eficientes de las portadas de música y videos. Para configurar, obtén tu clave API siguiendo la guía oficial.", "fr": "L'API YouTube est un complément optionnel qui améliore l'obtention de données plus efficaces des pochettes de musique et vidéos. Pour configurer, obtenez votre clé API en suivant le guide officiel.", "ru": "API YouTube - это дополнительное дополнение, которое улучшает получение более эффективных данных обложек музыки и видео. Для настройки получите ключ API, следуя официальному руководству."},
    "current_player": {"pt": "Fonte da Mídia", "en": "Media Source", "es": "Fuente de Medios", "fr": "Source Média", "ru": "Источник медиа"},
    "show_lastfm_profile_link": {"pt": "Meu Last.FM", "en": "Show Last.FM Profile", "es": "Perfil Last.FM", "fr": "Profil Last.FM", "ru": "Профиль Last.FM"},
    "fm_link_selector": {"pt": "FM Link", "en": "FM Link", "es": "Enlace FM", "fr": "Lien FM", "ru": "Ссылка FM"},
    "fm_custom_link_url": {"pt": "Custom Link (URL)", "en": "Custom Link (URL)", "es": "Enlace personalizado (URL)", "fr": "Lien personnalisé (URL)", "ru": "Пользовательская ссылка (URL)"},
    "fm_custom_link_url_sub": {"pt": "Cole aqui o link personalizado do Player FM em 'Player Ativo'", "en": "Paste here the custom link for the FM Player in 'Active Player'", "es": "Pega aquí el enlace personalizado del reproductor FM en 'Reproductor Activo'", "fr": "Collez ici le lien personnalisé pour le lecteur FM dans 'Lecteur Actif'", "ru": "Вставьте здесь пользовательскую ссылку для FM-плеера в 'Активный плеер'"},
    "youtube_api_key": {"pt": "Chave da API do YouTube", "en": "YouTube API Key", "es": "Clave de API de YouTube", "fr": "Clé API YouTube", "ru": "Ключ API YouTube"},
    "lastfm_title": {"pt": "API do Last.FM", "en": "Last.FM API", "es": "API de Last.FM", "fr": "API Last.FM", "ru": "API Last.FM"},
    "customfm_use_background": {"pt": "Capa de Fundo", "en": "Cover BG", "es": "Fondo Álbum", "fr": "Fond Album", "ru": "Фон Обложки"},
    "customfm_background_color": {"pt": "Cor do Fundo (hex)", "en": "Background Color (hex)", "es": "Color de Fondo (hex)", "fr": "Couleur de fond (hex)", "ru": "Цвет фона (hex)"},
    "customfm_text_color": {"pt": "Cor do Texto (hex)", "en": "Text Color (hex)", "es": "Color del Texto (hex)", "fr": "Couleur du texte (hex)", "ru": "Цвет текста (hex)"},
    "customfm_use_background_sub": {"pt": "Usa a capa do álbum como fundo do card.", "en": "Use the album cover as the card background.", "es": "Usa la portada del álbum como fondo.", "fr": "Utilise la pochette comme fond.", "ru": "Использовать обложку как фон карточки."},
    "customfm_background_color_sub": {"pt": "Cor de fundo personalizada para o tema CustomFM.", "en": "Custom background color for CustomFM theme.", "es": "Color de fondo personalizado para CustomFM.", "fr": "Couleur de fond personnalisée pour CustomFM.", "ru": "Пользовательский цвет фона для CustomFM."},
    "customfm_text_color_sub": {"pt": "Cor do texto personalizada para o tema CustomFM.", "en": "Custom text color for CustomFM theme.", "es": "Color de texto personalizado para CustomFM.", "fr": "Couleur de texte personnalisée pour CustomFM.", "ru": "Пользовательский цвет текста для CustomFM."},
    "customfm_radius": {"pt": "Radius da Capa", "en": "Cover Radius", "es": "Radio de Portada", "fr": "Rayon de Couverture", "ru": "Радиус Обложки"},
    "customfm_radius_standard": {"pt": "Padrão", "en": "Standard", "es": "Estándar", "fr": "Standard", "ru": "Стандарт"},
    "customfm_radius_small": {"pt": "Pequeno", "en": "Small", "es": "Pequeño", "fr": "Petit", "ru": "Маленький"},
    "customfm_radius_medium": {"pt": "Médio", "en": "Medium", "es": "Medio", "fr": "Moyen", "ru": "Средний"},
    "customfm_radius_large": {"pt": "Grande", "en": "Large", "es": "Grande", "fr": "Grand", "ru": "Большой"},
    "customfm_radius_circle": {"pt": "Círculo", "en": "Circle", "es": "Círculo", "fr": "Cercle", "ru": "Круг"},


    "apple_antialiasing_quality": {"pt": "Qualidade de Suavização", "en": "Smoothing Quality", "es": "Calidad de Suavizado", "fr": "Qualité de Lissage", "ru": "Качество Сглаживания"},
    "apple_antialiasing_standard": {"pt": "Básica", "en": "Basic", "es": "Básica", "fr": "Basique", "ru": "Базовое"},
    "apple_antialiasing_smooth": {"pt": "Suave", "en": "Smooth", "es": "Suave", "fr": "Doux", "ru": "Плавное"},
    "apple_antialiasing_ultra_smooth": {"pt": "Extra Suave", "en": "Extra Smooth", "es": "Extra Suave", "fr": "Extra Doux", "ru": "Сверхплавное"},
    "apple_antialiasing_high_quality": {"pt": "Refinada", "en": "Refined", "es": "Refinada", "fr": "Raffiné", "ru": "Утонченное"},
    "apple_resize_algorithm": {"pt": "Algoritmo de Redimensionamento", "en": "Resize Algorithm", "es": "Algoritmo de Redimensionamiento", "fr": "Algorithme de Redimensionnement", "ru": "Алгоритм Изменения Размера"},
    "apple_cover_quality": {"pt": "Qualidade da Mini Capa", "en": "Mini Cover Quality", "es": "Calidad de Mini Portada", "fr": "Qualité de Mini Couverture", "ru": "Качество Мини Обложки"},
    "apple_ui_warning": {"pt": "Opções Avançadas do Apple UI", "en": "Apple UI Advanced Options", "es": "Opciones Avanzadas de Apple UI", "fr": "Options Avancées d'Apple UI", "ru": "Расширенные Опции Apple UI"},

    "apple_quality_antialiasing_section": {"pt": "Qualidade e Anti-aliasing", "en": "Quality & Anti-aliasing", "es": "Calidad y Anti-aliasing", "fr": "Qualité et Anti-aliasing", "ru": "Качество и Сглаживание"},
    "apple_visual_optimizations_section": {"pt": "Otimizações Visuais", "en": "Visual Optimizations", "es": "Optimizaciones Visuales", "fr": "Optimisations Visuelles", "ru": "Визуальные Оптимизации"},
    "apple_performance_section": {"pt": "Performance", "en": "Performance", "es": "Rendimiento", "fr": "Performance", "ru": "Производительность"},
    "customfm_overlay_url": {"pt": "URL do Overlay", "en": "Overlay URL", "es": "URL de Overlay", "fr": "URL de Superposition", "ru": "URL Наложения"},
    "customfm_overlay_url_sub": {"pt": "Link da imagem overlay personalizada. Dimensões recomendadas: 400x400px", "en": "Custom overlay image link. Recommended dimensions: 400x400px", "es": "Enlace de imagen overlay personalizada. Dimensiones recomendadas: 400x400px", "fr": "Lien d'image de superposition personnalisée. Dimensions recommandées: 400x400px", "ru": "Ссылка на пользовательское изображение наложения. Рекомендуемые размеры: 400x400px"},
    "customfm_overlay_url_enhanced_sub": {"pt": "URL direto para a imagem PNG/JPG do overlay.", "en": "Direct URL to the PNG/JPG overlay image.", "es": "URL directo a la imagen PNG/JPG del overlay.", "fr": "URL directe vers l'image PNG/JPG de superposition.", "ru": "Прямая ссылка на изображение PNG/JPG для наложения."},
    "customfm_background_section": {"pt": "Configurações de Fundo", "en": "Background Settings", "es": "Configuraciones de Fondo", "fr": "Paramètres d'Arrière-plan", "ru": "Настройки Фона"},
    "customfm_text_section": {"pt": "Configurações de Texto", "en": "Text Settings", "es": "Configuraciones de Texto", "fr": "Paramètres de Texte", "ru": "Настройки Текста"},
    "customfm_style_section": {"pt": "Estilo e Aparência", "en": "Style & Appearance", "es": "Estilo y Apariencia", "fr": "Style et Apparence", "ru": "Стиль и Внешний Вид"},
    "customfm_overlay_section": {"pt": "Overlay Personalizado", "en": "Custom Overlay", "es": "Overlay Personalizado", "fr": "Superposition Personnalisée", "ru": "Пользовательское Наложение"},
    "customfm_use_overlay": {"pt": "Usar Overlay Personalizado", "en": "Use Custom Overlay", "es": "Usar Overlay Personalizado", "fr": "Utiliser Superposition Personnalisée", "ru": "Использовать Пользовательское Наложение"},
    "customfm_use_overlay_sub": {
        "pt": "Usa uma imagem de overlay como plano de fundo em vez da capa ou cor personalizada definida pelo usuário",
        "en": "Uses an overlay image as the background instead of the track cover or a user-defined custom color",
        "es": "Usa una imagen de overlay como fondo en lugar de la portada o un color personalizado definido por el usuario",
        "fr": "Utilise une image de superposition comme arrière-plan au lieu de la pochette ou d'une couleur personnalisée définie par l'utilisateur",
        "ru": "Использует изображение наложения в качестве фона вместо обложки или пользовательского цвета, заданного пользователем"
    },
    "customfm_blur": {"pt": "Blur", "en": "Blur", "es": "Blur", "fr": "Blur", "ru": "Размытие"},
    "customfm_blur_sub": {"pt": "Aplica desfoque ao fundo. Funciona tanto no overlay quanto no fundo da capa.", "en": "Applies blur to the background. Works for both overlay and cover backgrounds.", "es": "Aplica desenfoque al fondo. Funciona tanto en el overlay como en el fondo de la portada.", "fr": "Applique un flou à l'arrière-plan. Fonctionne sur la superposition et l'arrière-plan de la couverture.", "ru": "Применяет размытие к фону. Работает как на наложении, так и на фоне обложки."},
    "customfm_darken_background": {"pt": "Escurecer fundo", "en": "Darken background", "es": "Oscurecer fondo", "fr": "Assombrir l'arrière-plan", "ru": "Затемнить фон"},
    "customfm_darken_background_sub": {"pt": "Adiciona uma camada transparente escura. Funciona no overlay e no fundo da capa.", "en": "Adds a dark transparent layer. Works on both overlay and cover backgrounds.", "es": "Añade una capa transparente oscura. Funciona en el overlay y el fondo de la portada.", "fr": "Ajoute une couche transparente sombre. Fonctionne sur la superposition et l'arrière-plan de la couverture.", "ru": "Добавляет темный прозрачный слой. Работает на наложении и фоне обложки."},
    "customfm_bold_text": {"pt": "Realce de texto", "en": "Text Emphasis", "es": "Énfasis de texto", "fr": "Emphase du texte", "ru": "Выделение текста"},
    "customfm_bold_text_sub": {"pt": "Ativa o negrito no título da música e nome do artista", "en": "Enables bold formatting for song title and artist name.", "es": "Activa el formato en negrita para el título de la canción y nombre del artista", "fr": "Active le formatage en gras pour le titre de la chanson et nom de l'artiste", "ru": "Включает жирное форматирование для названия песни и имени исполнителя"},
    "customfm_cover_position": {"pt": "Posição da mini capa", "en": "Mini cover position", "es": "Posición de la mini portada", "fr": "Position de la mini couverture", "ru": "Позиция мини обложки"},
    "customfm_cover_position_sub": {"pt": "Escolha o lado em que a mini capa será exibida", "en": "Choose the side where the mini cover will be displayed", "es": "Elige el lado donde se mostrará la mini portada", "fr": "Choisissez le côté où la mini couverture sera affichée", "ru": "Выберите сторону, где будет отображаться мини обложка"},
    "customfm_position_left": {"pt": "Esquerda", "en": "Left", "es": "Izquierda", "fr": "Gauche", "ru": "Слева"},
    "customfm_position_right": {"pt": "Direita", "en": "Right", "es": "Derecha", "fr": "Droite", "ru": "Справа"},
    "customfm_icon_colors": {"pt": "Cores dos Ícones", "en": "Icon Colors", "es": "Colores de Iconos", "fr": "Couleurs des Icônes", "ru": "Цвета Иконок"},
    "customfm_custom_icon_url": {"pt": "Ícone Personalizado (URL)", "en": "Custom Icon (URL)", "es": "Icono Personalizado (URL)", "fr": "Icône Personnalisée (URL)", "ru": "Пользовательская Иконка (URL)"},
    "customfm_custom_icon_url_sub": {"pt": "Cole aqui o link do ícone personalizado para o player FM", "en": "Paste here the custom icon link for FM player", "es": "Pega aquí el enlace del icono personalizado para el reproductor FM", "fr": "Collez ici le lien de l'icône personnalisée pour le lecteur FM", "ru": "Вставьте здесь ссылку на пользовательскую иконку для FM плеера"},
    "customfm_custom_link_url": {"pt": "Link Personalizado (URL)", "en": "Custom Link (URL)", "es": "Enlace Personalizado (URL)", "fr": "Lien Personnalisé (URL)", "ru": "Пользовательская Ссылка (URL)"},
    "customfm_custom_link_url_sub": {"pt": "Cole aqui o link personalizado para o serviço FM (ex: link do Spotify, Apple Music, etc.)", "en": "Paste here the custom link for FM service (e.g. Spotify link, Apple Music, etc.)", "es": "Pega aquí el enlace personalizado para el servicio FM (ej. enlace de Spotify, Apple Music, etc.)", "fr": "Collez ici le lien personnalisé pour le service FM (ex. lien Spotify, Apple Music, etc.)", "ru": "Вставьте здесь пользовательскую ссылку для FM сервиса (например, ссылка Spotify, Apple Music и т.д.)"},
    "customfm_custom_player_name": {
        "pt": "Player",
        "en": "Player",
        "es": "Reproductor",
        "fr": "Lecteur",
        "ru": "Плеер"
    },
    "customfm_custom_player_name_sub": {"pt": "Digite um nome personalizado para o player FM (ex: 'Meu Player', 'Custom FM')", "en": "Enter a custom name for the FM player (e.g. 'My Player', 'Custom FM')", "es": "Ingresa un nombre personalizado para el reproductor FM (ej. 'Mi Reproductor', 'Custom FM')", "fr": "Entrez un nom personnalisé pour le lecteur FM (ex. 'Mon Lecteur', 'Custom FM')", "ru": "Введите пользовательское имя для FM плеера (например, 'Мой Плеер', 'Custom FM')"},
    "customfm_high_resolution": {"pt": "Alta Resolução", "en": "High Resolution", "es": "Alta Resolución", "fr": "Haute Résolution", "ru": "Высокое Разрешение"},
    "customfm_high_resolution_sub": {"pt": "Gera imagens em 1920x1080 para melhor qualidade. A geração pode demorar alguns segundos adicionais devido ao processamento de alta resolução", "en": "Generates images in 1920x1080 for better quality. Generation may take a few additional seconds due to high resolution processing", "es": "Genera imágenes en 1920x1080 para mejor calidad. La generación puede tardar algunos segundos adicionales debido al procesamiento de alta resolución", "fr": "Génère des images en 1920x1080 pour une meilleure qualité. La génération peut prendre quelques secondes supplémentaires en raison du traitement haute résolution", "ru": "Генерирует изображения в 1920x1080 для лучшего качества. Генерация может занять несколько дополнительных секунд из-за обработки высокого разрешения"},
    "dynamic_skins_section": {"pt": "Overlay Skins", "en": "Overlay Skins", "es": "Overlay Skins", "fr": "Overlay Skins", "ru": "Overlay Skins"},
    
    "vinify_ui_section": {"pt": "Vinify UI", "en": "Vinify UI", "es": "Vinify UI", "fr": "Vinify UI", "ru": "Vinify UI"},
    "vinify_background_section": {"pt": "Configurações de Fundo", "en": "Background Settings", "es": "Configuraciones de Fondo", "fr": "Paramètres d'Arrière-plan", "ru": "Настройки фона"},
    "vinify_custom_bg": {"pt": "Custom BG", "en": "Custom BG", "es": "Fondo Personalizado", "fr": "Arrière-plan Personnalisé", "ru": "Пользовательский фон"},
    "vinify_custom_bg_sub": {"pt": "Usa uma imagem personalizada como fundo. Se vazio, usa a capa.", "en": "Use a custom image as background. If empty, uses cover.", "es": "Usa una imagen personalizada como fondo. Si está vacío, usa la portada.", "fr": "Utilise une image personnalisée comme arrière-plan. Si vide, utilise la pochette.", "ru": "Использовать пользовательское изображение как фон. Если пусто, использовать обложку."},
    "vinify_custom_bg_url": {"pt": "Custom BG (URL)", "en": "Custom BG (URL)", "es": "Fondo Personalizado (URL)", "fr": "Arrière-plan Personnalisé (URL)", "ru": "Пользовательский фон (URL)"},
    "vinify_custom_bg_url_sub": {"pt": "Cole o link da imagem 1012x512 (PNG/JPG).", "en": "Paste the 1012x512 image link (PNG/JPG).", "es": "Pega el enlace de imagen 1012x512 (PNG/JPG).", "fr": "Collez le lien d'image 1012x512 (PNG/JPG).", "ru": "Вставьте ссылку на изображение 1012x512 (PNG/JPG)."},
    "vinify_bg_styles": {"pt": "BG Styles", "en": "BG Styles", "es": "Estilos de Fondo", "fr": "Styles d'Arrière-plan", "ru": "Стили фона"},
    "vinify_bg_styles_sub": {"pt": "Substitui o fundo pela imagem escolhida.", "en": "Replaces the background with the chosen image.", "es": "Reemplaza el fondo por la imagen elegida.", "fr": "Remplace l'arrière-plan par l'image choisie.", "ru": "Заменяет фон выбранным изображением."},
    "vinify_bg_style_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "vinify_bg_style_obsidian": {"pt": "Obsidian", "en": "Obsidian", "es": "Obsidian", "fr": "Obsidian", "ru": "Obsidian"},
    "vinify_bg_style_morph": {"pt": "Morph", "en": "Morph", "es": "Morph", "fr": "Morph", "ru": "Morph"},
    "vinify_bg_style_noir": {"pt": "Noir", "en": "Noir", "es": "Noir", "fr": "Noir", "ru": "Noir"},
    "vinify_bg_style_ethereal": {"pt": "Ethereal", "en": "Ethereal", "es": "Ethereal", "fr": "Ethereal", "ru": "Ethereal"},
    "vinify_bg_style_ethereal_mirage": {"pt": "Ethereal Mirage", "en": "Ethereal Mirage", "es": "Ethereal Mirage", "fr": "Ethereal Mirage", "ru": "Ethereal Mirage"},
    "vinify_bg_style_silken": {"pt": "Silken", "en": "Silken", "es": "Silken", "fr": "Silken", "ru": "Silken"},
    "vinify_bg_style_mock": {"pt": "Mock", "en": "Mock", "es": "Mock", "fr": "Mock", "ru": "Mock"},
    "vinify_bg_style_random": {"pt": "Aleatório", "en": "Random", "es": "Aleatorio", "fr": "Aléatoire", "ru": "Случайный"},
    "vinify_shadow": {"pt": "Shadow", "en": "Shadow", "es": "Sombra", "fr": "Ombre", "ru": "Тень"},
    "vinify_shadow_sub": {"pt": "Adiciona overlay transparente sobre o fundo.", "en": "Adds a transparent overlay over the background.", "es": "Añade un overlay transparente sobre el fondo.", "fr": "Ajoute une superposition transparente sur l'arrière-plan.", "ru": "Добавляет прозрачное наложение поверх фона."},
    "vinify_shadow_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "vinify_shadow_black": {"pt": "Black", "en": "Black", "es": "Negro", "fr": "Noir", "ru": "Чёрный"},
    "vinify_shadow_white": {"pt": "White", "en": "White", "es": "Blanco", "fr": "Blanc", "ru": "Белый"},
    "vinify_shadow_gradient": {"pt": "Gradient", "en": "Gradient", "es": "Gradiente", "fr": "Dégradé", "ru": "Градиент"},
    "vinibar_section": {"pt": "Configurações da ViniBar", "en": "ViniBar Settings", "es": "Configuración de ViniBar", "fr": "Paramètres de ViniBar", "ru": "Настройки ViniBar"},
    "vinibar_color": {"pt": "Cor da ViniBar", "en": "ViniBar Color", "es": "Color de ViniBar", "fr": "Couleur de ViniBar", "ru": "Цвет ViniBar"},
    "vinibar_color_sub": {"pt": "Cor principal da barra de progresso", "en": "Main color of the progress bar", "es": "Color principal de la barra de progreso", "fr": "Couleur principale de la barre de progression", "ru": "Основной цвет индикатора выполнения"},
    "vinibar_bg_color": {"pt": "Cor de fundo da ViniBar", "en": "ViniBar Background Color", "es": "Color de fondo de ViniBar", "fr": "Couleur de fond de ViniBar", "ru": "Цвет фона ViniBar"},
    "vinibar_bg_color_sub": {"pt": "Cor de fundo da barra de progresso", "en": "Background color of the progress bar", "es": "Color de fondo de la barra de progreso", "fr": "Couleur de fond de la barre de progression", "ru": "Цвет фона индикатора выполнения"},
    "vinibar_gradient": {"pt": "Gradiente da ViniBar", "en": "ViniBar Gradient", "es": "Gradiente de ViniBar", "fr": "Dégradé de ViniBar", "ru": "Градиент ViniBar"},
    "vinibar_gradient_sub": {"pt": "Combina a cor selecionada com uma cor baseada na capa do álbum", "en": "Combines the selected color with a color based on the album cover", "es": "Combina el color seleccionado con un color basado en la portada del álbum", "fr": "Combine la couleur sélectionnée avec une couleur basée sur la pochette de l'album", "ru": "Сочетает выбранный цвет с цветом на основе обложки альбома"},
    "vinibar_blur": {"pt": "Efeito Vidro na ViniBar", "en": "ViniBar Glass Effect", "es": "Efecto Cristal en ViniBar", "fr": "Effet Verre ViniBar", "ru": "Стеклянный эффект ViniBar"},
    "vinibar_blur_sub": {"pt": "Aplica um efeito de vidro translúcido na barra de fundo, permitindo ver a imagem através dela", "en": "Applies a translucent glass effect to the background bar, allowing the image to show through", "es": "Aplica un efecto de vidrio translúcido en la barra de fondo, permitiendo ver la imagen a través de ella", "fr": "Applique un effet de verre translucide à la barre d'arrière-plan, permettant de voir l'image à travers", "ru": "Применяет полупрозрачный стеклянный эффект к фоновой полосе, позволяя видеть изображение сквозь неё"},
    
    # Seções do Vinify UI
    "vinibar_settings_section": {"pt": "Configurações da ViniBar", "en": "ViniBar Settings", "es": "Configuraciones de ViniBar", "fr": "Paramètres ViniBar", "ru": "Настройки ViniBar"},
    "card_info_section": {"pt": "Informações do Card", "en": "Card Information", "es": "Información de la Tarjeta", "fr": "Informations de la Carte", "ru": "Информация карточки"},
    "advanced_settings_section": {"pt": "Configurações Avançadas", "en": "Advanced Settings", "es": "Configuraciones Avanzadas", "fr": "Paramètres Avancés", "ru": "Расширенные настройки"},
    
    # Novas opções do Vinify UI
    "album_playlist_mode": {"pt": "Modo Álbum/Playlist", "en": "Album/Playlist Mode", "es": "Modo Álbum/Playlist", "fr": "Mode Album/Playlist", "ru": "Режим альбом/плейлист"},
    "album_playlist_disabled": {"pt": "Desabilitado", "en": "Disabled", "es": "Deshabilitado", "fr": "Désactivé", "ru": "Отключено"},
    "album_playlist_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "album_playlist_album": {"pt": "Álbum", "en": "Album", "es": "Álbum", "fr": "Album", "ru": "Альбом"},
    "album_playlist_playlist": {"pt": "Playlist", "en": "Playlist", "es": "Playlist", "fr": "Playlist", "ru": "Плейлист"},
    "show_device": {"pt": "Mostrar Device", "en": "Show Device", "es": "Mostrar Dispositivo", "fr": "Afficher Appareil", "ru": "Показать устройство"},
    "show_device_sub": {"pt": "Exibe o nome do dispositivo acima da barra de progresso", "en": "Shows device name above the progress bar", "es": "Muestra el nombre del dispositivo encima de la barra de progreso", "fr": "Affiche le nom de l'appareil au-dessus de la barre de progression", "ru": "Показывает название устройства над индикатором выполнения"},
    
    # Novas opções para o seletor Device/Profile
    "device_profile_selector": {"pt": "Exibir Informações", "en": "Display Information", "es": "Mostrar Información", "fr": "Afficher les Informations", "ru": "Отображать информацию"},
    "my_profile": {"pt": "Meu Perfil", "en": "My Profile", "es": "Mi Perfil", "fr": "Mon Profil", "ru": "Мой профиль"},
    "custom_name": {"pt": "Nome Personalizado", "en": "Custom Name", "es": "Nombre Personalizado", "fr": "Nom Personnalisé", "ru": "Пользовательское имя"},
    "profile_and_device": {"pt": "Perfil & Device", "en": "Profile & Device", "es": "Perfil y Dispositivo", "fr": "Profil et Appareil", "ru": "Профиль и устройство"},
    "display_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    
    # Input para nome personalizado
    "custom_display_name": {"pt": "Nome Personalizado", "en": "Custom Display Name", "es": "Nombre de Visualización Personalizado", "fr": "Nom d'Affichage Personnalisé", "ru": "Пользовательское отображаемое имя"},
    "custom_display_name_sub": {"pt": "Digite o nome personalizado que será exibido acima da barra de progresso", "en": "Enter the custom name that will be displayed above the progress bar", "es": "Ingrese el nombre personalizado que se mostrará encima de la barra de progreso", "fr": "Entrez le nom personnalisé qui sera affiché au-dessus de la barre de progression", "ru": "Введите пользовательское имя, которое будет отображаться над индикатором выполнения"},
    
    # Switch para trocar lado da capa e textos
    "vinify_swap_layout": {"pt": "Trocar Layout", "en": "Swap Layout", "es": "Intercambiar Diseño", "fr": "Échanger la Mise en Page", "ru": "Поменять макет"},
    "vinify_swap_layout_sub": {"pt": "Troca o lado da capa e dos textos", "en": "Swaps the side of the cover and texts", "es": "Intercambia el lado de la portada y los textos", "fr": "Échange le côté de la couverture et des textes", "ru": "Меняет местами обложку и текст"},
    
    # Logo Position
    "logo_position": {"pt": "Logo Position", "en": "Logo Position", "es": "Posición del Logo", "fr": "Position du Logo", "ru": "Позиция логотипа"},
    "logo_position_superior": {"pt": "Superior", "en": "Top", "es": "Superior", "fr": "Supérieur", "ru": "Верх"},
    "logo_position_inferior": {"pt": "Inferior", "en": "Bottom", "es": "Inferior", "fr": "Inférieur", "ru": "Низ"},
    
    # Seletor de efeitos de fundo
    "vinify_background_effect": {"pt": "Efeito de Fundo", "en": "Background Effect", "es": "Efecto de Fondo", "fr": "Effet d'Arrière-plan", "ru": "Эффект фона"},
    "vinify_background_effect_sub": {"pt": "Escolha o efeito aplicado ao fundo da imagem", "en": "Choose the effect applied to the image background", "es": "Elige el efecto aplicado al fondo de la imagen", "fr": "Choisissez l'effet appliqué à l'arrière-plan de l'image", "ru": "Выберите эффект, применяемый к фону изображения"},
    
    # Opções do seletor de efeito de fundo
    "background_effect_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "background_effect_album_colors": {"pt": "Cores do Álbum", "en": "Album Colors", "es": "Colores del Álbum", "fr": "Couleurs de l'Album", "ru": "Цвета альбома"},
    "background_effect_blur": {"pt": "Blur", "en": "Blur", "es": "Desenfoque", "fr": "Flou", "ru": "Размытие"},

    # Versão / Atualizações
    "version_status_section": {"pt": "Status da Versão", "en": "Version Status", "es": "Estado de Versión", "fr": "Statut de Version", "ru": "Статус версии"},
    "installed_version_label": {"pt": "Versão instalada", "en": "Installed version", "es": "Versión instalada", "fr": "Version installée", "ru": "Установленная версия"},
    "latest_version_label": {"pt": "Última versão", "en": "Latest version", "es": "Última versión", "fr": "Dernière version", "ru": "Последняя версия"},
    "version_status_up_to_date": {"pt": "Atualizado", "en": "Up to date", "es": "Actualizado", "fr": "À jour", "ru": "Актуально"},
    "version_status_outdated": {"pt": "Atualização disponível", "en": "Update available", "es": "Actualización disponible", "fr": "Mise à jour disponible", "ru": "Доступно обновление"},
    "version_status_unknown": {"pt": "Desconhecido", "en": "Unknown", "es": "Desconocido", "fr": "Inconnu", "ru": "Неизвестно"},
    "update_available_text": {"pt": "Nova versão {version} disponível", "en": "New version {version} available", "es": "Nueva versión {version} disponible", "fr": "Nouvelle version {version} disponible", "ru": "Доступна новая версия {version}"},
    "open_update_page": {"pt": "Abrir página de atualização", "en": "Open update page", "es": "Abrir página de actualización", "fr": "Ouvrir la page de mise à jour", "ru": "Открыть страницу обновления"},
    "check_version_now": {"pt": "Verificar versão agora", "en": "Check version now", "es": "Verificar versión ahora", "fr": "Vérifier la version maintenant", "ru": "Проверить версию сейчас"},
    "version_check_failed": {"pt": "Falha ao verificar versão", "en": "Version check failed", "es": "Fallo al verificar versión", "fr": "Échec de la vérification de version", "ru": "Сбой проверки версии"},
    "background_effect_darker": {"pt": "Escuro", "en": "Darker", "es": "Más Oscuro", "fr": "Plus Sombre", "ru": "Темнее"},
    "background_effect_both": {"pt": "Blur + Escuro", "en": "Blur + Dark", "es": "Desenfoque + Oscuro", "fr": "Flou + Sombre", "ru": "Размытие + Темный"},
    
    # Platform Logo Selector
    "vinify_platform_logo": {"pt": "Platform Logo", "en": "Platform Logo", "es": "Platform Logo", "fr": "Platform Logo", "ru": "Platform Logo"},
    "platform_logo_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
            "platform_logo_spotify_green_white": {"pt": "Green & White", "en": "Green & White", "es": "Green & White", "fr": "Green & White", "ru": "Green & White"},
    "platform_logo_spotify_white_green": {"pt": "White & Green", "en": "White & Green", "es": "White & Green", "fr": "White & Green", "ru": "White & Green"},
    "platform_logo_spotify_black_white": {"pt": "Black & White", "en": "Black & White", "es": "Black & White", "fr": "Black & White", "ru": "Black & White"},
    "platform_logo_spotify_white_black": {"pt": "White & Black", "en": "White & Black", "es": "White & Black", "fr": "White & Black", "ru": "White & Black"},
    "platform_logo_apple_red_white": {"pt": "Red & White", "en": "Red & White", "es": "Red & White", "fr": "Red & White", "ru": "Red & White"},
    "platform_logo_apple_white_red": {"pt": "White & Red", "en": "White & Red", "es": "White & Red", "fr": "White & Red", "ru": "White & Red"},
    "platform_logo_apple_black_white": {"pt": "Black & White", "en": "Black & White", "es": "Black & White", "fr": "Black & White", "ru": "Black & White"},
    "platform_logo_apple_white_black": {"pt": "White & Black", "en": "White & Black", "es": "White & Black", "fr": "White & Black", "ru": "White & Black"},
    
    # Inversão de imagem de fundo
    "vinify_flip_background": {"pt": "Inverter Imagem de Fundo", "en": "Flip Background Image", "es": "Voltear Imagen de Fondo", "fr": "Retourner l'Image de Fond", "ru": "Отразить фоновое изображение"},
    "vinify_flip_background_sub": {"pt": "Inverte horizontalmente a imagem de fundo da capa", "en": "Horizontally flips the cover background image", "es": "Voltea horizontalmente la imagen de fondo de la portada", "fr": "Retourne horizontalement l'image de fond de la couverture", "ru": "Горизонтально отражает фоновое изображение обложки"},
    
    # Platform Links
    "platform_links": {"pt": "Platform Links", "en": "Platform Links", "es": "Platform Links", "fr": "Platform Links", "ru": "Platform Links"},
    "platform_links_sub": {"pt": "Escolha quais links de plataforma incluir", "en": "Choose which platform links to include", "es": "Elige qué enlaces de plataforma incluir", "fr": "Choisissez quels liens de plateforme inclure", "ru": "Выберите, какие ссылки платформы включить"},
    "platform_links_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "platform_links_universal": {"pt": "Universal", "en": "Universal", "es": "Universal", "fr": "Universal", "ru": "Universal"},
    "platform_links_both": {"pt": "Both", "en": "Both", "es": "Ambos", "fr": "Les deux", "ru": "Оба"},
    
    # FM Links section
    "fm_links_section": {"pt": "FM Links", "en": "FM Links", "es": "FM Links", "fr": "FM Links", "ru": "FM Links"},
    "fm_links_spotify_profile": {"pt": "Perfil Spotify", "en": "Spotify Profile", "es": "Perfil de Spotify", "fr": "Profil Spotify", "ru": "Профиль Spotify"},
    "fm_links_spotify_profile_sub": {"pt": "Inclui link para o perfil do usuário no Spotify", "en": "Include link to user's Spotify profile", "es": "Incluye enlace al perfil del usuario en Spotify", "fr": "Inclut un lien vers le profil utilisateur Spotify", "ru": "Включает ссылку на профиль пользователя в Spotify"},
    
    # Dialog explicativo
    "universal_link_dialog_title": {"pt": "O que é Universal Link?", "en": "What is Universal Link?", "es": "¿Qué es Universal Link?", "fr": "Qu'est-ce qu'un lien universel?", "ru": "Что такое универсальная ссылка?"},
    "universal_link_dialog_content": {"pt": "O Universal Link (song.link) é um serviço que cria links universais para músicas, permitindo que os usuários abram a música em sua plataforma de streaming preferida (Spotify, Apple Music, YouTube Music, etc.), independentemente da plataforma original.", "en": "Universal Link (song.link) is a service that creates universal links for songs, allowing users to open the song in their preferred streaming platform (Spotify, Apple Music, YouTube Music, etc.), regardless of the original platform.", "es": "Universal Link (song.link) es un servicio que crea enlaces universales para canciones, permitiendo a los usuarios abrir la canción en su plataforma de streaming preferida (Spotify, Apple Music, YouTube Music, etc.), independientemente de la plataforma original.", "fr": "Universal Link (song.link) est un service qui crée des liens universels pour les chansons, permettant aux utilisateurs d'ouvrir la chanson dans leur plateforme de streaming préférée (Spotify, Apple Music, YouTube Music, etc.), quelle que soit la plateforme d'origine.", "ru": "Universal Link (song.link) - это сервис, который создает универсальные ссылки на песни, позволяя пользователям открывать песню на их предпочитаемой стриминговой платформе (Spotify, Apple Music, YouTube Music и т.д.), независимо от исходной платформы."},
    
    # Dialog do Yandex Music
    "yandex_music_dialog_title": {"pt": "Yandex Music Selecionado", "en": "Yandex Music Selected", "es": "Yandex Music Seleccionado", "fr": "Yandex Music Sélectionné", "ru": "Yandex Music Выбран"},
    "yandex_music_dialog_content": {"pt": "Como não existe API oficial do Yandex Music, recomendamos usar o Last.FM para scrobble e track de suas músicas.\n\nE sim, essa mensagem sempre será exibida toda vez se por algum motivo você ficar trocando de player e voltando para o Yandex Music.", "en": "Since there is no official Yandex Music API, we recommend using Last.FM to scrobble and track your music.\n\nAnd yes, this message will always be displayed every time if for some reason you keep switching players and returning to Yandex Music.", "es": "Como no existe una API oficial de Yandex Music, recomendamos usar Last.FM para hacer scrobble y rastrear tu música.\n\nY sí, este mensaje siempre se mostrará cada vez si por alguna razón sigues cambiando de reproductor y volviendo a Yandex Music.", "fr": "Comme il n'existe pas d'API officielle Yandex Music, nous recommandons d'utiliser Last.FM pour scrobbler et suivre votre musique.\n\nEt oui, ce message sera toujours affiché à chaque fois si pour une raison quelconque vous continuez à changer de lecteur et à revenir à Yandex Music.", "ru": "Поскольку официального API Yandex Music не существует, мы рекомендуем использовать Last.FM для скробблинга и отслеживания вашей музыки.\n\nИ да, это сообщение всегда будет отображаться каждый раз, если по какой-то причине вы продолжаете переключать плееры и возвращаться к Yandex Music."},
    
    # Traduções do tema Nowv
    "nowv_theme_style": {"pt": "Estilo do Tema", "en": "Theme Style", "es": "Estilo del Tema", "fr": "Style du Thème", "ru": "Стиль темы"},
    "nowv_visual_appearance": {"pt": "Aparência Visual", "en": "Visual Appearance", "es": "Apariencia Visual", "fr": "Apparence Visuelle", "ru": "Внешний вид"},
    "nowv_progress_bar": {"pt": "Barra de Progresso", "en": "Progress Bar", "es": "Barra de Progreso", "fr": "Barre de Progression", "ru": "Полоса прогресса"},
    
    # Seletor de dispositivo para Stats.fm
    "statsfm_device_selector": {"pt": "Ícone do Dispositivo (Stats.fm)", "en": "Device Icon (Stats.fm)", "es": "Ícono del Dispositivo (Stats.fm)", "fr": "Icône de l'Appareil (Stats.fm)", "ru": "Значок устройства (Stats.fm)"},
    "device_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "device_smartphone": {"pt": "Smartphone", "en": "Smartphone", "es": "Smartphone", "fr": "Smartphone", "ru": "Смартфон"},
    "device_computer": {"pt": "PC", "en": "PC", "es": "PC", "fr": "PC", "ru": "PC"},
    "device_speaker": {"pt": "Alto-falante", "en": "Speaker", "es": "Altavoz", "fr": "Haut-parleur", "ru": "Динамик"},
    "device_tv": {"pt": "TV", "en": "TV", "es": "TV", "fr": "TV", "ru": "ТВ"},
    "device_web": {"pt": "Navegador Web", "en": "Web Browser", "es": "Navegador Web", "fr": "Navigateur Web", "ru": "Веб-браузер"},
    "device_name": {"pt": "Nome do Dispositivo", "en": "Device Name", "es": "Nombre del Dispositivo", "fr": "Nom de l'Appareil", "ru": "Имя устройства"},
    "device_name_sub": {"pt": "Nome personalizado que aparecerá no card em vez do nome detectado automaticamente", "en": "Custom name that will appear on the card instead of the automatically detected name", "es": "Nombre personalizado que aparecerá en la tarjeta en lugar del nombre detectado automáticamente", "fr": "Nom personnalisé qui apparaîtra sur la carte au lieu du nom détecté automatiquement", "ru": "Пользовательское имя, которое будет отображаться на карточке вместо автоматически определенного имени"},
    
    # Traduções de cores
    "color_default": {"pt": "Padrão", "en": "Default", "es": "Predeterminado", "fr": "Par défaut", "de": "Standard", "it": "Predefinito", "ru": "По умолчанию", "zh": "默认", "ja": "デフォルト", "ko": "기본값"},
    "color_white": {"pt": "Branco", "en": "White", "es": "Blanco", "fr": "Blanc", "de": "Weiß", "it": "Bianco", "ru": "Белый", "zh": "白色", "ja": "白", "ko": "흰색"},
    "color_red": {"pt": "Vermelho", "en": "Red", "es": "Rojo", "fr": "Rouge", "de": "Rot", "it": "Rosso", "ru": "Красный", "zh": "红色", "ja": "赤", "ko": "빨간색"},
    "color_orange": {"pt": "Laranja", "en": "Orange", "es": "Naranja", "fr": "Orange", "de": "Orange", "it": "Arancione", "ru": "Оранжевый", "zh": "橙色", "ja": "オレンジ", "ko": "주황색"},
    "color_yellow": {"pt": "Amarelo", "en": "Yellow", "es": "Amarillo", "fr": "Jaune", "de": "Gelb", "it": "Giallo", "ru": "Желтый", "zh": "黄色", "ja": "黄色", "ko": "노란색"},
    "color_green": {"pt": "Verde", "en": "Green", "es": "Verde", "fr": "Vert", "de": "Grün", "it": "Verde", "ru": "Зеленый", "zh": "绿色", "ja": "緑", "ko": "초록색"},
    "color_blue": {"pt": "Azul", "en": "Blue", "es": "Azul", "fr": "Bleu", "de": "Blau", "it": "Blu", "ru": "Синий", "zh": "蓝色", "ja": "青", "ko": "파란색"},
    "color_indigo": {"pt": "Índigo", "en": "Indigo", "es": "Índigo", "fr": "Indigo", "de": "Indigo", "it": "Indaco", "ru": "Индиго", "zh": "靛蓝", "ja": "インディゴ", "ko": "남색"},
    "color_violet": {"pt": "Violeta", "en": "Violet", "es": "Violeta", "fr": "Violet", "de": "Violett", "it": "Viola", "ru": "Фиолетовый", "zh": "紫色", "ja": "紫", "ko": "보라색"},
    "dynamic_skins_selector": {"pt": "Overlay Skins", "en": "Overlay Skins", "es": "Overlay Skins", "fr": "Overlay Skins", "ru": "Overlay Skins"},
    "dynamic_skins_sub": {"pt": "Selecione um pré-overlay com temas prontos para o CustomFM", "en": "Select a pre-overlay with ready themes for CustomFM", "es": "Selecciona un pre-overlay con temas listos para CustomFM", "fr": "Sélectionnez un pré-overlay avec des thèmes prêts pour CustomFM", "ru": "Выберите пре-оверлей с готовыми темами для CustomFM"},
    "dynamic_skins_none": {"pt": "Nenhum", "en": "None", "es": "Ninguno", "fr": "Aucun", "ru": "Нет"},
    "dynamic_skins_random": {"pt": "Aleatório", "en": "Random", "es": "Aleatorio", "fr": "Aléatoire", "ru": "Случайный"},
    "dynamic_skins_spcy": {"pt": "Spcy", "en": "Spcy", "es": "Spcy", "fr": "Spcy", "ru": "Spcy"},
    "dynamic_skins_purpl": {"pt": "Purpl", "en": "Purpl", "es": "Purpl", "fr": "Purpl", "ru": "Purpl"},
    "dynamic_skins_ardente": {"pt": "Ardente", "en": "Ardente", "es": "Ardente", "fr": "Ardente", "ru": "Ardente"},
    "dynamic_skins_manifest": {"pt": "Manifest", "en": "Manifest", "es": "Manifest", "fr": "Manifest", "ru": "Manifest"},
    "dynamic_skins_moment": {"pt": "Moment", "en": "Moment", "es": "Moment", "fr": "Moment", "ru": "Moment"},
    "dynamic_skins_moment_redd": {"pt": "Moment Redd", "en": "Moment Redd", "es": "Moment Redd", "fr": "Moment Redd", "ru": "Moment Redd"},
    "dynamic_skins_moment_variant": {"pt": "Moment Variant", "en": "Moment Variant", "es": "Moment Variant", "fr": "Moment Variant", "ru": "Moment Variant"},
    # Visual Avançado - Traduções
    "visual_avancado_section": {"pt": "Visual Avançado", "en": "Advanced Visual", "es": "Visual Avanzado", "fr": "Visuel Avancé", "ru": "Продвинутый визуал"},
    "gradientes_dinamicos_section": {"pt": "Gradientes Dinâmicos", "en": "Dynamic Gradients", "es": "Gradientes Dinámicos", "fr": "Dégradés Dynamiques", "ru": "Динамические градиенты"},
    "gradiente_enable": {"pt": "Ativar Gradientes", "en": "Enable Gradients", "es": "Activar Gradientes", "fr": "Activer les Dégradés", "ru": "Включить градиенты"},
    "gradiente_enable_sub": {"pt": "Aplica gradientes dinâmicos baseados nas cores da capa do álbum", "en": "Applies dynamic gradients based on album cover colors", "es": "Aplica gradientes dinámicos basados en los colores de la portada del álbum", "fr": "Applique des dégradés dynamiques basés sur les couleurs de la pochette", "ru": "Применяет динамические градиенты на основе цветов обложки альбома"},
    "gradiente_style": {"pt": "Estilo do Gradiente", "en": "Gradient Style", "es": "Estilo del Gradiente", "fr": "Style de Dégradé", "ru": "Стиль градиента"},
    "gradiente_linear": {"pt": "Linear", "en": "Linear", "es": "Lineal", "fr": "Linéaire", "ru": "Линейный"},
    "gradiente_radial": {"pt": "Radial", "en": "Radial", "es": "Radial", "fr": "Radial", "ru": "Радиальный"},
    "gradiente_diagonal": {"pt": "Diagonal", "en": "Diagonal", "es": "Diagonal", "fr": "Diagonal", "ru": "Диагональный"},
    "gradiente_direction": {"pt": "Direção do Gradiente", "en": "Gradient Direction", "es": "Dirección del Gradiente", "fr": "Direction du Dégradé", "ru": "Направление градиента"},
    "gradiente_top_bottom": {"pt": "Cima para Baixo", "en": "Top to Bottom", "es": "Arriba a Abajo", "fr": "Haut vers Bas", "ru": "Сверху вниз"},
    "gradiente_left_right": {"pt": "Esquerda para Direita", "en": "Left to Right", "es": "Izquierda a Derecha", "fr": "Gauche vers Droite", "ru": "Слева направо"},
    "gradiente_diagonal_tl_br": {"pt": "Diagonal (↘)", "en": "Diagonal (↘)", "es": "Diagonal (↘)", "fr": "Diagonal (↘)", "ru": "Диагональ (↘)"},
    "gradiente_diagonal_tr_bl": {"pt": "Diagonal (↙)", "en": "Diagonal (↙)", "es": "Diagonal (↙)", "fr": "Diagonal (↙)", "ru": "Диагональ (↙)"},
    "gradiente_intensity": {"pt": "Intensidade do Gradiente", "en": "Gradient Intensity", "es": "Intensidad del Gradiente", "fr": "Intensité du Dégradé", "ru": "Интенсивность градиента"},
    "gradiente_suave": {"pt": "Suave", "en": "Soft", "es": "Suave", "fr": "Doux", "ru": "Мягкий"},
    "gradiente_medio": {"pt": "Médio", "en": "Medium", "es": "Medio", "fr": "Moyen", "ru": "Средний"},
    "gradiente_intenso": {"pt": "Intenso", "en": "Intense", "es": "Intenso", "fr": "Intense", "ru": "Интенсивный"},
    "gradiente_color_extraction": {"pt": "Extração de Cores", "en": "Color Extraction", "es": "Extracción de Colores", "fr": "Extraction de Couleurs", "ru": "Извлечение цветов"},
    "gradiente_dominante": {"pt": "Cor Dominante", "en": "Dominant Color", "es": "Color Dominante", "fr": "Couleur Dominante", "ru": "Доминирующий цвет"},
    "gradiente_complementar": {"pt": "Cores Complementares", "en": "Complementary Colors", "es": "Colores Complementarios", "fr": "Couleurs Complémentaires", "ru": "Дополнительные цвета"},
    "gradiente_analogas": {"pt": "Cores Análogas", "en": "Analogous Colors", "es": "Colores Análogos", "fr": "Couleurs Analogues", "ru": "Аналогичные цвета"},
    "cores_personalizadas_section": {"pt": "Cores Personalizadas", "en": "Custom Colors", "es": "Colores Personalizados", "fr": "Couleurs Personnalisées", "ru": "Пользовательские цвета"},
    "gradiente_cor1": {"pt": "Cor Primária", "en": "Primary Color", "es": "Color Primario", "fr": "Couleur Primaire", "ru": "Основной цвет"},
    "gradiente_cor2": {"pt": "Cor Secundária", "en": "Secondary Color", "es": "Color Secundario", "fr": "Couleur Secondaire", "ru": "Вторичный цвет"},
    "gradiente_modo": {"pt": "Modo do Gradiente", "en": "Gradient Mode", "es": "Modo del Gradiente", "fr": "Mode Dégradé", "ru": "Режим градиента"},
    "gradiente_modo_auto": {"pt": "Automático", "en": "Automatic", "es": "Automático", "fr": "Automatique", "ru": "Автоматический"},
    "gradiente_modo_custom": {"pt": "Personalizado", "en": "Custom", "es": "Personalizado", "fr": "Personnalisé", "ru": "Пользовательский"},
    "read_docs_theme": { 
        "en": "Use these default values unless you want to customize:\n- Background: #d2d2d2\n- Text: #000000\n\n• coolors.co/generate",
        "pt": "Use estes valores padrão a menos que queira personalizar:\n- Fundo: #d2d2d2\n- Texto: #000000\n\n• coolors.co/generate",
        "es": "Usa estos valores predeterminados, a menos que desees personalizar:\n- Fondo: #d2d2d2\n- Texto: #000000\n\n• coolors.co/generate",
        "ru": "Используйте эти значения по умолчанию, если не хотите настраивать:\n- Фон: #d2d2d2\n- Текст: #000000\n\n• coolors.co/generate",
        "fr": "Utilisez ces valeurs par défaut sauf si vous souhaitez personnaliser:\n- Fond : #d2d2d2\n- Texte : #000000\n\n• coolors.co/generate"
    },
    "read_docs_warning": {
        "pt": "É importante que leia toda a documentação, guia, FAQ para não restar dúvidas.\n\nSe precisar, releia, está tudo muito bem explicado.\nO uso do Last.FM no nowFy é simples e para tudo funcionar corretamente, basta seguir as instruções.\n\nTambém criamos uma FAQ no canal: @nowfyDOCS\n\nSe tiver realmente dúvidas, algo que não esteja nas docs, guias, aí sim, pode entrar em contato, vamos tentar ajudar.",
        "en": "It's important to read all the documentation, guides, and FAQ to clear any doubts.\n\nIf needed, read them again; everything is well explained.\nUsing Last.FM on nowFy is simple and to make it work correctly, just follow the instructions.\n\nWe also created a FAQ channel: @nowfyDOCS\n\nIf you still have real doubts not covered in the docs or guides, then feel free to contact us; we'll try to help.",
        "es": "Es importante leer toda la documentación, guías y FAQ para no tener dudas.\n\nSi es necesario, léelas de nuevo; todo está bien explicado.\nUsar Last.FM en nowFy es sencillo y para que funcione correctamente, solo sigue las instrucciones.\n\nTambién creamos un canal FAQ: @nowfyDOCS\n\nSi realmente tienes dudas que no estén en las docs o guías, entonces contáctanos; intentaremos ayudarte.",
        "fr": "Il est important de lire toute la documentation, les guides et la FAQ pour ne pas avoir de doutes.\n\nSi besoin, relisez-les ; tout est bien expliqué.\nL'utilisation de Last.FM sur nowFy est simple, il suffit de suivre les instructions pour que cela fonctionne correctement.\n\nNous avons aussi créé un canal FAQ : @nowfyDOCS\n\nSi vous avez encore de réels doutes qui ne sont pas couverts par les docs ou guides, alors contactez-nous ; nous essaierons de vous aider.",
        "ru": "Важно прочитать всю документацию, руководства и FAQ, чтобы не оставалось вопросов.\n\nЕсли нужно, перечитайте их снова; всё хорошо объяснено.\nИспользование Last.FM в nowFy простое, чтобы всё работало правильно, просто следуйте инструкциям.\nМы также создали канал FAQ: @nowfyDOCS\n\nЕсли у вас всё ещё есть вопросы, не описанные в документации или руководствах, свяжитесь с нами; мы постараемся помочь."
    },
    "nowcast_info_warning_title": {
        "pt": "Sobre o NowCast",
        "en": "About NowCast",
        "es": "Sobre NowCast",
        "fr": "À propos de NowCast",
        "ru": "О NowCast"
    },
    "nowcast_info_warning": {
        "pt": "INFORMAÇÕES IMPORTANTES SOBRE O NOWCAST\n\nNowCast é exclusivo para Spotify com API configurada. Não funciona com Last.fm ou Stats.fm.\n\nRATE LIMITING DO BOT:\n• Os bots do Telegram têm limites de requisições por segundo\n• Limite padrão: 30 mensagens por segundo\n• Para grupos: 20 mensagens por minuto\n• Estes limites são impostos pelo Telegram, não controlamos\n\nCOMO OBTER O TOKEN DO BOT:\n1. Acesse @BotFather no Telegram\n2. Digite /newbot e siga as instruções\n3. Escolha um nome e username para seu bot\n4. Copie o token fornecido\n5. Cole o token no campo 'Bot Token' acima\n\nIMPORTANTE: Mantenha seu token seguro e não compartilhe com terceiros.",
        "en": "IMPORTANT INFORMATION ABOUT NOWCAST\n\nNowCast is exclusive for Spotify with configured API. It doesn't work with Last.fm or Stats.fm.\n\nBOT RATE LIMITING:\n• Telegram bots have request limits per second\n• Default limit: 30 messages per second\n• For groups: 20 messages per minute\n• These limits are imposed by Telegram, we don't control them\n\nHOW TO GET BOT TOKEN:\n1. Go to @BotFather on Telegram\n2. Type /newbot and follow instructions\n3. Choose a name and username for your bot\n4. Copy the provided token\n5. Paste the token in the 'Bot Token' field above\n\nIMPORTANT: Keep your token secure and don't share with third parties.",
        "es": "INFORMACIÓN IMPORTANTE SOBRE NOWCAST\n\nNowCast es exclusivo para Spotify con API configurada. No funciona con Last.fm o Stats.fm.\n\nLIMITACIÓN DE VELOCIDAD DEL BOT:\n• Los bots de Telegram tienen límites de solicitudes por segundo\n• Límite predeterminado: 30 mensajes por segundo\n• Para grupos: 20 mensajes por minuto\n• Estos límites son impuestos por Telegram, no los controlamos\n\nCÓMO OBTENER EL TOKEN DEL BOT:\n1. Ve a @BotFather en Telegram\n2. Escribe /newbot y sigue las instrucciones\n3. Elige un nombre y nombre de usuario para tu bot\n4. Copia el token proporcionado\n5. Pega el token en el campo 'Bot Token' arriba\n\nIMPORTANTE: Mantén tu token seguro y no lo compartas con terceros.",
        "fr": "INFORMATIONS IMPORTANTES SUR NOWCAST\n\nNowCast est exclusif pour Spotify avec API configurée. Il ne fonctionne pas avec Last.fm ou Stats.fm.\n\nLIMITATION DE DÉBIT DU BOT:\n• Les bots Telegram ont des limites de requêtes par seconde\n• Limite par défaut: 30 messages par seconde\n• Pour les groupes: 20 messages par minute\n• Ces limites sont imposées par Telegram, nous ne les contrôlons pas\n\nCOMMENT OBTENIR LE TOKEN DU BOT:\n1. Allez sur @BotFather sur Telegram\n2. Tapez /newbot et suivez les instructions\n3. Choisissez un nom et nom d'utilisateur pour votre bot\n4. Copiez le token fourni\n5. Collez le token dans le champ 'Bot Token' ci-dessus\n\nIMPORTANT: Gardez votre token sécurisé et ne le partagez pas avec des tiers.",
        "ru": "ВАЖНАЯ ИНФОРМАЦИЯ О NOWCAST\n\nNowCast работает только со Spotify с настроенным API. Не работает с Last.fm или Stats.fm.\n\nОГРАНИЧЕНИЯ СКОРОСТИ БОТА:\n• У ботов Telegram есть лимиты запросов в секунду\n• Стандартный лимит: 30 сообщений в секунду\n• Для групп: 20 сообщений в минуту\n• Эти лимиты устанавливает Telegram, мы их не контролируем\n\nКАК ПОЛУЧИТЬ ТОКЕН БОТА:\n1. Перейдите к @BotFather в Telegram\n2. Введите /newbot и следуйте инструкциям\n3. Выберите имя и имя пользователя для вашего бота\n4. Скопируйте предоставленный токен\n5. Вставьте токен в поле 'Bot Token' выше\n\nВАЖНО: Держите ваш токен в безопасности и не делитесь им с третьими лицами."
    },
    "artwork_priority": {
        "pt": "Prioridade de Capa",
        "en": "Artwork Priority",
        "es": "Prioridad de Portada",
        "ru": "Приоритет обложки",
        "fr": "Priorité de la pochette"
    },
    "get_api_key": {
        "en": "Get your API key",
        "pt": "Obtenha sua chave de API",
        "es": "Obtén tu clave de API",
        "ru": "Получите ваш ключ API",
        "fr": "Obtenez votre clé API"
    },
    "youtube_api_guide": {
        "en": "You need a YouTube API key to use this feature. Tap the button below to open a step-by-step guide on how to generate your key.",
        "pt": "Você precisa de uma chave de API do YouTube para usar este recurso. Toque no botão abaixo para abrir um guia passo a passo sobre como gerar sua chave.",
        "es": "Necesitas una clave de API de YouTube para usar esta función. Pulsa el botón de abajo para abrir una guía paso a paso sobre cómo generar tu clave.",
        "ru": "Для использования этой функции необходим ключ API YouTube. Нажмите кнопку ниже, чтобы открыть пошаговое руководство по созданию ключа.",
        "fr": "Vous avez besoin d'une clé API YouTube pour utiliser cette fonctionnalité. Appuyez sur le bouton ci-dessous pour ouvrir un guide étape par étape sur la génération de votre clé."
    },
    "lastfm_content": {
        "en": "You can use Last.fm to scrobble from services like YouTube, YouTube Music, SoundCloud, exteraGram, and AyuGram (make sure you're using a tracking app). If you only want to use Spotify, just enter your Stats.fm username — but note that it only supports players available on Stats.fm.",
        "pt": "Você pode usar o Last.fm para scrobble em serviços como YouTube, YouTube Music, SoundCloud, exteraGram e AyuGram (certifique-se de usar algum app de tracking). Se quiser usar apenas o Spotify, basta inserir seu nome de usuário do Stats.fm — mas saiba que ele só oferece suporte aos players compatíveis com o Stats.fm.",
        "es": "Puedes usar Last.fm para hacer scrobble desde servicios como YouTube, YouTube Music, SoundCloud, exteraGram y AyuGram (asegúrate de usar una app de tracking). Si solo quieres usar Spotify, solo ingresa tu nombre de usuario de Stats.fm, pero ten en cuenta que solo admite los reproductores compatibles con Stats.fm.",
        "ru": "Вы можете использовать Last.fm для скробблинга с YouTube, YouTube Music, SoundCloud, exteraGram и AyuGram (убедитесь, что используете приложение для трекинга). Если хотите использовать только Spotify, введите имя пользователя Stats.fm — но учтите, что он поддерживает только плееры, совместимые со Stats.fm.",
        "fr": "Vous pouvez utiliser Last.fm pour scrobbler depuis des services comme YouTube, YouTube Music, SoundCloud, exteraGram et AyuGram (assurez-vous d'utiliser une application de suivi). Si vous souhaitez uniquement utiliser Spotify, entrez simplement votre nom d'utilisateur Stats.fm — mais sachez qu'il ne prend en charge que les lecteurs pris en charge par Stats.fm."
    },
    "lastfm_get_api_key": {
        "en": "Get key",
        "pt": "Obter chave",
        "es": "Obtener clave",
        "ru": "Получить ключ",
        "fr": "Obtenir clé"
    },
    "artwork_priority_title": {"pt": "Prioridade de Capa", "en": "Artwork Priority", "es": "Prioridad de Portada", "ru": "Приоритет обложки", "fr": "Priorité de la pochette"},
    "error_generic": {"pt": "Erro: {error}", "en": "Error: {error}", "es": "Error: {error}", "fr": "Erreur: {error}", "ru": "Ошибка: {error}"},
    "error_lastfm": {"pt": "Erro do LastFM: {error}", "en": "LastFM error: {error}", "es": "Error de LastFM: {error}", "fr": "Erreur LastFM: {error}", "ru": "Ошибка LastFM: {error}"},
    "artwork_priority_subtext": {"pt": "Escolha a prioridade de capa preferida", "en": "Choose your preferred artwork priority", "es": "Elige tu prioridad de portada preferida", "ru": "Выберите предпочтительный приоритет обложки", "fr": "Choisissez votre priorité de pochette préférée"},
    "lastfm_credentials_header": {
        "pt": "Credenciais e APIs",
        "en": "Credentials & APIs",
        "ru": "Данные и API",
        "es": "Credenciales y APIs",
        "fr": "Identifiants et APIs"
    },
    "lastfm_personalization_header": {
        "pt": "Personalização do Last.FM",
        "en": "Last.FM Personalization",
        "ru": "Персонализация Last.FM",
        "es": "Personalización de Last.FM",
        "fr": "Personnalisation Last.FM"
    },
    "lastfm_integration_header": {
        "pt": "Integração e Fonte de Mídia",
        "en": "Integration & Media Source",
        "ru": "Интеграция и источник медиа",
        "es": "Integración y Fuente de Medios",
        "fr": "Intégration et Source Média"
    },
    "exteragram_username_subtext": {
        "pt": "Insira o username de um perfil, canal ou grupo para linkar no card. Exemplo: exteradevplugins (irá abrir t.me/exteradevplugins)",
        "en": "Enter the username of a profile, channel or group to link in the card. Example: exteradevplugins (will open t.me/exteradevplugins)",
        "ru": "Введите username профиля, канала или группы для ссылки на карточке. Пример: exteradevplugins (откроет t.me/exteradevplugins)",
        "es": "Ingrese el nombre de usuario de un perfil, canal o grupo para enlazar en la tarjeta. Ejemplo: exteradevplugins (abrirá t.me/exteradevplugins)",
        "fr": "Entrez le nom d'utilisateur d'un profil, canal ou groupe à lier sur la carte. Exemple : exteradevplugins (ouvrira t.me/exteradevplugins)"
    },

    "test_lastfm_account": {
        "pt": "Verificar Conta LastFM",
        "en": "Verify LastFM Account",
        "es": "Verificar Cuenta LastFM",
        "fr": "Vérifier Compte LastFM",
        "ru": "Проверить аккаунт LastFM"
    },
    "integration_media_source_info": {
        "pt": "Media Source",
        "en": "Media Source",
        "es": "Fuente de Medios",
        "fr": "Source Média",
        "ru": "Источник медиа"
    },
    "integration_media_source_dialog": {
        "pt": "Integration & Media Source\n\nEsta seção permite configurar como o nowFy detecta e processa música de diferentes fontes:\n\n• Active Player: Define qual aplicativo de música será monitorado para detectar a música atual (Spotify, YouTube Music, Apple Music, etc.). O plugin irá capturar informações da música que está tocando no player selecionado. O player 'FM' é um player personalizado que permite usar dados do Last.fm independente do player ativo.\n\n• Data Mode: Determina de onde vêm os dados da música:\n  - Via Spotify: Usa a API do Spotify para obter informações detalhadas\n  - Via Last.FM: Usa o Last.FM para obter dados de scrobbling e histórico\n\n• Artwork API: Prioridade das APIs para buscar capas de álbuns\n\nEssas configurações determinam como o plugin funciona com diferentes serviços de música.",
        "en": "Integration & Media Source\n\nThis section allows you to configure how nowFy detects and processes music from different sources:\n\n• Active Player: Defines which music app will be monitored to detect the current music (Spotify, YouTube Music, Apple Music, etc.). The plugin will capture information from the music playing on the selected player. The 'FM' player is a custom player that allows using Last.fm data regardless of the active player.\n\n• Data Mode: Determines where the music data comes from:\n  - Via Spotify: Uses Spotify API to get detailed information\n  - Via Last.FM: Uses Last.FM to get scrobbling data and history\n\n• Artwork API: Priority of APIs to search for album covers\n\nThese settings determine how the plugin works with different music services.",
        "es": "Integración y Fuente de Medios\n\nEsta sección te permite configurar cómo nowFy detecta y procesa música de diferentes fuentes:\n\n• Reproductor Activo: Define qué aplicación de música será monitoreada para detectar la música actual (Spotify, YouTube Music, Apple Music, etc.). El plugin capturará información de la música que se reproduce en el reproductor seleccionado. El reproductor 'FM' es un reproductor personalizado que permite usar datos de Last.fm independientemente del reproductor activo.\n\n• Modo de Datos: Determina de dónde provienen los datos de la música:\n  - Vía Spotify: Usa la API de Spotify para obtener información detallada\n  - Vía Last.FM: Usa Last.FM para obtener datos de scrobbling e historial\n\n• API de Portada: Prioridad de las APIs para buscar portadas de álbumes\n\nEstos ajustes determinan cómo funciona el plugin con diferentes servicios de música.",
        "fr": "Intégration et Source Média\n\nCette section vous permet de configurer comment nowFy détecte et traite la musique de différentes sources :\n\n• Lecteur Actif : Définit quelle application musicale sera surveillée pour détecter la musique actuelle (Spotify, YouTube Music, Apple Music, etc.). Le plugin capturera les informations de la musique en cours de lecture sur le lecteur sélectionné. Le lecteur 'FM' est un lecteur personnalisé qui permet d'utiliser les données Last.fm indépendamment du lecteur actif.\n\n• Mode de Données : Détermine d'où proviennent les données musicales :\n  - Via Spotify : Utilise l'API Spotify pour obtenir des informations détaillées\n  - Via Last.FM : Utilise Last.FM pour obtenir des données de scrobbling et l'historique\n\n• API de Pochette : Priorité des APIs pour rechercher les pochettes d'albums\n\nCes paramètres déterminent comment le plugin fonctionne avec différents services de musique.",
        "ru": "Интеграция и источник медиа\n\nЭтот раздел позволяет настроить, как nowFy обнаруживает и обрабатывает музыку из разных источников:\n\n• Активный плеер: Определяет, какое музыкальное приложение будет отслеживаться для обнаружения текущей музыки (Spotify, YouTube Music, Apple Music и т.д.). Плагин будет захватывать информацию о музыке, воспроизводимой в выбранном плеере. Плеер 'FM' - это пользовательский плеер, который позволяет использовать данные Last.fm независимо от активного плеера.\n\n• Режим данных: Определяет, откуда берутся данные о музыке:\n  - Через Spotify: Использует API Spotify для получения подробной информации\n  - Через Last.FM: Использует Last.FM для получения данных скробблинга и истории\n\n• API обложки: Приоритет API для поиска обложек альбомов\n\nЭти настройки определяют, как плагин работает с различными музыкальными сервисами."
    },
    "credentials_info": {
        "pt": "Sobre as Credenciais",
        "en": "Credentials Info",
        "es": "Info de Credenciales",
        "fr": "Info Identifiants",
        "ru": "Информация об учетных данных"
    },
    "credentials_info_dialog": {
        "en": (
            "Spotify Credentials Setup\n\n"
            "To use nowFy with Spotify, follow the steps below:\n\n"
            "1. Go to https://developer.spotify.com/dashboard/create and create an app\n"
            "2. Add this Redirect URI (mandatory):\n"
            "   https://example.com/callback\n"
            "3. After creating the app, copy your:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. In the plugin chat, send:\n"
            "   • .setid YOUR_CLIENT_ID\n"
            "   • .setsecret YOUR_CLIENT_SECRET\n"
            "5. Then use:\n"
            "   • .connect\n"
            "   This will generate your personal authorization link\n"
            "6. Open the link, log in to Spotify, and authorize the app\n"
            "7. You will be redirected to a URL like:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copy the full URL or just the code and send:\n"
            "   • .code FULL_URL or .code CODE_ONLY\n\n"
            "All credentials are required for the plugin to work."
        ),
        "pt": (
            "Configuração do Spotify\n\n"
            "Para usar o nowFy com o Spotify, siga os passos abaixo:\n\n"
            "1. Acesse https://developer.spotify.com/dashboard/create e crie um app\n"
            "2. Adicione este Redirect URI (obrigatório):\n"
            "   https://example.com/callback\n"
            "3. Após criar o app, copie:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. No chat com o plugin, envie:\n"
            "   • .setid SEU_CLIENT_ID\n"
            "   • .setsecret SEU_CLIENT_SECRET\n"
            "5. Em seguida, use:\n"
            "   • .connect\n"
            "   Isso vai gerar seu link de autorização\n"
            "6. Abra o link, entre na sua conta do Spotify e autorize o app\n"
            "7. Você será redirecionado para uma URL como:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copie a URL completa ou só o código e envie:\n"
            "   • .code URL_COMPLETA ou .code CODIGO_APENAS\n\n"
            "Todas as credenciais são obrigatórias para o funcionamento do plugin."
        ),
        "es": (
            "Configuración de Spotify\n\n"
            "Para usar nowFy con Spotify, sigue estos pasos:\n\n"
            "1. Ve a https://developer.spotify.com/dashboard/create y crea una app\n"
            "2. Agrega este Redirect URI (obligatorio):\n"
            "   https://example.com/callback\n"
            "3. Después de crear la app, copia:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. En el chat del plugin, envía:\n"
            "   • .setid TU_CLIENT_ID\n"
            "   • .setsecret TU_CLIENT_SECRET\n"
            "5. Luego usa:\n"
            "   • .connect\n"
            "   Esto generará tu enlace de autorización personal\n"
            "6. Abre el enlace, inicia sesión en Spotify y autoriza la app\n"
            "7. Serás redirigido a una URL como:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copia la URL completa o solo el código y envía:\n"
            "   • .code URL_COMPLETA o .code SOLO_CODIGO\n\n"
            "Todas las credenciales son necesarias para que el plugin funcione."
        ),
        "fr": (
            "Configuration de Spotify\n\n"
            "Pour utiliser nowFy avec Spotify, suivez ces étapes :\n\n"
            "1. Allez sur https://developer.spotify.com/dashboard/create et créez une application\n"
            "2. Ajoutez cet URI de redirection (obligatoire) :\n"
            "   https://example.com/callback\n"
            "3. Après avoir créé l'application, copiez :\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. Dans le chat du plugin, envoyez :\n"
            "   • .setid VOTRE_CLIENT_ID\n"
            "   • .setsecret VOTRE_CLIENT_SECRET\n"
            "5. Ensuite, utilisez :\n"
            "   • .connect\n"
            "   Cela générera votre lien d'autorisation personnel\n"
            "6. Ouvrez le lien, connectez-vous à Spotify et autorisez l'application\n"
            "7. Vous serez redirigé vers une URL comme :\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Copiez l'URL complète ou seulement le code et envoyez :\n"
            "   • .code URL_COMPLÈTE ou .code CODE_SEUL\n\n"
            "Toutes les informations sont nécessaires pour que le plugin fonctionne."
        ),
        "ru": (
            "Настройка Spotify\n\n"
            "Чтобы использовать nowFy с Spotify, выполните следующие шаги:\n\n"
            "1. Перейдите на https://developer.spotify.com/dashboard/create и создайте приложение\n"
            "2. Добавьте этот Redirect URI (обязательно):\n"
            "   https://example.com/callback\n"
            "3. После создания приложения скопируйте:\n"
            "   • Client ID\n"
            "   • Client Secret\n"
            "4. В чате с плагином выполните:\n"
            "   • .setid ВАШ_CLIENT_ID\n"
            "   • .setsecret ВАШ_CLIENT_SECRET\n"
            "5. Затем используйте:\n"
            "   • .connect\n"
            "   Это сгенерирует вашу персональную ссылку авторизации\n"
            "6. Откройте ссылку, войдите в Spotify и подтвердите доступ\n"
            "7. Вы будете перенаправлены на адрес вроде:\n"
            "   https://example.com/callback?code=abc123xyz\n"
            "8. Скопируйте полную ссылку или только код и отправьте:\n"
            "   • .code ПОЛНАЯ_ССЫЛКА или .code ТОЛЬКО_КОД\n\n"
            "Все учетные данные необходимы для работы плагина."
        )
    },
    "card_appearance_header": {"pt": "Aparência do Card", "en": "Card Appearance", "es": "Apariencia de la Tarjeta", "fr": "Apparence de la carte", "ru": "Внешний вид карточки"},
    "cache_header": {"pt": "Cache", "en": "Cache", "es": "Caché", "fr": "Cache", "ru": "Кэш"},
    "smart_bio_header": {
        "en": "Bio Features",
        "pt": "Recursos da Bio",
        "es": "Funciones de la Bio",
        "fr": "Fonctionnalités Bio",
        "ru": "Функции био"
    },
    "lastfm_test_title": {
        "pt": "Teste LastFM",
        "en": "LastFM Test",
        "es": "Prueba LastFM",
        "fr": "Test LastFM",
        "ru": "Тест LastFM"
    },
    "lastfm_username_not_configured": {
        "pt": "Username não configurado!\n\nConfigure o username do LastFM primeiro.",
        "en": "Username not configured!\n\nConfigure the LastFM username first.",
        "es": "¡Username no configurado!\n\nConfigure el username de LastFM primero.",
        "fr": "Nom d'utilisateur non configuré!\n\nConfigurez le nom d'utilisateur LastFM d'abord.",
        "ru": "Имя пользователя не настроено!\n\nСначала настройте имя пользователя LastFM."
    },
    "lastfm_testing": {
        "pt": "Testando LastFM",
        "en": "Testing LastFM",
        "es": "Probando LastFM",
        "fr": "Test de LastFM",
        "ru": "Тестирование LastFM"
    },
    "lastfm_checking_account": {
        "pt": "Verificando conta: @{username}\n\nAguarde...",
        "en": "Checking account: @{username}\n\nPlease wait...",
        "es": "Verificando cuenta: @{username}\n\nEspere...",
        "fr": "Vérification du compte: @{username}\n\nVeuillez patienter...",
        "ru": "Проверка аккаунта: @{username}\n\nПодождите..."
    },
    "cancel": {
        "pt": "Cancelar",
        "en": "Cancel",
        "es": "Cancelar",
        "fr": "Annuler",
        "ru": "Отмена"
    },
    "lastfm_api_connection_error": {
        "pt": "Não foi possível conectar à API do LastFM",
        "en": "Could not connect to LastFM API",
        "es": "No se pudo conectar a la API de LastFM",
        "fr": "Impossible de se connecter à l'API LastFM",
        "ru": "Не удалось подключиться к API LastFM"
    },
    "lastfm_recent_tracks_error": {
        "pt": "Não foi possível buscar músicas recentes",
        "en": "Could not fetch recent tracks",
        "es": "No se pudieron obtener las canciones recientes",
        "fr": "Impossible de récupérer les morceaux récents",
        "ru": "Не удалось получить недавние треки"
    },
    "lastfm_test_result": {
        "pt": "Resultado do Teste LastFM",
        "en": "LastFM Test Result",
        "es": "Resultado de la Prueba LastFM",
        "fr": "Résultat du Test LastFM",
        "ru": "Результат теста LastFM"
    },
    "lastfm_account_working": {
        "pt": "Conta verificada com sucesso!\n\nUsuário: @{username}\nTotal de músicas ouvidas: {playcount}",
        "en": "Account successfully verified!\n\nUsername: @{username}\nTotal tracks played: {playcount}",
        "es": "¡Cuenta verificada con éxito!\n\nUsuario: @{username}\nTotal de canciones escuchadas: {playcount}",
        "fr": "Compte vérifié avec succès !\n\nNom d'utilisateur : @{username}\nTotal de morceaux écoutés : {playcount}",
        "ru": "Аккаунт успешно проверен!\n\nПользователь: @{username}\nВсего прослушанных треков: {playcount}"
    },
    "lastfm_now_playing": {
        "pt": "Tocando agora:\n{track} by {artist}",
        "en": "Now playing:\n{track} by {artist}",
        "es": "Reproduciendo ahora:\n{track} by {artist}",
        "fr": "En cours de lecture:\n{track} by {artist}",
        "ru": "Сейчас играет:\n{track} by {artist}"
    },
    "lastfm_last_played": {
        "pt": "Última música ouvida:\n{track} by {artist}",
        "en": "Last played:\n{track} by {artist}",
        "es": "Última canción escuchada:\n{track} by {artist}",
        "fr": "Dernier morceau écouté:\n{track} by {artist}",
        "ru": "Последний прослушанный трек:\n{track} by {artist}"
    },
    "lastfm_test_failed": {
        "pt": "Falha no teste!\n\nUsuário: @{username}{error}\n\nVerifique:\n• API Key configurada\n• Username correto\n• Conexão com internet",
        "en": "Test failed!\n\nUsername: @{username}{error}\n\nCheck:\n• API Key configured\n• Correct username\n• Internet connection",
        "es": "¡Prueba fallida!\n\nUsuario: @{username}{error}\n\nVerifique:\n• API Key configurada\n• Username correcto\n• Conexión a internet",
        "fr": "Test échoué!\n\nNom d'utilisateur: @{username}{error}\n\nVérifiez:\n• Clé API configurée\n• Nom d'utilisateur correct\n• Connexion internet",
        "ru": "Тест не удался!\n\nПользователь: @{username}{error}\n\nПроверьте:\n• API ключ настроен\n• Правильное имя пользователя\n• Интернет соединение"
    },
    "extras_header": {"pt": "Extras", "en": "Extras", "es": "Extras", "fr": "Extras", "ru": "Дополнительно"},
    "smart_bio_enabled": {"pt": "Smart Bio", "en": "Smart Bio", "es": "Bio Inteligente", "fr": "Bio intelligente", "ru": "Умная био"},
    "smart_bio_auto_refresh": {"pt": "Auto-refresh bio", "en": "Auto-refresh bio", "es": "Auto-actualizar bio", "fr": "Actualisation auto de la bio", "ru": "Автообновление био"},
    "bio_text": {"pt": "Bio", "en": "Bio", "es": "Bio", "fr": "Bio", "ru": "Био"},
    "smart_bio_panel_sub": {
        "pt": "Gerencie a bio automática baseada na música tocando",
        "en": "Manage automatic bio based on the current track",
        "es": "Gestiona la bio automática según la música actual",
        "fr": "Gérez la bio automatique selon la musique en cours",
        "ru": "Управляйте авто-био на основе текущего трека"
    },
    "error_youtube_api_key": {
        "pt": "YouTube API Key não configurada. Configure em Configurações > nowFy > YouTube API Key",
        "en": "YouTube API Key not configured. Configure in Settings > nowFy > YouTube API Key",
        "es": "Clave de API de YouTube no configurada. Configure en Ajustes > nowFy > YouTube API Key",
        "fr": "Clé API YouTube non configurée. Configurez dans Paramètres > nowFy > YouTube API Key",
        "ru": "Ключ API YouTube не настроен. Настройте в Настройки > nowFy > YouTube API Key"
    },
    "guide_title": {
        "pt": "Guia de Login e Uso",
        "en": "Login & Usage Guide",
        "es": "Guía de inicio de sesión y uso",
        "fr": "Guide de connexion et d'utilisation",
        "ru": "Руководство по входу и использованию"
    },
    "guide_message": {
        "pt": "Veja o guia completo para criar um app no Spotify for Developers e obter seu Client ID e Secret. Siga o passo a passo para configurar o nowFy corretamente.",
        "en": "View the full guide to create an app on Spotify for Developers and get your Client ID and Secret. Follow the step-by-step instructions to set up nowFy correctly.",
        "es": "Consulta la guía completa para crear una aplicación en Spotify for Developers y obtener tu Client ID y Secret. Sigue las instrucciones paso a paso para configurar nowFy correctamente.",
        "fr": "Consultez le guide complet pour créer une application sur Spotify for Developers et obtenir votre Client ID et Secret. Suivez les instructions étape par étape pour configurer nowFy correctement.",
        "ru": "Ознакомьтесь с полным руководством по созданию приложения в Spotify for Developers и получению Client ID и Secret. Следуйте пошаговым инструкциям для правильной настройки nowFy."
    },
    "guide_open_link": {
        "pt": "Abrir Guia",
        "en": "Open Guide",
        "es": "Abrir Guía",
        "fr": "Ouvrir le guide",
        "ru": "Открыть руководство"
    },
    "no_track_playing_soundcloud": {
        "pt": "Nenhuma música tocando no SoundCloud.",
        "en": "No track playing on SoundCloud.",
        "es": "No hay música reproduciéndose en SoundCloud.",
        "fr": "Aucune musique en cours sur SoundCloud.",
        "ru": "Нет воспроизводимой музыки в SoundCloud."
    },
    "lastfm_key_saved": {
        "pt": "Chave da API do LastFM salva!",
        "en": "LastFM API key saved!",
        "es": "¡Clave API de LastFM guardada!",
        "fr": "Clé API LastFM enregistrée!",
        "ru": "Ключ API LastFM сохранён!"
    },
    "lastfm_user_saved": {
        "pt": "Usuário do LastFM salvo!",
        "en": "LastFM username saved!",
        "es": "¡Usuario de LastFM guardado!",
        "fr": "Nom d'utilisateur LastFM enregistré!",
        "ru": "Имя пользователя LastFM сохранено!"
    },
    "client_id": {"pt": "Client ID", "en": "Client ID", "es": "Client ID", "fr": "Client ID", "ru": "Client ID"},
    "client_id_subtext": {
        "pt": "Seu Client ID do app Spotify Developers.",
        "en": "Your Client ID from Spotify Developers app.",
        "es": "Tu Client ID de la app Spotify Developers.",
        "fr": "Votre Client ID de l'application Spotify Developers.",
        "ru": "Ваш Client ID из приложения Spotify Developers."
    },
    "client_secret": {"pt": "Client Secret", "en": "Client Secret", "es": "Client Secret", "fr": "Client Secret", "ru": "Client Secret"},
    "client_secret_subtext": {
        "pt": "Seu Client Secret do app Spotify Developers.",
        "en": "Your Client Secret from Spotify Developers app.",
        "es": "Tu Client Secret de la app Spotify Developers.",
        "fr": "Votre Client Secret de l'application Spotify Developers.",
        "ru": "Ваш Client Secret из приложения Spotify Developers."
    },
    "refresh_token": {"pt": "Refresh Token", "en": "Refresh Token", "es": "Refresh Token", "fr": "Refresh Token", "ru": "Refresh Token"},
    "refresh_token_subtext": {
        "pt": "Cole aqui seu refresh token ou use o comando .code para gerar.",
        "en": "Paste your refresh token here or use the .code command to generate.",
        "es": "Pega aquí tu refresh token o usa el comando .code para generar uno.",
        "fr": "Collez ici votre refresh token ou utilisez la commande .code pour en générer un.",
        "ru": "Вставьте сюда ваш refresh token или используйте команду .code для его получения."
    },
    "artwork_source_youtube": {"pt": "Usar YouTube como fonte de capa", "en": "Use YouTube as artwork source", "es": "Usar YouTube como fuente de portada", "fr": "Utiliser YouTube comme source de pochette", "ru": "Использовать YouTube как источник обложки"},
    "artwork_source_lastfm": {"pt": "Usar LastFM como fonte de capa", "en": "Use LastFM as artwork source", "es": "Usar LastFM como fuente de portada", "fr": "Utiliser LastFM comme source de pochette", "ru": "Использовать LastFM как источник обложки"},
    "artwork_priority_selector": {"pt": "Fonte de capa preferida", "en": "Preferred artwork source", "es": "Fuente de portada preferida", "fr": "Source de pochette préférée", "ru": "Предпочтительный источник обложки"},
    "artwork_spotify": {"pt": "Spotify", "en": "Spotify", "es": "Spotify", "fr": "Spotify", "ru": "Spotify"},
    "artwork_deezer": {"pt": "Deezer", "en": "Deezer", "es": "Deezer", "fr": "Deezer", "ru": "Deezer"},
    "artwork_itunes": {"pt": "iTunes", "en": "iTunes", "es": "iTunes", "fr": "iTunes", "ru": "iTunes"},
    "artwork_youtube": {"pt": "YouTube", "en": "YouTube", "es": "YouTube", "fr": "YouTube", "ru": "YouTube"},
    "artwork_lastfm": {"pt": "LastFM", "en": "LastFM", "es": "LastFM", "fr": "LastFM", "ru": "LastFM"},
    "artwork_coverart": {"pt": "Cover Art Archive", "en": "Cover Art Archive", "es": "Cover Art Archive", "fr": "Cover Art Archive", "ru": "Cover Art Archive"},
    "diversos_header": {
        "pt": "Diversos",
        "en": "Miscellaneous",
        "es": "Varios",
        "fr": "Divers",
        "ru": "Разное"
    },
    "diversos_custom_command": {
        "pt": "Comando Personalizado",
        "en": "Custom Command",
        "es": "Comando Personalizado",
        "fr": "Commande personnalisée",
        "ru": "Пользовательская команда"
    },
    "diversos_show_chat_menu": {
        "pt": "Mostrar no Menu do Chat",
        "en": "Show in Chat Menu",
        "es": "Mostrar en el menú del chat",
        "fr": "Afficher dans le menu du chat",
        "ru": "Показать в меню чата"
    },
    "music_detection_section": {
        "pt": "Detecção de Música",
        "en": "Music Detection",
        "es": "Detección de Música",
        "fr": "Détection Musicale",
        "ru": "Обнаружение музыки"
    },
    "active_player": {
        "pt": "Player Ativo",
        "en": "Active Player",
        "es": "Reproductor Activo",
        "fr": "Lecteur Actif",
        "ru": "Активный плеер"
    },
    "active_player_subtext": {
        "pt": "Qual aplicativo está tocando música",
        "en": "Which app is playing music",
        "es": "Qué aplicación está reproduciendo música",
        "fr": "Quelle application joue de la musique",
        "ru": "Какое приложение воспроизводит музыку"
    },
    "data_mode": {
        "pt": "Modo de Dados",
        "en": "Data Mode",
        "es": "Modo de Datos",
        "fr": "Mode de Données",
        "ru": "Режим данных"
    },
    "data_mode_subtext": {
        "pt": "Como obter informações da música",
        "en": "How to get music information",
        "es": "Cómo obtener información de la música",
        "fr": "Comment obtenir les informations musicales",
        "ru": "Как получить информацию о музыке"
    },
    "apis_integration_section": {
        "pt": "APIs e Integração",
        "en": "APIs & Integration",
        "es": "APIs e Integración",
        "fr": "APIs et Intégration",
        "ru": "API и интеграция"
    },
    "diversos_media_source": {
        "pt": "Fonte da Mídia",
        "en": "Media Source",
        "es": "Fuente de Medios",
        "fr": "Source Média",
        "ru": "Источник медиа"
    },
    "diversos_artwork_api": {
        "pt": "API de Capa",
        "en": "Artwork API",
        "es": "API de Portada",
        "fr": "API de pochette",
        "ru": "API обложки"
    },
    "diversos_media_source_info": {
        "pt": "Configurações de mídia",
        "en": "Media Settings",
        "es": "Configuración de medios",
        "fr": "Paramètres des médias",
        "ru": "Настройки медиа"
    },
    "link_options_header": {
        "pt": "Opções de Links",
        "en": "Link Options",
        "es": "Opciones de Enlaces",
        "fr": "Options de Liens",
        "ru": "Опции ссылок"
    },
    "no_services_configured": {
        "pt": "Nenhum serviço configurado. Configure pelo menos um: Stats.fm username, Last.fm API key ou credenciais do Spotify.",
        "en": "No services configured. Please configure at least one: Stats.fm username, Last.fm API key, or Spotify credentials.",
        "es": "Ningún servicio configurado. Configure al menos uno: nombre de usuario de Stats.fm, clave API de Last.fm o credenciales de Spotify.",
        "fr": "Aucun service configuré. Veuillez configurer au moins un : nom d'utilisateur Stats.fm, clé API Last.fm ou identifiants Spotify.",
        "ru": "Сервисы не настроены. Настройте хотя бы один: имя пользователя Stats.fm, ключ API Last.fm или учетные данные Spotify."
    },
    
    # NowCast Messages
    "nowcast_activated_card_sent": {
        "pt": "NowCast ativado e card enviado!",
        "en": "NowCast activated and card sent!",
        "es": "NowCast activado y tarjeta enviada!",
        "fr": "NowCast activé et carte envoyée!",
        "ru": "NowCast активирован и карточка отправлена!"
    },
    "nowcast_activated_card_error": {
        "pt": "NowCast ativado, mas erro ao enviar card",
        "en": "NowCast activated, but error sending card",
        "es": "NowCast activado, pero error al enviar tarjeta",
        "fr": "NowCast activé, mais erreur lors de l'envoi de la carte",
        "ru": "NowCast активирован, но ошибка отправки карточки"
    },
    "nowcast_activated_duplicate": {
        "pt": "NowCast ativado! Música já foi postada recentemente.",
        "en": "NowCast activated! Song was already posted recently.",
        "es": "NowCast activado! La canción ya fue publicada recientemente.",
        "fr": "NowCast activé! La chanson a déjà été postée récemment.",
        "ru": "NowCast активирован! Песня уже была опубликована недавно."
    },
    "nowcast_activated_waiting": {
        "pt": "NowCast ativado! Aguardando música...",
        "en": "NowCast activated! Waiting for music...",
        "es": "NowCast activado! Esperando música...",
        "fr": "NowCast activé! En attente de musique...",
        "ru": "NowCast активирован! Ожидание музыки..."
    },
    "nowcast_bot_command_error": {
        "pt": "Erro ao executar comando .bot",
        "en": "Error executing .bot command",
        "es": "Error al ejecutar comando .bot",
        "fr": "Erreur lors de l'exécution de la commande .bot",
        "ru": "Ошибка выполнения команды .bot"
    },
    "nowcast_not_configured": {
        "pt": "NowCast não está configurado corretamente. Verifique as credenciais e configurações do bot.",
        "en": "NowCast is not configured correctly. Check bot credentials and settings.",
        "es": "NowCast no está configurado correctamente. Verifique las credenciales y configuraciones del bot.",
        "fr": "NowCast n'est pas configuré correctement. Vérifiez les identifiants et paramètres du bot.",
        "ru": "NowCast настроен неправильно. Проверьте учетные данные и настройки бота."
    },
    "nowcast_auto_disabled": {
        "pt": "NowCast foi desligado automaticamente após 10 minutos de inatividade musical.",
        "en": "NowCast was automatically disabled after 10 minutes of musical inactivity.",
        "es": "NowCast se desactivó automáticamente después de 10 minutos de inactividad musical.",
        "fr": "NowCast a été automatiquement désactivé après 10 minutes d'inactivité musicale.",
        "ru": "NowCast был автоматически отключен после 10 минут музыкальной неактивности."
    },
    "nowcast_link_spotify": {
        "pt": "Ouvir no Spotify",
        "en": "Listen on Spotify",
        "es": "Escuchar en Spotify",
        "fr": "Écouter sur Spotify",
        "ru": "Слушать в Spotify"
    },
    "nowcast_link_platforms": {
        "pt": "song.link",
        "en": "song.link",
        "es": "song.link",
        "fr": "song.link",
        "ru": "song.link"
    }
}

TRANSLATIONS.update({
    "diversos_sub": {
        "pt": "Expandir para visualizar configurações diversas. Ativar expande o painel, desativar o recolhe.",
        "en": "Expand to view miscellaneous settings. Turning on expands the panel, turning off collapses it.",
        "es": "Expandir para ver configuraciones diversas. Al activar se expande el panel, al desactivar se contrae.",
        "fr": "Développer pour voir les paramètres divers. Activer déploie le panneau, désactiver le replie.",
        "ru": "Развернуть для просмотра различных настроек. Включение раскрывает панель, выключение сворачивает её."
    },
    "command_settings_section": {
        "pt": "Configurações de Comando",
        "en": "Command Settings",
        "es": "Configuraciones de Comando",
        "fr": "Paramètres de Commande",
        "ru": "Настройки команд"
    },
    "interface_settings_section": {
        "pt": "Configurações de Interface",
        "en": "Interface Settings",
        "es": "Configuraciones de Interfaz",
        "fr": "Paramètres d'Interface",
        "ru": "Настройки интерфейса"
    },
    "media_settings_section": {
        "pt": "Configurações de Mídia",
        "en": "Media Settings",
        "es": "Configuraciones de Medios",
        "fr": "Paramètres Média",
        "ru": "Настройки медиа"
    },
    "help_info_section": {
        "pt": "Ajuda e Informações",
        "en": "Help and Information",
        "es": "Ayuda e Información",
        "fr": "Aide et Informations",
        "ru": "Справка и информация"
    },
    "spotify_auth_section": {
        "pt": "Autenticação do Spotify",
        "en": "Spotify Authentication",
        "es": "Autenticación de Spotify",
        "fr": "Authentification Spotify",
        "ru": "Аутентификация Spotify"
    },
    "spotify_help_section": {
        "pt": "Ajuda e Informações",
        "en": "Help and Information",
        "es": "Ayuda e Información",
        "fr": "Aide et Informations",
        "ru": "Справка и информация"
    },
    "lastfm_auth_section": {
        "pt": "Autenticação do Last.FM",
        "en": "Last.FM Authentication",
        "es": "Autenticación de Last.FM",
        "fr": "Authentification Last.FM",
        "ru": "Аутентификация Last.FM"
    },
    "youtube_api_section": {
        "pt": "API do YouTube",
        "en": "YouTube API",
        "es": "API de YouTube",
        "fr": "API YouTube",
        "ru": "API YouTube"
    },
    "lastfm_help_section": {
        "pt": "Testes e Ajuda",
        "en": "Tests and Help",
        "es": "Pruebas y Ayuda",
        "fr": "Tests et Aide",
        "ru": "Тесты и справка"
    },
    # Apple UI Options
    "apple_ui_section": {
        "pt": "Apple UI (Experimental)",
        "en": "Apple UI (Experimental)",
        "es": "Apple UI (Experimental)",
        "fr": "Apple UI (Expérimental)",
        "ru": "Apple UI (Экспериментальный)"
    },
    "apple_ui_warning": {
        "pt": "Configurações experimentais para temas Apple. Algumas features podem precisar de melhorias.",
        "en": "Experimental settings for Apple themes. Some features may need improvements.",
        "es": "Configuraciones experimentales para temas Apple. Algunas características pueden necesitar mejoras.",
        "fr": "Paramètres expérimentaux pour les thèmes Apple. Certaines fonctionnalités peuvent nécessiter des améliorations.",
        "ru": "Экспериментальные настройки для тем Apple. Некоторые функции могут нуждаться в улучшениях."
    },

    "apple_radius_original": {
        "pt": "Original",
        "en": "Original",
        "es": "Original",
        "fr": "Original",
        "ru": "Оригинал"
    },
    "apple_radius_standard": {
        "pt": "Padrão",
        "en": "Standard",
        "es": "Estándar",
        "fr": "Standard",
        "ru": "Стандарт"
    },
    "apple_radius_small": {
        "pt": "Pequeno",
        "en": "Small",
        "es": "Pequeño",
        "fr": "Petit",
        "ru": "Маленький"
    },
    "apple_radius_medium": {
        "pt": "Médio",
        "en": "Medium",
        "es": "Medio",
        "fr": "Moyen",
        "ru": "Средний"
    },
    "apple_radius_large": {
        "pt": "Grande",
        "en": "Large",
        "es": "Grande",
        "fr": "Grand",
        "ru": "Большой"
    },
    "apple_antialiasing_quality": {
        "pt": "Qualidade do Anti-aliasing",
        "en": "Anti-aliasing Quality",
        "es": "Calidad del Anti-aliasing",
        "fr": "Qualité de l'Anti-aliasing",
        "ru": "Качество сглаживания"
    },
    "apple_resize_algorithm": {
        "pt": "Algoritmo de Redimensionamento",
        "en": "Resize Algorithm",
        "es": "Algoritmo de Redimensionamiento",
        "fr": "Algorithme de Redimensionnement",
        "ru": "Алгоритм изменения размера"
    },
    "apple_cover_quality": {
        "pt": "Qualidade da Mini Capa",
        "en": "Mini Cover Quality",
        "es": "Calidad de Mini Portada",
        "fr": "Qualité de Mini Couverture",
        "ru": "Качество мини обложки"
    },
    "apple_enhanced_smoothing": {
        "pt": "Suavização Aprimorada",
        "en": "Enhanced Smoothing",
        "es": "Suavizado Mejorado",
        "fr": "Lissage Amélioré",
        "ru": "Улучшенное сглаживание"
    },
    "apple_edge_enhancement": {
        "pt": "Realce de Bordas",
        "en": "Edge Enhancement",
        "es": "Realce de Bordes",
        "fr": "Amélioration des Bords",
        "ru": "Улучшение краев"
    },
    "apple_color_enhancement": {
        "pt": "Realce de Cores",
        "en": "Color Enhancement",
        "es": "Realce de Colores",
        "fr": "Amélioration des Couleurs",
        "ru": "Улучшение цветов"
    },
    "apple_cache_processed_covers": {
        "pt": "Cache de Mini Capas Processadas",
        "en": "Processed Mini Covers Cache",
        "es": "Caché de Mini Portadas Procesadas",
        "fr": "Cache de Mini Couvertures Traitées",
        "ru": "Кэш обработанных мини обложек"
    },
    "apple_async_processing": {
        "pt": "Processamento Assíncrono",
        "en": "Asynchronous Processing",
        "es": "Procesamiento Asíncrono",
        "fr": "Traitement Asynchrone",
        "ru": "Асинхронная обработка"
    }
})

# Send visual effect toggle and style selector translations
TRANSLATIONS.update({
    "send_visual_effect_sub": {
        "pt": "Cria um efeito de pulso na tela ao gerar o card Now Playing",
        "en": "Creates a pulse effect on the screen when generating the Now Playing card",
        "es": "Crea un efecto de pulso en la pantalla al generar la tarjeta Now Playing",
        "fr": "Crée un effet de pulsation à l'écran lors de la génération de la carte Now Playing",
        "ru": "Создаёт эффект пульсации на экране при создании карточки Now Playing"
    },
    "now_playing_label": {
        "pt": "Now Playing",
        "en": "Now Playing",
        "es": "Now Playing",
        "fr": "Now Playing",
        "ru": "Now Playing"
    },
    "now_playing_sub": {
        "pt": "Mostra Now Playing no menu do chat e envia o card",
        "en": "Shows Now Playing in chat menu and sends the card",
        "es": "Muestra Now Playing en el menú del chat y envía la tarjeta",
        "fr": "Affiche Now Playing dans le menu du chat et envoie la carte",
        "ru": "Показывает Now Playing в меню чата и отправляет карточку"
    },
    "now_card_source_label": {
        "pt": "Serviço do Now Card",
        "en": "Now Card Service",
        "es": "Servicio de la Tarjeta Now",
        "fr": "Service de la Carte Now",
        "ru": "Сервис карточки Now"
    },
    "now_playing_menu_item": {
        "pt": "Now Playing",
        "en": "Now Playing",
        "es": "Now Playing",
        "fr": "Now Playing",
        "ru": "Now Playing"
    }
})

def tr(key):
    lang = Locale.getDefault().getLanguage()
    # Normaliza para os idiomas suportados
    if lang not in ["pt", "en", "es", "fr", "ru"]:
        lang = "en"
    entry = TRANSLATIONS.get(key, {})
    return entry.get(lang) or entry.get("en") or key

# Sistema de menu de contexto implementado diretamente
class _MessageMenuRegistry:
    def __init__(self):
        self.items = []
        self._unhook_fill = None
        self._unhook_process = None

    def ensure_hooks(self, plugin):
        try:
            if not self._unhook_fill:
                ChatActivity = find_class("org.telegram.ui.ChatActivity")
                MessageObject = find_class("org.telegram.messenger.MessageObject")
                fill_method = ChatActivity.getClass().getDeclaredMethod(
                    "fillMessageMenu",
                    MessageObject,
                    ArrayList,
                    ArrayList,
                    ArrayList
                )
                self._unhook_fill = plugin.hook_method(fill_method, _FillMenuHook(self))
        except Exception as e:
            log(f"[Nowfy] fillMessageMenu hook error: {str(e)}")
        try:
            if not self._unhook_process:
                ChatActivity = find_class("org.telegram.ui.ChatActivity")
                process_method = ChatActivity.getClass().getDeclaredMethod(
                    "processSelectedOption",
                    Integer.TYPE
                )
                self._unhook_process = plugin.hook_method(process_method, _ProcessOptionHook(self))
        except Exception as e:
            log(f"[Nowfy] processSelectedOption hook error: {str(e)}")

    def register_item(self, *, text: str, option_id: int, icon_res: int, condition_predicate, on_click, insert_at_top: bool):
        handle = {
            'text': text,
            'option_id': int(option_id),
            'icon_res': int(icon_res),
            'condition': condition_predicate,
            'on_click': on_click,
            'insert_top': bool(insert_at_top),
        }
        self.items.append(handle)
        return handle

    def unregister_item(self, handle):
        if handle in self.items:
            self.items.remove(handle)

    def cleanup_hooks(self, plugin):
        try:
            if self._unhook_fill:
                plugin.unhook_method(self._unhook_fill)
                self._unhook_fill = None
            if self._unhook_process:
                plugin.unhook_method(self._unhook_process)
                self._unhook_process = None
        except Exception:
            pass

class _FillMenuHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        pass

    def after_hooked_method(self, param):
        try:
            primary = param.args[0]
            if primary is None:
                return
            try:
                self.registry.last_message = primary
            except Exception:
                pass
            icons = param.args[1]
            items = param.args[2]
            options = param.args[3]

            for entry in list(self.registry.items):
                try:
                    if entry.get('condition') and callable(entry['condition']):
                        if not entry['condition'](primary):
                            continue
                    if entry.get('insert_top'):
                        icons.add(0, Integer(entry['icon_res']))
                        options.add(0, Integer(entry['option_id']))
                        items.add(0, entry['text'])
                    else:
                        icons.add(Integer(entry['icon_res']))
                        options.add(Integer(entry['option_id']))
                        items.add(entry['text'])
                except Exception:
                    continue
        except Exception:
            pass

class _ProcessOptionHook:
    def __init__(self, registry: _MessageMenuRegistry):
        self.registry = registry

    def before_hooked_method(self, param):
        try:
            option = param.args[0]
            try:
                opt_val = int(option)
            except Exception:
                try:
                    opt_val = option.intValue()
                except Exception:
                    return

            for entry in list(self.registry.items):
                if opt_val == entry.get('option_id'):
                    try:
                        chat_activity = param.thisObject
                        message = getattr(chat_activity, 'selectedObject', None)
                        if message is None:
                            message = getattr(self.registry, 'last_message', None)
                        try:
                            chat_activity.closeMenu()
                        except Exception:
                            pass
                        if callable(entry.get('on_click')):
                            entry['on_click'](chat_activity, message)
                        param.setResult(None)
                    except Exception:
                        pass
                    finally:
                        return
        except Exception:
            pass

    def after_hooked_method(self, param):
        pass

# Registry global
_message_menu_registry = _MessageMenuRegistry()

def _ensure_message_menu_hooks(plugin):
    _message_menu_registry.ensure_hooks(plugin)

def cleanup_message_menu_hooks(plugin):
    _message_menu_registry.cleanup_hooks(plugin)

class MessageMenuUtilities:
    def register_message_menu_item(self, *, text: str, option_id: int, icon_res: int = R.drawable.files_music, condition_predicate=None, on_click=None, insert_at_top: bool = False):
        try:
            return _message_menu_registry.register_item(
                text=text,
                option_id=option_id,
                icon_res=icon_res,
                condition_predicate=condition_predicate,
                on_click=on_click,
                insert_at_top=insert_at_top,
            )
        except Exception as e:
            log(f"[Nowfy] register_message_menu_item error: {str(e)}")
            return None

    def unregister_message_menu_item(self, handle):
        try:
            if handle:
                _message_menu_registry.unregister_item(handle)
        except Exception as e:
            log(f"[Nowfy] unregister_message_menu_item error: {str(e)}")

# Instância global
message_menu_utilities = MessageMenuUtilities()

class exteraFyPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._message_lock = threading.Lock()
        self._cache_lock = threading.Lock()
        self._image_cache = {}
        self._cache_timestamps = {}
        self._cache_enabled = False
        self._cache_thread = None
        self._cache_running = False
        self._cache_ttl = 300
        self._cache_max_size = 10
        self._disk_cache_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFyCache")
        if not self._disk_cache_dir.exists():
            self._disk_cache_dir.mkdirs()
        
        # --- PERFORMANCE OPTIMIZATION: Enhanced Cache System ---
        self._enhanced_image_cache = {}  # Cache otimizado para imagens processadas (298x298)
        self._base_theme_cache = {}  # Cache para imagens base dos temas
        self._performance_mode = "balanced"  # turbo, balanced, quality
        self._preload_enabled = False
        self._compression_enabled = True
        self._standard_cover_size = (298, 298)  # Tamanho padrão das capas (FIXO)
        self._last_track_id = None
        self._bio_update_thread = None
        self._stop_bio_update = False
        # Inicializar variáveis do NowCast
        self._nowcast_worker_running = False
        
        # Sistema anti-duplicatas do NowCast
        self._nowcast_last_track_hash = None
        self._nowcast_post_history = []  # Histórico dos últimos 10 posts
        self._nowcast_cooldown_time = 0  # Timestamp do último post
        self._nowcast_min_interval = 30  # Intervalo mínimo entre posts (30 segundos)
        # Iniciar thread de auto-update da bio
        threading.Thread(target=self._bio_update_worker, daemon=True).start()
        self._load_external_commands()
        self._search_cache = {}

    def _load_external_commands(self):
        """Experimental: Tenta carregar o JSON de comandos externos da web, com fallback local."""
        try:
            resp = requests.get(self._external_commands_url, timeout=5)
            if resp.status_code == 200:
                self._external_commands = resp.json()
                return
        except Exception:
            pass
        # Fallback local
        try:
            with open(self._external_commands_local, "r", encoding="utf-8") as f:
                self._external_commands = json.load(f)
        except Exception:
            self._external_commands = None

    def _get_external_command(self, cmd):
        if not self._external_commands:
            self._load_external_commands()
        if self._external_commands and "commands" in self._external_commands:
            return self._external_commands["commands"].get(cmd)
        return None

    def _get_caption_template(self, style, track_data):
        """Retorna o template de caption baseado no estilo selecionado"""
        templates = {
            "Apple Based": "[🎙](5909015791088439934) *{track}*\nby *{artist}* from *{album}*\n[🔗](5256057883082107781)",
            "Pepe": "[🤘](5942984300885446067) *{track}*\nby *{artist}* from *{album}*\n[🎸](5938034540055366532)",
            "Minim": "[🎵](5258289810082111221) *Now Playing*: {track}\n*by* {artist} | {album}",
            "Spoty": "[🎵](5294137402430858861) *{track}*\nfrom *{album}* by *{artist}*"
        }
        
        if style not in templates:
            return ""
            
        template = templates[style]
        
        # Substituir placeholders pelos dados da música
        if track_data:
            template = template.replace("{track}", track_data.get("name", "Unknown Track"))
            template = template.replace("{artist}", track_data.get("artist", "Unknown Artist"))
            template = template.replace("{album}", track_data.get("album", "Unknown Album"))
        
        return template

    def _add_menu_items(self):
        try:
            # Sempre adicionar item "Nowfy" se configurado
            if self.get_setting("show_chat_menu", True):
                self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text=tr("Nowfy"),
                    icon="files_music",
                    priority=5,
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings())
                ))
            
            # Adicionar item "Now Playing" se estiver ativado
            self._update_now_playing_chat_menu_item()
            
            # Inicializar sistema de menu de contexto
            _ensure_message_menu_hooks(self)
            self._update_now_playing_context_menu_item()

        except Exception as e:
            log(f"[exteraFy] Failed to add menu items: {e}")

    def remove_menu_items(self):
        try:
            # Remover item do menu de contexto
            self._remove_now_playing_context_menu_item()
            # Remover item do menu de chat
            if hasattr(self, 'now_playing_chat_menu_id'):
                self.remove_menu_item(self.now_playing_chat_menu_id)
                self.now_playing_chat_menu_id = None
            cleanup_message_menu_hooks(self)
        except Exception as e:
            log(f"[exteraFy] Failed to remove menu items: {e}")

    def _add_now_playing_context_menu_item(self):
        """Adiciona item Now Playing ao menu de contexto"""
        try:
            # Evita duplicatas
            if hasattr(self, 'now_playing_context_menu_id') and self.now_playing_context_menu_id:
                try:
                    self.remove_menu_item(self.now_playing_context_menu_id)
                except Exception:
                    pass
                self.now_playing_context_menu_id = None

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=tr("now_playing_menu_item"),
                icon="msg_round_play_m",
                on_click=lambda ctx: run_on_ui_thread(lambda: self._send_now_playing_card())
            ))
            try:
                self.now_playing_context_menu_id = item_id
            except Exception:
                pass
        except Exception as e:
            log(f"[Nowfy] Failed to add Now Playing context menu item: {e}")

    def _remove_now_playing_context_menu_item(self):
        """Remove item Now Playing do menu de contexto"""
        try:
            if hasattr(self, 'now_playing_context_menu_id') and self.now_playing_context_menu_id:
                try:
                    self.remove_menu_item(self.now_playing_context_menu_id)
                except Exception:
                    pass
                self.now_playing_context_menu_id = None
        except Exception as e:
            log(f"[Nowfy] Failed to remove Now Playing context menu item: {e}")

    def _update_now_playing_context_menu_item(self):
        """Atualiza item Now Playing no menu de contexto baseado na configuração"""
        try:
            if self.get_setting("enable_now_playing", False):
                self._add_now_playing_context_menu_item()
            else:
                self._remove_now_playing_context_menu_item()
        except Exception as e:
            log(f"[Nowfy] Error updating Now Playing context menu item: {e}")
    
    def _update_now_playing_chat_menu_item(self):
        """Atualiza item Now Playing no menu de chat baseado na configuração"""
        try:
            # Remover item existente se houver
            if hasattr(self, 'now_playing_chat_menu_id'):
                self.remove_menu_item(self.now_playing_chat_menu_id)
                self.now_playing_chat_menu_id = None
            
            # Adicionar item se estiver ativado
            if self.get_setting("enable_now_playing", False):
                self.now_playing_chat_menu_id = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text=tr("now_playing_menu_item"),
                    icon="msg_round_play_m",
                    priority=0,  # Prioridade muito baixa para aparecer no topo do menu
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._send_now_playing_card())
                ))
        except Exception as e:
            log(f"[Nowfy] Error updating Now Playing chat menu item: {e}")

    def _is_service_message(self, message):
        """Verifica se é mensagem de serviço"""
        try:
            from org.telegram.tgnet import TLRPC
            return message and hasattr(message, 'messageOwner') and isinstance(message.messageOwner, TLRPC.TL_messageService)
        except Exception:
            return False
    
    def _is_failed_message(self, message):
        """Verifica se é mensagem falhada"""
        try:
            if not message or not hasattr(message, 'messageOwner') or not message.messageOwner:
                return False
            
            message_owner = message.messageOwner
            return (hasattr(message_owner, 'send_state') and message_owner.send_state == 2) or \
                   (hasattr(message_owner, 'id') and message_owner.id < 0)
        except Exception:
            return False

    def _on_now_playing_context_click(self, chat_activity, message):
        """Callback para clique no item Now Playing do menu de contexto"""
        try:
            log(f"[Nowfy] Now Playing clicked in context menu")
            self._send_now_playing_card()
        except Exception as e:
            log(f"[Nowfy] Error in Now Playing context click: {e}")
            BulletinHelper.show_info(f"Error: {e}")

    def _open_plugin_settings(self):
        try:
            log("[exteraFy] Attempting to open plugin settings...")
            controller = PluginsController.getInstance()
            log(f"[exteraFy] Controller instance: {controller}")
            plugin = controller.plugins.get(self.id)
            log(f"[exteraFy] Plugin instance: {plugin}")
            fragment = get_last_fragment()
            log(f"[exteraFy] Fragment instance: {fragment}")
            if plugin and fragment:
                try:
                    # Trigger a background version check so About shows latest status
                    self._check_version_async(False)
                except Exception:
                    pass
                fragment.presentFragment(PluginSettingsActivity(plugin))
                log("[exteraFy] Settings opened successfully")
            else:
                log(f"[exteraFy] Failed to open settings - Plugin: {plugin}, Fragment: {fragment}")
        except Exception as e:
            log(f"[exteraFy] Error opening plugin settings: {str(e)}\nType: {type(e)}")
            import traceback
            log(traceback.format_exc())

    def on_setting_changed(self, key, value):
        if key == "show_chat_menu":
            self.remove_menu_items()
            self._add_menu_items()
        elif key == "enable_now_playing":
            # Atualiza o item do menu de contexto (e chat) quando o switch universal muda
            try:
                self._update_now_playing_context_menu_item()
                self._update_now_playing_chat_menu_item()
            except Exception as e:
                log(f"[Nowfy] Error updating Now Playing menus on setting change: {e}")
        elif key == "nowcast_enabled":
            print(f"[DEBUG] on_setting_changed chamado para nowcast_enabled: {value}")
            if value:
                print("[DEBUG] Ativando NowCast...")
                # Verificar se está configurado corretamente
                if self._verify_nowcast_setup():
                    print("[DEBUG] Configuração verificada com sucesso")
                    # Iniciar worker do NowCast
                    if not self._nowcast_worker_running:
                        import threading
                        print("[DEBUG] Criando thread do NowCast worker...")
                        threading.Thread(target=self._nowcast_worker, daemon=True).start()
                        print("[DEBUG] Thread iniciada")
                        print(f"[NowCast] {NOWCAST_MESSAGES['worker_started']}")
                        
                        # Mostrar bulletin de confirmação
                        print("[DEBUG] Tentando mostrar bulletin de confirmação...")
                        try:
                            BulletinHelper.show_bulletin(
                                NOWCAST_MESSAGES['nowcast_enabled'],
                                NOWCAST_MESSAGES['nowcast_ready']
                            )
                            print("[DEBUG] Bulletin de confirmação enviado com sucesso")
                        except Exception as e:
                            print(f"[DEBUG] Erro ao mostrar bulletin: {e}")
                    else:
                        print("[DEBUG] Worker já está rodando")
                else:
                    print("[DEBUG] Configuração inválida, desativando NowCast")
                    # Desativar se não estiver configurado
                    self.set_setting("nowcast_enabled", False)
                    try:
                        BulletinHelper.show_bulletin(
                            "NowCast",
                            NOWCAST_MESSAGES['nowcast_error']
                        )
                    except Exception as e:
                        print(f"[DEBUG] Erro ao mostrar bulletin de erro: {e}")
            else:
                print("[DEBUG] Desativando NowCast...")
                print(f"[NowCast] {NOWCAST_MESSAGES['worker_stopping']}")
                try:
                    BulletinHelper.show_bulletin(
                        "NowCast",
                        NOWCAST_MESSAGES['nowcast_disabled']
                    )
                    print("[DEBUG] Bulletin de desativação enviado")
                except Exception as e:
                    print(f"[DEBUG] Erro ao mostrar bulletin de desativação: {e}")

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._start_cache_system()
        self._add_menu_items()
        
        # Iniciar NowCast automaticamente se estiver habilitado
        if self.get_setting("nowcast_enabled", False):
            print("[DEBUG] NowCast habilitado detectado no carregamento do plugin")
            if self._verify_nowcast_setup():
                print("[DEBUG] Iniciando NowCast automaticamente...")
                if not self._nowcast_worker_running:
                    import threading
                    threading.Thread(target=self._nowcast_worker, daemon=True).start()
                    print("[NowCast] Worker iniciado automaticamente")
            else:
                print("[DEBUG] Configuração inválida, desabilitando NowCast")
                self.set_setting("nowcast_enabled", False)
        self._capture_original_bio()

    def on_plugin_unload(self):
        self._stop_bio_update = True
        if self._bio_update_thread:
            self._bio_update_thread.join(timeout=1)
        try:
            self.remove_menu_items()
        except:
            pass

    def create_nowcast_info_warning(self):
        return [
            Divider(text=tr("nowcast_info_warning"))
        ]

    def create_nowcast_how_to_use(self):
        return [
            Divider(text=tr("nowcast_how_to_use") if "nowcast_how_to_use" in TRANSLATIONS else "HOW TO USE NOWCAST\n\nATIVAÇÃO:\n• Use o comando .bot para ativar e iniciar o NowCast.\n\nFUNCIONAMENTO:\n• Após alguns segundos, uma notificação (bulletin) aparecerá exibindo a música atual.\n• Em seguida, dentro de mais alguns segundos, o bot realizará o primeiro post no canal configurado.\n\nDESATIVAÇÃO AUTOMÁTICA:\n• Se a música ficar em pausa/inativa por mais de 10 minutos, o NowCast será desativado automaticamente.\n\nCOMPATIBILIDADE:\n• NowCast é exclusivo para Spotify (API).")
        ]

    def create_settings(self):
        show_credentials = self.get_setting("show_credentials", False)
        show_cache_settings = self.get_setting("show_cache_settings", False)
        custom_fonts = self._list_custom_fonts()
        font_selector = self.get_setting("font_selector", 0)
        font_items = [
            "SourceSansPro",
            "exteraCJK",
            "NotoNaskhArabic"
        ]
        if custom_fonts:
            font_items += custom_fonts
        settings = []
        
        # ═══════════════════════════════════════════════════════════════
        # CREDENCIAIS E AUTENTICAÇÃO
        # ═══════════════════════════════════════════════════════════════
        settings.append(Divider(text=tr("credentials_section")))
        


        # Spotify Credentials
        settings.append(
            Text(
                text=tr("spotify_credentials"),
                icon="menu_feature_reliable",
                create_sub_fragment=self.create_spotify_credentials_subfragment
            )
        )
        
        # Last.FM Credentials
        settings.append(
            Text(
                text=tr("lastfm_credentials"),
                icon="msg_permissions_solar",
                create_sub_fragment=self.create_lastfm_credentials_subfragment
            )
        )
        
        # Stats.FM Credentials
        settings.append(
            Text(
                text=tr("statsfm_credentials"),
                icon="menu_username_change",
                create_sub_fragment=self.create_statsfm_credentials_subfragment
            )
        )
        
        # ═══════════════════════════════════════════════════════════════
        # NOWCAST
        # ═══════════════════════════════════════════════════════════════
        settings.append(Divider(text=tr("nowcast_section")))
        
        # NowCast Settings
        settings.append(
            Text(
                text=tr("NowCast"),
                icon="filled_premium_bots",
                create_sub_fragment=self.create_nowcast_subfragment
            )
        )
        
        # ═══════════════════════════════════════════════════════════════
        # TEMAS E CONFIGURAÇÕES
        # ═══════════════════════════════════════════════════════════════
        
        # Temas unificados incluindo LastFM - StatsFM
        external_themes = self._get_external_themes()
        log(f"[NowFy] External themes found: {len(external_themes)}")
        theme_items = ["Apple"]
        # Adicionar temas externos diretamente na lista
        if external_themes:
            for theme_id, theme_data in external_themes.items():
                theme_items.append(theme_data['name'])
                log(f"[NowFy] Added external theme: {theme_data['name']}")
        # Adicionar tema Spotlight
        theme_items.append("Spotlight")
        # Adicionar tema Vinify
        theme_items.append("Vinify")
        # Adicionar novo tema Nowv
        theme_items.append("Nowv")
        # CustomFM sempre como penúltimo
        theme_items.append("CustomFM (Global)")
        # Mantém o tema Minimal sempre por último
        theme_items.append(tr("minimal"))
        log(f"[NowFy] Total theme items: {len(theme_items)}")
        settings.extend([
            Divider(text=tr("theme_selection_section")),
            # Seleção de Tema
            Selector(
                key="theme_selector",
                text=tr("theme_selector"),
                default=0,
                items=theme_items,
                icon="msg_theme",
                on_change=lambda v: self.reload_settings()
            )
        ])
        
        # Apple Skins - aparece logo após o Card Theme se Apple estiver selecionado
        current_theme = self.get_setting("theme_selector", 0)
        if current_theme == 0:  # Tema Apple
            settings.append(self._get_apple_skin_selector())
        
        # Spotlight Skins - aparece quando Spotlight estiver selecionado
        spotlight_index = len(external_themes) + 1  # Apple(0) + external_themes + Spotlight
        if current_theme == spotlight_index:  # Tema Spotlight
            settings.append(self._get_spotlight_skin_selector())
        
        # Calcular o índice do tema Minimal
        external_themes = self._get_external_themes()
        minimal_index = len(theme_items) - 1  # Minimal é sempre o último tema
        
        # Adicionar seletor de fontes apenas se não for o tema Minimal
        if current_theme != minimal_index:
            settings.append(
                Selector(
                    key="font_selector",
                    text=tr("font_selector_label"),
                    default=0,
                    items=font_items,
                    icon="msg_photo_text_framed3",
                )
            )
        
        # Divider anterior - Aparência
        settings.extend([
            Divider(text=tr("appearance_options_section")),
            # Opções de Aparência
        ])

        # Efeito visual ao enviar - AuraSend
        settings.append(
            Switch(
                key="enable_aurasend_on_send",
                text="AuraSend",
                subtext=tr("send_visual_effect_sub"),
                default=False,
                icon="menu_premium_effects",
                on_change=lambda v: self.reload_settings()
            )
        )

        # Novo Divider - Seção de Now Playing
        settings.extend([
            Divider(text=tr("now_playing_section")),
        ])

        # Now Playing - funcionalidade principal
        settings.append(
            Switch(
                key="enable_now_playing",
                text=tr("now_playing_label"),
                subtext=tr("now_playing_sub"),
                default=False,
                icon="msg_round_play_m",
                on_change=lambda v: (
                    self._update_now_playing_context_menu_item(),
                    self._update_now_playing_chat_menu_item(),
                    self.reload_settings()  # força recarregar a exibição do selector
                )
            )
        )

        # Now Card Source - aparece apenas se Now Playing estiver ativado
        if self.get_setting("enable_now_playing", False):
            settings.append(
                Selector(
                    key="now_card_source",
                    text=tr("now_card_source_label"),
                    default=0,
                    items=[
                        "Spotify",
                        "Stats.fm", 
                        "Last.fm",
                        "AyuGram",
                        "exteraGram"
                    ],
                    icon="live_stream",
                    on_change=lambda v: self.reload_settings()
                )
            )

        # ExteraBar - aparece apenas se Apple estiver selecionado
        if current_theme == 0:  # Tema Apple
            settings.append(
                Switch(
                    key="show_extera_bar",
                    text=tr("extera_bar_label"),
                    subtext=tr("extera_bar_sub"),
                    default=True,
                    icon="msg_noise_on",
                    on_change=lambda v: self.reload_settings()
                )
            )

        #  - Seção Extra
        settings.extend([
            Divider(text=tr("extra_section")),
        ])

        # Random Theme Mode
        settings.append(
            Switch(
                key="random_theme_mode",
                text=tr("random_theme_mode"),
                subtext=tr("random_theme_mode_sub"),
                default=False,
                icon="menu_random",
            )
        )

        # Show Caption
        settings.append(
            Switch(
                key="show_caption",
                text=tr("show_caption"),
                default=True,
                icon="msg_chats_add_solar",
                on_change=lambda v: self.reload_settings()
            )
        )

        # Caption Style - aparece apenas se show_caption estiver ativo (True)
        if self.get_setting("show_caption", True):
            caption_style_items = [
                "Custom",
                "Apple Based", 
                "Pepe",
                "Minim",
                "Spoty"
            ]
            
            settings.append(
                Selector(
                    key="caption_style",
                    text=tr("caption_style"),
                    default=0,
                    items=caption_style_items,
                    icon="msg_photo_text_framed3",
                    on_change=lambda v: self.reload_settings()
                )
            )
            
            # Custom Footer Text - aparece apenas se caption_style for "Custom" (índice 0)
            if self.get_setting("caption_style", 0) == 0:
                settings.append(
                    Input(
                        key="custom_footer_text",
                        text=tr("custom_caption"),
                        default="",
                        icon="menu_topic_add",
                    )
                )

        settings.extend([
            Divider(text=tr("customization_section")),
            # Personalização - UI dinâmica baseada no tema selecionado
            *self._get_dynamic_ui_options(theme_items),
            Text(
                text=tr("link_options_header"),
                icon="msg_link2_remix",
                create_sub_fragment=self.create_link_options_subfragment
            ),
            Text(
                text=tr("how_to_use_premium_emoji"),
                accent=True,
                icon="msg_premium_prolfilestar",
                on_click=lambda view: self._show_premium_emoji_help()
            ),
            Divider(text=tr("help_info_section")),
            # Ajuda e Informações
            Text(
                text=tr("about_custom_fonts"),
                icon="msg_info",
                accent=True,
                on_click=lambda v: self._about_custom_fonts_dialog()
            ),
            Divider(),
        ])
        
        # 1. Bio Features (painel expansível) - PRIMEIRA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_smart_bio_panel",
                text=tr("smart_bio_header"),
                subtext=tr("smart_bio_panel_sub"),
                default=False,
                icon="msg_contacts",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_smart_bio_panel", False):
            settings.extend([
                Divider(text=tr("bio_automation_section")),
                
                # Automação da Bio
                Switch(key="enable_autobio", text=tr("smart_bio_enabled"), subtext=tr("autobio_sub"), default=False, icon="gift_upgrade"),
                Switch(key="enable_auto_bio_update", text=tr("smart_bio_auto_refresh"), subtext=tr("enable_auto_bio_update_sub"), default=False, icon="menu_browser_refresh"),
                Switch(key="show_bio_notification", text=tr("show_bio_notification"), subtext=tr("show_bio_notification_sub"), default=True, icon="msg2_notifications"),
                
                Divider(text=tr("bio_customization_section")),
                
                # Personalização da Bio
                Input(key="autobio_text", text=tr("bio_text"), default="Now Playing: {track} by {artist}", icon="msg_addbio"),
                Input(key="restore_bio_text", text=tr("restore_bio_text"), default="I'm using nowFy!", icon="msg_saved"),
                
                Divider(text=tr("bio_help_section")),
                
                # Ajuda e Informações
                Text(
                    text=tr("bio_command_info"),
                    icon="msg2_help",
                    accent=True,
                    on_click=lambda view: self._show_bio_command_info_dialog()
                ),
            ])
        
        # 2. Cache Settings - SEGUNDA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_cache_settings",
                text=tr("show_cache_settings"),
                default=False,
                subtext=tr("show_cache_settings_sub"),
                icon="msg_addfolder",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_cache_settings", False):
            settings.extend([
                # Configurações básicas de cache
                Switch(key="enable_cache", text=tr("enable_cache"), subtext=tr("enable_cache_sub"), default=False, icon="msg_photos_solar", on_change=lambda v: self._toggle_cache_system(v)),
                Switch(key="enable_compression", text=tr("enable_compression"), subtext=tr("enable_compression_sub"), default=False, icon="msg_addphoto_solar"),
                Input(key="cache_ttl", text=tr("cache_ttl"), default="5", icon="menu_clear_cache_remix"),
                
                Divider(text=tr("cache_performance_section")),
                
                # Otimizações de Performance
                Switch(key="enhanced_cache", text=tr("enhanced_cache"), subtext=tr("enhanced_cache_sub"), default=True, icon="msg_speed"),
                Selector(key="performance_mode", text=tr("performance_mode"), default=1, icon="qr_flashlight_remix", items=[
                    tr("turbo_mode") if "turbo_mode" in TRANSLATIONS else "Turbo",
                    tr("balanced_mode") if "balanced_mode" in TRANSLATIONS else "Balanceado",
                    tr("quality_mode") if "quality_mode" in TRANSLATIONS else "Qualidade"
                ]),
                Switch(key="enable_preload", text=tr("enable_preload"), subtext=tr("enable_preload_sub"), default=False, icon="msg_download"), 
                # Advanced Options
                Text(
                    text=tr("advanced_options_title"),
                    icon="msg_customize",
                    create_sub_fragment=self.create_advanced_options_subfragment
                ),
                Divider(text=tr("cache_management_section")),
                # Gerenciamento de cache
                Text(text=tr("clear_cache"), on_click=lambda v: self._clear_cache(), icon="msg_clear_solar", red=True),
            ])
        
        # 3. Miscellaneous - TERCEIRA SEÇÃO
        settings.append(Divider())
        settings.append(
            Switch(
                key="show_diversos",
                text=tr("diversos_header"),
                subtext=tr("diversos_sub"),
                default=False,
                icon="notifications_settings",
                on_change=lambda v: self.reload_settings()
            )
        )
        if self.get_setting("show_diversos", False):
            settings.extend([
                # Configurações de Comando
                Divider(text=tr("command_settings_section")),
                Input(
                    key="custom_command",
                    text=tr("diversos_custom_command"),
                    default=".now",
                    icon="input_bot1"
                ),
                # Configurações de Interface
                Divider(text=tr("interface_settings_section")),
                Switch(
                    key="show_chat_menu",
                    text=tr("diversos_show_chat_menu"),
                    default=True,
                    subtext=tr("show_chat_menu_sub"),
                    icon="preview_dots",
                    on_change=lambda v: self.reload_settings()
                ),

                # Detecção de Música
                Divider(text=tr("music_detection_section")),
                Selector(
                    key="current_player",
                    icon="header_goinline_solar",
                    text=tr("active_player"),
                    default=0,
                    items=["Spotify", "YouTube", "YouTube Music", "exteraGram", "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"],
                    on_change=lambda value: self._on_player_changed(value)
                ),
            ])
            
            # Ícone personalizado já está implementado no CustomFM UI
            
            # Obter configuração do player atual
            current_player_setting = self.get_setting("current_player", 0)
            
            # Mostrar "Modo de Dados" apenas quando Spotify estiver selecionado
            if current_player_setting == 0:  # Spotify
                settings.append(
                    Selector(
                        key="media_source",
                        icon="msg_filled_datausage",
                        text=tr("data_mode"),
                        default=0,
                        items=["Player", "Via Last.FM"]
                    )
                )
            
            settings.extend([
                # APIs e Integração
                Divider(text=tr("apis_integration_section")),
                Selector(
                    key="artwork_priority",
                    icon="msg_saved_ny_remix",
                    text=tr("diversos_artwork_api"),
                    default=0,
                    items=["Default", "Spotify", "Deezer", "Cover Art Archive", "iTunes", "YouTube", "LastFM"]
                ),

                # YouTube API agora usa chave universal integrada
                # Ajuda e Informações
                Divider(text=tr("help_info_section")),
                Text(
                    text=tr("diversos_media_source_info"),
                    icon="msg2_help",
                    accent=True,
                    on_click=lambda view: self._show_integration_info_dialog()
                ),
            ])
        settings.append(Divider())
        # 4. Extras
        settings.append(Divider())
        settings.append(Text(
            text=tr("dotted_credit") if "dotted_credit" in TRANSLATIONS else "Dotted Plugins",
            icon="etg_settings",
            accent=True,
            on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
        ))
        settings.append(Text(
            text="Nowfy",
            icon="msg_reactions",
            accent=True,
            create_sub_fragment=self.create_about_plugin_subfragment
        ))
        return settings

    def create_lastfm_credentials_secure(self):
        return [
            Input(
                key="lastfm_user",
                text="Username",
                icon="menu_username_change",
                default=self.get_setting("lastfm_user", ""),
                subtext=tr("lastfm_user_subtext")
            ),
            Input(
                key="lastfm_api_key",
                text="Last.FM API Key",
                icon="filled_access_fingerprint",
                default=self.get_setting("lastfm_api_key", ""),
                subtext=tr("lastfm_api_key_subtext")
            ),
            Input(
                key="statsfm_username",
                text="Stats.fm Username",
                icon="menu_username_change",
                default=self.get_setting("statsfm_username", ""),
                subtext="Seu username do stats.fm"
            ),            
            Text(
                text=tr("lastfm_title"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_lastfm_api_dialog()
            ),
        ]

    def create_about_plugin_subfragment(self):
        return [
            Divider(text=tr("about_plugin_description")),
            Header(text=tr("about_plugin_header")),
            Text(
                text=tr("about_plugin_donate"),
                icon="msg_reactions",
                accent=True,
                on_click=lambda view: self._open_url("https://livepix.gg/makios")
            ),
            Text(
                text=tr("about_plugin_donate_kofi"),
                icon="msg_reactions",
                accent=True,
                on_click=lambda view: self._open_url("https://ko-fi.com/ageekapple")
            ),
            Text(
                text="TON",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("TON", "UQCy_iox46geMTCNxxZ0G8W0_gg0NXQXz4_A2ho8UtciXvW1"))
            ),
            Text(
                text="TON Telegram",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("TON Telegram", "UQAnV3cohn83QODugckxVP-f9jfjwsBgp6MR_RS4hLDWy1rT"))
            ),
            Text(
                text="BTC",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("BTC", "bc1qkyq4zqy07agmspnuve6gtjlt40ew278l94ljry8fulykec7vhfuqnuh7he"))
            ),
            Text(
                text="Ethereum (ERC20)",
                icon="msg_copy",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("Ethereum", "0xd41a8f8aed90108380688a46b97ad0a15a91598b"))
            )
            ,
            Divider(text=tr("version_status_section")),
            Text(
                text=f"{tr('installed_version_label')}: {__version__}",
                icon="msg_info"
            ),
            Text(
                text=f"{tr('latest_version_label')}: {getattr(self, '_latest_version', None) or tr('version_status_unknown')}",
                icon="menu_factcheck"
            ),
            Text(
                text=(tr("update_available_text").format(version=getattr(self, "_latest_version", "")) if getattr(self, "_version_is_outdated", False) and getattr(self, "_latest_version", None) else tr("version_status_up_to_date")),
                icon=("msg_other_new_outline" if getattr(self, "_version_is_outdated", False) else "msg_rate_up_remix"),
                accent=True,
                on_click=lambda view: self._open_url(getattr(self, "_version_update_url", "https://github.com/soumaki/nowFy")) if getattr(self, "_version_is_outdated", False) else None
            ),
            Text(
                text=tr("check_version_now"),
                icon="msg_retry",
                accent=True,
                on_click=lambda view: self._check_version_async(True)
            )
        ]

    def _open_lastfm_settings(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                # Teste: abrir um AlertDialog
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title("LastFM Settings")
                builder.set_message("Aqui será a interface de configurações do LastFM.")
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir LastFM Settings: {e}")

    def _copy_to_clipboard(self, label, text):
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
        clip = ClipData.newPlainText(label, text)
        clipboard.setPrimaryClip(clip)
        BulletinHelper.show_info(tr("copied_to_clipboard").format(label=label) if "copied_to_clipboard" in TRANSLATIONS else f"Copied {label} to clipboard")

    def _should_show_error_bulletin(self, error_type):
        """Verifica se deve mostrar o bulletin de erro para evitar spam"""
        import time
        current_time = time.time()
        
        # Inicializar controle de erro se não existir
        if not hasattr(self, '_error_display_control'):
            self._error_display_control = {}
        
        # Verificar se já foi mostrado recentemente (últimos 30 segundos)
        last_shown = self._error_display_control.get(error_type, 0)
        if current_time - last_shown < 30:  # 30 segundos de cooldown
            return False
        
        # Atualizar timestamp
        self._error_display_control[error_type] = current_time
        return True

    def _show_credentials_error_bulletin(self, error_type, error_log, missing_fields):
        """Mostra bulletin detalhado para erros de credenciais com botão de copiar logs"""
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
                
            # Definir mensagens baseadas no tipo de erro
            error_messages = {
                "missing_credentials": {
                    "title": tr("credentials_missing_title"),
                    "message": tr("credentials_missing_message").format(fields=', '.join(missing_fields))
                },
                "invalid_credentials": {
                    "title": tr("credentials_invalid_title"),
                    "message": tr("credentials_invalid_message").format(fields=', '.join(missing_fields))
                },
                "invalid_refresh_token": {
                    "title": tr("refresh_token_invalid_title"),
                    "message": tr("refresh_token_invalid_message")
                },
                "api_error": {
                    "title": tr("api_error_title"),
                    "message": tr("api_error_message")
                },
                "connection_error": {
                    "title": tr("connection_error_title"),
                    "message": tr("connection_error_message")
                }
            }
            
            error_info = error_messages.get(error_type, {
                "title": tr("error_auth"),
                "message": tr("error_auth")
            })
            
            # Criar log detalhado para copiar
            detailed_log = f"""=== SPOTIFY AUTHENTICATION ERROR ===
Error Type: {error_type}
Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Missing/Invalid Fields: {', '.join(missing_fields) if missing_fields else 'None'}

Detailed Log:
{error_log}

=== END ERROR LOG ==="""
            
            def on_copy_log():
                # Usar get_last_fragment() para compatibilidade
                fragment = get_last_fragment()
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copiar para clipboard usando context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("log", detailed_log)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (
                    BulletinHelper.show_success(tr("copied_bulletin") if "copied_bulletin" in TRANSLATIONS else "Log copiado!", fragment)
                ))
            
            # Mostrar bulletin com botão de copiar (similar ao .list)
            error_icon = getattr(R.raw, "error", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                error_info["message"],
                error_icon,
                tr("copy_button") if "copy_button" in TRANSLATIONS else "Copiar Log",
                on_copy_log,
                fragment
            ))
            
        except Exception as e:
            log(f"[Nowfy] Error showing credentials error bulletin: {e}")
            # Fallback para bulletin simples - só mostrar se não foi mostrado recentemente
            if self._should_show_error_bulletin("fallback_error"):
                BulletinHelper.show_info(tr("error_auth"))

     # --- AUTENTICAÇÃO SPOTIFY ---
    def _get_masked_setting(self, key):
        value = self.get_setting(key, "")
        if value and isinstance(value, str) and len(value) > 8:
            return value[:4] + "****" + value[-4:]
        elif value:
            return "****"
        return ""

    def _get_access_token(self, show_error_bulletin=False):
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        refresh_token = self.get_setting("refresh_token", "")
        log(f"[Nowfy] Credentials check - Client ID: {bool(client_id)}, Client Secret: {bool(client_secret)}, Refresh Token: {bool(refresh_token)}")
        
        # Verificar credenciais ausentes
        if not client_id or not client_secret or not refresh_token:
            missing_creds = []
            if not client_id: missing_creds.append("Client ID")
            if not client_secret: missing_creds.append("Client Secret")
            if not refresh_token: missing_creds.append("Refresh Token")
            
            error_log = f"[Nowfy] Missing credentials: {', '.join(missing_creds)}"
            log(error_log)
            # Só mostrar bulletin se explicitamente solicitado (comando .now)
            if show_error_bulletin and self._should_show_error_bulletin("missing_credentials"):
                self._show_credentials_error_bulletin("missing_credentials", error_log, missing_creds)
            return None
            
        try:
            auth = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
            resp = requests.post(
                "https://accounts.spotify.com/api/token",
                data={"grant_type": "refresh_token", "refresh_token": refresh_token},
                headers={"Authorization": f"Basic {auth}"},
                timeout=5
            )
            log(f"[Nowfy] Token request response - Status: {resp.status_code}")
            
            if resp.status_code == 400:
                # Erro de credenciais inválidas
                try:
                    error_data = resp.json()
                    error_description = error_data.get("error_description", "Invalid credentials")
                    error_log = f"[Nowfy] Invalid credentials - Status: {resp.status_code}, Error: {error_description}"
                    log(error_log)
                    if show_error_bulletin and self._should_show_error_bulletin("invalid_credentials"):
                        self._show_credentials_error_bulletin("invalid_credentials", error_log, ["Client ID", "Client Secret"])
                except:
                    error_log = f"[Nowfy] Invalid credentials - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                    log(error_log)
                    if show_error_bulletin and self._should_show_error_bulletin("invalid_credentials"):
                        self._show_credentials_error_bulletin("invalid_credentials", error_log, ["Client ID", "Client Secret"])
                return None
            elif resp.status_code == 401:
                # Token de refresh inválido
                error_log = f"[Nowfy] Invalid refresh token - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                log(error_log)
                if show_error_bulletin and self._should_show_error_bulletin("invalid_refresh_token"):
                    self._show_credentials_error_bulletin("invalid_refresh_token", error_log, ["Refresh Token"])
                return None
            elif resp.status_code != 200:
                # Outros erros de API
                error_log = f"[Nowfy] API error - Status: {resp.status_code}, Response: {resp.text if hasattr(resp, 'text') else 'No response text'}"
                log(error_log)
                if show_error_bulletin and self._should_show_error_bulletin("api_error"):
                    self._show_credentials_error_bulletin("api_error", error_log, [])
                return None
                
            data = resp.json()
            access_token = data.get("access_token")
            log(f"[Nowfy] Access token obtained successfully: {bool(access_token)}")
            return access_token
        except Exception as e:
            error_log = f"[Nowfy] Exception getting access token: {str(e)}"
            log(error_log)
            if show_error_bulletin and self._should_show_error_bulletin("connection_error"):
                self._show_credentials_error_bulletin("connection_error", error_log, [])
            return None

    def _exchange_code(self, code):
        log(f"[NowFy] Iniciando _exchange_code com código: {code[:10]}...")
        
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        
        log(f"[NowFy] Client ID: {client_id[:10] if client_id else 'VAZIO'}...")
        log(f"[NowFy] Client Secret: {client_secret[:10] if client_secret else 'VAZIO'}...")
        
        if not client_id or not client_secret:
            log("[NowFy] Credenciais faltando!")
            return False, "Missing Client ID or Client Secret"
            
        try:
            auth = base64.b64encode(f"{client_id}:{client_secret}".encode()).decode()
            log(f"[NowFy] Auth header criado: {auth[:20]}...")
            
            payload = {
                "grant_type": "authorization_code", 
                "code": code, 
                "redirect_uri": "https://example.com/callback"
            }
            log(f"[NowFy] Payload: {payload}")
            
            resp = requests.post(
                "https://accounts.spotify.com/api/token",
                data=payload,
                headers={"Authorization": f"Basic {auth}"},
                timeout=10
            )
            
            log(f"[NowFy] Status da resposta: {resp.status_code}")
            log(f"[NowFy] Resposta completa: {resp.text}")
            
            if resp.status_code != 200:
                error_msg = f"Spotify API Error {resp.status_code}"
                try:
                    error_data = resp.json()
                    if "error_description" in error_data:
                        error_msg = error_data["error_description"]
                    elif "error" in error_data:
                        error_msg = error_data["error"]
                except:
                    pass
                log(f"[NowFy] ERRO na API do Spotify: {resp.status_code} - {resp.text}")
                return False, error_msg
                
            data = resp.json()
            log(f"[NowFy] Dados recebidos: {list(data.keys())}")
            
            if "refresh_token" in data:
                refresh_token = data["refresh_token"]
                self.set_setting("refresh_token", refresh_token)
                log(f"[NowFy] Refresh token salvo: {refresh_token[:10]}...")
                
                if "access_token" in data:
                    self.set_setting("access_token", data["access_token"])
                    self.set_setting("token_expiry", str(int(time.time()) + data.get("expires_in", 3600)))
                    log(f"[NowFy] Access token também salvo")
                
                log(f"[NowFy] SUCESSO! Token obtido")
                return True, None
            else:
                error_msg = f"No refresh_token in response: {list(data.keys())}"
                log(f"[NowFy] Resposta sem refresh_token: {data}")
                return False, error_msg
                
        except Exception as e:
            error_msg = f"Exception: {str(e)}"
            log(f"[NowFy] EXCEÇÃO ao trocar código: {str(e)}")
            import traceback
            log(f"[NowFy] Traceback: {traceback.format_exc()}")
            return False, error_msg
    # --- EXPERIMENTAL ---  


    def _validate_credentials(self):
        return self._get_access_token() is not None

    def _get_spotify_user_profile(self):
        """Obtém informações do perfil do usuário usando a API oficial do Spotify."""
        try:
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Usar o endpoint /me para obter o perfil do usuário atual
            resp = requests.get(
                "https://api.spotify.com/v1/me",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                
                # Extrair informações do perfil
                profile_info = {
                    "display_name": data.get("display_name", ""),
                    "id": data.get("id", ""),
                    "followers": data.get("followers", {}).get("total", 0),
                    "country": data.get("country", ""),
                    "product": data.get("product", ""),  # free, premium, etc.
                    "images": data.get("images", [])
                }
                
                # Obter a melhor imagem de perfil disponível
                if profile_info["images"]:
                    # Ordenar por tamanho (maior primeiro) e pegar a primeira
                    sorted_images = sorted(
                        profile_info["images"], 
                        key=lambda x: x.get("width", 0) * x.get("height", 0), 
                        reverse=True
                    )
                    profile_info["profile_image_url"] = sorted_images[0].get("url", "")
                else:
                    profile_info["profile_image_url"] = ""
                
                return profile_info
            
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting Spotify user profile: {str(e)}")
            return None

    def create_link_options_subfragment(self):
        # Detectar se FM está ativo
        current_player_setting = self.get_setting("current_player", 0)
        is_fm_player = current_player_setting == 7

        # Calcular visibilidade para duplicar "Player" em Apple, Spotlight e Vinify
        external_themes = self._get_external_themes() or {}
        current_theme = self.get_setting("theme_selector", 0)
        spotlight_index = len(external_themes) + 1
        vinify_index = spotlight_index + 1
        nowv_index = vinify_index + 1
        show_player_duplicate = is_fm_player and (current_theme in [0, spotlight_index, vinify_index, nowv_index])

        options = [
            # Platform Links Selector
            Selector(
                key="platform_links",
                text=tr("platform_links"),
                default=0,  # Spotify como padrão
                items=[
                    tr("platform_links_spotify"),
                    tr("platform_links_universal"),
                    tr("platform_links_both")
                ],
                icon="msg_link",
                on_change=lambda value: self.show_universal_link_dialog() if value == 1 else None
            ),
            Switch(
                key="show_track_link",
                text=tr("show_track_link"),
                subtext=tr("show_track_link_sub"),
                default=True,
                icon="filled_link_remix"
            ),
            # Seção FM Links
            Divider(text=tr("fm_links_section")),
            Selector(
                key="fm_link_option",
                icon="menu_username_change",
                text=tr("fm_link_selector"),
                default=0,
                items=["None", "LastFM", "StatsFM", "Custom Link"]
            )
        ]

        # Input Custom Link (URL) abaixo de FM Link, visível apenas com FM ativo
        if is_fm_player:
            options.append(Input(
                key="fm_custom_link_url",
                text=tr("fm_custom_link_url") if "fm_custom_link_url" in TRANSLATIONS else "Custom Link (URL)",
                icon="msg_link2_remix",
                default=self.get_setting("fm_custom_link_url", ""),
                subtext=tr("fm_custom_link_url_sub") if "fm_custom_link_url_sub" in TRANSLATIONS else "Paste here the custom link for FM"
            ))

        # Duplicar input "Player" quando FM ativo e tema Apple/Vinify/Spotlight
        if show_player_duplicate:
            options.append(Input(
                key="fm_custom_player_name",
                text=tr("customfm_custom_player_name") if "customfm_custom_player_name" in TRANSLATIONS else "Player",
                icon="msg_photo_text_framed3",
                default=self.get_setting("fm_custom_player_name", "Custom Player"),
                subtext=tr("customfm_custom_player_name_sub") if "customfm_custom_player_name_sub" in TRANSLATIONS else "Custom player name for FM"
            ))

        return options

    def create_advanced_options_subfragment(self):
        return [
            Divider(text=tr("thumbnail_cache_section")),  
            # Cache de Thumbnails
            Switch(
                key="enable_youtube_thumbnail_cache",
                text=tr("youtube_cache"),
                subtext=tr("youtube_cache_sub"),
                default=False,
                icon="msg_data"
            ),
            Switch(
                key="enable_soundcloud_thumbnail_cache",
                text=tr("soundcloud_cache"),
                subtext=tr("soundcloud_cache_sub"),
                default=False,
                icon="msg_data"
            ),
            
            Divider(text=tr("quality_options_section")),
            # Opções de Qualidade
            Switch(
                key="enable_quality_fallback",
                text=tr("quality_fallback"),
                subtext=tr("quality_fallback_sub"),
                default=True,
                icon="msg_retry"
            ),
            Switch(
                key="enable_url_cache",
                text=tr("url_cache"),
                subtext=tr("url_cache_sub"),
                default=True,
                icon="msg_link"
            ),
            Switch(
                key="enable_adaptive_compression",
                text=tr("adaptive_compression"),
                subtext=tr("adaptive_compression_sub"),
                default=False,
                icon="msg_premium_speed"
            )
        ]

    def create_spotify_credentials_subfragment(self):
        show_auth = self.get_setting("show_spotify_auth", True)
        items = [
            Divider(text=tr("spotify_auth_section")),
            Switch(
                key="show_spotify_auth",
                text=tr("spotify_auth_toggle") if "spotify_auth_toggle" in TRANSLATIONS else "Spotify Auth",
                subtext=tr("spotify_auth_toggle_sub") if "spotify_auth_toggle_sub" in TRANSLATIONS else "Expandir para configurar credenciais do Spotify",
                default=show_auth,
                icon="msg_filled_unlockedrecord",
                on_change=lambda v: self.reload_settings()
            )
        ]
        if show_auth:
            # Credenciais de Autenticação
            items.extend([
                Input(
                    key="client_id",
                    text=tr("client_id"),
                    default=self.get_setting("client_id", ""),
                    icon="trusted_mini",
                    subtext=tr("client_id_subtext")
                ),
                Input(
                    key="client_secret",
                    text=tr("client_secret"),
                    default=self.get_setting("client_secret", ""),
                    icon="trusted_mini",
                    subtext=tr("client_secret_subtext")
                ),
                Input(
                    key="refresh_token",
                    text=tr("refresh_token"),
                    default=self.get_setting("refresh_token", ""),
                    icon="trusted_mini",
                    subtext=tr("refresh_token_subtext")
                ),
            ])
        else:
            items.append(Text(text=tr("spotify_auth_hidden_notice"), icon="msg_info"))

        items.extend([
            Divider(text=tr("spotify_help_section")),
            # Ajuda e Informações
            Text(
                text=tr("credentials_info"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_credentials_info_dialog()
            ),
            Text(
                text=tr("spotify_control"),
                icon="live_stream",
                accent=True,
                on_click=lambda view: self._show_spotify_control_dialog()
            ),
        ])
        return items

    def create_lastfm_credentials_subfragment(self):
        visible = self.get_setting("lastfm_api_key_visible", True)
        items = [
            Divider(text=tr("lastfm_auth_section")),          
            # Credenciais Last.FM
            Input(
                key="lastfm_username",
                text=tr("lastfm_username"),
                icon="menu_username_change",
                default=self.get_setting("lastfm_username", ""),
                subtext=tr("lastfm_user_subtext")
            ),
            Switch(
                key="lastfm_api_key_visible",
                text=tr("lastfm_key_visibility"),
                subtext=tr("lastfm_key_visibility_sub"),
                default=self.get_setting("lastfm_api_key_visible", True),
                icon="msg_permissions_solar"
            ),
        ]
        if visible:
            items.append(
                Input(
                    key="lastfm_api_key",
                    text=tr("lastfm_api_key"),
                    icon="filled_access_fingerprint",
                    default=self.get_setting("lastfm_api_key", ""),
                    subtext=tr("lastfm_api_key_subtext")
                )
            )
        items += [
            Divider(text=tr("lastfm_help_section")),        
            # Ajuda e Testes
            Text(
                text=tr("test_lastfm_account"),
                icon="msg_limit_accounts",
                accent=True,
                on_click=lambda view: self._test_lastfm_account()
            ),
            Text(
                text=tr("lastfm_title"),
                icon="msg2_help",
                accent=True,
                on_click=lambda view: self._show_lastfm_api_dialog()
            ),
        ]
        return items

    def create_statsfm_credentials_subfragment(self):
        return [
            Input(
                key="statsfm_username",
                text=tr("statsfm_username"),
                icon="menu_username_change",
                default=self.get_setting("statsfm_username", ""),
                subtext=tr("statsfm_username_sub")
            ),
        ]
    
    # Atualiza traduções para o bloco "How to Use" do NowCast
    TRANSLATIONS.update({
        "nowcast_how_to_use_title": {
            "pt": "Como usar o NowCast",
            "en": "How to Use NowCast",
            "es": "Cómo usar NowCast",
            "fr": "Comment utiliser NowCast",
            "ru": "Как использовать NowCast"
        },
        "nowcast_how_to_use": {
            "pt": "COMO USAR O NOWCAST\n\nATIVAÇÃO:\n• Use o comando .bot para ativar e iniciar o NowCast.\n\nFUNCIONAMENTO:\n• Após alguns segundos, uma notificação (bulletin) aparecerá exibindo a música atual.\n• Em seguida, dentro de mais alguns segundos, o bot realizará o primeiro post no canal configurado.\n\nDESATIVAÇÃO AUTOMÁTICA:\n• Se a música ficar em pausa/inativa por mais de 10 minutos, o NowCast será desativado automaticamente.\n\nCOMPATIBILIDADE:\n• NowCast é exclusivo para Spotify (API).",
            "en": "HOW TO USE NOWCAST\n\nACTIVATION:\n• Use the .bot command to activate and start NowCast.\n\nOPERATION:\n• After a few seconds, a bulletin notification will appear showing the current song.\n• Then, within a few more seconds, the bot will make the first post in the configured channel.\n\nAUTO DISABLE:\n• If music is paused/inactive for more than 10 minutes, NowCast will automatically disable.\n\nCOMPATIBILITY:\n• NowCast is exclusive to Spotify (API).",
            "es": "CÓMO USAR NOWCAST\n\nACTIVACIÓN:\n• Usa el comando .bot para activar e iniciar NowCast.\n\nFUNCIONAMIENTO:\n• Tras unos segundos, aparecerá una notificación (bulletin) mostrando la canción actual.\n• Luego, en unos segundos más, el bot realizará la primera publicación en el canal configurado.\n\nDESACTIVACIÓN AUTOMÁTICA:\n• Si la música está en pausa/inactiva por más de 10 minutos, NowCast se desactivará automáticamente.\n\nCOMPATIBILIDAD:\n• NowCast es exclusivo para Spotify (API).",
            "fr": "COMMENT UTILISER NOWCAST\n\nACTIVATION:\n• Utilisez la commande .bot pour activer et démarrer NowCast.\n\nFONCTIONNEMENT:\n• Après quelques secondes, une notification (bulletin) apparaîtra affichant la chanson en cours.\n• Ensuite, en quelques secondes, le bot effectuera la première publication dans le canal configuré.\n\nDÉSACTIVATION AUTOMATIQUE:\n• Si la musique est en pause/inactive pendant plus de 10 minutes, NowCast sera désactivé automatiquement.\n\nCOMPATIBILITÉ:\n• NowCast est exclusif à Spotify (API).",
            "ru": "КАК ИСПОЛЬЗОВАТЬ NOWCAST\n\nАКТИВАЦИЯ:\n• Используйте команду .bot, чтобы активировать и запустить NowCast.\n\nРАБОТА:\n• Через несколько секунд появится уведомление (bulletin), показывающее текущую песню.\n• Затем, ещё через несколько секунд, бот выполнит первую публикацию в настроенном канале.\n\nАВТООТКЛЮЧЕНИЕ:\n• Если музыка поставлена на паузу/неактивна более 10 минут, NowCast будет автоматически отключён.\n\nСОВМЕСТИМОСТЬ:\n• NowCast работает только со Spotify (API)."
        }
    })

    def create_nowcast_subfragment(self):
        """Cria o subfragment para configurações do NowCast"""
        return [
            Switch(
                key="nowcast_enabled",
                text=tr("nowcast_enable"),
                subtext=tr("nowcast_enable_sub"),
                icon="input_bot1",
                default=False
            ),
            Input(
                key="nowcast_bot_token",
                text=tr("nowcast_bot_token"),
                icon="menu_bots_add",
                default=""
            ),
            Input(
                key="nowcast_channel_id",
                text=tr("nowcast_channel_id"),
                icon="msg_channel",
                default="",
                subtext="Ex: -1001234567890"
            ),
            Input(
                key="bot_caption_text",
                text=tr("bot_caption"),
                default="",
                icon="msg_photo_text_framed3",
                subtext=tr("bot_caption_sub")
            ),
            Selector(
                key="nowcast_link_option",
                text=tr("nowcast_link_option"),
                icon="filled_link_remix",
                default=0,
                items=[tr("nowcast_link_none"), tr("nowcast_link_spotify"), tr("nowcast_link_songlink")]
            ),
            Divider(),
            Text(
                text=tr("test_nowcast_connection") if "test_nowcast_connection" in TRANSLATIONS else "Test NowCast Connection",
                icon="msg_send_remix",
                accent=True,
                on_click=lambda view: self._test_nowcast_connection()
            ),
            Text(
                text=tr("clear_nowcast_history") if "clear_nowcast_history" in TRANSLATIONS else "Clear NowCast History",
                icon="menu_clear_recent",
                red=True,
                on_click=lambda view: self._clear_nowcast_history()
            ),
            Text(
                text=tr("nowcast_info_warning_title") if "nowcast_info_warning_title" in TRANSLATIONS else "Important Information About NowCast",
                icon="filled_premium_bots",
                create_sub_fragment=self.create_nowcast_info_warning
            ),
            Text(
                text=tr("nowcast_how_to_use_title") if "nowcast_how_to_use_title" in TRANSLATIONS else "How to Use NowCast",
                icon="msg_info_remix",
                create_sub_fragment=self.create_nowcast_how_to_use
            )
        ]

    # ===== NOWCAST FUNCTIONS =====
    def _send_nowcast_card(self):
        """Envia card do NowCast adaptado ao tema selecionado"""
        print("[NowCast DEBUG] Iniciando envio de card...")
        if not self.get_setting("nowcast_enabled", False):
            print("[NowCast DEBUG] NowCast não está habilitado")
            return False
            
        token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        print(f"[NowCast DEBUG] Credenciais bot: token={bool(token)}, channel_id={bool(channel_id)}")
        
        if not token or not channel_id:
            print("[NowCast] Token ou Channel ID não configurado")
            return False
            
        try:
            # Tentar obter música do Stats.fm primeiro (se configurado)
            statsfm_username = self.get_setting("statsfm_username", "")
            track_data = None
            data_source = "spotify"  # padrão
            
            if statsfm_username:
                print("[NowCast DEBUG] Tentando Stats.fm...")
                track_data = self._get_statsfm_current_track(statsfm_username)
                if track_data:
                    data_source = "statsfm"
                    print(f"[NowCast DEBUG] Música obtida via Stats.fm: {track_data.get('title', '')} - {track_data.get('artist', '')}")
                    
                    # Adaptar dados do Stats.fm para formato compatível
                    track = {
                        'name': track_data.get('title', ''),
                        'artists': [{'name': artist.strip()} for artist in track_data.get('artist', '').split(',')],
                        'album': {
                            'name': track_data.get('album', ''),
                            'images': [{'url': track_data.get('image_url', '')}] if track_data.get('image_url') else []
                        },
                        'duration_ms': track_data.get('duration_ms', 0)
                    }
                    progress_ms = track_data.get('progress_ms', 0)
                    is_playing = True
            
            # Se não conseguiu do Stats.fm, usar Spotify (comportamento original)
            if not track_data:
                print("[NowCast DEBUG] Usando Spotify (padrão)...")
                # Verificar credenciais do Spotify
                client_id = self.get_setting("client_id", "")
                client_secret = self.get_setting("client_secret", "")
                refresh_token = self.get_setting("refresh_token", "")
                print(f"[NowCast DEBUG] Credenciais Spotify: {bool(client_id and client_secret and refresh_token)}")
                
                if not (client_id and client_secret and refresh_token):
                    print("[NowCast] Credenciais do Spotify incompletas")
                    return False
                
                # Obter token de acesso
                print("[NowCast DEBUG] Obtendo token de acesso...")
                access_token = self._get_access_token(show_error_bulletin=False)
                print(f"[NowCast DEBUG] Token obtido: {bool(access_token)}")
                if not access_token:
                    print("[NowCast] Erro ao obter token de acesso")
                    return False
                
                # Obter música atual do Spotify
                print("[NowCast DEBUG] Consultando API do Spotify...")
                import requests
                resp = requests.get(
                    "https://api.spotify.com/v1/me/player/currently-playing",
                    headers={"Authorization": f"Bearer {access_token}"},
                    timeout=5
                )
                print(f"[NowCast DEBUG] Resposta Spotify: {resp.status_code}, tem conteúdo: {bool(resp.content)}")
                
                if resp.status_code != 200 or not resp.content:
                    print("[NowCast] Nenhuma música tocando")
                    return False
                
                data = resp.json()
                track = data.get("item")
                progress_ms = data.get("progress_ms", 0)
                is_playing = data.get('is_playing')
                print(f"[NowCast DEBUG] Track: {bool(track)}, is_playing: {is_playing}, progress_ms: {progress_ms}")
                
                if not track or not track.get("name") or not is_playing:
                    print("[NowCast] Música não está tocando")
                    return False
            
            # Preparar dados da música com links para o seletor
            track_title = track.get('name', '')
            track_artists = ', '.join([artist.get('name', '') for artist in track.get('artists', [])])
            spotify_url = track.get('external_urls', {}).get('spotify', '')
            song_link_url = ''
            
            # Gerar song.link se houver URL do Spotify
            if spotify_url:
                song_link_url = self._get_song_link(spotify_url)
            
            # Armazenar dados da música atual para o seletor de links
            self._current_nowcast_track = {
                'title': track_title,
                'artist': track_artists,
                'album': track.get('album', {}).get('name', ''),
                'spotify_url': spotify_url,
                'song_link_url': song_link_url
            }
            print(f"[NowCast DEBUG] Dados armazenados - Spotify: {bool(spotify_url)}, song.link: {bool(song_link_url)}")
            
            # SISTEMA ANTI-DUPLICATAS: Verificar se já foi postado
            if self._is_duplicate_post(self._current_nowcast_track):
                print("[NowCast DEBUG] Post duplicado detectado - cancelando envio")
                return False
            
            print("[NowCast DEBUG] Verificação anti-duplicatas passou - prosseguindo")
            
            # Detectar tema selecionado
            theme = self.get_setting("theme_selector", 0)
            external_themes = self._get_external_themes()
            # CORREÇÃO: Usar a mesma lógica de cálculo da função _generate_card
            # Apple = 0, Temas externos = 1 até len(external_themes)
            # Spotlight = 1 + len(external_themes)
            # Vinify = 2 + len(external_themes) 
            # CustomFM = 3 + len(external_themes)
            # Minimal = 4 + len(external_themes)
            spotlight_index = 1 + len(external_themes)
            vinni_index = 2 + len(external_themes)
            nowv_index = 3 + len(external_themes)
            customfm_index = 4 + len(external_themes)
            minimal_index = 5 + len(external_themes)
            
            print(f"[NowCast DEBUG] Tema selecionado: {theme}, Spotlight index: {spotlight_index}, Vinify index: {vinni_index}, Nowv index: {nowv_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}")
            
            # Verificar se é tema Minimal
            if theme == minimal_index:
                print("[NowCast DEBUG] Tema Minimal detectado - usando função existente")
                return self._send_nowcast_minimal_via_existing_function(track, token, channel_id)
            
            # Para CustomFM e outros temas, gerar card visual
            print("[NowCast DEBUG] Gerando card visual...")
            image_path = self._generate_nowcast_visual_card(track, token, channel_id, progress_ms)
            
            if image_path:
                print(f"[NowCast DEBUG] Card gerado: {image_path}")
                # Enviar imagem via bot
                success = self._send_nowcast_image_via_bot(image_path, "")
                if success:
                    print("[NowCast DEBUG] Card enviado com sucesso")
                    # Atualizar histórico anti-duplicatas
                    self._update_post_history(self._current_nowcast_track)
                    print("[NowCast DEBUG] Histórico anti-duplicatas atualizado")
                    return True
                else:
                    print("[NowCast DEBUG] Falha ao enviar card")
                    return False
            else:
                print("[NowCast DEBUG] Falha ao gerar card")
                return False
                
        except Exception as e:
            print(f"[NowCast] Erro ao enviar card: {e}")
            return False
    
    def _send_nowcast_minimal_via_existing_function(self, track, bot_token, channel_id):
        """Envia texto do tema Minimal usando a função existente _generate_minimal_card"""
        try:
            import requests
            from java.util import ArrayList
            
            # Criar parâmetros simulados para capturar a mensagem
            class MockParams:
                def __init__(self):
                    self.message = None
                    self.entities = ArrayList()
                    self.peer = type('obj', (object,), {'id': int(channel_id)})()
                    
            mock_params = MockParams()
            
            # Salvar configurações originais para o modo NowCast
            self._nowcast_bot_token = bot_token
            self._nowcast_channel_id = channel_id
            self._nowcast_mode = True
            
            # Usar a função existente do tema Minimal
            self._generate_minimal_card(track, mock_params)
            
            # Limpar configurações temporárias
            self._nowcast_mode = False
            
            # Verificar se a mensagem foi gerada
            if not mock_params.message:
                print("[NowCast] Mensagem não foi gerada pela função Minimal")
                return False
            
            # Enviar via bot API
            url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
            data = {
                'chat_id': channel_id,
                'text': mock_params.message,
                'parse_mode': 'MarkdownV2',
                'disable_web_page_preview': False
            }
            
            response = requests.post(url, data=data, timeout=30)
            
            if response.status_code == 200:
                print("[NowCast] Texto Minimal enviado com sucesso")
                try:
                    run_on_ui_thread(self._trigger_send_ripple)
                except Exception:
                    pass
                # Atualizar histórico anti-duplicatas
                self._update_post_history(self._current_nowcast_track)
                print("[NowCast DEBUG] Histórico anti-duplicatas atualizado (Minimal)")
                return True
            else:
                print(f"[NowCast] Erro ao enviar texto: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            print(f"[NowCast] Erro ao enviar texto Minimal: {e}")
            return False
    
    def _generate_nowcast_visual_card(self, track_data, bot_token, channel_id, progress_ms=0):
        """Gera card visual do NowCast usando a mesma lógica dos comandos .now/.fm"""
        try:
            # Detectar tema selecionado
            theme = self.get_setting("theme_selector", 0)
            external_themes = self._get_external_themes()
            # CORREÇÃO: Usar a mesma lógica de cálculo da função _generate_card
            # Apple = 0, Temas externos = 1 até len(external_themes)
            # Spotlight = 1 + len(external_themes)
            # Vinify = 2 + len(external_themes) 
            # CustomFM = 3 + len(external_themes)
            # Minimal = 4 + len(external_themes)
            spotlight_index = 1 + len(external_themes)
            vinni_index = 2 + len(external_themes)
            nowv_index = 3 + len(external_themes)
            customfm_index = 4 + len(external_themes)
            minimal_index = 5 + len(external_themes)
            
            print(f"[NowCast DEBUG] Tema detectado: {theme}, Spotlight index: {spotlight_index}, Vinify index: {vinni_index}, Nowv index: {nowv_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}")
            
            # Criar parâmetros simulados
            from java.util import ArrayList
            
            class MockParams:
                def __init__(self, channel_id):
                    self.message = ".now"
                    self.entities = ArrayList()
                    self.peer = type('obj', (object,), {'id': int(channel_id)})()
                    
            mock_params = MockParams(channel_id)
            
            # Salvar configurações originais para o modo NowCast
            self._nowcast_bot_token = bot_token
            self._nowcast_channel_id = channel_id
            self._nowcast_mode = True
            
            # Se for tema CustomFM, usar função específica
            if theme == customfm_index:
                print("[NowCast DEBUG] Usando função CustomFM específica")
                title = track_data["name"]
                artists = ", ".join([a["name"] for a in track_data["artists"]])
                album = track_data.get("album", {}).get("name", "")
                image_url = None
                if track_data.get("album", {}).get("images"):
                    image_url = track_data["album"]["images"][0]["url"]
                
                # Chamar função CustomFM diretamente
                image_path = self._get_current_track_lastfm_customfm(
                    title, artists, album, image_url, mock_params,
                    progress_dialog=None, player="Spotify", 
                    youtube_url=track_data["external_urls"]["spotify"]
                )
            else:
                # Para outros temas, usar função padrão
                print(f"[NowCast DEBUG] Usando função padrão para tema {theme}")
                image_path = self._generate_card(track_data, mock_params, progress_ms)
            
            # Limpar configurações temporárias
            self._nowcast_mode = False
            if hasattr(self, '_nowcast_caption'):
                delattr(self, '_nowcast_caption')
            
            return image_path
            
        except Exception as e:
            print(f"[NowCast] Erro ao gerar card visual: {e}")
            return None
    
    def _send_nowcast_image_via_bot(self, image_path, caption):
        """Envia imagem via API do bot para o NowCast"""
        try:
            import requests
            
            bot_token = getattr(self, '_nowcast_bot_token', None)
            channel_id = getattr(self, '_nowcast_channel_id', None)
            
            if not bot_token or not channel_id:
                print("[NowCast] Token ou Channel ID não configurados")
                return False
            
            # Usar caption do CustomFM se disponível, senão usar bot_caption
            customfm_caption = getattr(self, '_nowcast_caption', None)
            if customfm_caption:
                caption = customfm_caption
                print(f"[NowCast DEBUG] Usando caption do CustomFM: {caption}")
            else:
                # Usar bot_caption se não houver caption do CustomFM
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar placeholders {track}, {artist} e {album} no bot_caption
                    track_data = getattr(self, '_current_nowcast_track', None)
                    if track_data and ("{track}" in bot_caption or "{artist}" in bot_caption or "{album}" in bot_caption):
                        processed_caption = bot_caption.replace("{track}", track_data.get('title', 'Unknown Track'))
                        processed_caption = processed_caption.replace("{artist}", track_data.get('artist', 'Unknown Artist'))
                        processed_caption = processed_caption.replace("{album}", track_data.get('album', 'Unknown Album'))
                        caption = processed_caption
                    else:
                        caption = bot_caption
                    print(f"[NowCast DEBUG] Usando bot caption: {caption}")
                else:
                    print(f"[NowCast DEBUG] Usando caption padrão: {caption}")
            
            # Processar seletor de links do NowCast
            nowcast_link_option = self.get_setting("nowcast_link_option", 0)
            if nowcast_link_option > 0:  # Se não for "None"
                # Obter dados da música atual
                track_data = getattr(self, '_current_nowcast_track', None)
                if track_data:
                    link_text = ""
                    if nowcast_link_option == 1:  # Spotify
                        spotify_url = track_data.get('spotify_url', '')
                        if spotify_url:
                            link_text = f"[{tr('nowcast_link_spotify')}]({spotify_url})"
                    elif nowcast_link_option == 2:  # song.link
                        song_link_url = track_data.get('song_link_url', '')
                        if song_link_url:
                            link_text = f"[{tr('nowcast_link_platforms')}]({song_link_url})"
                        elif track_data.get('spotify_url', ''):  # Fallback para Spotify se song.link não disponível
                            link_text = f"[{tr('nowcast_link_spotify')}]({track_data.get('spotify_url', '')})"
                    
                    if link_text:
                        caption = (caption or "") + link_text
                        print(f"[NowCast DEBUG] Link adicionado à legenda: {link_text.strip()}")
            
            url = f"https://api.telegram.org/bot{bot_token}/sendPhoto"
            
            with open(image_path, 'rb') as photo:
                files = {'photo': photo}
                data = {
                    'chat_id': channel_id,
                    'caption': caption,
                    'parse_mode': 'Markdown'
                }
                
                response = requests.post(url, files=files, data=data, timeout=30)
                
                if response.status_code == 200:
                    print("[NowCast] Card visual enviado com sucesso")
                    try:
                        run_on_ui_thread(self._trigger_send_ripple)
                    except Exception:
                        pass
                    return True
                else:
                    print(f"[NowCast] Erro ao enviar: {response.status_code} - {response.text}")
                    return False
                    
        except Exception as e:
            print(f"[NowCast] Erro ao enviar via bot: {e}")
            return False
    
    def _get_statsfm_current_track(self, username):
        """Obtém dados da música atual do Stats.fm"""
        try:
            import requests
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }
            
            resp = requests.get(url, headers=headers, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                item = data.get("item")
                if item and item.get("isPlaying"):
                    track_info = item.get("track", {})
                    artists = [artist.get("name", "") for artist in track_info.get("artists", [])]
                    album = track_info.get("albums", [{}])[0]
                    
                    return {
                        'title': track_info.get("name", ""),
                        'artist': ", ".join(artists),
                        'album': album.get("name", ""),
                        'image_url': album.get("image", ""),
                        'duration_ms': track_info.get("durationMs", 0),
                        'progress_ms': item.get("progressMs", 0)
                    }
            return None
        except Exception as e:
            log(f"[NowCast] Stats.fm error: {str(e)}")
            return None
    
    def _get_lastfm_current_track(self, username, api_key):
        """Obtém dados da música atual do Last.fm"""
        try:
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params = {
                'method': 'user.getrecenttracks',
                'user': username,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            resp = requests.get(url, params=params, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                tracks = data.get('recenttracks', {}).get('track', [])
                if tracks and isinstance(tracks, list) and len(tracks) > 0:
                    track = tracks[0]
                    # Sempre considerar a música mais recente como "tocando agora"
                    # Last.fm pode não incluir @attr.nowplaying quando está scrobblando
                    # Vamos assumir que a música mais recente está tocando
                    if True:
                        artist = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                        album = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                        images = track.get('image', [])
                        image_url = ''
                        if images:
                            # Prefer the largest available Last.fm image
                            size_priority = ['mega', 'extralarge', 'large']
                            size_map = {img.get('size'): img.get('#text', '') for img in images if img.get('#text')}
                            for s in size_priority:
                                if size_map.get(s):
                                    image_url = size_map[s]
                                    break
                            if not image_url:
                                # Fallback to last non-empty image URL
                                for img in reversed(images):
                                    if img.get('#text'):
                                        image_url = img.get('#text', '')
                                        break
                        
                        return {
                            'title': track.get('name', ''),
                            'artist': artist,
                            'album': album,
                            'image_url': image_url,
                            'duration_ms': 0,
                            'progress_ms': 0
                        }
            return None
        except Exception as e:
            log(f"[NowCast] Last.fm error: {str(e)}")
            return None
    
    def _get_current_track_for_nowcast(self):
        """Obtém dados da música atual para o NowCast"""
        try:
            # Tentar Stats.fm primeiro
            statsfm_username = self.get_setting("statsfm_username", "")
            if statsfm_username:
                track_data = self._get_statsfm_current_track(statsfm_username)
                if track_data:
                    track_data['source'] = 'statsfm'
                    return track_data
            
            # Tentar Last.fm
            lastfm_username = self.get_setting("lastfm_user", "")
            lastfm_api_key = self.get_setting("lastfm_api_key", "")
            if lastfm_username and lastfm_api_key:
                track_data = self._get_lastfm_current_track(lastfm_username, lastfm_api_key)
                if track_data:
                    track_data['source'] = 'lastfm'
                    return track_data
            
            # Tentar Spotify
            client_id = self.get_setting("client_id", "")
            client_secret = self.get_setting("client_secret", "")
            refresh_token = self.get_setting("refresh_token", "")
            
            if client_id and client_secret and refresh_token:
                token = self._get_access_token(show_error_bulletin=False)
                if token:
                    import requests
                    resp = requests.get(
                        "https://api.spotify.com/v1/me/player/currently-playing",
                        headers={"Authorization": f"Bearer {token}"},
                        timeout=5
                    )
                    
                    if resp.status_code == 200 and resp.content:
                        data = resp.json()
                        track = data.get("item")
                        if track and track.get("name") and track.get("artists") and data.get('is_playing'):
                            artists = [a['name'] for a in track['artists']]
                            album = track.get('album', {})
                            images = album.get('images', [])
                            image_url = images[0]['url'] if images else ''
                            
                            track_data = {
                                'title': track['name'],
                                'artist': ', '.join(artists),
                                'album': album.get('name', ''),
                                'image_url': image_url,
                                'duration_ms': track.get('duration_ms', 0),
                                'progress_ms': data.get('progress_ms', 0),
                                'source': 'spotify'
                            }
                            return track_data
            
            return None
            
        except Exception as e:
            print(f"[NowCast] Erro ao obter música atual: {e}")
            return None
        
    def _send_nowcast_test_message(self, message_text):
        """Envia mensagem de teste via bot do Telegram para o NowCast"""
        if not self.get_setting("nowcast_enabled", False):
            print("[NowCast] NowCast não está habilitado")
            return False
            
        token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        
        if not token or not channel_id:
            print("[NowCast] Token ou Channel ID ausente")
            return False
            
        try:
            print("[NowCast] Iniciando teste de conexão...")
            
            url = f"https://api.telegram.org/bot{token}/sendMessage"
            
            payload = {
                "chat_id": channel_id,
                "text": message_text,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            
            print("[NowCast] Enviando requisição para API do Telegram...")
            print(f"[NowCast] URL: {url}")
            print(f"[NowCast] Payload: chat_id={channel_id}, text_length={len(message_text)}")
            
            import time
            start_time = time.time()
            
            # Aumentar timeout para evitar travamentos
            response = requests.post(url, data=payload, timeout=15)
            
            elapsed_time = time.time() - start_time
            print(f"[NowCast] Tempo de resposta: {elapsed_time:.2f}s")
            print(f"[NowCast] Status da resposta: {response.status_code}")
            
            if response.status_code == 200:
                data = response.json()
                if data.get("ok"):
                    print("[NowCast] Mensagem de teste enviada com sucesso")
                    return True
                else:
                    print(f"[NowCast] Erro na API: {data}")
                    return False
            else:
                print(f"[NowCast] Erro HTTP: {response.status_code}")
                return False
                
        except requests.exceptions.Timeout as e:
            print(f"[NowCast] Timeout na conexão com a API do Telegram: {e}")
            return False
        except requests.exceptions.ConnectionError as e:
            print(f"[NowCast] Erro de conexão com a API do Telegram: {e}")
            return False
        except ImportError as e:
            print(f"[NowCast] Erro ao importar requests: {e}")
            return False
        except Exception as e:
            print(f"[NowCast] Erro inesperado: {e}")
            import traceback
            print(f"[NowCast] Traceback: {traceback.format_exc()[:300]}")
            return False
    
    def _test_nowcast_connection(self):
        """Testa a conexão do NowCast"""
        print("[NowCast] Iniciando teste de conexão...")
        
        # Parar temporariamente o worker para evitar conflitos
        worker_was_running = getattr(self, '_nowcast_worker_running', False)
        if worker_was_running:
            print("[NowCast] Parando worker temporariamente para teste...")
            self._nowcast_worker_running = False
            time.sleep(1)  # Aguardar worker parar
        
        try:
            test_message = "NowCast - Powered by Nowfy"
            result = self._send_nowcast_test_message(test_message)
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker...")
                self._nowcast_worker_running = True
            
            return result
            
        except Exception as e:
            print(f"[NowCast] Erro no teste de conexão: {e}")
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker após erro...")
                self._nowcast_worker_running = True
            
            return False
    
    def _has_any_credentials(self):
        """Verifica se há credenciais configuradas - APENAS Spotify e StatsFM"""
        statsfm_username = self.get_setting("statsfm_username", "")
        client_id = self.get_setting("client_id", "")
        client_secret = self.get_setting("client_secret", "")
        refresh_token = self.get_setting("refresh_token", "")
        
        return (statsfm_username or 
                (client_id and client_secret and refresh_token))
    
    def _verify_nowcast_setup(self):
        """Verifica se o NowCast está configurado corretamente"""
        print("[DEBUG] _verify_nowcast_setup iniciado")
        
        # Verificar credenciais
        has_credentials = self._has_any_credentials()
        print(f"[DEBUG] _has_any_credentials retornou: {has_credentials}")
        print(f"[NowCast] Credenciais configuradas: {has_credentials}")
        if not has_credentials:
            print("[DEBUG] Credenciais não encontradas, retornando False")
            return False
        
        # Verificar configurações do bot
        bot_token = self.get_setting("nowcast_bot_token", "")
        channel_id = self.get_setting("nowcast_channel_id", "")
        print(f"[DEBUG] Bot token obtido: {bool(bot_token)} (length: {len(bot_token) if bot_token else 0})")
        print(f"[DEBUG] Channel ID obtido: '{channel_id}'")
        print(f"[NowCast] Bot token configurado: {bool(bot_token)}")
        print(f"[NowCast] Channel ID configurado: {bool(channel_id)}")
        
        result = bool(bot_token and channel_id)
        print(f"[DEBUG] _verify_nowcast_setup retornando: {result}")
        return result
    
    def _handle_bot_command(self, params):
        """Manipula o comando .bot - ativa NowCast e faz check imediato"""
        try:
            print("[NowCast] Comando .bot executado")
            
            # Verificar se está configurado corretamente
            if not self._verify_nowcast_setup():
                self._send_msg(params, tr('nowcast_not_configured'))
                return
            
            # Ativar o NowCast
            self.set_setting("nowcast_enabled", True)
            print("[NowCast] Switch ativado via comando .bot")
            
            # Fazer check imediato
            current_track = self._get_current_track_info()
            if current_track:
                print(f"[NowCast] Música detectada: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                
                # Verificar se não é duplicata antes de enviar card
                import hashlib
                track_data = f"{current_track.get('id', '')}-{current_track.get('name', '')}-{current_track.get('artist', '')}"
                current_track_hash = hashlib.sha256(track_data.encode('utf-8')).hexdigest()[:16]
                
                # Verificar se já foi postada recentemente usando o sistema anti-duplicatas
                if not self._is_duplicate_post(current_track):
                    try:
                        self._send_nowcast_card()
                        # Atualizar histórico anti-duplicatas
                        self._update_post_history(current_track)
                        self._send_msg(params, f"{tr('nowcast_activated_card_sent')}\n🎵 {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                        print("[NowCast] Card enviado via comando .bot")
                    except Exception as send_error:
                        print(f"[NowCast] Erro ao enviar card via .bot: {send_error}")
                        self._send_msg(params, f"{tr('nowcast_activated_card_error')}: {send_error}")
                else:
                    self._send_msg(params, f"{tr('nowcast_activated_duplicate')}\n🎵 {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                    print("[NowCast] Card não enviado via .bot - música duplicada detectada")
            else:
                self._send_msg(params, tr('nowcast_activated_waiting'))
                print("[NowCast] Ativado via .bot, mas nenhuma música detectada")
            
            # Iniciar worker se não estiver rodando
            if not self._nowcast_worker_running:
                print("[NowCast] Iniciando worker via comando .bot")
                threading.Thread(target=self._nowcast_worker, daemon=True).start()
            else:
                print("[NowCast] Worker já está rodando")
                
        except Exception as e:
            print(f"[NowCast] Erro no comando .bot: {e}")
            self._send_msg(params, f"{tr('nowcast_bot_command_error')}: {e}")
    
    def _check_music_playing(self):
        """Verifica se há música tocando - APENAS Spotify API e StatsFM"""
        print("[NowCast DEBUG] Iniciando verificação de música...")
        try:
            # Verificar Stats.fm
            statsfm_username = self.get_setting("statsfm_username", "")
            print(f"[NowCast DEBUG] Stats.fm username: {bool(statsfm_username)}")
            if statsfm_username:
                response = requests.get(f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current", timeout=10)
                print(f"[NowCast DEBUG] Stats.fm response: {response.status_code}")
                if response.status_code == 200:
                    data = response.json()
                    if data.get("item"):
                        print("[NowCast DEBUG] Música detectada no Stats.fm")
                        return True
            
            # Verificar Spotify API
            access_token = self._get_access_token(show_error_bulletin=False)
            print(f"[NowCast DEBUG] Spotify access token: {bool(access_token)}")
            if access_token:
                headers = {"Authorization": f"Bearer {access_token}"}
                response = requests.get("https://api.spotify.com/v1/me/player/currently-playing", headers=headers, timeout=10)
                print(f"[NowCast DEBUG] Spotify response: {response.status_code}, has content: {bool(response.text)}")
                if response.status_code == 200 and response.text:
                    data = response.json()
                    is_playing = data.get("is_playing")
                    print(f"[NowCast DEBUG] Spotify is_playing: {is_playing}")
                    if is_playing:
                        print("[NowCast DEBUG] Música detectada no Spotify")
                        return True
            
            print("[NowCast DEBUG] Nenhuma música detectada")
            return False
        except Exception as e:
            print(f"[NowCast DEBUG] Erro na verificação: {e}")
            print(f"[NowCast] {NOWCAST_MESSAGES['error_check_music'].format(e)}")
            return False
    
    def _get_current_track_info(self):
        """Obtém informações da música atual - APENAS Spotify API e StatsFM"""
        try:
            # Verificar Stats.fm primeiro
            statsfm_username = self.get_setting("statsfm_username", "")
            if statsfm_username:
                response = requests.get(f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current", timeout=10)
                if response.status_code == 200:
                    data = response.json()
                    item = data.get("item")
                    if item:
                        track = item.get("track", {})
                        artist_name = track.get("artists", [{}])[0].get("name", "") if track.get("artists") else ""
                        track_id = track.get("id", "")
                        return {
                            "id": track_id,
                            "name": track.get('name', ''),
                            "artist": artist_name,
                            "source": "statsfm",
                            "unique_key": f"statsfm_{track_id}_{track.get('name', '')}_{artist_name}"
                        }
            
            # Verificar Spotify API
            access_token = self._get_access_token(show_error_bulletin=False)
            if access_token:
                headers = {"Authorization": f"Bearer {access_token}"}
                response = requests.get("https://api.spotify.com/v1/me/player/currently-playing", headers=headers, timeout=10)
                if response.status_code == 200 and response.text:
                    data = response.json()
                    if data.get("is_playing"):
                        item = data.get("item", {})
                        artists = ", ".join([artist.get("name", "") for artist in item.get("artists", [])])
                        track_id = item.get("id", "")
                        return {
                            "id": track_id,
                            "name": item.get('name', ''),
                            "artist": artists,
                            "source": "spotify",
                            "unique_key": f"spotify_{track_id}_{item.get('name', '')}_{artists}"
                        }
            
            return None
        except Exception as e:
            print(f"[NowCast] Erro ao obter info da música: {e}")
            return None
    
    def _nowcast_worker(self):
        """Worker thread robusto para o NowCast - Sistema anti-falhas com auto-desligamento"""
        # Verificar se já existe um worker rodando
        if hasattr(self, '_nowcast_worker_running') and self._nowcast_worker_running:
            print("[NowCast] ⚠️ Worker já está rodando - ignorando nova instância")
            return
        
        # Marcar worker como ativo
        self._nowcast_worker_running = True
        
        try:
            # Usar variáveis de instância para permitir limpeza via _clear_nowcast_history
            if not hasattr(self, '_nowcast_last_track_hash'):
                self._nowcast_last_track_hash = None
            if not hasattr(self, '_nowcast_post_history'):
                self._nowcast_post_history = []
            if not hasattr(self, '_nowcast_cooldown_time'):
                self._nowcast_cooldown_time = 0
            consecutive_errors = 0
            last_successful_check = time.time()
            last_activity_time = time.time()  # Para controle de inatividade
            last_cache_clear = time.time()  # Para limpeza preventiva de cache
            posting_lock = False  # Lock para evitar posts simultâneos
            min_post_interval = 60  # Aumentado para 60 segundos
            inactivity_timeout = 600  # 10 minutos em segundos
            cache_clear_interval = 3600  # 1 hora em segundos
            print("[NowCast] 🎵 Worker iniciado - Sistema robusto ativo com auto-desligamento!")
            
            while self.get_setting("nowcast_enabled", False):
                cycle_start = time.time()
                try:
                    print(f"[NowCast DEBUG] Ciclo iniciado - Erros consecutivos: {consecutive_errors}")
                    
                    # Verificar credenciais
                    if not self._has_any_credentials():
                        print("[NowCast] ⚠️ Nenhuma credencial configurada, aguardando...")
                        time.sleep(30)
                        continue
                    
                    # Obter música atual com timeout
                    print("[NowCast DEBUG] Obtendo informações da música atual...")
                    current_track = None
                    try:
                        current_track = self._get_current_track_info()
                        print(f"[NowCast DEBUG] Música atual: {current_track or 'Nenhuma'}")
                    except Exception as track_error:
                        print(f"[NowCast] ⚠️ Erro ao obter música: {track_error}")
                        current_track = None
                    
                    current_time = time.time()
                    
                    if current_track:
                        last_successful_check = current_time
                        last_activity_time = current_time  # Atualizar tempo de atividade
                        
                        # Criar hash SHA-256 único e robusto da música atual
                        import hashlib
                        track_data = f"{current_track.get('id', '')}-{current_track.get('name', '')}-{current_track.get('artist', '')}-{current_track.get('source', '')}"
                        current_track_hash = hashlib.sha256(track_data.encode('utf-8')).hexdigest()[:16]  # Usar apenas 16 caracteres
                        
                        # Verificar se é uma música diferente usando o sistema anti-duplicatas
                        should_post = not self._is_duplicate_post(current_track)
                        if should_post:
                            print(f"[NowCast] 🎵 Nova música detectada: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                            print(f"[NowCast DEBUG] Hash: {current_track_hash} (novo)")
                        else:
                            print(f"[NowCast DEBUG] Música já postada ou muito próxima: {current_track.get('name', 'N/A')} - {current_track.get('artist', 'N/A')}")
                            print(f"[NowCast DEBUG] Hash: {current_track_hash} (duplicata detectada)")
                        
                        # Postar apenas se for uma música nova e não houver lock
                        if should_post and not posting_lock:
                            posting_lock = True  # Ativar lock
                            print(f"[NowCast] 📤 Enviando card para nova música...")
                            try:
                                self._send_nowcast_card()
                                # Atualizar histórico usando o sistema centralizado
                                self._update_post_history(current_track)
                                consecutive_errors = 0  # Reset contador de erros
                                print(f"[NowCast] Card enviado com sucesso às {time.strftime('%H:%M:%S')}")
                                print(f"[NowCast DEBUG] Hash {current_track_hash} adicionado ao histórico ({len(self._nowcast_post_history)} total)")
                            except Exception as send_error:
                                print(f"[NowCast] Erro ao enviar card: {send_error}")
                                consecutive_errors += 1
                            finally:
                                posting_lock = False  # Liberar lock
                        elif should_post and posting_lock:
                            print("[NowCast DEBUG] Post bloqueado - já há um envio em andamento")
                    
                    else:
                        # Sem música tocando - verificar inatividade
                        time_inactive = current_time - last_activity_time
                        
                        if self._nowcast_last_track_hash:
                            print("[NowCast] ⏹️ Música parou - Resetando estado")
                            self._nowcast_last_track_hash = None
                            self._nowcast_cooldown_time = 0
                        
                        # Auto-desligamento após 10 minutos de inatividade
                        if time_inactive >= inactivity_timeout:
                            print(f"[NowCast] 🔄 Auto-desligamento: {time_inactive:.0f}s sem atividade (limite: {inactivity_timeout}s)")
                            self.set_setting("nowcast_enabled", False)
                            try:
                                BulletinHelper.show_bulletin(
                                    "NowCast Auto-Desligado",
                                    tr('nowcast_auto_disabled')
                                )
                            except:
                                pass
                            break
                        
                        # Verificar se há muito tempo sem música (possível problema)
                        time_without_music = current_time - last_successful_check
                        if time_without_music > 300:  # 5 minutos sem música
                            print(f"[NowCast] ⚠️ Sem música há {time_without_music:.0f}s - Verificando conexões...")
                            last_successful_check = current_time  # Reset para evitar spam
                        
                        # Mostrar contagem regressiva para auto-desligamento
                        remaining_inactivity = inactivity_timeout - time_inactive
                        if remaining_inactivity <= 300:  # Últimos 5 minutos
                            print(f"[NowCast DEBUG] Auto-desligamento em {remaining_inactivity:.0f}s por inatividade")
                    
                    # Limpeza preventiva de cache a cada hora
                    time_since_cache_clear = current_time - last_cache_clear
                    if time_since_cache_clear >= cache_clear_interval:
                        print("[NowCast] 🧹 Limpeza preventiva de cache (1 hora de funcionamento)")
                        try:
                            self._clear_cache()
                            last_cache_clear = current_time
                            print("[NowCast] Cache limpo preventivamente")
                        except Exception as cache_error:
                            print(f"[NowCast] Erro na limpeza preventiva: {cache_error}")
                    
                    # Reset contador de erros em ciclo bem-sucedido
                    if current_track:  # Só resetar se detectou música
                        consecutive_errors = 0
                    
                    # Aguardar antes do próximo ciclo (aumentado para evitar posts múltiplos)
                    sleep_time = min(45 + (consecutive_errors * 15), 90)  # Min 45s, Max 90s
                    print(f"[NowCast DEBUG] Ciclo concluído em {time.time() - cycle_start:.1f}s - Aguardando {sleep_time}s")
                    time.sleep(sleep_time)
                
                except Exception as e:
                    consecutive_errors += 1
                    error_msg = f"[NowCast] Erro no worker (#{consecutive_errors}): {e}"
                    print(error_msg)
                    
                    # Aguardar mais tempo em caso de erros consecutivos
                    error_sleep = min(30 + (consecutive_errors * 15), 120)  # Max 2 minutos
                    print(f"[NowCast] Recuperando em {error_sleep}s...")
                    time.sleep(error_sleep)
                    
                    # Se muitos erros consecutivos, tentar reset completo com limpeza de cache
                    if consecutive_errors >= 5:
                        print("[NowCast] Muitos erros - Resetando estado completo e limpando cache...")
                        
                        # Limpeza automática de cache para resolver problemas de funcionamento
                        try:
                            self._clear_cache()
                            print("[NowCast] Cache limpo automaticamente para resolver problemas")
                        except Exception as cache_error:
                            print(f"[NowCast] Erro ao limpar cache: {cache_error}")
                        
                        last_track_posted = None
                        last_post_time = 0
                        consecutive_errors = 0
                        last_successful_check = time.time()
                        last_activity_time = time.time()
                        last_cache_clear = time.time()
                        posting_lock = False  # Reset do lock também
        
        finally:
            # Resetar flag do worker
            self._nowcast_worker_running = False
            print("[NowCast] Worker finalizado - NowCast desabilitado")

    


    def _get_song_link(self, spotify_url):
        """Gera song.link URL para o track do Spotify"""
        try:
            # song.link API para gerar link universal
            song_link_url = f"https://song.link/s/{spotify_url.split('/')[-1]}"
            return song_link_url
        except Exception as e:
            log(f"[exteraFy] Error generating song.link: {e}")
            return spotify_url
    
    def _generate_track_hash(self, track_data):
        """Gera hash único para identificar uma música"""
        try:
            if not track_data:
                return None
            
            # Criar string única baseada nos dados da música
            track_string = f"{track_data.get('title', '')}-{track_data.get('artist', '')}-{track_data.get('album', '')}"
            
            # Gerar hash MD5
            import hashlib
            return hashlib.md5(track_string.encode('utf-8')).hexdigest()
        except Exception as e:
            return None
    
    def _is_duplicate_post(self, track_data):
        """Verifica se a música já foi postada recentemente"""
        try:
            import time
            
            current_time = time.time()
            
            # Verificar intervalo mínimo entre posts
            if current_time - self._nowcast_cooldown_time < self._nowcast_min_interval:
                return True
            
            # Gerar hash da música atual
            current_hash = self._generate_track_hash(track_data)
            if not current_hash:
                return False
            
            # Verificar se é a mesma música do último post
            if current_hash == self._nowcast_last_track_hash:
                return True
            
            # Verificar histórico dos últimos posts
            if current_hash in self._nowcast_post_history:
                return True
            
            return False
        except Exception as e:
            return False
    
    def _update_post_history(self, track_data):
        """Atualiza o histórico de posts"""
        try:
            import time
            
            current_hash = self._generate_track_hash(track_data)
            if not current_hash:
                return
            
            # Atualizar último hash
            self._nowcast_last_track_hash = current_hash
            
            # Adicionar ao histórico
            self._nowcast_post_history.append(current_hash)
            
            # Manter apenas os últimos 10 posts no histórico
            if len(self._nowcast_post_history) > 10:
                self._nowcast_post_history.pop(0)
            
            # Atualizar timestamp do último post
            self._nowcast_cooldown_time = time.time()
        except Exception as e:
            pass

    # --- AUTOBIO ---
    def _capture_original_bio(self):
        """Captura a bio original do usuário na primeira execução"""
        try:
            # Verificar se já foi registrado
            if self.get_setting("original_bio_captured", False):
                return
            
            user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
            if user_full and user_full.about:
                # Capturar a bio original (experimental)
                self.set_setting("original_bio", user_full.about)
                self.set_setting("original_bio_captured", True)
                # Definir automaticamente o restore_bio_text com a bio original se estiver vazio
                current_restore_text = self.get_setting("restore_bio_text", "").strip()
                if not current_restore_text:
                    self.set_setting("restore_bio_text", user_full.about)
                    log(f"[NowFy] Auto-set restore_bio_text to original bio: {user_full.about}")
                
                log(f"[NowFy] Original bio captured: {user_full.about}")
        except Exception as e:
            log(f"[NowFy] Error capturing original bio: {e}")

    def _update_bio(self, text, show_bulletin=False, is_restore=False):
        try:
            user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
            max_len = 140 if get_user_config().isPremium() else 70
            # Sempre atualizar a bio (remover cache do etg)
            req = TL_account.updateProfile()
            req.flags = 4
            req.about = text[:max_len]
            send_request(req, ())
            # Só mostrar bulletin se show_bulletin=True ou se for auto-refresh com notificação ativada
            if show_bulletin:
                BulletinHelper.show_info(tr("bio_restored"))
            elif self.get_setting("show_bio_notification", True) and self.get_setting("enable_auto_bio_update", True):
                # Para auto-refresh, mostrar mensagem específica baseada no contexto
                if is_restore:
                    # Não mostrar notificação para restauração automática (sem música)
                    pass
                else:
                    # Mostrar notificação apenas quando há música tocando
                    BulletinHelper.show_info(tr("bio_updated_short"))
        except Exception as e:
            log(f"[exteraFy] Error updating bio: {e}")
            if show_bulletin or self.get_setting("show_bio_notification", True):
                BulletinHelper.show_with_button(tr("bio_error"), R.raw.error, "OK", None)

    # --- CACHE ---
    def _start_cache_system(self):
        self._cache_enabled = self.get_setting("enable_cache", True)
        if self._cache_enabled and not self._cache_running:
            self._cache_running = True
            self._cache_thread = threading.Thread(target=self._cache_worker, daemon=True)
            self._cache_thread.start()
        else:
            self._cache_running = False

    def _toggle_cache_system(self, enabled):
        self._cache_enabled = enabled
        if enabled:
            self._start_cache_system()
        else:
            self._cache_running = False
            with self._cache_lock:
                self._image_cache.clear()

    def _cache_worker(self):
        while self._cache_running:
            try:
                if not self._cache_enabled:
                    time.sleep(2)
                    continue
                # Ajustar intervalo baseado no modo de performance
                performance_mode = self.get_setting("performance_mode", 1)
                sleep_interval = 2 if performance_mode == 0 else (3 if performance_mode == 1 else 4)
                
                token = self._get_access_token(show_error_bulletin=False)
                if not token:
                    time.sleep(5)
                    continue
                # Usar timeout baseado no modo de performance
                timeout = 3 if performance_mode == 0 else (5 if performance_mode == 1 else 7)
                
                resp = requests.get(
                    "https://api.spotify.com/v1/me/player/currently-playing",
                    headers={"Authorization": f"Bearer {token}"},
                    timeout=timeout
                )
                if resp.status_code == 200 and resp.content:
                    data = resp.json()
                    track = data.get("item")
                    if track:
                        track_id = track["id"]
                        if track_id != self._last_track_id:
                            self._last_track_id = track_id
                            # Atualizar ID da faixa atual para o sistema de pré-carregamento
                            self._update_current_track_id(track_id)
                            self._pre_render_current_track(track)
                            
                            # Pré-carregar próxima faixa se habilitado
                            if self.get_setting("enable_preload", False):
                                self._preload_next_track_cover()
                            
                            # Limpar cache antigo
                            self._cleanup_preload_cache()
                
                time.sleep(sleep_interval)
            except Exception:
                time.sleep(5)

    def _pre_render_current_track(self, track):
        # Gera card baseado no tema selecionado
        self._generate_card(track, is_fm_command=False)

    def _bio_update_worker(self):
        """Worker para atualizar/restaurar a bio automaticamente"""
        log("[exteraFy] Bio update worker started")
        self._last_no_track_time = None
        self._restore_done = False
        while not self._stop_bio_update:
            try:
                if self.get_setting("enable_auto_bio_update", False):
                    log("[exteraFy] Auto bio update is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[exteraFy] Failed to get userFull")
                        time.sleep(5)
                        continue
                    max_len = 140 if get_user_config().isPremium() else 70
                    token = self._get_access_token(show_error_bulletin=False)
                    if not token:
                        log("[exteraFy] No access token available")
                        time.sleep(5)
                        continue
                    log("[exteraFy] Fetching current track for bio update")
                    resp = requests.get(
                        "https://api.spotify.com/v1/me/player/currently-playing",
                        headers={"Authorization": f"Bearer {token}"},
                        timeout=5
                    )
                    if resp.status_code == 200 and resp.content:
                        data = resp.json()
                        track = data.get("item")
                        if track:
                            log(f"[exteraFy] Found track for bio update: {track['name']}")
                            # Atualizar ID da faixa atual para o sistema de pré-carregamento
                            self._update_current_track_id(track.get('id'))
                            autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                            bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                            if userFull.about != bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = bio[:max_len]
                                    send_request(req, ())
                                    log("[exteraFy] Successfully updated bio automatically")
                                except Exception as e:
                                    log(f"[exteraFy] Error updating bio automatically: {e}")
                                    time.sleep(5)
                            self._last_no_track_time = None
                            self._restore_done = False
                        else:
                            log("[exteraFy] No track playing for bio update")
                            if self._last_no_track_time is None:
                                self._last_no_track_time = time.time()
                                self._restore_done = False
                            elif not self._restore_done and time.time() - self._last_no_track_time >= 600:
                                # Capturar bio atual do perfil em vez de usar bio antiga
                                try:
                                    current_bio = userFull.about if userFull else ""
                                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                    
                                    if current_bio and current_bio.strip():
                                        default_bio = current_bio
                                    elif restore_bio_text:
                                        default_bio = restore_bio_text
                                    else:
                                        default_bio = "I'm using nowFy!"
                                except:
                                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                    if restore_bio_text:
                                        default_bio = restore_bio_text
                                    else:
                                        default_bio = "I'm using nowFy!"
                                if userFull.about != default_bio[:max_len]:
                                    try:
                                        req = TL_account.updateProfile()
                                        req.flags = 4
                                        req.about = default_bio[:max_len]
                                        send_request(req, ())
                                        log("[exteraFy] Restored bio after inactivity")
                                        # Não mostrar bulletin aqui, pois é auto-refresh (restauração)
                                    except Exception as e:
                                        log(f"[exteraFy] Error restoring bio after inactivity: {e}")
                                self._restore_done = True
                    else:
                        log("[exteraFy] Failed to get current track for bio update")
                        if self._last_no_track_time is None:
                            self._last_no_track_time = time.time()
                            self._restore_done = False
                        elif not self._restore_done and time.time() - self._last_no_track_time >= 600:
                            # Capturar bio atual do perfil em vez de usar bio antiga
                            try:
                                current_bio = userFull.about if userFull else ""
                                restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                
                                if current_bio and current_bio.strip():
                                    default_bio = current_bio
                                elif restore_bio_text:
                                    default_bio = restore_bio_text
                                else:
                                    default_bio = "I'm using nowFy!"
                            except:
                                restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                                if restore_bio_text:
                                    default_bio = restore_bio_text
                                else:
                                    default_bio = "I'm using nowFy!"
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[exteraFy] Restored bio after inactivity (no track)")
                                    # Não mostrar bulletin aqui, pois é auto-refresh (restauração)
                                except Exception as e:
                                    log(f"[exteraFy] Error restoring bio after inactivity (no track): {e}")
                            self._restore_done = True
                    time.sleep(120)
                else:
                    time.sleep(5)
            except Exception as e:
                log(f"[exteraFy] Bio update worker error: {e}")
                time.sleep(10)

    def _clear_cache(self):
        with self._cache_lock:
            # Limpar cache original
            self._image_cache.clear()
            self._cache_timestamps.clear()
            # Limpar cache otimizado
            if hasattr(self, '_enhanced_image_cache'):
                self._enhanced_image_cache.clear()
            if hasattr(self, '_base_theme_cache'):
                self._base_theme_cache.clear()
            # Limpar cache do Apple UI
            if hasattr(self, '_apple_cache'):
                self._apple_cache.clear()
                log("[RADIUS DEBUG] Apple cache cleared during general cache clear")
        # Limpar cache em disco
        try:
            for file in self._disk_cache_dir.listFiles():
                if file.getName().endswith('.cache'):
                    file.delete()
        except Exception:
            pass
        
        # Mostrar estatísticas de cache limpo
        performance_mode = self.get_setting("performance_mode", 1)
        mode_names = ["Turbo", "Balanceado", "Qualidade"]
        mode_name = mode_names[performance_mode] if 0 <= performance_mode <= 2 else "Desconhecido"
        
        BulletinHelper.show_info(tr("cache_cleared"))
    
    def _clear_nowcast_history(self):
        """Limpa completamente o histórico do NowCast para resolver problemas de postagem"""
        try:
            print("[NowCast] Limpando histórico completo do NowCast...")
            
            # Parar worker temporariamente se estiver rodando
            worker_was_running = getattr(self, '_nowcast_worker_running', False)
            if worker_was_running:
                print("[NowCast] Parando worker para limpeza...")
                self._nowcast_worker_running = False
                time.sleep(2)
            
            # Resetar todas as variáveis de controle do sistema anti-duplicatas
            self._nowcast_last_track_hash = None
            self._nowcast_post_history = []
            self._nowcast_cooldown_time = 0
            
            # Limpar cache também
            self._clear_cache()
            
            # Restaurar worker se estava rodando
            if worker_was_running:
                print("[NowCast] Restaurando worker após limpeza...")
                self._nowcast_worker_running = True
            
            print("[NowCast] Histórico do NowCast limpo completamente")
            
            try:
                BulletinHelper.show_bulletin(
                    "NowCast Reset",
                    "Histórico e cache do NowCast foram limpos. O bot deve voltar a funcionar normalmente."
                )
            except:
                pass
            
            return True
            
        except Exception as e:
            print(f"[NowCast] Erro ao limpar histórico: {e}")
            return False

    # === PERFORMANCE DO NOWFY ===

    
    def _get_cached_image_enhanced(self, url, cache_key=None, force_size=None):
        """Cache inteligente de imagens com otimizações de performance"""
        if not self.get_setting("enhanced_cache", True):
            return self._get_cached_image_original(url)
        
        if not cache_key:
            cache_key = url
        # Verificar cache em memória primeiro
        with self._cache_lock:
            if cache_key in self._enhanced_image_cache:
                cached_data = self._enhanced_image_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['image']
                else:
                    del self._enhanced_image_cache[cache_key]
        # Verificar cache em disco
        disk_cache_file = File(self._disk_cache_dir, f"{hash(cache_key) % 100000}.cache")
        if disk_cache_file.exists():
            try:
                with open(disk_cache_file.getAbsolutePath(), 'rb') as f:
                    cached_image = f.read()
                    # Adicionar de volta ao cache em memória
                    with self._cache_lock:
                        self._enhanced_image_cache[cache_key] = {
                            'image': cached_image,
                            'timestamp': time.time()
                        }
                    return cached_image
            except Exception:
                pass
        # Download e processamento da imagem
        try:
            performance_mode = self.get_setting("performance_mode", 1)
            timeout = 5 if performance_mode == 0 else (10 if performance_mode == 1 else 15)
            
            response = requests.get(url, timeout=timeout)
            if response.status_code == 200:
                image_data = response.content             
                # Optimize only if compression is enabled AND a target size was provided
                if self.get_setting("enable_compression", False) and not self._is_theme_base_image(url):
                    if force_size:
                        image_data = self._optimize_image(image_data, force_size)
                    else:
                        # Preserve original resolution/format when no force_size
                        pass
                # Salvar no cache em memória
                with self._cache_lock:
                    self._enhanced_image_cache[cache_key] = {
                        'image': image_data,
                        'timestamp': time.time()
                    }                   
                    # Limitar tamanho do cache em memória
                    if len(self._enhanced_image_cache) > self._cache_max_size:
                        oldest_key = min(self._enhanced_image_cache.keys(), 
                                        key=lambda k: self._enhanced_image_cache[k]['timestamp'])
                        del self._enhanced_image_cache[oldest_key]                
                # Salvar no cache em disco (assíncrono)
                try:
                    with open(disk_cache_file.getAbsolutePath(), 'wb') as f:
                        f.write(image_data)
                except Exception:
                    pass
                
                return image_data
        except Exception as e:
            log(f"[exteraFy] Error downloading image {url}: {e}")
        
        return None
    
    def _is_theme_base_image(self, url):
        """Verifica se a URL é de uma imagem base dos temas Apple"""
        theme_base_urls = [
            "https://i.postimg.cc/7L9Hf5Pd/applelight.png",
            "https://i.postimg.cc/d10qdJL1/appledark.png", 
            "https://i.postimg.cc/269phvZb/applered.png",
            "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png",
            "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png",
            "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png",
            "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png",
            "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png",
            "https://i.postimg.cc/C502GHp8/appledarkytmusic.png",
            "https://i.postimg.cc/qvtSs7Cp/etglight.png",
            "https://i.postimg.cc/cJwzz5mj/etgdark.png",
            "https://i.postimg.cc/2yR4VrBj/ayulight.png",
            "https://i.postimg.cc/ryx170vD/ayudark.png",
            "https://i.postimg.cc/8cRLv9hR/ayured.png",
            "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png",
            "https://i.postimg.cc/hvQs0qNw/appledarkapple.png",
            "https://i.postimg.cc/Jn2KJhYZ/appleredapple.png"
        ]
        return url in theme_base_urls

    def _optimize_image(self, image_data, target_size=None):
        """Optimize image preserving quality and save as PNG (lossless)."""
        try:
            from PIL import Image, ImageOps
            import io
            
            # Open image
            img = Image.open(io.BytesIO(image_data))
            # Resize to target if provided, preserving aspect
            if target_size and img.size != target_size:
                img = ImageOps.fit(img, target_size, method=Image.LANCZOS, centering=(0.5, 0.5))
            
            # PNG compression level based on performance mode (0-9)
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else (4 if performance_mode == 1 else 6)
            
            output = io.BytesIO()
            img.save(output, format='PNG', optimize=True, compress_level=compress_level)
            return output.getvalue()
            
        except Exception as e:
            log(f"[exteraFy] Error optimizing image: {e}")
            return image_data
    
    def _preload_next_track_cover(self):
        """Pré-carrega as próximas 5 faixas se o pré-carregamento estiver ativado"""
        if not self.get_setting("enable_preload", False):
            return
        
        try:
            # Executar pré-carregamento em thread separada para não bloquear
            threading.Thread(target=self._preload_worker, daemon=True).start()
        except Exception as e:
            log(f"[exteraFy] Error starting preload worker: {e}")
    
    def _preload_worker(self):
        """Worker thread para pré-carregamento de faixas"""
        try:
            account = self._get_account()
            if not account:
                return
            
            token = self._get_spotify_token(account)
            if not token:
                return
            
            # Obter informações da fila de reprodução atual
            queue_data = self._get_spotify_queue(token)
            if not queue_data:
                return
            
            # Pré-carregar próximas 5 faixas
            next_tracks = queue_data.get('queue', [])[:5]
            
            for i, track in enumerate(next_tracks):
                try:
                    self._preload_track_card(track, i + 1)
                    # Pequeno delay entre pré-carregamentos para não sobrecarregar
                    time.sleep(0.5)
                except Exception as e:
                    log(f"[exteraFy] Error preloading track {i+1}: {e}")
                    
        except Exception as e:
            log(f"[exteraFy] Error in preload worker: {e}")
    
    def _get_spotify_queue(self, token):
        """Obtém a fila de reprodução atual do Spotify"""
        try:
            # Primeiro, tentar obter a fila de reprodução
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/queue",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                return resp.json()
            
            # Se não conseguir a fila, usar faixas recentes como fallback
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/recently-played?limit=10",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                recent_data = resp.json()
                # Simular uma fila baseada nas faixas recentes
                return {
                    'queue': [item['track'] for item in recent_data.get('items', [])]
                }
            
            return None
            
        except Exception as e:
            log(f"[exteraFy] Error getting Spotify queue: {e}")
            return None
    
    def _preload_track_card(self, track, position):
        """Pré-carrega o card de uma faixa específica"""
        try:
            if not track or not track.get('id'):
                return
            
            track_id = track['id']
            track_name = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])]
            artist_name = ', '.join(artists) if artists else 'Unknown'
            album_name = track.get('album', {}).get('name', 'Unknown')
            
            # Criar chave de cache para esta faixa
            cache_key = f"preload_{track_id}_{position}"
            
            # Verificar se já está em cache
            if hasattr(self, '_preload_cache') and cache_key in self._preload_cache:
                cached_data = self._preload_cache[cache_key]
                if time.time() - cached_data['timestamp'] < 1800:  # Cache por 30 minutos
                    return
            
            # Obter URL da capa do álbum
            album_images = track.get('album', {}).get('images', [])
            image_url = ''
            if album_images:
                # Usar a imagem de maior qualidade disponível
                image_url = album_images[0]['url']
            
            # Pré-carregar a imagem da capa
            if image_url:
                cover_cache_key = f"preload_cover_{track_id}"
                cover_data = self._get_cached_image_enhanced(
                    image_url, 
                    cache_key=cover_cache_key,
                    force_size=298
                )
            
            # Gerar card pré-renderizado baseado no tema atual
            theme_mode = self.get_setting("theme_mode", 0)
            card_data = None
            
            if theme_mode in [0, 1, 2]:  # Temas Apple
                card_data = self._prerender_apple_card(track, image_url, theme_mode)
            elif theme_mode == 3:  # Tema CustomFM
                card_data = self._prerender_customfm_card(track, image_url)
            elif theme_mode == 4:  # Tema Default
                card_data = self._prerender_default_card(track, image_url)
            
            # Armazenar no cache de pré-carregamento
            if not hasattr(self, '_preload_cache'):
                self._preload_cache = {}
            
            self._preload_cache[cache_key] = {
                'track_data': {
                    'id': track_id,
                    'name': track_name,
                    'artist': artist_name,
                    'album': album_name,
                    'image_url': image_url
                },
                'card_data': card_data,
                'timestamp': time.time(),
                'position': position
            }
            
            # Limitar tamanho do cache de pré-carregamento
            if len(self._preload_cache) > 20:
                oldest_key = min(self._preload_cache.keys(),
                               key=lambda k: self._preload_cache[k]['timestamp'])
                del self._preload_cache[oldest_key]
            
            log(f"[exteraFy] Preloaded track {position}: {track_name} by {artist_name}")
            
        except Exception as e:
            log(f"[exteraFy] Error preloading track card: {e}")
    
    def _prerender_apple_card(self, track, image_url, theme_mode):
        """Pré-renderiza card no estilo Apple"""
        try:
            # Implementação simplificada - pode ser expandida
            return {
                'type': 'apple',
                'theme_mode': theme_mode,
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering Apple card: {e}")
            return None
    
    def _prerender_customfm_card(self, track, image_url):
        """Pré-renderiza card no estilo CustomFM"""
        try:
            return {
                'type': 'customfm',
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering CustomFM card: {e}")
            return None
    
    def _prerender_default_card(self, track, image_url):
        """Pré-renderiza card no estilo Default"""
        try:
            return {
                'type': 'default',
                'track': track,
                'image_url': image_url,
                'rendered': True
            }
        except Exception as e:
            log(f"[exteraFy] Error prerendering Default card: {e}")
            return None
    
    def get_preloaded_track(self, track_id):
        """Obtém uma faixa pré-carregada do cache"""
        try:
            if not hasattr(self, '_preload_cache'):
                return None
            
            for cache_key, cached_data in self._preload_cache.items():
                if cached_data['track_data']['id'] == track_id:
                    # Verificar se o cache ainda é válido
                    if time.time() - cached_data['timestamp'] < 1800:  # 30 minutos
                        return cached_data
                    else:
                        # Cache expirado, remover
                        del self._preload_cache[cache_key]
                        break
            
            return None
            
        except Exception as e:
             log(f"[exteraFy] Error getting preloaded track: {e}")
             return None
    
    def _is_preloaded_card_compatible(self, preloaded_card, current_theme):
        """Verifica se o card pré-carregado é compatível com o tema atual"""
        try:
            if not preloaded_card or not preloaded_card.get('type'):
                return False
            
            card_type = preloaded_card['type']
            
            # Verificar compatibilidade baseada no tipo de card e tema atual
            if card_type == 'apple' and current_theme in [0, 1, 2]:
                # Card Apple é compatível com temas Apple (0, 1, 2)
                return preloaded_card.get('theme_mode') == current_theme
            elif card_type == 'customfm' and current_theme == 3:
                # Card CustomFM é compatível com tema CustomFM (3)
                return True
            elif card_type == 'default' and current_theme == 4:
                # Card Default é compatível com tema Default (4)
                return True
            
            return False
            
        except Exception as e:
            log(f"[exteraFy] Error checking preloaded card compatibility: {e}")
            return False
    
    def _process_preloaded_card(self, preloaded_card, params, progress_ms, is_fm_command):
        """Processa um card pré-carregado rapidamente"""
        try:
            if not preloaded_card or not preloaded_card.get('track'):
                return
            
            track = preloaded_card['track']
            image_url = preloaded_card.get('image_url', '')
            card_type = preloaded_card.get('type', 'default')
            
            # Processar baseado no tipo de card
            if card_type == 'apple':
                theme_mode = preloaded_card.get('theme_mode', 0)
                self._process_preloaded_apple_card(track, image_url, theme_mode, params, progress_ms, is_fm_command)
            elif card_type == 'customfm':
                self._process_preloaded_customfm_card(track, image_url, params, progress_ms, is_fm_command)
            elif card_type == 'default':
                self._process_preloaded_default_card(track, image_url, params, progress_ms, is_fm_command)
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded card: {e}")
    
    def _process_preloaded_apple_card(self, track, image_url, theme_mode, params, progress_ms, is_fm_command):
        """Processa card Apple pré-carregado"""
        try:
            # Usar dados pré-carregados para gerar card Apple rapidamente
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração Apple com dados pré-carregados
            self._get_current_track_lastfm_customfm(
                title, artist, album, image_url, params, 
                progress_dialog=None, player="Spotify", 
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded Apple card: {e}")
    
    def _process_preloaded_customfm_card(self, track, image_url, params, progress_ms, is_fm_command):
        """Processa card CustomFM pré-carregado"""
        try:
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração CustomFM com dados pré-carregados
            self._get_current_track_lastfm_customfm(
                title, artist, album, image_url, params,
                progress_dialog=None, player="Spotify",
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded CustomFM card: {e}")
    
    def _process_preloaded_default_card(self, track, image_url, params, progress_ms, is_fm_command):
        """Processa card Default pré-carregado"""
        try:
            title = track.get('name', 'Unknown')
            artists = [artist['name'] for artist in track.get('artists', [])] if track.get('artists') else ['Unknown']
            artist = ', '.join(artists)
            album = track.get('album', {}).get('name', 'Unknown') if track.get('album') else 'Unknown'
            
            # Chamar função de geração Default com dados pré-carregados
            self._get_current_track_lastfm_default(
                title, artist, album, image_url, params,
                progress_dialog=None, player="Spotify",
                youtube_url=None, etg_cover_image=None
            )
            
        except Exception as e:
            log(f"[exteraFy] Error processing preloaded Default card: {e}")
    
    def _cleanup_preload_cache(self):
        """Limpa o cache de pré-carregamento de faixas antigas"""
        try:
            if not hasattr(self, '_preload_cache'):
                return
            
            current_time = time.time()
            cache_ttl = 300  # 5 minutos
            
            # Remover entradas antigas do cache
            expired_keys = []
            for track_id, data in self._preload_cache.items():
                if current_time - data.get('timestamp', 0) > cache_ttl:
                    expired_keys.append(track_id)
            
            for key in expired_keys:
                del self._preload_cache[key]
            
            # Limitar tamanho do cache (máximo 10 faixas)
            if len(self._preload_cache) > 10:
                # Remover as mais antigas
                sorted_items = sorted(self._preload_cache.items(), 
                                    key=lambda x: x[1].get('timestamp', 0))
                for track_id, _ in sorted_items[:-10]:
                    del self._preload_cache[track_id]
            
            log(f"[exteraFy] Preload cache cleaned. Current size: {len(self._preload_cache)}")
            
        except Exception as e:
            log(f"[exteraFy] Error cleaning preload cache: {e}")
    
    def _is_track_currently_playing(self, track_id):
        """Verifica se a faixa está atualmente sendo reproduzida"""
        try:
            if not hasattr(self, '_current_track_id'):
                return False
            return self._current_track_id == track_id
        except Exception as e:
            log(f"[exteraFy] Error checking current track: {e}")
            return False
    
    def _update_current_track_id(self, track_id):
        """Atualiza o ID da faixa atual"""
        try:
            self._current_track_id = track_id
        except Exception as e:
            log(f"[exteraFy] Error updating current track ID: {e}")
    
    def _get_cached_customfm_image(self, cache_key, temp_dir):
        """Verifica se existe uma imagem CustomFM em cache"""
        try:
            cache_file = File(temp_dir, f"customfm_{cache_key}.png")
            if cache_file.exists():
                # Verificar se o arquivo não é muito antigo (cache por 1 hora)
                file_time = cache_file.lastModified()
                current_time = System.currentTimeMillis()
                if (current_time - file_time) < 3600000:  # 1 hora em millisegundos
                    return cache_file.getAbsolutePath()
                else:
                    # Cache expirado, deletar arquivo
                    cache_file.delete()
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao verificar cache CustomFM: {e}")
            return None

    def _get_cached_image_original(self, url):
        """Função original de cache para fallback"""
        cache_key = url
        current_time = time.time()
        
        with self._cache_lock:
            if cache_key in self._image_cache:
                if current_time - self._cache_timestamps.get(cache_key, 0) < self._cache_ttl:
                    return self._image_cache[cache_key]
                else:
                    del self._image_cache[cache_key]
                    if cache_key in self._cache_timestamps:
                        del self._cache_timestamps[cache_key]
        
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                image_data = response.content
                with self._cache_lock:
                    self._image_cache[cache_key] = image_data
                    self._cache_timestamps[cache_key] = current_time
                return image_data
        except Exception as e:
            log(f"[exteraFy] Error downloading image {url}: {e}")
        
        return None

    def _get_youtube_thumbnail_cached(self, video_id, quality='maxresdefault'):
        """Cache específico para thumbnails do YouTube com fallback de qualidade"""
        if not self.get_setting("enable_youtube_thumbnail_cache", False):
            return self._get_youtube_thumbnail_direct(video_id, quality)
        
        cache_key = f"yt_thumb_{video_id}_{quality}"      
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_youtube_thumbnail_cache') and cache_key in self._youtube_thumbnail_cache:
                cached_data = self._youtube_thumbnail_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['data']
                else:
                    del self._youtube_thumbnail_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_youtube_thumbnail_cache'):
            self._youtube_thumbnail_cache = {}
        
        # Tentar obter thumbnail
        thumbnail_data = self._get_youtube_thumbnail_direct(video_id, quality)
        
        if thumbnail_data:
            # Armazenar no cache
            with self._cache_lock:
                self._youtube_thumbnail_cache[cache_key] = {
                    'data': thumbnail_data,
                    'timestamp': time.time()
                }
                
                # Limitar tamanho do cache
                if len(self._youtube_thumbnail_cache) > 50:
                    oldest_key = min(self._youtube_thumbnail_cache.keys(),
                                    key=lambda k: self._youtube_thumbnail_cache[k]['timestamp'])
                    del self._youtube_thumbnail_cache[oldest_key]
        
        return thumbnail_data
    
    def _get_youtube_thumbnail_direct(self, video_id, quality='maxresdefault'):
        """Obtém thumbnail do YouTube com fallback de qualidade e valida resolução."""
        # Tentar sempre as melhores opções primeiro
        qualities = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
        
        # Respeitar configuração de fallback
        if self.get_setting("enable_quality_fallback", True):
            if quality in qualities:
                start_index = qualities.index(quality)
                qualities = qualities[start_index:] + qualities[:start_index]
        else:
            qualities = [quality]
        
        bases = ["https://img.youtube.com", "https://i.ytimg.com"]
        for q in qualities:
            for base in bases:
                try:
                    thumb_url = f"{base}/vi/{video_id}/{q}.jpg"
                    response = requests.get(thumb_url, timeout=10)
                    if response.status_code == 200 and self._is_high_quality_thumbnail(response.content):
                        return response.content
                except Exception as e:
                    log(f"[exteraFy] Error getting YouTube thumbnail {q} from {base}: {e}")
                    continue
        
        return None
    
    def _is_high_quality_thumbnail(self, response_content):
        """Valida se a thumbnail tem resolução útil (evita placeholders)."""
        try:
            from io import BytesIO
            from PIL import Image
            
            # Verificação mínima de conteúdo
            if not response_content or len(response_content) < 8000:
                return False
            # JPEG assinatura
            if not (b'JFIF' in response_content[:64] or b'\xff\xd8\xff' in response_content[:10]):
                return False
            
            # Abrir e verificar dimensões
            img = Image.open(BytesIO(response_content))
            w, h = img.size
            # Exigir pelo menos qualidade SD e evitar 120x90
            if w >= 640 and h >= 360:
                return True
            # Permitir hqdefault quando nada melhor está disponível
            return w >= 480 and h >= 270
        except Exception:
            return False
    
    def _get_soundcloud_thumbnail_cached(self, track_url):
        """Cache específico para thumbnails do SoundCloud"""
        if not self.get_setting("enable_soundcloud_thumbnail_cache", False):
            return self._get_soundcloud_thumbnail_direct(track_url)
        
        cache_key = f"sc_thumb_{hash(track_url)}"
        
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_soundcloud_thumbnail_cache') and cache_key in self._soundcloud_thumbnail_cache:
                cached_data = self._soundcloud_thumbnail_cache[cache_key]
                if time.time() - cached_data['timestamp'] < self._cache_ttl:
                    return cached_data['data']
                else:
                    del self._soundcloud_thumbnail_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_soundcloud_thumbnail_cache'):
            self._soundcloud_thumbnail_cache = {}
        
        # Tentar obter thumbnail
        thumbnail_data = self._get_soundcloud_thumbnail_direct(track_url)
        
        if thumbnail_data:
            # Armazenar no cache
            with self._cache_lock:
                self._soundcloud_thumbnail_cache[cache_key] = {
                    'data': thumbnail_data,
                    'timestamp': time.time()
                }
                
                # Limitar tamanho do cache
                if len(self._soundcloud_thumbnail_cache) > 30:
                    oldest_key = min(self._soundcloud_thumbnail_cache.keys(),
                                    key=lambda k: self._soundcloud_thumbnail_cache[k]['timestamp'])
                    del self._soundcloud_thumbnail_cache[oldest_key]
        
        return thumbnail_data
    
    def _get_soundcloud_thumbnail_direct(self, track_url):
        """Obtém thumbnail do SoundCloud diretamente"""
        try:
            # Implementação básica - pode ser expandida conforme necessário
            response = requests.get(track_url, timeout=10)
            if response.status_code == 200:
                # Extrair URL da thumbnail do HTML (implementação simplificada)
                import re
                content = response.text
                thumbnail_match = re.search(r'"artwork_url":"([^"]+)"', content)
                if thumbnail_match:
                    thumbnail_url = thumbnail_match.group(1).replace('\\/', '/')
                    # Tentar obter thumbnail em alta resolução
                    thumbnail_url = thumbnail_url.replace('large.jpg', 't500x500.jpg')
                    
                    thumb_response = requests.get(thumbnail_url, timeout=10)
                    if thumb_response.status_code == 200:
                        return thumb_response.content
        except Exception as e:
            log(f"[exteraFy] Error getting SoundCloud thumbnail: {e}")
        
        return None
    
    def _get_valid_thumbnail_url_cached(self, url):
        """Cache de URLs de thumbnails válidas"""
        if not self.get_setting("enable_url_cache", True):
            return self._validate_thumbnail_url_direct(url)
        
        cache_key = f"url_valid_{hash(url)}"
        
        # Verificar cache em memória
        with self._cache_lock:
            if hasattr(self, '_url_validation_cache') and cache_key in self._url_validation_cache:
                cached_data = self._url_validation_cache[cache_key]
                if time.time() - cached_data['timestamp'] < (self._cache_ttl * 2):  # URLs válidas duram mais
                    return cached_data['data']
                else:
                    del self._url_validation_cache[cache_key]
        
        # Inicializar cache se não existir
        if not hasattr(self, '_url_validation_cache'):
            self._url_validation_cache = {}
        
        # Validar URL
        is_valid = self._validate_thumbnail_url_direct(url)
        
        # Armazenar no cache
        with self._cache_lock:
            self._url_validation_cache[cache_key] = {
                'data': is_valid,
                'timestamp': time.time()
            }
            
            # Limitar tamanho do cache
            if len(self._url_validation_cache) > 100:
                oldest_key = min(self._url_validation_cache.keys(),
                                key=lambda k: self._url_validation_cache[k]['timestamp'])
                del self._url_validation_cache[oldest_key]
        
        return is_valid
    
    def _validate_thumbnail_url_direct(self, url):
        """Valida se uma URL de thumbnail é válida"""
        try:
            response = requests.head(url, timeout=5)
            return response.status_code == 200 and 'image' in response.headers.get('content-type', '')
        except Exception:
            return False

    def _get_card_base_image_url(self, theme=0):
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Light", "Dark"]  # Red removido por problemas de compatibilidade
            skin = skin_names[apple_skin_index]
            
            # Usar o dicionário APPLE_BACKGROUNDS
            if current_player in APPLE_BACKGROUNDS and skin in APPLE_BACKGROUNDS[current_player]:
                return APPLE_BACKGROUNDS[current_player][skin]
            
            # Fallback para Spotify se player não encontrado
            return APPLE_BACKGROUNDS["Spotify"][skin]
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        is_yandex_music = current_player == "Yandex Music"
        
        # Compatibilidade com temas antigos (será removido gradualmente)
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return "https://i.postimg.cc/6p0NgnSh/appleredsoundcloud.png"
            elif is_youtube:
                return "https://i.postimg.cc/bvXjBnQ6/appleredyoutubered.png"
            elif is_youtube_music:
                return "https://i.postimg.cc/44vqJMpQ/appleredytmusic.png"
            elif is_exteragram:
                return "https://i.postimg.cc/6pDSYNdn/etgred.png"
            elif is_ayugram:
                return "https://i.postimg.cc/8cRLv9hR/ayured.png"
            elif is_apple_music:
                return "https://i.postimg.cc/Jn2KJhYZ/appleredapple.png"
            return "https://i.postimg.cc/269phvZb/applered.png"
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return "https://i.postimg.cc/qv0T1jmR/appledarksoundcloud.png"
            elif is_youtube:
                return "https://i.postimg.cc/0yKsnnJM/appleredyoutubedark.png"
            elif is_youtube_music:
                return "https://i.postimg.cc/C502GHp8/appledarkytmusic.png"
            elif is_exteragram:
                return "https://i.postimg.cc/cJwzz5mj/etgdark.png"
            elif is_ayugram:
                return "https://i.postimg.cc/ryx170vD/ayudark.png"
            elif is_apple_music:
                return "https://i.postimg.cc/hvQs0qNw/appledarkapple.png"
            elif is_yandex_music:
                return "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex_swap.png"
            return "https://i.postimg.cc/d10qdJL1/appledark.png"
        
        # Fallback para Apple Light
        if is_soundcloud:
            return "https://i.postimg.cc/5N8J5ZST/applelightsoundcloud.png"
        elif is_youtube:
            return "https://i.postimg.cc/rFPT53z2/appleredyoutubelight.png"
        elif is_youtube_music:
            return "https://i.postimg.cc/Wz7HXFsH/applelightytmusic.png"
        elif is_exteragram:
            return "https://i.postimg.cc/qvtSs7Cp/etglight.png"
        elif is_ayugram:
            return "https://i.postimg.cc/2yR4VrBj/ayulight.png"
        elif is_apple_music:
            return "https://i.postimg.cc/HxxBVMzT/applelightapplelight.png"
        elif is_yandex_music:
            return "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex.png"
        return "https://i.postimg.cc/7L9Hf5Pd/applelight.png"

    def _get_card_base_path(self, theme=0):
        temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy/cards")
        if not temp_dir.exists():
            temp_dir.mkdirs()
        
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Light", "Dark", "Red"]
            skin = skin_names[apple_skin_index].lower()
            
            # Gerar nome do arquivo baseado no player e skin
            player_suffix = ""
            if current_player == "SoundCloud":
                player_suffix = "_soundcloud"
            elif current_player == "YouTube":
                player_suffix = "_youtube"
            elif current_player == "YouTube Music":
                player_suffix = "_ytmusic"
            elif current_player == "exteraGram":
                player_suffix = "_exteragram"
            elif current_player == "AyuGram":
                player_suffix = "_ayugram"
            elif current_player == "Apple Music":
                player_suffix = "_applemusic"
            
            filename = f"apple{skin}{player_suffix}.png"
            return File(temp_dir, filename).getAbsolutePath()
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music para usar caminhos diferentes
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return File(temp_dir, "applered_soundcloud.png").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "applered_youtube.png").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "applered_ytmusic.png").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "applered_exteragram.png").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "applered_ayugram.png").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "applered_applemusic.png").getAbsolutePath()
            elif is_yandex_music:
                return File(temp_dir, "yandex_swap.png").getAbsolutePath()
            return File(temp_dir, "applered.png").getAbsolutePath()
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return File(temp_dir, "appledark_soundcloud.png").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "appledark_youtube.png").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "appledark_ytmusic.png").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "appledark_exteragram.png").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "appledark_ayugram.png").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "appledark_applemusic.png").getAbsolutePath()
            elif is_yandex_music:
                return File(temp_dir, "yandex_swap.png").getAbsolutePath()
            return File(temp_dir, "appledark.png").getAbsolutePath()
        # Fallback para Apple Light
        if is_soundcloud:
            return File(temp_dir, "applelight_soundcloud.png").getAbsolutePath()
        elif is_youtube:
            return File(temp_dir, "applelight_youtube.png").getAbsolutePath()
        elif is_youtube_music:
            return File(temp_dir, "applelight_ytmusic.png").getAbsolutePath()
        elif is_exteragram:
            return File(temp_dir, "applelight_exteragram.png").getAbsolutePath()
        elif is_ayugram:
            return File(temp_dir, "applelight_ayugram.png").getAbsolutePath()
        elif is_apple_music:
            return File(temp_dir, "applelight_applemusic.png").getAbsolutePath()
        elif is_yandex_music:
            return File(temp_dir, "yandex.png").getAbsolutePath()
        return File(temp_dir, "applelight.png").getAbsolutePath()

    def _get_card_base_version_path(self, theme=0):
        temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy/cards")
        if not temp_dir.exists():
            temp_dir.mkdirs()
        
        # Para o tema Apple unificado (theme=0), usar o sistema de skin
        if theme == 0:  # Apple unificado
            current_player = self._detect_current_player()
            apple_skin_index = self._get_apple_skin_index_mapped()
            skin_names = ["Dark", "Red"]
            skin = skin_names[apple_skin_index].lower()
            
            # Gerar nome do arquivo baseado no player e skin
            player_suffix = ""
            if current_player == "SoundCloud":
                player_suffix = "_soundcloud"
            elif current_player == "YouTube":
                player_suffix = "_youtube"
            elif current_player == "YouTube Music":
                player_suffix = "_ytmusic"
            elif current_player == "exteraGram":
                player_suffix = "_exteragram"
            elif current_player == "AyuGram":
                player_suffix = "_ayugram"
            elif current_player == "Apple Music":
                player_suffix = "_applemusic"
            
            filename = f"apple{skin}{player_suffix}_version.txt"
            return File(temp_dir, filename).getAbsolutePath()
        
        # Manter compatibilidade com temas externos (theme > 0)
        # Detectar se o player ativo é SoundCloud, YouTube, YouTube Music, exteraGram, AyuGram ou Apple Music para usar caminhos diferentes
        current_player = self._detect_current_player()
        is_soundcloud = current_player == "SoundCloud"
        is_youtube = current_player == "YouTube"
        is_youtube_music = current_player == "YouTube Music"
        is_exteragram = current_player == "exteraGram"
        is_ayugram = current_player == "AyuGram"
        is_apple_music = current_player == "Apple Music"
        is_yandex_music = current_player == "Yandex Music"
        
        if theme == 2:  # Apple Red
            if is_soundcloud:
                return File(temp_dir, "applered_soundcloud_version.txt").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "applered_youtube_version.txt").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "applered_ytmusic_version.txt").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "applered_exteragram_version.txt").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "applered_ayugram_version.txt").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "applered_applemusic_version.txt").getAbsolutePath()
            return File(temp_dir, "applered_version.txt").getAbsolutePath()
        if theme == 1:  # Apple Dark
            if is_soundcloud:
                return File(temp_dir, "appledark_soundcloud_version.txt").getAbsolutePath()
            elif is_youtube:
                return File(temp_dir, "appledark_youtube_version.txt").getAbsolutePath()
            elif is_youtube_music:
                return File(temp_dir, "appledark_ytmusic_version.txt").getAbsolutePath()
            elif is_exteragram:
                return File(temp_dir, "appledark_exteragram_version.txt").getAbsolutePath()
            elif is_ayugram:
                return File(temp_dir, "appledark_ayugram_version.txt").getAbsolutePath()
            elif is_apple_music:
                return File(temp_dir, "appledark_applemusic_version.txt").getAbsolutePath()
            return File(temp_dir, "appledark_version.txt").getAbsolutePath()
        # Fallback para Apple Light
        if is_soundcloud:
            return File(temp_dir, "applelight_soundcloud_version.txt").getAbsolutePath()
        elif is_youtube:
            return File(temp_dir, "applelight_youtube_version.txt").getAbsolutePath()
        elif is_youtube_music:
            return File(temp_dir, "applelight_ytmusic_version.txt").getAbsolutePath()
        elif is_exteragram:
            return File(temp_dir, "applelight_exteragram_version.txt").getAbsolutePath()
        elif is_ayugram:
            return File(temp_dir, "applelight_ayugram_version.txt").getAbsolutePath()
        elif is_apple_music:
            return File(temp_dir, "applelight_applemusic_version.txt").getAbsolutePath()
        return File(temp_dir, "applelight_version.txt").getAbsolutePath()

    def _ensure_card_base_image(self, force_update=False, theme=0):
        base_path = self._get_card_base_path(theme)
        version_path = self._get_card_base_version_path(theme)
        current_url = self._get_card_base_image_url(theme)
        should_download = force_update
        if not should_download:
            if not os.path.exists(base_path):
                should_download = True
                log("[exteraFy] Base image not found, downloading...")
            elif not os.path.exists(version_path):
                should_download = True
                log("[exteraFy] Version file not found, downloading...")
            else:
                try:
                    with open(version_path, "r") as f:
                        saved_url = f.read().strip()
                    if saved_url != current_url:
                        should_download = True
                        log(f"[exteraFy] URL changed from {saved_url} to {current_url}, downloading new image...")
                    else:
                        log("[exteraFy] Using cached base image")
                except Exception as e:
                    should_download = True
                    log(f"[exteraFy] Error reading version file: {e}, downloading...")
        if should_download:
            try:
                log(f"[exteraFy] Downloading new base image from: {current_url}")
                # Usar cache original para download da imagem base (sem otimização de tamanho)
                image_data = self._get_cached_image_original(current_url)
                if image_data:
                    os.makedirs(os.path.dirname(base_path), exist_ok=True)
                    with open(base_path, "wb") as f:
                        f.write(image_data)
                    with open(version_path, "w") as f:
                        f.write(current_url)
                    log(f"[exteraFy] New base image downloaded and saved successfully")
                else:
                    raise Exception("Failed to download base image from cache")
            except Exception as e:
                log(f"[exteraFy] Error downloading new base image: {e}")
                if not os.path.exists(base_path):
                    raise e
                else:
                    log("[exteraFy] Using existing image as fallback")
        return base_path

    def _get_external_themes(self):
        """Obtém temas do plugin 'Themes for NowFy' se disponível"""
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            comm_dir = File(base_dir, "nowfy_communication")
            comm_file = File(comm_dir, "themes_data.json")
            
            log(f"[NowFy] Checking for external themes file: {comm_file.getAbsolutePath()}")
            log(f"[NowFy] File exists: {comm_file.exists()}")
            
            if comm_file.exists():
                with open(str(comm_file.getAbsolutePath()), 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                log(f"[NowFy] Communication data: {data.get('plugin_name', 'Unknown')} - Enabled: {data.get('is_enabled', False)}")
                log(f"[NowFy] Themes count: {len(data.get('themes', {}))}")
                    
                if data.get("is_enabled", False) and data.get("themes"):
                    # Filtrar temas indesejados
                    blocked_themes = ["apple_blue", "apple_rose", "caramella"]
                    filtered_themes = {k: v for k, v in data["themes"].items() if k not in blocked_themes}
                    
                    log(f"[NowFy] Found external themes: {list(data['themes'].keys())}")
                    log(f"[NowFy] Filtered external themes: {list(filtered_themes.keys())}")
                    return filtered_themes
                else:
                    log(f"[NowFy] External themes not enabled or empty")
            else:
                log(f"[NowFy] Communication file not found")
        except Exception as e:
            log(f"[NowFy] Error reading external themes: {e}")
        
        log(f"[NowFy] No external themes available")
        return {}

    def _generate_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera o card baseado no tema selecionado ou aleatório"""
        log(f"[Nowfy] _generate_card called - Track: {track.get('name', 'Unknown') if track else 'None'}, Force Spotify: {force_spotify}, is_fm_command: {is_fm_command}")
        
        # Verificar se existe versão pré-carregada desta faixa
        if track and track.get('id') and self.get_setting("enable_preload", False):
            preloaded_data = self.get_preloaded_track(track['id'])
            if preloaded_data and preloaded_data.get('card_data'):
                log(f"[exteraFy] Using preloaded card for track: {track.get('name', 'Unknown')}")
                # Usar dados pré-carregados se disponíveis e compatíveis com o tema atual
                current_theme = self.get_setting("theme_mode", 0)
                preloaded_card = preloaded_data['card_data']
                
                # Verificar compatibilidade do tema
                if self._is_preloaded_card_compatible(preloaded_card, current_theme):
                    # Processar card pré-carregado rapidamente
                    self._process_preloaded_card(preloaded_card, params, progress_ms, is_fm_command)
                    return
        

        
        random_theme = self.get_setting("random_theme_mode", False)
        if random_theme:
            import random
            # Incluir temas externos no modo aleatório
            external_themes = self._get_external_themes()
            
            # Verificar se é Last.FM para excluir temas Apple
            media_source = self.get_setting("media_source", 0)
            is_lastfm = media_source == 1  # 1 = Last.FM
            
            # Incluir temas Apple para todas as fontes (Spotify, Stats.fm e Last.fm)
            theme_options = [0, 1, 2]  # Apple Light, Apple Dark, Apple Red
            
            if external_themes:
                # Adicionar índices dos temas externos (3+)
                theme_options.extend(range(3, 3 + len(external_themes)))
            # Adicionar índice do tema Vinni
            vinni_index = 3 + len(external_themes)
            theme_options.append(vinni_index)
            # Adicionar índice do CustomFM (penúltimo)
            customfm_index = vinni_index + 1
            theme_options.append(customfm_index)
            # Adicionar índice do tema Minimal (último)
            minimal_index = customfm_index + 1
            theme_options.append(minimal_index)
            theme = random.choice(theme_options)
            log(f"[NowFy] Random theme selected: {theme} (Last.FM: {is_lastfm})")
        else:
            theme = self.get_setting("theme_selector", 0)
            log(f"[NowFy] Using selected theme: {theme}")
        
        # Verificar se é Last.FM e bloquear temas Apple completamente
        media_source = self.get_setting("media_source", 0)
        is_lastfm = media_source == 1  # 1 = Last.FM
        
        # Temas Apple (0, 1, 2) e Minimal agora têm suporte ao Last.fm
        
        if is_fm_command:
            player = self._detect_current_player()
            log(f"[NowFy] FM command - Theme: {theme}, Player: {player}")
        
        # Obter temas externos
        external_themes = self._get_external_themes()
        
        # Debug: Calcular índices dos temas
        vinni_index = 3 + len(external_themes)
        customfm_index = vinni_index + 1
        minimal_index = customfm_index + 1
        log(f"[NowFy] Theme debug - Selected: {theme}, Vinni index: {vinni_index}, CustomFM index: {customfm_index}, Minimal index: {minimal_index}, External themes count: {len(external_themes)}")
        log(f"[NowFy] Available themes: Apple Light(0), Apple Dark(1), Apple Red(2), External themes(3-{2+len(external_themes)}), Vinni({vinni_index}), CustomFM({customfm_index}), Minimal({minimal_index})")
        
        # Verificar se há uma imagem de capa do ETG
        player = self._detect_current_player()
        if etg_cover_image is None and player in ["exteraGram", "AyuGram", "Telegram"]:
            # Tentar obter a capa do ETG se não foi fornecida
            try:
                from org.telegram.messenger import MediaController
                media_controller = MediaController.getInstance()
                playing_song = media_controller.getPlayingMessageObject()
                etg_cover_image = self.get_etg_cover(playing_song)
            except Exception as e:
                log(f"[NowFy] Error getting ETG cover: {e}")
                etg_cover_image = None
        
        # Verificar se é Spotify para temas Apple
        player = "Spotify" if force_spotify else self._detect_current_player()
        
        if theme == 0:  # Apple unificado
            # Permitir para Spotify, SoundCloud, exteraGram, AyuGram e Apple Music (exceto Last.FM)
            # Apple Light bloqueado para SoundCloud conforme solicitado
            apple_skin_index = self._get_apple_skin_index_mapped()
            current_player = self._detect_current_player()
            
            # Verificar se Apple Light está sendo usado com SoundCloud (bloqueado)
            if apple_skin_index == 0 and current_player == "SoundCloud":
                log(f"[NowFy] Apple Light blocked for SoundCloud as requested")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=current_player, youtube_url=youtube_url)
                return
            
            # Verificar se o player é suportado (agora com suporte ao Last.fm)
            if player in ["Spotify", "SoundCloud", "exteraGram", "AyuGram", "Apple Music"] or force_spotify:
                self._generate_apple_unified_card(track, params, progress_ms, force_spotify, etg_cover_image)
            else:
                # Fallback para CustomFM apenas se player não suportado
                log(f"[NowFy] Apple theme fallback - Player: {player} not supported")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                current_player = self._detect_current_player()
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=current_player, youtube_url=youtube_url)
                return
        elif theme >= 1 and external_themes:  # Temas externos (índice 1+)
            # Calcular qual tema externo usar
            external_theme_index = theme - 1
            external_theme_ids = list(external_themes.keys())
            if external_theme_index < len(external_theme_ids):
                theme_id = external_theme_ids[external_theme_index]
                log(f"[NowFy] Using external theme: {theme_id} (index: {external_theme_index})")
                self._generate_external_theme_card(track, params, progress_ms, theme_id, external_themes[theme_id], force_spotify)
            else:
                # Se o índice for maior que o número de temas externos, verificar Vinni, Spotlight, CustomFM ou Minimal
                vinni_index = 1 + len(external_themes)
                spotlight_index = vinni_index + 1
                customfm_index = spotlight_index + 1
                minimal_index = customfm_index + 1
                log(f"[NowFy] Checking theme {theme} against Vinni index {vinni_index}, CustomFM index {customfm_index}")
                if theme == vinni_index:  # Vinify (anteriormente Vinni)
                    # Verificar se o player atual é suportado pelo tema Vinify
                    current_player = self._detect_current_player()
                    supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM"]
                    
                    if current_player in supported_players:
                        # Para Spotify, Apple Music, YouTube, YouTube Music e SoundCloud, usar o tema Vinify
                        self._generate_vinni_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
                    else:
                        # Para outros players, fazer fallback para CustomFM
                        log(f"[NowFy] Player {current_player} não suportado pelo tema Vinify, usando CustomFM como fallback")
                        title = track["name"]
                        artists = ", ".join([a["name"] for a in track["artists"]])
                        album = track["album"]["name"] if track.get("album") else ""
                        images = track["album"].get("images", [])
                        image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                        player = "Spotify" if force_spotify else current_player
                        youtube_url = track["external_urls"].get("spotify")
                        self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                        return
                elif theme == spotlight_index:  # Spotlight
                    # Verificar se o player atual é suportado pelo tema Spotlight
                    current_player = self._detect_current_player()
                    supported_players = ["Spotify", "Apple Music", "FM"]
                    
                    if current_player in supported_players or (current_player and ".fm" in current_player.lower()):
                        # Para Spotify e Apple Music, usar o tema Spotlight
                        self._generate_spotlight_card(track, params, progress_ms, force_spotify, etg_cover_image)
                    else:
                        # Para outros players, fazer fallback para CustomFM
                        log(f"[NowFy] Player {current_player} não suportado pelo tema Spotlight, usando CustomFM como fallback")
                        title = track["name"]
                        artists = ", ".join([a["name"] for a in track["artists"]])
                        album = track["album"]["name"] if track.get("album") else ""
                        images = track["album"].get("images", [])
                        image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                        player = "Spotify" if force_spotify else current_player
                        youtube_url = track["external_urls"].get("spotify")
                        self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                        return
                elif theme == customfm_index:  # CustomFM
                    # Extrair informações da faixa
                    title = track["name"]
                    artists = ", ".join([a["name"] for a in track["artists"]])
                    album = track["album"]["name"] if track.get("album") else ""
                    images = track["album"].get("images", [])
                    image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    player = "Spotify" if force_spotify else self._detect_current_player()
                    youtube_url = track["external_urls"].get("spotify")
                    self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                    return
                elif theme == minimal_index:  # Minimal
                    self._generate_minimal_card(track, params, force_spotify, etg_cover_image)
                else:
                    log(f"[NowFy] Theme index out of range: {theme}")
                    self._generate_apple_light_card(track, params, progress_ms, force_spotify, etg_cover_image)
        elif theme == 1 + len(external_themes):  # Spotlight (quando não há temas externos)
            log(f"[NowFy] Using Spotlight theme (no external themes case) - theme: {theme}")
            # Verificar se o player atual é suportado pelo tema Spotlight
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "FM"]
            
            if current_player in supported_players or (current_player and ".fm" in current_player.lower()):
                # Para Spotify e Apple Music, usar o tema Spotlight
                self._generate_spotlight_card(track, params, progress_ms, force_spotify, etg_cover_image)
            else:
                # Para outros players, fazer fallback para CustomFM
                log(f"[NowFy] Player {current_player} não suportado pelo tema Spotlight, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 2 + len(external_themes):  # Vinify (quando não há temas externos)
            log(f"[NowFy] Using Vinify theme (no external themes case) - theme: {theme}")
            # Verificar se o player atual é suportado pelo tema Vinify
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM"]
            
            if current_player in supported_players:
                # Para Spotify, Apple Music, YouTube, YouTube Music e SoundCloud, usar o tema Vinify
                self._generate_vinni_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
            else:
                # Para outros players, fazer fallback para CustomFM
                log(f"[NowFy] Player {current_player} não suportado pelo tema Vinify, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 3 + len(external_themes):  # Nowv (quando não há temas externos)
            log(f"[NowFy] Using Nowv theme (no external themes case) - theme: {theme}")
            current_player = self._detect_current_player()
            supported_players = ["Spotify", "Apple Music", "YouTube", "YouTube Music", "SoundCloud", "Yandex Music", "FM", "exteraGram", "AyuGram", "Telegram"]
            if current_player in supported_players:
                self._generate_nowv_card(track, params, progress_ms, force_spotify, etg_cover_image, is_fm_command)
            else:
                log(f"[NowFy] Player {current_player} não suportado pelo tema Nowv, usando CustomFM como fallback")
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                player = "Spotify" if force_spotify else current_player
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
                return
        elif theme == 4 + len(external_themes):  # CustomFM (quando não há temas externos)
            log(f"[NowFy] Using CustomFM theme (no external themes case) - theme: {theme}")
            # Extrair informações da faixa
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            album = track["album"]["name"] if track.get("album") else ""
            images = track["album"].get("images", [])
            image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
            player = "Spotify" if force_spotify else self._detect_current_player()
            youtube_url = track["external_urls"].get("spotify")
            self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
            return
        elif theme == 5 + len(external_themes):  # Minimal (quando não há temas externos)
            log(f"[NowFy] Using Minimal theme (no external themes case) - theme: {theme}")
            self._generate_minimal_card(track, params, force_spotify, etg_cover_image)
        else:
            # Verificar se é SoundCloud antes de usar Apple Light como fallback
            player = "Spotify" if force_spotify else self._detect_current_player()
            if player == "SoundCloud":
                log(f"[NowFy] Apple Light blocked for SoundCloud as requested (fallback case)")
                # Usar CustomFM como fallback para SoundCloud
                title = track["name"]
                artists = ", ".join([a["name"] for a in track["artists"]])
                album = track["album"]["name"] if track.get("album") else ""
                images = track["album"].get("images", [])
                image_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                youtube_url = track["external_urls"].get("spotify")
                self._get_current_track_lastfm_customfm(title, artists, album, image_url, params, player=player, youtube_url=youtube_url)
            else:
                self._generate_apple_light_card(track, params, progress_ms, force_spotify, etg_cover_image)

    def _generate_spotlight_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        """Gera card do tema Spotlight com design minimalista - fundo branco, apenas mini capa e barra de progresso"""
        try:
            # Obter configurações da skin do Spotlight
            spotlight_skin = self.get_setting("spotlight_skin", 0)
            skin_config = SPOTLIGHT_SKIN_STYLE.get(spotlight_skin, SPOTLIGHT_SKIN_STYLE[0])
            
            # Criar imagem base 567x614 com cor de fundo baseada na skin
            bg_color = skin_config.get("bg_color", (255, 255, 255))
            img = Image.new("RGB", (567, 614), bg_color)
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            
            # Obter capa do álbum
            if etg_cover_image is not None:
                cover_image = etg_cover_image
            else:
                # Detectar player atual
                player_name = self._detect_current_player()
                
                # Lógica dedicada para Yandex Music com capa YouTube-first
                if player_name == "Yandex Music":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para Yandex: {e}")
                        cover_image = self._get_fallback_cover(title, artists)
                elif player_name == "SoundCloud":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                        cover_image = self._get_fallback_cover(title, artists)
                else:
                    # Lógica para obter capa via imagens do álbum e fallback
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception as e:
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        cover_image = self._get_fallback_cover(title, artists)
            
            # Se a capa carregada for pequena, tentar upgrade com YouTube
            if cover_image and (cover_image.width < 457 or cover_image.height < 457):
                try:
                    yt_url_upgrade = self._get_youtube_cover(title, artists)
                    if yt_url_upgrade == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        yt_url_upgrade = self._get_youtube_thumbnail_forced(title, artists)
                    cover_data_upgrade = self._get_cached_image_enhanced(yt_url_upgrade, f"yt_cover_{hash(yt_url_upgrade)}")
                    if cover_data_upgrade:
                        cover_image = Image.open(BytesIO(cover_data_upgrade)).convert("RGBA")
                except Exception as e:
                    log(f"Upgrade de capa YouTube falhou: {e}")
            
            # Redimensionar mini capa para 457x457 com bordas arredondadas
            if cover_image:
                from PIL import ImageOps
                mini_cover = ImageOps.fit(cover_image, (457, 457), method=Image.LANCZOS, centering=(0.5, 0.5))
                
                # Se for a variação Blur, aplicar blur simples na capa como fundo
                if skin_config.get("use_blur_bg", False):
                    # Criar fundo blur da capa
                    blur_bg = cover_image.resize((567, 614), Image.LANCZOS)
                    blur_bg = blur_bg.filter(ImageFilter.GaussianBlur(radius=15))
                    
                    # Aplicar overlay escuro para escurecer o background
                    dark_overlay = Image.new('RGBA', (567, 614), (0, 0, 0, 150))
                    blur_bg = Image.alpha_composite(blur_bg.convert('RGBA'), dark_overlay)
                    
                    # Usar o fundo blur escurecido
                    img = blur_bg.convert("RGB")
                
                # Aplicar bordas arredondadas
                mini_cover = self._apply_rounded_corners(mini_cover, radius=20)
                
                # Posicionar mini capa centralizada horizontalmente e um pouco mais baixo
                cover_x = (567 - 457) // 2  # Centralizar horizontalmente
                cover_y = 50  # Posição mais baixa para centralizar com a barra
                img.paste(mini_cover, (cover_x, cover_y), mini_cover)
            
            draw = ImageDraw.Draw(img)
            
            # Configurar fonte apenas para a barra de progresso
            try:
                font_time = ImageFont.truetype("SourceSansPro-Regular.ttf", 14)
            except Exception:
                font_time = ImageFont.load_default()
            
            # Barra de progresso "spotibar" abaixo da capa
            if progress_ms is not None and track.get("duration_ms"):
                progress_y = cover_y + 457 + 49  # 40px abaixo da capa
                self._draw_spotibar(draw, img, progress_ms, track["duration_ms"], progress_y, font_time)
            
            # Salvar imagem
            output_path = File(ApplicationLoader.getFilesDirFixed(), "nowfy_spotlight_card.png")
            img.save(output_path.getAbsolutePath(), "PNG")
            
            # Enviar mensagem
            self._send_card_with_caption(params, output_path.getAbsolutePath(), track)
            
        except Exception as e:
            log(f"Erro ao gerar card Spotlight: {e}")
            import traceback
            traceback.print_exc()
    
    def _apply_rounded_corners(self, image, radius):
        """Aplica bordas arredondadas à imagem"""
        # Criar máscara com bordas arredondadas
        mask = Image.new("L", image.size, 0)
        draw = ImageDraw.Draw(mask)
        draw.rounded_rectangle([(0, 0), image.size], radius=radius, fill=255)
        
        # Aplicar máscara
        result = Image.new("RGBA", image.size, (0, 0, 0, 0))
        result.paste(image, (0, 0))
        result.putalpha(mask)
        
        return result
    
    def _draw_spotibar(self, draw, image, progress_ms, duration_ms, y_position, font_time):
        """Desenha a barra de progresso spotibar com tempos ao lado da barra"""
        # Obter configurações da skin do Spotlight
        spotlight_skin = self.get_setting("spotlight_skin", 0)
        skin_config = SPOTLIGHT_SKIN_STYLE.get(spotlight_skin, SPOTLIGHT_SKIN_STYLE[0])
        
        # Configurações da barra - largura igual à capa (457px)
        cover_width = 457  # Largura da capa
        bar_width = 350    # Largura da barra (menor que a capa para dar espaço aos tempos)
        bar_height = 8     # Altura normal, não muito fina
        
        # Tempos
        current_time = self._format_time(progress_ms)
        total_time = self._format_time(duration_ms)
        
        # Usar fonte padrão SourceSansPro
        try:
            font_default = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
        except Exception:
            font_default = font_time  # Fallback para fonte padrão
        
        # Calcular larguras dos tempos para posicionamento
        try:
            current_width = draw.textlength(current_time, font=font_default)
            total_width = draw.textlength(total_time, font=font_default)
        except:
            try:
                left, top, right, bottom = font_default.getbbox(current_time)
                current_width = right - left
                left, top, right, bottom = font_default.getbbox(total_time)
                total_width = right - left
            except:
                current_width = len(current_time) * 8  # Estimativa
                total_width = len(total_time) * 8
        
        # Posicionamento dentro da margem da capa (457px)
        cover_x = (567 - cover_width) // 2  # Posição da capa
        spacing = 15  # Espaçamento entre tempo e barra
        
        # Centralizar tudo dentro da largura da capa
        total_width_needed = current_width + spacing + bar_width + spacing + total_width
        start_x = cover_x + (cover_width - total_width_needed) // 2
        
        # Posições
        current_x = start_x
        bar_x = current_x + current_width + spacing
        total_x = bar_x + bar_width + spacing
        bar_offset = 5  # Ajuste independente da barra (+ para baixo, - para cima)
        bar_y = y_position + bar_offset
        
        # Calcular progresso
        progress_ratio = min(progress_ms / duration_ms, 1.0) if duration_ms > 0 else 0
        progress_width = int(bar_width * progress_ratio)
        
        # Desenhar barra de fundo com efeito glass (blur + overlay semi-transparente escuro)
        if skin_config.get("use_blur_bg", False):
            try:
                # Extrair a área da imagem onde a barra será desenhada
                blur_area = image.crop((
                    bar_x, bar_y, 
                    bar_x + bar_width, bar_y + bar_height
                ))

                # Aplicar blur na área extraída para suavizar o fundo
                blurred_area = blur_area.filter(ImageFilter.GaussianBlur(radius=10))

                # Criar uma sobreposição translúcida escura para efeito vidro fosco
                overlay = Image.new('RGBA', (bar_width, bar_height), (30, 30, 30, 120))  # Cinza escuro semi-transparente

                # Combinar blur com overlay escura
                glass_effect = Image.alpha_composite(blurred_area.convert('RGBA'), overlay)

                # Criar máscara com cantos arredondados para a barra
                mask = Image.new('L', (bar_width, bar_height), 0)
                mask_draw = ImageDraw.Draw(mask)
                mask_draw.rounded_rectangle(
                    [(0, 0), (bar_width - 1, bar_height - 1)],
                    radius=4,
                    fill=255
                )

                # Aplicar máscara para manter cantos arredondados
                glass_effect.putalpha(mask)

                # Colar efeito vidro na imagem principal
                image.paste(glass_effect, (bar_x, bar_y), glass_effect)

            except Exception as e:
                # Fallback para cor sólida mais clara e transparente
                draw.rounded_rectangle(
                    [(bar_x, bar_y), (bar_x + bar_width, bar_y + bar_height)],
                    radius=4,
                    fill=(60, 60, 60, 100)  # Menos opaco que antes
                )
        else:
            # Cor sólida normal (sem blur)
            draw.rounded_rectangle(
                [(bar_x, bar_y), (bar_x + bar_width, bar_y + bar_height)],
                radius=4,
                fill=skin_config["bar_bg_color"]
            )
        
        # Desenhar barra de progresso
        if progress_width > 0:
            draw.rounded_rectangle(
                [(bar_x, bar_y), (bar_x + progress_width, bar_y + bar_height)],
                radius=4,
                fill=skin_config["bar_fill_color"]
            )
        
        # Posicionar tempos independentemente da barra
        try:
            left, top, right, bottom = font_default.getbbox("0")
            text_height = bottom - top
        except:
            text_height = 24  # Altura estimada
        text_y = y_position + (bar_height - text_height) // 2  # Usar posição original dos tempos
        
        # Tempo atual (esquerda)
        draw.text((current_x, text_y), current_time, font=font_default, fill=skin_config["time_color"])
        
        # Tempo total (direita)
        draw.text((total_x, text_y), total_time, font=font_default, fill=skin_config["time_color"])
    
    def _format_time(self, ms):
        """Formata tempo em milissegundos para mm:ss"""
        if ms is None:
            return "0:00"
        seconds = int(ms / 1000)
        minutes = seconds // 60
        seconds = seconds % 60
        return f"{minutes}:{seconds:02d}"
    
    def _get_universal_youtube_key(self):
        """Key Universal UT - Experimental"""
        # Chave criptografada com XOR + base64
        _encrypted_key = "a2NQS3lTaX1nYB17dXx8RUZ8SUFQRmV4YU1vZXtgRVNGcmRGfERJ"
        _xor_salt = 42
        
        try:
            # Decodifica base64 e aplica XOR reverso
            encrypted_bytes = base64.b64decode(_encrypted_key)
            decrypted = ''.join(chr(b ^ _xor_salt) for b in encrypted_bytes)
            return decrypted
        except Exception:
            # Fallback em caso de erro na descriptografia
            return "AIzaSyCWMJ7Q_VVolVckzlORKgEOQJoylXNlVnc"

    def _generate_vinni_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera card do tema Vinni com design personalizado - dimensões 1012x512"""
        try:
            # Criar imagem base 1012x512
            img = Image.new("RGB", (1012, 512), (0, 0, 0))
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            
            # Obter capa do álbum
            if etg_cover_image is not None:
                cover_image = etg_cover_image
            else:
                # Detectar player atual
                player_name = self._detect_current_player()

                # FM (Active Player) - suportar Vinify como SoundCloud
                if player_name == "FM":
                    images = track.get("album", {}).get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0)).get("url") if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception:
                            # Fallback YouTube-first unificado para FM
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        # Fallback YouTube-first unificado para FM
                        cover_image = self._get_fallback_cover(title, artists)
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music"):
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para {player_name}: {e}")
                        cover_image = Image.new("RGBA", (375, 375), (30, 30, 30, 255))
                elif player_name == "SoundCloud":
                    youtube_cover_url = self._get_youtube_cover(title, artists)
                    if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                        youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                    try:
                        cover_data = self._get_cached_image_enhanced(youtube_cover_url, f"yt_cover_{hash(youtube_cover_url)}")
                        if cover_data:
                            cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                        else:
                            raise Exception("Failed to download cover from cache")
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                        cover_image = Image.new("RGBA", (375, 375), (30, 30, 30, 255))
                else:
                    # Lógica para outros players
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            cover_data = self._get_cached_image_enhanced(cover_url, f"album_cover_{hash(cover_url)}")
                            if cover_data:
                                cover_image = Image.open(BytesIO(cover_data)).convert("RGBA")
                            else:
                                raise Exception("Failed to download cover from cache")
                        except Exception:
                            cover_image = self._get_fallback_cover(title, artists)
                    else:
                        cover_image = self._get_fallback_cover(title, artists)
            
            # Armazenar a capa para uso no gradiente da barra de progresso
            self._current_album_cover = cover_image
            
            # Criar fundo com base nas novas opções do Vinify UI
            if cover_image:
                # Determinar imagem de fundo: BG Style, Custom BG ou capa
                custom_bg_enabled = self.get_setting("vinify_custom_bg_enable", False)
                custom_bg_url = self.get_setting("vinify_custom_bg_url", "").strip()
                bg_style = self.get_setting("vinify_bg_style", 0)  # 0=None, 1=Obsidian, 2=Morph, 3=Noir, 4=Ethereal, 5=Ethereal Mirage, 6=Silken, 7=Mock, 8=Random
                shadow_style = self.get_setting("vinify_shadow_style", 0)  # 0=None, 1=Black, 2=White, 3=Gradient

                bg_image = None
                style_url = None
                if bg_style == 1:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Obsidian.png"
                elif bg_style == 2:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Morph.png"
                elif bg_style == 3:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Noir.png"
                elif bg_style == 4:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal.png"
                elif bg_style == 5:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal%20Mirage.png"
                elif bg_style == 6:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Silken.png"
                elif bg_style == 7:
                    style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Mock.png"
                elif bg_style == 8:
                    try:
                        import random
                        rand_style = random.choice([1, 2, 3, 4, 5, 6, 7])
                        if rand_style == 1:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Obsidian.png"
                        elif rand_style == 2:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Morph.png"
                        elif rand_style == 3:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Noir.png"
                        elif rand_style == 4:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal.png"
                        elif rand_style == 5:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Ethereal%20Mirage.png"
                        elif rand_style == 6:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Silken.png"
                        else:
                            style_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Mock.png"
                    except Exception as e:
                        log(f"[NowFy] Random BG selection failed: {e}")
                        style_url = None

                if style_url:
                    try:
                        style_data = self._get_cached_image_enhanced(style_url, f"vinify_bg_style_{bg_style}")
                        if style_data:
                            bg_image = Image.open(BytesIO(style_data)).convert("RGBA")
                    except Exception as e:
                        log(f"[NowFy] Falha ao carregar BG Style: {e}")
                        bg_image = None
                elif custom_bg_enabled and custom_bg_url:
                    try:
                        custom_data = self._get_cached_image_enhanced(custom_bg_url, f"vinify_custom_bg_{hash(custom_bg_url)}")
                        if custom_data:
                            bg_image = Image.open(BytesIO(custom_data)).convert("RGBA")
                    except Exception as e:
                        log(f"[NowFy] Falha ao carregar Custom BG: {e}")
                        bg_image = None

                # Fallback para capa do álbum se não houver imagem de fundo definida
                if bg_image is None:
                    bg_image = cover_image

                # Redimensionar imagem de fundo para cobrir todo o fundo 1012x512 mantendo proporção
                background_cover = self._resize_with_aspect_ratio_vinni(bg_image, (1012, 512))
                
                # Aplicar flip horizontal se ativado
                flip_background = self.get_setting("vinify_flip_background", False)
                if flip_background:
                    background_cover = background_cover.transpose(Image.FLIP_LEFT_RIGHT)
                
                # Obter configuração do efeito de fundo
                background_effect = self.get_setting("vinify_background_effect", 0)
                
                # Aplicar efeitos baseados na seleção
                if background_effect == 1:  # Album Colors (Cores do Álbum)
                    # Extrair cores dominantes da capa e criar um fundo gradiente com cores puras
                    try:
                        # Redimensionar a capa para análise mais rápida
                        small_cover = cover_image.resize((50, 50), Image.LANCZOS)
                        # Converter para RGB se necessário
                        if small_cover.mode != 'RGB':
                            small_cover = small_cover.convert('RGB')
                        
                        # Extrair cores dominantes usando quantização
                        quantized = small_cover.quantize(colors=4)
                        palette = quantized.getpalette()
                        
                        # Obter as 4 cores mais dominantes
                        colors = []
                        for i in range(4):
                            r = palette[i*3]
                            g = palette[i*3 + 1] 
                            b = palette[i*3 + 2]
                            colors.append((r, g, b))
                        
                        # Criar fundo com gradiente radial das cores extraídas
                        color_bg = Image.new('RGB', (1012, 512), colors[0])  # Cor base
                        draw = ImageDraw.Draw(color_bg)
                        
                        # Criar gradiente radial com múltiplas cores
                        center_x, center_y = 506, 256
                        max_radius = 600
                        
                        # Desenhar círculos concêntricos com as cores
                        for radius in range(max_radius, 0, -8):
                            # Calcular qual cor usar baseado no raio
                            ratio = radius / max_radius
                            if ratio > 0.75:
                                color = colors[0]
                            elif ratio > 0.5:
                                # Interpolar entre cor 0 e 1
                                t = (ratio - 0.5) / 0.25
                                color = tuple(int(colors[0][i] * t + colors[1][i] * (1-t)) for i in range(3))
                            elif ratio > 0.25:
                                # Interpolar entre cor 1 e 2
                                t = (ratio - 0.25) / 0.25
                                color = tuple(int(colors[1][i] * t + colors[2][i] * (1-t)) for i in range(3))
                            else:
                                # Interpolar entre cor 2 e 3
                                t = ratio / 0.25
                                color = tuple(int(colors[2][i] * t + colors[3][i] * (1-t)) for i in range(3))
                            
                            # Desenhar círculo com a cor interpolada
                            bbox = [center_x - radius, center_y - radius, center_x + radius, center_y + radius]
                            draw.ellipse(bbox, fill=color)
                        
                        # Aplicar overlay escuro para garantir legibilidade do texto
                        overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 100))  # 40% de opacidade
                        color_bg = color_bg.convert("RGBA")
                        img = Image.alpha_composite(color_bg, overlay).convert("RGB")
                        
                    except Exception as e:
                        log(f"[NowFy] Erro ao aplicar efeito Album Colors: {e}")
                        # Fallback para gradiente padrão colorido
                        fallback_bg = Image.new('RGB', (1012, 512), (60, 60, 120))
                        draw = ImageDraw.Draw(fallback_bg)
                        for y in range(512):
                            ratio = y / 512
                            color = (int(60 + ratio * 100), int(60 + ratio * 80), int(120 + ratio * 60))
                            draw.line([(0, y), (1012, y)], fill=color)
                        overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 100))
                        fallback_bg = fallback_bg.convert("RGBA")
                        img = Image.alpha_composite(fallback_bg, overlay).convert("RGB")
                        
                elif background_effect == 2:  # Blur
                    background_cover = background_cover.filter(ImageFilter.GaussianBlur(radius=15))
                    img = background_cover.convert("RGB")
                elif background_effect == 3:  # Darker
                    # Aplicar escurecimento sutil (overlay escuro 30%)
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 77))  # 30% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                elif background_effect == 4:  # Both (Blur + Darker)
                    # Aplicar blur
                    background_cover = background_cover.filter(ImageFilter.GaussianBlur(radius=15))
                    # Aplicar escurecimento (overlay escuro 40%)
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 102))  # 40% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                else:  # None (0)
                    # Aplicar escurecimento muito sutil para não ficar muito claro
                    overlay = Image.new("RGBA", (1012, 512), (0, 0, 0, 25))  # 10% de opacidade
                    background_cover = background_cover.convert("RGBA")
                    background_cover = Image.alpha_composite(background_cover, overlay)
                    img = background_cover.convert("RGB")
                
                # Aplicar overlay de Shadow sobre o fundo (após o efeito)
                if shadow_style in (1, 2, 3):
                    shadow_urls = {
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow.png",
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow_white.png",
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/shadow_gradient.png"
                    }
                    shadow_url = shadow_urls.get(shadow_style)
                    try:
                        shadow_data = self._get_cached_image_enhanced(shadow_url, f"vinify_shadow_{shadow_style}")
                        if shadow_data:
                            shadow_img = Image.open(BytesIO(shadow_data)).convert("RGBA")
                            if shadow_img.size != (1012, 512):
                                shadow_img = shadow_img.resize((1012, 512), Image.LANCZOS)
                            base_rgba = img.convert("RGBA")
                            img = Image.alpha_composite(base_rgba, shadow_img).convert("RGB")
                    except Exception as e:
                        log(f"[NowFy] Falha ao aplicar Shadow overlay: {e}")
                
                # Verificar se o swap layout está habilitado
                swap_layout = self.get_setting("vinify_swap_layout", False)
                
                # Redimensionar capa para 375x375 mantendo proporção (corte central)
                try:
                    cover_display = ImageOps.fit(cover_image, (375, 375), method=Image.LANCZOS, centering=(0.5, 0.5))
                except Exception:
                    # Fallback em caso de erro: usar resize padrão
                    cover_display = cover_image.resize((375, 375), Image.LANCZOS)
                
                # Aplicar bordas arredondadas na capa
                mask = Image.new("L", (375, 375), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, 375, 375), 25, fill=255)
                cover_display = cover_display.convert("RGBA")
                cover_display.putalpha(mask)
                
                # Posicionar capa baseado no swap layout
                if swap_layout:
                    # Capa à direita
                    cover_x = 1012 - 60 - 375  # Margem direita de 60px
                    img.paste(cover_display, (cover_x, 68), cover_display)
                    # Área de texto à esquerda
                    text_x = 60  # Margem esquerda
                    text_width = cover_x - text_x - 40  # Largura disponível para texto (margem entre texto e capa)
                else:
                    # Capa à esquerda (padrão)
                    cover_x = 60
                    img.paste(cover_display, (cover_x, 68), cover_display)
                    # Área de texto à direita
                    text_x = 475  # Início do texto após a capa (60 + 375 + 40 margem)
                    text_width = 1012 - text_x - 50  # Largura disponível para texto (margem direita aumentada para evitar texto na borda)
            
            draw = ImageDraw.Draw(img)
            
            # Configurar fontes com suporte a custom fonts
            font_selector = self.get_setting("font_selector", 0)
            
            try:
                # Usar sistema de custom fonts para título (bold)
                font_title_path = self._get_font_path_by_selector(font_selector)
                font_title = ImageFont.truetype(font_title_path, 44)
            except:
                font_title = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 44)
            
            try:
                # Usar sistema de custom fonts para artista (regular)
                font_artist_path = self._get_font_regular_by_selector(font_selector)
                font_artist = ImageFont.truetype(font_artist_path, 24)
            except:
                font_artist = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            
            try:
                # Fonte padrão para tempo
                font_time = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 20)
            except:
                font_time = ImageFont.load_default()
            
            # Área de texto (baseada no swap layout)
            # text_x e text_width já foram definidos acima baseado no swap_layout
            
            # Alinhamento vertical dos textos com a capa do álbum
            capa_y = 68  # Posição Y da capa
            
            # Título da música (negrito, branco) - alinhado com o topo da capa
            title_y = capa_y  # Alinhado exatamente com o topo da capa
            
            # Quebra de linha automática para título
            title_lines = self._wrap_text_vinni(title, font_title, text_width)
            for i, line in enumerate(title_lines[:2]):  # Máximo 2 linhas
                draw.text((text_x, title_y + i * 50), line, font=font_title, fill=(255, 255, 255))
            
            # Nome do artista (maiúsculas, branco com opacidade)
            artist_text = artists.upper()
            artist_y = title_y + len(title_lines[:2]) * 50 + 20
            
            # Quebra de linha automática para artista
            artist_lines = self._wrap_text_vinni(artist_text, font_artist, text_width)
            for i, line in enumerate(artist_lines[:2]):  # Máximo 2 linhas
                draw.text((text_x, artist_y + i * 30), line, font=font_artist, fill=(217, 217, 217))  # 85% opacidade
            
            # Calcular posição Y após o artista
            current_y = artist_y + len(artist_lines[:2]) * 30 + 10
            
            # Exibir nome do álbum/playlist baseado no modo selecionado (apenas para tema Vinify)
            album_name = self._get_album_or_playlist_name(track)
            if album_name:
                try:
                    # Usar sistema de custom fonts para álbum (bold)
                    font_album_path = self._get_font_path_by_selector(font_selector)
                    font_album = ImageFont.truetype(font_album_path, 20)
                except:
                    font_album = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 20)
                
                # Quebra de linha automática para álbum/playlist
                album_lines = self._wrap_text_vinni(album_name, font_album, text_width)
                for i, line in enumerate(album_lines[:1]):  # Máximo 1 linha
                    draw.text((text_x, current_y + i * 25), line, font=font_album, fill=(255, 255, 255))  # Branco, negrito
                current_y += len(album_lines[:1]) * 25 + 10
            
            # Exibir informações do dispositivo ou perfil do usuário se habilitado (apenas para tema Vinify)
            device_y = 375 - 50  # Posição fixa acima da barra de progresso
            device_profile_mode = self.get_setting("vinify_device_profile_mode", 0)  # 0 = Show Device, 1 = My Profile, 2 = Custom Name, 3 = None

            # Auto-ativar Custom Name para .fm/.stats quando houver nome personalizado configurado
            try:
                player_name = self._detect_current_player()
            except Exception:
                player_name = "Spotify"
            track_source = track.get("source", "")
            vinify_name = self.get_setting("vinify_custom_display_name", "").strip()
            fm_name = self.get_setting("fm_custom_player_name", "").strip()
            if (player_name == "FM" or track_source == "statsfm" or is_fm_command) and (vinify_name or fm_name):
                device_profile_mode = 2
            
            if device_profile_mode == 0:  # Show Device
                device_full_info = self._get_current_device_full_info()
                if device_full_info:
                    try:
                        # Fonte padrão para dispositivo
                        font_device_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_device_name = ImageFont.load_default()
                    
                    # Obter ícone SVG baseado no tipo do dispositivo
                    device_type = device_full_info.get("type", "computer")
                    
                    # Usar nome personalizado se configurado, senão usar o nome detectado
                    custom_device_name = self.get_setting("vinify_device_name", "")
                    if custom_device_name.strip():
                        device_name = custom_device_name.strip()
                    else:
                        device_name = device_full_info.get("name", "Unknown Device")
                    
                    # URLs dos ícones PNG para cada tipo de dispositivo - URLs corretos e funcionais
                    device_icon_urls = {
                        "smartphone": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/mobile.png",
                        "computer": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/computer.png", 
                        "speaker": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/speaker.png",
                        "tv": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/tv.png",
                        "web": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/web.png"
                    }
                    
                    # Obter URL do ícone baseado no tipo do dispositivo
                    icon_url = device_icon_urls.get(device_type, device_icon_urls["computer"])
                    
                    try:
                        # Usar o sistema de cache nativo do plugin com cache key específico para ícones de dispositivo
                        cache_key = f"device_icon_{device_type}"
                        log(f"[Nowfy] Tentando carregar ícone do dispositivo: {device_type} - URL: {icon_url}")
                        icon_data = self._get_cached_image_enhanced(icon_url, cache_key)
                        if icon_data:
                            log(f"[Nowfy] Ícone carregado com sucesso: {len(icon_data)} bytes")
                            icon_image = Image.open(BytesIO(icon_data)).convert("RGBA")
                            
                            # Redimensionar ícone para 20x20 pixels
                            icon_size = 20
                            icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                            
                            # Colar o ícone na posição
                            img.paste(icon_image, (text_x, device_y), icon_image)
                            icon_width = icon_size + 8  # Espaço após o ícone
                        else:
                            log(f"[Nowfy] Falha ao carregar ícone do dispositivo {device_type}, usando fallback emoji")
                            # Fallback: usar texto simples se não conseguir baixar o ícone
                            fallback_text = {
                                "smartphone": "📱",
                                "computer": "💻", 
                                "speaker": "🔊",
                                "tv": "📺",
                                "web": "🌐"
                            }.get(device_type, "💻")
                            draw.text((text_x, device_y), fallback_text, font=font_device_name, fill=(255, 255, 255))
                            icon_width = 25
                    except Exception as e:
                        log(f"[Nowfy] Erro ao carregar ícone do dispositivo {device_type}: {str(e)}")
                        # Fallback em caso de erro
                        fallback_text = {
                            "smartphone": "📱",
                            "computer": "💻", 
                            "speaker": "🔊",
                            "tv": "📺",
                            "web": "🌐"
                        }.get(device_type, "💻")
                        draw.text((text_x, device_y), fallback_text, font=font_device_name, fill=(255, 255, 255))
                        icon_width = 25
                    
                    # Desenhar nome do dispositivo em negrito e maiúsculas
                    device_name_upper = device_name.upper()
                    draw.text((text_x + icon_width, device_y), device_name_upper, font=font_device_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 1:  # My Profile
                spotify_profile = self._get_spotify_user_profile()
                if spotify_profile:
                    try:
                        # Fonte padrão para perfil
                        font_profile_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_profile_name = ImageFont.load_default()
                    
                    # Obter nome do perfil
                    profile_name = spotify_profile.get("display_name", spotify_profile.get("id", "Spotify User"))
                    
                    # Tentar carregar a imagem de perfil
                    profile_image_url = spotify_profile.get("profile_image_url", "")
                    icon_width = 0
                    
                    if profile_image_url:
                        try:
                            # Usar o sistema de cache nativo do plugin com cache key específico para imagens de perfil
                            cache_key = f"profile_image_{hash(profile_image_url)}"
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 20x20 pixels
                                profile_size = 20
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (text_x, device_y), profile_image)
                                icon_width = profile_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading profile image: {str(e)}")
                    
                    # Se não conseguiu carregar a imagem, usar ícone fy.png como fallback
                    if icon_width == 0:
                        try:
                            # Tentar carregar o ícone fy.png como fallback
                            fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                            cache_key = "fallback_fy_icon_profile"
                            fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                            if fallback_data:
                                fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                                
                                # Redimensionar ícone para 18x18 pixels (ligeiramente menor para melhor aparência)
                                fallback_size = 18
                                fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                                
                                # Colar o ícone na posição
                                img.paste(fallback_image, (text_x, device_y), fallback_image)
                                icon_width = fallback_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading fallback fy.png icon for profile: {str(e)}")
                        
                        # Se ainda não conseguiu carregar, usar emoji como último fallback
                        if icon_width == 0:
                            draw.text((text_x, device_y), "👤", font=font_profile_name, fill=(255, 255, 255))
                            icon_width = 25
                    
                    # Desenhar nome do perfil em negrito e maiúsculas
                    profile_name_upper = profile_name.upper()
                    draw.text((text_x + icon_width, device_y), profile_name_upper, font=font_profile_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 2:  # Custom Name
                custom_display_name = self.get_setting("vinify_custom_display_name", "").strip() or self.get_setting("fm_custom_player_name", "").strip()
                if custom_display_name.strip():
                    try:
                        # Fonte padrão para nome personalizado
                        font_custom_name = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 18)
                    except:
                        font_custom_name = ImageFont.load_default()
                    
                    # Usar a mesma lógica de imagem de perfil do My Profile
                    icon_width = 0
                    try:
                        # Obter informações do perfil do Spotify (mesmo que My Profile)
                        profile_info = self._get_spotify_user_profile()
                        if profile_info and profile_info.get("images"):
                            profile_image_url = profile_info["images"][0]["url"]
                            cache_key = f"profile_{hashlib.md5(profile_image_url.encode()).hexdigest()}"
                            
                            # Carregar imagem de perfil com cache
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 20x20 pixels
                                profile_size = 20
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (text_x, device_y), profile_image)
                                icon_width = profile_size + 8  # Espaço após a imagem
                    except Exception as e:
                        log(f"[Nowfy] Error loading profile image for custom name: {str(e)}")
                    
                    # Se não conseguiu carregar a imagem, usar ícone fy.png como fallback
                    if icon_width == 0:
                        try:
                            # Tentar carregar o ícone fy.png como fallback
                            fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                            cache_key = "fallback_fy_icon"
                            fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                            if fallback_data:
                                fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                                
                                # Redimensionar ícone para 18x18 pixels
                                fallback_size = 18
                                fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                                
                                # Colar o ícone na posição
                                img.paste(fallback_image, (text_x, device_y), fallback_image)
                                icon_width = fallback_size + 8  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading fallback fy.png icon: {str(e)}")
                        
                        # Se ainda não conseguiu carregar, usar emoji como último fallback
                        if icon_width == 0:
                            draw.text((text_x, device_y), "✨", font=font_custom_name, fill=(255, 255, 255))
                            icon_width = 25
                    
                    # Desenhar nome personalizado em negrito e maiúsculas
                    custom_name_upper = custom_display_name.strip().upper()
                    draw.text((text_x + icon_width, device_y), custom_name_upper, font=font_custom_name, fill=(255, 255, 255))
            
            elif device_profile_mode == 3:  # Profile & Device
                # Layout combinado: foto do perfil + nome do usuário + ícone do dispositivo + nome do dispositivo
                try:
                    # Fonte padrão para perfil e dispositivo
                    font_profile_device = ImageFont.truetype("/system/fonts/SourceSansPro-Bold.ttf", 16)
                except:
                    font_profile_device = ImageFont.load_default()
                
                current_x = text_x
                
                # 1. Carregar e exibir foto do perfil
                profile_info = self._get_spotify_user_profile()
                profile_width = 0
                
                if profile_info:
                    profile_image_url = profile_info.get("profile_image_url", "")
                    if profile_image_url:
                        try:
                            cache_key = f"profile_image_{hash(profile_image_url)}"
                            profile_data = self._get_cached_image_enhanced(profile_image_url, cache_key)
                            if profile_data:
                                profile_image = Image.open(BytesIO(profile_data)).convert("RGBA")
                                
                                # Redimensionar imagem de perfil para 18x18 pixels
                                profile_size = 18
                                profile_image = profile_image.resize((profile_size, profile_size), Image.LANCZOS)
                                
                                # Aplicar bordas arredondadas na imagem de perfil
                                mask = Image.new("L", (profile_size, profile_size), 0)
                                ImageDraw.Draw(mask).ellipse((0, 0, profile_size, profile_size), fill=255)
                                profile_image.putalpha(mask)
                                
                                # Colar a imagem de perfil na posição
                                img.paste(profile_image, (current_x, device_y + 1), profile_image)
                                profile_width = profile_size + 6  # Espaço após a imagem
                        except Exception as e:
                            log(f"[Nowfy] Error loading profile image for Profile & Device: {str(e)}")
                
                # Se não conseguiu carregar a imagem de perfil, usar ícone fy.png como fallback
                if profile_width == 0:
                    try:
                        fallback_url = "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/fy.png"
                        cache_key = "fallback_fy_icon_profile_device"
                        fallback_data = self._get_cached_image_enhanced(fallback_url, cache_key)
                        if fallback_data:
                            fallback_image = Image.open(BytesIO(fallback_data)).convert("RGBA")
                            
                            # Redimensionar ícone para 18x18 pixels
                            fallback_size = 18
                            fallback_image = fallback_image.resize((fallback_size, fallback_size), Image.LANCZOS)
                            
                            # Colar o ícone na posição
                            img.paste(fallback_image, (current_x, device_y), fallback_image)
                            profile_width = fallback_size + 6  # Espaço após a imagem
                    except Exception as e:
                        log(f"[Nowfy] Error loading fallback fy.png icon for Profile & Device: {str(e)}")
                    
                    # Se ainda não conseguiu carregar, usar emoji como último fallback
                    if profile_width == 0:
                        draw.text((current_x, device_y), "👤", font=font_profile_device, fill=(255, 255, 255))
                        profile_width = 20
                
                current_x += profile_width
                
                # 2. Exibir nome do usuário
                if profile_info:
                    profile_name = profile_info.get("display_name", profile_info.get("id", "User"))
                    draw.text((current_x, device_y), profile_name.upper(), font=font_profile_device, fill=(255, 255, 255))
                    
                    # Calcular largura do nome do usuário para posicionar o próximo elemento
                    try:
                        bbox = font_profile_device.getbbox(profile_name.upper())
                        name_width = bbox[2] - bbox[0] + 12  # Espaço após o nome
                    except:
                        name_width = len(profile_name) * 8 + 12  # Fallback aproximado
                    
                    current_x += name_width
                
                # 3. Adicionar separador "•" antes do ícone do dispositivo
                draw.text((current_x, device_y), "•", font=font_profile_device, fill=(255, 255, 255))
                current_x += 15  # Espaço após o separador
                
                # 4. Carregar e exibir ícone do dispositivo
                device_full_info = self._get_current_device_full_info()
                device_icon_width = 0
                
                if device_full_info:
                    device_type = device_full_info.get("type", "computer")
                    
                    # URLs dos ícones PNG para cada tipo de dispositivo
                    device_icon_urls = {
                        "smartphone": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/mobile.png",
                        "computer": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/computer.png", 
                        "speaker": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/speaker.png",
                        "tv": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/tv.png",
                        "web": "https://raw.githubusercontent.com/soumaki/nowFy/main/icons/web.png"
                    }
                    
                    icon_url = device_icon_urls.get(device_type, device_icon_urls["computer"])
                    
                    try:
                        cache_key = f"device_icon_{device_type}_profile_device"
                        icon_data = self._get_cached_image_enhanced(icon_url, cache_key)
                        if icon_data:
                            icon_image = Image.open(BytesIO(icon_data)).convert("RGBA")
                            
                            # Redimensionar ícone para 16x16 pixels
                            icon_size = 16
                            icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                            
                            # Colar o ícone na posição
                            img.paste(icon_image, (current_x, device_y + 2), icon_image)
                            device_icon_width = icon_size + 6  # Espaço após o ícone
                    except Exception as e:
                        log(f"[Nowfy] Error loading device icon for Profile & Device: {str(e)}")
                        # Fallback: usar emoji
                        fallback_text = {
                            "smartphone": "📱",
                            "computer": "💻", 
                            "speaker": "🔊",
                            "tv": "📺",
                            "web": "🌐"
                        }.get(device_type, "💻")
                        draw.text((current_x, device_y), fallback_text, font=font_profile_device, fill=(255, 255, 255))
                        device_icon_width = 18
                    
                    current_x += device_icon_width
                    
                    # 5. Exibir nome do dispositivo
                    custom_device_name = self.get_setting("vinify_device_name", "")
                    if custom_device_name.strip():
                        device_name = custom_device_name.strip()
                    else:
                        device_name = device_full_info.get("name", "Unknown Device")
                    
                    draw.text((current_x, device_y), device_name.upper(), font=font_profile_device, fill=(255, 255, 255))
            
            # Barra de progresso na parte inferior - POSIÇÃO BASEADA NO LAYOUT
            progress_y = 375  # Posição fixa independente do tamanho do texto (capa_y=68 + 375 - 45)
            
            # Ajustar posição X e largura da barra de progresso baseado no swap layout
            # A barra deve ficar alinhada com os textos, não com a capa
            if swap_layout:
                # Barra alinhada com os textos à esquerda
                progress_x = text_x  # Mesma posição X dos textos
                progress_width = text_width  # Mesma largura da área de texto
            else:
                # Barra alinhada com os textos à direita (padrão)
                progress_x = text_x  # Mesma posição X dos textos
                progress_width = text_width  # Mesma largura da área de texto
            
            # Ocultar ViniBar no Vinify quando for comando .fm (LastFM)
            current_player = self._detect_current_player()
            if not is_fm_command:
                self._draw_vinni_progress_bar_new(draw, track, progress_ms, font_time, progress_x, progress_y, progress_width)
            
            # Adicionar logo da plataforma (apenas para Spotify e Apple Music)
            if current_player in ["Spotify", "Apple Music"]:
                platform_logo_option = self.get_setting("vinify_platform_logo", 0)
                self._add_platform_logo_vinify(img, current_player, platform_logo_option, swap_layout)
            
            # Durante o comando .fm (LastFM): usar overlays por player quando suportado;
            # caso contrário (inclui player FM), aplicar overlay do LastFM.
            if is_fm_command:
                try:
                    player_overlay_map = {
                        "YouTube": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yt.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yt_swap.png",
                        },
                        "YouTube Music": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/ytmusic.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/ytmusic_swap.png",
                        },
                        "SoundCloud": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/soundcloud.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/soundcloud_swap.png",
                        },
                        "exteraGram": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/etg.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/etg_swap.png",
                        },
                        "AyuGram": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/ayu.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/ayu_swap.png",
                        },
                        "Yandex Music": {
                            "normal": "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex.png",
                            "swap":   "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/yandex_swap.png",
                        },
                    }
                    if current_player in player_overlay_map:
                        overlay_url = player_overlay_map[current_player]["swap" if swap_layout else "normal"]
                        response = requests.get(overlay_url, timeout=10)
                        if response.status_code == 200:
                            overlay_image = Image.open(BytesIO(response.content)).convert("RGBA")
                            if overlay_image.size != (1012, 512):
                                overlay_image = overlay_image.resize((1012, 512), Image.LANCZOS)
                            img = Image.alpha_composite(img.convert("RGBA"), overlay_image).convert("RGB")
                            log(f"[Nowfy] Overlay {current_player} aplicado durante .fm com sucesso")
                        else:
                            log(f"[Nowfy] Erro ao baixar overlay {current_player} (.fm): HTTP {response.status_code}")
                    else:
                        overlay_url = (
                            "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/lastfm_swap.png"
                            if swap_layout
                            else "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/lastfm.png"
                        )
                        response = requests.get(overlay_url, timeout=10)
                        if response.status_code == 200:
                            overlay_image = Image.open(BytesIO(response.content)).convert("RGBA")
                            overlay_image = overlay_image.resize((1012, 512), Image.LANCZOS)
                            img = Image.alpha_composite(img.convert("RGBA"), overlay_image).convert("RGB")
                            log(f"[Nowfy] Overlay LastFM aplicado durante .fm com sucesso")
                        else:
                            log(f"[Nowfy] Erro ao baixar overlay LastFM (.fm): HTTP {response.status_code}")
                except Exception as e:
                    log(f"[Nowfy] Erro ao aplicar overlay durante .fm: {e}")
            
            # Salvar imagem
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")
    
    def _wrap_text_vinni(self, text, font, max_width):
        """Quebra texto em linhas para o tema Vinni"""
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            try:
                bbox = font.getbbox(test_line)
                text_width = bbox[2] - bbox[0]
            except:
                text_width = len(test_line) * 10  # Fallback aproximado
            
            if text_width <= max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                    current_line = word
                else:
                    lines.append(word)  # Palavra muito longa, adiciona mesmo assim
        
        if current_line:
            lines.append(current_line)
        
        return lines
    
    def _resize_with_aspect_ratio_vinni(self, img, target_size):
        """Redimensiona a imagem com crop inteligente para remover bordas pretas e evitar distorção"""
        width, height = img.size
        target_width, target_height = target_size
        
        # Detectar e remover bordas pretas automaticamente
        img_cropped = self._remove_black_borders(img)
        width, height = img_cropped.size
        
        # Calcular proporções
        img_ratio = width / height
        target_ratio = target_width / target_height
        
        # Estratégia: sempre preencher completamente o espaço (crop inteligente)
        if img_ratio > target_ratio:
            # Imagem mais larga que o target - crop nas laterais
            new_height = target_height
            new_width = round(new_height * img_ratio)
            resized_img = img_cropped.resize((new_width, new_height), Image.LANCZOS)
            
            # Crop centralizado
            crop_x = (new_width - target_width) // 2
            final_img = resized_img.crop((crop_x, 0, crop_x + target_width, target_height))
        else:
            # Imagem mais alta que o target - crop em cima/baixo
            new_width = target_width
            new_height = round(new_width / img_ratio)
            resized_img = img_cropped.resize((new_width, new_height), Image.LANCZOS)
            
            # Crop centralizado
            crop_y = (new_height - target_height) // 2
            final_img = resized_img.crop((0, crop_y, target_width, crop_y + target_height))
        
        # Garantir que a imagem final tenha exatamente o tamanho target
        if final_img.size != target_size:
            final_img = final_img.resize(target_size, Image.LANCZOS)
        
        return final_img
    
    def _remove_black_borders(self, img):
        """Remove bordas pretas da imagem automaticamente"""
        try:
            import numpy as np
            
            # Converter para array numpy
            img_array = np.array(img)
            
            # Se for RGBA, usar apenas RGB para detecção
            if img_array.shape[2] == 4:
                rgb_array = img_array[:, :, :3]
            else:
                rgb_array = img_array
            
            # Detectar pixels que não são pretos (threshold baixo para capturar quase-pretos)
            # Considera preto qualquer pixel com todos os canais RGB < 30
            non_black_mask = np.any(rgb_array > 30, axis=2)
            
            # Encontrar limites da área não-preta
            rows = np.any(non_black_mask, axis=1)
            cols = np.any(non_black_mask, axis=0)
            
            if not np.any(rows) or not np.any(cols):
                # Se toda a imagem for preta, retornar original
                return img
            
            # Encontrar coordenadas de crop
            top, bottom = np.where(rows)[0][[0, -1]]
            left, right = np.where(cols)[0][[0, -1]]
            
            # Adicionar pequena margem para evitar cortar conteúdo importante
            margin = 2
            top = max(0, top - margin)
            left = max(0, left - margin)
            bottom = min(img.height - 1, bottom + margin)
            right = min(img.width - 1, right + margin)
            
            # Crop apenas se houver bordas significativas (> 5% da imagem)
            crop_threshold = 0.05
            if (top > img.height * crop_threshold or 
                left > img.width * crop_threshold or 
                (img.height - bottom) > img.height * crop_threshold or 
                (img.width - right) > img.width * crop_threshold):
                
                return img.crop((left, top, right + 1, bottom + 1))
            
            return img
            
        except Exception as e:
            # Em caso de erro, retornar imagem original
            log(f"[Nowfy] Erro ao remover bordas pretas: {e}")
            return img
    
    def _add_platform_logo_vinify(self, img, player, logo_option, swap_layout):
        """Adiciona logo da plataforma no tema Vinify como overlay"""
        try:
            # Log de debug para rastrear a execução
            log(f"[Nowfy] Platform Logo Debug - player: {player}, logo_option: {logo_option}, swap_layout: {swap_layout}")
            
            # Se a opção "None" (índice 0) estiver selecionada, não aplicar logo
            if logo_option == 0:
                log(f"[Nowfy] Platform Logo: Opção 'None' selecionada, não aplicando logo")
                return
            
            # Ajustar índice para as opções de logo (subtrair 1 porque "None" é índice 0)
            adjusted_logo_option = logo_option - 1
            log(f"[Nowfy] Platform Logo: Índice ajustado: {adjusted_logo_option}")
            
            # URLs dos logos baseados na plataforma, opção de cor, swap layout e posição
            logo_urls = {
                "Spotify": {
                    "normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_green_and_white.png",  # Green & White
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_white_and_green.png",  # White & Green
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_black_and_white.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_white_and_black.png"   # White & Black
                    },
                    "swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/white_and_green_swap.png",  # White & Green
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/green_and_white_swap.png",  # Green & White
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/black_and_white_swap.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/white_and_black_swap.png"   # White & Black
                    },
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_green_and_white.png",  # Green & White (inferior)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_green.png",  # White & Green (inferior)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_black_and_white.png",  # Black & White (inferior)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_black.png"   # White & Black (inferior)
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_green_and_white_swap.png",  # Green & White (inferior swap)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_green_swap.png",  # White & Green (inferior swap)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_black_and_white_swap.png",  # Black & White (inferior swap)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/spotify_inf_white_and_black_swap.png"   # White & Black (inferior swap)
                    }
                },
                "Apple Music": {
                    "normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_red_and_white.png",  # Red & White
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_red.png",  # White & Red
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_black_and_white.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_black.png"   # White & Black
                    },
                    "swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_red_swap.png",  # White & Red
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_red_and_white_swap.png",  # Red & White
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_black_and_white_swap.png",  # Black & White
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_white_and_black_swap.png"   # White & Black
                    },
                    "inf_normal": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_red_and_white.png",  # Red & White (inferior)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_red.png",  # White & Red (inferior)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_black_and_white.png",  # Black & White (inferior)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_black.png"   # White & Black (inferior)
                    },
                    "inf_swap": {
                        0: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_red_and_white_swap.png",  # Red & White (inferior swap)
                        1: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_red_swap.png",  # White & Red (inferior swap)
                        2: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_black_and_white_swap.png",  # Black & White (inferior swap)
                        3: "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/plataform/apple_inf_white_and_black_swap.png"   # White & Black (inferior swap)
                    }
                }
            }
            
            # Determinar layout (swap ou normal) e posição (superior/inferior)
            layout_type = "swap" if swap_layout else "normal"
            logo_position = self.get_setting("vinify_logo_position", 0)  # 0: Superior, 1: Inferior
            if logo_position == 1:
                layout_type = "inf_swap" if swap_layout else "inf_normal"
            log(f"[Nowfy] Platform Logo: Layout type: {layout_type}")
            
            # Obter URL do logo usando o índice ajustado
            logo_url = logo_urls.get(player, {}).get(layout_type, {}).get(adjusted_logo_option)
            log(f"[Nowfy] Platform Logo: URL do logo: {logo_url}")
            if not logo_url:
                log(f"[Nowfy] Platform Logo: URL não encontrada para player={player}, layout={layout_type}, option={adjusted_logo_option}")
                return
            
            # Carregar logo com cache
            cache_key = f"platform_logo_{player.lower().replace(' ', '_')}_{layout_type}_{adjusted_logo_option}"
            log(f"[Nowfy] Platform Logo: Cache key: {cache_key}")
            logo_data = self._get_cached_image_enhanced(logo_url, cache_key)
            if not logo_data:
                log(f"[Nowfy] Platform Logo: Falha ao carregar dados da imagem do logo")
                return
            
            log(f"[Nowfy] Platform Logo: Logo carregado com sucesso, aplicando overlay")
            logo_image = Image.open(BytesIO(logo_data)).convert("RGBA")
            
            # Como é overlay, usar o tamanho completo do card (1012x512)
            card_size = (1012, 512)
            logo_image = logo_image.resize(card_size, Image.LANCZOS)
            
            # Aplicar logo como overlay na posição (0, 0) cobrindo todo o card
            img.paste(logo_image, (0, 0), logo_image)
            log(f"[Nowfy] Platform Logo: Overlay aplicado com sucesso")
            
        except Exception as e:
            log(f"[Nowfy] Error adding platform logo: {str(e)}")
    
    def _draw_vinni_progress_bar_new(self, draw, track, progress_ms, font_time, x, y, width, use_blur_override=None):
        """Desenha a barra de progresso do tema Vinni ao lado direito da capa"""
        # Configurações da barra
        progress_y = y
        progress_x = x
        progress_width = width
        progress_height = 10
        
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        
        # Log de depuração para ViniBar
        log(f"[NowFy] ViniBar Debug - progress_ms: {progress_ms}, duration_ms: {duration_ms}, track: {track.get('name', 'Unknown')}")
        
        # Obter configurações de cores da ViniBar
        color_options = [
            (255, 255, 255, 255),  # Branco
            (255, 0, 0, 255),      # Vermelho
            (255, 127, 0, 255),    # Laranja
            (255, 255, 0, 255),    # Amarelo
            (0, 255, 0, 255),      # Verde
            (0, 0, 255, 255),      # Azul
            (75, 0, 130, 255),     # Índigo
            (148, 0, 211, 255)     # Violeta
        ]
        
        dark_color_options = [
            (128, 128, 128, 8),    # Cinza (padrão)
            (128, 0, 0, 8),       # Vermelho escuro
            (128, 64, 0, 8),      # Laranja escuro
            (128, 128, 0, 8),     # Amarelo escuro
            (0, 128, 0, 8),       # Verde escuro
            (0, 0, 128, 8),       # Azul escuro
            (64, 0, 64, 8),       # Índigo escuro
            (75, 0, 96, 8)        # Violeta escuro
        ]
        
        # Obter índices das cores selecionadas
        bar_color_index = self.get_setting("vinify_bar_color", 0)
        bg_color_index = self.get_setting("vinify_bar_bg_color", 0)
        use_gradient = self.get_setting("vinify_bar_gradient", False)
        # Permitir override para usar efeito vidro (glass) por padrão no Nowv
        use_blur = self.get_setting("vinify_bar_blur", False) if use_blur_override is None else bool(use_blur_override)
        
        # Cores padrão caso os índices estejam fora do intervalo
        bar_color = color_options[min(bar_color_index, len(color_options) - 1)]
        bg_color = dark_color_options[min(bg_color_index, len(dark_color_options) - 1)]
        
        # Fundo da barra com efeito de blur ou cor selecionada
        if use_blur and hasattr(draw, '_image'):
            try:
                # EFEITO DE BLUR ATIVADO: Criar efeito de vidro translúcido
                log(f"[NowFy] ViniBar Blur ATIVO - Aplicando efeito de vidro")
                
                # Extrair a área da imagem onde a barra será desenhada
                blur_area = draw._image.crop((
                    progress_x, progress_y, 
                    progress_x + progress_width, progress_y + progress_height
                ))
                
                # Aplicar blur na área extraída
                blurred_area = blur_area.filter(ImageFilter.GaussianBlur(radius=8))
                
                # Criar uma sobreposição translúcida para o efeito de vidro
                overlay = Image.new('RGBA', (progress_width, progress_height), (255, 255, 255, 40))
                
                # Combinar o blur com a sobreposição
                glass_effect = Image.alpha_composite(blurred_area.convert('RGBA'), overlay)
                
                # Criar máscara com cantos arredondados
                mask = Image.new('L', (progress_width, progress_height), 0)
                mask_draw = ImageDraw.Draw(mask)
                mask_draw.rounded_rectangle(
                    [(0, 0), (progress_width - 1, progress_height - 1)],
                    radius=5,
                    fill=255
                )
                
                # Aplicar a máscara ao efeito de vidro
                glass_effect.putalpha(mask)
                
                # Colar o efeito de vidro na imagem principal
                draw._image.paste(glass_effect, (progress_x, progress_y), glass_effect)
                
            except Exception as e:
                log(f"[NowFy] Erro no efeito de blur, usando cor sólida: {e}")
                # Fallback para cor sólida
                draw.rounded_rectangle(
                    [(progress_x, progress_y), (progress_x + progress_width, progress_y + progress_height)],
                    radius=5,
                    fill=bg_color
                )
        else:
            # EFEITO DE BLUR DESATIVADO: Usar cor selecionada
            draw.rounded_rectangle(
                [(progress_x, progress_y), (progress_x + progress_width, progress_y + progress_height)],
                radius=5,
                fill=bg_color
            )
        
        # Calcular progresso
        if duration_ms > 0:
            progress_ratio = min(progress_ms / duration_ms, 1.0)
            filled_width = int(progress_width * progress_ratio)
            
            # Barra preenchida com a cor selecionada ou gradiente
            if filled_width > 0:
                if use_gradient:
                    try:
                        # GRADIENTE ATIVADO: Usar cores da capa do álbum
                        log(f"[NowFy] ViniBar Gradient ATIVO - Extraindo cores da capa do álbum")
                        
                        # Tentar obter a capa do álbum atual
                        album_cover = None
                        
                        # Verificar se temos acesso à capa através da função _generate_vinni_card
                        # Buscar a capa na função pai ou usar uma referência global
                        if hasattr(self, '_current_album_cover') and self._current_album_cover:
                            album_cover = self._current_album_cover
                        else:
                            # Tentar obter a capa do track atual
                            try:
                                current_track = self._get_current_track()
                                if current_track and current_track.get('album', {}).get('images'):
                                    images = current_track['album']['images']
                                    cover_url = max(images, key=lambda i: i['width'])['url'] if images else None
                                    if cover_url:
                                        cover_data = self._get_cached_image_enhanced(cover_url, f"gradient_cover_{hash(cover_url)}")
                                        if cover_data:
                                            album_cover = Image.open(BytesIO(cover_data)).convert('RGB')
                            except Exception as e:
                                log(f"[NowFy] Erro ao obter capa para gradiente: {e}")
                        
                        if album_cover:
                            # Extrair cores da capa usando a função existente
                            extracted_colors = self._extract_colors_from_cover(album_cover, 0)  # Modo dominante + variação
                            
                            # Converter cores hex para RGB
                            def hex_to_rgb(hex_color):
                                hex_color = hex_color.lstrip('#')
                                return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
                            
                            start_color = hex_to_rgb(extracted_colors[0]) + (255,)
                            end_color = hex_to_rgb(extracted_colors[1]) + (255,)
                            
                            log(f"[NowFy] Cores extraídas da capa: {extracted_colors[0]} -> {extracted_colors[1]}")
                        else:
                            # Fallback: gradiente dinâmico baseado no tempo
                            import time
                            import colorsys
                            
                            current_time = int(time.time() * 2) % 360
                            h1 = (current_time / 360.0) % 1.0
                            s1, v1 = 0.8, 0.9
                            r1, g1, b1 = colorsys.hsv_to_rgb(h1, s1, v1)
                            start_color = (int(r1 * 255), int(g1 * 255), int(b1 * 255), 255)
                            
                            h2 = (h1 + 0.3) % 1.0
                            r2, g2, b2 = colorsys.hsv_to_rgb(h2, s1, v1)
                            end_color = (int(r2 * 255), int(g2 * 255), int(b2 * 255), 255)
                            
                            log(f"[NowFy] Usando gradiente dinâmico (fallback): {start_color} -> {end_color}")
                        
                        # NOVA IMPLEMENTAÇÃO: Criar gradiente diretamente na imagem principal
                        # Criar uma imagem temporária para o gradiente completo
                        gradient_img = Image.new('RGBA', (filled_width, progress_height), (0, 0, 0, 0))
                        
                        # Desenhar o gradiente preenchendo completamente a área
                        for x_pos in range(filled_width):
                            # Calcular a cor do gradiente para esta posição
                            if filled_width > 1:
                                ratio = x_pos / (filled_width - 1)
                            else:
                                ratio = 0
                            
                            # Interpolar as cores
                            r = int(start_color[0] * (1 - ratio) + end_color[0] * ratio)
                            g = int(start_color[1] * (1 - ratio) + end_color[1] * ratio)
                            b = int(start_color[2] * (1 - ratio) + end_color[2] * ratio)
                            
                            # Desenhar uma linha vertical com a cor interpolada
                            for y_pos in range(progress_height):
                                gradient_img.putpixel((x_pos, y_pos), (r, g, b, 255))
                        
                        # Criar máscara com cantos arredondados
                        mask = Image.new('L', (filled_width, progress_height), 0)
                        mask_draw = ImageDraw.Draw(mask)
                        mask_draw.rounded_rectangle(
                            [(0, 0), (filled_width - 1, progress_height - 1)],
                            radius=5,
                            fill=255
                        )
                        
                        # Aplicar a máscara ao gradiente
                        gradient_img.putalpha(mask)
                        
                        # Colar o gradiente na imagem principal, sobrepondo completamente a barra de fundo
                        if hasattr(draw, '_image'):
                            # Primeiro, desenhar um retângulo sólido para cobrir completamente o fundo
                            temp_draw = ImageDraw.Draw(draw._image)
                            temp_draw.rounded_rectangle(
                                [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                                radius=5,
                                fill=(0, 0, 0, 0)  # Transparente para limpar a área
                            )
                            
                            # Agora colar o gradiente
                            draw._image.paste(gradient_img, (progress_x, progress_y), gradient_img)
                        else:
                            # Fallback: usar método de desenho direto
                            self._draw_gradient_fallback(draw, progress_x, progress_y, filled_width, progress_height, start_color, end_color)
                        
                    except Exception as e:
                        # Fallback para cor sólida em caso de erro
                        log(f"[NowFy] Erro no gradiente, usando cor sólida: {e}")
                        draw.rounded_rectangle(
                            [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                            radius=5,
                            fill=bar_color
                        )
                else:
                    # GRADIENTE DESATIVADO: Usar cor selecionada nos seletores
                    log(f"[NowFy] ViniBar Gradient DESATIVADO - Usando cor selecionada: {bar_color}")
                    draw.rounded_rectangle(
                        [(progress_x, progress_y), (progress_x + filled_width, progress_y + progress_height)],
                        radius=5,
                        fill=bar_color
                    )
        
        # Função para formatar tempo
        def ms_to_minsec(ms):
            m = int(ms // 60000)
            s = int((ms % 60000) // 1000)
            return f"{m}:{s:02d}"
        
        # Tempo atual e total
        current_time = ms_to_minsec(progress_ms)
        total_time = ms_to_minsec(duration_ms)
        
        # Tempo atual (esquerda)
        draw.text((progress_x, progress_y + 20), current_time, font=font_time, fill=(255, 255, 255))
        
        # Tempo total (direita)
        try:
            total_time_bbox = draw.textbbox((0, 0), total_time, font=font_time)
            total_time_width = total_time_bbox[2] - total_time_bbox[0]
        except:
            total_time_width = len(total_time) * 10  # Fallback aproximado
        
        draw.text((progress_x + progress_width - total_time_width, progress_y + 20), total_time, font=font_time, fill=(255, 255, 255))
    
    def _draw_gradient_fallback(self, draw, x, y, width, height, start_color, end_color):
        """Método fallback para desenhar gradiente quando não há acesso direto à imagem"""
        try:
            # Dividir em segmentos menores para um gradiente mais suave
            segments = min(width, 50)  # Máximo de 50 segmentos
            segment_width = width / segments
            
            for i in range(segments):
                # Calcular posição e largura do segmento
                seg_x = x + int(i * segment_width)
                seg_width = int((i + 1) * segment_width) - int(i * segment_width)
                
                # Calcular cor interpolada
                ratio = i / (segments - 1) if segments > 1 else 0
                r = int(start_color[0] * (1 - ratio) + end_color[0] * ratio)
                g = int(start_color[1] * (1 - ratio) + end_color[1] * ratio)
                b = int(start_color[2] * (1 - ratio) + end_color[2] * ratio)
                
                # Desenhar segmento
                if i == 0:  # Primeiro segmento com cantos arredondados à esquerda
                    draw.rounded_rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        radius=5,
                        fill=(r, g, b, 255)
                    )
                elif i == segments - 1:  # Último segmento com cantos arredondados à direita
                    draw.rounded_rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        radius=5,
                        fill=(r, g, b, 255)
                    )
                else:  # Segmentos do meio sem cantos arredondados
                    draw.rectangle(
                        [(seg_x, y), (seg_x + seg_width, y + height)],
                        fill=(r, g, b, 255)
                    )
        except Exception as e:
            log(f"[NowFy] Erro no fallback do gradiente: {e}")
            # Último recurso: cor sólida
            draw.rounded_rectangle(
                [(x, y), (x + width, y + height)],
                radius=5,
                fill=start_color
            )
    
    def _draw_vinni_progress_bar(self, draw, track, progress_ms=None):
        """Desenha a barra de progresso personalizada do tema Vinni (versão antiga)"""
        bar_width = 260
        bar_height = 6
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 35
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        
        # Barra de fundo (cinza escuro)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(60, 60, 70, 26)
        )
        
        # Barra de progresso (azul vibrante)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(100, 150, 255, 255)
        )
        
        # Handle (círculo azul)
        handle_radius = 8
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(100, 150, 255, 255)
        )
        
        # Tempos
        def ms_to_minsec(ms):
            m = int(ms // 60000)
            s = int((ms % 60000) // 1000)
            return f"{m}:{s:02d}"
        
        font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 22)
        time_current = ms_to_minsec(progress_ms)
        time_total = ms_to_minsec(duration_ms)
        # Usando método alternativo para calcular altura do texto
        font_height = font.size
        text_y = bar_y + bar_height // 2 - font_height // 2
        draw.text((bar_x, text_y - 30), time_current, font=font, fill=(176, 176, 176, 255))
        # Estimativa simples para largura do texto
        time_width = len(time_total) * (font.size // 2)
        draw.text((bar_x + bar_width - time_width, text_y - 30), time_total, font=font, fill=(176, 176, 176, 255))

    def _generate_apple_light_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        try:
            base_path = self._ensure_card_base_image(theme=0)
            img = Image.open(base_path).convert("RGBA")
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            target_size = (298, 298)

            # Usar a imagem de capa do ETG se disponível
            if etg_cover_image is not None:
                # Aplicar anti-aliasing avançado do Apple UI
                cover = self._apply_apple_antialiasing(etg_cover_image, target_size)
            else:
                player_name = self._detect_current_player()

                if player_name == "SoundCloud":
                    # Primeiro tentar obter capa diretamente do SoundCloud
                    soundcloud_cover_url = self.get_soundcloud_cover(title, artists)
                    if soundcloud_cover_url:
                        try:
                            resp = requests.get(soundcloud_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do SoundCloud: {e}")
                            # Fallback para YouTube apenas se SoundCloud falhar
                            youtube_cover_url = self._get_youtube_cover(title, artists)
                            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                            try:
                                resp = requests.get(youtube_cover_url, timeout=10)
                                resp.raise_for_status()
                                cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                                cover = self._apply_apple_antialiasing(cover, target_size)
                            except Exception:
                                cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                    else:
                        # Fallback para YouTube se SoundCloud não retornar capa
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        try:
                            resp = requests.get(youtube_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                            cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music"):
                    # Lógica dedicada: obter capa do YouTube/YouTube Music
                    try:
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        cover = self._apply_apple_antialiasing(cover, target_size)
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube: {e}")
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
                else:
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            # Tentar baixar diretamente como no Apple Dark
                            resp = requests.get(cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception:
                            # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                            cover = self._get_fallback_cover(title, artists)
                    else:
                        cover = self._get_fallback_cover(title, artists)

            # Não aplicar máscara adicional aqui, pois o raio já foi aplicado pelo _apply_apple_antialiasing
            img.paste(cover, (70, 153), cover)
            draw = ImageDraw.Draw(img)

            # Verificar se é Last.FM com Spotify configurado para ocultar exteraBar
            media_source = self.get_setting("media_source", 0)
            current_player_setting = self.get_setting("current_player", 0)
            is_lastfm_with_spotify = media_source == 1 and current_player_setting == 0  # Last.FM + Spotify
            
            # Mostrar exteraBar apenas se não for Last.FM com Spotify
            if self.get_setting("show_extera_bar", True) and not is_lastfm_with_spotify:
                player = self._detect_current_player()
                # exteraBar funciona apenas com Spotify, Apple Music e players .fm (não exteraGram/AyuGram)
                if player in ["Spotify", "Apple Music"] or (player and ".fm" in player.lower()):
                    self.exteraBarSeek(draw, track, progress_ms)

            font_selector = self.get_setting("font_selector", 0)
            max_font_size = 54
            min_font_size = 36
            base_font_size = 42
            if len(title) <= 10:
                font_size = max_font_size
            elif len(title) <= 18:
                font_size = int(base_font_size + (max_font_size - base_font_size) * (18 - len(title)) / 8)
            else:
                font_size = min_font_size

            # Fonte do título e artista: selecionada/custom
            font_path_bold = self._get_font_path_by_selector(font_selector)
            font_path_regular = self._get_font_regular_by_selector(font_selector)
            try:
                font_title = ImageFont.truetype(font_path_bold, font_size)
            except Exception as e:
                log(f"[Nowfy] Erro ao carregar fonte bold {font_path_bold}: {e}")
                font_title = ImageFont.load_default()

            if self._is_arabic(artists):
                try:
                    font_artist = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 25)
                except Exception:
                    font_artist = ImageFont.load_default()
            else:
                try:
                    font_artist = ImageFont.truetype(font_path_regular, 25)
                except Exception as e:
                    log(f"[Nowfy] Erro ao carregar fonte regular {font_path_regular}: {e}")
                    font_artist = ImageFont.load_default()

            # Fonte padrão para 'Playing'
            try:
                font_playing = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 26)
            except Exception:
                font_playing = ImageFont.load_default()

            text_x = 400
            text_y = 160
            max_text_width = 600
            playing_text = tr("playing")

            text_y = self.draw_multiline_text(draw, playing_text, (text_x, text_y), font_playing, "#888888", max_text_width)
            text_y += 12
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, "#000000", max_text_width)
            text_y += 20
            self.draw_multiline_text(draw, artists, (text_x, text_y), font_artist, "#888888", max_text_width)

            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")


    def exteraBarSeek(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa ---
        bar_width = 260  # Largura menor
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2  # Centralizada em relação à capa
        bar_y = 153 - 30  # 30px acima da capa
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        # Proteção para não ultrapassar a barra
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # --- Desenhar barra de fundo (cinza médio) ---
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(180, 180, 180, 255)  # Cinza mais escuro, mas ainda sutil
        )
        # --- Desenhar barra de progresso (preta) ---
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(40, 40, 40, 255)
        )
        # --- Desenhar handle (círculo) ---
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(40, 40, 40, 255)
        )
        # --- Tempo atual e total ---
        # Nota: Esta função só é chamada quando não é Last.FM com Spotify
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            # Tempo atual real à esquerda da barra
            left, top, right, bottom = font.getbbox("Ay")
            text_y = bar_y + bar_height // 2 - (bottom - top) // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(40, 40, 40, 255))
            # Tempo total à direita da barra
            left, top, right, bottom = font.getbbox(time_total)
            draw.text((bar_x + bar_width - (right - left), text_y - 28), time_total, font=font, fill=(40, 40, 40, 255))

    def _generate_nowv_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None, is_fm_command=False):
        """Gera o card do tema Nowv (1280x719) com capa central e overlays"""
        try:
            import io
            from PIL import Image, ImageDraw, ImageFilter, ImageOps, ImageFont

            W, H = 1280, 719
            canvas = Image.new("RGB", (W, H), (12, 12, 12))
            draw = ImageDraw.Draw(canvas)

            # Metadados
            title = track.get("name") or track.get("title") or "Unknown Track"
            artists_list = track.get("artists", [])
            if isinstance(artists_list, list) and artists_list and isinstance(artists_list[0], dict):
                artists = ", ".join([a.get("name", "") for a in artists_list])
            else:
                artists = track.get("artist") or track.get("artists_text") or "Unknown Artist"

            # Capa
            cover = None
            if etg_cover_image:
                try:
                    cover = Image.open(io.BytesIO(etg_cover_image)).convert("RGB")
                except Exception:
                    cover = None
            if cover is None:
                image_url = None
                images = track.get("album", {}).get("images", []) if isinstance(track.get("album"), dict) else []
                if images:
                    try:
                        image_url = max(images, key=lambda i: i.get("width", 0)).get("url")
                    except Exception:
                        image_url = images[0].get("url")
                if image_url:
                    try:
                        image_bytes = self._get_cached_image_enhanced(image_url, cache_key=image_url)
                        cover = Image.open(io.BytesIO(image_bytes)).convert("RGB")
                    except Exception:
                        cover = None
            if cover is None:
                try:
                    cover = self._get_fallback_cover(title, artists)
                    if cover:
                        cover = cover.convert("RGB")
                except Exception:
                    cover = None

            # Verificar se Banner Style está ativado
            banner_style = self.get_setting("nowv_banner_style", False)
            
            if banner_style:
                # Banner Style: Usar apenas fundo da capa sem efeitos
                if cover is not None:
                    bg = cover.copy()
                    # Redimensionar para cobrir o canvas mantendo proporção e recortar centralizado
                    try:
                        scale = max(W / float(bg.width), H / float(bg.height))
                        new_w = int(bg.width * scale)
                        new_h = int(bg.height * scale)
                        bg = bg.resize((new_w, new_h), Image.LANCZOS)
                        left = max(0, (new_w - W) // 2)
                        top = max(0, (new_h - H) // 2)
                        bg = bg.crop((left, top, left + W, top + H))
                    except Exception:
                        bg = bg.resize((W, H), Image.LANCZOS)
                    canvas = bg
                    draw = ImageDraw.Draw(canvas)
                else:
                    draw.rectangle([0, 0, W, H], fill=(20, 20, 22))
            else:
                # Modo normal: Fundo com efeitos
                bg_effect = self.get_setting("nowv_background_effect", 0)
                flip_bg = self.get_setting("nowv_flip_background", False)
                if cover is not None:
                    bg = cover.copy()
                    # Redimensionar para cobrir o canvas mantendo proporção e recortar centralizado
                    try:
                        scale = max(W / float(bg.width), H / float(bg.height))
                        new_w = int(bg.width * scale)
                        new_h = int(bg.height * scale)
                        bg = bg.resize((new_w, new_h), Image.LANCZOS)
                        left = max(0, (new_w - W) // 2)
                        top = max(0, (new_h - H) // 2)
                        bg = bg.crop((left, top, left + W, top + H))
                    except Exception:
                        # Fallback simples caso algo falhe
                        bg = bg.resize((W, H), Image.LANCZOS)
                    if flip_bg:
                        bg = ImageOps.mirror(bg)
                    if bg_effect == 1:  # Blur
                        bg = bg.filter(ImageFilter.GaussianBlur(24))
                    elif bg_effect == 2:  # Darker
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 140))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    elif bg_effect == 3:  # Both
                        bg = bg.filter(ImageFilter.GaussianBlur(24))
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 140))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    else:
                        overlay = Image.new("RGBA", (W, H), (0, 0, 0, 90))
                        bg = bg.convert("RGBA")
                        bg.alpha_composite(overlay)
                        bg = bg.convert("RGB")
                    canvas = bg
                    draw = ImageDraw.Draw(canvas)
                else:
                    draw.rectangle([0, 0, W, H], fill=(20, 20, 22))

            # Capa central e overlay (dependendo do modo)
            if banner_style:
                # Banner Style: Adicionar overlay baseado no NowvBar Style
                nowv_bar_style = self.get_setting("nowv_bar_style", 0)
                overlay_url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Style1.png" if nowv_bar_style == 0 else "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/bg/Style2.png"
                
                try:
                    # Baixar e aplicar overlay
                    overlay_data = self._get_cached_image_enhanced(overlay_url, f"nowv_overlay_style{nowv_bar_style + 1}")
                    if overlay_data:
                        overlay_img = Image.open(io.BytesIO(overlay_data)).convert("RGBA")
                        # Redimensionar overlay para o tamanho do canvas
                        overlay_img = overlay_img.resize((W, H), Image.LANCZOS)
                        # Aplicar overlay sobre o canvas
                        canvas = canvas.convert("RGBA")
                        canvas = Image.alpha_composite(canvas, overlay_img)
                        canvas = canvas.convert("RGB")
                        draw = ImageDraw.Draw(canvas)
                except Exception as e:
                    log(f"[NowFy] Erro ao aplicar overlay Banner Style: {e}")
            else:
                # Modo normal: Capa central com cantos arredondados e glass effect
                if cover is not None:
                    s = min(cover.width, cover.height)
                    l = (cover.width - s) // 2
                    t = (cover.height - s) // 2
                    cover_sq = cover.crop((l, t, l + s, t + s)).resize((512, 512), Image.LANCZOS)
                    mask = Image.new("L", (512, 512), 0)
                    mdraw = ImageDraw.Draw(mask)
                    try:
                        mdraw.rounded_rectangle((0, 0, 512, 512), radius=36, fill=255)
                    except Exception:
                        mdraw.rectangle((0, 0, 512, 512), fill=255)
                    cx = (W - 512) // 2
                    cy = 84
                    # Criar painel de vidro atrás da capa (glass effect)
                    try:
                        bg_region = canvas.crop((cx, cy, cx + 512, cy + 512))
                        blurred_bg = bg_region.filter(ImageFilter.GaussianBlur(12))
                        glass_overlay = Image.new("RGBA", (512, 512), (255, 255, 255, 48))
                        glass_panel = Image.alpha_composite(blurred_bg.convert("RGBA"), glass_overlay)
                        glass_panel.putalpha(mask)
                        canvas.paste(glass_panel, (cx, cy), glass_panel)
                    except Exception:
                        pass
                    canvas.paste(cover_sq, (cx, cy), mask)

            # Tipografia (apenas fonte de tempo; remover título e artista)
            font_selector = self.get_setting("font_selector", 0)
            try:
                time_font = ImageFont.truetype(self._get_font_regular_by_selector(font_selector), 22)
            except Exception:
                time_font = ImageFont.load_default()

            def text_w(font, text):
                try:
                    bbox = font.getbbox(text)
                    return bbox[2] - bbox[0]
                except Exception:
                    return draw.textlength(text, font=font)

            # Barra de progresso (NowvBar) - Compatível apenas com Spotify API, StatsFM e Apple Music
            current_player = self._detect_current_player()
            compatible_players = ["Spotify", "Apple Music"]
            
            # Verificar se é StatsFM (player pode ser "StatsFM" ou similar)
            is_statsfm = current_player == "StatsFM" or (hasattr(self, '_is_statsfm_mode') and self._is_statsfm_mode)
            
            duration_ms = track.get("duration_ms") or track.get("duration") or 0
            if (duration_ms and progress_ms is not None and 
                (current_player in compatible_players or is_statsfm or force_spotify)):
                
                try:
                    ratio = max(0.0, min(1.0, float(progress_ms) / float(duration_ms)))
                except Exception:
                    ratio = 0.0
                
                # Configurar NowvBar baseado no estilo selecionado
                nowv_bar_style = self.get_setting("nowv_bar_style", 0)
                
                if nowv_bar_style == 1:  # Style 2 - Compacto
                    bw = 512  # Largura da capa
                    bx = (W - bw) // 2  # Centralizado como a capa
                    by = H - 84
                else:  # Style 1 - Padrão
                    bw = 800
                    bx = (W - bw) // 2
                    by = H - 84
                
                # Usar ViniBar com efeito vidro (glass) como padrão
                self._draw_vinni_progress_bar_new(draw, track, progress_ms, time_font, bx, by, bw, use_blur_override=True)

            # Salvar e enviar
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            temp_path = File(temp_dir, f"nowv_{int(time.time()*1000)}.png").getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            canvas.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
            return temp_path
        except Exception as e:
            log(f"[NowFy] Erro ao gerar card Nowv: {e}")
            try:
                if params:
                    self._send_msg(params, f"Erro: {e}")
            except Exception:
                pass
            return None

    def _send_card_with_caption(self, params, temp_path, track, force_spotify=False):
        """Envia o card com caption personalizada"""
        try:
            show_caption = self.get_setting("show_caption", True)
            # Verificar se está no modo NowCast para usar bot_caption
            is_nowcast_mode = getattr(self, '_nowcast_mode', False)
            
            # Verificar se show_caption está ativado
            if not show_caption:
                # Se show_caption está OFF, enviar apenas o card sem caption
                params["caption"] = ""
                self._send_photo(params, temp_path)
                return
            
            # Obter o estilo de caption selecionado
            caption_style_index = self.get_setting("caption_style", 0)
            caption_style_items = ["Custom", "Apple Based", "Pepe", "Minim", "Spoty"]
            caption_style = caption_style_items[caption_style_index] if caption_style_index < len(caption_style_items) else "Custom"
            
            if is_nowcast_mode:
                custom_caption = self.get_setting("bot_caption_text", "")
            else:
                custom_caption = self.get_setting("custom_footer_text", "")
            
            show_track_link = self.get_setting("show_track_link", True)
            platform_links = self.get_setting("platform_links", 0)  # 0=Spotify, 1=Universal, 2=Both
            
            # Detectar o player real para links corretos
            real_player = self._detect_current_player()
            # Se force_spotify=True (comando .now), usar Spotify para compatibilidade, mas manter player real para links
            if force_spotify:
                player = "Spotify"
                # Para temas Apple, usar o player real para links corretos
                link_player = real_player
            else:
                player = real_player
                link_player = real_player
            
            # Montar link/caption de acordo com o serviço selecionado
            caption_parts = []
            used_link_placeholders = False
            
            # Processar caption baseado no estilo selecionado
            if caption_style == "Custom":
                # Usar caption personalizado (comportamento original)
                if custom_caption:
                    # Processar variáveis {track}, {artist} e {album} no custom caption
                    processed_caption = custom_caption.strip()
                    if "{track}" in processed_caption or "{artist}" in processed_caption or "{album}" in processed_caption or "{spotify}" in processed_caption or "{song}" in processed_caption:
                        title = track.get("name", "Unknown Track")
                        artists = ", ".join([a["name"] for a in track.get("artists", [])]) if track.get("artists") else "Unknown Artist"
                        album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                        # Links para placeholders
                        spotify_link = None
                        try:
                            external_urls = track.get("external_urls")
                            if isinstance(external_urls, dict):
                                spotify_link = external_urls.get("spotify")
                        except Exception:
                            spotify_link = None
                        song_link_url = None
                        try:
                            if spotify_link:
                                song_link_url = self._get_song_link(spotify_link)
                        except Exception:
                            song_link_url = None
                        processed_caption = processed_caption.replace("{track}", title)
                        processed_caption = processed_caption.replace("{artist}", artists)
                        processed_caption = processed_caption.replace("{album}", album)
                        # Substituição dos novos placeholders {spotify} e {song}
                        if "{spotify}" in processed_caption:
                            processed_caption = processed_caption.replace("{spotify}", spotify_link or "")
                        if "{song}" in processed_caption:
                            processed_caption = processed_caption.replace("{song}", song_link_url or "")
                        # Marcar que placeholders de link foram usados para evitar duplicação de links automáticos
                        used_link_placeholders = ("{spotify}" in custom_caption) or ("{song}" in custom_caption)
                    caption_parts.append(processed_caption)
            else:
                # Usar template predefinido
                title = track.get("name", "Unknown Track")
                artists = ", ".join([a["name"] for a in track.get("artists", [])]) if track.get("artists") else "Unknown Artist"
                album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                
                track_data = {
                    "name": title,
                    "artist": artists,
                    "album": album
                }
                
                template_caption = self._get_caption_template(caption_style, track_data)
                if template_caption:
                    caption_parts.append(template_caption)
            
            # Adicionar links apenas se show_track_link estiver ativado e não houver links via placeholders
            if show_track_link and not used_link_placeholders:
                # Verificar se estamos usando Last.FM com Spotify configurado
                media_source = self.get_setting("media_source", 0)
                current_player_setting = self.get_setting("current_player", 0)
                is_lastfm_with_spotify = media_source == 1 and current_player_setting == 0  # Last.FM + Spotify
                
                if link_player == "Spotify" or is_lastfm_with_spotify:
                    spotify_link = track["external_urls"]["spotify"]
                    
                    # Lógica baseada no novo Platform Links selector
                    if platform_links == 0:  # Spotify only
                        caption_parts.append(f"[Spotify]({spotify_link})")
                    elif platform_links == 1:  # Universal only
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")
                    elif platform_links == 2:  # Both
                        caption_parts.append(f"[Spotify]({spotify_link})")
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")

                elif link_player == "YouTube":
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])} official music video"
                    yt_link = f"https://www.youtube.com/results?search_query={quote(search_query)}"
                    caption_parts.append(f"[YouTube]({yt_link})")

                elif link_player == "YouTube Music":
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                    ytm_link = f"https://music.youtube.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[YouTube Music]({ytm_link})")

                elif link_player == "SoundCloud":
                    external_urls = track.get("external_urls")
                    soundcloud_url = None
                    if isinstance(external_urls, dict):
                        soundcloud_url = external_urls.get("soundcloud")
                    if not soundcloud_url:
                        search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                        soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[SoundCloud]({soundcloud_url})")

                elif link_player == "Apple Music":
                    # Gerar link de busca do Apple Music
                    search_query = f"{track['name']} {', '.join([a['name'] for a in track['artists']])}"
                    apple_music_url = f"https://music.apple.com/search?term={quote(search_query)}"
                    caption_parts.append(f"[Apple Music]({apple_music_url})")

                elif link_player == "Yandex Music":
                    # Usar song.link como universal para Yandex Music
                    if track.get("external_urls", {}).get("spotify"):
                        spotify_link = track["external_urls"]["spotify"]
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[Yandex Music]({song_link_url})")

                elif link_player in ["exteraGram", "AyuGram"]:
                    # Adicionar link específico para exteraGram/AyuGram
                    display_name = "AyuGram" if link_player == "AyuGram" else "exteraGram"
                    username = self.get_setting("exteragram_username", "").strip()
                    if username.startswith("@"):
                        username = username[1:]
                        if not username:
                            link = "https://t.me/exteraGram" if link_player == "exteraGram" else "https://t.me/ayugram"
                        else:
                            link = f"https://t.me/{username}"
                        caption_parts.append(f"[{display_name}]({link})")

                    # Se nenhum, usar song.link apenas para players .fm (media source) que não sejam Last.FM com Spotify
                    elif link_player not in ["exteraGram", "AyuGram"] and ".fm" in link_player.lower() and not is_lastfm_with_spotify:
                        spotify_link = track["external_urls"]["spotify"]
                        song_link_url = self._get_song_link(spotify_link)
                        caption_parts.append(f"[song.link]({song_link_url})")

                # Adicionar link FM baseado na seleção do usuário
                fm_link_option = self.get_setting("fm_link_option", 0)
                if fm_link_option == 1:  # LastFM
                    lastfm_user = self.get_setting("lastfm_user", "")
                    if lastfm_user:
                        caption_parts.append(f"[Last.FM](https://www.last.fm/user/{lastfm_user})")
                elif fm_link_option == 2:  # StatsFM
                    statsfm_username = self.get_setting("statsfm_username", "")
                    if statsfm_username:
                        caption_parts.append(f"[Stats.FM](https://stats.fm/{statsfm_username})")
                elif fm_link_option == 3:  # Custom Link para FM
                    custom_url = self.get_setting("fm_custom_link_url", "")
                    custom_name = self.get_setting("fm_custom_player_name", "Custom Player")
                    if custom_url:
                        caption_parts.append(f"[{custom_name}]({custom_url})")

            # Montar caption final
            caption = " • ".join(caption_parts)
            if caption and params:
                # Processar emojis premium (sempre habilitado)
                caption = self._process_premium_emojis(caption)
                
                caption_md = parse_markdown(caption)
                # Atribuição segura de caption/entities para objetos ou dicionários
                try:
                    params.caption = caption_md.text
                    params.entities = ArrayList()
                    for entity in caption_md.entities:
                        params.entities.add(entity.to_tlrpc_object())
                    is_attr_params = True
                except Exception:
                    is_attr_params = False
                    try:
                        params["caption"] = caption_md.text
                        params["entities"] = [entity.to_tlrpc_object() for entity in caption_md.entities]
                    except Exception as e:
                        log(f"[NowFy] Falha ao definir caption/entities no params: {e}")

                send_helper = get_send_messages_helper()
                photo = send_helper.generatePhotoSizes(temp_path, None)
                # Atribuição segura de photo/path/message
                try:
                    params.photo = photo
                    params.path = temp_path
                    params.message = None
                except Exception:
                    try:
                        params["photo"] = photo
                        params["path"] = temp_path
                        params["message"] = None
                    except Exception as e:
                        log(f"[NowFy] Falha ao definir photo/path/message no params: {e}")

                # Verificar se está no modo NowCast
                if hasattr(self, '_nowcast_mode') and self._nowcast_mode:
                    # Enviar via API do bot para o NowCast
                    self._send_nowcast_image_via_bot(temp_path, caption)
                else:
                    # Envio normal via Telegram
                    if is_attr_params:
                        run_on_ui_thread(lambda: send_helper.sendMessage(params))
                        try:
                            run_on_ui_thread(self._trigger_send_ripple)
                        except Exception:
                            pass
                    else:
                        # Fallback: se params for dict, enviar via API do bot para evitar incompatibilidade
                        self._send_nowcast_image_via_bot(temp_path, caption)

                # Atualizar bio após o envio do card
                if self.get_setting("enable_autobio", False):
                    autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                    bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                    run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))

                run_on_ui_thread(self._dismiss_loading_dialog)

        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _generate_external_theme_card(self, track, params=None, progress_ms=None, theme_id=None, theme_data=None, force_spotify=False, etg_cover_image=None):
        """Gera card usando tema externo do plugin 'Themes for NowFy'"""
        player = "Spotify" if force_spotify else self._detect_current_player()
        
        # Temas Apple removidos do seletor
        
        title = track.get("name") or ""
        artist = ", ".join([a["name"] for a in track.get("artists", [])]) if isinstance(track.get("artists"), list) else ""
        
        # Verificar se há uma imagem de capa do ETG e adicioná-la ao track
        if etg_cover_image and player in ["exteraGram", "AyuGram", "Telegram"]:
            track["etg_cover_image"] = etg_cover_image

        if player == "SoundCloud":
            youtube_cover_url = self._get_youtube_cover(title, artist)
            # Forçar uso de thumbnails mesmo se a API falhar
            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artist)
            if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                track["image_url"] = youtube_cover_url
        # Fallback geral: se não houver image_url, tentar álbum ou YouTube (unificado)
        if not track.get("image_url"):
            images = track.get("album", {}).get("images", []) if isinstance(track.get("album"), dict) else []
            image_url = None
            if images:
                try:
                    image_url = max(images, key=lambda i: i.get("width", 0)).get("url")
                except Exception:
                    try:
                        image_url = images[0].get("url")
                    except Exception:
                        image_url = None
            if image_url:
                track["image_url"] = image_url
            else:
                youtube_cover_url = self._get_youtube_cover(title, artist)
                if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                    youtube_cover_url = self._get_youtube_thumbnail_forced(title, artist)
                if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                    track["image_url"] = youtube_cover_url
        try:
            log(f"[NowFy] Generating external theme card: {theme_id}")
            
            # ========================================
            # SISTEMA DE TEMAS EXTERNOS V1.0
            # ========================================
            # IMPORTANTE: Todos os temas adicionais devem estar no plugin themes_for_nowfy.plugin
            # ========================================
            # Método 1: Tentar via PluginsController
            try:
                from com.exteragram.messenger.plugins import PluginsController
                plugins_controller = PluginsController.getInstance()
                log(f"[NowFy] PluginsController obtained: {plugins_controller is not None}")
                
                if plugins_controller:
                    # Buscar o plugin themes_for_nowfy
                    themes_plugin = plugins_controller.getPlugin("themes_for_nowfy")
                    log(f"[NowFy] Themes plugin found: {themes_plugin is not None}")
                    
                    if themes_plugin:
                        log(f"[NowFy] Themes plugin has generate_theme_card: {hasattr(themes_plugin, 'generate_theme_card')}")
                        
                        if hasattr(themes_plugin, 'generate_theme_card_direct'):
                            log(f"[NowFy] Calling generate_theme_card_direct for theme: {theme_id}")
                            image_path = themes_plugin.generate_theme_card_direct(theme_id, track, params, progress_ms)
                            log(f"[NowFy] generate_theme_card_direct result: {image_path}")
                            if image_path and params:
                                log(f"[NowFy] External theme card generated, sending with custom caption")
                                self._send_card_with_caption(params, image_path, track, force_spotify)
                                return
                            else:
                                log(f"[NowFy] generate_theme_card_direct returned False or no params")
                        elif hasattr(themes_plugin, 'generate_theme_card'):
                            log(f"[NowFy] Calling generate_theme_card for theme: {theme_id}")
                            success = themes_plugin.generate_theme_card(theme_id, track, params, progress_ms)
                            log(f"[NowFy] generate_theme_card result: {success}")
                            if success:
                                log(f"[NowFy] External theme card generated successfully")
                                return
                            else:
                                log(f"[NowFy] generate_theme_card returned False")
                        else:
                            log(f"[NowFy] Themes plugin doesn't have generate_theme_card method")
                    else:
                        log(f"[NowFy] Themes plugin not found")
                else:
                    log(f"[NowFy] PluginsController is None")
            except Exception as e:
                log(f"[NowFy] Error accessing themes plugin via PluginsController: {e}")
                
            # Método 2: Tentar importar diretamente o módulo
            try:
                import themes_for_nowfy
                if hasattr(themes_for_nowfy, 'get_themes_plugin_instance'):
                    themes_plugin = themes_for_nowfy.get_themes_plugin_instance()
                    log(f"[NowFy] Themes plugin instance obtained via import: {themes_plugin is not None}")
                    
                    if themes_plugin and hasattr(themes_plugin, 'generate_theme_card_direct'):
                        log(f"[NowFy] Calling generate_theme_card_direct via import for theme: {theme_id}")
                        image_path = themes_plugin.generate_theme_card_direct(theme_id, track, params, progress_ms)
                        log(f"[NowFy] generate_theme_card_direct result via import: {image_path}")
                        if image_path and params:
                            log(f"[NowFy] External theme card generated via import, sending with custom caption")
                            self._send_card_with_caption(params, image_path, track, force_spotify)
                            return
                    elif themes_plugin and hasattr(themes_plugin, 'generate_theme_card'):
                        log(f"[NowFy] Calling generate_theme_card via import for theme: {theme_id}")
                        success = themes_plugin.generate_theme_card(theme_id, track, params, progress_ms)
                        log(f"[NowFy] generate_theme_card result via import: {success}")
                        if success:
                            log(f"[NowFy] External theme card generated successfully via import")
                            return
            except Exception as e:
                log(f"[NowFy] Error accessing themes plugin via import: {e}")
                import traceback
                log(f"[NowFy] Traceback: {traceback.format_exc()}")
            
            # Método 3: Tentar via comunicação por arquivo JSON
            try:
                import os
                from java.io import File
                from org.telegram.messenger import ApplicationLoader
                
                # Criar diretório de comunicação se não existir
                comm_dir = File(ApplicationLoader.getFilesDirFixed(), "nowfy_communication")
                if not comm_dir.exists():
                    comm_dir.mkdirs()
                
                # Escrever dados do tema para o arquivo JSON
                theme_request = {
                    "action": "generate_theme_card",
                    "theme_id": theme_id,
                    "track": track,
                    "progress_ms": progress_ms,
                    "timestamp": datetime.now().isoformat()
                }
                
                request_file = File(comm_dir, "theme_request.json")
                with open(request_file.getAbsolutePath(), 'w', encoding='utf-8') as f:
                    json.dump(theme_request, f, ensure_ascii=False, indent=2)
                
                log(f"[NowFy] Theme request written to JSON file")
                
                # Aguardar um pouco para o plugin de temas processar
                import time
                time.sleep(0.5)
                
                # Verificar se o plugin de temas respondeu
                response_file = File(comm_dir, "theme_response.json")
                if response_file.exists():
                    with open(response_file.getAbsolutePath(), 'r', encoding='utf-8') as f:
                        response = json.load(f)
                    
                    if response.get("success") and response.get("image_path"):
                        log(f"[NowFy] Theme response received: {response.get('image_path')}")
                        # Enviar o card gerado pelo plugin de temas com caption customizável
                        if params:
                            self._send_card_with_caption(params, response.get("image_path"), track, force_spotify)
                        return
                    else:
                        log(f"[NowFy] Theme response indicates failure: {response.get('error', 'Unknown error')}")
                
                # Limpar arquivos de comunicação
                if request_file.exists():
                    request_file.delete()
                if response_file.exists():
                    response_file.delete()
                
            except Exception as e:
                log(f"[NowFy] Error in JSON communication method: {e}")
            
            # Fallback: informar erro se não conseguir acessar o plugin de temas
            log(f"[NowFy] All methods failed, unable to generate external theme card")
            if params:
                self._send_msg(params, "Erro: Não foi possível gerar o card do tema Apple Light. Verifique se o plugin 'Themes for NowFy' está ativo.")
                
        except Exception as e:
            log(f"[NowFy] Error generating external theme card: {e}")
            if params:
                self._send_msg(params, f"Erro ao gerar tema externo: {e}")


    def _generate_external_lastfm_theme_card(self, title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image, theme_data):
        """Gera card do LastFM usando tema externo do plugin 'Themes for NowFy'"""
        try:
            log(f"[NowFy] Generating external LastFM theme card: {theme_data['name']}")
            
            # Configurações do tema
            colors = theme_data.get("colors", {})
            bg_color = colors.get("background", "#ffffff")
            text_primary = colors.get("text_primary", "#000000")
            text_secondary = colors.get("text_secondary", "#666666")
            accent_color = colors.get("accent", "#1db954")
            
            # Usar o tema CustomFM do LastFM - StatsFM
            return self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image)
            
        except Exception as e:
            log(f"[NowFy] Error generating external LastFM theme card: {e}")
            # Fallback para tema CustomFM
            return self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, etg_cover_image)

    # --- HOOK DE MENSAGEM ---
    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()
        msg = params.message.strip()
        custom_cmd = self.get_setting("custom_command", ".now")
        # Captura antecipada do comando .code para garantir interceptação
        # Suporta variações: ".code <url|code>", ".code\n<url|code>", ou sem espaço
        import re
        if msg.startswith(".code ") or msg == ".code" or re.match(r"^\s*\.code\b", msg):
            progress_dialog = None
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                from org.telegram.messenger import ApplicationLoader
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
                progress_dialog.set_message(tr("exchanging_code") if "exchanging_code" in TRANSLATIONS else "Trocando código...")
                progress_dialog.show()
            except Exception as e:
                log(f"[Nowfy] Falha ao criar progress dialog para .code: {e}")
            def run_code():
                try:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(30))
                    time.sleep(0.5)
                    # Extrair o código da mensagem em diferentes formatos
                    raw_payload = ""
                    if " " in msg:
                        raw_payload = msg.split(" ", 1)[1].strip()
                    else:
                        parts = msg.splitlines()
                        if len(parts) >= 2:
                            raw_payload = "\n".join(parts[1:]).strip()
                    # Se não houver payload, informar falta de código
                    if not raw_payload:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("error_missing_code")))
                        if progress_dialog:
                            run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    # Se vier uma URL, tentar extrair o parâmetro code
                    code = raw_payload
                    if raw_payload.startswith("http://") or raw_payload.startswith("https://"):
                        try:
                            # Extrair após "code=" e antes de "&"
                            if "code=" in raw_payload:
                                code = raw_payload.split("code=")[-1].split("&")[0]
                        except Exception:
                            pass
                    elif "code=" in raw_payload:
                        code = raw_payload.split("code=")[-1].split("&")[0]
                    client_id = self.get_setting("client_id", "")
                    client_secret = self.get_setting("client_secret", "")
                    if not client_id or not client_secret:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("client_id_or_secret_missing")))
                        if progress_dialog:
                            run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    success, error_msg = self._exchange_code(code)
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(70))
                    time.sleep(0.5)
                    if success:
                        run_on_ui_thread(lambda: BulletinHelper.show_success(tr("refresh_token_saved") if "refresh_token_saved" in TRANSLATIONS else "Refresh Token salvo com sucesso"))
                    else:
                        error_display = error_msg if error_msg else (tr("code_exchange_error") if "code_exchange_error" in TRANSLATIONS else "Erro ao trocar código")
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {error_display}"))
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                    time.sleep(0.2)
                except Exception as e:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {str(e)}"))
                finally:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(run_code)
            return HookResult(strategy=HookStrategy.CANCEL)

        # Captura antecipada do comando .import com feedback visual
        if msg == ".import" or re.match(r"^\s*\.import\b", msg):
            progress_dialog = None
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                from org.telegram.messenger import ApplicationLoader
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
                progress_dialog.set_message(tr("backup_import_starting"))
                progress_dialog.show()
            except Exception as e:
                log(f"[NowFy] Falha ao criar progress dialog para .import: {e}")
            def _run_import():
                try:
                    if progress_dialog:
                        self._import_backup_with_progress(progress_dialog, params)
                    else:
                        self._import_backup(params)
                except Exception as e:
                    from ui.bulletin import BulletinHelper
                    err_title = tr("backup_import_error")
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"{err_title}: {str(e)}"))
                finally:
                    if progress_dialog:
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(_run_import)
            try:
                params.message = ""
            except Exception:
                pass
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == custom_cmd:
            run_on_queue(lambda: self._handle_now_restore_bio(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".bot":
            run_on_queue(lambda: self._handle_bot_command(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".player":
            try:
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                players = [
                    "Spotify", "YouTube", "YouTube Music", "exteraGram",
                    "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"
                ]

                def on_item_click(bld, which):
                    try:
                        self.set_setting("current_player", which)
                        BulletinHelper.show_info(f"{tr('active_player')}: {players[which]}")
                    except Exception as e:
                        log(f"[Nowfy] Error setting active player: {e}")
                    finally:
                        try:
                            bld.dismiss()
                        except Exception:
                            pass

                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("active_player"))
                builder.set_items(players, on_item_click)
                builder.set_negative_button(
                    tr("cancel") if "cancel" in TRANSLATIONS else "Cancelar",
                    lambda b, w: b.dismiss()
                )
                run_on_ui_thread(builder.show)
            except Exception as e:
                log(f"[Nowfy] Error showing player selector: {e}")
            return HookResult(strategy=HookStrategy.CANCEL)
        # Comando .ver: verificar versão e mostrar status com botão de atualização
        if msg == ".ver" or re.match(r"^\s*\.ver\b", msg):
            run_on_queue(lambda: self._check_version_async(True))
            try:
                params.message = ""
            except Exception:
                pass
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setkey "):
            self.set_setting("lastfm_api_key", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_info(tr("lastfm_key_saved"))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg.startswith(".setuser "):
            self.set_setting("lastfm_username", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_info(tr("lastfm_user_saved"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".list":
            run_on_queue(lambda: self._get_recently_played(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".play":
            run_on_queue(lambda: self._resume_playback_only(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".pause":
            run_on_queue(lambda: self._pause_playback_only(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".skip":
            run_on_queue(lambda: self._skip_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".back":
            run_on_queue(lambda: self._previous_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".vol":
            BulletinHelper.show_info(tr("error_missing_volume"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".repeat":
            BulletinHelper.show_info(tr("error_missing_repeat"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".code":
            BulletinHelper.show_info(tr("error_missing_code"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".setid":
            BulletinHelper.show_info(tr("error_missing_setid"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".setsecret":
            BulletinHelper.show_info(tr("error_missing_setsecret"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".like":
            BulletinHelper.show_info(tr("error_missing_like"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".like now":
            run_on_queue(lambda: self._like_current_track(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".guide":
            run_on_ui_thread(self._show_guide_dialog)
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".vol "):
            try:
                value = int(msg.split(" ", 1)[1].strip())
            except Exception:
                value = -1
            run_on_queue(lambda: self._set_volume(params, value))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".repeat "):
            mode = msg.split(" ", 1)[1].strip().lower()
            run_on_queue(lambda: self._set_repeat(params, mode))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".like "):
            track_id = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._like_track(params, track_id))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".code "):
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            progress_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
            progress_dialog.set_message(tr("exchanging_code"))
            progress_dialog.show()
            def run_code():
                try:
                    run_on_ui_thread(lambda: progress_dialog.set_progress(30))
                    time.sleep(0.5)
                    code = msg.split(" ", 1)[1].strip()
                    if "code=" in code:
                        code = code.split("code=")[1].split("&")[0] if "&" in code else code.split("code=")[1]
                    client_id = self.get_setting("client_id", "")
                    client_secret = self.get_setting("client_secret", "")
                    if not client_id or not client_secret:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(tr("client_id_or_secret_missing")))
                        run_on_ui_thread(lambda: progress_dialog.dismiss())
                        return
                    
                    success, error_msg = self._exchange_code(code)
                    run_on_ui_thread(lambda: progress_dialog.set_progress(70))
                    time.sleep(0.5)
                    
                    if success:
                        refresh_token = self.get_setting("refresh_token", "")
                        token_preview = refresh_token[:10] + "..." if refresh_token else "Erro"
                        run_on_ui_thread(lambda: BulletinHelper.show_info("Refresh Token salvo com sucesso"))
                    else:
                        error_display = error_msg if error_msg else tr("code_exchange_error")
                        run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {error_display}"))
                    
                    run_on_ui_thread(lambda: progress_dialog.set_progress(100))
                    time.sleep(0.2)
                except Exception as e:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(f"Erro: {str(e)}"))
                finally:
                    run_on_ui_thread(lambda: progress_dialog.dismiss())
            run_on_queue(run_code)
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setid "):
            self.set_setting("client_id", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_info(tr("setid"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".setsecret "):
            self.set_setting("client_secret", msg.split(" ", 1)[1].strip())
            BulletinHelper.show_info(tr("setsecret"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".play "):
            track_number = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._play_track(account, params, track_number))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".dev":
            run_on_ui_thread(lambda: self._open_plugin_settings())
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".bio":
            restore_bio_text = self.get_setting("restore_bio_text", "").strip()
            if restore_bio_text:
                restore_bio = restore_bio_text
            else:
                restore_bio = "I'm using nowFy!"
            run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=True))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".clear":
            run_on_queue(lambda: self._clear_cache())
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".check":
            BulletinHelper.show_info(tr("check"))
            if self._validate_credentials():
                BulletinHelper.show_info(tr("valid"))
            else:
                BulletinHelper.show_info(tr("bio_error"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".update":
            client_id = self.get_setting("client_id", "")
            if not client_id:
                BulletinHelper.show_info(tr("client_id_missing"))
                return HookResult(strategy=HookStrategy.CANCEL)
            auth_url = (
                "https://accounts.spotify.com/authorize?"
                f"client_id={client_id}&response_type=code&"
                "redirect_uri=https://example.com/callback&"
                "scope=user-read-currently-playing%20user-read-playback-state%20user-modify-playback-state%20user-read-recently-played%20user-library-modify%20playlist-modify-private"
            )
            
            # Prepare message for clipboard
            message = f"Spotify Authorization Link:\n{auth_url}"
            
            # Create bulletin with copy button
            fragment = get_last_fragment()
            def on_copy():
                # Use fragment context for compatibility
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copy to clipboard using context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("auth_url", auth_url)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (BulletinHelper.show_success(tr("copied_bulletin"), fragment)))
            
            # Show bulletin with copy button
            music_icon = getattr(R.raw, "music", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                "Spotify Authorization",
                music_icon,
                "Copy Link",
                on_copy,
                fragment
            ))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".connect":
            client_id = self.get_setting("client_id", "")
            if not client_id:
                BulletinHelper.show_info(tr("client_id_missing"))
                return HookResult(strategy=HookStrategy.CANCEL)
            auth_url = (
                "https://accounts.spotify.com/authorize?"
                f"client_id={client_id}&response_type=code&"
                "redirect_uri=https://example.com/callback&"
                "scope=user-read-currently-playing%20user-read-playback-state%20user-modify-playback-state%20user-read-recently-played%20user-library-modify%20playlist-modify-private"
            )
            caption = f"[🎵](5294137402430858861) [Connect your Spotify]({auth_url})"
            caption_md = parse_markdown(caption)
            # Atribuição segura para objetos ou dict
            try:
                params.message = caption_md.text
                params.entities = ArrayList()
                for entity in caption_md.entities:
                    params.entities.add(entity.to_tlrpc_object())
                run_on_ui_thread(lambda: get_send_messages_helper().sendMessage(params))
            except Exception:
                try:
                    params["message"] = caption_md.text
                    params["entities"] = [e.to_tlrpc_object() for e in caption_md.entities]
                    # Sem envio direto quando params é dict para evitar incompatibilidade
                    self._send_msg(params, caption_md.text)
                except Exception as e:
                    log(f"[NowFy] Erro ao definir message/entities no params: {e}")
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".search":
            BulletinHelper.show_info(tr("error_missing_search"))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg.startswith(".search "):
            query = msg.split(" ", 1)[1].strip()
            run_on_queue(lambda: self._search_spotify(params, query))
            return HookResult(strategy=HookStrategy.CANCEL)
        if msg == ".fm":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._handle_fm_only_lastfm(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comando .etg - exteraGram music detection
        if msg == ".etg":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._handle_etg_command(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comando .ayu - AyuGram music detection  
        if msg == ".ayu":
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._handle_ayu_command(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Alternativa de testes - Comando interno
        if msg == ".api":
            log(f"[Nowfy] .api command - testing Last.fm credentials")
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            
            log(f"[Nowfy] Test - User: '{user}' (length: {len(user) if user else 0})")
            log(f"[Nowfy] Test - API Key: '{api_key[:10] if api_key else ''}...' (length: {len(api_key) if api_key else 0})")
            
            if not user or not api_key:
                BulletinHelper.show_info(f"Credenciais faltando - User: {bool(user)}, API Key: {bool(api_key)}")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            # Testar API diretamente
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params_test = {
                'method': 'user.getrecenttracks',
                'user': user,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            try:
                resp = requests.get(url, params=params_test, timeout=10)
                log(f"[Nowfy] Test API response: {resp.status_code}")
                if resp.status_code == 200:
                    data = resp.json()
                    tracks = data.get('recenttracks', {}).get('track', [])
                    if tracks:
                        track = tracks[0] if isinstance(tracks, list) else tracks
                        track_name = track.get('name', 'Unknown')
                        BulletinHelper.show_info(f"API OK! Última música: {track_name}")
                    else:
                        BulletinHelper.show_info("API OK! Mas nenhuma música encontrada")
                else:
                    BulletinHelper.show_info(f"API Error: {resp.status_code}")
            except Exception as e:
                log(f"[Nowfy] Test API error: {e}")
                BulletinHelper.show_info(f"Erro na API: {str(e)}")
            
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".stats":
            # Restrições de Active Player para o comando .stats:
            # Suporta apenas Spotify e Apple Music.
            try:
                current_player_setting = self.get_setting("current_player", 0)
            except Exception:
                current_player_setting = 0
            if current_player_setting not in [0, 6]:  # 0 = Spotify, 6 = Apple Music
                BulletinHelper.show_info("O comando .stats suporta apenas Spotify e Apple Music no modo Active Player. Selecione um desses players em Configurações → Active Player.")
                return HookResult(strategy=HookStrategy.CANCEL)
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            run_on_queue(lambda: self._handle_stats_only(account, params))
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg == ".help":
            run_on_queue(lambda: self._show_help(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        # Comandos de backup e restauração
        if msg == ".export":
            run_on_queue(lambda: self._export_backup(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        if msg == ".backups":
            run_on_queue(lambda: self._list_backups(params))
            return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()

    def _handle_etg_command(self, account, params):
        """Comando .etg - exteraGram music detection"""
        try:
            log(f"[Nowfy] .etg command - detecting music from exteraGram")
            
            # Usar o método da classe para detectar música do exteraGram
            track_info = self.get_current_track_etg(account)
            
            if track_info and track_info.get('title') and track_info.get('artist'):
                title = track_info.get('title', '')
                artist = track_info.get('artist', '')
                album = track_info.get('album', '')
                duration = track_info.get('duration', 0)
                position = track_info.get('progress', 0)
                
                log(f"[Nowfy] exteraGram track detected: {title} by {artist}")
                
                # Buscar capa do exteraGram
                etg_cover_image = None
                try:
                    # Obter o objeto de mensagem atual
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    
                    if playing_song:
                        etg_cover_image = self.get_etg_cover(playing_song)
                        log(f"[Nowfy] exteraGram cover obtained: {bool(etg_cover_image)}")
                except Exception as e:
                    log(f"[Nowfy] Error getting exteraGram cover: {e}")
                
                # Buscar link do Spotify
                spotify_url = None
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                
                # Criar objeto de track no formato do Spotify
                track_obj = {
                    "name": title,
                    "artists": [{"name": artist}],
                    "album": {
                        "name": album,
                        "images": []
                    },
                    "external_urls": {
                        "spotify": spotify_url
                    },
                    "duration_ms": duration * 1000 if duration else 0
                }
                
                # Forçar o player como exteraGram para que o username apareça no caption
                original_player = getattr(self, '_forced_player', None)
                self._forced_player = "exteraGram"
                
                # Usar o _generate_card para aplicar o tema selecionado
                self._generate_card(track_obj, params, position * 1000 if position else 0, 
                                  force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=False)
                
                # Restaurar o player original
                if original_player is not None:
                    self._forced_player = original_player
                else:
                    if hasattr(self, '_forced_player'):
                        delattr(self, '_forced_player')
                log(f"[Nowfy] exteraGram track displayed: {title}")
                return True
            else:
                log(f"[Nowfy] No track currently playing on exteraGram")
                BulletinHelper.show_info("No track currently playing on exteraGram")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .etg command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_ayu_command(self, account, params):
        """Comando .ayu - AyuGram music detection"""
        try:
            log(f"[Nowfy] .ayu command - detecting music from AyuGram")
            
            # Usar o método da classe para detectar música do AyuGram (mesma função do exteraGram)
            track_info = self.get_current_track_etg(account)
            
            if track_info and track_info.get('title') and track_info.get('artist'):
                title = track_info.get('title', '')
                artist = track_info.get('artist', '')
                album = track_info.get('album', '')
                duration = track_info.get('duration', 0)
                position = track_info.get('progress', 0)
                
                log(f"[Nowfy] AyuGram track detected: {title} by {artist}")
                
                # Buscar capa do AyuGram
                etg_cover_image = None
                try:
                    # Obter o objeto de mensagem atual
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    
                    if playing_song:
                        etg_cover_image = self.get_etg_cover(playing_song)
                        log(f"[Nowfy] AyuGram cover obtained: {bool(etg_cover_image)}")
                except Exception as e:
                    log(f"[Nowfy] Error getting AyuGram cover: {e}")
                
                # Buscar link do Spotify
                spotify_url = None
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                
                # Criar objeto de track no formato do Spotify
                track_obj = {
                    "name": title,
                    "artists": [{"name": artist}],
                    "album": {
                        "name": album,
                        "images": []
                    },
                    "external_urls": {
                        "spotify": spotify_url
                    },
                    "duration_ms": duration * 1000 if duration else 0
                }
                
                # Usar o _generate_card para aplicar o tema selecionado
                self._generate_card(track_obj, params, position * 1000 if position else 0, 
                                  force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=False)
                log(f"[Nowfy] AyuGram track displayed: {title}")
                return True
            else:
                log(f"[Nowfy] No track currently playing on AyuGram")
                BulletinHelper.show_info("No track currently playing on AyuGram")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .ayu command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_fm_only_lastfm(self, account, params):
        """Comando .fm - apenas Last.fm"""
        try:
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            
            # Debug: Log das credenciais recuperadas
            log(f"[Nowfy] Debug - Last.fm user: '{user}' (length: {len(user) if user else 0})")
            log(f"[Nowfy] Debug - Last.fm API key: '{api_key[:10]}...' (length: {len(api_key) if api_key else 0})")

            # Verificar se há credenciais do Last.fm disponíveis
            if not user or not api_key:
                log(f"[Nowfy] Debug - Missing credentials: user={bool(user)}, api_key={bool(api_key)}")
                BulletinHelper.show_info("Last.fm credentials not configured. Use .help for setup instructions.")
                return False

            # Tentar Last.fm
            try:
                import requests
                url = "http://ws.audioscrobbler.com/2.0/"
                params_lastfm = {
                    'method': 'user.getrecenttracks',
                    'user': user,
                    'api_key': api_key,
                    'format': 'json',
                    'limit': 1
                }
                
                resp = requests.get(url, params=params_lastfm, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                    log(f"[Nowfy] Last.fm API response received, parsing tracks...")
                    tracks = data.get('recenttracks', {}).get('track', [])
                    log(f"[Nowfy] Found {len(tracks) if tracks else 0} tracks")
                    
                    if tracks and isinstance(tracks, list) and len(tracks) > 0:
                        track = tracks[0]
                        log(f"[Nowfy] Processing first track: {track.get('name', 'Unknown')}")
                        
                        # Nova lógica: verificar se a música mais recente foi scrobblada recentemente
                        # Se foi scrobblada nos últimos 10 minutos, considerar como "tocando agora"
                        import time
                        current_time = int(time.time())
                        
                        # Verificar se tem atributo nowplaying (música realmente tocando agora)
                        is_now_playing = track.get('@attr', {}).get('nowplaying') == 'true'
                        log(f"[Nowfy] Is now playing: {is_now_playing}")
                        
                        # Se não está tocando agora, verificar se foi scrobblada recentemente
                        is_recent = False
                        if not is_now_playing and 'date' in track:
                            track_time = int(track['date']['uts'])
                            time_diff = current_time - track_time
                            is_recent = time_diff <= 600  # 10 minutos = 600 segundos
                            log(f"[Nowfy] Track time diff: {time_diff} seconds (recent: {is_recent})")
                        elif not is_now_playing:
                            log(f"[Nowfy] No date field found, assuming now playing")
                            is_recent = True  # Se não tem data, assumir que está tocando
                        
                        # Mostrar se está tocando agora OU foi scrobblada recentemente
                        if is_now_playing or is_recent:
                            title = track.get('name', '')
                            artist_name = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                            album_name = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                            
                            log(f"[Nowfy] Showing track: {title} by {artist_name} (nowplaying: {is_now_playing}, recent: {is_recent})")
                            
                            # Obter URL da imagem do álbum
                            image_url = None
                            images = track.get('image', [])
                            if images:
                                for img in images:
                                    if img.get('size') == 'large':
                                        image_url = img.get('#text', '')
                                        break
                            
                            # Buscar link do Spotify
                            spotify_url = None
                            try:
                                spotify_url = self._search_spotify_url(title, artist_name)
                            except Exception as e:
                                log(f"[Nowfy] Error searching Spotify URL: {e}")
                            
                            # Criar objeto de track no formato do Spotify
                            track_obj = {
                                "name": title,
                                "artists": [{"name": artist_name}],
                                "album": {
                                    "name": album_name,
                                    "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                                },
                                "external_urls": {
                                    "spotify": spotify_url
                                },
                                "duration_ms": 0
                            }
                            
                            # Usar o _generate_card para aplicar o tema selecionado
                            self._generate_card(track_obj, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                            log(f"[Nowfy] Last.fm track found and displayed: {title}")
                            return True
                        else:
                            log(f"[Nowfy] Last.fm: Track found but not showing (nowplaying: {is_now_playing}, recent: {is_recent})")
                            if 'date' in track:
                                track_time = int(track['date']['uts'])
                                time_diff = current_time - track_time
                                log(f"[Nowfy] Track was scrobbled {time_diff} seconds ago")
                            BulletinHelper.show_info("No track currently playing on Last.fm")
                            return True
                    else:
                        log(f"[Nowfy] Last.fm: No tracks found")
                        BulletinHelper.show_info("No track currently playing on Last.fm")
                        return True
                else:
                    log(f"[Nowfy] Last.fm API error: {resp.status_code} - {resp.text}")
                    BulletinHelper.show_info("Last.fm API error")
                    return True
            except Exception as e:
                log(f"[ERROR] Last.fm error: {e}")
                BulletinHelper.show_info("Last.fm connection error")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .fm command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_stats_only(self, account, params):
        """Comando .stats - apenas Stats.fm"""
        try:
            statsfm_username = self.get_setting("statsfm_username", "")

            # Verificar se há credenciais do Stats.fm disponíveis
            if not statsfm_username:
                BulletinHelper.show_info("Stats.fm username not configured. Use .help for setup instructions.")
                return False

            # Tentar Stats.fm
            import requests
            url = f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }

            try:
                resp = requests.get(url, headers=headers, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                    item = data.get("item")
                    if item and item.get("isPlaying"):
                        # Criar um objeto de track compatível com o formato do Spotify
                        track_info = item.get("track", {})
                        artists_list = []
                        for artist_name in track_info.get("artists", []):
                            artists_list.append({"name": artist_name["name"]})
                        
                        album = track_info["albums"][0] if track_info.get("albums") else {}
                        album_images = []
                        if album.get("image"):
                            album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                        
                        spotify_id = None
                        if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                            spotify_id = track_info["externalIds"]["spotify"][0]
                        
                        # Criar objeto de track no formato do Spotify
                        track = {
                            "name": track_info.get("name", ""),
                            "artists": artists_list,
                            "album": {
                                "name": album.get("name", ""),
                                "images": album_images
                            },
                            "external_urls": {
                                "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                            },
                            "duration_ms": track_info.get("durationMs", 0)
                        }
                        
                        # Usar o _generate_card para aplicar o tema selecionado
                        progress_ms = item.get("progressMs", 0)
                        # .stats deve exibir ViniBar e não overlay
                        self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                        return True
                    else:
                        BulletinHelper.show_info("No track currently playing on Stats.fm")
                        return True
                else:
                    log(f"[ERROR] Stats.fm API error: {resp.status_code} - {resp.text}")
                    BulletinHelper.show_info("Stats.fm API error")
                    return True
            except Exception as e:
                log(f"[ERROR] Stats.fm connection failed: {str(e)}")
                BulletinHelper.show_info("Stats.fm connection error")
                return True

        except Exception as e:
            log(f"[Nowfy] Error in .stats command: {e}")
            BulletinHelper.show_info(f"Error: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _handle_fm_lastfm(self, account, params):
        try:
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            theme = self.get_setting("theme_selector", 0)
            statsfm_username = self.get_setting("statsfm_username", "")
            show_track_link = self.get_setting("show_track_link", True)

            title = artist = album_name = image_url = None
            duration_ms = progress_ms = 0
            spotify_url = None

            def render_statsfm(data):
                nonlocal title, artist, album_name, image_url, duration_ms, progress_ms, spotify_url
                track = data.get("item")
                if not track:
                    return

                track_info = track.get("track", {})
                artists = ", ".join([artist["name"] for artist in track_info.get("artists", [])])
                album = track_info["albums"][0] if track_info.get("albums") else {}
                title = track_info.get("name", "")
                artist = artists
                album_name = album.get("name", "")
                image_url = album.get("image", "")
                progress_ms = track.get("progressMs", 0)
                duration_ms = track_info.get("durationMs", 0)

                if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                    spotify_url = f"https://open.spotify.com/track/{track_info['externalIds']['spotify'][0]}"

                player = "StatsFM"
                link = spotify_url if show_track_link else None

                if theme_style == 0:
                    return self._get_current_track_lastfm_customfm(
                        title, artist, album_name, image_url, params,
                        None,      
                        "statsfm",      
                        link,         
                        None,           
                        None,           
                        None            
                    )
                else:
                    return self._get_current_track_lastfm_customfm(
                        title, artist, album_name, image_url, params,
                        None, player, link, None, None, None
                    )

            # 1. Tenta os dados do Stats.fm
            if statsfm_username:
                import requests
                url = f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current"
                headers = {
                    "Accept": "application/json",
                    "User-Agent": "NowfyPlugin/1.0"
                }

                try:
                    resp = requests.get(url, headers=headers, timeout=5)
                    if resp.status_code == 200:
                        data = resp.json()
                        item = data.get("item")
                        if item and item.get("isPlaying"):
                            # Criar um objeto de track compatível com o formato do Spotify
                            track_info = item.get("track", {})
                            artists_list = []
                            for artist_name in track_info.get("artists", []):
                                artists_list.append({"name": artist_name["name"]})
                            
                            album = track_info["albums"][0] if track_info.get("albums") else {}
                            album_images = []
                            if album.get("image"):
                                album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                            
                            spotify_id = None
                            if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                                spotify_id = track_info["externalIds"]["spotify"][0]
                            
                            # Criar objeto de track no formato do Spotify
                            track = {
                                "name": track_info.get("name", ""),
                                "artists": artists_list,
                                "album": {
                                    "name": album.get("name", ""),
                                    "images": album_images
                                },
                                "external_urls": {
                                    "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                                },
                                "duration_ms": track_info.get("durationMs", 0)
                            }
                            
                            # Usar o _generate_card para aplicar o tema selecionado
                            progress_ms = item.get("progressMs", 0)
                            self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                            return True
                    else:
                        log(f"[ERROR] Stats.fm API error: {resp.status_code} - {resp.text}")
                except Exception as e:
                    log(f"[ERROR] Stats.fm connection failed: {str(e)}")

            # 2. Tenta o Last.fm
            if user and api_key:
                try:
                    # Usar requests em vez de pylast para evitar dependência externa
                    import requests
                    url = "http://ws.audioscrobbler.com/2.0/"
                    params_lastfm = {
                        'method': 'user.getrecenttracks',
                        'user': user,
                        'api_key': api_key,
                        'format': 'json',
                        'limit': 1
                    }
                    
                    resp = requests.get(url, params=params_lastfm, timeout=5)
                    if resp.status_code == 200:
                        data = resp.json()
                        tracks = data.get('recenttracks', {}).get('track', [])
                        if tracks and isinstance(tracks, list) and len(tracks) > 0:
                            track = tracks[0]
                            # Verificar se está tocando agora
                            # Last.fm pode não incluir @attr.nowplaying quando está scrobblando
                            # Vamos assumir que a música mais recente está tocando, a menos que explicitamente diga que não
                            is_now_playing = track.get('@attr', {}).get('nowplaying') == 'true'
                            has_nowplaying_attr = '@attr' in track and 'nowplaying' in track['@attr']
                            
                            # Se tem o atributo nowplaying e é true, OU se não tem o atributo (assumir que está tocando)
                            # Mudança: ser mais permissivo - mostrar a música a menos que explicitamente não esteja tocando
                            if is_now_playing or not has_nowplaying_attr:
                                title = track.get('name', '')
                                artist_name = track.get('artist', {}).get('#text', '') if isinstance(track.get('artist'), dict) else str(track.get('artist', ''))
                                album_name = track.get('album', {}).get('#text', '') if isinstance(track.get('album'), dict) else str(track.get('album', ''))
                                
                                # Obter URL da imagem do álbum
                                image_url = None
                                images = track.get('image', [])
                                if images:
                                    # Prefer the largest available Last.fm image
                                    size_priority = ['mega', 'extralarge', 'large']
                                    size_map = {img.get('size'): img.get('#text', '') for img in images if img.get('#text')}
                                    for s in size_priority:
                                        if size_map.get(s):
                                            image_url = size_map[s]
                                            break
                                    if not image_url:
                                        # Fallback to last non-empty image URL
                                        for img in reversed(images):
                                            if img.get('#text'):
                                                image_url = img.get('#text', '')
                                                break
                                
                                # Buscar link do Spotify
                                spotify_url = None
                                try:
                                    spotify_url = self._search_spotify_url(title, artist_name)
                                except Exception as e:
                                    log(f"[Nowfy] Error searching Spotify URL: {e}")
                                
                                # Criar objeto de track no formato do Spotify
                                track = {
                                    "name": title,
                                    "artists": [{"name": artist_name}],
                                    "album": {
                                        "name": album_name,
                                        "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                                    },
                                    "external_urls": {
                                        "spotify": spotify_url
                                    },
                                    "duration_ms": 0
                                }
                                
                                # Usar o _generate_card para aplicar o tema selecionado
                                self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=True)
                                log(f"[Nowfy] Last.fm track found and displayed: {title}")
                                return True
                            else:
                                log(f"[Nowfy] Last.fm: Track found but not currently playing (nowplaying=false)")
                                BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                                return True
                        else:
                            log(f"[Nowfy] Last.fm: No tracks found")
                            BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                            return True
                    else:
                        log(f"[Nowfy] Last.fm API error: {resp.status_code} - {resp.text}")
                        BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                        return True
                except Exception as e:
                    log(f"[ERROR] Last.fm error: {e}")
                    BulletinHelper.show_info(tr("no_track_lastfm") if "no_track_lastfm" in TRANSLATIONS else "No track currently playing on Last.fm")
                    return True

            # 3. Tenta o player do etg como fallback
            player_name = self._detect_current_player()
            if player_name in ["exteraGram", "AyuGram"]:
                etg_track = self.get_current_track_etg(account)
                if etg_track:
                    title = etg_track["title"]
                    artist = etg_track["artist"]
                    # Funcionalidade para obter dados do etg (áudio)
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    playing_song = media_controller.getPlayingMessageObject()
                    etg_cover_image = self.get_etg_cover(playing_song)
                    album_name = etg_track.get("album", "")
                    image_url = None  # Fallback
                    
                    # Buscar link do Spotify
                    spotify_url = None
                    try:
                        spotify_url = self._search_spotify_url(title, artist)
                    except Exception as e:
                        log(f"[Nowfy] Error searching Spotify URL: {e}")
                    
                    # Criar objeto de track no formato do Spotify
                    track = {
                        "name": title,
                        "artists": [{"name": artist}],
                        "album": {
                            "name": album_name,
                            "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                        },
                        "external_urls": {
                            "spotify": spotify_url
                        },
                        "duration_ms": 0
                    }
                    
                    # Usar o _generate_card com o cover do ETG
                    # Obter o tema selecionado
                    theme = self.get_setting("theme_selector", 0)
                    random_theme = self.get_setting("random_theme_mode", False)
                    
                    # Se for tema externo (índice >= 5), passar o etg_cover_image
                    if theme >= 5 and not random_theme:
                        # Obter temas externos
                        external_themes = self._get_external_themes()
                        if external_themes:
                            # Calcular qual tema externo usar
                            external_theme_index = theme - 5
                            external_theme_ids = list(external_themes.keys())
                            if external_theme_index < len(external_theme_ids):
                                theme_id = external_theme_ids[external_theme_index]
                                self._generate_external_theme_card(track, params, 0, theme_id, 
                                                                external_themes[theme_id], 
                                                                force_spotify=False, 
                                                                etg_cover_image=etg_cover_image)
                                return True
                    
                    # Para outros temas, usar o _generate_card normal
                    self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=etg_cover_image, is_fm_command=True)
                    return True
                else:
                    # Não há música tocando no exteraGram/AyuGram - não enviar card
                    log(f"[Nowfy] No track playing on {player_name}")
                    BulletinHelper.show_info(tr("no_track_playing_generic"))
                    return False

            # 4. Sem respotas
            BulletinHelper.show_info(tr("no_track_playing_generic"))

        except Exception as e:
            log(f"[Nowfy] Error in .fm command: {e}")
            self._send_msg(params, f"Error: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _open_url(self, url):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            intent = Intent(Intent.ACTION_VIEW)
            intent.setData(Uri.parse(url))
            ctx.startActivity(intent)
        except Exception as e:
            log(f"Erro ao abrir link: {e}")

    def _send_msg(self, params, text):
        if isinstance(text, str) and text in TRANSLATIONS:
            BulletinHelper.show_info(tr(text))
        else:
            BulletinHelper.show_info(text)

    def _trigger_send_ripple(self):
        try:
            if not self.get_setting("enable_aurasend_on_send", False):
                return
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            view = None
            if activity:
                try:
                    window = activity.getWindow()
                    if window:
                        view = window.getDecorView()
                except Exception:
                    view = None
            try:
                width = float(view.getWidth()) if view else 540.0
                height = float(view.getHeight()) if view else 960.0
            except Exception:
                width = 540.0
                height = 960.0
            cx = width / 2.0
            cy = height / 2.0
            # Seleciona estilo Notify (iOS) quando habilitado
            try:
                if not hasattr(self, "_launch_activity_jclass") or self._launch_activity_jclass is None:
                    self._launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
                    try:
                        self._launch_activity_clsobj = getattr(self._launch_activity_jclass, "class_", None)
                    except Exception:
                        self._launch_activity_clsobj = None
                owner = self._launch_activity_clsobj or self._launch_activity_jclass
                if owner:
                    if not hasattr(self, "_make_ripple_method") or self._make_ripple_method is None:
                        method = None
                        try:
                            method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                        except Exception:
                            try:
                                methods = owner.getDeclaredMethods()
                                for m in methods:
                                    try:
                                        if m.getName() != "makeRipple":
                                            continue
                                        if len(m.getParameterTypes()) == 3:
                                            method = m
                                            break
                                    except Exception:
                                        method = m
                                        break
                            except Exception:
                                method = None
                        if method:
                            try:
                                method.setAccessible(True)
                            except Exception:
                                pass
                            self._make_ripple_method = method
                    if getattr(self, "_make_ripple_method", None):
                        self._make_ripple_method.invoke(None, JFloat(cx), JFloat(cy), JFloat(2.5))
            except Exception as e:
                log(f"[NowFy] Ripple invoke error: {e}")
        except Exception:
            pass

    def _trigger_notify_effect(self):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not activity:
                return
            def _run():
                try:
                    # Root content view
                    content = activity.findViewById(16908290)  # android.R.id.content
                    if content is None:
                        try:
                            content = activity.getWindow().getDecorView()
                        except Exception:
                            content = None
                    if content is None:
                        return
                    FrameLayout = find_class("android.widget.FrameLayout")
                    FrameLayout_LayoutParams = find_class("android.widget.FrameLayout$LayoutParams")
                    ImageView = find_class("android.widget.ImageView")
                    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
                    Orientation = find_class("android.graphics.drawable.GradientDrawable$Orientation")
                    Gravity = find_class("android.view.Gravity")
                    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                    Color = find_class("android.graphics.Color")

                    overlay = FrameLayout(activity)
                    try:
                        overlay.setClickable(False)
                    except Exception:
                        pass

                    # Garantir remoção de overlay anterior (efeito não persistente)
                    try:
                        if hasattr(self, "_aura_overlay") and self._aura_overlay:
                            parent_prev = getattr(self._aura_overlay, "getParent", None)
                            try:
                                if parent_prev:
                                    p = self._aura_overlay.getParent()
                                    if p:
                                        p.removeView(self._aura_overlay)
                            except Exception:
                                pass
                            self._aura_overlay = None
                    except Exception:
                        pass

                    # Parâmetros em tela cheia para efeito nas bordas
                    params = FrameLayout_LayoutParams(-1, -1)

                    # Criar drawable com gradiente radial para bordas
                    gd = GradientDrawable()
                    try:
                        gd.setGradientType(GradientDrawable.RADIAL_GRADIENT)
                    except Exception:
                        pass
                    try:
                        # Determinar tamanho de tela para raio
                        WindowManager = find_class("android.view.WindowManager")
                        Point = find_class("android.graphics.Point")
                        display = activity.getWindowManager().getDefaultDisplay()
                        sizePt = Point()
                        display.getSize(sizePt)
                        screen_w, screen_h = sizePt.x, sizePt.y
                        radius = float(max(screen_w, screen_h)) * 0.75
                        gd.setGradientCenter(0.5, 0.5)
                        # Centro transparente, bordas com cor
                        center_color = Color.argb(0, 123, 97, 255)
                        edge_color = Color.argb(120, 0, 194, 255)
                        gd.setColors([center_color, edge_color])
                        try:
                            gd.setGradientRadius(radius)
                        except Exception:
                            # Fallback para valor fixo
                            gd.setGradientRadius(float(AndroidUtilities.dp(420.0)))
                    except Exception:
                        try:
                            gd.setColor(Color.argb(96, 123, 97, 255))
                        except Exception:
                            pass

                    # Círculo radial central com cores gradientes (Notify)
                    circle_iv = ImageView(activity)
                    circle_gd = GradientDrawable()
                    try:
                        circle_gd.setGradientType(GradientDrawable.RADIAL_GRADIENT)
                        # gradiente do centro (roxo suave) para borda (ciano)
                        c_center = Color.argb(150, 123, 97, 255)
                        c_edge = Color.argb(150, 0, 194, 255)
                        circle_gd.setColors([c_center, c_edge])
                        circle_gd.setGradientCenter(0.5, 0.5)
                    except Exception:
                        try:
                            circle_gd.setColor(Color.argb(120, 123, 97, 255))
                        except Exception:
                            pass
                    try:
                        diameter = AndroidUtilities.dp(240.0)
                    except Exception:
                        diameter = 480
                    try:
                        circle_gd.setGradientRadius(float(diameter) / 2.0)
                    except Exception:
                        pass
                    lp_circle = FrameLayout_LayoutParams(diameter, diameter)
                    lp_circle.gravity = Gravity.CENTER
                    circle_iv.setBackground(circle_gd)
                    try:
                        circle_iv.setAlpha(0.0)
                        circle_iv.setScaleX(0.4)
                        circle_iv.setScaleY(0.4)
                    except Exception:
                        pass
                    overlay.addView(circle_iv, lp_circle)

                    parent_view = content
                    try:
                        content.addView(overlay)
                    except Exception:
                        try:
                            decor = activity.getWindow().getDecorView()
                            decor.addView(overlay)
                            parent_view = decor
                        except Exception:
                            return

                    # Guardar referência atual para remoção garantida
                    try:
                        self._aura_overlay = overlay
                    except Exception:
                        pass

                    # Disparar o mesmo ripple do Default (centro da tela)
                    try:
                        view = None
                        try:
                            view = activity.getWindow().getDecorView()
                        except Exception:
                            view = parent_view
                        try:
                            width = float(view.getWidth()) if view else 540.0
                            height = float(view.getHeight()) if view else 960.0
                        except Exception:
                            width = 540.0
                            height = 960.0
                        cx = width / 2.0
                        cy = height / 2.0
                        if not hasattr(self, "_launch_activity_jclass") or self._launch_activity_jclass is None:
                            self._launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
                            try:
                                self._launch_activity_clsobj = getattr(self._launch_activity_jclass, "class_", None)
                            except Exception:
                                self._launch_activity_clsobj = None
                        owner = self._launch_activity_clsobj or self._launch_activity_jclass
                        if owner:
                            if not hasattr(self, "_make_ripple_method") or self._make_ripple_method is None:
                                method = None
                                try:
                                    method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                                except Exception:
                                    try:
                                        methods = owner.getDeclaredMethods()
                                        for m in methods:
                                            try:
                                                if m.getName() != "makeRipple":
                                                    continue
                                                if len(m.getParameterTypes()) == 3:
                                                    method = m
                                                    break
                                            except Exception:
                                                method = m
                                                break
                                    except Exception:
                                        method = None
                                if method:
                                    try:
                                        method.setAccessible(True)
                                    except Exception:
                                        pass
                                    self._make_ripple_method = method
                            if getattr(self, "_make_ripple_method", None):
                                self._make_ripple_method.invoke(None, JFloat(cx), JFloat(cy), JFloat(2.5))
                    except Exception:
                        pass

                    # Animar ripple semelhante ao Default: escala do círculo + alpha
                    try:
                        DecelerateInterpolator = find_class("android.view.animation.DecelerateInterpolator")
                        AccelerateInterpolator = find_class("android.view.animation.AccelerateInterpolator")
                        interpolator_in = DecelerateInterpolator()
                        interpolator_out = AccelerateInterpolator()
                        try:
                            overlay.setAlpha(0.0)
                        except Exception:
                            pass
                        def _fade_out():
                            try:
                                a2 = overlay.animate().alpha(0.0).setDuration(220)
                                try:
                                    a2.setInterpolator(interpolator_out)
                                except Exception:
                                    pass
                                a2.withEndAction(lambda: self._remove_notify_overlay(parent_view, overlay))
                                a2.start()
                            except Exception:
                                try:
                                    self._remove_notify_overlay(parent_view, overlay)
                                except Exception:
                                    pass
                        # Fade-in + expansão do círculo
                        try:
                            a_circle = circle_iv.animate().alpha(0.9).scaleX(2.6).scaleY(2.6).setDuration(280)
                            try:
                                a_circle.setInterpolator(interpolator_in)
                            except Exception:
                                pass
                            a_circle.withEndAction(_fade_out)
                            a_circle.start()
                        except Exception:
                            _fade_out()
                        # Overlay acompanha a visibilidade
                        try:
                            overlay.animate().alpha(0.9).setDuration(140).setInterpolator(interpolator_in).start()
                        except Exception:
                            pass
                    except Exception:
                        pass

                    # Remoção com tempo limite para garantir desaparecimento
                    try:
                        AndroidUtilities.runOnUIThread(lambda: self._remove_notify_overlay(parent_view, overlay), 800)
                    except Exception:
                        try:
                            overlay.postDelayed(lambda: self._remove_notify_overlay(parent_view, overlay), 800)
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[NowFy] Notify effect error: {e}")
            try:
                run_on_ui_thread(_run)
            except Exception:
                _run()
        except Exception:
            pass

    def _remove_notify_overlay(self, parent, overlay):
        try:
            if overlay:
                # Sempre garante invisibilidade imediata
                try:
                    overlay.setAlpha(0.0)
                except Exception:
                    pass
                # Remove do parent conhecido
                if parent:
                    try:
                        parent.removeView(overlay)
                    except Exception:
                        pass
                # Fallback: remove do parent real
                try:
                    real_parent = overlay.getParent()
                    if real_parent:
                        try:
                            real_parent.removeView(overlay)
                        except Exception:
                            pass
                except Exception:
                    pass
                # Limpa filhos para liberar referências
                try:
                    overlay.removeAllViews()
                except Exception:
                    pass
            try:
                if hasattr(self, "_aura_overlay") and self._aura_overlay is overlay:
                    self._aura_overlay = None
            except Exception:
                pass
        except Exception:
            pass

    def _trigger_surge_effect(self):
        try:
            # Removido: estilo SurgeWave descontinuado
            return
        except Exception:
            return

    def _compare_versions(self, v1, v2):
        try:
            def to_ints(v):
                return [int(x) for x in str(v).split('.') if x.isdigit() or x.isnumeric()]
            a, b = to_ints(v1), to_ints(v2)
            # Normalize lengths
            maxlen = max(len(a), len(b))
            a += [0] * (maxlen - len(a))
            b += [0] * (maxlen - len(b))
            for i in range(maxlen):
                if a[i] < b[i]:
                    return -1
                if a[i] > b[i]:
                    return 1
            return 0
        except Exception:
            return 0

    def _check_version_async(self, show_bulletin=False):
        try:
            import threading
            def worker():
                url = "https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/check/version.json"
                latest = None
                update_url = None
                try:
                    resp = requests.get(url, timeout=6)
                    if resp.status_code == 200:
                        data = resp.json()
                        latest = data.get("latest_version")
                        update_url = data.get("update_url") or data.get("changelog_url")
                        # Sanitize values coming from JSON (trim spaces/backticks)
                        try:
                            latest = str(latest).strip() if latest is not None else None
                        except Exception:
                            pass
                        try:
                            if update_url:
                                update_url = str(update_url).strip().strip('`').strip()
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[Nowfy] Version check request failed: {e}")

                self._latest_version = latest
                self._version_update_url = update_url
                status_text = None
                try:
                    cmp = self._compare_versions(__version__, latest) if latest else 0
                    if latest and cmp < 0:
                        self._version_is_outdated = True
                        status_text = tr("version_status_outdated")
                    elif latest:
                        self._version_is_outdated = False
                        status_text = tr("version_status_up_to_date")
                    else:
                        self._version_is_outdated = False
                        status_text = tr("version_status_unknown")
                except Exception:
                    status_text = tr("version_status_unknown")

                # Refresh settings to update About section labels
                try:
                    self.reload_settings()
                except Exception:
                    pass

                if show_bulletin:
                    try:
                        def show_bulletin_msg():
                            if latest and self._version_is_outdated:
                                msg = tr("update_available_text").format(version=latest)
                                if update_url:
                                    BulletinHelper.show_with_button(
                                        msg,
                                        getattr(R.raw, "info", R.raw.music),
                                        tr("open_update_page"),
                                        lambda: self._open_url(update_url)
                                    )
                                else:
                                    BulletinHelper.show_info(msg)
                            elif latest and not self._version_is_outdated:
                                BulletinHelper.show_info(tr("version_status_up_to_date"))
                            else:
                                BulletinHelper.show_info(tr("version_status_unknown"))
                        try:
                            run_on_ui_thread(show_bulletin_msg)
                        except Exception:
                            show_bulletin_msg()
                    except Exception as e:
                        log(f"[Nowfy] Bulletin version status failed: {e}")
            threading.Thread(target=worker, daemon=True).start()
        except Exception as e:
            log(f"[Nowfy] check_version_async failed: {e}")

    def _show_card_dialog(self):
        try:
            AlertDialogBuilder.show_info(tr("Nowfy"), tr("valid"))
        except Exception as e:
            log(f"[exteraFy] Error showing dialog: {e}")

    def _show_loading_dialog(self, fragment):
        try:
            self._dialog = AlertDialog(fragment.getParentActivity(), 3)
            self._dialog.setMessage(tr("check"))
            self._dialog.show()
        except Exception as e:
            log(f"[exteraFy] Error showing loading dialog: {e}")

    def _dismiss_loading_dialog(self):
        try:
            if hasattr(self, "_dialog") and self._dialog and self._dialog.isShowing():
                self._dialog.dismiss()
        except Exception:
            pass
        self._dialog = None

    def _handle_now_restore_bio(self, params):
        try:
            log(f"[Nowfy] .now command started")
            fragment = get_last_fragment()
            if fragment:
                run_on_ui_thread(lambda: self._show_loading_dialog(fragment))
            
            # Verificar se há credenciais do Stats.fm ou Last.fm disponíveis
            statsfm_username = self.get_setting("statsfm_username", "")
            lastfm_username = self.get_setting("lastfm_username", "")
            lastfm_api_key = self.get_setting("lastfm_api_key", "")
            
            has_statsfm = bool(statsfm_username)
            has_lastfm = bool(lastfm_username and lastfm_api_key)
            
            log(f"[Nowfy] Service availability - Stats.fm: {has_statsfm}, Last.fm: {has_lastfm}")
            
            # 1. Tentar Stats.fm primeiro se disponível
            if has_statsfm:
                log(f"[Nowfy] Trying Stats.fm with username: {statsfm_username}")
                if self._try_statsfm_now_playing(params, statsfm_username):
                    run_on_ui_thread(self._dismiss_loading_dialog)
                    return
            
            # 2. Tentar Last.fm se disponível
            if has_lastfm:
                log(f"[Nowfy] Trying Last.fm with username: {lastfm_username}")
                if self._try_lastfm_now_playing(params, lastfm_username, lastfm_api_key):
                    run_on_ui_thread(self._dismiss_loading_dialog)
                    return
            
            # 3. Só verificar Spotify se Stats.fm e Last.fm falharam
            client_id = self.get_setting("client_id", "")
            client_secret = self.get_setting("client_secret", "")
            refresh_token = self.get_setting("refresh_token", "")
            
            has_spotify_creds = bool(client_id or client_secret or refresh_token)
            has_complete_spotify_creds = bool(client_id and client_secret and refresh_token)
            
            log(f"[Nowfy] Checking Spotify - Partial creds: {has_spotify_creds}, Complete creds: {has_complete_spotify_creds}")
            
            if has_complete_spotify_creds:
                log(f"[Nowfy] Trying Spotify with complete credentials")
                token = self._get_access_token(show_error_bulletin=True)
                log(f"[Nowfy] Access token obtained: {token is not None}")
                if not token:
                    log(f"[Nowfy] No access token - credentials error already shown")
                    run_on_ui_thread(self._dismiss_loading_dialog)
                    return
            elif has_spotify_creds:
                # Credenciais incompletas do Spotify - mostrar erro apenas se chegamos até aqui
                log(f"[Nowfy] Incomplete Spotify credentials detected")
                missing_creds = []
                if not client_id: missing_creds.append("Client ID")
                if not client_secret: missing_creds.append("Client Secret")
                if not refresh_token: missing_creds.append("Refresh Token")
                
                if self._should_show_error_bulletin("missing_credentials"):
                    self._show_credentials_error_bulletin("missing_credentials", f"[Nowfy] Missing credentials: {', '.join(missing_creds)}", missing_creds)
                run_on_ui_thread(self._dismiss_loading_dialog)
                return
            else:
                # Nenhum serviço configurado ou funcionando
                if not has_statsfm and not has_lastfm:
                    log(f"[Nowfy] No services configured")
                    BulletinHelper.show_info(tr("no_services_configured") if "no_services_configured" in TRANSLATIONS else "Nenhum serviço configurado. Configure Stats.fm, Last.fm ou Spotify nas configurações.")
                else:
                    log(f"[Nowfy] Services available but no track found")
                    BulletinHelper.show_info(tr("no_track_playing_generic") if "no_track_playing_generic" in TRANSLATIONS else "Nenhuma música tocando no momento.")
                run_on_ui_thread(self._dismiss_loading_dialog)
                return
            
            # Continuar apenas se chegou até aqui com credenciais completas do Spotify
            # Testar se o token é válido fazendo uma chamada simples
            test_resp = requests.get(
                "https://api.spotify.com/v1/me",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            log(f"[Nowfy] Token validation - Status: {test_resp.status_code}")
            if test_resp.status_code == 401:
                log(f"[Nowfy] Token is invalid or expired")
                run_on_ui_thread(self._dismiss_loading_dialog)
                if self._should_show_error_bulletin("invalid_token"):
                    self._show_credentials_error_bulletin("invalid_refresh_token", f"[Nowfy] Token is invalid or expired - Status: {test_resp.status_code}", ["Refresh Token"])
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            log(f"[Nowfy] API Response - Status: {resp.status_code}, Has Content: {bool(resp.content)}")
            if resp.status_code == 204:
                log(f"[Nowfy] API returned 204 - No content (nothing playing)")
                # Restore bio se não houver música tocando
                try:
                    user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    current_bio = user_full.about if user_full else ""
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    
                    if current_bio and current_bio.strip():
                        restore_bio = current_bio
                    elif restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                except:
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    if restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                BulletinHelper.show_info(tr("no_track_playing"))
                return
            elif resp.status_code == 200 and resp.content:
                data = resp.json()
                track = data.get("item")
                progress_ms = data.get("progress_ms", 0)
                is_playing = data.get("is_playing", False)
                log(f"[Nowfy] .now command - Track: {track is not None}, Is Playing: {is_playing}")
                if track:
                    log(f"[Nowfy] Track details - Name: {track.get('name')}, Artists: {[a.get('name') for a in track.get('artists', [])]}")
                else:
                    log(f"[Nowfy] No track data in API response")
                # Verificar se há uma faixa válida (mesmo pausada)
                track_name = track.get("name") if track else None
                track_artists = track.get("artists") if track else None
                log(f"[Nowfy] Track validation - Name: {bool(track_name)}, Artists: {bool(track_artists and len(track_artists) > 0)}")
                if track and track_name and track_artists:
                    log(f"[Nowfy] Calling _generate_card for track: {track_name} by {', '.join([a.get('name', '') for a in track_artists])}")
                    try:
                        # Atualizar ID da faixa atual para o sistema de pré-carregamento
                        self._update_current_track_id(track.get('id'))
                        
                        self._generate_card(track, params, progress_ms, force_spotify=True)
                        log(f"[Nowfy] _generate_card completed successfully")
                        
                        # Limpar cache antigo após gerar o card
                        self._cleanup_preload_cache()
                        
                    except Exception as e:
                        log(f"[Nowfy] Error in _generate_card: {e}")
                        import traceback
                        log(f"[Nowfy] _generate_card traceback: {traceback.format_exc()}")
                        raise e
                    if self.get_setting("enable_autobio", False) and is_playing:
                        autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                        bio = autobio_text.format(track=track["name"], artist=", ".join([a["name"] for a in track["artists"]]))
                        run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                    # Exibir bulletin curto se show_bio_notification estiver ativado e há uma música
                    if self.get_setting("show_bio_notification", True):
                        if self.get_setting("enable_auto_bio_update", True):
                            # Para auto-refresh, não mostrar bulletin no comando .now
                            pass
                        else:
                            BulletinHelper.show_info(tr("bio_notification_disabled"))
                else:
                    # Restore bio se não houver música tocando
                    log(f"[Nowfy] .now command - No track playing or paused")
                    # Capturar bio atual do perfil em vez de usar bio antiga
                    try:
                        user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                        current_bio = user_full.about if user_full else ""
                        restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                        
                        if current_bio and current_bio.strip():
                            restore_bio = current_bio
                        elif restore_bio_text:
                            restore_bio = restore_bio_text
                        else:
                            restore_bio = "I'm using nowFy!"
                    except:
                        restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                        if restore_bio_text:
                            restore_bio = restore_bio_text
                        else:
                            restore_bio = "I'm using nowFy!"
                    run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                    # Mostrar mensagem específica do Spotify
                    BulletinHelper.show_info(tr("no_track_playing"))
            else:
                # Restore bio se não houver música tocando
                log(f"[Nowfy] .now command - Invalid API response or no content - Status: {resp.status_code}")
                if resp.status_code != 200:
                    log(f"[Nowfy] API Error Response: {resp.text if hasattr(resp, 'text') else 'No response text'}")
                # Capturar bio atual do perfil em vez de usar bio antiga (experimental)
                try:
                    user_full = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    current_bio = user_full.about if user_full else ""
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    
                    if current_bio and current_bio.strip():
                        restore_bio = current_bio
                    elif restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                except:
                    restore_bio_text = self.get_setting("restore_bio_text", "").strip()
                    if restore_bio_text:
                        restore_bio = restore_bio_text
                    else:
                        restore_bio = "I'm using nowFy!"
                run_on_ui_thread(lambda: self._update_bio(restore_bio, show_bulletin=False, is_restore=True))
                # Mostrar mensagem específica do Spotify
                BulletinHelper.show_info(tr("no_track_playing"))
        except Exception as e:
            log(f"[exteraFy] Error in now command: {e}")
            self._send_msg(params, f"Erro: {e}")
        finally:
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _send_now_playing_card(self):
        """Envia o card Now Playing baseado na fonte selecionada"""
        try:
            # Obter a fonte selecionada
            source_index = self.get_setting("now_card_source", 0)
            sources = ["Spotify", "Stats.fm", "Last.fm", "AyuGram", "exteraGram"]
            selected_source = sources[source_index]
            
            log(f"[Nowfy] Send Card Now - Source: {selected_source}")
            
            # Mapear source para comando
            command_map = {
                "Spotify": self.get_setting("custom_command", ".now"),
                "Stats.fm": ".stats",
                "Last.fm": ".fm",
                "AyuGram": ".ayu",
                "exteraGram": ".etg"
            }
            
            command = command_map.get(selected_source, ".now")
            log(f"[Nowfy] Sending command: {command}")
            
            # Enviar o comando como se fosse digitado pelo usuário
            # Isso garantirá que o hook de mensagem intercepte e processe corretamente
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_info("Unable to get chat context")
                return
            
            # Obter o send helper e enviar o comando
            def send_command():
                try:
                    send_helper = get_send_messages_helper()
                    # Simular digitação do comando
                    from org.telegram.messenger import SendMessagesHelper
                    
                    # O comando será interceptado pelo hook antes de ser enviado
                    run_on_ui_thread(lambda: send_helper.sendMessage(
                        SendMessagesHelper.SendMessageParams.of(
                            command,
                            fragment.getDialogId()
                        )
                    ))
                except Exception as e:
                    log(f"[Nowfy] Error sending command: {e}")
                    # Fallback: tentar método direto
                    try:
                        account = get_user_config()
                        from java.util import ArrayList
                        
                        class MockParams:
                            def __init__(self):
                                self.message = command
                                self.entities = ArrayList()
                                self.photo = None
                                self.path = None
                                self.caption = None
                            
                            def __setitem__(self, key, value):
                                setattr(self, key, value)
                            
                            def __getitem__(self, key):
                                return getattr(self, key, None)
                        
                        params = MockParams()
                        
                        # Executar comando baseado na fonte selecionada
                        if selected_source == "Spotify":
                            self._handle_now_restore_bio(params)
                        elif selected_source == "Stats.fm":
                            self._handle_stats_only(account, params)
                        elif selected_source == "Last.fm":
                            self._handle_fm_only_lastfm(account, params)
                        elif selected_source == "AyuGram":
                            self._handle_ayu_command(account, params)
                        elif selected_source == "exteraGram":
                            self._handle_etg_command(account, params)
                    except Exception as fallback_error:
                        log(f"[Nowfy] Fallback error: {fallback_error}")
                        BulletinHelper.show_info(f"Error: {fallback_error}")
            
            run_on_queue(send_command)
            
        except Exception as e:
            log(f"[Nowfy] Error in _send_now_playing_card: {e}")
            BulletinHelper.show_info(f"Error: {e}")

    def _try_statsfm_now_playing(self, params, username):
        """Tenta obter música atual do Stats.fm"""
        try:
            import requests
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "NowfyPlugin/1.0"
            }
            
            resp = requests.get(url, headers=headers, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                item = data.get("item")
                if item and item.get("isPlaying"):
                    # Criar um objeto de track compatível com o formato do Spotify
                    track_info = item.get("track", {})
                    artists_list = []
                    for artist_name in track_info.get("artists", []):
                        artists_list.append({"name": artist_name["name"]})
                    
                    album = track_info["albums"][0] if track_info.get("albums") else {}
                    album_images = []
                    if album.get("image"):
                        album_images.append({"url": album.get("image"), "width": 640, "height": 640})
                    
                    spotify_id = None
                    if track_info.get("externalIds") and track_info["externalIds"].get("spotify"):
                        spotify_id = track_info["externalIds"]["spotify"][0]
                    
                    # Criar objeto de track no formato do Spotify
                    track = {
                        "name": track_info.get("name", ""),
                        "artists": artists_list,
                        "album": {
                            "name": album.get("name", ""),
                            "images": album_images
                        },
                        "external_urls": {
                            "spotify": f"https://open.spotify.com/track/{spotify_id}" if spotify_id else None
                        },
                        "duration_ms": track_info.get("durationMs", 0)
                    }
                    
                    # Usar o _generate_card para aplicar o tema selecionado
                    # No comando .now, não devemos aplicar overlay do Last.fm
                    progress_ms = item.get("progressMs", 0)
                    self._generate_card(track, params, progress_ms, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                    log(f"[Nowfy] Stats.fm track found and displayed: {track_info.get('name', '')}")
                    return True
                else:
                    log(f"[Nowfy] Stats.fm: No track currently playing")
                    return False
            else:
                log(f"[Nowfy] Stats.fm API error: {resp.status_code} - {resp.text}")
                return False
        except Exception as e:
            log(f"[Nowfy] Stats.fm connection failed: {str(e)}")
            return False
    
    def _try_lastfm_now_playing(self, params, username, api_key):
        """Tenta obter música atual do Last.fm"""
        try:
            # Usar requests em vez de pylast para evitar dependência externa
            import requests
            url = "http://ws.audioscrobbler.com/2.0/"
            params = {
                'method': 'user.getrecenttracks',
                'user': username,
                'api_key': api_key,
                'format': 'json',
                'limit': 1
            }
            
            resp = requests.get(url, params=params, timeout=5)
            if resp.status_code == 200:
                data = resp.json()
                tracks = data.get('recenttracks', {}).get('track', [])
                if tracks and isinstance(tracks, list) and len(tracks) > 0:
                    track_item = tracks[0]
                    # Considerar como tocando apenas quando o atributo nowplaying estiver presente e verdadeiro
                    nowplaying_attr = None
                    if isinstance(track_item, dict):
                        nowplaying_attr = track_item.get('@attr', {}).get('nowplaying')
                    is_playing = str(nowplaying_attr).lower() in ('true', '1', 'yes')

                    if is_playing:
                        title = track_item.get('name', '')
                        artist_name = track_item.get('artist', {}).get('#text', '') if isinstance(track_item.get('artist'), dict) else str(track_item.get('artist', ''))
                        album_name = track_item.get('album', {}).get('#text', '') if isinstance(track_item.get('album'), dict) else str(track_item.get('album', ''))

                        # Obter URL da imagem do álbum
                        image_url = None
                        images = track_item.get('image', [])
                        if images:
                            for img in images:
                                if img.get('size') == 'large':
                                    image_url = img.get('#text', '')
                                    break

                        # Criar objeto de track no formato do Spotify
                        track = {
                            "name": title,
                            "artists": [{"name": artist_name}],
                            "album": {
                                "name": album_name,
                                "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                            },
                            "external_urls": {
                                "spotify": None
                            },
                            "duration_ms": 0
                        }

                        # Usar o _generate_card para aplicar o tema selecionado
                        # No comando .now, não devemos aplicar overlay do Last.fm
                        self._generate_card(track, params, 0, force_spotify=False, etg_cover_image=None, is_fm_command=False)
                        log(f"[Nowfy] Last.fm track found and displayed: {title}")
                        return True
                    else:
                        log(f"[Nowfy] Last.fm: Track found but not currently playing")
                        return False
                else:
                    log(f"[Nowfy] Last.fm: No tracks found")
                    return False
        except Exception as e:
            log(f"[Nowfy] Last.fm error: {e}")
            return False

    def _search_tracks(self, account, params, query):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return

            search_type = "track"
            if query.startswith(".album "):
                search_type = "album"
                query = query[7:].strip()

            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type={search_type}&limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )

            if resp.status_code != 200:
                self._send_msg(params, "bio_error")
                return

            data = resp.json()
            items = data.get(f"{search_type}s", {}).get("items", [])
            if not items:
                self._send_msg(params, "no_track_playing")
                return

            self._search_cache[account] = items
            # Monta mensagem
            message = f"{tr('search_results')}\n\n"
            for i, item in enumerate(items, 1):
                title = item["name"]
                artists = ", ".join([a["name"] for a in item["artists"]])
                if search_type == "track":
                    album = item["album"]["name"]
                    message += f"{i}. {title}\nby {artists} • {album}\n\n"
                else:
                    total_tracks = item["total_tracks"]
                    release_date = item["release_date"][:4]
                    message += f"{i}. {title}\nby {artists} • {total_tracks} tracks • {release_date}\n\n"
            play_type = 'a track' if search_type == 'track' else 'an album'
            message += f"\n{tr('use_play_command').format(play_type) if 'use_play_command' in TRANSLATIONS else ''}"

            # Exibe em dialog
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(tr("search_results"))
            builder.set_message(message)
            # Corrigindo o callback do botão OK para não fechar o app
            builder.set_positive_button("OK", None)
            dialog = builder.create()
            run_on_ui_thread(dialog.show)

        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _get_recently_played(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/recently-played?limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            if resp.status_code != 200:
                self._send_msg(params, "bio_error")
                return
            data = resp.json()
            items = data.get("items", [])
            if not items:
                self._send_msg(params, "no_track_playing")
                return
            # Novo formato: título e lista numerada, indicando que são as mais recentes
            message = tr("recently_played_title") + "\n" + "\n".join([
                f"{i+1}. {item['track']['name']} — {', '.join([a['name'] for a in item['track']['artists']])}" for i, item in enumerate(items)
            ])
            fragment = get_last_fragment()
            def on_copy():
                # Usar context do fragment para compatibilidade
                if hasattr(fragment, 'getParentActivity') and fragment.getParentActivity():
                    context = fragment.getParentActivity()
                else:
                    from org.telegram.messenger import ApplicationLoader
                    context = ApplicationLoader.applicationContext
                
                # Copiar para clipboard usando context
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("message", message)
                clipboard.setPrimaryClip(clip)
                
                run_on_ui_thread(lambda: (BulletinHelper.show_success(tr("copied_bulletin"), fragment)))
            music_icon = getattr(R.raw, "music", R.raw.info)
            run_on_ui_thread(lambda: BulletinHelper.show_with_button(
                tr('list_bulletin_short'),
                music_icon,
                tr("copy_button"),
                on_copy,
                fragment
            ))
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _play_track(self, account, params, track_number):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            # Se for número, usa o cache da busca
            try:
                item_index = int(track_number) - 1
                if not hasattr(self, '_search_cache') or account not in self._search_cache:
                    self._send_msg(params, "no_track_playing")
                    return
                if item_index < 0 or item_index >= len(self._search_cache[account]):
                    self._send_msg(params, "error_invalid_number")
                    return
                item = self._search_cache[account][item_index]
                is_album = "total_tracks" in item
                play_request = {"context_uri": item["uri"]} if is_album else {"uris": [item["uri"]]}
            except ValueError:
                # Se não for número, tenta tocar pelo track_id
                track_id = track_number.strip()
                if not track_id or len(track_id) < 5:
                    self._send_msg(params, "error_invalid_number")
                    return
                play_request = {"uris": [f"spotify:track:{track_id}"]}
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/play",
                headers={"Authorization": f"Bearer {token}"},
                json=play_request,
                timeout=5
            )
            if resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
            elif resp.status_code != 204:
                self._send_msg(params, "bio_error")
            else:
                self._send_msg(params, "bulletin_playing")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _toggle_repeat(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 401:
                self._send_msg(params, "bio_error")
                return
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            elif resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
                return
            data = resp.json()
            current_repeat = data.get("repeat_state", "off")
            states = {"off": "context", "context": "track", "track": "off"}
            new_repeat = states.get(current_repeat, "off")
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/repeat?state={new_repeat}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 204:
                self._send_msg(params, f"repeat_{new_repeat}")
            else:
                self._send_msg(params, "bio_error")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _toggle_shuffle(self, params):
        try:
            token = self._get_access_token()
            if not token:
                self._send_msg(params, "bio_error")
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 401:
                self._send_msg(params, "bio_error")
                return
            elif resp.status_code == 403:
                self._send_msg(params, "error_premium_required")
                return
            elif resp.status_code == 404:
                self._send_msg(params, "no_track_playing")
                return
            data = resp.json()
            current_shuffle = data.get("shuffle_state", False)
            new_shuffle = not current_shuffle
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/shuffle?state={str(new_shuffle).lower()}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code == 204:
                state_key = "shuffle_enabled" if new_shuffle else "shuffle_disabled"
                self._send_msg(params, state_key)
            else:
                self._send_msg(params, "bio_error")
        except Exception as e:
            self._send_msg(params, f"Erro: {str(e)}")

    def _generate_minimal_card(self, track, params=None, force_spotify=False, etg_cover_image=None):
        try:
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            spotify_link = track["external_urls"]["spotify"]

            # Usar song.link se habilitado
            use_song_link = self.get_setting("use_song_link", False)
            show_track_link = self.get_setting("show_track_link", True)

            if use_song_link:
                track_link = self._get_song_link(spotify_link)
            else:
                track_link = spotify_link

            # Formatar texto com markdown V2
            playing_text = tr("playing")

            if show_track_link:
                message = f"{playing_text}\n*{title}* by *{artists}* • [Spotify]({track_link})"
            else:
                message = f"{playing_text}\n*{title}* by *{artists}*"
            
            # Adicionar bot_caption se estiver no modo NowCast
            is_nowcast_mode = getattr(self, '_nowcast_mode', False)
            if is_nowcast_mode:
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar variáveis {track}, {artist} e {album} no bot caption
                    processed_bot_caption = bot_caption.strip()
                    if "{track}" in processed_bot_caption or "{artist}" in processed_bot_caption or "{album}" in processed_bot_caption:
                        album = track.get("album", {}).get("name", "Unknown Album") if track.get("album") else "Unknown Album"
                        processed_bot_caption = processed_bot_caption.replace("{track}", title)
                        processed_bot_caption = processed_bot_caption.replace("{artist}", artists)
                        processed_bot_caption = processed_bot_caption.replace("{album}", album)
                    message += f"\n\n{processed_bot_caption}"
            # Parse markdown
            parsed = parse_markdown(message)
            # Enviar mensagem ou preparar dados para NowCast
            if params:
                params.message = parsed.text
                params.entities = ArrayList()
                for entity in parsed.entities:
                    params.entities.add(entity.to_tlrpc_object())

                # Verificar se está no modo NowCast
                if not getattr(self, '_nowcast_mode', False):
                    send_helper = get_send_messages_helper()
                    run_on_ui_thread(lambda: send_helper.sendMessage(params))
                # No modo NowCast, apenas preparar os dados (não enviar)
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _ensure_extera_font(self, font_id):
        """Baixa e cacheia a fonte selecionada se não existir."""
        import requests
        font_dir = "/storage/emulated/0/Android/media/com.exteragram.messenger/fonts"
        if not os.path.exists(font_dir):
            os.makedirs(font_dir)
        if font_id == 1:  # NotoSansCJK
            font_path = f"{font_dir}/exteraCJK.ttc"
            url = "https://github.com/googlefonts/noto-cjk/raw/main/Sans/OTC/NotoSansCJK-Regular.ttc"
        else:  # SourceSansPro
            return "/system/fonts/SourceSansPro-Bold.ttf"
        if not os.path.exists(font_path):
            try:
                # Usar cache otimizado para download da fonte
                font_data = self._get_cached_image_enhanced(url, f"font_{font_id}_{hash(url)}")
                if font_data:
                    with open(font_path, "wb") as f:
                        f.write(font_data)
            except Exception as e:
                pass  # Se falhar, ignora e usa a fonte padrão
        return font_path

    def _resize_with_aspect_ratio(self, img, target_size):
        """Redimensiona a imagem mantendo a proporção e centralizando-a"""
        # Cria uma imagem de fundo preta
        background = Image.new("RGBA", target_size, (30, 30, 30, 255))
        
        # Verifica se a imagem é muito mais larga ou alta
        width, height = img.size
        aspect_ratio = width / height
        target_aspect_ratio = target_size[0] / target_size[1]
        
        # SEMPRE usar min() para manter a proporção original e evitar espremimento
        # Isso garante que a imagem nunca seja distorcida, mesmo que resulte em áreas vazias
        ratio = min(target_size[0] / width, target_size[1] / height)
        
        new_size = (int(width * ratio), int(height * ratio))
        # Redimensiona a imagem original
        resized_img = img.resize(new_size, Image.LANCZOS)
        # Se a imagem redimensionada for maior que o alvo, recorta o centro
        if new_size[0] > target_size[0] or new_size[1] > target_size[1]:
            left = (new_size[0] - target_size[0]) // 2 if new_size[0] > target_size[0] else 0
            top = (new_size[1] - target_size[1]) // 2 if new_size[1] > target_size[1] else 0
            right = left + target_size[0] if new_size[0] > target_size[0] else new_size[0]
            bottom = top + target_size[1] if new_size[1] > target_size[1] else new_size[1]
            
            cropped_img = resized_img.crop((left, top, right, bottom)) 
            # Ajusta o tamanho final se necessário
            if cropped_img.size != target_size:
                background = Image.new("RGBA", target_size, (30, 30, 30, 255))
                pos_x = (target_size[0] - cropped_img.size[0]) // 2
                pos_y = (target_size[1] - cropped_img.size[1]) // 2
                background.paste(cropped_img, (pos_x, pos_y), cropped_img)
                return background
            
            return cropped_img
        else:
            # Calcula posição para centralizar
            pos_x = (target_size[0] - new_size[0]) // 2
            pos_y = (target_size[1] - new_size[1]) // 2
            
            # Cola a imagem redimensionada no centro do fundo
            background.paste(resized_img, (pos_x, pos_y), resized_img)
            return background


    def _generate_apple_unified_card(self, track, params=None, progress_ms=None, force_spotify=False, etg_cover_image=None):
        """Função unificada para gerar cards Apple usando o sistema de skin."""
        try:
            # Obter skin selecionada (0=Light, 1=Dark, 2=Red)
            apple_skin = self._get_apple_skin_index_mapped()
            
            # Validar se o índice está dentro dos limites válidos
            if apple_skin not in APPLE_SKIN_STYLE:
                apple_skin = 0  # Default para Light se índice inválido
            
            # Obter configurações de estilo baseadas na skin
            skin_style = APPLE_SKIN_STYLE[apple_skin]
            
            # Carregar imagem base usando o sistema unificado
            base_path = self._ensure_card_base_image(theme=0)
            img = Image.open(base_path).convert("RGBA")
            
            title = track["name"]
            artists = ", ".join([a["name"] for a in track["artists"]])
            target_size = (298, 298)
            
            # Usar a imagem de capa do ETG se disponível
            if etg_cover_image is not None:
                # Aplicar anti-aliasing avançado do Apple UI
                cover = self._apply_apple_antialiasing(etg_cover_image, target_size)
            else:
                # Detectar player atual
                player_name = self._detect_current_player()
                
                # Lógica específica para SoundCloud (igual ao CustomFM)
                if player_name == "SoundCloud":
                    # Primeiro tentar obter capa diretamente do SoundCloud
                    soundcloud_cover_url = self.get_soundcloud_cover(title, artists)
                    if soundcloud_cover_url:
                        try:
                            resp = requests.get(soundcloud_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do SoundCloud: {e}")
                            # Fallback para YouTube apenas se SoundCloud falhar
                            youtube_cover_url = self._get_youtube_cover(title, artists)
                            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                            try:
                                resp = requests.get(youtube_cover_url, timeout=10)
                                resp.raise_for_status()
                                cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                                cover = self._apply_apple_antialiasing(cover, target_size)
                            except Exception:
                                cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                    else:
                        # Fallback para YouTube se SoundCloud não retornar capa
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        try:
                            resp = requests.get(youtube_cover_url, timeout=10)
                            resp.raise_for_status()
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception as e:
                            log(f"Erro ao carregar capa do YouTube para SoundCloud: {e}")
                            cover = Image.new("RGBA", target_size, (30, 30, 30, 255))
                elif player_name in ("YouTube", "YouTube Music", "Yandex Music", "FM"):
                    # Lógica dedicada: obter capa do YouTube/YouTube Music/Yandex/FMs
                    try:
                        youtube_cover_url = self._get_youtube_cover(title, artists)
                        if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                            youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        # Aplicar anti-aliasing avançado do Apple UI
                        cover = self._apply_apple_antialiasing(cover, target_size)
                    except Exception as e:
                        log(f"Erro ao carregar capa do YouTube: {e}")
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
                else:
                    # Lógica original para outros players
                    images = track["album"].get("images", [])
                    cover_url = max(images, key=lambda i: i.get("width", 0))["url"] if images else None
                    if cover_url:
                        try:
                            resp = requests.get(cover_url, timeout=10)
                            cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                            # Aplicar anti-aliasing avançado do Apple UI
                            cover = self._apply_apple_antialiasing(cover, target_size)
                        except Exception:
                            # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                            cover = self._get_fallback_cover(title, artists)
                    else:
                        # Fallback obrigatório: tentar APIs, YouTube cover ou icondefault
                        cover = self._get_fallback_cover(title, artists)
            
            # Aplicar máscara arredondada
            mask = Image.new("L", (298, 298), 0)
            ImageDraw.Draw(mask).rounded_rectangle((0, 0, 298, 298), 30, fill=255)
            cover.putalpha(mask)
            img.paste(cover, (70, 153), cover)
            
            draw = ImageDraw.Draw(img)
            
            # Verificar se é Last.FM com Spotify configurado para ocultar exteraBar
            media_source = self.get_setting("media_source", 0)
            current_player_setting = self.get_setting("current_player", 0)
            is_lastfm_with_spotify = media_source == 1 and current_player_setting == 0  # Last.FM + Spotify
            
            # Mostrar exteraBar apenas se não for Last.FM com Spotify
            if self.get_setting("show_extera_bar", True) and not is_lastfm_with_spotify:
                player = self._detect_current_player()
                # exteraBar funciona apenas com Spotify, Apple Music e players .fm (não exteraGram/AyuGram)
                if player in ["Spotify", "Apple Music"] or (player and ".fm" in player.lower()):
                    # Chamar função exteraBar baseada na skin
                    exterabar_fn_name = skin_style["exteraBar_fn"]
                    if exterabar_fn_name == "exteraBarSeek_light_opposite":
                        self.exteraBarSeek_light_opposite(draw, track, progress_ms)
                    elif exterabar_fn_name == "exteraBarSeek_dark_opposite":
                        self.exteraBarSeek_dark_opposite(draw, track, progress_ms)
                    elif exterabar_fn_name == "exteraBarSeek_red_opposite":
                        self.exteraBarSeek_red_opposite(draw, track, progress_ms)
                    else:
                        # Fallback para dark_opposite
                        self.exteraBarSeek_dark_opposite(draw, track, progress_ms)
            
            # Configuração de fontes
            font_selector = self.get_setting("font_selector", 0)
            max_font_size = 54
            min_font_size = 36
            base_font_size = 42
            
            if len(title) <= 10:
                font_size = max_font_size
            elif len(title) <= 18:
                font_size = int(base_font_size + (max_font_size - base_font_size) * (18 - len(title)) / 8)
            else:
                font_size = min_font_size
            
            font_path_bold = self._get_font_path_by_selector(font_selector)
            font_path_regular = self._get_font_regular_by_selector(font_selector)
            
            # Prioridade: árabe > CJK > custom/padrão
            if self._is_arabic(artists):
                font_path_bold = "/system/fonts/NotoNaskhArabic-Bold.ttf"
                font_path_regular = "/system/fonts/NotoNaskhArabic-Regular.ttf"
            
            try:
                font_title = ImageFont.truetype(font_path_bold, font_size)
                font_artist = ImageFont.truetype(font_path_regular, 25)
                font_playing = ImageFont.truetype(font_path_regular, 26)
            except Exception as e:
                log(f"[Nowfy] Erro ao carregar fonte {font_path_bold} ou {font_path_regular}: {e}")
                font_title = ImageFont.load_default()
                font_artist = ImageFont.load_default()
                font_playing = ImageFont.load_default()
            
            # Configurações de texto baseadas na skin
            text_x = 400
            text_y = 160
            max_text_width = 600
            playing_text = tr("playing")
            
            if self._is_arabic(artists) or font_selector == 2:
                font_artist = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 25)
                font_playing = ImageFont.truetype("/system/fonts/NotoNaskhArabic-Regular.ttf", 26)
            
            if font_selector == 1:
                font_artist = ImageFont.truetype(self._ensure_extera_font(1), 25)
                font_playing = ImageFont.truetype(self._ensure_extera_font(1), 26)
            
            # Desenhar textos com cores da skin
            text_y = self.draw_multiline_text(draw, playing_text, (text_x, text_y), font_playing, skin_style["playing_color"], max_text_width)
            text_y += 12
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, skin_style["title_color"], max_text_width)
            text_y += 20
            
            # Desenhar artista com quebra automática
            if not self._is_arabic(artists):
                text_y = self.draw_multiline_text(draw, artists, (text_x, text_y), font_artist, skin_style["artist_color"], max_text_width)
            else:
                draw.text((text_x, text_y), artists, font=font_artist, fill=skin_style["artist_color"])
                left, top, right, bottom = font_artist.getbbox("Ay")
                text_y += (bottom - top) + 4
            

            
            # Salvar imagem
            temp_dir = File(ApplicationLoader.getFilesDirFixed(), "exteraFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            filename = f"{uuid.uuid4()}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else 4 if performance_mode == 1 else 6
            img.save(temp_path, format="PNG", optimize=True, compress_level=compress_level)
            
            if params:
                self._send_card_with_caption(params, temp_path, track, force_spotify)
                
        except Exception as e:
            if params:
                self._send_msg(params, f"Erro: {e}")

    def _get_album_or_playlist_name(self, track):
        """Obtém o nome do álbum ou playlist baseado no modo selecionado."""
        try:
            mode = self.get_setting("vinify_album_playlist_mode", 0)
            
            # 0 = Desabilitado
            if mode == 0:
                return None
            
            # Obter token de acesso
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Obter informações atuais da reprodução
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code != 200 or not resp.content:
                return None
                
            data = resp.json()
            context = data.get("context")
            item = data.get("item")
            
            # 1 = Automático (detecta se é playlist ou álbum)
            if mode == 1:
                if context and context.get("type") == "playlist":
                    # É uma playlist
                    playlist_uri = context.get("uri")
                    if playlist_uri:
                        playlist_id = playlist_uri.split(":")[-1]
                        return self._get_playlist_name(playlist_id, token)
                else:
                    # É um álbum ou single
                    if item and "album" in item and "name" in item["album"]:
                        return item["album"]["name"]
            
            # 2 = Forçar Álbum
            elif mode == 2:
                if item and "album" in item and "name" in item["album"]:
                    return item["album"]["name"]
            
            # 3 = Forçar Playlist
            elif mode == 3:
                if context and context.get("type") == "playlist":
                    playlist_uri = context.get("uri")
                    if playlist_uri:
                        playlist_id = playlist_uri.split(":")[-1]
                        return self._get_playlist_name(playlist_id, token)
            
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao obter álbum/playlist: {e}")
            return None
    
    def _get_playlist_name(self, playlist_id, token):
        """Obtém o nome da playlist via API."""
        try:
            playlist_resp = requests.get(
                f"https://api.spotify.com/v1/playlists/{playlist_id}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if playlist_resp.status_code == 200:
                playlist_data = playlist_resp.json()
                return playlist_data.get("name")
            return None
        except Exception as e:
            log(f"[Nowfy] Erro ao obter nome da playlist: {e}")
            return None
    

    def _get_current_device_info(self):
        """Obtém informações do dispositivo atual de reprodução usando API oficial do Spotify ou Stats.fm como fallback."""
        # Tentar primeiro a API oficial do Spotify
        device_info = self._get_device_from_spotify_api()
        if device_info:
            return device_info["name"]  # Manter compatibilidade retornando apenas o nome
        
        # Se falhar, tentar a API do Stats.fm como fallback
        device_info = self._get_device_from_statsfm_api()
        if device_info:
            return device_info["name"]
        
        return None
    
    def _get_current_device_full_info(self):
        """Obtém informações completas do dispositivo (nome e tipo) usando API oficial do Spotify ou Stats.fm como fallback."""
        # Verificar se o usuário selecionou um tipo específico no seletor
        device_type_setting = self.get_setting("statsfm_device_type", 0)
        
        # Se não for "Automático" (0), usar o tipo selecionado pelo usuário
        if device_type_setting != 0:
            # Mapear seleção para tipo de dispositivo
            device_type_map = {
                1: "smartphone",  # Smartphone
                2: "computer",    # Computador
                3: "speaker",     # Alto-falante
                4: "tv",          # TV
                5: "web"          # Navegador Web
            }
            
            selected_device_type = device_type_map.get(device_type_setting, "computer")
            
            # Tentar obter o nome do dispositivo do Spotify primeiro
            spotify_device = self._get_device_from_spotify_api()
            if spotify_device:
                return {
                    "name": spotify_device["name"],
                    "type": selected_device_type  # Usar o tipo selecionado pelo usuário
                }
            
            # Se Spotify falhar, tentar Stats.fm
            statsfm_device = self._get_device_from_statsfm_api()
            if statsfm_device:
                return {
                    "name": statsfm_device["name"],
                    "type": selected_device_type  # Usar o tipo selecionado pelo usuário
                }
            
            # Se ambos falharem, retornar um dispositivo padrão com o tipo selecionado
            return {
                "name": "Unknown Device",
                "type": selected_device_type
            }
        
        # Se for "Automático" (0), usar a lógica original
        # Tentar primeiro a API oficial do Spotify
        device_info = self._get_device_from_spotify_api()
        if device_info:
            return device_info
        
        # Se falhar, tentar a API do Stats.fm como fallback
        return self._get_device_from_statsfm_api()
    
    def _get_device_from_spotify_api(self):
        """Obtém informações do dispositivo usando a API oficial do Spotify."""
        try:
            token = self._get_access_token(show_error_bulletin=False)
            if not token:
                return None
            
            # Usar o endpoint correto para obter dispositivos
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/devices",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                devices = data.get("devices", [])
                
                # Procurar primeiro por dispositivo ativo
                for device in devices:
                    if device.get("is_active", False) and "name" in device:
                        return {
                            "name": device["name"],
                            "type": device.get("type", "computer").lower()
                        }
                
                # Se nenhum dispositivo estiver ativo, retornar o primeiro disponível
                if devices and "name" in devices[0]:
                    return {
                        "name": devices[0]["name"],
                        "type": devices[0].get("type", "computer").lower()
                    }
            
            return None
        except Exception as e:
            return None
    
    def _get_device_from_statsfm_api(self):
        """Obtém informações do dispositivo usando a API do Stats.fm."""
        try:
            # Primeiro, tentar obter o username do Stats.fm das configurações
            statsfm_username = self.get_setting("statsfm_username", "")
            if not statsfm_username:
                return None
            
            # Fazer requisição para a API do Stats.fm
            resp = requests.get(
                f"https://api.stats.fm/api/v1/users/{statsfm_username}/streams/current",
                timeout=5
            )
            
            if resp.status_code == 200 and resp.content:
                data = resp.json()
                
                # Verificar se há dados do item atual
                item = data.get("item")
                if item and "deviceName" in item:
                    device_name = item["deviceName"]
                    
                    # Obter tipo de dispositivo do seletor (Stats.fm não fornece tipo automaticamente)
                    device_type_setting = self.get_setting("statsfm_device_type", 0)
                    
                    # Mapear seleção para tipo de dispositivo
                    device_type_map = {
                        0: "computer",    # Automático (padrão)
                        1: "smartphone",  # Smartphone
                        2: "computer",    # Computador
                        3: "speaker",     # Alto-falante
                        4: "tv",          # TV
                        5: "web"          # Navegador Web
                    }
                    
                    device_type = device_type_map.get(device_type_setting, "computer")
                    
                    return {
                        "name": device_name,
                        "type": device_type
                    }
            
            return None
        except Exception as e:
            return None

    def _is_arabic(self, text):
        """Verifica se o texto contém caracteres árabes."""
        return any('\u0600' <= c <= '\u06FF' or '\u0750' <= c <= '\u077F' for c in text)

    def _get_custom_fonts_path(self):
        """Retorna o caminho da pasta de fontes customizadas."""
        return "/storage/emulated/0/Android/media/com.exteragram.messenger/fonts"

    def _list_custom_fonts(self):
        """Lista os arquivos de fontes customizadas (.ttf, .otf) na pasta padrão."""
        fonts_dir = self._get_custom_fonts_path()
        custom_fonts = []
        if os.path.exists(fonts_dir):
            for file in os.listdir(fonts_dir):
                if file.lower().endswith(('.ttf', '.otf')):
                    custom_fonts.append(file)
        return custom_fonts

    def _get_font_path_by_selector(self, font_selector):
        """Retorna o caminho da fonte de acordo com o índice do seletor, incluindo custom fonts."""
        custom_fonts = self._list_custom_fonts()
        # 0: SourceSansPro-Bold, 1: NotoSansCJK, 2: NotoNaskhArabic-Bold, 3+: custom
        if font_selector == 0:
            return "/system/fonts/SourceSansPro-Bold.ttf"
        elif font_selector == 1:
            return self._ensure_extera_font(1)
        elif font_selector == 2:
            return "/system/fonts/NotoNaskhArabic-Bold.ttf"
        elif font_selector > 2 and custom_fonts:
            idx = font_selector - 3
            if idx < len(custom_fonts):
                return os.path.join(self._get_custom_fonts_path(), custom_fonts[idx])
        return "/system/fonts/SourceSansPro-Bold.ttf"

    def _get_font_regular_by_selector(self, font_selector):
        """Retorna o caminho da fonte regular de acordo com o índice do seletor, incluindo custom fonts."""
        custom_fonts = self._list_custom_fonts()
        if font_selector == 0:
            return "/system/fonts/SourceSansPro-Regular.ttf"
        elif font_selector == 1:
            return self._ensure_extera_font(1)
        elif font_selector == 2:
            return "/system/fonts/NotoNaskhArabic-Regular.ttf"
        elif font_selector > 2 and custom_fonts:
            idx = font_selector - 3
            if idx < len(custom_fonts):
                return os.path.join(self._get_custom_fonts_path(), custom_fonts[idx])
        return "/system/fonts/SourceSansPro-Regular.ttf"

    def _get_font_for_title(self, text, selector, max_size=28, min_size=28, base_size=28, force_bold=False):
        # Notas do dev:
        # Como no default original o título é fixo em 28, deixei fixo, 
        # mas se quiser pode adaptar tamanho aqui também, mantendo 28 fixo é igual ao original
        # Se force_bold for True, sempre usa a fonte em negrito
        if force_bold:
            return ImageFont.truetype(self._get_font_path_by_selector(selector), max_size)
        else:
            return ImageFont.truetype(self._get_font_regular_by_selector(selector), max_size)

    def _get_font_for_artist(self, artist_text, selector, size=22, force_bold=False):
        if self._is_arabic(artist_text):
            # Para texto árabe, usar a fonte apropriada (regular ou bold)
            font_path = "/system/fonts/NotoNaskhArabic-Bold.ttf" if force_bold else "/system/fonts/NotoNaskhArabic-Regular.ttf"
            return ImageFont.truetype(font_path, size)
        # Para outros idiomas, usar a fonte regular ou bold conforme solicitado
        if force_bold:
            return ImageFont.truetype(self._get_font_path_by_selector(selector), size)  # Fonte em negrito
        else:
            return ImageFont.truetype(self._get_font_regular_by_selector(selector), size)  # Fonte regular

    def _get_default_font(self, size=20):
        return ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", size)

    # Utilitário para desenhar texto multilinha com quebra automática
    def draw_multiline_text(self, draw, text, position, font, fill, max_width, line_spacing=4):
        words = text.split() if " " in text else ([text] if len(text) <= 5 else list(text))
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            if draw.textbbox((0, 0), test_line, font=font)[2] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        x, y = position
        for line in lines:
            draw.text((x, y), line, font=font, fill=fill)
            left, top, right, bottom = font.getbbox("Ay")
            y += (bottom - top) + line_spacing
        return y

    def get_text_dimensions(self, text, font):
        """Função auxiliar para obter dimensões de texto de forma compatível com diferentes versões do PIL/Pillow"""
        try:
            # Método mais recente (Pillow >= 9.2.0)
            left, top, right, bottom = font.getbbox(text)
            return right - left, bottom - top
        except AttributeError:
            try:
                # Método antigo
                return font.getsize(text)
            except AttributeError:
                # Fallback para estimativa
                return len(text) * 8, font.size

    def get_multiline_height(self, draw, text, font, max_width, line_spacing=4):
        words = text.split() if " " in text else ([text] if len(text) <= 5 else list(text))
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            width, _ = self.get_text_dimensions(test_line, font)
            if width <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        _, height = self.get_text_dimensions("Ay", font)
        return (height + line_spacing) * len(lines)

    def _about_custom_fonts_dialog(self, view=None):
        try:
            import requests
            import json
            import time

            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(tr("about_custom_fonts"))

            try:
                timestamp = int(time.time())
                response = requests.get(f'https://raw.githubusercontent.com/soumaki/nowFy/refs/heads/main/customfonts.json?t={timestamp}')
                fonts_data = json.loads(response.text)

                if 'image_url' in fonts_data:
                    try:
                        if fonts_data['image_url'].endswith('.svg'):
                            builder.set_icon(fonts_data['image_url'], "#FFFFFF")
                        else:
                            img_response = requests.get(fonts_data['image_url'], timeout=5)
                            if img_response.status_code == 200:
                                builder.set_icon_from_bytes(img_response.content)
                    except Exception as e:
                        log(f"Error loading custom fonts image: {e}")

                try:
                    system_language = Locale.getDefault().getLanguage()
                except:
                    system_language = "en"
                fonts_info = fonts_data.get('custom_fonts_info', {})
                
                lang_content = fonts_info.get(system_language) or fonts_info.get('en')
                
                if lang_content:
                    message = lang_content['description'] + '\n\n'
                    for step in lang_content['steps']:
                        message += f'• {step}\n'
                else:
                    message = 'Information not available in your language.'

                builder.set_message(message)
            except Exception as e:
                builder.set_message(f"Error loading custom fonts info: {str(e)}\n\nPlease try again later.")
            builder.set_positive_button("OK", None)
            run_on_ui_thread(lambda: builder.show())
        except Exception as e:
            log(f"Error showing custom fonts dialog: {e}")

    def _show_custom_fonts_help(self):
        # Alias para manter compatibilidade
        self._about_custom_fonts_dialog()

    def _show_premium_emoji_help(self):
        """Mostra dialog com informações sobre como usar Premium Emoji"""
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("premium_emoji_help_title"))
                builder.set_message(tr("premium_emoji_help_content"))
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao mostrar Premium Emoji Help: {e}")

    def _show_youtube_api_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("youtube_api_title"))
                builder.set_message(tr("youtube_api_guide"))
                builder.set_positive_button("OK", lambda b, w: b.dismiss())
                builder.set_neutral_button(tr("get_api_key"), lambda b, w: self._open_youtube_api_guide())
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir YouTube API Dialog: {e}")

    def _show_lastfm_api_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("lastfm_title"))
                builder.set_message(tr("lastfm_content"))
                builder.set_positive_button(tr("lastfm_get_api_key"), lambda b, w: self._open_lastfm_api_guide())
                builder.set_negative_button(tr("cancel"), None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM API dialog: {e}")

    def _show_integration_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("integration_media_source_info"))
                builder.set_message(tr("integration_media_source_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing integration info dialog: {e}")

    def _show_credentials_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("credentials_info"))
                builder.set_message(tr("credentials_info_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing credentials info dialog: {e}")

    def _show_spotify_control_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("spotify_control"))
                builder.set_message(tr("spotify_control_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing Spotify Control dialog: {e}")

    def _show_bio_command_info_dialog(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("bio_command_info"))
                builder.set_message(tr("bio_command_info_dialog"))
                builder.set_positive_button("OK", None)
                run_on_ui_thread(builder.show)
        except Exception as e:
            log(f"[Nowfy] Error showing bio command info dialog: {e}")

    def _on_player_changed(self, value):
        """Callback chamado quando o player ativo é alterado"""
        try:
            players = ["Spotify", "YouTube", "YouTube Music", "exteraGram", "AyuGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"]
            if 0 <= value < len(players) and players[value] == "Yandex Music":
                # Mostrar dialog informativo sobre Yandex Music
                self._show_yandex_music_dialog()
        except Exception as e:
            log(f"[Nowfy] Error in _on_player_changed: {e}")

    def _show_yandex_music_dialog(self):
        """Mostra dialog informativo sobre Yandex Music"""
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                
                def show_dialog():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title(tr("yandex_music_dialog_title"))
                        builder.set_message(tr("yandex_music_dialog_content"))
                        builder.set_positive_button("OK", lambda b, w: b.dismiss())
                        builder.show()
                    except Exception as e:
                        log(f"[Nowfy] Error creating Yandex Music dialog: {e}")
                
                run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing Yandex Music dialog: {e}")

    def _open_youtube_api_guide(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/soumaki/nowFy/blob/main/ytkey/guide.md#youtube-api-key-youtube-data-api-v3"))
                run_on_ui_thread(lambda: ctx.startActivity(intent))
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir YouTube API Guide: {e}")

    def _open_lastfm_api_guide(self):
        try:
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://www.last.fm/api/account/create"))
                run_on_ui_thread(lambda: ctx.startActivity(intent))
        except Exception as e:
            log(f"[Nowfy] Erro ao abrir LastFM API Guide: {e}")

    def _resume_playback_only(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/play",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_resumed"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _pause_playback_only(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/player/pause",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_paused"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _skip_track(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.post(
                "https://api.spotify.com/v1/me/player/next",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_skipped"))
                
                # Ativar pré-carregamento após pular faixa
                if self.get_setting("enable_preload", False):
                    # Aguardar um pouco para a nova faixa começar
                    def delayed_preload():
                        time.sleep(1)
                        self._preload_next_track_cover()
                    threading.Thread(target=delayed_preload, daemon=True).start()
                    
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _previous_track(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.post(
                "https://api.spotify.com/v1/me/player/previous",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_previous"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _set_volume(self, params, value):
        try:
            if not isinstance(value, int) or value < 0 or value > 100:
                BulletinHelper.show_info(tr("error_invalid_volume"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/volume?volume_percent={value}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_volume_set").format(value=value))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _set_repeat(self, params, mode):
        try:
            if mode not in ("off", "context", "track"):
                BulletinHelper.show_info(tr("error_invalid_repeat"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                f"https://api.spotify.com/v1/me/player/repeat?state={mode}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr(f"bulletin_repeat_{mode}"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _like_track(self, params, track_id):
        try:
            if not track_id or len(track_id) < 5:
                BulletinHelper.show_info(tr("error_missing_like"))
                return
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.put(
                "https://api.spotify.com/v1/me/tracks",
                headers={"Authorization": f"Bearer {token}"},
                json={"ids": [track_id]},
                timeout=5
            )
            if resp.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_liked"))
            elif resp.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif resp.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _like_current_track(self, params):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.get(
                "https://api.spotify.com/v1/me/player/currently-playing",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code != 200 or not resp.content:
                BulletinHelper.show_info(tr("error_no_track_playing"))
                return
            data = resp.json()
            track = data.get("item")
            if not track or not track.get("id"):
                BulletinHelper.show_info(tr("error_no_track_playing"))
                return
            track_id = track["id"]
            # Verifica se já está curtida
            check = requests.get(
                f"https://api.spotify.com/v1/me/tracks/contains?ids={track_id}",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if check.status_code == 200 and check.json()[0]:
                BulletinHelper.show_info(tr("bulletin_already_liked"))
                return
            # Curtir a música
            like = requests.put(
                "https://api.spotify.com/v1/me/tracks",
                headers={"Authorization": f"Bearer {token}"},
                json={"ids": [track_id]},
                timeout=5
            )
            if like.status_code in (200, 202, 204):
                BulletinHelper.show_info(tr("bulletin_liked"))
            elif like.status_code == 403:
                BulletinHelper.show_info(tr("error_premium_required"))
            elif like.status_code == 404:
                BulletinHelper.show_info(tr("error_no_active_device"))
            else:
                BulletinHelper.show_info(tr("error_unknown"))
        except Exception as e:
            BulletinHelper.show_info(tr("error_unknown"))

    def _search_spotify(self, params, query):
        try:
            token = self._get_access_token()
            if not token:
                if self._should_show_error_bulletin("auth_error"):
                    BulletinHelper.show_info(tr("error_auth"))
                return
            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=5",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            if resp.status_code != 200:
                BulletinHelper.show_info(tr("error_unknown"))
                return
            data = resp.json()
            items = data.get("tracks", {}).get("items", [])
            if not items:
                BulletinHelper.show_info(tr("no_track_playing"))
                return
            # Salva o resultado em cache para o usuário poder usar .play N
            account = getattr(params, 'account', None)
            if account is not None:
                self._search_cache[account] = items
            # Monta mensagem markdown
            message = tr("search_results") + "\n\n"
            for i, item in enumerate(items, 1):
                title = item["name"]
                artists = ", ".join([a["name"] for a in item["artists"]])
                track_id = item["id"]
                message += f"{i}. *{title}* — _{artists}_\nID: `{track_id}`\n\n"
            message += tr("use_play_command") if "use_play_command" in TRANSLATIONS else ""
            try:
                from java.util import ArrayList
                parsed = parse_markdown(message)
                params.message = parsed.text
                params.entities = ArrayList()
                for entity in parsed.entities:
                    params.entities.add(entity.to_tlrpc_object())
                run_on_ui_thread(lambda: get_send_messages_helper().sendMessage(params))
            except Exception as e:
                BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Markdown error: {str(e)}")
        except Exception as e:
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Search error: {str(e)}")

    def _get_current_track_soundcloud(self, account):
        from android_utils import log
        log("[Nowfy] _get_current_track_soundcloud chamado, mas não implementado.")
        # TODO: Implementar integração real com SoundCloud
        return None

    def _get_current_track_lastfm(self, account, params, progress_dialog=None, show_bulletins=True):
        try:
            log(f"[DEBUG] _get_current_track_lastfm: current_player setting: {self.get_setting('current_player', 0)}")
            log(f"[Nowfy] Starting LastFM track fetch...")

            player = self._detect_current_player()
            log(f"[Nowfy] Player detected: {player}")

            # --- Segue fluxo normal para LastFM/etg/YouTube ---
            user = self.get_setting("lastfm_username", "")
            api_key = self.get_setting("lastfm_api_key", "")
            youtube_api_key = self.get_setting("youtube_api_key", "")
            if not user or not api_key:
                log(f"[Nowfy] LastFM credentials missing - User: {bool(user)}, API Key: {bool(api_key)}")
                if show_bulletins:
                    BulletinHelper.show_info(tr("error_lastfm_credentials") if "error_lastfm_credentials" in TRANSLATIONS else "LastFM credentials missing.")
                return

            resp = requests.get(
                "https://ws.audioscrobbler.com/2.0/",
                params={
                    "method": "user.getrecenttracks",
                    "user": user,
                    "api_key": api_key,
                    "format": "json",
                    "limit": 1
                },
                timeout=3
            )
            data = resp.json()
            tracks = data.get("recenttracks", {}).get("track", [])
            if not tracks:
                if show_bulletins:
                    if player in ["exteraGram", "AyuGram", "Telegram"]:
                        BulletinHelper.show_info(tr("no_track_playing_generic"))
                    else:
                        self._show_no_track_playing_bulletin()
                return

            track = tracks[0]
            title = track["name"]
            artist = track["artist"]["#text"]
            album = track.get("album", {}).get("#text", "")
            image_url = track.get("image", [{}])[-1].get("#text", "")
            theme_style = self.get_setting("lastfm_theme_style", 0)
            youtube_url = None
            etg_cover_image = None

            is_playing = False
            # Last.fm nem sempre inclui @attr.nowplaying - assumir que está tocando se não tiver o atributo
            if "@attr" in track:
                is_playing = track["@attr"].get("nowplaying") == "true"
            else:
                # Se não tem o atributo @attr, assumir que a música mais recente está tocando
                is_playing = True

            if player == "SoundCloud":
                soundcloud_url = None
                if "url" in track:
                    soundcloud_url = track["url"]
                    if "soundcloud.com" not in soundcloud_url:
                        search_query = f"{title} {artist}"
                        soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                else:
                    search_query = f"{title} {artist}"
                    soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                if "external_urls" not in track or not isinstance(track["external_urls"], dict):
                    track["external_urls"] = {}
                track["external_urls"]["soundcloud"] = soundcloud_url

                youtube_url = soundcloud_url

            # Detectar música do Telegram se for o player selecionado
            telegram_cover_image = None
            if player in ["exteraGram", "AyuGram", "Telegram"]:
                log(f"[Nowfy] Processing {player} player...")
                from org.telegram.messenger import MediaController
                media_controller = MediaController.getInstance()
                playing_song = media_controller.getPlayingMessageObject()
                
                log(f"[Nowfy] Playing song object: {playing_song}")
                
                telegram_track = self.get_current_track_etg(account)
                log(f"[Nowfy] Telegram track data: {telegram_track}")
                
                if telegram_track:
                    title = telegram_track["title"]
                    artist = telegram_track["artist"]
                    log(f"[Nowfy] Using {player} track - Title: '{title}', Artist: '{artist}'")
                    
                    # Buscar capa do Telegram
                    telegram_cover_image = self.get_etg_cover(playing_song)
                    log(f"[Nowfy] {player} cover search result: {'Found' if telegram_cover_image else 'Not found'}")
                else:
                    log(f"[Nowfy] No {player} track found")
                    if show_bulletins:
                        BulletinHelper.show_info(tr("no_track_playing_generic"))
                    return

            elif player in ("YouTube", "YouTube Music") and youtube_api_key:
                youtube_url = self._search_youtube_url(title, artist, youtube_api_key)

            log(f"[Nowfy] Final data - Title: '{title}', Artist: '{artist}', Player: '{player}', Telegram cover: {'Available' if telegram_cover_image else 'None'}")

            if self.get_setting("enable_autobio", False):
                autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                bio = autobio_text.format(track=title, artist=artist)
                run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                if self.get_setting("show_bio_notification", True):
                    if self.get_setting("enable_auto_bio_update", True):
                        BulletinHelper.show_info(tr("bio_updated_short"))
                    else:
                        BulletinHelper.show_info(tr("bio_notification_disabled"))

            # Usar o tema selecionado pelo usuário
            theme = self.get_setting("theme_selector", 0)
            random_theme = self.get_setting("random_theme_mode", False)
            
            if random_theme:
                external_themes = self._get_external_themes()
                # Calcular índices dos temas
                vinni_index = 3 + len(external_themes)
                customfm_index = vinni_index + 1
                minimal_index = customfm_index + 1
                
                theme_options = [0, 1, 2]  # Temas Apple
                if external_themes:
                    theme_options.extend(range(3, 3 + len(external_themes)))  # Temas externos
                theme_options.extend([vinni_index, customfm_index, minimal_index])  # Vinni, CustomFM, Minimal
                theme = random.choice(theme_options)
            
            # Buscar capa do SoundCloud se necessário (antes de criar track_obj)
            if player == "SoundCloud":
                soundcloud_cover_url = self.get_soundcloud_cover(title, artist)
                if soundcloud_cover_url:
                    image_url = soundcloud_cover_url
                    log(f"[Nowfy] Using SoundCloud cover: {soundcloud_cover_url}")

            # Buscar link do Spotify se necessário
            spotify_url = None
            if player != "SoundCloud":
                try:
                    spotify_url = self._search_spotify_url(title, artist)
                except Exception as e:
                    log(f"[Nowfy] Error searching Spotify URL: {e}")
            
            # Track para compatibilidade (criado após busca de capa do SoundCloud)
            track_obj = {
                "name": title,
                "artists": [{"name": artist}],
                "album": {
                    "name": album,
                    "images": [{"url": image_url, "width": 640, "height": 640}] if image_url else []
                },
                "external_urls": {
                    "spotify": youtube_url if player == "SoundCloud" else spotify_url
                },
                "duration_ms": 0
            }
            # Sistema de geração de cards baseado no tema selecionado
            if theme >= 5:  # Tema externo
                external_themes = self._get_external_themes()
                if external_themes:
                    external_theme_index = theme - 5
                    external_theme_ids = list(external_themes.keys())
                    if external_theme_index < len(external_theme_ids):
                        theme_id = external_theme_ids[external_theme_index]
                        self._generate_external_theme_card(track_obj, params, 0, theme_id, 
                                                          external_themes[theme_id], 
                                                          force_spotify=False, 
                                                          telegram_cover_image=telegram_cover_image)
                        return True
            
            # Temas internos
            if theme == 4:  # CustomFM
                self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
            elif theme == 3:  # Default (LastFM-StatsFM)
                if theme_style == 0:
                    self._get_current_track_lastfm_default(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
                else:
                    self._get_current_track_lastfm_customfm(title, artist, album, image_url, params, progress_dialog, player, youtube_url, telegram_cover_image)
            elif theme in [0, 1, 2]:  # Temas Apple para Last.FM
                # Usar o sistema de geração de cards padrão com temas Apple para todos os players
                self._generate_card(track_obj, params, theme, force_spotify=True, etg_cover_image=telegram_cover_image, is_fm_command=True)
            else:
                # Calcular índices dos temas
                external_themes = self._get_external_themes()
                vinni_index = 3 + len(external_themes)
                customfm_index = vinni_index + 1
                minimal_index = customfm_index + 1
                
                if theme == minimal_index:  # Tema Minimal
                    self._generate_card(track_obj, params, theme, force_spotify=True, etg_cover_image=telegram_cover_image, is_fm_command=True)
                else:  # Usar o sistema de geração de cards padrão
                    self._generate_card(track_obj, params, 0, force_spotify=False, etg_cover_image=telegram_cover_image, is_fm_command=False)
            return True

        except Exception as e:
            if show_bulletins:
                BulletinHelper.show_info(tr("error_lastfm").format(error=str(e)) if "error_lastfm" in TRANSLATIONS else f"LastFM error: {str(e)}")

    def _search_youtube_url(self, title, artist, api_key):
        try:
            query = f"{title} {artist}"
            resp = requests.get(
                "https://www.googleapis.com/youtube/v3/search",
                params={
                    "part": "snippet",
                    "q": query,
                    "key": api_key,
                    "type": "video",
                    "maxResults": 1
                },
                timeout=5
            )
            data = resp.json()
            items = data.get("items", [])
            if items:
                video_id = items[0]["id"]["videoId"]
                return f"https://youtu.be/{video_id}"
        except Exception:
            pass
        return None

    # --- CUSTOMFM LASTFM-STATSFM THEME ---
    def _generate_gradient_background(self, card_width, card_height, album_cover=None):
        """Gera background com gradiente dinâmico baseado nas configurações do Visual Avançado"""
        try:
            # Verificar se gradientes estão habilitados
            if not self.get_setting("visual_avancado_gradiente_enable", False):
                return None
                
            # Obter configurações de gradiente
            gradient_mode = self.get_setting("visual_avancado_gradiente_modo", 0)  # 0=Automático, 1=Personalizado
            gradient_style = self.get_setting("visual_avancado_gradiente_style", 0)  # 0=Linear, 1=Radial, 2=Diagonal
            gradient_direction = self.get_setting("visual_avancado_gradiente_direction", 0)  # 0=Cima para Baixo, 1=Esquerda para Direita, 2=Diagonal
            gradient_intensity = self.get_setting("visual_avancado_gradiente_intensity", 1)  # 0=Suave, 1=Médio, 2=Intenso
            gradient_extraction = self.get_setting("visual_avancado_color_extraction", 0)  # 0=Dominante, 1=Complementares, 2=Análogas
            
            # Definir cores do gradiente
            if gradient_mode == 0 and album_cover:  # Automático - extrair da capa
                colors = self._extract_colors_from_cover(album_cover, gradient_extraction)
                log(f"[NowFy] Usando cores extraídas da capa: {colors}")
            else:  # Personalizado
                color1 = self.get_setting("visual_avancado_gradiente_cor1", "#FF6B6B")
                color2 = self.get_setting("visual_avancado_gradiente_cor2", "#4ECDC4")
                colors = [color1, color2]
                log(f"[NowFy] Usando cores personalizadas: {color1} -> {color2}")
            
            # Criar gradiente
            gradient_img = Image.new("RGBA", (card_width, card_height))
            
            if gradient_style == 0:  # Linear
                gradient_img = self._create_linear_gradient(card_width, card_height, colors, gradient_direction, gradient_intensity)
            elif gradient_style == 1:  # Radial
                gradient_img = self._create_radial_gradient(card_width, card_height, colors, gradient_intensity)
            elif gradient_style == 2:  # Diagonal
                gradient_img = self._create_diagonal_gradient(card_width, card_height, colors, gradient_direction, gradient_intensity)
            
            return gradient_img
            
        except Exception as e:
            log(f"[NowFy] Erro ao gerar gradiente: {e}")
            return None
    
    def _extract_colors_from_cover(self, album_cover, extraction_mode):
        """Extrai cores da capa do álbum para gradientes automáticos"""
        try:
            from collections import Counter
            import colorsys
            
            # Redimensionar para análise mais rápida
            small_cover = album_cover.resize((50, 50), Image.LANCZOS)
            pixels = list(small_cover.getdata())
            
            # Filtrar pixels muito escuros ou muito claros
            filtered_pixels = []
            for pixel in pixels:
                if len(pixel) >= 3:
                    r, g, b = pixel[:3]
                    brightness = (r + g + b) / 3
                    if 30 < brightness < 225:  # Evitar preto/branco puros
                        filtered_pixels.append((r, g, b))
            
            if not filtered_pixels:
                return ["#FF6B6B", "#4ECDC4"]  # Fallback
            
            # Encontrar cor dominante
            color_counts = Counter(filtered_pixels)
            dominant_color = color_counts.most_common(1)[0][0]
            
            if extraction_mode == 0:  # Dominante + variação
                r, g, b = dominant_color
                # Criar segunda cor com variação de matiz
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.3) % 1.0  # Rotacionar matiz
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
                
            elif extraction_mode == 1:  # Complementares
                r, g, b = dominant_color
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.5) % 1.0  # Cor complementar
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
                
            else:  # Análogas
                r, g, b = dominant_color
                h, s, v = colorsys.rgb_to_hsv(r/255, g/255, b/255)
                h2 = (h + 0.15) % 1.0  # Cor análoga
                r2, g2, b2 = colorsys.hsv_to_rgb(h2, s, v)
                color2 = (int(r2*255), int(g2*255), int(b2*255))
            
            # Converter para hex
            color1_hex = f"#{r:02x}{g:02x}{b:02x}"
            color2_hex = f"#{color2[0]:02x}{color2[1]:02x}{color2[2]:02x}"
            
            return [color1_hex, color2_hex]
            
        except Exception as e:
            log(f"[NowFy] Erro ao extrair cores: {e}")
            return ["#FF6B6B", "#4ECDC4"]
    
    def _create_linear_gradient(self, width, height, colors, direction, intensity):
        """Cria gradiente linear"""
        gradient = Image.new("RGBA", (width, height))
        
        # Converter cores hex para RGB
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        # Definir intensidade (alpha)
        alpha_values = [128, 180, 255]  # Suave, Médio, Intenso
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        for i in range(width if direction == 1 else height):
            if direction == 0:  # Cima para Baixo
                ratio = i / height
                for x in range(width):
                    r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                    g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                    b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                    gradient.putpixel((x, i), (r, g, b, alpha))
            else:  # Esquerda para Direita
                ratio = i / width
                for y in range(height):
                    r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                    g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                    b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                    gradient.putpixel((i, y), (r, g, b, alpha))
        
        return gradient
    
    def _create_radial_gradient(self, width, height, colors, intensity):
        """Cria gradiente radial"""
        gradient = Image.new("RGBA", (width, height))
        
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        alpha_values = [128, 180, 255]
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        center_x, center_y = width // 2, height // 2
        max_distance = ((width/2)**2 + (height/2)**2)**0.5
        
        for x in range(width):
            for y in range(height):
                distance = ((x - center_x)**2 + (y - center_y)**2)**0.5
                ratio = min(distance / max_distance, 1.0)
                
                r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                gradient.putpixel((x, y), (r, g, b, alpha))
        
        return gradient
    
    def _create_diagonal_gradient(self, width, height, colors, direction, intensity):
        """Cria gradiente diagonal"""
        gradient = Image.new("RGBA", (width, height))
        
        def hex_to_rgb(hex_color):
            hex_color = hex_color.lstrip('#')
            return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        color1_rgb = hex_to_rgb(colors[0])
        color2_rgb = hex_to_rgb(colors[1])
        
        alpha_values = [128, 180, 255]
        alpha = alpha_values[intensity] if intensity < len(alpha_values) else 180
        
        max_distance = (width + height)
        
        for x in range(width):
            for y in range(height):
                if direction == 2:  # Diagonal ↗
                    distance = x + (height - y)
                else:  # Diagonal ↘ (padrão)
                    distance = x + y
                
                ratio = min(distance / max_distance, 1.0)
                
                r = int(color1_rgb[0] * (1 - ratio) + color2_rgb[0] * ratio)
                g = int(color1_rgb[1] * (1 - ratio) + color2_rgb[1] * ratio)
                b = int(color1_rgb[2] * (1 - ratio) + color2_rgb[2] * ratio)
                gradient.putpixel((x, y), (r, g, b, alpha))
        
        return gradient

    def _get_current_track_lastfm_customfm(
        self, title, artist, album, image_url, params,
        progress_dialog=None, player=None, youtube_url=None,
        telegram_cover_image=None, font_name=None, font_size=None
    ):
        try:
            # Importar todas as dependências da PIL no início
            from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps
            from io import BytesIO
            import requests
            
            log(f"[Nowfy] CustomFM theme - Starting with title: '{title}', artist: '{artist}', player: '{player}', telegram_cover: {telegram_cover_image is not None}")
            if progress_dialog:
                run_on_ui_thread(lambda: progress_dialog.set_progress(50))

            player_name = self._detect_current_player()
            send_helper = get_send_messages_helper()
            base_dir = ApplicationLoader.getFilesDirFixed()
            temp_dir = File(base_dir, "nowFy")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            # Verificar se alta resolução está ativada
            use_high_res = self.get_setting("customfm_high_resolution", False)
            if use_high_res:
                card_width, card_height = 1920, 1080
            else:
                card_width, card_height = 1012, 512
            
            # Cache key para otimização de performance
            cache_key = f"customfm_{title}_{artist}_{use_high_res}_{self.get_setting('lastfm_customfm_background_color', '#d2d2d2')}_{self.get_setting('lastfm_customfm_text_color', '#000000')}_{self.get_setting('lastfm_customfm_cover_position', 0)}"
            cache_key = hashlib.md5(cache_key.encode()).hexdigest()
            
            # Verificar cache primeiro para melhor performance
            cached_path = self._get_cached_customfm_image(cache_key, temp_dir)
            if cached_path and File(cached_path).exists():
                log(f"[Nowfy] CustomFM cache hit - usando imagem em cache: {cached_path}")
                return cached_path
            
            filename = f"customfm_{cache_key}.png"
            temp_path = File(temp_dir, filename).getAbsolutePath()
                
            use_bg = self.get_setting("lastfm_customfm_use_background", True)
            bg_color = self.get_setting("lastfm_customfm_background_color", "#d2d2d2")
            text_color = self.get_setting("lastfm_customfm_text_color", "#000000")
            # Ajustar tamanho da mini capa baseado na resolução
            if use_high_res:
                mini_cover_size = 570  # Proporcionalmente maior para 1920x1080
            else:
                mini_cover_size = 300
            
            # Verificar a posição da mini capa (esquerda ou direita)
            cover_position = self.get_setting("lastfm_customfm_cover_position", 0)  # 0 = Esquerda, 1 = Direita
            
            # Definir padding com base na posição da capa e resolução
            base_padding = 95 if use_high_res else 50
            text_spacing = 75 if use_high_res else 40
            
            if cover_position == 0:  # Esquerda (padrão)
                padding_left = base_padding
                text_start_x = padding_left + mini_cover_size + text_spacing  # Texto à direita da capa
            else:  # Direita
                padding_left = card_width - mini_cover_size - base_padding  # Capa à direita
                text_start_x = base_padding  # Texto à esquerda
                
            padding_top = (card_height - mini_cover_size) // 2
            # --- CAPA (OTIMIZADA) ---
            album_cover = None
            cover_cache_key = f"cover_{title}_{artist}_{mini_cover_size}"
            
            # Tentar cache primeiro para melhor performance
            try:
                from PIL import Image, ImageOps
                if telegram_cover_image and player_name in ["exteraGram", "AyuGram", "Telegram"]:
                    album_cover = telegram_cover_image.resize((mini_cover_size, mini_cover_size), Image.LANCZOS)
                elif player_name in ["YouTube", "YouTube Music", "Yandex Music"]:
                    # Usar cache para YouTube covers
                    cached_image = self._get_cached_image_enhanced(
                        self._get_youtube_cover(title, artist), 
                        cache_key=cover_cache_key,
                        force_size=(mini_cover_size, mini_cover_size)
                    )
                    if cached_image:
                        # Converter bytes para PIL Image se necessário
                        if isinstance(cached_image, bytes):
                            try:
                                album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                # Usar ImageOps.fit para manter proporção sem distorção
                                from PIL import ImageOps
                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                album_cover = album_cover.convert("RGBA")
                            except Exception as e:
                                log(f"[Nowfy] Error converting cached bytes to PIL Image: {e}")
                                album_cover = self._get_icondefault_cached(mini_cover_size)
                        else:
                            # Mesmo quando o cache retorna uma Image, garantir corte consistente
                            try:
                                album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                            except Exception:
                                album_cover = cached_image
                    else:
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                elif player_name == "SoundCloud":
                    # Processamento específico para SoundCloud com fallback para YouTube
                    try:
                        # Primeiro tentar obter capa diretamente do SoundCloud
                        soundcloud_cover_url = self.get_soundcloud_cover(title, artist)
                        cover_url = None
                        
                        if soundcloud_cover_url:
                            cover_url = soundcloud_cover_url
                            log(f"[Nowfy] CustomFM: Using SoundCloud cover: {soundcloud_cover_url}")
                        else:
                            # Fallback para YouTube se SoundCloud não retornar capa
                            youtube_cover_url = self._get_youtube_cover(title, artist)
                            if youtube_cover_url and youtube_cover_url != "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                cover_url = youtube_cover_url
                                log(f"[Nowfy] CustomFM: SoundCloud fallback to YouTube cover: {youtube_cover_url}")
                        
                        if cover_url:
                            log(f"[Nowfy] CustomFM: Processing SoundCloud cover URL: {cover_url}")
                            
                            # Tentar baixar a imagem diretamente primeiro
                            try:
                                import requests
                                from PIL import Image, ImageOps
                                from io import BytesIO
                                
                                response = requests.get(cover_url, timeout=10)
                                if response.status_code == 200:
                                    album_cover = Image.open(BytesIO(response.content)).convert("RGBA")
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    # Upgrade de qualidade: se a capa for pequena, substituir por YouTube
                                    try:
                                        if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                            yt_url_up = self._get_youtube_cover(title, artist)
                                            if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                                yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                            yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                            if yt_cached:
                                                if isinstance(yt_cached, bytes):
                                                    album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                                else:
                                                    album_cover = yt_cached
                                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    except Exception as _e:
                                        log(f"[Nowfy] CustomFM: Upgrade YouTube falhou: {_e}")
                                    log(f"[Nowfy] CustomFM: SoundCloud cover downloaded and processed successfully")
                                else:
                                    log(f"[Nowfy] CustomFM: Failed to download SoundCloud cover, status: {response.status_code}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                            except Exception as e:
                                log(f"[Nowfy] CustomFM: Error downloading SoundCloud cover directly: {e}")
                                
                                # Fallback para o sistema de cache
                                try:
                                    cached_image = self._get_cached_image_enhanced(
                                        cover_url, 
                                        cache_key=cover_cache_key,
                                        force_size=(mini_cover_size, mini_cover_size)
                                    )
                                    if cached_image:
                                        if isinstance(cached_image, bytes):
                                            try:
                                                album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                                album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                                # Upgrade de qualidade: se a capa for pequena, substituir por YouTube
                                                try:
                                                    if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                                        yt_url_up = self._get_youtube_cover(title, artist)
                                                        if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                                            yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                                        yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                                        if yt_cached:
                                                            if isinstance(yt_cached, bytes):
                                                                album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                                            else:
                                                                album_cover = yt_cached
                                                            album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                                except Exception as _e:
                                                    log(f"[Nowfy] CustomFM: Upgrade YouTube falhou: {_e}")
                                                log(f"[Nowfy] CustomFM: SoundCloud cover processed from cache")
                                            except Exception as cache_e:
                                                log(f"[Nowfy] Error processing cached SoundCloud cover: {cache_e}")
                                                album_cover = self._get_icondefault_cached(mini_cover_size)
                                        else:
                                            # Garantir corte consistente também quando vier como Image
                                            try:
                                                album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                            except Exception:
                                                album_cover = cached_image
                                    else:
                                        log(f"[Nowfy] CustomFM: No cached image returned for SoundCloud")
                                        album_cover = self._get_icondefault_cached(mini_cover_size)
                                except Exception as cache_error:
                                    log(f"[Nowfy] CustomFM: Cache system error for SoundCloud: {cache_error}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                        else:
                            log(f"[Nowfy] CustomFM: No cover URL found for SoundCloud")
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] CustomFM: Error loading SoundCloud cover: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                elif player_name == "FM":
                    # FM deve se comportar como YouTube Music: priorizar thumbnail do YouTube e aplicar crop
                    try:
                        from PIL import ImageOps, Image
                        cover_url = self._get_youtube_cover(title, artist)
                        cached_image = self._get_cached_image_enhanced(
                            cover_url,
                            cache_key=cover_cache_key,
                            force_size=(mini_cover_size, mini_cover_size)
                        )
                        if cached_image:
                            if isinstance(cached_image, bytes):
                                try:
                                    album_cover = Image.open(BytesIO(cached_image)).convert("RGBA")
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                    album_cover = album_cover.convert("RGBA")
                                except Exception as e:
                                    log(f"[Nowfy] FM: Error converting cached bytes to PIL Image: {e}")
                                    album_cover = self._get_icondefault_cached(mini_cover_size)
                            else:
                                # Aplicar ImageOps.fit também quando já for Image
                                try:
                                    album_cover = ImageOps.fit(cached_image, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                                except Exception:
                                    album_cover = cached_image
                        else:
                            # Fallback para ícone padrão se a capa do YouTube não estiver disponível
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] FM: Error loading YouTube cover: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
                else:
                    # Para Spotify e outros players, usar sistema otimizado de artwork
                    try:
                        from PIL import Image, ImageOps
                        album_cover = self._search_music_artwork(artist, title)
                        if album_cover:
                            # Aplicar crop consistente mantendo proporção, igual ao YouTube
                            album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                            log(f"[Nowfy] CustomFM: Using artwork from priority system")
                        else:
                            album_cover = self._get_icondefault_cached(mini_cover_size)
                    except Exception as e:
                        log(f"[Nowfy] CustomFM: Error using priority artwork system: {e}")
                        album_cover = self._get_icondefault_cached(mini_cover_size)
            except Exception as e:
                log(f"[Nowfy] CustomFM: Error loading cover: {e}")
                album_cover = self._get_icondefault_cached(mini_cover_size)
            
            # Fallback: tentar image_url do Last.fm se ainda não temos capa
            if not album_cover and image_url:
                try:
                    resp = requests.get(image_url, timeout=10)
                    if resp.status_code == 200:
                        album_cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                        # Upgrade de qualidade: se a imagem do Last.fm for pequena, substituir por YouTube
                        try:
                            if album_cover.width < mini_cover_size or album_cover.height < mini_cover_size:
                                yt_url_up = self._get_youtube_cover(title, artist)
                                if yt_url_up == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                                    yt_url_up = self._get_youtube_thumbnail_forced(title, artist)
                                yt_cached = self._get_cached_image_enhanced(yt_url_up, cache_key=cover_cache_key, force_size=(mini_cover_size, mini_cover_size))
                                if yt_cached:
                                    if isinstance(yt_cached, bytes):
                                        album_cover = Image.open(BytesIO(yt_cached)).convert("RGBA")
                                    else:
                                        album_cover = yt_cached
                                    album_cover = ImageOps.fit(album_cover, (mini_cover_size, mini_cover_size), method=Image.LANCZOS, centering=(0.5, 0.5))
                        except Exception as _e:
                            log(f"[Nowfy] CustomFM: YouTube upgrade on Last.fm fallback failed: {_e}")
                except Exception as e:
                    log(f"[Nowfy] CustomFM: Last.fm image_url fallback failed: {e}")
            
            # Garantir que sempre temos uma capa
            if not album_cover:
                album_cover = self._get_icondefault_cached(mini_cover_size)
                log(f"[Nowfy] CustomFM: Using default icon as final fallback")
            # --- BLUR DE FUNDO (OTIMIZADO) ---
            if use_bg:
                from PIL import Image
                bg_cover = album_cover.copy()
                # Aumentar ligeiramente o fator de escala para evitar tarjas pretas
                bg_ratio = max(card_width / bg_cover.width, card_height / bg_cover.height) * 1.05
                new_size = (int(bg_cover.width * bg_ratio), int(bg_cover.height * bg_ratio))
                bg_cover = bg_cover.resize(new_size, Image.LANCZOS)              
                # Verificar se o blur está ativado
                use_blur = self.get_setting("lastfm_customfm_blur", True)
                if use_blur:
                    # Otimizar blur para alta resolução - usar blur menor em imagem menor e depois redimensionar
                    if use_high_res:
                        temp_bg = bg_cover.resize((new_size[0]//2, new_size[1]//2), Image.LANCZOS)
                        blur_bg = temp_bg.filter(ImageFilter.GaussianBlur(15))
                        blur_bg = blur_bg.resize(new_size, Image.LANCZOS)
                    else:
                        blur_bg = bg_cover.filter(ImageFilter.GaussianBlur(30))
                else:
                    blur_bg = bg_cover
                    
                from PIL import Image
                background = Image.new("RGBA", (card_width, card_height))
                # Centralizar melhor a imagem de fundo
                x_offset = -(new_size[0] - card_width) // 2
                y_offset = -(new_size[1] - card_height) // 2
                background.paste(blur_bg, (x_offset, y_offset))
                
                # Verificar se o escurecimento está ativado
                use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                if use_darken:
                    from PIL import Image
                    overlay = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 150))
                    background = Image.alpha_composite(background.convert("RGBA"), overlay)
                
                # --- GRADIENTES DINÂMICOS (Visual Avançado) ---
                gradient_bg = self._generate_gradient_background(card_width, card_height, album_cover)
                if gradient_bg:
                    from PIL import Image
                    background = Image.alpha_composite(background.convert("RGBA"), gradient_bg)
                    log(f"[NowFy] Gradiente dinâmico aplicado ao background com capa")
                
                # --- DYNAMIC SKINS ---
                dynamic_skin_selection = self.get_setting("dynamic_skins_selector", 0)
                dynamic_skin_url = None
                
                if dynamic_skin_selection == 1:  # Aleatório
                    import random
                    random_choice = random.choice([2, 3, 4, 5, 6, 7, 8, 9, 10])  # Sortear entre todos os skins disponíveis
                    dynamic_skin_selection = random_choice
                
                if dynamic_skin_selection == 2:  # Midnight Pulse
                    dynamic_skin_url = "https://i.postimg.cc/8CX52pBX/customov.png"
                elif dynamic_skin_selection == 3:  # Sunset Rhythm
                    dynamic_skin_url = "https://i.postimg.cc/W41zYFrJ/customov2.png"
                elif dynamic_skin_selection == 4:  # Spcy
                    dynamic_skin_url = "https://i.postimg.cc/MK6DDtH6/Spcy.png"
                elif dynamic_skin_selection == 5:  # Purpl
                    dynamic_skin_url = "https://i.postimg.cc/ZYFHpXTs/Purpl.png"
                elif dynamic_skin_selection == 6:  # Ardente
                    dynamic_skin_url = "https://i.postimg.cc/zf5tjsR7/Ardente.png"
                elif dynamic_skin_selection == 7:  # Manifest
                    dynamic_skin_url = "https://i.postimg.cc/FKZPnTy4/Manifest.png"
                elif dynamic_skin_selection == 8:  # Moment
                    dynamic_skin_url = "https://i.postimg.cc/65k172WD/Moment.png"
                elif dynamic_skin_selection == 9:  # Moment Redd
                    dynamic_skin_url = "https://i.postimg.cc/Sxc1cSjj/Redd.png"
                elif dynamic_skin_selection == 10:  # Moment Variant
                    dynamic_skin_url = "https://i.postimg.cc/k4gjrWst/Variant.png"
                
                # Aplicar Dynamic Skin se selecionado
                if dynamic_skin_url:
                    try:
                        # Usar sistema de cache avançado
                        cache_key = f"dynamic_skin_{dynamic_skin_selection}"
                        cached_image_data = self._get_cached_image_enhanced(dynamic_skin_url, cache_key)
                        
                        if cached_image_data:
                            from PIL import Image
                            dynamic_skin_image = Image.open(BytesIO(cached_image_data)).convert("RGBA")
                            dynamic_skin_image = dynamic_skin_image.resize((card_width, card_height), Image.LANCZOS)
                            log(f"[NowFy] Dynamic Skin carregado do cache: {cache_key}")
                        else:
                            dynamic_skin_image = None
                            log(f"[NowFy] Erro ao carregar Dynamic Skin: {cache_key}")
                        
                        # Aplicar efeitos apenas se a imagem foi carregada com sucesso
                        if dynamic_skin_image:
                            # Aplicar blur no Dynamic Skin se ativado
                            if use_blur:
                                dynamic_skin_image = dynamic_skin_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no Dynamic Skin se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                dynamic_skin_image = Image.alpha_composite(dynamic_skin_image, overlay_dark)
                            
                            from PIL import Image
                            background = Image.alpha_composite(background.convert("RGBA"), dynamic_skin_image)
                    except Exception as e:
                        log(f"Erro ao carregar Dynamic Skin: {e}")
                
                # --- CUSTOM OVERLAY COMO BACKGROUND (fallback se Dynamic Skin não estiver ativo) ---
                if not dynamic_skin_url:
                    use_custom_overlay = self.get_setting("lastfm_customfm_use_overlay", False)
                    custom_overlay_url = self.get_setting("lastfm_customfm_overlay_url", "")
                    statsfm_username = self.get_setting("statsfm_username", "")
                    # Aplicar overlay apenas quando a origem for Last.fm (evitar StatsFM)
                    apply_overlay = use_custom_overlay and custom_overlay_url and (player_name == "FM") and not statsfm_username
                    if apply_overlay:
                        try:
                            overlay_resp = requests.get(custom_overlay_url, stream=True, timeout=10)
                            overlay_resp.raise_for_status()
                            from PIL import Image
                            custom_overlay_image = Image.open(BytesIO(overlay_resp.content)).convert("RGBA")
                            custom_overlay_image = custom_overlay_image.resize((card_width, card_height), Image.LANCZOS)
                            
                            # Aplicar blur no overlay se ativado
                            if use_blur:
                                custom_overlay_image = custom_overlay_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no overlay se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                custom_overlay_image = Image.alpha_composite(custom_overlay_image, overlay_dark)
                            
                            from PIL import Image
                            background = Image.alpha_composite(background.convert("RGBA"), custom_overlay_image)
                        except Exception as e:
                            log(f"Erro ao carregar overlay personalizado: {e}")
                
                # --- CAPA NÍTIDA COM MÁSCARA (apenas se use_bg estiver ativado) ---
                # Obter configuração de radius
                radius_setting = self.get_setting("lastfm_customfm_radius", 0)
                radius_values = [23, 10, 35, 50, 150]  # Standard, Small, Medium, Large, Circle
                radius = radius_values[radius_setting] if radius_setting < len(radius_values) else 23
                
                from PIL import Image, ImageDraw
                mask = Image.new("L", (mini_cover_size, mini_cover_size), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, mini_cover_size, mini_cover_size), radius, fill=255)
                album_cover.putalpha(mask)
                background.paste(album_cover, (padding_left, padding_top), album_cover)
            else:
                # Usar apenas cores quando Cover BG estiver desativado
                from PIL import Image
                background = Image.new("RGBA", (card_width, card_height), bg_color)
                
                # --- GRADIENTES DINÂMICOS (Visual Avançado) ---
                gradient_bg = self._generate_gradient_background(card_width, card_height, album_cover)
                if gradient_bg:
                    from PIL import Image
                    background = Image.alpha_composite(background.convert("RGBA"), gradient_bg)
                    log(f"[NowFy] Gradiente dinâmico aplicado ao background sem capa")
                
                # --- DYNAMIC SKINS (sem blur de fundo) ---
                dynamic_skin_selection = self.get_setting("dynamic_skins_selector", 0)
                dynamic_skin_url = None
                
                if dynamic_skin_selection == 1:  # Aleatório
                    import random
                    random_choice = random.choice([2, 3, 4, 5, 6, 7, 8, 9, 10])  # Sortear entre todos os skins disponíveis
                    dynamic_skin_selection = random_choice
                
                if dynamic_skin_selection == 2:  # Midnight Pulse
                    dynamic_skin_url = "https://i.postimg.cc/GtRhnHVR/customov.png"
                elif dynamic_skin_selection == 3:  # Sunset Rhythm
                    dynamic_skin_url = "https://i.postimg.cc/3NZr83Qv/customov2.png"
                elif dynamic_skin_selection == 4:  # Spcy
                    dynamic_skin_url = "https://i.postimg.cc/MK6DDtH6/Spcy.png"
                elif dynamic_skin_selection == 5:  # Purpl
                    dynamic_skin_url = "https://i.postimg.cc/ZYFHpXTs/Purpl.png"
                elif dynamic_skin_selection == 6:  # Ardente
                    dynamic_skin_url = "https://i.postimg.cc/zf5tjsR7/Ardente.png"
                elif dynamic_skin_selection == 7:  # Manifest
                    dynamic_skin_url = "https://i.postimg.cc/FKZPnTy4/Manifest.png"
                elif dynamic_skin_selection == 8:  # Moment
                    dynamic_skin_url = "https://i.postimg.cc/65k172WD/Moment.png"
                elif dynamic_skin_selection == 9:  # Moment Redd
                    dynamic_skin_url = "https://i.postimg.cc/Sxc1cSjj/Redd.png"
                elif dynamic_skin_selection == 10:  # Moment Variant
                    dynamic_skin_url = "https://i.postimg.cc/k4gjrWst/Variant.png"
                
                # Aplicar Dynamic Skin se selecionado
                if dynamic_skin_url:
                    try:
                        # Verificar cache primeiro
                        cache_key = f"dynamic_skin_{dynamic_skin_selection}"
                        cached_image_data = self._get_cached_image_enhanced(dynamic_skin_url, cache_key)
                        
                        if cached_image_data:
                            from PIL import Image
                            dynamic_skin_image = Image.open(BytesIO(cached_image_data)).convert("RGBA")
                            dynamic_skin_image = dynamic_skin_image.resize((card_width, card_height), Image.LANCZOS)
                            log(f"[NowFy] Dynamic Skin carregado do cache: {cache_key}")
                        else:
                            dynamic_skin_image = None
                            log(f"[NowFy] Erro ao carregar Dynamic Skin: {cache_key}")
                        
                        # Aplicar efeitos apenas se a imagem foi carregada com sucesso
                        if dynamic_skin_image:
                            # Verificar configurações de blur e escurecimento
                            use_blur = self.get_setting("lastfm_customfm_blur", True)
                            use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                            
                            # Aplicar blur no Dynamic Skin se ativado
                            if use_blur:
                                dynamic_skin_image = dynamic_skin_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no Dynamic Skin se ativado
                            if use_darken:
                                from PIL import Image
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                dynamic_skin_image = Image.alpha_composite(dynamic_skin_image, overlay_dark)
                            
                            background = Image.alpha_composite(background.convert("RGBA"), dynamic_skin_image)
                    except Exception as e:
                        log(f"Erro ao carregar Dynamic Skin: {e}")
                
                # --- CUSTOM OVERLAY COMO BACKGROUND (fallback se Dynamic Skin não estiver ativo) ---
                if not dynamic_skin_url:
                    use_custom_overlay = self.get_setting("lastfm_customfm_use_overlay", False)
                    custom_overlay_url = self.get_setting("lastfm_customfm_overlay_url", "")
                    statsfm_username = self.get_setting("statsfm_username", "")
                    # Aplicar overlay apenas quando a origem for Last.fm (evitar StatsFM)
                    apply_overlay = use_custom_overlay and custom_overlay_url and (player_name == "FM") and not statsfm_username
                    if apply_overlay:
                        try:
                            overlay_resp = requests.get(custom_overlay_url, stream=True, timeout=10)
                            overlay_resp.raise_for_status()
                            custom_overlay_image = Image.open(BytesIO(overlay_resp.content)).convert("RGBA")
                            custom_overlay_image = custom_overlay_image.resize((card_width, card_height), Image.LANCZOS)
                            
                            # Verificar configurações de blur e escurecimento
                            use_blur = self.get_setting("lastfm_customfm_blur", True)
                            use_darken = self.get_setting("lastfm_customfm_darken_background", False)
                            
                            # Aplicar blur no overlay se ativado
                            if use_blur:
                                custom_overlay_image = custom_overlay_image.filter(ImageFilter.GaussianBlur(15))
                            
                            # Aplicar escurecimento no overlay se ativado
                            if use_darken:
                                overlay_dark = Image.new("RGBA", (card_width, card_height), (0, 0, 0, 100))
                                custom_overlay_image = Image.alpha_composite(custom_overlay_image, overlay_dark)
                            
                            background = Image.alpha_composite(background.convert("RGBA"), custom_overlay_image)
                        except Exception as e:
                            log(f"Erro ao carregar overlay personalizado: {e}")
                
                # --- CAPA NÍTIDA COM MÁSCARA (apenas se use_bg estiver ativado) ---
                # Obter configuração de radius
                radius_setting = self.get_setting("lastfm_customfm_radius", 0)
                radius_values = [23, 10, 35, 50, 150]  # Standard, Small, Medium, Large, Circle
                radius = radius_values[radius_setting] if radius_setting < len(radius_values) else 23
                
                mask = Image.new("L", (mini_cover_size, mini_cover_size), 0)
                ImageDraw.Draw(mask).rounded_rectangle((0, 0, mini_cover_size, mini_cover_size), radius, fill=255)
                album_cover.putalpha(mask)
                background.paste(album_cover, (padding_left, padding_top), album_cover)

            # --- FONTES E TEXTO ---
            # Usa fontes customizadas da classe, ajustando tamanho para alta resolução
            font_selector = self.get_setting("font_selector", 0)
            title_size = 53 if use_high_res else 28
            artist_size = 42 if use_high_res else 22
            regular_size = 38 if use_high_res else 20
            
            font_title = self._get_font_for_title(title, font_selector, max_size=title_size, min_size=title_size, base_size=title_size)
            font_artist = self._get_font_for_artist(artist, font_selector, size=artist_size)
            font_regular = self._get_default_font(size=regular_size)
            
            # Verificar se o texto deve ser em negrito
            use_bold_text = self.get_setting("lastfm_customfm_bold_text", False)
            if use_bold_text:
                # Usar fontes em negrito para título e artista
                font_title = self._get_font_for_title(title, font_selector, max_size=title_size, min_size=title_size, base_size=title_size, force_bold=True)
                font_artist = self._get_font_for_artist(artist, font_selector, size=artist_size, force_bold=True)

            draw = ImageDraw.Draw(background)
            text_x = text_start_x  # Usar a posição calculada com base na posição da capa
            text_y_offset = 57 if use_high_res else 30
            text_y = padding_top + text_y_offset
            max_text_width = 1140 if use_high_res else 600
            # 'Listening to' (regular)
            text_y = self.draw_multiline_text(draw, "Listening to", (text_x, text_y), font_regular, text_color, max_text_width)
            text_y += 15 if use_high_res else 8
            # Título (negrito ou regular, dependendo da configuração)
            text_y = self.draw_multiline_text(draw, title, (text_x, text_y), font_title, text_color, max_text_width)
            text_y += 11 if use_high_res else 6
            # Desenhar nome do artista (negrito ou regular, dependendo da configuração)
            text_y = self.draw_multiline_text(draw, artist, (text_x, text_y), font_artist, text_color, max_text_width)
            text_y += 38 if use_high_res else 20

            # --- ICON DO PLAYER ---
            icon_size = 85 if use_high_res else 45
            icon_x = text_x
            icon_y = text_y
            icon_url = self._get_service_icon(player_name, use_custom_color=True)
            if icon_url:
                try:
                    response = requests.get(icon_url, stream=True)
                    if response.status_code == 200:
                        icon_image = Image.open(BytesIO(response.content)).convert('RGBA')
                        icon_image = icon_image.resize((icon_size, icon_size), Image.LANCZOS)
                        background.paste(icon_image, (icon_x, icon_y), icon_image)
                except Exception:
                    pass

            # --- MASK FINAL ---
            corner_radius = 95 if use_high_res else 50
            rounded_mask = Image.new("L", (card_width, card_height), 0)
            draw_round = ImageDraw.Draw(rounded_mask)
            draw_round.rounded_rectangle((0, 0, card_width, card_height), corner_radius, fill=255)
            background.putalpha(rounded_mask)

            if progress_dialog:
                run_on_ui_thread(lambda: progress_dialog.set_progress(90))
            # Salvar como PNG (lossless) mantendo RGBA; compress_level baseado em performance_mode
            performance_mode = self.get_setting("performance_mode", 1)
            compress_level = 1 if performance_mode == 0 else (4 if performance_mode == 1 else 6)
            background.save(temp_path, format='PNG', optimize=True, compress_level=compress_level)
            
            # Definir track_data com base nos parâmetros do método
            track_data = {
                "name": title or "Unknown Track",
                "artist": artist or "Unknown Artist", 
                "album": album or "Unknown Album"
            }
            
            # Caption personalizada baseada no player
            footer = self.get_setting("custom_footer_text", "")
            custom_caption = self.get_setting("custom_footer_text", "")
            caption_parts = []
            # Verificar se deve mostrar a legenda
            show_caption = self.get_setting("show_caption", True)
            if show_caption:
                # Obter o estilo de caption selecionado
                caption_style_index = self.get_setting("caption_style", 0)
                caption_style_items = ["Custom", "Apple Based", "Pepe", "Minim", "Spoty"]
                caption_style = caption_style_items[caption_style_index] if caption_style_index < len(caption_style_items) else "Custom"
                
                if caption_style == "Custom":
                    # Usar caption personalizado (comportamento original)
                    footer = self.get_setting("custom_footer_text", "")
                    if footer:
                        # Processar variáveis {track}, {artist} e {album} no custom caption
                        processed_footer = footer.strip()
                        if "{track}" in processed_footer or "{artist}" in processed_footer or "{album}" in processed_footer:
                            album_name = track_data.get("album", "Unknown Album") if track_data else "Unknown Album"
                            processed_footer = processed_footer.replace("{track}", title or "Unknown Track")
                            processed_footer = processed_footer.replace("{artist}", artist or "Unknown Artist")
                            processed_footer = processed_footer.replace("{album}", album_name)
                        caption_parts.append(processed_footer)
                else:
                    # Usar template predefinido
                    track_info = {
                        "name": title or "Unknown Track",
                        "artist": artist or "Unknown Artist",
                        "album": track_data.get("album", "Unknown Album") if track_data else "Unknown Album"
                    }
                    
                    template_caption = self._get_caption_template(caption_style, track_info)
                    if template_caption:
                        caption_parts.append(template_caption)
            # Verificar configurações de Link Options
            show_track_link = self.get_setting("show_track_link", True)
            platform_links = self.get_setting("platform_links", 0)  # 0=Spotify, 1=Universal, 2=Both
            
            if show_caption == "ON" and show_track_link:
                # Lógica de Link Options baseada nas configurações
                if show_track_link and player_name == "Spotify":
                    # Lógica baseada no novo Platform Links selector
                    if platform_links == 0:  # Spotify only
                        if youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            if spotify_url:
                                caption_parts.append(f"[Spotify]({spotify_url})")
                    elif platform_links == 1:  # Universal only
                        if youtube_url and "open.spotify.com" in youtube_url:
                            song_link_url = self._get_song_link(youtube_url)
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            song_link_url = self._get_song_link(spotify_url) if spotify_url else None
                        
                        if song_link_url:
                            caption_parts.append(f"[song.link]({song_link_url})")
                        elif youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                        elif spotify_url:
                            caption_parts.append(f"[Spotify]({spotify_url})")
                    elif platform_links == 2:  # Both
                        # Adicionar ambos os links
                        if youtube_url and "open.spotify.com" in youtube_url:
                            caption_parts.append(f"[Spotify]({youtube_url})")
                            song_link_url = self._get_song_link(youtube_url)
                            if song_link_url:
                                caption_parts.append(f"[song.link]({song_link_url})")
                        else:
                            spotify_url = self._search_spotify_url(title, artist)
                            if spotify_url:
                                caption_parts.append(f"[Spotify]({spotify_url})")
                                song_link_url = self._get_song_link(spotify_url)
                                if song_link_url:
                                    caption_parts.append(f"[song.link]({song_link_url})")
                elif player_name == "YouTube" or player_name == "YouTube Music":
                    search_query = f"{title} {artist}"
                    youtube_search_url = f"https://www.youtube.com/results?search_query={quote(search_query)}"
                    service_name = "YouTube Music" if player_name == "YouTube Music" else "YouTube"
                    caption_parts.append(f"[{service_name}]({youtube_search_url})")
                elif player_name == "SoundCloud":
                    # Adicionar link para SoundCloud
                    search_query = f"{title} {artist}"
                    soundcloud_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    caption_parts.append(f"[SoundCloud]({soundcloud_url})")
                elif player_name == "Apple Music":
                    # Adicionar link para Apple Music
                    search_query = f"{title} {artist}"
                    apple_music_url = f"https://music.apple.com/search?term={quote(search_query)}"
                    caption_parts.append(f"[Apple Music]({apple_music_url})")
                elif player_name in ["exteraGram", "AyuGram"]:
                    display_name = "AyuGram" if player_name == "AyuGram" else "exteraGram"
                    username = self.get_setting("exteragram_username", "").strip()
                    if username.startswith("@"):
                        username = username[1:]
                    if not username:
                        link = "https://t.me/exteraGram" if player_name == "exteraGram" else "https://t.me/ayugram"
                    else:
                        link = f"https://t.me/{username}"
                    caption_parts.append(f"[{display_name}]({link})")
                elif player_name == "FM":
                    # Para FM, verificar se há Custom Link configurado
                    custom_link_url = self.get_setting("fm_custom_link_url", "").strip()
                    if custom_link_url:
                        # Usar nome personalizado do player se configurado
                        custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                        caption_parts.append(f"[{custom_player_name}]({custom_link_url})")
                    else:
                        # Para FM, usar Last.fm se disponível
                        lastfm_username = self.get_setting("lastfm_user", "")
                        if lastfm_username:
                            lastfm_profile_url = f"https://www.last.fm/user/{lastfm_username}"
                            caption_parts.append(f"[Last.FM]({lastfm_profile_url})")
                        else:
                            # Usar nome personalizado do player se configurado
                            custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                            caption_parts.append(f"{custom_player_name}")

            # Verificar se deve mostrar o link FM baseado na seleção do usuário
            fm_link_option = self.get_setting("fm_link_option", 0)
            if fm_link_option == 1:  # LastFM
                lastfm_username = self.get_setting("lastfm_user", "")
                if lastfm_username:
                    lastfm_profile_url = f"https://www.last.fm/user/{lastfm_username}"
                    caption_parts.append(f"[Last.FM]({lastfm_profile_url})")
            elif fm_link_option == 2:  # StatsFM
                statsfm_username = self.get_setting("statsfm_username", "")
                if statsfm_username:
                    statsfm_profile_url = f"https://stats.fm/{statsfm_username}"
                    caption_parts.append(f"[Stats.FM]({statsfm_profile_url})")
            elif fm_link_option == 3:  # Custom Link
                custom_url = self.get_setting("fm_custom_link_url", "")
                custom_name = self.get_setting("fm_custom_player_name", "Custom Player")
                if custom_url:
                    caption_parts.append(f"[{custom_name}]({custom_url})")
            elif fm_link_option == 3:  # Custom Link
                custom_link_url = self.get_setting("fm_custom_link_url", "").strip()
                if custom_link_url:
                    custom_player_name = self.get_setting("fm_custom_player_name", "Custom Player")
                    caption_parts.append(f"[{custom_player_name}]({custom_link_url})")

            caption = " • ".join(caption_parts) if caption_parts else ""
            
            # Verificar se está no modo NowCast
            if getattr(self, '_nowcast_mode', False):
                # No modo NowCast, usar bot_caption se disponível
                bot_caption = self.get_setting("bot_caption_text", "")
                if bot_caption:
                    # Processar variáveis {track}, {artist} e {album} no bot caption
                    processed_bot_caption = bot_caption.strip()
                    if "{track}" in processed_bot_caption or "{artist}" in processed_bot_caption or "{album}" in processed_bot_caption:
                        album_name = album or "Unknown Album"  # Usar parâmetro album diretamente
                        processed_bot_caption = processed_bot_caption.replace("{track}", title)
                        processed_bot_caption = processed_bot_caption.replace("{artist}", artist)
                        processed_bot_caption = processed_bot_caption.replace("{album}", album_name)
                    
                    # Combinar caption original com bot_caption
                    if caption:
                        final_caption = f"{caption} • {processed_bot_caption}"
                    else:
                        final_caption = processed_bot_caption
                    self._nowcast_caption = final_caption
                else:
                    # Usar caption original se não houver bot_caption
                    self._nowcast_caption = caption
                return temp_path
            
            if params:
                # Verificar se params é um objeto com atributo caption ou um dict
                if hasattr(params, 'caption'):
                    # Processar emojis premium (sempre habilitado)
                    if caption:
                        caption = self._process_premium_emojis(caption)
                    
                    caption_md = parse_markdown(caption)
                    params.caption = caption_md.text
                    params.entities = ArrayList()
                    for entity in caption_md.entities:
                        params.entities.add(entity.to_tlrpc_object())
                    photo = send_helper.generatePhotoSizes(temp_path, None)
                    params.photo = photo
                    params.path = temp_path
                    params.message = None
                    run_on_ui_thread(lambda: send_helper.sendMessage(params))
                else:
                    # Se params é um dict ou não tem atributo caption, apenas retornar o caminho da imagem
                    log(f"[Nowfy] CustomFM - params is dict or missing caption attribute, returning image path: {temp_path}")
                    return temp_path
                # Atualizar bio após o envio do card
                if self.get_setting("enable_autobio", False):
                    autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                    bio = autobio_text.format(track=title, artist=artist)
                    run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                run_on_ui_thread(self._dismiss_loading_dialog)

        except Exception as e:
            if progress_dialog:
                try: progress_dialog.dismiss()
                except Exception: pass
            BulletinHelper.show_info(tr("error_lastfm").format(error=str(e)) if "error_lastfm" in TRANSLATIONS else f"LastFM error: {str(e)}")
            # Fechar o dialog de loading mesmo em caso de erro
            run_on_ui_thread(self._dismiss_loading_dialog)

    def _detect_current_player(self):
        try:
            # Verificar se há um player forçado (para comandos .etg e .ayu)
            if hasattr(self, '_forced_player'):
                forced_player = self._forced_player
                log(f"[Nowfy] Using forced player: {forced_player}")
                return forced_player
                
            player_index = self.get_setting("current_player", 0)
            players = ["Spotify", "YouTube", "YouTube Music", "AyuGram", "exteraGram", "SoundCloud", "Apple Music", "Yandex Music", "FM"]
            # Se vier como string numérica, converte para int
            if isinstance(player_index, str) and player_index.isdigit():
                player_index = int(player_index)
            # Se vier como índice, retorna o player correspondente
            if isinstance(player_index, int):
                if player_index >= len(players):
                    detected_player = "Spotify"
                else:
                    detected_player = players[player_index]
            # Se vier como string com nome do player, retorna direto
            elif isinstance(player_index, str) and player_index in players:
                detected_player = player_index
            else:
                detected_player = "Spotify"
            log(f"[Nowfy] Detected player: {detected_player} (index: {player_index})")
            return detected_player
        except Exception as e:
            log(f"[Nowfy] Error detecting player: {e}")
            return "Spotify"
    
    def _get_apple_skin_selector(self):
        """Retorna o seletor Apple Skin com lógica para ocultar 'Light' quando SoundCloud estiver ativo e 'Red' removido por problemas de compatibilidade"""
        current_player = self._detect_current_player()
        
        # Se SoundCloud estiver ativo, usar apenas Dark (Red removido por problemas)
        if current_player == "SoundCloud":
            items = ["Dark"]
            default = 0  # Dark será o único índice disponível
        else:
            items = ["Light", "Dark"]  # Red removido por problemas de compatibilidade
            default = 0  # Light como padrão
        
        return Selector(
             key="apple_skin",
             text=tr("apple_skin"),
             default=default,
             items=items,
             icon="msg_palette",
             on_change=lambda v: self.reload_settings()
         )
    
    def _get_platform_logo_selector(self):
        """Retorna o seletor Platform Logo com opções baseadas no player atual"""
        current_player = self._detect_current_player()
        
        # Opção "None" sempre disponível como primeira opção
        items = [tr("platform_logo_none")]
        
        if current_player == "Apple Music":
            items.extend([
                tr("platform_logo_apple_red_white"),
                tr("platform_logo_apple_white_red"),
                tr("platform_logo_apple_black_white"),
                tr("platform_logo_apple_white_black")
            ])
        else:  # Spotify ou outros (usar opções do Spotify como padrão)
            items.extend([
                tr("platform_logo_spotify_green_white"),
                tr("platform_logo_spotify_white_green"),
                tr("platform_logo_spotify_black_white"),
                tr("platform_logo_spotify_white_black")
            ])
        
        return Selector(
            key="vinify_platform_logo",
            text=tr("vinify_platform_logo"),
            default=0,  # "None" como padrão
            items=items,
            icon="menu_feature_custombg"
        )
    
    def _get_spotlight_skin_selector(self):
        """Retorna o seletor Spotlight Skin com as opções Light, Dark e Blur"""
        items = ["Light", "Dark", "Blur"]
        default = 0  # Light como padrão
        
        return Selector(
             key="spotlight_skin",
             text="Spotlight Skin",
             default=default,
             items=items,
             icon="msg_palette",
             on_change=lambda v: self.reload_settings()
         )
    
    def _get_apple_skin_index_mapped(self):
        """Mapeia o índice do apple_skin considerando se SoundCloud está ativo"""
        current_player = self._detect_current_player()
        apple_skin_setting = self.get_setting("apple_skin", 0)  # Padrão Light (0)
        
        if current_player == "SoundCloud":
            # Para SoundCloud: apenas Dark e Red são suportados
            # O seletor mostra ["Dark", "Red"] com índices 0 e 1
            # Precisamos mapear para o sistema original: Dark=1, Red=2
            if apple_skin_setting == 0:  # Dark (primeiro item no seletor SoundCloud)
                return 1  # Mapear para Dark no sistema original
            elif apple_skin_setting == 1:  # Red (segundo item no seletor SoundCloud)
                return 2  # Mapear para Red no sistema original
            else:
                return 1  # Default para Dark
        else:
            # Para outros players: Light=0, Dark=1, Red=2 (sistema original)
            # Garantir que o valor está dentro dos limites válidos
            if apple_skin_setting < 0 or apple_skin_setting > 2:
                return 0  # Default para Light se valor inválido
            return apple_skin_setting

    def create_lastfm_customfm_options(self):
        # Opções fixas de Icon Colors
        icon_color_items = [
            "Normal",
            "Black", 
            "White"
        ]     
        # Opções para posição da mini capa
        cover_position_items = [
            tr("customfm_position_left"),   # Posição padrão
            tr("customfm_position_right")   # Nova posição
        ]
        
        # Verificar qual player está selecionado
        current_player_setting = self.get_setting("current_player", 0)
        is_fm_player = current_player_setting == 7  # FM
        
        options = [
            Divider(text=tr("customfm_background_section")),
            Switch(
                key="lastfm_customfm_use_background",
                text=tr("customfm_use_background"),
                default=True,
                icon="msg_copy_photo",
                subtext=tr("customfm_use_background_sub")
            ),
            Input(
                key="lastfm_customfm_background_color",
                text=tr("customfm_background_color"),
                default="#d2d2d2",
                icon="ic_colorpicker_solar",
                subtext=tr("customfm_background_color_sub")
            ),
            # Opção para ativar/desativar blur de fundo
            Switch(
                key="lastfm_customfm_blur",
                text=tr("customfm_blur"),
                default=True,
                icon="msg_copy_photo",
                subtext=tr("customfm_blur_sub")
            ),
            # Opção para ativar/desativar escurecimento de fundo
            Switch(
                key="lastfm_customfm_darken_background",
                text=tr("customfm_darken_background"),
                default=False,
                icon="msg_copy_photo",
                subtext=tr("customfm_darken_background_sub")
            ),

            Divider(text=tr("customfm_text_section")),
            Input(
                key="lastfm_customfm_text_color",
                text=tr("customfm_text_color"),
                default="#000000",
                icon="menu_feature_color_name",
                subtext=tr("customfm_text_color_sub")
            ),
            # Opção para ativar/desativar negrito no título e artista
            Switch(
                key="lastfm_customfm_bold_text",
                text=tr("customfm_bold_text"),
                default=False,
                icon="msg_photo_text_framed2",
                subtext=tr("customfm_bold_text_sub")
            ),

            Divider(text=tr("customfm_style_section")),
            # Opção para escolher a posição da mini capa
            Selector(
                key="lastfm_customfm_cover_position",
                text=tr("customfm_cover_position"),
                default=0,  # Esquerda como padrão
                items=cover_position_items,
                icon="menu_feature_cover"
            ),
            Selector(
                key="lastfm_customfm_radius",
                text=tr("customfm_radius"),
                default=0,
                items=[tr("customfm_radius_standard"), tr("customfm_radius_small"), tr("customfm_radius_medium"), tr("customfm_radius_large"), tr("customfm_radius_circle")],
                icon="menu_cover_stories"
            ),
            # Mostrar Icon Colors apenas quando FM NÃO estiver selecionado
            *([Selector(
                key="customfm_icon_color",
                text=tr("customfm_icon_colors"),
                default=0,
                items=icon_color_items,
                icon="msg_colors"
            )] if not is_fm_player else []),
            
            # Mostrar Ícone Personalizado apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_icon_url",
                text=tr("customfm_custom_icon_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_custom_icon_url_sub")
            )] if is_fm_player else []),
            
            # Mostrar Link Personalizado apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_link_url",
                text=tr("customfm_custom_link_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_custom_link_url_sub")
            )] if is_fm_player else []),
            
            # Mostrar Nome Personalizado do Player apenas quando FM estiver selecionado
            *([Input(
                key="fm_custom_player_name",
                text=tr("customfm_custom_player_name"),
                default="Custom Player",
                icon="msg_photo_text_framed3",
                subtext=tr("customfm_custom_player_name_sub")
            )] if is_fm_player else []),
        ]
        
        # Adicionar as demais opções
        options.extend([
            Divider(text=tr("quality_options_section")),
            Switch(
                key="customfm_high_resolution",
                text=tr("customfm_high_resolution"),
                default=True,
                icon="menu_quality_hd_filled",
                subtext=tr("customfm_high_resolution_sub")
            ),
            Divider(text=tr("customfm_overlay_section")),
            Switch(
                key="lastfm_customfm_use_overlay",
                text=tr("customfm_use_overlay"),
                default=False,
                icon="msg_copy_photo",
                subtext=tr("customfm_use_overlay_sub")
            ),
            Input(
                key="lastfm_customfm_overlay_url",
                text=tr("customfm_overlay_url"),
                default="",
                icon="msg_link2_remix",
                subtext=tr("customfm_overlay_url_enhanced_sub")
            ),
            Divider(text=tr("dynamic_skins_section")),
            Selector(
                key="dynamic_skins_selector",
                text=tr("dynamic_skins_selector"),
                default=0,
                items=[
                    tr("dynamic_skins_none"),
                    tr("dynamic_skins_random"),
                    "Midnight Pulse",
                    "Sunset Rhythm",
                    tr("dynamic_skins_spcy"),
                    tr("dynamic_skins_purpl"),
                    tr("dynamic_skins_ardente"),
                    tr("dynamic_skins_manifest"),
                    tr("dynamic_skins_moment"),
                    tr("dynamic_skins_moment_redd"),
                    tr("dynamic_skins_moment_variant")
                ],
                icon="msg_fave",
            ),
            # Visual Avançado Subfragment
            Text(
                text=tr("visual_avancado_section"),
                icon="msg_mini_customize_remix",
                create_sub_fragment=self.create_visual_avancado_subfragment
            ),
            Divider(text=tr("read_docs_theme"))
        ])
        
        return options

    
    def _get_apple_cache_key(self, image_data, settings):
        """Gera uma chave única para o cache baseada na imagem e configurações"""
        import hashlib
        # Criar hash da imagem
        if hasattr(image_data, 'tobytes'):
            image_hash = hashlib.md5(image_data.tobytes()).hexdigest()[:16]
        else:
            image_hash = hashlib.md5(str(image_data).encode()).hexdigest()[:16]
        
        # Criar hash das configurações - VERSÃO CORRIGIDA
        
        # Construir string de configurações de forma explícita e segura
        settings_str = (
            f"{settings['antialiasing_quality']}_"
            f"{settings['resize_algorithm']}_"
            f"{settings['cover_quality']}_"
            f"{settings['enhanced_smoothing']}_"
            f"{settings['edge_enhancement']}_"
            f"{settings['color_enhancement']}_"
        )
        
        settings_hash = hashlib.md5(settings_str.encode()).hexdigest()[:8]
        
        # Log para diagnóstico
        log(f"[RADIUS DEBUG] Cache key settings_str: {settings_str}")
        log(f"[RADIUS DEBUG] Cache key generated: apple_cache_{image_hash}_{settings_hash}")
        
        return f"apple_cache_{image_hash}_{settings_hash}"
    
    def _apply_apple_antialiasing(self, image, target_size):
        """Aplica anti-aliasing baseado nas configurações do Apple UI"""
        try:
            # Obter configurações do Apple UI
            antialiasing_quality = self.get_setting("apple_antialiasing_quality", 1)
            resize_algorithm = self.get_setting("apple_resize_algorithm", 0)
            cover_quality = self.get_setting("apple_cover_quality", 0)
            enhanced_smoothing = self.get_setting("apple_enhanced_smoothing", True)
            edge_enhancement = self.get_setting("apple_edge_enhancement", False)
            color_enhancement = self.get_setting("apple_color_enhancement", False)
            cache_enabled = self.get_setting("apple_cache_processed_covers", True)
            async_processing = self.get_setting("apple_async_processing", True)
            
            # Verificar cache se habilitado
            if cache_enabled:
                settings_dict = {
                    'antialiasing_quality': antialiasing_quality,
                    'resize_algorithm': resize_algorithm,
                    'cover_quality': cover_quality,
                    'enhanced_smoothing': enhanced_smoothing,
                    'edge_enhancement': edge_enhancement,
                    'color_enhancement': color_enhancement
                }
                cache_key = self._get_apple_cache_key(image, settings_dict)
                
                # Log para diagnóstico de cache
                log(f"[RADIUS DEBUG] Checking cache with key: {cache_key}")
                log(f"[RADIUS DEBUG] Cache exists: {hasattr(self, '_apple_cache')}")
                if hasattr(self, '_apple_cache'):
                    log(f"[RADIUS DEBUG] Cache contains key: {cache_key in self._apple_cache}")
                    log(f"[RADIUS DEBUG] Cache size: {len(self._apple_cache)}")
                
                # Tentar obter do cache
                if hasattr(self, '_apple_cache') and cache_key in self._apple_cache:
                    log(f"[RADIUS DEBUG] Using cached image")
                    return self._apple_cache[cache_key]
                else:
                    log(f"[RADIUS DEBUG] Cache miss, will process new image")
                
                # Inicializar cache se não existir
                if not hasattr(self, '_apple_cache'):
                    self._apple_cache = {}
                
                # Limitar tamanho do cache (máximo 50 itens)
                if len(self._apple_cache) > 50:
                    # Remover itens mais antigos
                    oldest_keys = list(self._apple_cache.keys())[:10]
                    for key in oldest_keys:
                        del self._apple_cache[key]
            
            # Determinar tamanho baseado na qualidade (melhorado para Apple Music)
            if cover_quality == 1:  # Alta
                process_size = (600, 600)
            elif cover_quality == 2:  # Ultra
                process_size = (800, 800)
            else:  # Normal - aumentado para melhor qualidade mantendo proporções
                process_size = (512, 512) if target_size == (298, 298) else target_size
            
            # Determinar algoritmo de redimensionamento (otimizado para qualidade)
            algorithms = [Image.LANCZOS, Image.BICUBIC, Image.BILINEAR, Image.NEAREST]
            # Usar LANCZOS por padrão para melhor qualidade
            algorithm = algorithms[resize_algorithm] if resize_algorithm < len(algorithms) else Image.LANCZOS
            
            # Para Apple Music, sempre usar LANCZOS para máxima qualidade
            current_player = self._detect_current_player()
            if current_player == "Apple Music":
                algorithm = Image.LANCZOS
            
            # Redimensionar para tamanho de processamento
            if process_size != target_size:
                processed_image = ImageOps.fit(image, process_size, method=algorithm, centering=(0.5, 0.5))
            else:
                processed_image = ImageOps.fit(image, target_size, method=algorithm, centering=(0.5, 0.5))
            
            # Aplicar filtros baseados na qualidade do anti-aliasing (otimizado)
            if antialiasing_quality >= 1:  # Suave ou superior
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
            
            if antialiasing_quality >= 2:  # Ultra Suave ou superior
                processed_image = processed_image.filter(ImageFilter.SMOOTH)
                # Aplicar nitidez leve para compensar a suavização
                processed_image = processed_image.filter(ImageFilter.SHARPEN)
            
            if antialiasing_quality >= 3:  # Máxima Qualidade
                # Aplicar filtro UnsharpMask para melhor nitidez
                processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=120, threshold=3))
            
            # Para Apple Music, aplicar sempre filtros de alta qualidade
            if current_player == "Apple Music":
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
                processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=110, threshold=2))
            
            # Aplicar suavização aprimorada se habilitada
            if enhanced_smoothing:
                processed_image = processed_image.filter(ImageFilter.SMOOTH_MORE)
            
            # Aplicar realce de bordas se habilitado
            if edge_enhancement:
                processed_image = processed_image.filter(ImageFilter.EDGE_ENHANCE)
            
            # Aplicar realce de cores se habilitado
            if color_enhancement:
                from PIL import ImageEnhance
                enhancer = ImageEnhance.Color(processed_image)
                processed_image = enhancer.enhance(1.2)  # Aumentar saturação em 20%
                enhancer = ImageEnhance.Contrast(processed_image)
                processed_image = enhancer.enhance(1.1)  # Aumentar contraste em 10%
            
            # Redimensionar para tamanho final se necessário
            if process_size != target_size:
                processed_image = ImageOps.fit(processed_image, target_size, method=algorithm, centering=(0.5, 0.5))
            
            # Processamento finalizado
            
            # Salvar no cache se habilitado
            if cache_enabled:
                self._apple_cache[cache_key] = processed_image.copy()
            
            return processed_image
            
        except Exception as e:
            log(f"Erro ao aplicar anti-aliasing Apple: {e}")
            # Fallback para método padrão
            return ImageOps.fit(image, target_size, method=Image.LANCZOS, centering=(0.5, 0.5)).filter(ImageFilter.SMOOTH_MORE)
    
    def _get_dynamic_ui_options(self, theme_items):
        """Retorna as opções de UI baseadas no tema selecionado"""
        ui_options = []
        
        # Obter o tema selecionado atual
        current_theme = self.get_setting("theme_selector", 0)
        
        # Verificar se é o tema Apple (índice 0)
        if current_theme == 0:  # Apple
            ui_options.extend([
                Text(
                    text="Apple UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_apple_ui_options
                )
            ])
        
        # Verificar se é CustomFM (penúltimo na lista)
        customfm_index = len(theme_items) - 2  # CustomFM é sempre penúltimo
        if current_theme == customfm_index:
            ui_options.append(
                Text(
                    text="CustomFM UI",
                    icon="msg_theme_solar",
                    create_sub_fragment=self.create_lastfm_customfm_options
                )
            )
        
        # Verificar se é Vinify (4º último na lista: Vinify, Nowv, CustomFM, Minimal)
        vinify_index = len(theme_items) - 4  # Vinify é o 4º último
        if current_theme == vinify_index:
            ui_options.append(
                Text(
                    text="Vinify UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_vinify_ui_options
                )
            )
        
        # Verificar se é Nowv (3º último na lista)
        nowv_index = len(theme_items) - 3  # Nowv é o 3º último
        if current_theme == nowv_index:
            ui_options.append(
                Text(
                    text="Nowv UI",
                    icon="msg_theme_remix",
                    create_sub_fragment=self.create_nowv_ui_options
                )
            )
        
        # Para Minimal, não mostrar nenhuma UI específica
        
        return ui_options
    
    def create_apple_ui_options(self):
        """Cria as opções avançadas para os temas Apple (Experimental)
        
        Funcionalidades implementadas:
        - Radius configurável para mini capas
        - Anti-aliasing configurável (Padrão, Suave, Ultra Suave, Máxima Qualidade)
        - Algoritmos de redimensionamento (LANCZOS, BICUBIC, BILINEAR, NEAREST)
        - Qualidade da mini capa (Normal 298x298, Alta 400x400, Ultra 500x500)
        - Suavização aprimorada com filtros adicionais
        - Realce de bordas para melhor definição
        - Realce de cores com saturação e contraste
        - Cache inteligente para mini capas processadas
        - Processamento assíncrono para melhor performance
        """
        

        
        # Opções de qualidade de anti-aliasing
        antialiasing_quality_items = [
            tr("apple_antialiasing_standard"),
            tr("apple_antialiasing_smooth"),
            tr("apple_antialiasing_ultra_smooth"),
            tr("apple_antialiasing_high_quality")
        ]
        
        # Opções de algoritmo de redimensionamento
        resize_algorithm_items = [
            "LANCZOS (Default)",
            "BICUBIC",
            "BILINEAR",
            "NEAREST"
        ]
        
        # Opções de qualidade da mini capa
        cover_quality_items = [
            "Normal (298x298)",
            "Alta (400x400)",
            "Ultra (500x500)"
        ]
        
        return [
            Divider(text=tr("apple_ui_warning")),
            

            
            Divider(text=tr("apple_quality_antialiasing_section")),
            Selector(
                key="apple_antialiasing_quality",
                text=tr("apple_antialiasing_quality"),
                default=1,  # Suave como padrão
                items=antialiasing_quality_items,
                icon="msg_photo_curve_remix"
            ),
            Selector(
                key="apple_resize_algorithm",
                text=tr("apple_resize_algorithm"),
                default=0,  # LANCZOS como padrão
                items=resize_algorithm_items,
                icon="media_crop"
            ),
            Selector(
                key="apple_cover_quality",
                text=tr("apple_cover_quality"),
                default=1,  # Alta qualidade como padrão
                items=cover_quality_items,
                icon="menu_feature_cover"
            ),
            
            Divider(text=tr("apple_visual_optimizations_section")),
            Switch(
                key="apple_enhanced_smoothing",
                text=tr("apple_enhanced_smoothing"),
                default=True,
                icon="msg_forward_replace_remix"
            ),
            Switch(
                key="apple_edge_enhancement",
                text=tr("apple_edge_enhancement"),
                default=True,
                icon="msg_gallery"
            ),
            Switch(
                key="apple_color_enhancement",
                text=tr("apple_color_enhancement"),
                default=True,
                icon="msg_brightness_low"
            ),
            
            Divider(text=tr("apple_performance_section")),
            Switch(
                key="apple_cache_processed_covers",
                text=tr("apple_cache_processed_covers"),
                default=True,
                icon="menu_feature_hourglass"
            ),
            Switch(
                key="apple_async_processing",
                text=tr("apple_async_processing"),
                default=False,
                icon="msg2_folder"
            )
        ]

    def create_vinify_ui_options(self):
        """Cria as opções de UI para o tema Vinify"""
        
        # Opções de cores para a ViniBar com nomes traduzidos
        color_options = [
            tr("color_default"),  # Padrão (Branco)
            tr("color_red"),      # Vermelho
            tr("color_orange"),   # Laranja
            tr("color_yellow"),   # Amarelo
            tr("color_green"),    # Verde
            tr("color_blue"),     # Azul
            tr("color_indigo"),   # Índigo
            tr("color_violet")    # Violeta
        ]
        
        # Opções de cores de fundo com nomes traduzidos
        bg_color_options = [
            tr("color_default"),  # Padrão (Cinza)
            tr("color_red"),      # Vermelho escuro
            tr("color_orange"),   # Laranja escuro
            tr("color_yellow"),   # Amarelo escuro
            tr("color_green"),    # Verde escuro
            tr("color_blue"),     # Azul escuro
            tr("color_indigo"),   # Índigo escuro
            tr("color_violet")    # Violeta escuro
        ]
        
        # Verificar configuração atual do Display Information
        device_profile_mode = self.get_setting("vinify_device_profile_mode", 0)
        
        options = [
            # Seção Informações do Card
            Divider(text=tr("card_info_section")),
            
            # Seletor para mostrar dispositivo, perfil do usuário, nome personalizado, profile & device ou nenhum
            Selector(
                key="vinify_device_profile_mode",
                text=tr("device_profile_selector"),
                default=0,  # Show Device
                items=[
                    tr("show_device"),
                    tr("my_profile"),
                    tr("custom_name"),
                    tr("profile_and_device"),
                    tr("display_none")
                ],
                icon="msg_openprofile",
                on_change=lambda v: self.reload_settings()
            )
        ]
        
        # Input para nome personalizado (aparece apenas quando Custom Name está selecionado)
        if device_profile_mode == 2:  # Custom Name
            options.append(
                Input(
                    key="vinify_custom_display_name",
                    text=tr("custom_display_name"),
                    default="",
                    icon="menu_tag_rename",
                    subtext=tr("custom_display_name_sub")
                )
            )
        
        options.extend([
            # Exibir nome do álbum ou playlist no card
            Selector(
                key="vinify_album_playlist_mode",
                text=tr("album_playlist_mode"),
                default=0,  # Desabilitado
                items=[
                    tr("album_playlist_disabled"),
                    tr("album_playlist_auto"),
                    tr("album_playlist_album"),
                    tr("album_playlist_playlist")
                ],
                icon="files_music"
            ),
            
            # Seção ViniBar Settings
            Divider(text=tr("vinibar_settings_section")),
            
            # Cor principal da ViniBar
            Selector(
                key="vinify_bar_color",
                text=tr("vinibar_color"),
                default=0,  # Padrão como padrão
                items=color_options,
                icon="photo_paint_brush_solar"
            ),
            
            # Cor de fundo da ViniBar
            Selector(
                key="vinify_bar_bg_color",
                text=tr("vinibar_bg_color"),
                default=0,  # Padrão como padrão
                items=bg_color_options,
                icon="photo_paint_brush"
            ),
            
            # Switch para ativar o gradiente
            Switch(
                key="vinify_bar_gradient",
                text=tr("vinibar_gradient"),
                default=False,
                icon="gradient_right",
                subtext=tr("vinibar_gradient_sub")
            ),
            
            # Switch para ativar o efeito de blur/vidro (ativado por padrão)
            Switch(
                key="vinify_bar_blur",
                text=tr("vinibar_blur"),
                default=True,
                icon="gradient_left",
                subtext=tr("vinibar_blur_sub")
            ),

            # Seção de Fundo do Vinify
            Divider(text=tr("vinify_background_section")),
            Switch(
                key="vinify_custom_bg_enable",
                text=tr("vinify_custom_bg"),
                default=False,
                icon="widgets_light_badgebg",
                subtext=tr("vinify_custom_bg_sub")
            ),
            Input(
                key="vinify_custom_bg_url",
                text=tr("vinify_custom_bg_url"),
                default="",
                icon="menu_feature_links",
                subtext=tr("vinify_custom_bg_url_sub")
            ),
            Selector(
                key="vinify_bg_style",
                text=tr("vinify_bg_styles"),
                default=0,
                items=[
                    tr("vinify_bg_style_none"),
                    tr("vinify_bg_style_obsidian"),
                    tr("vinify_bg_style_morph"),
                    tr("vinify_bg_style_noir"),
                    tr("vinify_bg_style_ethereal"),
                    tr("vinify_bg_style_ethereal_mirage"),
                    tr("vinify_bg_style_silken"),
                    tr("vinify_bg_style_mock"),
                    tr("vinify_bg_style_random")
                ],
                icon="msg_copy_photo"
            ),
            Selector(
                key="vinify_shadow_style",
                text=tr("vinify_shadow"),
                default=0,
                items=[
                    tr("vinify_shadow_none"),
                    tr("vinify_shadow_black"),
                    tr("vinify_shadow_white"),
                    tr("vinify_shadow_gradient")
                ],
                icon="photo_rectangle"
            ),
            
            # Seção Efeitos Visuais
            Divider(text=tr("visual_effects_section")),
            
            # Platform Logo Selector (apenas para Spotify e Apple Music)
            self._get_platform_logo_selector(),
            
            # Logo Position Selector (Superior/Inferior)
            Selector(
                key="vinify_logo_position",
                text=tr("logo_position"),
                default=0,
                items=[
                    tr("logo_position_superior"),
                    tr("logo_position_inferior")
                ],
                icon="photo_expand"
            ),
            
            # Switch para inverter horizontalmente a imagem de fundo
            Switch(
                key="vinify_flip_background",
                text=tr("vinify_flip_background"),
                default=False,
                icon="media_flip",
                subtext=tr("vinify_flip_background_sub")
            ),
            
            # Seletor de efeitos de fundo baseado na capa da música
            Selector(
                key="vinify_background_effect",
                text=tr("vinify_background_effect"),
                default=0,  # None como padrão
                items=[
                    tr("background_effect_none"),
                    tr("background_effect_album_colors"),
                    tr("background_effect_blur"),
                    tr("background_effect_darker"),
                    tr("background_effect_both")
                ],
                icon="menu_feature_custombg"
            ),
            
            # Seção Configurações Avançadas
            Divider(text=tr("advanced_settings_section")),
            
            # Escolher ícone do dispositivo para Stats.fm
            Selector(
                key="statsfm_device_type",
                text=tr("statsfm_device_selector"),
                default=0,
                items=[
                    tr("device_auto"),
                    tr("device_smartphone"),
                    tr("device_computer"),
                    tr("device_speaker"),
                    tr("device_tv"),
                    tr("device_web")
                ],
                icon="msg_devices_remix"
            ),
            
            # Nome personalizado do dispositivo
            Input(
                key="vinify_device_name",
                text=tr("device_name"),
                default="",
                icon="menu_tag_rename",
                subtext=tr("device_name_sub")
            ),
            
            # Switch para trocar o lado da capa e textos
            Switch(
                key="vinify_swap_layout",
                text=tr("vinify_swap_layout"),
                default=False,
                icon="msg_replace",
                subtext=tr("vinify_swap_layout_sub")
            )
        ])
        
        return options
    
    def create_nowv_ui_options(self):
        """Cria as opções de UI para o tema Nowv"""
        try:
            # Verificar se Banner Style está ativado para controlar visibilidade
            banner_style_enabled = self.get_setting("nowv_banner_style", False)
            
            options = [
                # Seção Estilo do Tema
                Divider(text=tr("nowv_theme_style")),
                
                # Banner Style Switch
                Switch(
                    key="nowv_banner_style",
                    text="Banner Style",
                    default=False,
                    icon="msg_photos",
                    on_change=lambda v: self.reload_settings()
                )
            ]
            
            # Só mostrar Background Effect se Banner Style estiver desativado
            if not banner_style_enabled:
                options.extend([
                    # Seção Aparência Visual
                    Divider(text=tr("nowv_visual_appearance")),
                    
                    # Efeito de fundo baseado na capa
                    Selector(
                        key="nowv_background_effect",
                        text=tr("vinify_background_effect"),
                        default=0,  # None como padrão
                        items=[
                            tr("background_effect_none"),
                            tr("background_effect_blur"),
                            tr("background_effect_darker"),
                            tr("background_effect_both")
                        ],
                        icon="menu_feature_custombg"
                    ),
                    
                    # Inverter horizontalmente a imagem de fundo
                    Switch(
                        key="nowv_flip_background",
                        text=tr("vinify_flip_background"),
                        default=False,
                        icon="media_flip",
                        subtext=tr("vinify_flip_background_sub")
                    )
                ])
            
            # Seção Barra de Progresso sempre visível
            options.extend([
                # Seção Barra de Progresso
                Divider(text=tr("nowv_progress_bar")),
                
                # Seletor de estilo da NowvBar
                Selector(
                    key="nowv_bar_style",
                    text="NowvBar Style",
                    default=0,  # Style 1 como padrão
                    items=[
                        "Style 1",
                        "Style 2"
                    ],
                    icon="photo_star"
                )
            ])
            
            return options
        except Exception:
            return []
    
    def create_visual_avancado_subfragment(self):
        """Cria o subfragment Visual Avançado com recursos de gradientes dinâmicos"""
        
        # Opções para estilo do gradiente
        gradient_style_items = [
            tr("gradiente_linear"),
            tr("gradiente_radial"),
            tr("gradiente_diagonal")
        ]
        
        # Opções para direção do gradiente
        gradient_direction_items = [
            tr("gradiente_top_bottom"),
            tr("gradiente_left_right"),
            tr("gradiente_diagonal_tl_br"),
            tr("gradiente_diagonal_tr_bl")
        ]
        
        # Opções para intensidade do gradiente
        gradient_intensity_items = [
            tr("gradiente_suave"),
            tr("gradiente_medio"),
            tr("gradiente_intenso")
        ]
        
        # Opções para extração de cores
        color_extraction_items = [
            tr("gradiente_dominante"),
            tr("gradiente_complementar"),
            tr("gradiente_analogas")
        ]
        
        return [
            Divider(text=tr("gradientes_dinamicos_section")),
            Switch(
                key="visual_avancado_gradiente_enable",
                text=tr("gradiente_enable"),
                default=False,
                icon="media_button_restore",
                subtext=tr("gradiente_enable_sub")
            ),
            Selector(
                key="visual_avancado_gradiente_modo",
                text=tr("gradiente_modo"),
                default=0,
                items=[tr("gradiente_modo_auto"), tr("gradiente_modo_custom")],
                icon="msg_photo_settings"
            ),
            Selector(
                key="visual_avancado_gradiente_style",
                text=tr("gradiente_style"),
                default=0,
                items=gradient_style_items,
                icon="menu_tag_edit"
            ),
            Selector(
                key="visual_avancado_gradiente_direction",
                text=tr("gradiente_direction"),
                default=0,
                items=gradient_direction_items,
                icon="msg_call_minimize"
            ),
            Selector(
                key="visual_avancado_gradiente_intensity",
                text=tr("gradiente_intensity"),
                default=1,
                items=gradient_intensity_items,
                icon="menu_edit_appearance_remix"
            ),
            Selector(
                key="visual_avancado_color_extraction",
                text=tr("gradiente_color_extraction"),
                default=0,
                items=color_extraction_items,
                icon="ic_colorpicker_solar"
            ),
            Divider(text=tr("cores_personalizadas_section")),
            Input(
                key="visual_avancado_gradiente_cor1",
                text=tr("gradiente_cor1"),
                default="#FF6B6B",
                icon="msg_edit_solar"
            ),
            Input(
                key="visual_avancado_gradiente_cor2",
                text=tr("gradiente_cor2"),
                default="#4ECDC4",
                icon="msg_edit_solar"
            )
        ]

    def _get_service_icon(self, player, use_custom_color=False):
        try:
            # Dicionário de ícones com cores personalizadas
            icon_colors = {
                "spotify": {
                    "normal": "https://i.postimg.cc/MZg52Vkb/spfynow.png",
                    "black": "https://i.postimg.cc/5NzH8DcQ/spfynowblack.png",
                    "white": "https://i.postimg.cc/GmJH5Ymc/spfynowwhite.png"
                },
                "youtube": {
                    "normal": "https://i.postimg.cc/sgrJ1zgM/yt.png",
                    "black": "https://i.postimg.cc/L8MJDvRC/ytblack.png",
                    "white": "https://i.postimg.cc/Twh114qw/ytwhite.png"
                },
                "youtubemusic": {
                    "normal": "https://i.postimg.cc/nhGGDWX0/ytm.png",
                    "black": "https://i.postimg.cc/wBq78v1D/ytmblack.png",
                    "white": "https://i.postimg.cc/vm0DQsnk/ytmwhite.png"
                },
                "soundcloud": {
                    "normal": "https://i.postimg.cc/nc7kHrp8/soundcloudicon.png",
                    "black": "https://i.postimg.cc/6qkyDfZQ/soundcloudiconblack.png",
                    "white": "https://i.postimg.cc/7PdGGwRy/soundcloudiconwhite.png"
                },
                "exteragram": {
                    "normal": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                    "black": "https://i.postimg.cc/nL29Cmyd/exteragramblack.png",
                    "white": "https://i.postimg.cc/gjXxSTn5/exteragramwhite.png"
                },
                "ayugram": {
                    "normal": "https://i.postimg.cc/c6qr9dbw/ayugram.png",
                    "black": "https://i.postimg.cc/sX0BJrD7/ayugramblack.png",
                    "white": "https://i.postimg.cc/DZzJsZF7/ayugramwhite.png"
                },
                "applemusic": {
                    "normal": "https://i.postimg.cc/V6ppw48x/applemusic.png",
                    "black": "https://i.postimg.cc/1tf2b2L0/applemusicblack.png",
                    "white": "https://i.postimg.cc/GpM67dSh/applemusicwhite.png"
                },
                "fm": {
                    "normal": self.get_setting("fm_custom_icon_url", ""),
                    "black": self.get_setting("fm_custom_icon_url", ""),
                    "white": self.get_setting("fm_custom_icon_url", "")
                }
            }
            
            # Se usar cor personalizada, verificar configuração
            if use_custom_color:
                icon_color_setting = self.get_setting("customfm_icon_color", 0)
                log(f"[Nowfy] Icon color setting: {icon_color_setting}")
                
                # Usar o Media Source (current_player) configurado pelo usuário
                media_source_player = self._detect_current_player()
                log(f"[Nowfy] Media Source detected: {media_source_player}")
                
                # Mapear o Media Source para a chave do dicionário
                player_lower = media_source_player.lower().replace(" ", "")
                if player_lower == "youtubemusic":
                    current_source = "youtubemusic"
                elif player_lower in ["exteragram", "telegram"]:
                    current_source = "exteragram"
                elif player_lower == "ayugram":
                    current_source = "ayugram"
                elif player_lower == "applemusic":
                    current_source = "applemusic"
                elif player_lower == "fm":
                    current_source = "fm"
                else:
                    current_source = player_lower
                
                log(f"[Nowfy] Media Source: {media_source_player}, Mapped source: {current_source}")
                
                color_options = ["normal", "black", "white"]
                selected_color = color_options[icon_color_setting] if icon_color_setting < len(color_options) else "normal"
                log(f"[Nowfy] Selected color: {selected_color}")
                
                if current_source in icon_colors and selected_color in icon_colors[current_source]:
                    icon_url = icon_colors[current_source][selected_color]
                    log(f"[Nowfy] Using custom color icon for Media Source: {icon_url}")
                    return icon_url
                else:
                    log(f"[Nowfy] Custom color not found for {current_source}/{selected_color}, using fallback")
            
            # Fallback para ícones padrão
            icon_urls = {
                "Spotify": "https://i.postimg.cc/MZg52Vkb/spfynow.png",
                "YouTube": "https://i.postimg.cc/sgrJ1zgM/yt.png",
                "YouTube Music": "https://i.postimg.cc/nhGGDWX0/ytm.png",
                "Telegram": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                "exteraGram": "https://i.postimg.cc/PfCyRK75/exteragram.png",
                "AyuGram": "https://i.postimg.cc/c6qr9dbw/ayugram.png",
                "SoundCloud": "https://i.postimg.cc/nc7kHrp8/soundcloudicon.png",
                "Apple Music": "https://i.postimg.cc/V6ppw48x/applemusic.png",
                "FM": self.get_setting("fm_custom_icon_url", "")
            }
            return icon_urls.get(player)
        except Exception as e:
            print(f"Error getting service icon: {e}")
            return None

    def _get_youtube_cover(self, song_title, artists=''):
        try:
            # Usar chave universal se não houver chave configurada pelo usuário
            youtube_api_key = self.get_setting('youtube_api_key', '') or self._get_universal_youtube_key()
            if not youtube_api_key:
                raise Exception(tr('error_youtube_api_key'))

            search_query = f"{song_title} {artists} official music video"
            # Buscar mais resultados para aumentar a chance de maxresdefault
            search_url = f"https://www.googleapis.com/youtube/v3/search?part=snippet&q={quote(search_query)}&type=video&maxResults=5&key={youtube_api_key}"

            response = requests.get(search_url, timeout=10)
            data = response.json()

            if 'error' in data:
                raise Exception(tr('error_youtube_api').format(data['error'].get('message', tr('error_unknown'))))

            if 'items' in data and data['items']:
                video_ids = [item['id']['videoId'] for item in data['items'] if 'id' in item and 'videoId' in item['id']]
                quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                # Prioriza a melhor qualidade disponível entre até 5 resultados, validando resolução
                for quality in quality_order:
                    for video_id in video_ids:
                        for base in ["https://img.youtube.com", "https://i.ytimg.com"]:
                            thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                            try:
                                # HEAD rápida; se não suportado, tentar GET
                                head_resp = requests.head(thumb_url, timeout=5)
                                if head_resp.status_code != 200:
                                    get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                    if get_resp.status_code != 200:
                                        continue
                                # Validar qualidade real com GET
                                data_resp = requests.get(thumb_url, timeout=8)
                                if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                    return thumb_url
                            except Exception:
                                continue
            # Fallback Nowfy
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"
        except Exception as e:
            print(tr('error_unknown').format(str(e)))
            if 'quota' in str(e).lower():
                print(tr('error_youtube_quota'))
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"

    def _get_youtube_thumbnail_forced(self, song_title, artists=''):
        """Busca thumbnails do YouTube priorizando o primeiro resultado (oficial)"""
        try:
            import re
            from urllib.parse import quote_plus
            
            # Limpar e melhorar a query de busca
            clean_title = self._clean_search_term(song_title)
            clean_artist = self._clean_search_term(artists) if artists else ''
            
            # Estratégia SIMPLES: priorizar busca oficial
            if clean_artist:
                # Busca mais precisa: Artista + Título + "official"
                search_query = f"{clean_artist} {clean_title} official"
            else:
                # Sem artista: Título + "official"
                search_query = f"{clean_title} official"
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            try:
                search_url = f"https://www.youtube.com/results?search_query={quote_plus(search_query)}"
                log(f"[CustomFM] YouTube search: {search_query}")
                
                response = requests.get(search_url, headers=headers, timeout=10)
                if response.status_code == 200:
                    # Buscar video IDs na página (pegar os primeiros resultados)
                    video_ids = re.findall(r'"videoId":"([a-zA-Z0-9_-]{11})"', response.text)
                    
                    if video_ids:
                        # SEMPRE usar o PRIMEIRO resultado (geralmente é o oficial)
                        video_id = video_ids[0]
                        log(f"[CustomFM] Using FIRST result (official): {video_id}")
                        
                        # Tentar diferentes qualidades com validação de resolução e domínios alternativos
                        quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                        bases = ["https://img.youtube.com", "https://i.ytimg.com"]
                        for quality in quality_order:
                            for base in bases:
                                thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                                try:
                                    # HEAD rápida; se não suportado, tentar GET
                                    head_resp = requests.head(thumb_url, timeout=5)
                                    if head_resp.status_code != 200:
                                        get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                        if get_resp.status_code != 200:
                                            continue
                                    # Validar qualidade real com GET
                                    data_resp = requests.get(thumb_url, timeout=8)
                                    if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                        log(f"[CustomFM] Found YouTube thumbnail: {thumb_url}")
                                        return thumb_url
                                except Exception:
                                    continue
                    
                    # Fallback: tentar busca sem "official"
                    if clean_artist:
                        fallback_query = f"{clean_artist} {clean_title}"
                    else:
                        fallback_query = clean_title
                    
                    fallback_url = f"https://www.youtube.com/results?search_query={quote_plus(fallback_query)}"
                    log(f"[CustomFM] Fallback search: {fallback_query}")
                    
                    fallback_response = requests.get(fallback_url, headers=headers, timeout=10)
                    if fallback_response.status_code == 200:
                        video_ids = re.findall(r'"videoId":"([a-zA-Z0-9_-]{11})"', fallback_response.text)
                        
                        if video_ids:
                            video_id = video_ids[0]  # Primeiro resultado sempre
                            log(f"[CustomFM] Using fallback FIRST result: {video_id}")
                            
                            # Tentar diferentes qualidades com validação e domínios alternativos
                            quality_order = ['maxresdefault', 'hq720', 'sddefault', 'hqdefault', 'mqdefault', 'default']
                            bases = ["https://img.youtube.com", "https://i.ytimg.com"]
                            for quality in quality_order:
                                for base in bases:
                                    thumb_url = f"{base}/vi/{video_id}/{quality}.jpg"
                                    try:
                                        head_resp = requests.head(thumb_url, timeout=5)
                                        if head_resp.status_code != 200:
                                            get_resp = requests.get(thumb_url, timeout=8, stream=True)
                                            if get_resp.status_code != 200:
                                                continue
                                        data_resp = requests.get(thumb_url, timeout=8)
                                        if data_resp.status_code == 200 and self._is_high_quality_thumbnail(data_resp.content):
                                            log(f"[CustomFM] Found fallback thumbnail: {thumb_url}")
                                            return thumb_url
                                    except Exception:
                                        continue
                        
            except Exception as e:
                log(f"[CustomFM] Error in YouTube search: {e}")
            
            log(f"[CustomFM] No YouTube thumbnail found, using icondefault")
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"
            
        except Exception as e:
            log(f"[CustomFM] Error in forced YouTube thumbnail search: {e}")
            return "https://i.postimg.cc/4yjVLFTV/icondefault.png"

    def _find_best_youtube_match(self, matches, title, artist):
        """Encontra o melhor match do YouTube baseado em relevância"""
        try:
            import re
            
            # Normalizar termos para comparação
            title_lower = title.lower() if title else ''
            artist_lower = artist.lower() if artist else ''
            
            scored_matches = []
            
            for video_id, video_title in matches:
                video_title_lower = video_title.lower()
                score = 0
                
                # Pontuação baseada na presença de termos
                if title_lower and title_lower in video_title_lower:
                    score += 50
                
                if artist_lower and artist_lower in video_title_lower:
                    score += 40
                
                # Bonus para vídeos oficiais
                if any(term in video_title_lower for term in ['official', 'oficial']):
                    score += 20
                
                # Bonus para music videos
                if any(term in video_title_lower for term in ['music video', 'mv', 'clipe']):
                    score += 15
                
                # Penalizar covers, remixes, etc.
                penalty_terms = ['cover', 'remix', 'karaoke', 'instrumental', 'live', 'ao vivo', 'reaction', 'tutorial']
                for term in penalty_terms:
                    if term in video_title_lower:
                        score -= 25
                        break
                
                # Penalizar vídeos muito longos (provavelmente playlists)
                if any(term in video_title_lower for term in ['playlist', 'mix', 'compilation', 'hours', 'horas']):
                    score -= 30
                
                # Bonus para correspondência exata de palavras
                title_words = re.findall(r'\b\w+\b', title_lower)
                video_words = re.findall(r'\b\w+\b', video_title_lower)
                
                matching_words = len(set(title_words) & set(video_words))
                if title_words:
                    word_match_ratio = matching_words / len(title_words)
                    score += int(word_match_ratio * 30)
                
                scored_matches.append((video_id, video_title, score))
            
            # Ordenar por pontuação (maior primeiro)
            scored_matches.sort(key=lambda x: x[2], reverse=True)
            
            # Retornar o melhor match se tiver pontuação positiva
            if scored_matches and scored_matches[0][2] > 0:
                best_match = scored_matches[0]
                log(f"[CustomFM] Best match score: {best_match[2]} for '{best_match[1]}'")
                return (best_match[0], best_match[1])
            
            # Se nenhum match bom, retornar o primeiro da lista original
            if matches:
                log(f"[CustomFM] No good matches, using first result: '{matches[0][1]}'")
                return matches[0]
            
            return None
            
        except Exception as e:
            log(f"[CustomFM] Error in YouTube match filtering: {e}")
            # Fallback para o primeiro resultado
            return matches[0] if matches else None

    def _search_spotify_url(self, title, artist):
        """Busca o link do Spotify para uma música específica"""
        try:
            token = self._get_access_token()
            if not token:
                return None
            
            query = f"{title} {artist}"
            resp = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=1",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if resp.status_code == 200:
                data = resp.json()
                items = data.get("tracks", {}).get("items", [])
                if items:
                    return items[0]["external_urls"]["spotify"]
        except Exception:
            pass
        return None

    def _search_spotify_url_public(self, title, artist):
        try:
            import re
            import requests
            from urllib.parse import quote
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
            }
            query = f"site:open.spotify.com track {title} {artist}"
            url = f"https://duckduckgo.com/html/?q={quote(query)}"
            resp = requests.get(url, timeout=8, headers=headers)
            if resp.status_code == 200:
                body = resp.text
                m = re.search(r"https://open\.spotify\.com/track/[A-Za-z0-9]+", body)
                if m:
                    return m.group(0)
        except Exception as e:
            log(f"[Nowfy] Public Spotify search failed: {e}")
        return None

    def _get_spotify_oembed_thumbnail(self, spotify_url):
        try:
            import re
            import requests
            from urllib.parse import quote
            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36",
                "Accept": "application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            }
            oembed_url = f"https://open.spotify.com/oembed?url={quote(spotify_url)}"
            r = requests.get(oembed_url, timeout=8, headers=headers)
            if r.status_code == 200:
                data = r.json()
                thumb = data.get("thumbnail_url")
                if thumb:
                    return thumb
            # Fallback: parse OG image da página
            page = requests.get(spotify_url, timeout=8, headers=headers)
            if page.status_code == 200:
                m = re.search(r'<meta property="og:image" content="([^"]+)"', page.text)
                if m:
                    return m.group(1)
        except Exception as e:
            log(f"[Nowfy] Spotify oEmbed/OG thumbnail failed: {e}")
        return None

    def _get_spotify_cover_fallback(self, title, artists):
        try:
            primary_artist = artists.split(",")[0].strip() if isinstance(artists, str) else artists
            # Tentar via API com token
            spotify_url = self._search_spotify_url(title, primary_artist)
            if not spotify_url:
                # Tentar via busca pública sem credenciais
                spotify_url = self._search_spotify_url_public(title, primary_artist)
            if spotify_url:
                return self._get_spotify_oembed_thumbnail(spotify_url)
        except Exception as e:
            log(f"[Nowfy] Spotify cover fallback failed: {e}")
        return None

    def get_current_track_etg(self, account):
    # Detecta música tocando no exteraGram/AyuGram usando MediaController"""
        try:
            from org.telegram.messenger import MediaController
            media_controller = MediaController.getInstance()
            playing_song = media_controller.getPlayingMessageObject()

            if playing_song is None or not playing_song.isMusic():
                return None

            title = playing_song.getMusicTitle()
            artist = playing_song.getMusicAuthor()
            duration = playing_song.getDuration()
            progress = media_controller.getPlayingMessageObject().audioProgressSec

            return {
                "title": title,
                "artist": artist,
                "duration": duration,
                "progress": progress,
                "is_playing": True
            }
        except Exception as e:
            log(f"[Nowfy] Error detecting Telegram music: {e}")
            return None

    def get_etg_cover(self, message_object):
        ## Busca capa da música do etg usando múltiplas APIs
        try:
            debug_mode = self.get_setting("artwork_debug", False)
            
            # Verificação segura do objeto de mensagem
            if not message_object or not hasattr(message_object, '__dict__'):
                if debug_mode:
                    log("[Nowfy] No valid message object provided for etg cover")
                return None
                
            # Verificação segura dos métodos necessários
            if not all(hasattr(message_object, attr) for attr in ['getMusicTitle', 'getMusicAuthor']):
                if debug_mode:
                    log("[Nowfy] Message object doesn't have required music methods")
                return None
                
            # Verificação segura do atributo caption (se existir)
            if hasattr(message_object, 'caption'):
                caption = message_object.caption
                if debug_mode:
                    log(f"[Nowfy] Message caption: {caption}")
            
            title = message_object.getMusicTitle()
            artist = message_object.getMusicAuthor()
            
            if debug_mode:
                log(f"[Nowfy] etg music data - Title: '{title}', Artist: '{artist}'")
            
            if not title and not artist:
                if debug_mode:
                    log("[Nowfy] No title or artist found in etg message")
                return None
                
            # Sempre ativar debug para etg covers
            self.set_setting("artwork_debug", True)
            result = self._search_music_artwork(artist, title)
            log(f"[Nowfy] etg cover search completed. Result: {'Found' if result else 'Not found'}")
            return result
            
        except Exception as e:
            log(f"[Nowfy] Error getting etg cover: {e}")
            return None

    def get_soundcloud_cover(self, title, artist):
        """Busca a capa da música no SoundCloud usando múltiplas estratégias avançadas."""
        try:
            import re
            import requests
            from secrets import choice
            import json
            import time
            from urllib.parse import quote, unquote
            
            # User agents mais variados e atualizados para evitar bloqueios
            user_agents = [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
            ]
            
            # Headers mais realistas
            headers = {
                'User-Agent': choice(user_agents),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,pt;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0'
            }
            
            # Limpar e normalizar termos de busca
            clean_title = self._clean_search_term(title) if hasattr(self, '_clean_search_term') else title
            clean_artist = self._clean_search_term(artist) if hasattr(self, '_clean_search_term') else artist
            
            # Múltiplas variações de busca para aumentar chances de sucesso
            search_queries = [
                f"{clean_title} {clean_artist}",
                f"{clean_artist} {clean_title}",
                f'"{clean_title}" "{clean_artist}"',
                f"{clean_title}",
                f"{clean_artist} - {clean_title}",
                f"{clean_title} by {clean_artist}"
            ]
            
            log(f"[Nowfy] Advanced SoundCloud search starting for: {title} by {artist}")
            
            for i, search_query in enumerate(search_queries):
                try:
                    log(f"[Nowfy] SoundCloud search attempt {i+1}: {search_query}")
                    
                    # Estratégia 1: Busca direta no SoundCloud com retry
                    search_url = f"https://soundcloud.com/search?q={quote(search_query)}"
                    
                    # Adicionar delay entre requests para evitar rate limiting
                    if i > 0:
                        time.sleep(0.5)
                    
                    resp = requests.get(search_url, timeout=15, headers=headers)
                    
                    if resp.status_code == 200:
                        # Padrões mais robustos e específicos para encontrar tracks
                        track_patterns = [
                            r'"permalink_url":"(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'href="(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'"uri":"(https://soundcloud\.com/[^/]+/[^"]+)"',
                            r'<a[^>]*href="(https://soundcloud\.com/[^/]+/[^"]+)"[^>]*>',
                            r'soundcloud\.com/([^/]+)/([^"\s]+)'
                        ]
                        
                        track_urls = []
                        for pattern in track_patterns:
                            matches = re.findall(pattern, resp.text, re.IGNORECASE)
                            for match in matches:
                                if isinstance(match, tuple):
                                    url = f"https://soundcloud.com/{match[0]}/{match[1]}"
                                else:
                                    url = match
                                
                                # Filtrar URLs válidas (não de usuários, playlists ou páginas especiais)
                                if (url not in track_urls and 
                                    '/sets/' not in url and 
                                    '/likes' not in url and 
                                    '/tracks' not in url and
                                    '/following' not in url and
                                    '/followers' not in url and
                                    url.count('/') >= 4):
                                    track_urls.append(url)
                        
                        # Tentar cada URL encontrada
                        for track_url in track_urls[:3]:  # Limitar a 3 tentativas por busca
                            try:
                                log(f"[Nowfy] Processing SoundCloud track: {track_url}")
                                
                                # Estratégia 2: oEmbed API (mais confiável)
                                oembed_url = f"https://soundcloud.com/oembed?format=json&url={quote(track_url)}"
                                oembed_resp = requests.get(oembed_url, timeout=10, headers=headers)
                                
                                if oembed_resp.status_code == 200:
                                    try:
                                        data = oembed_resp.json()
                                        thumbnail_url = data.get("thumbnail_url")
                                        
                                        if thumbnail_url and 'default_avatar' not in thumbnail_url:
                                            # Múltiplas tentativas de qualidade
                                            quality_variants = [
                                                thumbnail_url.replace('-large.jpg', '-t500x500.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-original.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-crop.jpg'),
                                                thumbnail_url.replace('-large.jpg', '-t300x300.jpg'),
                                                thumbnail_url
                                            ]
                                            
                                            for variant in quality_variants:
                                                try:
                                                    test_resp = requests.head(variant, timeout=5)
                                                    if test_resp.status_code == 200:
                                                        log(f"[Nowfy] SoundCloud cover found via oEmbed: {variant}")
                                                        return variant
                                                except:
                                                    continue
                                    except json.JSONDecodeError:
                                        pass
                                
                                # Estratégia 3: Scraping avançado da página do track
                                track_resp = requests.get(track_url, timeout=12, headers=headers)
                                if track_resp.status_code == 200:
                                    content = track_resp.text
                                    
                                    # Múltiplos padrões para artwork
                                    artwork_patterns = [
                                        r'"artwork_url":"([^"]+)"',
                                        r'<meta property="og:image" content="([^"]+)"',
                                        r'<meta name="twitter:image" content="([^"]+)"',
                                        r'"avatar_url":"([^"]+)"',
                                        r'artwork_url":\s*"([^"]+)"',
                                        r'image":\s*"([^"]+)"',
                                        r'"large":"([^"]+)"'
                                    ]
                                    
                                    for pattern in artwork_patterns:
                                        matches = re.findall(pattern, content, re.IGNORECASE)
                                        for match in matches:
                                            artwork_url = match.replace('\\/', '/')
                                            if (artwork_url and 
                                                'default_avatar' not in artwork_url and
                                                'avatars-000' not in artwork_url and
                                                artwork_url.startswith('http')):
                                                
                                                # Tentar diferentes qualidades
                                                quality_variants = [
                                                    artwork_url.replace('-large.jpg', '-t500x500.jpg'),
                                                    artwork_url.replace('-large.jpg', '-original.jpg'),
                                                    artwork_url.replace('-large.jpg', '-crop.jpg'),
                                                    artwork_url.replace('-large.jpg', '-t300x300.jpg'),
                                                    artwork_url
                                                ]
                                                
                                                for variant in quality_variants:
                                                    try:
                                                        test_resp = requests.head(variant, timeout=5)
                                                        if test_resp.status_code == 200:
                                                            log(f"[Nowfy] SoundCloud cover found via scraping: {variant}")
                                                            return variant
                                                    except:
                                                        continue
                                    
                                    # Estratégia 4: Buscar dados JSON embutidos (hydration data)
                                    json_patterns = [
                                        r'window\.__sc_hydration\s*=\s*(\[.*?\]);',
                                        r'__INITIAL_STATE__\s*=\s*({.*?});',
                                        r'window\.__INITIAL_DATA__\s*=\s*({.*?});'
                                    ]
                                    
                                    for json_pattern in json_patterns:
                                        json_matches = re.findall(json_pattern, content, re.DOTALL)
                                        for json_match in json_matches:
                                            try:
                                                if json_match.startswith('['):
                                                    hydration_data = json.loads(json_match)
                                                    if isinstance(hydration_data, list):
                                                        for item in hydration_data:
                                                            if isinstance(item, dict):
                                                                artwork_url = self._extract_artwork_from_json(item)
                                                                if artwork_url:
                                                                    log(f"[Nowfy] SoundCloud cover found via JSON hydration: {artwork_url}")
                                                                    return artwork_url
                                                else:
                                                    initial_data = json.loads(json_match)
                                                    artwork_url = self._extract_artwork_from_json(initial_data)
                                                    if artwork_url:
                                                        log(f"[Nowfy] SoundCloud cover found via JSON initial data: {artwork_url}")
                                                        return artwork_url
                                            except (json.JSONDecodeError, KeyError):
                                                continue
                                
                            except Exception as e:
                                log(f"[Nowfy] Error processing track URL {track_url}: {e}")
                                continue
                    
                    elif resp.status_code == 429:  # Rate limited
                        log(f"[Nowfy] Rate limited, waiting before retry...")
                        time.sleep(2)
                        continue
                        
                except Exception as e:
                    log(f"[Nowfy] Search query {i+1} failed: {e}")
                    continue
            
            # Estratégia 5: Fallback para API alternativa
            try:
                log(f"[Nowfy] Trying SoundCloud API fallback...")
                api_search_url = f"https://api-v2.soundcloud.com/search?q={quote(search_queries[0])}&client_id=YOUR_CLIENT_ID"
                # Nota: Seria necessário um client_id válido para esta estratégia funcionar completamente
                # Por enquanto, apenas logamos a tentativa
                log(f"[Nowfy] API fallback would use: {api_search_url}")
            except Exception as e:
                log(f"[Nowfy] API fallback failed: {e}")
                
            log(f"[Nowfy] No SoundCloud cover found after all strategies for: {title} by {artist}")
            return None
                
        except Exception as e:
            log(f"[Nowfy] Critical error in SoundCloud cover search: {e}")
            return None

    def _extract_artwork_from_json(self, data):
        """Extrai artwork URL de dados JSON complexos do SoundCloud"""
        try:
            if isinstance(data, dict):
                # Procurar por chaves relacionadas a artwork
                artwork_keys = ['artwork_url', 'avatar_url', 'image', 'thumbnail_url', 'cover_url']
                for key in artwork_keys:
                    if key in data and data[key]:
                        url = data[key]
                        if isinstance(url, str) and url.startswith('http') and 'default_avatar' not in url:
                            # Tentar melhorar qualidade preferindo original, depois t500
                            try:
                                if '-large.jpg' in url:
                                    quality_variants = [
                                        url.replace('-large.jpg', '-original.jpg'),
                                        url.replace('-large.jpg', '-t500x500.jpg'),
                                        url.replace('-large.jpg', '-crop.jpg'),
                                        url.replace('-large.jpg', '-t300x300.jpg'),
                                        url
                                    ]
                                else:
                                    quality_variants = [url]
                                for variant in quality_variants:
                                    try:
                                        test_resp = requests.head(variant, timeout=5)
                                        if test_resp.status_code == 200:
                                            return variant
                                    except Exception:
                                        continue
                            except Exception:
                                pass
                            return url
                
                # Busca recursiva em objetos aninhados
                for value in data.values():
                    if isinstance(value, (dict, list)):
                        result = self._extract_artwork_from_json(value)
                        if result:
                            return result
                            
            elif isinstance(data, list):
                for item in data:
                    result = self._extract_artwork_from_json(item)
                    if result:
                        return result
                        
        except Exception as e:
            log(f"[Nowfy] Error extracting artwork from JSON: {e}")
        
        return None

    def _search_music_artwork(self, artist, title):
        try:
            debug_mode = self.get_setting("artwork_debug", False)
            clean_artist = self._clean_search_term(artist)
            clean_title = self._clean_search_term(title)
            if debug_mode:
                log(f"[Nowfy] Original data - Title: '{title}', Artist: '{artist}'")
                log(f"[Nowfy] Cleaned data - Title: '{clean_title}', Artist: '{clean_artist}'")
            # Reserved:
            player = self._detect_current_player() if hasattr(self, '_detect_current_player') else None
            if player == "SoundCloud":
                # Usar a função específica do SoundCloud primeiro
                soundcloud_cover_url = self.get_soundcloud_cover(clean_title, clean_artist)
                if soundcloud_cover_url and "icondefault.png" not in soundcloud_cover_url:
                    try:
                        resp = requests.get(soundcloud_cover_url, timeout=10)
                        resp.raise_for_status()
                        return Image.open(BytesIO(resp.content)).convert("RGBA")
                    except Exception as e:
                        log(f"[Nowfy] Erro ao carregar capa do SoundCloud: {e}")
                
                # Fallback para YouTube apenas se SoundCloud falhar
                youtube_cover_url = self._get_youtube_cover(clean_title, clean_artist)
                if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                    youtube_cover_url = self._get_youtube_thumbnail_forced(clean_title, clean_artist)
                if youtube_cover_url and "icondefault.png" not in youtube_cover_url:
                    try:
                        resp = requests.get(youtube_cover_url, timeout=10)
                        resp.raise_for_status()
                        return Image.open(BytesIO(resp.content)).convert("RGBA")
                    except Exception:
                        pass
            search_strategies = [
                (clean_title, clean_artist),
                (f"{clean_title} {clean_artist}", ""),
                (clean_title, ""),
                (clean_artist, clean_title),
            ]
            # APIs na ordem do selector
            apis = [
                ("Spotify", self._search_spotify_artwork),
                ("Deezer", self._search_deezer_artwork),
                ("iTunes", self._search_itunes_artwork),
                ("YouTube", lambda a, t: self._get_youtube_cover(t, a)),
                ("LastFM", self._search_lastfm_artwork),
                ("Cover Art Archive", self._search_coverart_archive)
            ]
            priority = self.get_setting("artwork_priority", 0)
            if debug_mode:
                log(f"[Nowfy] Priority API: {apis[priority][0]} (index: {priority})")
            # Tenta a API de prioridade
            priority_api = apis[priority]
            for title_search, artist_search in search_strategies:
                if debug_mode:
                    log(f"[Nowfy] Trying {priority_api[0]} with: '{title_search}' by '{artist_search}'")
                if priority_api[0] == "YouTube":
                    yt_cover_url = priority_api[1](artist_search, title_search)
                    if yt_cover_url and "icondefault.png" not in yt_cover_url:
                        try:
                            yt_resp = requests.get(yt_cover_url, timeout=5)
                            yt_resp.raise_for_status()
                            return Image.open(BytesIO(yt_resp.content)).convert("RGBA")
                        except Exception as e:
                            if debug_mode:
                                log(f"[Nowfy] YouTube artwork failed: {e}")
                else:
                    cover = priority_api[1](artist_search, title_search)
                    if cover:
                        log(f"[Nowfy] Found artwork using {priority_api[0]} with strategy: '{title_search}' by '{artist_search}'")
                        return cover
            # Tenta as demais em ordem
            for i, (api_name, api_func) in enumerate(apis):
                if i != priority:
                    if debug_mode:
                        log(f"[Nowfy] Trying fallback API: {api_name}")
                    for title_search, artist_search in search_strategies:
                        if debug_mode:
                            log(f"[Nowfy] Trying {api_name} with: '{title_search}' by '{artist_search}'")
                        if api_name == "YouTube":
                            yt_cover_url = api_func(artist_search, title_search)
                            if yt_cover_url and "icondefault.png" not in yt_cover_url:
                                try:
                                    yt_resp = requests.get(yt_cover_url, timeout=5)
                                    yt_resp.raise_for_status()
                                    return Image.open(BytesIO(yt_resp.content)).convert("RGBA")
                                except Exception as e:
                                    if debug_mode:
                                        log(f"[Nowfy] YouTube artwork failed: {e}")
                        else:
                            cover = api_func(artist_search, title_search)
                            if cover:
                                log(f"[Nowfy] Found artwork using {api_name} with strategy: '{title_search}' by '{artist_search}'")
                                return cover
            log(f"[Nowfy] No artwork found for any API, using default")
            return self._get_default_artwork()
        except Exception as e:
            log(f"[Nowfy] Error in _search_music_artwork: {e}")
            return self._get_default_artwork()

    def _clean_search_term(self, term):
        """Limpa e normaliza termos de busca preservando colaborações"""
        if not term:
            return ""    
        # Remove caracteres especiais e normaliza
        import re      
        # Remove parênteses e conteúdo dentro deles (remastered, live, etc)
        term = re.sub(r'\([^)]*\)', '', term)       
        # Remove colchetes e conteúdo dentro deles
        term = re.sub(r'\[[^\]]*\]', '', term)       
        # Remove apenas palavras que realmente interferem (NÃO remover feat/ft/featuring)
        common_words = ['remastered', 'remaster', 'live', 'version', 'edit', 'mix']
        for word in common_words:
            term = re.sub(rf'\b{word}\b', '', term, flags=re.IGNORECASE)       
        # Normalizar feat/ft/featuring para formato padrão
        term = re.sub(r'\b(feat\.?|ft\.?|featuring)\b', 'feat', term, flags=re.IGNORECASE)
        # Remove caracteres especiais mas mantém espaços, hífens e pontos
        term = re.sub(r'[^\w\s\-\.]', '', term)       
        # Remove espaços extras
        term = re.sub(r'\s+', ' ', term).strip()       
        # Remove hífens e pontos isolados (mas não os que estão entre palavras)
        term = re.sub(r'\s*[-\.]\s*', ' ', term)       
        # Remove espaços extras novamente
        term = re.sub(r'\s+', ' ', term).strip()
        
        return term

    def _search_spotify_artwork(self, artist, title):
        """Busca capa no Spotify com melhor processamento"""
        try:
            token = self._get_access_token()
            if not token:
                return None               
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} {artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Spotify for: {query}")
            
            response = requests.get(
                f"https://api.spotify.com/v1/search?q={query}&type=track&limit=3",
                headers={"Authorization": f"Bearer {token}"},
                timeout=5
            )
            
            if response.status_code == 200:
                data = response.json()
                items = data.get("tracks", {}).get("items", [])
                
                for item in items:
                    if item.get("album", {}).get("images"):
                        # Pega a imagem de maior resolução
                        images = item["album"]["images"]
                        best_image = max(images, key=lambda x: x.get("width", 0))
                        
                        log(f"[Nowfy] Found Spotify artwork: {best_image['url']}")
                        
                        art_response = requests.get(best_image["url"], timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Spotify artwork: {e}")
        return None

    def _search_deezer_artwork(self, artist, title):
        """Busca capa no Deezer com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} {artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Deezer for: {query}")
            
            response = requests.get(
                "https://api.deezer.com/search",
                params={"q": query, "limit": 3},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("data") and len(data["data"]) > 0:
                for track in data["data"]:
                    if track.get("album", {}).get("cover_xl"):
                        cover_url = track["album"]["cover_xl"]
                        log(f"[Nowfy] Found Deezer artwork: {cover_url}")
                        
                        art_response = requests.get(cover_url, timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Deezer artwork: {e}")
        return None

    def _search_itunes_artwork(self, artist, title):
        """Busca capa no iTunes com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                search_term = f"{artist} {title}"
            elif title:
                search_term = title
            else:
                return None
                
            log(f"[Nowfy] Searching iTunes for: {search_term}")
            
            response = requests.get(
                "https://itunes.apple.com/search",
                params={"term": search_term, "entity": "song", "limit": 3},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data['resultCount'] > 0:
                for result in data['results']:
                    if result.get('artworkUrl100'):
                        artwork_url = result['artworkUrl100'].replace('100x100', '600x600')
                        log(f"[Nowfy] Found iTunes artwork: {artwork_url}")
                        
                        art_response = requests.get(artwork_url, timeout=3)
                        art_response.raise_for_status()
                        return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching iTunes artwork: {e}")
        return None

    def _search_lastfm_artwork(self, artist, title):
        """Busca capa no LastFM com melhor processamento"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None              
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                search_term = f"{title} {artist}"
            elif title:
                search_term = title
            else:
                return None
                
            log(f"[Nowfy] Searching LastFM for: {search_term}")
            
            response = requests.get(
                "http://ws.audioscrobbler.com/2.0/",
                params={
                    "method": "track.search",
                    "track": title,
                    "artist": artist,
                    "api_key": api_key,
                    "format": "json",
                    "limit": 3
                },
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("results", {}).get("trackmatches", {}).get("track"):
                tracks = data["results"]["trackmatches"]["track"]
                for track in tracks:
                    if track.get("image") and len(track["image"]) > 0:
                        # Pega a imagem de maior tamanho (extralarge)
                        for img in track["image"]:
                            if img.get("size") == "extralarge" and img.get("#text"):
                                cover_url = img["#text"]
                                if cover_url and cover_url != "":
                                    log(f"[Nowfy] Found LastFM artwork: {cover_url}")
                                    art_response = requests.get(cover_url, timeout=3)
                                    art_response.raise_for_status()
                                    return Image.open(BytesIO(art_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching LastFM artwork: {e}")
        return None

    def _search_coverart_archive(self, artist, title):
        """Busca capa no Cover Art Archive com melhor processamento"""
        try:
            # Constrói query baseada nos parâmetros disponíveis
            if artist and title:
                query = f"{title} AND artist:{artist}"
            elif title:
                query = title
            else:
                return None
                
            log(f"[Nowfy] Searching Cover Art Archive for: {query}")
            
            # Primeiro busca o release no MusicBrainz
            response = requests.get(
                "https://musicbrainz.org/ws/2/release",
                params={
                    "query": query,
                    "fmt": "json",
                    "limit": 3
                },
                headers={"User-Agent": "Nowfy/1.0"},
                timeout=3
            )
            response.raise_for_status()
            data = response.json()
            
            if data.get("releases") and len(data["releases"]) > 0:
                for release in data["releases"]:
                    release_id = release["id"]
                    # Agora busca a capa no Cover Art Archive (experimental)
                    cover_response = requests.get(
                        f"https://coverartarchive.org/release/{release_id}/front-500",
                        timeout=3
                    )
                    if cover_response.status_code == 200:
                        log(f"[Nowfy] Found Cover Art Archive artwork for release: {release_id}")
                        return Image.open(BytesIO(cover_response.content)).convert("RGBA")
        except Exception as e:
            log(f"[Nowfy] Error fetching Cover Art Archive: {e}")
        return None

    def _get_default_artwork(self):
        """Retorna uma capa padrão quando não consegue encontrar"""
        try:
            # Cria uma capa padrão com gradiente e ícone de música
            size = 600
            img = Image.new("RGBA", (size, size), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)
            
            # Gradiente de fundo
            for y in range(size):
                alpha = int(255 * (1 - y / size))
                color = (40, 40, 40, alpha)
                draw.line([(0, y), (size, y)], fill=color)
            
            # Ícone de música simples
            icon_size = size // 3
            icon_x = (size - icon_size) // 2
            icon_y = (size - icon_size) // 2
            
            # Desenha um ícone de música estilizado
            draw.ellipse([icon_x, icon_y, icon_x + icon_size, icon_y + icon_size], 
                        fill=(100, 100, 100, 180), outline=(150, 150, 150, 255), width=3)
            
            # Notas musicais
            note_size = icon_size // 4
            draw.ellipse([icon_x + icon_size//3, icon_y + icon_size//3, 
                         icon_x + icon_size//3 + note_size, icon_y + icon_size//3 + note_size], 
                        fill=(200, 200, 200, 255))
            
            return img
        except Exception as e:
            log(f"[Nowfy] Error creating default artwork: {e}")
            return Image.new("RGBA", (600, 600), (50, 50, 50, 255))

    def test_artwork_search(self, title, artist):
        """Função para testar o sistema de busca de capas (debug)"""
        try:
            log(f"[Nowfy] Testing artwork search for: '{title}' by '{artist}'")
            result = self._search_music_artwork(artist, title)
            if result:
                log(f"[Nowfy] Artwork found successfully")
                return True
            else:
                log(f"[Nowfy] No artwork found")
                return False
        except Exception as e:
            log(f"[Nowfy] Error testing artwork search: {e}")
            return False

    def _test_lastfm_account(self):
        """Testa se a conta LastFM está funcionando e mostra última música"""
        try:
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Verificar se username está configurado
            lastfm_username = self.get_setting("lastfm_username", "")
            if not lastfm_username:
                lastfm_username = self.get_setting("lastfm_user", "")
            if not lastfm_username:
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("lastfm_test_title"))
                builder.set_message(tr("lastfm_username_not_configured"))
                builder.set_positive_button("OK", None)
                builder.show()
                return
            
            # Mostrar dialog de loading
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("lastfm_testing"))
            builder.set_message(tr("lastfm_checking_account").format(username=lastfm_username))
            builder.set_positive_button(tr("cancel"), None)
            dialog = builder.show()
            
            # Executar teste em background
            def run_test():
                try:
                    # Buscar informações do usuário
                    user_info = self._get_lastfm_user_info(lastfm_username)
                    if not user_info:
                        run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, tr("lastfm_api_connection_error")))
                        return
                    
                    # Buscar última música ouvida
                    recent_tracks = self._get_lastfm_recent_tracks(lastfm_username, 1)
                    if not recent_tracks:
                        run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, tr("lastfm_recent_tracks_error")))
                        return
                    
                    # Buscar música atual (se estiver tocando)
                    current_track = self._get_lastfm_now_playing(lastfm_username)
                    
                    run_on_ui_thread(lambda: self._show_lastfm_test_result(True, lastfm_username, None, user_info, recent_tracks, current_track))
                    
                except Exception as e:
                    log(f"[Nowfy] LastFM test error: {e}")
                    run_on_ui_thread(lambda: self._show_lastfm_test_result(False, lastfm_username, str(e)))
                finally:
                    run_on_ui_thread(lambda: dialog.dismiss())
            
            import threading
            test_thread = threading.Thread(target=run_test)
            test_thread.start()
            
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM test: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error: {str(e)}")

    def _get_lastfm_user_info(self, username):
        """Busca informações do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getinfo&user={username}&api_key={api_key}&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'user' in data:
                    return data['user']
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM user info: {e}")
            return None

    def _get_lastfm_recent_tracks(self, username, limit=1):
        """Busca músicas recentes do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user={username}&api_key={api_key}&limit={limit}&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'recenttracks' in data and 'track' in data['recenttracks']:
                    return data['recenttracks']['track']
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM recent tracks: {e}")
            return None

    def _get_lastfm_now_playing(self, username):
        """Busca música atual do usuário LastFM"""
        try:
            api_key = self.get_setting("lastfm_api_key", "")
            if not api_key:
                return None
            
            url = f"http://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user={username}&api_key={api_key}&limit=1&format=json"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                if 'recenttracks' in data and 'track' in data['recenttracks']:
                    tracks = data['recenttracks']['track']
                    if tracks and len(tracks) > 0:
                        track = tracks[0] if isinstance(tracks, list) else tracks
                        # Verificar se está tocando agora
                        if '@attr' in track and 'nowplaying' in track['@attr']:
                            return track
            return None
        except Exception as e:
            log(f"[Nowfy] Error getting LastFM now playing: {e}")
            return None

    def _show_lastfm_test_result(self, success, username, error=None, user_info=None, recent_tracks=None, current_track=None):
        """Mostra resultado do teste LastFM"""
        try:
            from ui.alert import AlertDialogBuilder
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(ctx)
            builder.set_title(tr("lastfm_test_result"))
            
            if success:
                # Informações do usuário
                user_name = user_info.get('name', username) if user_info else username
                play_count = user_info.get('playcount', '0') if user_info else '0'
                
                message = tr("lastfm_account_working").format(username=user_name, playcount=play_count)
                
                # Música atual ou última ouvida
                if current_track:
                    track_name = current_track.get('name', 'Unknown')
                    artist_name = current_track.get('artist', {}).get('#text', 'Unknown') if isinstance(current_track.get('artist'), dict) else current_track.get('artist', 'Unknown')
                    
                    message += "\n\n" + tr("lastfm_now_playing").format(track=track_name, artist=artist_name)
                elif recent_tracks:
                    track = recent_tracks[0] if isinstance(recent_tracks, list) else recent_tracks
                    track_name = track.get('name', 'Unknown')
                    artist_name = track.get('artist', {}).get('#text', 'Unknown') if isinstance(track.get('artist'), dict) else track.get('artist', 'Unknown')
                    
                    message += "\n\n" + tr("lastfm_last_played").format(track=track_name, artist=artist_name)
            else:
                error_msg = f"\n{tr('error')}: {error}" if error else ""
                message = tr("lastfm_test_failed").format(username=username, error=error_msg)
            
            builder.set_message(message)
            builder.set_positive_button("OK", None)
            builder.show()
            
        except Exception as e:
            log(f"[Nowfy] Error showing LastFM test result: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error showing result: {str(e)}")

    # Atualizar lógica de caption e quebra de linha nos temas Default e CustomFM
    def _lastfm_multiline_title(self, draw, text, font, max_width):
        words = text.split()
        lines, current_line = [], ""
        for word in words:
            test_line = current_line + " " + word if current_line else word
            if draw.textbbox((0, 0), test_line, font=font)[2] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)
        return lines

    def _get_icondefault_cached(self, mini_cover_size=300):
        """Baixa e cacheia localmente o icondefault.png, retornando o objeto Image."""
        import os
        from PIL import Image, ImageDraw
        from io import BytesIO
        cache_dir = os.path.join(str(ApplicationLoader.getFilesDirFixed()), "nowfy_cache")
        if not os.path.exists(cache_dir):
            os.makedirs(cache_dir)
        cache_path = os.path.join(cache_dir, f"icondefault_{mini_cover_size}.png")
        # Se já existe no cache, carrega
        if os.path.exists(cache_path):
            try:
                return Image.open(cache_path).convert("RGBA")
            except Exception:
                pass
        # Se não existe, baixa e salva
        try:
            img_resp = requests.get("https://i.postimg.cc/4yjVLFTV/icondefault.png", stream=True, timeout=3)
            img_resp.raise_for_status()
            img = Image.open(BytesIO(img_resp.content)).convert("RGBA")
            img = img.resize((mini_cover_size, mini_cover_size), Image.LANCZOS)
            img.save(cache_path)
            return img
        except Exception:
            # Se tudo falhar, cria uma imagem com gradiente ao invés de cor sólida escura
            img = Image.new("RGBA", (mini_cover_size, mini_cover_size), color=(60, 60, 60, 255))
            draw = ImageDraw.Draw(img)
            # Adiciona um gradiente simples
            for i in range(mini_cover_size):
                alpha = int(255 * (1 - i / mini_cover_size) * 0.3)
                color = (80 + i // 4, 80 + i // 4, 80 + i // 4, alpha)
                draw.line([(0, i), (mini_cover_size, i)], fill=color)
            return img

    NO_TRACK_PLAYING = {
        "en": "No track playing on %s",
        "pt": "Nenhuma faixa tocando no %s",
        "es": "Ninguna pista se está reproduciendo en %s",
        "fr": "Aucune piste en cours de lecture sur %s",
        "ru": "Нет воспроизводимой дорожки в %s",
    }

    def _show_no_track_playing_bulletin(self):
        lang = Locale.getDefault().getLanguage()
        player = self._detect_current_player()
        msg = self.NO_TRACK_PLAYING.get(lang, self.NO_TRACK_PLAYING["en"]) % player
        BulletinHelper.show_info(msg)

    def _show_no_spotify_track_bulletin(self):
        """Bulletin específico para quando não há música tocando no Spotify"""
        lang = Locale.getDefault().getLanguage()
        spotify_messages = {
            "pt": "Nenhuma música tocando no Spotify",
            "en": "No track playing on Spotify",
            "es": "Ninguna música reproduciéndose en Spotify",
            "fr": "Aucune musique en cours de lecture sur Spotify",
            "ru": "Нет воспроизводимой музыки в Spotify"
        }
        msg = spotify_messages.get(lang, spotify_messages["en"])
        BulletinHelper.show_info(msg)

    def _build_lastfm_caption(self, player_name, artist, title):
        custom_caption = self.get_setting("custom_footer_text", "")
        caption_parts = []
        
        # Adiciona o custom_caption se existir
        if custom_caption:
            # Processar variáveis {track}, {artist} e {album} no custom caption
            processed_caption = custom_caption.strip()
            if "{track}" in processed_caption or "{artist}" in processed_caption or "{album}" in processed_caption:
                processed_caption = processed_caption.replace("{track}", title or "Unknown Track")
                processed_caption = processed_caption.replace("{artist}", artist or "Unknown Artist")
                processed_caption = processed_caption.replace("{album}", "Unknown Album")  # Last.fm não fornece álbum
            caption_parts.append(processed_caption)
            
        # Adiciona os links dos players
        if player_name == "YouTube":
            search_query = f"{artist} {title} official music video"
            song_link = f"https://www.youtube.com/results?search_query={quote(search_query)}"
            caption_parts.append(f"[YouTube]({song_link})")
        elif player_name == "YouTube Music":
            search_query = f"{artist} {title}"
            song_link = f"https://music.youtube.com/search?q={quote(search_query)}"
            caption_parts.append(f"[YouTube Music]({song_link})")
        elif player_name == "Spotify":
            song_link = f"https://open.spotify.com/search/{artist.replace(' ', '+')}%20{title.replace(' ', '+')}"
            caption_parts.append(f"[Spotify]({song_link})")
        elif player_name == "Apple Music":
            search_query = f"{artist} {title}"
            song_link = f"https://music.apple.com/search?term={quote(search_query)}"
            caption_parts.append(f"[Apple Music]({song_link})")
        # Suporte para outros players
        caption = " • ".join(caption_parts)
        
        # Processar emojis premium (sempre habilitado)
        if caption:
            caption = self._process_premium_emojis(caption)
        
        return caption

    def _process_premium_emojis(self, caption):
        """Processa emojis premium no caption usando a sintaxe [alt text](document_id)"""
        try:
            import re
            from markdown_parser import parse_markdown
          
            # Padrão para detectar emojis premium: [emoji](document_id)
            # Onde document_id é um número longo
            premium_emoji_pattern = r'\[([^\]]+)\]\((\d{10,})\)'
            
            def replace_premium_emoji(match):
                alt_text = match.group(1)
                document_id = match.group(2)
                
                # Retorna a sintaxe de emoji customizado do Telegram
                # Formato: <emoji id="document_id">alt_text</emoji>
                return f'<emoji id="{document_id}">{alt_text}</emoji>'         
            # Substituir todos os emojis premium encontrados
            processed_caption = re.sub(premium_emoji_pattern, replace_premium_emoji, caption)
            
            return processed_caption
            
        except Exception as e:
            log(f"[Nowfy] Erro ao processar emojis premium: {e}")
            # Em caso de erro, retorna o caption original
            return caption

    def get_current_track_etg_only(self, account, params, progress_dialog=None):
        try:
            log(f"[Nowfy] Starting etg-only track fetch...")
            
            # Detectar música do TG
            from org.telegram.messenger import MediaController
            media_controller = MediaController.getInstance()
            playing_song = media_controller.getPlayingMessageObject()
            
            log(f"[Nowfy] Playing song object: {playing_song}")
            
            etg_track = self.get_current_track_etg(account)
            log(f"[Nowfy] etg track data: {etg_track}")
            
            if not etg_track:
                log(f"[Nowfy] No etg track found")
                BulletinHelper.show_info(tr("no_track_playing_generic"))
                return
            
            title = etg_track["title"]
            artist = etg_track["artist"]
            album = etg_track.get("album", "")
            
            log(f"[Nowfy] Using etg track - Title: '{title}', Artist: '{artist}'")
            
            # Buscar capa do Telegram
            etg_cover_image = self.get_etg_cover(playing_song)
            log(f"[Nowfy] etg cover search result: {'Found' if etg_cover_image else 'Not found'}")
            
            # Detectar player (sempre será exteragram/Ayugram)
            player = self.detect_etg_player()
            
            # Atualizar a bio se habilitado
            if self.get_setting("enable_autobio", False):
                autobio_text = self.get_setting("autobio_text", "Now Playing: {track} by {artist}")
                bio = autobio_text.format(track=title, artist=artist)
                run_on_ui_thread(lambda: self._update_bio(bio, show_bulletin=False))
                # Mostrar notificação se habilitada
                if self.get_setting("show_bio_notification", True):
                    if self.get_setting("enable_auto_bio_update", True):
                        BulletinHelper.show_info(tr("bio_updated_short"))
                    else:
                        BulletinHelper.show_info(tr("bio_notification_disabled"))
            
            # Usar o tema configurado
            theme = self.get_setting("theme_selector", 0)
            
            if theme == 3:  # Default (LastFM)
                log(f"[Nowfy] Using Default theme for Telegram")
                return self._get_current_track_lastfm_default(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
            elif theme == 4:  # CustomFM
                log(f"[Nowfy] Using CustomFM theme for Telegram")
                return self._get_current_track_lastfm_customfm(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
            else:  # Usar Default como fallback
                log(f"[Nowfy] Using Default theme as fallback for Telegram")
                return self._get_current_track_lastfm_default(title, artist, album, "", params, progress_dialog, player, None, etg_cover_image)
                
        except Exception as e:
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Telegram error: {str(e)}")

    def detect_etg_player(self):
        # Detecta qual cliente do Telegram está sendo usado"""
        try:
            # Verificar se é exteraGram ou AyuGram baseado no package name
            from org.telegram.messenger import ApplicationLoader
            package_name = ApplicationLoader.applicationContext.getPackageName()
            
            if "exteragram" in package_name.lower():
                return "exteraGram"
            elif "ayugram" in package_name.lower():
                return "AyuGram"
            else:
                return "Telegram"
        except Exception as e:
            log(f"[Nowfy] Error detecting Telegram player: {e}")
            return "Telegram"

    def _show_help(self, params):
        # Mostra a mensagem de ajuda com todos os comandos disponíveis"""
        try:
            def show_dialog():
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx)
                builder.set_title(tr("help_title"))
                builder.set_message(tr("help_message"))
                builder.set_positive_button("OK", None)
                builder.show()
            run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing help: {e}")
            BulletinHelper.show_info(tr("error_generic").format(error=str(e)) if "error_generic" in TRANSLATIONS else f"Error showing help: {str(e)}")

    def _show_guide_dialog(self):
        try:
            def show_dialog():
                fragment = get_last_fragment()
                from ui.alert import AlertDialogBuilder
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else ApplicationLoader.applicationContext
                builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                builder.set_title(tr("guide_title"))
                builder.set_message(tr("guide_message"))
                builder.set_positive_button(
                    tr("guide_open_link"),
                    lambda b, w: self._open_url(
                        "https://github.com/soumaki/nowFy/blob/main/guide/nowfy.md#spotify-plugin--step-by-step-login-guide"
                    )
                )
                builder.set_negative_button("OK", None)
                builder.show()
            run_on_ui_thread(show_dialog)
        except Exception as e:
            log(f"[Nowfy] Error showing guide dialog: {e}")

    def _get_fallback_cover(self, title, artists):
        """Obtém uma capa de fallback obrigatória (YouTube thumbnail ou icondefault)"""
        try:
            log(f"[Nowfy] Getting fallback cover for: {title} - {artists}")
            target_size = (298, 298)
            
            # Primeiro, tentar obter thumbnail do YouTube
            youtube_cover_url = self._get_youtube_cover(title, artists)
            # Forçar uso de thumbnails mesmo se a API falhar
            if youtube_cover_url == "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                youtube_cover_url = self._get_youtube_thumbnail_forced(title, artists)
            if youtube_cover_url and youtube_cover_url != "https://i.postimg.cc/4yjVLFTV/icondefault.png":
                try:
                    resp = requests.get(youtube_cover_url, timeout=10)
                    if resp.status_code == 200:
                        cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                        # Aplicar anti-aliasing avançado do Apple UI
                        cover = self._apply_apple_antialiasing(cover, target_size)
                        log(f"[Nowfy] Successfully loaded YouTube fallback cover")
                        return cover
                except Exception as e:
                    log(f"[Nowfy] Error loading YouTube fallback cover: {e}")
            
            # Se YouTube falhar, usar icondefault
            try:
                icondefault_url = "https://i.postimg.cc/4yjVLFTV/icondefault.png"
                resp = requests.get(icondefault_url, timeout=10)
                if resp.status_code == 200:
                    cover = Image.open(BytesIO(resp.content)).convert("RGBA")
                    # Aplicar anti-aliasing avançado do Apple UI
                    cover = self._apply_apple_antialiasing(cover, target_size)
                    log(f"[Nowfy] Successfully loaded icondefault cover")
                    return cover
            except Exception as e:
                log(f"[Nowfy] Error loading icondefault cover: {e}")
            
            return None
        except Exception as e:
            log(f"[Nowfy] Error in _get_fallback_cover: {e}")
            return None

    # ==================== SISTEMA DE BACKUP E RESTAURAÇÃO ====================
    
    def _export_backup(self, params):
        """Exporta as configurações do plugin para um arquivo JSON"""
        try:
            backup_manager = BackupManager(self)
            backup_manager.export_backup()
        except Exception as e:
            log(f"[Nowfy] Error exporting backup: {e}")
            BulletinHelper.show_info(f"{tr('backup_export_error')}: {str(e)}")
    
    def _import_backup(self, params):
        """Importa configurações de um arquivo de backup"""
        try:
            log(f"[Nowfy] _import_backup called - starting backup import process")
            backup_manager = BackupManager(self)
            backup_manager.import_backup()
            log(f"[Nowfy] _import_backup completed successfully")
        except Exception as e:
            log(f"[Nowfy] Error importing backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def _import_backup_with_progress(self, progress_dialog, params):
        """Importa configurações com AlertDialog de progresso de 0 a 100%"""
        try:
            log(f"[Nowfy] Starting import process with progress")
            
            # Etapa 1: Verificar diretório de backup (10%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(10))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_checking_directory")))
            time.sleep(0.5)
            
            backup_manager = BackupManager(self)
            if not os.path.exists(backup_manager.backup_dir):
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_directory_not_found"))
                return
            
            # Etapa 2: Listar arquivos de backup (20%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(20))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_listing_files")))
            time.sleep(0.6)
            
            backup_files = self._get_backup_files(backup_manager.backup_dir)
            if not backup_files:
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_no_files_available"))
                return
            
            log(f"[Nowfy] Found {len(backup_files)} backup files")
            
            # Etapa 3: Selecionar backup mais recente (30%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(30))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_selecting_recent")))
            time.sleep(0.4)
            
            latest_backup = backup_files[0]  # Assumindo que está ordenado
            backup_path = os.path.join(backup_manager.backup_dir, latest_backup)
            
            # Etapa 4: Ler arquivo de backup (40%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(40))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_reading_file")))
            time.sleep(0.7)
            
            backup_data = self._read_backup_file(backup_path)
            if not backup_data:
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_read_error"))
                return
            
            # Etapa 5: Validar estrutura do backup (50%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(50))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_validating_structure")))
            time.sleep(0.5)
            
            if not backup_manager.validate_backup_data(backup_data):
                run_on_ui_thread(lambda: progress_dialog.dismiss())
                BulletinHelper.show_info(tr("backup_invalid_structure"))
                return
            
            # Etapa 6: Preparar aplicação das configurações (60%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(60))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_preparing_import")))
            time.sleep(0.5)
            
            # Etapa 7: Aplicar configurações do backup (70%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(70))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_applying_settings")))
            time.sleep(0.9)
            
            applied_count = self._apply_backup_settings_with_progress(backup_data, progress_dialog)
            
            # Etapa 8: Verificar configurações aplicadas (85%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(85))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_verifying_settings")))
            time.sleep(0.6)
            
            self._verify_applied_settings(backup_data)
            
            # Etapa 9: Limpar cache e arquivos temporários (95%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(95))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_cleaning_cache")))
            time.sleep(0.4)
            
            self._cleanup_temp_files()
            
            # Etapa 10: Concluído (100%)
            run_on_ui_thread(lambda: progress_dialog.set_progress(100))
            run_on_ui_thread(lambda: progress_dialog.set_message(tr("backup_import_completed")))
            time.sleep(0.5)
            
            # Fechar dialog
            run_on_ui_thread(lambda: progress_dialog.dismiss())
            
            # Mostrar resultado
            BulletinHelper.show_info(tr("backup_imported_success"))
            
            log(f"[Nowfy] Import completed successfully: {applied_count} settings applied")
            
        except Exception as e:
            log(f"[Nowfy] Error in import process: {e}")
            run_on_ui_thread(lambda: progress_dialog.dismiss())
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def _get_backup_files(self, backup_dir):
        """Lista e ordena arquivos de backup por data de modificação"""
        try:
            files = [f for f in os.listdir(backup_dir) if f.endswith('.json')]
            files.sort(key=lambda x: os.path.getmtime(os.path.join(backup_dir, x)), reverse=True)
            return files
        except Exception as e:
            log(f"[Nowfy] Error listing backup files: {e}")
            return []
    
    def _read_backup_file(self, backup_path):
        """Lê e decodifica arquivo de backup JSON"""
        try:
            with open(backup_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            log(f"[Nowfy] Error reading backup file {backup_path}: {e}")
            return None
    
    
    def _apply_backup_settings_with_progress(self, backup_data, progress_dialog):
        """Aplica configurações do backup com atualização de progresso"""
        try:
            settings = backup_data.get('settings', {})
            applied_count = 0
            total_settings = len(settings)
            
            for i, (key, value) in enumerate(settings.items()):
                try:
                    self.set_setting(key, value)
                    applied_count += 1
                    
                    # Atualizar progresso entre 70% e 80%
                    progress = 70 + int((i + 1) / total_settings * 10)
                    run_on_ui_thread(lambda p=progress: progress_dialog.set_progress(p))
                    
                    if i % 5 == 0:  # Atualizar mensagem a cada 5 configurações
                        run_on_ui_thread(lambda: progress_dialog.set_message(f"Aplicando configurações... ({applied_count}/{total_settings})"))
                    
                except Exception as e:
                    log(f"[Nowfy] Error applying setting {key}: {e}")
            
            return applied_count
        except Exception as e:
            log(f"[Nowfy] Error applying backup settings: {e}")
            return 0
    
    def _verify_applied_settings(self, backup_data):
        """Verifica se as configurações foram aplicadas corretamente"""
        try:
            settings = backup_data.get('settings', {})
            verified_count = 0
            
            for key, expected_value in settings.items():
                try:
                    current_value = self.get_setting(key)
                    if current_value == expected_value:
                        verified_count += 1
                except Exception as e:
                    log(f"[Nowfy] Error verifying setting {key}: {e}")
            
            log(f"[Nowfy] Verified {verified_count}/{len(settings)} settings")
        except Exception as e:
            log(f"[Nowfy] Error verifying settings: {e}")
    
    def _cleanup_temp_files(self):
        """Limpa arquivos temporários e cache"""
        try:
            # Simular limpeza de cache
            log(f"[Nowfy] Cleanup completed")
        except Exception as e:
            log(f"[Nowfy] Error during cleanup: {e}")
     
    def exteraBarSeek_dark_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Dark, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (#313a41)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(49, 58, 65, 255)  # #313a41
        )
        # Barra de progresso (#8e959d)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(142, 149, 157, 255)  # #8e959d
        )
        # Handle (círculo #8e959d)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(142, 149, 157, 255)  # #8e959d
        )
        # Tempos (#8e959d)
        # Nota: Esta função só é chamada quando não é Last.FM com Spotify
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            # Usar textbbox em vez de getsize (depreciado)
            bbox = draw.textbbox((0, 0), "Ay", font=font)
            text_height = bbox[3] - bbox[1]
            text_y = bar_y + bar_height // 2 - text_height // 2
            
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(142, 149, 157, 255))  # #8e959d
            
            # Calcular largura do texto do tempo total
            time_total_bbox = draw.textbbox((0, 0), time_total, font=font)
            time_total_width = time_total_bbox[2] - time_total_bbox[0]
            draw.text((bar_x + bar_width - time_total_width, text_y - 28), time_total, font=font, fill=(142, 149, 157, 255))  # #8e959d

    def exteraBarSeek_light_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Light, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (cinza claro)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(180, 180, 180, 255)
        )
        # Barra de progresso (preto)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(40, 40, 40, 255)
        )
        # Handle (círculo preto)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(40, 40, 40, 255)
        )
        # Tempos (preto)
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            text_y = bar_y + bar_height // 2 - self.get_text_dimensions("Ay", font)[1] // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(40, 40, 40, 255))
            draw.text((bar_x + bar_width - self.get_text_dimensions(time_total, font)[0], text_y - 28), time_total, font=font, fill=(40, 40, 40, 255))

    def exteraBarSeek_red_opposite(self, draw, track, progress_ms=None):
        # --- Barra de progresso estilo seekbar no topo da capa (Apple Red, oposta e ajustada) ---
        bar_width = 260
        bar_height = 5
        bar_x = 70 + (298 - bar_width) // 2
        bar_y = 153 - 30
        duration_ms = track.get("duration_ms", 225000)
        if progress_ms is None:
            progress_ms = 0
        if duration_ms <= 0:
            progress_width = 0
        else:
            progress_width = int((progress_ms / duration_ms) * bar_width)
            progress_width = min(progress_width, bar_width)
        # Barra de fundo (#bf0a0a)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + bar_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(191, 10, 10, 255)  # #bf0a0a
        )
        # Barra de progresso (#ffcfd6)
        draw.rounded_rectangle(
            (bar_x, bar_y, bar_x + progress_width, bar_y + bar_height),
            radius=bar_height // 2,
            fill=(255, 207, 214, 255)  # #ffcfd6
        )
        # Handle (círculo #ffcfd6)
        handle_radius = 10
        handle_x = bar_x + progress_width
        handle_y = bar_y + bar_height // 2
        draw.ellipse(
            (handle_x - handle_radius, handle_y - handle_radius, handle_x + handle_radius, handle_y + handle_radius),
            fill=(255, 207, 214, 255)  # #ffcfd6
        )
        # Tempos (#ffcfd6)
        if True:  # Sempre mostrar tempos quando a barra é exibida
            def ms_to_minsec(ms):
                m = int(ms // 60000)
                s = int((ms % 60000) // 1000)
                return f"{m}:{s:02d}"
            font = ImageFont.truetype("/system/fonts/SourceSansPro-Regular.ttf", 24)
            time_current = ms_to_minsec(progress_ms)
            time_total = ms_to_minsec(duration_ms)
            text_y = bar_y + bar_height // 2 - self.get_text_dimensions("Ay", font)[1] // 2
            draw.text((bar_x, text_y - 28), time_current, font=font, fill=(255, 207, 214, 255))  # #ffcfd6
            draw.text((bar_x + bar_width - self.get_text_dimensions(time_total, font)[0], text_y - 28), time_total, font=font, fill=(255, 207, 214, 255))  # #ffcfd6

    def _list_backups(self, params):
        """Lista todos os backups disponíveis"""
        try:
            backup_manager = BackupManager(self)
            backup_manager.list_backups()
        except Exception as e:
            log(f"[Nowfy] Error listing backups: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")


class BackupManager:
    """Gerenciador de backup e restauração de configurações do Nowfy"""
    
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.backup_dir = "/storage/emulated/0/Android/media/com.exteragram.messenger/nowfy_backups"
        self.ensure_backup_directory()
    
    def ensure_backup_directory(self):
        """Garante que o diretório de backup existe"""
        try:
            import os
            if not os.path.exists(self.backup_dir):
                os.makedirs(self.backup_dir)
                log(f"[Nowfy] Created backup directory: {self.backup_dir}")
        except Exception as e:
            log(f"[Nowfy] Error creating backup directory: {e}")
    
    def get_timestamp(self):
        """Retorna timestamp formatado para nome do arquivo"""
        import datetime
        return datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def export_backup(self):
        """Exporta todas as configurações para um arquivo JSON"""
        try:
            import json
            import os
            
            # Garantir que o diretório existe
            self.ensure_backup_directory()
            
            # Coletar todas as configurações
            collected_settings = self.collect_all_settings()
            log(f"[Nowfy] Export: Collected {len(collected_settings)} settings: {list(collected_settings.keys())}")
            
            if not collected_settings:
                log(f"[Nowfy] Warning: No settings collected for backup")
                BulletinHelper.show_info(tr('backup_no_files_found'))
                return
            
            backup_data = {
                "version": "1.0.5",
                "timestamp": self.get_timestamp(),
                "plugin_name": "nowfy",
                "settings": collected_settings,
                "total_settings": len(collected_settings)
            }
            
            # Gerar nome do arquivo com timestamp
            filename = f"nowfy_backup_{self.get_timestamp()}.json"
            filepath = os.path.join(self.backup_dir, filename)
            
            # Salvar arquivo
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, indent=2, ensure_ascii=False)
            
            # Verificar se o arquivo foi criado corretamente
            if os.path.exists(filepath):
                file_size = os.path.getsize(filepath)
                log(f"[Nowfy] Backup exported successfully: {filepath} ({file_size} bytes)")
                BulletinHelper.show_info(f"{tr('backup_export_success')} ({len(collected_settings)} {tr('backup_settings_count').lower()})")
            else:
                log(f"[Nowfy] Error: Backup file was not created")
                BulletinHelper.show_info(tr('backup_file_not_found'))
            
        except Exception as e:
            log(f"[Nowfy] Error exporting backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_export_error')}: {str(e)}")
    
    def collect_all_settings(self):
        """Coleta todas as configurações do plugin que possuem inputs do usuário"""
        settings = {}
        
        # Lista de configurações que possuem inputs do usuário (não valores padrão)
        setting_keys = [
            # Credenciais Spotify
            "client_id", "client_secret", "refresh_token",
            
            # Credenciais NowCast
            "nowcast_bot_token", "nowcast_channel_id", "nowcast_enabled",
            "nowcast_link_option", "nowcast_post_interval",
            
            # APIs externas
            "lastfm_user", "lastfm_api_key", "statsfm_username",
            "youtube_api_key", "exteragram_username",
            
            # Configurações de Bio personalizadas
            "autobio_text", "restore_bio_text", "custom_footer_text",
            "bot_caption_text", "original_bio",
            
            # Configurações de tema e aparência personalizadas
            "theme_selector", "font_selector", "custom_command",
            "lastfm_customfm_background_color", "lastfm_customfm_text_color",
            "lastfm_customfm_overlay_url", "customfm_icon_color",
            
            # Configurações de comportamento personalizadas
            "media_source", "current_player", "performance_mode",
            "fm_link_option", "artwork_priority", "lastfm_theme_style",
            "lastfm_customfm_cover_position", "lastfm_customfm_radius",
            
            # Configurações de switches importantes
            "enable_autobio", "enable_auto_bio_update", "show_bio_notification",
            "enable_cache", "enable_compression", "enhanced_cache", "enable_preload",
            "show_credentials", "show_cache_settings", "show_smart_bio_panel",
            "show_diversos", "random_theme_mode", "show_caption", "enable_aurasend_on_send",
            "platform_links", "show_track_link", "enable_premium_emoji",
            "lastfm_customfm_use_background", "lastfm_customfm_blur",
            "lastfm_customfm_darken_background", "lastfm_customfm_use_overlay",
            "lastfm_customfm_bold_text", "show_extera_bar", "vinify_show_device",
            "enable_soundcloud_thumbnail_cache", "enable_quality_fallback",
            "enable_url_cache", "enable_youtube_thumbnail_cache",
            "artwork_debug",
            "lastfm_username",
            "theme_mode", "spotlight_skin",
            "statsfm_device_type",
            "use_song_link", "show_spotify_link",
            "vinify_background_effect", "vinify_swap_layout",
            "vinify_device_profile_mode", "vinify_device_name",
            "vinify_bar_color", "vinify_bar_bg_color",
            "vinify_bar_gradient", "vinify_bar_blur",
            "vinify_album_playlist_mode",
            "dynamic_skins_selector",
            "customfm_high_resolution",
            "fm_custom_icon_url", "fm_custom_player_name",
            "visual_avancado_gradiente_enable",
            "visual_avancado_gradiente_modo",
            "visual_avancado_gradiente_style",
            "visual_avancado_gradiente_direction",
            "visual_avancado_gradiente_intensity",
            "visual_avancado_color_extraction",
            "visual_avancado_gradiente_cor1",
            "visual_avancado_gradiente_cor2",
            "apple_skin",
            "apple_antialiasing_quality",
            "apple_resize_algorithm",
            "apple_cover_quality",
            "apple_enhanced_smoothing",
            "apple_edge_enhancement",
            "apple_color_enhancement",
            "apple_cache_processed_covers",
            "apple_async_processing"
        ]
        
        for key in setting_keys:
            try:
                value = self.plugin.get_setting(key, None)
                log(f"[Nowfy] DEBUG: {key} = {value} (type: {type(value)})")
                if value is not None:
                    settings[key] = value
                    log(f"[Nowfy] SAVED: {key} = {value}")
                else:
                    log(f"[Nowfy] SKIPPED: {key} (value is None)")
            except Exception as e:
                log(f"[Nowfy] Error collecting setting {key}: {e}")
        
        return settings
    
    def import_backup(self):
        """Mostra seletor de arquivos de backup para importação"""
        try:
            import os
            
            log(f"[Nowfy] Starting import_backup process")
            log(f"[Nowfy] Backup directory: {self.backup_dir}")
            
            # Listar arquivos de backup disponíveis
            backup_files = []
            if os.path.exists(self.backup_dir):
                all_files = os.listdir(self.backup_dir)
                log(f"[Nowfy] Found {len(all_files)} files in backup directory")
                
                for file in all_files:
                    if file.endswith('.json') and file.startswith('nowfy_backup_'):
                        backup_files.append(file)
                        log(f"[Nowfy] Found backup file: {file}")
            else:
                log(f"[Nowfy] Backup directory does not exist: {self.backup_dir}")
                BulletinHelper.show_info(f"{tr('backup_directory_not_found')}: {self.backup_dir}")
                return
            
            log(f"[Nowfy] Total backup files found: {len(backup_files)}")
            
            if not backup_files:
                log(f"[Nowfy] No backup files found, showing info message")
                BulletinHelper.show_info(f"{tr('backup_no_files_found')}")
                return
            
            # Ordenar por data (mais recente primeiro)
            backup_files.sort(reverse=True)
            log(f"[Nowfy] Backup files sorted: {backup_files}")
            
            # Mostrar seletor de arquivos se houver múltiplos backups
            if len(backup_files) == 1:
                log(f"[Nowfy] Only one backup found, using: {backup_files[0]}")
                BulletinHelper.show_info(f"{tr('backup_using_recent')}: {backup_files[0]}")
                self.restore_from_backup(backup_files[0])
            else:
                log(f"[Nowfy] Multiple backups found, showing selector")
                self.show_backup_selector(backup_files)
            
        except Exception as e:
            log(f"[Nowfy] Error in import_backup: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_import_error')}: {str(e)}")
    
    def show_backup_selector(self, backup_files):
        """Mostra dialog para seleção de arquivo de backup"""
        try:
            log(f"[Nowfy] show_backup_selector called with {len(backup_files)} files")
            
            fragment = get_last_fragment()
            if not fragment:
                log(f"[Nowfy] Fragment not found in show_backup_selector")
                BulletinHelper.show_info(f"{tr('error_fragment_not_found')}")
                return
            
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            log(f"[Nowfy] Context obtained: {ctx}")
            
            # Criar lista de opções formatadas
            options = []
            for file in backup_files:
                # Extrair timestamp do nome do arquivo
                try:
                    timestamp_part = file.replace('nowfy_backup_', '').replace('.json', '')
                    # Formatar timestamp para exibição
                    if len(timestamp_part) >= 13:
                        date_part = timestamp_part[:8]
                        time_part = timestamp_part[9:15] if len(timestamp_part) > 8 else timestamp_part[8:14]
                        formatted_date = f"{date_part[:4]}/{date_part[4:6]}/{date_part[6:8]}"
                        formatted_time = f"{time_part[:2]}:{time_part[2:4]}:{time_part[4:6]}"
                        display_name = f"{formatted_date} {formatted_time}"
                    else:
                        display_name = file
                except:
                    display_name = file
                
                options.append(display_name)
            
            def on_backup_selected(index):
                log(f"[Nowfy] Backup selected at index: {index}")
                if 0 <= index < len(backup_files):
                    selected_file = backup_files[index]
                    log(f"[Nowfy] Selected backup file: {selected_file}")
                    self.restore_from_backup(selected_file)
                else:
                    log(f"[Nowfy] Invalid backup index: {index}")
            
            log(f"[Nowfy] About to show backup list dialog with {len(options)} options")
            # Mostrar AlertDialog com lista de backups
            run_on_ui_thread(lambda: self.show_backup_list_dialog(ctx, options, on_backup_selected))
            
        except Exception as e:
            log(f"[Nowfy] Error showing backup selector: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def show_backup_list_dialog(self, context, options, callback):
        """Mostra dialog com lista de backups"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            
            def show_dialog():
                try:
                    builder = AlertDialog.Builder(context)
                    builder.setTitle(tr('backup_select_title'))
                    
                    # Converter para array Java
                    java_options = ArrayList()
                    for option in options:
                        java_options.add(option)
                    
                    builder.setItems(java_options.toArray(), lambda dialog, which: callback(which))
                    builder.setNegativeButton(f"{tr('backup_cancel')}", None)
                    
                    dialog = builder.create()
                    dialog.show()
                    
                    log(f"[Nowfy] Backup selection dialog shown with {len(options)} options")
                    
                except Exception as e:
                    log(f"[Nowfy] Error in show_dialog: {e}")
                    # Fallback para seleção simples
                    if options:
                        log(f"[Nowfy] Using fallback - selecting first backup")
                        callback(0)  # Selecionar o primeiro backup
            
            # Executar na UI thread
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            log(f"[Nowfy] Error creating backup list dialog: {e}")
            # Fallback para seleção simples
            if options:
                log(f"[Nowfy] Using fallback - selecting first backup")
                callback(0)  # Selecionar o primeiro backup
    
    def restore_from_backup(self, filename):
        """Restaura configurações de um arquivo de backup específico"""
        try:
            import json
            import os
            
            log(f"[Nowfy] restore_from_backup called with filename: {filename}")
            filepath = os.path.join(self.backup_dir, filename)
            log(f"[Nowfy] Full filepath: {filepath}")
            
            if not os.path.exists(filepath):
                log(f"[Nowfy] Backup file not found: {filepath}")
                BulletinHelper.show_info(f"{tr('backup_file_not_found')}: {filename}")
                return
            
            # Ler arquivo de backup
            log(f"[Nowfy] Reading backup file...")
            with open(filepath, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            log(f"[Nowfy] Backup data loaded successfully")
            
            # Validar estrutura do backup
            if not self.validate_backup_data(backup_data):
                log(f"[Nowfy] Backup validation failed")
                BulletinHelper.show_info(tr('backup_invalid_file'))
                return
            
            log(f"[Nowfy] Backup validation passed, proceeding to confirm restore")
            
            # Confirmar restauração
            self.confirm_restore(backup_data, filename)
            
        except Exception as e:
            log(f"[Nowfy] Error restoring from backup: {e}")
            BulletinHelper.show_info(f"{tr('backup_restore_error')}: {str(e)}")
    
    def validate_backup_data(self, data):
        """Valida a estrutura dos dados de backup"""
        try:
            log(f"[Nowfy] Validating backup data structure")
            
            required_fields = ['version', 'timestamp', 'plugin_name', 'settings']
            for field in required_fields:
                if field not in data:
                    log(f"[Nowfy] Validation failed: Missing field '{field}'")
                    return False
            
            if data.get('plugin_name') != 'nowfy':
                log(f"[Nowfy] Validation failed: Invalid plugin name '{data.get('plugin_name')}'")
                return False
            
            settings = data.get('settings')
            if not isinstance(settings, dict):
                log(f"[Nowfy] Validation failed: Settings is not a dict, type: {type(settings)}")
                return False
            
            if len(settings) == 0:
                log(f"[Nowfy] Validation warning: No settings found in backup")
                return False
            
            log(f"[Nowfy] Backup validation passed: {len(settings)} settings found")
            return True
            
        except Exception as e:
            log(f"[Nowfy] Validation error: {e}")
            return False
    
    def confirm_restore(self, backup_data, filename):
        """Confirma a restauração do backup"""
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_info(f"{tr('error_fragment_not_found')}")
                return
            
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            
            # Informações do backup
            timestamp = backup_data.get('timestamp', tr('unknown'))
            version = backup_data.get('version', tr('unknown'))
            settings_count = len(backup_data.get('settings', {}))
            
            message = f"{tr('backup_confirm_restore')}\n\n{tr('backup_file')}: {filename}\n{tr('backup_date')}: {timestamp}\n{tr('backup_version')}: {version}\n{tr('backup_settings_count')}: {settings_count}\n\n{tr('backup_warning_replace')}"
            
            def on_confirm():
                self.apply_backup_settings(backup_data)
            
            run_on_ui_thread(lambda: self.show_confirmation_dialog(ctx, message, on_confirm))
            
        except Exception as e:
            log(f"[Nowfy] Error in confirm_restore: {e}")
            BulletinHelper.show_info(f"{tr('backup_restore_error')}: {str(e)}")
    
    def show_confirmation_dialog(self, context, message, on_confirm):
        """Mostra dialog de confirmação"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            
            builder = AlertDialog.Builder(context)
            builder.setTitle(tr('backup_restore_title'))
            builder.setMessage(message)
            builder.setPositiveButton(f"{tr('backup_confirm_button')}", lambda dialog, which: on_confirm())
            builder.setNegativeButton(f"{tr('backup_cancel')}", None)
            
            dialog = builder.create()
            dialog.show()
            
        except Exception as e:
            log(f"[Nowfy] Error creating confirmation dialog: {e}")
            # Fallback - aplicar diretamente
            on_confirm()
    
    def show_universal_link_dialog(self):
        """Mostra dialog explicativo sobre Universal Link"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            from org.telegram.messenger import AndroidUtilities
            
            # Obter contexto atual
            ctx = AndroidUtilities.findActivity(ApplicationLoader.applicationContext)
            if not ctx:
                return
            
            builder = AlertDialog.Builder(ctx)
            builder.setTitle(tr('universal_link_dialog_title'))
            builder.setMessage(tr('universal_link_dialog_message'))
            builder.setPositiveButton("OK", None)
            
            dialog = builder.create()
            dialog.show()
            
        except Exception as e:
            log(f"[Nowfy] Error creating universal link dialog: {e}")
    
    
    def apply_backup_settings(self, backup_data):
        """Aplica as configurações do backup"""
        try:
            log(f"[Nowfy] apply_backup_settings called")
            settings = backup_data.get('settings', {})
            log(f"[Nowfy] Found {len(settings)} settings to apply")
            applied_count = 0
            failed_count = 0
            failed_settings = []
            
            # Aplicar configurações do backup importado
            log(f"[Nowfy] Starting to apply {len(settings)} settings from backup")
            
            for key, value in settings.items():
                try:
                    # Validar se o valor não é None ou vazio
                    if value is not None and value != "":
                        log(f"[Nowfy] Applying setting: {key} = {value} (type: {type(value)})")
                        self.plugin.set_setting(key, value)
                        applied_count += 1
                        log(f"[Nowfy] Successfully applied setting: {key}")
                    else:
                        log(f"[Nowfy] Skipping empty/null setting: {key}")
                except Exception as e:
                    failed_count += 1
                    failed_settings.append(key)
                    log(f"[Nowfy] Error applying setting {key}: {e}")
            
            timestamp = backup_data.get('timestamp', tr('unknown'))
            
            # Mostrar resultado detalhado
            if failed_count > 0:
                log(f"[Nowfy] Backup restored with issues: {applied_count} applied, {failed_count} failed")
                log(f"[Nowfy] Failed settings: {failed_settings}")
                BulletinHelper.show_info(f"{tr('backup_restore_success')} ({applied_count}/{len(settings)}) {tr('backup_restart_required')}")
            else:
                log(f"[Nowfy] Backup restored successfully: {applied_count} settings applied")
                BulletinHelper.show_info(f"{tr('backup_restore_success')} ({applied_count} {tr('backup_settings_count').lower()}) {tr('backup_restart_required')}")
            
        except Exception as e:
            log(f"[Nowfy] Error applying backup settings: {e}")
            import traceback
            log(f"[Nowfy] Traceback: {traceback.format_exc()}")
            BulletinHelper.show_info(f"{tr('backup_apply_error')}: {str(e)}")
    
    def list_backups(self):
        """Lista todos os backups disponíveis"""
        try:
            import os
            
            if not os.path.exists(self.backup_dir):
                self.show_backup_list_dialog([], 0)
                return
            
            backup_files = []
            total_size = 0
            
            for file in os.listdir(self.backup_dir):
                if file.endswith('.json') and file.startswith('nowfy_backup_'):
                    filepath = os.path.join(self.backup_dir, file)
                    try:
                        size = os.path.getsize(filepath)
                        total_size += size
                        
                        # Extrair timestamp
                        timestamp_part = file.replace('nowfy_backup_', '').replace('.json', '')
                        if len(timestamp_part) >= 13:
                            date_part = timestamp_part[:8]
                            time_part = timestamp_part[9:15] if len(timestamp_part) > 8 else timestamp_part[8:14]
                            formatted_date = f"{date_part[:4]}/{date_part[4:6]}/{date_part[6:8]}"
                            formatted_time = f"{time_part[:2]}:{time_part[2:4]}:{time_part[4:6]}"
                            display_info = f"{formatted_date} {formatted_time} ({size} bytes)"
                        else:
                            display_info = f"{file} ({size} bytes)"
                        
                        backup_files.append({
                            'filename': file,
                            'display': display_info,
                            'size': size
                        })
                    except Exception as e:
                        backup_files.append({
                            'filename': file,
                            'display': f"{file} ({tr('backup_read_error')})",
                            'size': 0
                        })
            
            if not backup_files:
                self.show_backup_list_dialog([], 0)
                return
            
            # Ordenar por data (mais recente primeiro)
            backup_files.sort(key=lambda x: x['display'], reverse=True)
            
            total_size_mb = total_size / (1024 * 1024)
            self.show_backup_list_dialog(backup_files, total_size_mb)
            
        except Exception as e:
            log(f"[Nowfy] Error listing backups: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def show_backup_list_dialog(self, backup_files, total_size_mb):
        """Exibe dialog com lista de backups"""
        try:
            from org.telegram.ui.ActionBar import AlertDialog
            
            def show_dialog():
                try:
                    if not backup_files:
                        message = f"{tr('backup_no_backups_found')}\n\n{tr('backup_directory')}: {self.backup_dir}\n\n{tr('backup_use_export')}"
                        fragment = get_last_fragment()
                        if fragment:
                            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
                            AlertDialog.Builder(ctx) \
                                .setTitle(tr('backup_list_title')) \
                                .setMessage(message) \
                                .setPositiveButton("OK", None) \
                                .show()
                        return
                    
                    # Formatar lista de backups
                    backup_list = []
                    for i, backup in enumerate(backup_files[:15]):  # Mostrar até 15 backups
                        backup_list.append(f"{i+1}. {backup['display']}")
                    
                    if len(backup_files) > 15:
                         more_count = len(backup_files) - 15
                         backup_list.append(f"\n... {tr('backup_and_more').replace('{}', str(more_count))}")
                    
                    message = "\n".join(backup_list)
                    message += f"\n\n{tr('backup_total_size')}: {total_size_mb:.2f} MB"
                    message += f"\n{tr('backup_directory')}: {self.backup_dir}"
                    message += f"\n\n{tr('backup_use_import')}"
                    
                    fragment = get_last_fragment()
                    if fragment:
                        ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
                        AlertDialog.Builder(ctx) \
                            .setTitle(f"{tr('backup_list_title')} ({len(backup_files)})") \
                            .setMessage(message) \
                            .setPositiveButton("OK", None) \
                            .show()
                except Exception as e:
                    log(f"[Nowfy] Error in show_dialog: {e}")
            
            # Executar na UI thread
            run_on_ui_thread(show_dialog)
                
        except Exception as e:
            log(f"[Nowfy] Error showing backup list dialog: {e}")
            BulletinHelper.show_info(f"{tr('backup_list_error')}: {str(e)}")
    
    def export_data(self):
        """Export plugin data for backup system compatibility"""
        try:
            # Coletar todas as configurações do plugin
            data = {
                "spotify": {
                    "client_id": self.get_setting("spotify_client_id", ""),
                    "client_secret": self.get_setting("spotify_client_secret", ""),
                    "access_token": self.get_setting("spotify_access_token", ""),
                    "refresh_token": self.get_setting("spotify_refresh_token", ""),
                    "username": self.get_setting("spotify_username", "")
                },
                "lastfm": {
                    "username": self.get_setting("lastfm_username", ""),
                    "api_key": self.get_setting("lastfm_api_key", "")
                },
                "statsfm": {
                    "username": self.get_setting("statsfm_username", "")
                },
                "ui_preferences": {
                    "theme_id": self.get_setting("theme_id", 1),
                    "show_progress_bar": self.get_setting("show_progress_bar", True),
                    "show_bio_notification": self.get_setting("show_bio_notification", False),
                    "custom_command": self.get_setting("custom_command", ".now"),
                    "bio_text": self.get_setting("bio_text", "🎵 {track} - {artist}"),
                    "bio_default": self.get_setting("bio_default", "")
                },
                "advanced": {
                    "auto_bio_update": self.get_setting("auto_bio_update", True),
                    "show_lastfm_profile": self.get_setting("show_lastfm_profile", True),
                    "use_custom_covers": self.get_setting("use_custom_covers", False),
                    "cache_enabled": self.get_setting("cache_enabled", True),
                    "cache_ttl": self.get_setting("cache_ttl", 300),
                    "cache_max_size": self.get_setting("cache_max_size", 10)
                },
                "metadata": {
                    "export_version": "1.0",
                    "plugin_version": __version__,
                    "export_timestamp": str(int(time.time() * 1000))
                }
            }
            log("[Nowfy] Plugin data exported successfully")
            return data
        except Exception as e:
            log(f"[Nowfy] Error exporting plugin data: {e}")
            return {}
    
    def import_data(self, data):
        """Import plugin data from backup system"""
        try:
            if not isinstance(data, dict):
                log("[Nowfy] Invalid import data format")
                return False
            
            # Importar configurações do Spotify
            if "spotify" in data:
                spotify_data = data["spotify"]
                if spotify_data.get("client_id"):
                    self.set_setting("spotify_client_id", spotify_data["client_id"])
                if spotify_data.get("client_secret"):
                    self.set_setting("spotify_client_secret", spotify_data["client_secret"])
                if spotify_data.get("access_token"):
                    self.set_setting("spotify_access_token", spotify_data["access_token"])
                if spotify_data.get("refresh_token"):
                    self.set_setting("spotify_refresh_token", spotify_data["refresh_token"])
                if spotify_data.get("username"):
                    self.set_setting("spotify_username", spotify_data["username"])
            
            # Importar configurações do Last.fm
            if "lastfm" in data:
                lastfm_data = data["lastfm"]
                if lastfm_data.get("username"):
                    self.set_setting("lastfm_username", lastfm_data["username"])
                if lastfm_data.get("api_key"):
                    self.set_setting("lastfm_api_key", lastfm_data["api_key"])
            
            # Importar configurações do Stats.fm
            if "statsfm" in data:
                statsfm_data = data["statsfm"]
                if statsfm_data.get("username"):
                    self.set_setting("statsfm_username", statsfm_data["username"])
            
            # Importar preferências de UI
            if "ui_preferences" in data:
                ui_data = data["ui_preferences"]
                if "theme_id" in ui_data:
                    self.set_setting("theme_id", ui_data["theme_id"])
                if "show_progress_bar" in ui_data:
                    self.set_setting("show_progress_bar", ui_data["show_progress_bar"])
                if "show_bio_notification" in ui_data:
                    self.set_setting("show_bio_notification", ui_data["show_bio_notification"])
                if ui_data.get("custom_command"):
                    self.set_setting("custom_command", ui_data["custom_command"])
                if ui_data.get("bio_text"):
                    self.set_setting("bio_text", ui_data["bio_text"])
                if ui_data.get("bio_default"):
                    self.set_setting("bio_default", ui_data["bio_default"])
            
            # Importar configurações avançadas
            if "advanced" in data:
                advanced_data = data["advanced"]
                if "auto_bio_update" in advanced_data:
                    self.set_setting("auto_bio_update", advanced_data["auto_bio_update"])
                if "show_lastfm_profile" in advanced_data:
                    self.set_setting("show_lastfm_profile", advanced_data["show_lastfm_profile"])
                if "use_custom_covers" in advanced_data:
                    self.set_setting("use_custom_covers", advanced_data["use_custom_covers"])
                if "cache_enabled" in advanced_data:
                    self.set_setting("cache_enabled", advanced_data["cache_enabled"])
                if "cache_ttl" in advanced_data:
                    self.set_setting("cache_ttl", advanced_data["cache_ttl"])
                if "cache_max_size" in advanced_data:
                    self.set_setting("cache_max_size", advanced_data["cache_max_size"])
            
            log("[Nowfy] Plugin data imported successfully")
            
            # Reinicializar cache e configurações se necessário
            try:
                self._cache_enabled = self.get_setting("cache_enabled", True)
                self._cache_ttl = self.get_setting("cache_ttl", 300)
                self._cache_max_size = self.get_setting("cache_max_size", 10)
                if hasattr(self, '_image_cache'):
                    self._image_cache.clear()
                if hasattr(self, '_cache_timestamps'):
                    self._cache_timestamps.clear()
            except Exception as cache_error:
                log(f"[Nowfy] Warning: Error reinitializing cache after import: {cache_error}")
            
            return True
            
        except Exception as e:
            log(f"[Nowfy] Error importing plugin data: {e}")
            return False
