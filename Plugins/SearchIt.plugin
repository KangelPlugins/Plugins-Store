from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from hook_utils import find_class
from java import jclass
from ui.settings import Selector, Input, Divider, Switch, Text
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from org.telegram.messenger import R as R_tg, AndroidUtilities
from android.text import SpannableStringBuilder
from android.text import Spanned
from android.text.style import TypefaceSpan
from android.graphics import Typeface
import urllib.parse
import hashlib
import time
import os
import json
from java.io import File
from client_utils import get_last_fragment, get_messages_controller
from android_utils import run_on_ui_thread, OnClickListener
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from org.telegram.ui.ActionBar import BottomSheet, Theme, SimpleTextView
from org.telegram.ui.Components import LayoutHelper
from android.view import Gravity
from android.widget import FrameLayout, ImageView, TextView
from android.util import TypedValue

# Referências para classes nativas do Android
LinearLayout = find_class("android.widget.LinearLayout")
WebView = find_class("android.webkit.WebView")
WebViewClient = find_class("android.webkit.WebViewClient")
EditText = find_class("android.widget.EditText")

# Classes para navegador nativo - Opcional
try:
    ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
    Browser = find_class("org.telegram.messenger.browser.Browser")
except Exception:
    ApplicationLoader = None
    Browser = None

__id__ = "searchit"
__name__ = "Search It"
__description__ = (
    "Search It lets you quickly search the web using search engines like Google, Yandex, Bing, and more, "
    "directly from the chat, formatting menu, or via command.\n\n"
    "Usage:\n"
    "- Chat menu: tap Plugins → Search to open the search box.\n"
    "- Formatting menu: select a word or text and choose Search to see results.\n"
    "- Command: type .sr <term> for direct results, or just .sr to open the search box.\n\n"
    "You can configure your preferred search engine or a custom URL in settings with .panel.\n\n"
    "by @ApplePlugins Lab • @exteraDevPlugins"
)
__author__ = "@AGeekApple"
__version__ = "1.0.2"
__min_version__ = "11.12.0"
__icon__ = "AppleDevIcon/2"

# Diretório de cache local - Experimental
CACHE_DIR = "/storage/emulated/0/Android/media/com.exteragram.messenger/searchit"
HISTORY_FILE = os.path.join(CACHE_DIR, "search_history.json")
LAST_URL_FILE = os.path.join(CACHE_DIR, "last_url.txt")

# Dicionário de tradução e ajudantes
TRANSLATIONS = {
    "language": {"en": "Language", "ru": "Язык", "pt": "Idioma", "es": "Idioma", "fr": "Langue", "it": "Lingua"},
    "lang_en": {"en": "English", "ru": "Английский", "pt": "Inglês", "es": "Inglés", "fr": "Anglais", "it": "Inglese"},
    "lang_ru": {"en": "Russian", "ru": "Русский", "pt": "Russo", "es": "Ruso", "fr": "Russe", "it": "Russo"},
    "lang_pt": {"en": "Portuguese", "ru": "Португальский", "pt": "Português", "es": "Portugués", "fr": "Portugais", "it": "Portoghese"},
    "lang_es": {"en": "Spanish", "ru": "Испанский", "pt": "Espanhol", "es": "Español", "fr": "Espagnol", "it": "Spagnolo"},
    "lang_fr": {"en": "French", "ru": "Французский", "pt": "Francês", "es": "Francés", "fr": "Français", "it": "Francese"},
    "lang_it": {"en": "Italian", "ru": "Итальянский", "pt": "Italiano", "es": "Italiano", "fr": "Italien", "it": "Italiano"},

    "extras_section": {"en": "Extras", "ru": "Дополнительно", "pt": "Extras", "es": "Extras", "fr": "Extras", "it": "Extra"},
    "enable_switch_title": {"en": "Enable in formatting menu", "ru": "Включить в меню форматирования", "pt": "Habilitar no menu de formatação", "es": "Habilitar en el menú de formato", "fr": "Activer dans le menu de formatage", "it": "Abilita nel menu di formattazione"},
    "enable_switch_subtext": {"en": "Adds ‘Search’ option to composer formatting actions", "ru": "Добавляет пункт ‘Поиск’ к действиям форматирования", "pt": "Adiciona opção ‘Pesquisar’ às ações de formatação do editor", "es": "Añade la opción ‘Buscar’ a las acciones de formato del editor", "fr": "Ajoute l’option ‘Rechercher’ aux actions de formatage", "it": "Aggiunge l’opzione ‘Cerca’ alle azioni di formattazione"},
    "show_chat_menu_title": {"en": "Show in chat menu", "ru": "Показывать в меню чата", "pt": "Mostrar no menu do chat", "es": "Mostrar en el menú del chat", "fr": "Afficher dans le menu du chat", "it": "Mostra nel menu della chat"},
    "show_chat_menu_subtext": {"en": "Adds ‘Search’ to Plugins in chat overflow", "ru": "Добавляет ‘Поиск’ в \"Plugins\" в меню чата", "pt": "Adiciona ‘Pesquisar’ em Plugins no menu do chat", "es": "Añade ‘Buscar’ en Plugins del menú del chat", "fr": "Ajoute ‘Recherche’ dans Plugins du menu de chat", "it": "Aggiunge ‘Cerca’ in Plugins nel menu della chat"},
    "provider_section": {"en": "Search Provider", "ru": "Поисковая система", "pt": "Provedor de Pesquisa", "es": "Proveedor de búsqueda", "fr": "Moteur de recherche", "it": "Motore di ricerca"},
    "search_provider": {"en": "Search Provider", "ru": "Поисковая система", "pt": "Provedor de Pesquisa", "es": "Proveedor de búsqueda", "fr": "Moteur de recherche", "it": "Motore di ricerca"},
    "custom_provider_url": {"en": "Custom Provider URL", "ru": "URL пользовательского провайдера", "pt": "URL do Provedor Customizado", "es": "URL del proveedor personalizado", "fr": "URL du fournisseur personnalisé", "it": "URL del provider personalizzato"},
    "search_title": {"en": "Search", "ru": "Поиск", "pt": "Pesquisar", "es": "Buscar", "fr": "Recherche", "it": "Cerca"},
    "menu_item_search": {"en": "Search", "ru": "Поиск", "pt": "Pesquisar", "es": "Buscar", "fr": "Recherche", "it": "Cerca"},
    "search_input_hint": {"en": "Type your query", "ru": "Введите запрос", "pt": "Digite sua pesquisa", "es": "Escribe tu consulta", "fr": "Tapez votre requête", "it": "Digita la tua ricerca"},
    "usage_sr": {"en": "Usage: .sr <term>", "ru": "Использование: .sr <текст>", "pt": "Uso: .sr <termo>", "es": "Uso: .sr <término>", "fr": "Utilisation : .sr <terme>", "it": "Uso: .sr <termine>"},
    "panel_open_error": {"en": "Error opening settings", "ru": "Ошибка открытия настроек", "pt": "Erro ao abrir configurações", "es": "Error al abrir la configuración", "fr": "Erreur d’ouverture des paramètres", "it": "Errore nell’aprire le impostazioni"},

    "ctc_chat_title": {"en": "CTC: Chat Menu", "ru": "CTC: Меню чата", "pt": "CTC: Menu do Chat", "es": "CTC: Menú del chat", "fr": "CTC: Menu du chat", "it": "CTC: Menu della chat"},
    "ctc_chat_sub": {"en": "Adds Circle to Search to Plugins in chat overflow", "ru": "Добавляет ‘Circle to Search’ в Plugins в меню чата", "pt": "Adiciona ‘Circle to Search’ em Plugins no menu do chat", "es": "Añade ‘Circle to Search’ en Plugins del menú del chat", "fr": "Ajoute ‘Circle to Search’ dans Plugins du menu de chat", "it": "Aggiunge ‘Circle to Search’ in Plugins nel menu della chat"},
    "ctc_ctx_title": {"en": "CTC: Context Menu", "ru": "CTC: Контекстное меню", "pt": "CTC: Menu de Contexto", "es": "CTC: Menú contextual", "fr": "CTC: Menu contextuel", "it": "CTC: Menu contestuale"},
    "ctc_ctx_sub": {"en": "Triggers Circle to Search via context menu shortcut", "ru": "Вызывает Circle to Search через контекстное меню", "pt": "Aciona o Circle to Search via atalho no menu de contexto", "es": "Activa Circle to Search a través del menú contextual", "fr": "Déclenche Circle to Search via le menu contextuel", "it": "Attiva Circle to Search tramite il menu contestuale"},
    "ctc_menu_item": {"en": "Circle to Search", "ru": "Circle to Search", "pt": "Circle to Search", "es": "Circle to Search", "fr": "Circle to Search", "it": "Circle to Search"}
}
TRANSLATIONS.update({
    "command_selector_title": {"en": "Command Trigger", "ru": "Триггер команды", "pt": "Acionador do comando", "es": "Disparador del comando", "fr": "Déclencheur de commande", "it": "Trigger comando"},
    "command_option_default": {"en": "Default (.sr)", "ru": "По умолчанию (.sr)", "pt": "Padrão (.sr)", "es": "Predeterminado (.sr)", "fr": "Par défaut (.sr)", "it": "Predefinito (.sr)"},
    "command_option_custom": {"en": "Custom", "ru": "Пользовательский", "pt": "Personalizado", "es": "Personalizado", "fr": "Personnalisé", "it": "Personalizzato"},
    "custom_command_label": {"en": "Custom Command", "ru": "Пользовательская команда", "pt": "Comando personalizado", "es": "Comando personalizado", "fr": "Commande personnalisée", "it": "Comando personalizzato"},
    "dotted_credit": {"en": "Dotted Plugins", "ru": "Dotted Plugins", "pt": "Dotted Plugins", "es": "Dotted Plugins", "fr": "Dotted Plugins", "it": "Dotted Plugins"}
})

# Opções de Exibição: Tela Cheia e Janela Flutuante
TRANSLATIONS.update({
    "fullscreen_title": {
    "en": "Fullscreen Mode",
    "ru": "Режим полного экрана",
    "pt": "Tela Adaptativa",
    "es": "Modo Pantalla Completa",
    "fr": "Mode Plein Écran",
    "it": "Modalità Schermo Intero"
    },
    "screen_options": {
        "en": "Display Mode",
        "ru": "Режим отображения",
        "pt": "Modo de Exibição",
        "es": "Modo de Pantalla",
        "fr": "Mode d’affichage",
        "it": "Modalità Schermo"
    },
    "fullscreen_subtext": {
        "en": "Display results in an expanded view for better visibility.",
        "ru": "Отображение результатов в расширенном окне для лучшей видимости.",
        "pt": "Exibe os resultados em uma visualização ampliada para melhor visualização.",
        "es": "Muestra los resultados en una vista ampliada para una mejor visualización.",
        "fr": "Affiche les résultats dans une vue agrandie pour une meilleure visibilité.",
        "it": "Mostra i risultati in una vista ampliata per una migliore visibilità."
    },
    "floating_window_title": {
    "en": "Floating Window",
    "ru": "Плавающее окно",
    "pt": "Janela Flutuante",
    "es": "Ventana Flotante",
    "fr": "Fenêtre Flottante",
    "it": "Finestra Fluttuante"
    },
    "floating_window_subtext": {
    "en": "Keep results visible in a small draggable window while you browse other content.",
    "ru": "Держите результаты видимыми в небольшом перетаскиваемом окне, пока вы просматриваете другой контент.",
    "pt": "Mantenha os resultados visíveis em uma pequena janela que pode ser arrastada enquanto você navega em outros conteúdos.",
    "es": "Mantén los resultados visibles en una pequeña ventana desplazable mientras navegas por otros contenidos.",
    "fr": "Gardez les résultats visibles dans une petite fenêtre que vous pouvez déplacer tout en naviguant dans d’autres contenus.",
    "it": "Mantieni i risultati visibili in una piccola finestra trascinabile mentre navighi altri contenuti."
    },
    "overlay_minimize": {"en": "Min", "ru": "Св.", "pt": "Min", "es": "Min", "fr": "Min", "it": "Min"},
    "overlay_open_webview": {"en": "Results", "ru": "Результаты", "pt": "Resultados", "es": "Resultados", "fr": "Résultats", "it": "Risultati"},
    "overlay_close": {"en": "Close", "ru": "Закрыть", "pt": "Fechar", "es": "Cerrar", "fr": "Fermer", "it": "Chiudi"},
    "overlay_actions": {"en": "Actions", "ru": "Действия", "pt": "Ações", "es": "Acciones", "fr": "Actions", "it": "Azioni"}
})
TRANSLATIONS.update({
    "overlay_buttons_mode_title": {
        "en": "Show Icon Names",
        "ru": "Показывать названия иконок",
        "pt": "Mostrar nomes dos ícones",
        "es": "Mostrar nombres de iconos",
        "fr": "Afficher les noms des icônes",
        "it": "Mostra nomi icone"
    },
    "overlay_buttons_mode_icons_only": {
        "en": "Icons Only",
        "ru": "Только иконки",
        "pt": "Apenas ícones",
        "es": "Solo iconos",
        "fr": "Icônes uniquement",
        "it": "Solo icone"
    },
    "overlay_buttons_mode_icon_names": {
        "en": "Icon & Names",
        "ru": "Иконка и названия",
        "pt": "Ícone e nomes",
        "es": "Icono y nombres",
        "fr": "Icône et noms",
        "it": "Icona e nomi"
    },
    "native_browser_title": {
        "en": "Use Native Browser",
        "ru": "Использовать встроенный браузер",
        "pt": "Usar Navegador Nativo",
        "es": "Usar Navegador Nativo",
        "fr": "Utiliser le navigateur natif",
        "it": "Usa Browser Nativo"
    },
    "native_browser_subtext": {
        "en": "Open search results in the system's default browser instead of in-app WebView",
        "ru": "Открывать результаты поиска во встроенном браузере системы вместо WebView",
        "pt": "Abrir resultados de pesquisa no navegador padrão do sistema em vez do WebView interno",
        "es": "Abrir resultados de búsqueda en el navegador predeterminado del sistema en lugar del WebView interno",
        "fr": "Ouvrir les résultats de recherche dans le navigateur par défaut du système au lieu du WebView intégré",
        "it": "Apri i risultati di ricerca nel browser predefinito del sistema invece del WebView integrato"
    },
    "advanced_options_title": {
        "en": "Advanced Options",
        "ru": "Дополнительные опции",
        "pt": "Opções Avançadas",
        "es": "Opciones Avanzadas",
        "fr": "Options Avancées",
        "it": "Opzioni Avanzate"
    },
    "advanced_options_subtext": {
        "en": "Interface integration, native browser, custom commands, and context menu options",
        "ru": "Интеграция интерфейса, встроенный браузер, пользовательские команды и контекстное меню",
        "pt": "Integração de interface, navegador nativo, comandos personalizados e menu de contexto",
        "es": "Integración de interfaz, navegador nativo, comandos personalizados y menú contextual",
        "fr": "Intégration d'interface, navigateur natif, commandes personnalisées et menu contextuel",
        "it": "Integrazione interfaccia, browser nativo, comandi personalizzati e menu contestuale"
    },

    "recent_searches_title": {
        "en": "Your recent searches:",
        "ru": "Ваши недавние поиски:",
        "pt": "Suas pesquisas recentes:",
        "es": "Sus búsquedas recientes:",
        "fr": "Vos recherches récentes:",
        "it": "Le tue ricerche recenti:"
    },
    "copy_button": {
        "en": "Copy",
        "ru": "Копировать",
        "pt": "Copiar",
        "es": "Copiar",
        "fr": "Copier",
        "it": "Copia"
    },
    "no_recent_searches": {
        "en": "No recent searches found",
        "ru": "Недавние поиски не найдены",
        "pt": "Nenhuma pesquisa recente encontrada",
        "es": "No se encontraron búsquedas recientes",
        "fr": "Aucune recherche récente trouvée",
        "it": "Nessuna ricerca recente trovata"
    },
    "overlay_buttons_mode_names_only": {
        "en": "Only Names",
        "ru": "Только названия",
        "pt": "Apenas nomes",
        "es": "Solo nombres",
        "fr": "Uniquement les noms",
        "it": "Solo nomi"
    },
    "overlay_back": {
        "en": "Back",
        "ru": "Назад",
        "pt": "Voltar",
        "es": "Atrás",
        "fr": "Retour",
        "it": "Indietro"
    },
    "overlay_forward": {
        "en": "Forward",
        "ru": "Вперёд",
        "pt": "Avançar",
        "es": "Adelante",
        "fr": "Avancer",
        "it": "Avanti"
    }
})

# Navegação e histórico
TRANSLATIONS.update({
    "navigation_section": {"en": "Navigation", "ru": "Навигация", "pt": "Navegação", "es": "Navegación", "fr": "Navigation", "it": "Navigazione"},
    "history_title": {
    "en": "Save History (Experimental)",
    "ru": "Сохранять историю (экспериментально)",
    "pt": "Salvar histórico (experimental)",
    "es": "Guardar historial (experimental)",
    "fr": "Enregistrer l’historique (expérimental)",
    "it": "Salva cronologia (sperimentale)"
    },
    "history_subtext": {
    "en": "When disabled, your search history and cache are cleared automatically after each search",
    "ru": "Если функция выключена, история и кэш очищаются автоматически после каждого поиска",
    "pt": "Quando desativado, o histórico e o cache são limpos automaticamente após cada pesquisa",
    "es": "Cuando está desactivado, el historial y la caché se borran automáticamente después de cada búsqueda",
    "fr": "Lorsqu’elle est désactivée, l’historique et le cache sont effacés automatiquement après chaque recherche",
    "it": "Quando disattivato, la cronologia e la cache vengono eliminate automaticamente dopo ogni ricerca"
    },
    "keep_open_info": {"en": "Use .open to reopen the last page", "ru": "Используйте .open чтобы открыть последнюю страницу", "pt": "Use .open para reabrir a última página", "es": "Usa .open para reabrir la última página", "fr": "Utilisez .open pour rouvrir la dernière page", "it": "Usa .open per riaprire l’ultima pagina"},
    "open_no_last_url": {"en": "No last page to open", "ru": "Нет последней страницы для открытия", "pt": "Nenhuma página anterior para abrir", "es": "No hay última página para abrir", "fr": "Aucune dernière page à ouvrir", "it": "Nessuna ultima pagina da aprire"}
})

# Strings da folha "Como Usar"
TRANSLATIONS.update({
    "howto_title": {"en": "How to Use", "ru": "Как использовать", "pt": "Como Usar", "es": "Cómo usar", "fr": "Comment utiliser", "it": "Come usare"},
    "howto_subtitle": {"en": "Quick guide", "ru": "Краткое руководство", "pt": "Guia rápido", "es": "Guía rápida", "fr": "Guide rapide", "it": "Guida rapida"},
    "howto_description": {
        "en": (
            "SearchIt lets you search in four ways:\n\n"
            "- Chat menu: enable ‘Show in chat menu’ and tap Plugins → Search to open the search box.\n"
            "- Formatting menu: select text in the composer and choose Search to open results.\n"
            "- Command: type .sr <term> to open results directly, or just .sr to open the search box. If you set a Custom Command in settings, use it instead of .sr.\n"
            "- Choose a provider: select a search provider directly in chat with .select <provider> (Google, Bing, etc.) or open settings to choose it there.\n\n"
            "You can also search directly on supported video platforms:\n"
            "• YouTube — use .sr yt <term>.\n"
            "• VK Video — use .sr vk <term>.\n\n"
            "Open settings with .panel to set a provider or define a custom URL (supports {q} in patterns)."
        ),
        "ru": (
            "SearchIt позволяет искать четырьмя способами:\n\n"
            "- Меню чата: включите ‘Показывать в меню чата’ и нажмите Plugins → Поиск, чтобы открыть окно поиска.\n"
            "- Меню форматирования: выделите текст в редакторе и выберите Поиск, чтобы открыть результаты.\n"
            "- Команда: введите .sr <текст> для мгновенных результатов или просто .sr для открытия окна поиска. Если задана пользовательская команда, используйте её вместо .sr.\n"
            "- Выбор провайдера: выберите поисковую систему напрямую в чате с помощью .select <провайдер> (Google, Bing и др.) или откройте настройки, чтобы выбрать там.\n\n"
            "Также теперь можно искать напрямую на видеоплатформах:\n"
            "• YouTube — используйте .sr yt <запрос>.\n"
            "• VK Video — используйте .sr vk <запрос>.\n\n"
            "Откройте настройки через .panel, чтобы выбрать провайдера или указать пользовательский URL (поддерживает {q})."
        ),
        "pt": (
            "O SearchIt permite pesquisar de quatro formas:\n\n"
            "- Menu do chat: ative ‘Mostrar no menu do chat’ e toque em Plugins → Pesquisar para abrir a caixa de pesquisa.\n"
            "- Menu de formatação: selecione o texto no editor e escolha Pesquisar para ver os resultados.\n"
            "- Comando: digite .sr <termo> para abrir resultados diretamente ou apenas .sr para abrir a caixa de pesquisa. Se você definir um Comando Personalizado nas configurações, use-o no lugar de .sr.\n"
            "- Escolha do provedor: selecione um provedor de pesquisa diretamente no chat com .select <provedor> (Google, Bing, etc.) ou abra as configurações para escolher lá.\n\n"
            "Agora também é possível fazer pesquisas diretas em plataformas de vídeo compatíveis:\n"
            "• YouTube — use .sr yt <termo>.\n"
            "• VK Video — use .sr vk <termo>.\n\n"
            "Abra as configurações com .panel para definir um provedor ou uma URL personalizada (suporta {q} nos padrões)."
        ),
        "es": (
            "SearchIt permite buscar de cuatro maneras:\n\n"
            "- Menú del chat: active ‘Mostrar en el menú del chat’ y toque Plugins → Buscar para abrir el cuadro de búsqueda.\n"
            "- Menú de formato: seleccione texto en el editor y elija Buscar para ver los resultados.\n"
            "- Comando: escriba .sr <término> para abrir resultados directamente, o solo .sr para abrir el cuadro de búsqueda. Si configura un Comando Personalizado, úselo en lugar de .sr.\n"
            "- Selección del proveedor: elija un proveedor de búsqueda directamente en el chat con .select <proveedor> (Google, Bing, etc.) o abra los ajustes para seleccionarlo allí.\n\n"
            "También puede buscar directamente en plataformas de video compatibles:\n"
            "• YouTube — use .sr yt <término>.\n"
            "• VK Video — use .sr vk <término>.\n\n"
            "Abra los ajustes con .panel para elegir un proveedor o definir una URL personalizada (admite {q})."
        ),
        "fr": (
            "SearchIt permet de rechercher de quatre façons :\n\n"
            "- Menu du chat : activez ‘Afficher dans le menu du chat’ et touchez Plugins → Recherche pour ouvrir la boîte de recherche.\n"
            "- Menu de formatage : sélectionnez du texte dans l’éditeur et choisissez Recherche pour afficher les résultats.\n"
            "- Commande : tapez .sr <terme> pour ouvrir directement les résultats, ou juste .sr pour ouvrir la boîte de recherche. Si vous définissez une commande personnalisée, utilisez-la à la place de .sr.\n"
            "- Choix du moteur : sélectionnez un moteur de recherche directement dans le chat avec .select <moteur> (Google, Bing, etc.) ou ouvrez les paramètres pour le choisir là.\n\n"
            "Il est désormais possible de rechercher directement sur les plateformes vidéo prises en charge :\n"
            "• YouTube — utilisez .sr yt <terme>.\n"
            "• VK Video — utilisez .sr vk <terme>.\n\n"
            "Ouvrez les paramètres avec .panel pour choisir un moteur ou définir une URL personnalisée (prend en charge {q})."
        ),
        "it": (
            "SearchIt consente di cercare in quattro modi:\n\n"
            "- Menu chat: abilita ‘Mostra nel menu della chat’ e tocca Plugins → Cerca per aprire la casella di ricerca.\n"
            "- Menu di formattazione: seleziona il testo nell’editor e scegli Cerca per visualizzare i risultati.\n"
            "- Comando: digita .sr <termine> per aprire direttamente i risultati, oppure solo .sr per aprire la casella di ricerca. Se imposti un Comando personalizzato, usalo al posto di .sr.\n"
            "- Scelta del provider: seleziona un provider di ricerca direttamente nella chat con .select <provider> (Google, Bing, ecc.) oppure apri le impostazioni per sceglierlo lì.\n\n"
            "Ora è anche possibile cercare direttamente sulle piattaforme video supportate:\n"
            "• YouTube — usa .sr yt <termine>.\n"
            "• VK Video — usa .sr vk <termine>.\n\n"
            "Apri le impostazioni con .panel per scegliere un provider o impostare un URL personalizzato (supporta {q})."
        )
    },

    "understood": {"en": "Understood", "ru": "Понятно", "pt": "Entendi", "es": "Entendido", "fr": "Compris", "it": "Capito"}
})

# Traduções para seleção de provedor (.select)
TRANSLATIONS.update({
    "select_provider_title": {
        "en": "Select Provider",
        "ru": "Выбрать провайдера",
        "pt": "Selecionar Provedor",
        "es": "Seleccionar proveedor",
        "fr": "Sélectionner le fournisseur",
        "it": "Seleziona provider"
    },
    "provider_selected": {
        "en": "Provider selected: {name}",
        "ru": "Провайдер выбран: {name}",
        "pt": "Provedor selecionado: {name}",
        "es": "Proveedor seleccionado: {name}",
        "fr": "Fournisseur sélectionné : {name}",
        "it": "Provider selezionato: {name}"
    }
})

class SearchItPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hook_fill_action_mode_menu_ref = None
        self.hook_perform_menu_action_ref = None
        self.hook_message_text_touch_ref = None
        # ID de item de menu estável e determinístico
        try:
            self.menu_item_id = int(hashlib.md5(f"{__id__}:menu_search".encode()).hexdigest()[:8], 16)
        except Exception:
            self.menu_item_id = 10010
        # Estado da janela flutuante
        self._overlay_root = None
        self._overlay_header = None
        self._overlay_content = None
        self._overlay_webview = None
        self._overlay_visible = False
        self._overlay_collapsed = False
        self._overlay_wm = None
        # Última URL navegada para suporte ao comando .open
        self._last_url = None

    # Ajudantes de localização
    def _get_lang(self):
        try:
            Locale = find_class("java.util.Locale")
            lang = None
            try:
                lang = Locale.getDefault().getLanguage() if Locale else None
            except Exception:
                lang = None
            # Normaliza e mapea
            try:
                l = (lang or "en").lower()
                if l.startswith("pt"):
                    return "pt"
                if l.startswith("es"):
                    return "es"
                if l.startswith("fr"):
                    return "fr"
                if l.startswith("it"):
                    return "it"
                if l.startswith("ru"):
                    return "ru"
                # default English
                return "en"
            except Exception:
                return "en"
        except Exception:
            return "en"

    def _t(self, key: str) -> str:
        try:
            lang = self._get_lang()
            d = TRANSLATIONS.get(key, {})
            return d.get(lang, d.get("en", key))
        except Exception:
            return key

    def create_settings(self):
        settings = []
        # (Unificado)
        # Seção de provedor
        settings.append(Divider(text=self._t("provider_section")))
        provider_items = [
            "Google", "Bing", "DuckDuckGo", "Yahoo", "Yandex", "Brave", "Ecosia", "Startpage", "Qwant", "Custom"
        ]
        default_provider_index = self.get_setting("search_provider", 0)
        if isinstance(default_provider_index, str):
            try:
                default_provider_index = provider_items.index(default_provider_index)
            except Exception:
                default_provider_index = 0
        settings.append(Selector(
            key="search_provider",
            text=self._t("search_provider"),
            items=provider_items,
            default=default_provider_index,
            icon="msg_openin"
        ))

        # URL personalizada - 'Custom'
        try:
            current_provider_index = self.get_setting("search_provider", 0)
            if isinstance(current_provider_index, str):
                try:
                    current_provider_index = provider_items.index(current_provider_index)
                except Exception:
                    current_provider_index = 0
        except Exception:
            current_provider_index = 0
        if current_provider_index == len(provider_items) - 1:
            settings.append(Input(
                key="custom_search_url",
                text=self._t("custom_provider_url"),
                icon="msg_link2_remix",
                default=self.get_setting("custom_search_url", "")
            ))

        # Verificar se navegador nativo está ativo para ocultar opções de display
        try:
            use_native_browser = bool(self.get_setting("use_native_browser", False))
        except Exception:
            use_native_browser = False
        
        # Exibição: Tela Cheia e Janela Flutuante (ocultar se navegador nativo ativo)
        if not use_native_browser:
            settings.append(Divider(text=self._t("screen_options")))
            settings.append(Switch(
                key="fullscreen_mode",
                text=self._t("fullscreen_title"),
                subtext=self._t("fullscreen_subtext"),
                icon="pip_enlarge",
                default=self.get_setting("fullscreen_mode", False)
            ))
            settings.append(Switch(
                key="floating_window_mode",
                text=self._t("floating_window_title"),
                subtext=self._t("floating_window_subtext"),
                icon="menu_video_pip",
                default=self.get_setting("floating_window_mode", False)
            ))
        # Mostrar "Show Icon Names" apenas quando a Janela Flutuante estiver ativada E o navegador nativo estiver desativado
        try:
            is_floating = bool(self.get_setting("floating_window_mode", False))
        except Exception:
            is_floating = False
        if is_floating and not use_native_browser:
            try:
                mode_items = [
                    self._t("overlay_buttons_mode_icons_only"),
                    self._t("overlay_buttons_mode_icon_names"),
                    self._t("overlay_buttons_mode_names_only")
                ]
                try:
                    overlay_mode = int(self.get_setting("overlay_buttons_mode", 0) or 0)
                except Exception:
                    overlay_mode = 0
                settings.append(Selector(
                    key="overlay_buttons_mode",
                    text=self._t("overlay_buttons_mode_title"),
                    items=mode_items,
                    default=overlay_mode,
                    icon="profile_list"
                ))
            except Exception:
                pass

        # Seção: Navegação e Histórico
        settings.append(Divider(text=self._t("navigation_section")))
        # Histórico de navegação: quando desativado, limpar cache/histórico a cada pesquisa
        settings.append(Switch(
            key="history_enabled",
            text=self._t("history_title"),
            subtext=self._t("history_subtext"),
            icon="msg_recent",
            default=self.get_setting("history_enabled", False)
        ))
        # Dica do recurso Keep Open (.open)
        settings.append(Text(
            text=self._t("keep_open_info"),
            icon="msg_language_solar",
            accent=True
        ))

        # Seção: Opções Avançadas (colapso)
        settings.append(Divider(text=self._t("extras_section")))
        
        # Switch para mostrar/ocultar opções avançadas
        settings.append(Switch(
            key="show_advanced_options",
            text=self._t("advanced_options_title"),
            subtext=self._t("advanced_options_subtext"),
            icon="msg_settings_old",
            default=self.get_setting("show_advanced_options", False)
        ))
        
        # Verificar se deve mostrar opções avançadas
        try:
            show_advanced = bool(self.get_setting("show_advanced_options", False))
        except Exception:
            show_advanced = False
        
        if show_advanced:
            # Seção: Interface Integration
            settings.append(Divider(text="Interface Integration"))
            
            # Enable in formatting menu
            settings.append(Switch(
                key="enable_search_composer",
                text=self._t("enable_switch_title"),
                subtext=self._t("enable_switch_subtext"),
                icon="menu_browser_search",
                default=self.get_setting("enable_search_composer", True),
                on_change=lambda v: self._toggle_formatting_menu(v)
            ))
            
            # Show in chat menu
            settings.append(Switch(
                key="show_chat_menu",
                text=self._t("show_chat_menu_title"),
                subtext=self._t("show_chat_menu_subtext"),
                icon="preview_dots",
                default=self.get_setting("show_chat_menu", True),
                on_change=lambda v: self._toggle_chat_menu_item(v)
            ))
            
            # Context Menu (MESSAGE_CONTEXT_MENU)
            settings.append(Switch(
                key="enable_context_menu",
                text="Context Menu",
                subtext="Lê a mensagem, interpreta o texto e abre a pesquisa",
                icon="menu_browser_search",
                default=self.get_setting("enable_context_menu", False),
                on_change=lambda v: self._toggle_context_menu_item(v)
            ))
            
            # CTC: Chat Menu
            settings.append(Switch(
                key="show_circle_chat_menu",
                text=self._t("ctc_chat_title"),
                subtext=self._t("ctc_chat_sub"),
                icon="msg_viewchats",
                default=self.get_setting("show_circle_chat_menu", True),
                on_change=lambda v: self._toggle_circle_chat_menu_item(v)
            ))
            
            # CTC: Context Menu
            settings.append(Switch(
                key="enable_circle_context_menu",
                text=self._t("ctc_ctx_title"),
                subtext=self._t("ctc_ctx_sub"),
                icon="msg_download_settings",
                default=self.get_setting("enable_circle_context_menu", False),
                on_change=lambda v: self._toggle_circle_context_menu_item(v)
            ))
            
            # Seção: Browser Settings
            settings.append(Divider(text="Browser Settings"))
            
            # Native Browser
            settings.append(Switch(
                key="use_native_browser",
                text=self._t("native_browser_title"),
                subtext=self._t("native_browser_subtext"),
                icon="msg_language_solar",
                default=self.get_setting("use_native_browser", False)
            ))
            
            # Seção: Command Configuration
            settings.append(Divider(text="Command Configuration"))
            
            # Command Trigger (Default/Custom)
            try:
                command_items = [self._t("command_option_default"), self._t("command_option_custom")]
                command_mode = self.get_setting("command_mode", 0)
                if isinstance(command_mode, str):
                    try:
                        command_mode = command_items.index(command_mode)
                    except Exception:
                        command_mode = 0
                settings.append(Selector(
                    key="command_mode",
                    text=self._t("command_selector_title"),
                    icon="input_bot2",
                    items=command_items,
                    default=command_mode
                ))
                if int(command_mode) == 1:
                    settings.append(Input(
                        key="custom_command",
                        text=self._t("custom_command_label"),
                        icon="input_bot1",
                        default=self.get_setting("custom_command", ".sr")
                    ))
            except Exception:
                pass

        # Divider para separar Extras de How to Use / Dotted Plugins
        settings.append(Divider())
        # How to Use entry
        try:
            settings.append(Text(
                text=self._t("howto_title"),
                icon="msg_info_remix",
                on_click=lambda view: run_on_ui_thread(self._show_how_to_use_sheet)
            ))
        except Exception:
            pass
        try:
            settings.append(Text(
                text=self._t("dotted_credit"),
                icon="etg_settings",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
            ))
        except Exception:
            pass
        return settings

    def _ensure_cache_dir(self):
        """Garante que o diretório de cache existe"""
        try:
            if not os.path.exists(CACHE_DIR):
                os.makedirs(CACHE_DIR)
            return True
        except Exception:
            return False

    def _save_last_url_to_file(self, url):
        """Salva a última URL em arquivo local"""
        try:
            if self._ensure_cache_dir():
                with open(LAST_URL_FILE, 'w', encoding='utf-8') as f:
                    f.write(url)
                return True
        except Exception:
            pass
        return False

    def _load_last_url_from_file(self):
        """Carrega a última URL do arquivo local"""
        try:
            if os.path.exists(LAST_URL_FILE):
                with open(LAST_URL_FILE, 'r', encoding='utf-8') as f:
                    url = f.read().strip()
                    return url if url else None
        except Exception:
            pass
        return None

    def _save_history_to_file(self, history):
        """Salva o histórico em arquivo local"""
        try:
            if self._ensure_cache_dir():
                with open(HISTORY_FILE, 'w', encoding='utf-8') as f:
                    json.dump(history, f, ensure_ascii=False, indent=2)
                # Debug temporário
                BulletinHelper.show_info(f"Histórico salvo: {len(history)} itens")
                return True
        except Exception as e:
            # Debug temporário
            BulletinHelper.show_error(f"Erro ao salvar histórico: {str(e)}")
        return False

    def _load_history_from_file(self):
        """Carrega o histórico do arquivo local"""
        try:
            if os.path.exists(HISTORY_FILE):
                with open(HISTORY_FILE, 'r', encoding='utf-8') as f:
                    history = json.load(f)
                    result = history if isinstance(history, list) else []
                    # Debug temporário
                    BulletinHelper.show_info(f"Histórico carregado do arquivo: {len(result)} itens")
                    return result
            else:
                # Debug temporário
                BulletinHelper.show_info(f"Arquivo de histórico não existe: {HISTORY_FILE}")
        except Exception as e:
            # Debug temporário
            BulletinHelper.show_error(f"Erro ao carregar histórico: {str(e)}")
        return []

    def _save_last_url(self, url):
        """Salva a última URL na memória, configurações e arquivo local"""
        try:
            if url and url.strip():
                self._last_url = url
                self.set_setting("searchit_last_url", url)
                self._save_last_url_to_file(url)
        except Exception:
            pass

    def _show_search_history(self):
        """Mostra o histórico de pesquisas recentes"""
        try:
            # Debug temporário
            BulletinHelper.show_info("Carregando histórico...")
            
            # Obter histórico de pesquisas do arquivo local primeiro, depois das configurações
            history_data = self._load_history_from_file()
            BulletinHelper.show_info(f"Histórico do arquivo: {len(history_data) if history_data else 0} itens")
            
            if not history_data or len(history_data) == 0:
                history_data = self.get_setting("search_history", [])
                BulletinHelper.show_info(f"Histórico das config: {len(history_data) if history_data else 0} itens")
            
            if not history_data or len(history_data) == 0:
                # Mostrar mensagem de que não há histórico
                try:
                    BulletinHelper.show_info(self._t("no_recent_searches"))
                except Exception:
                    pass
                return
            
            # Criar BottomSheet para mostrar o histórico
            fragment = get_last_fragment()
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return
                
            # Criar BottomSheet (aprimorar nas futuraas versões)
            sheet = BottomSheet(activity, False)
            sheet.setTitle(self._t("recent_searches_title"))
            
            # Container principal
            container = LinearLayout(activity)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(
                AndroidUtilities.dp(16), AndroidUtilities.dp(8),
                AndroidUtilities.dp(16), AndroidUtilities.dp(16)
            )
            
            # Adicionar cada item do histórico
            for i, search_item in enumerate(reversed(history_data[-10:])):  # Últimas 10 pesquisas
                if not search_item or not isinstance(search_item, dict):
                    continue
                    
                query = search_item.get("query", "")
                provider = search_item.get("provider", "Google")
                
                if not query:
                    continue
                
                # Container do item
                item_container = LinearLayout(activity)
                item_container.setOrientation(LinearLayout.HORIZONTAL)
                item_container.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
                
                # TextView para o texto da pesquisa
                text_view = SimpleTextView(activity)
                text_view.setText(f"{query} ({provider})")
                text_view.setTextSize(16)
                text_view.setTextColor(Theme.getColor("windowBackgroundWhiteBlackText"))
                text_view.setGravity(Gravity.CENTER_VERTICAL)
                
                # Botão de pesquisar novamente
                search_btn = SimpleTextView(activity)
                search_btn.setText("🔍")
                search_btn.setTextSize(18)
                search_btn.setGravity(Gravity.CENTER)
                search_btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                
                # Botão de copiar
                copy_btn = SimpleTextView(activity)
                copy_btn.setText("📋")
                copy_btn.setTextSize(18)
                copy_btn.setGravity(Gravity.CENTER)
                copy_btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                
                # Adicionar click listeners
                def make_search_click(q, p):
                    def on_click(v):
                        try:
                            sheet.dismiss()
                            # Executar pesquisa
                            self._perform_search(q, p)
                        except Exception:
                            pass
                    return on_click
                
                def make_copy_click(q):
                    def on_click(v):
                        try:
                            self._copy_to_clipboard(q)
                            sheet.dismiss()
                        except Exception:
                            pass
                    return on_click
                
                search_btn.setOnClickListener(OnClickListener(make_search_click(query, provider)))
                copy_btn.setOnClickListener(OnClickListener(make_copy_click(query)))
                
                # Adicionar views ao container do item
                item_container.addView(text_view, LayoutHelper.createLinear(-1, -2, 1.0))
                item_container.addView(search_btn, LayoutHelper.createLinear(-2, -2))
                item_container.addView(copy_btn, LayoutHelper.createLinear(-2, -2))
                
                container.addView(item_container, LayoutHelper.createLinear(-1, -2))
                
                # Adicionar divisor (exceto no último item)
                if i < min(len(history_data), 10) - 1:
                    divider = FrameLayout(activity)
                    divider.setBackgroundColor(Theme.getColor("divider"))
                    container.addView(divider, LayoutHelper.createLinear(-1, 1))
            
            sheet.setCustomView(container)
            sheet.show()
            
        except Exception:
            # Fallback: mostrar mensagem simples
            try:
                BulletinHelper.show_info(self._t("no_recent_searches"))
            except Exception:
                pass

    def _perform_search(self, query, provider_name=None):
        """Executa uma pesquisa com a query e provider especificados"""
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            
            # Determinar provider override baseado no nome
            provider_override = None
            if provider_name:
                provider_lower = provider_name.lower()
                if "youtube" in provider_lower:
                    provider_override = "youtube"
                elif "vk" in provider_lower:
                    provider_override = "vkvideo"
                elif "tiktok" in provider_lower:
                    provider_override = "tiktok"
                elif "twitter" in provider_lower:
                    provider_override = "twitter"
            
            # Experimental
            # Adicionar ao histórico (não duplicar se já foi adicionado pelo _show_search_dialog)
            # Este método é usado principalmente pelo histórico, então não adiciona novamente
            
            # Verificar se deve usar navegador nativo
            try:
                use_native_browser = self.get_setting("use_native_browser", False)
                if use_native_browser and ApplicationLoader and Browser:
                    # Construir URL de pesquisa
                    if provider_override == "youtube":
                        url = f"https://www.youtube.com/results?search_query={urllib.parse.quote_plus(query)}"
                    elif provider_override == "vkvideo":
                        url = f"https://m.vk.com/video?q={urllib.parse.quote_plus(query)}"
                    elif provider_override == "tiktok":
                        url = f"https://www.tiktok.com/search?q={urllib.parse.quote_plus(query)}"
                    elif provider_override == "twitter":
                        url = f"https://twitter.com/search?q={urllib.parse.quote_plus(query)}"
                    else:
                        url = self._build_search_url(query)
                    
                    # Abrir no navegador nativo
                    app_context = ApplicationLoader.applicationContext
                    if app_context:
                        run_on_ui_thread(lambda: Browser.openUrl(app_context, url))
                        return
            except Exception:
                pass
            
            # Se não usar navegador nativo, usar o método normal
            self._show_search_dialog(activity, query, provider_override)
            
        except Exception:
            pass

    def _copy_to_clipboard(self, text):
        """Copia texto para a área de transferência"""
        try:
            ClipboardManager = find_class("android.content.ClipboardManager")
            ClipData = find_class("android.content.ClipData")
            Context = find_class("android.content.Context")
            
            fragment = get_last_fragment()
            if fragment:
                activity = fragment.getParentActivity()
                if activity:
                    clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE)
                    if clipboard and ClipData:
                        clip = ClipData.newPlainText("SearchIt", text)
                        clipboard.setPrimaryClip(clip)
                        try:
                            BulletinHelper.show_info(f"{self._t('copy_button')}: {text}")
                        except Exception:
                            pass
        except Exception:
            pass

    def _add_to_search_history(self, query, provider_name):
        """Adiciona uma pesquisa ao histórico"""
        try:
            if not query or not query.strip():
                return
            
            # Debug temporário
            BulletinHelper.show_info(f"Salvando no histórico: {query} ({provider_name})")
                
            # Obter histórico atual do arquivo local primeiro
            history = self._load_history_from_file()
            if not history:
                history = self.get_setting("search_history", [])
            if not isinstance(history, list):
                history = []
            
            # Criar item do histórico
            search_item = {
                "query": query.strip(),
                "provider": provider_name or "Google",
                "timestamp": int(time.time()) if 'time' in globals() else 0
            }
            
            # Remover duplicatas (mesma query e provider)
            history = [item for item in history if not (
                isinstance(item, dict) and 
                item.get("query") == search_item["query"] and 
                item.get("provider") == search_item["provider"]
            )]
            
            # Adicionar novo item no final
            history.append(search_item)
            
            # Manter apenas os últimos 50 itens
            if len(history) > 50:
                history = history[-50:]
            
            # Salvar histórico no arquivo local e nas configurações
            self._save_history_to_file(history)
            self.set_setting("search_history", history)
            
        except Exception:
            pass

    def on_plugin_load(self):
        # Habilita tratamento de comandos (.sr / .panel)
        try:
            self.add_on_send_message_hook()
        except Exception:
            pass
        try:
            if self.get_setting("enable_search_composer", True):
                self._hook_formatting_menu()
        except Exception:
            pass
        # Sempre habilita busca ao tocar na palavra no texto da mensagem
        try:
            self._hook_message_text_touch()
        except Exception:
            pass
        # Adiciona item ao menu do chat se habilitado
        try:
            if self.get_setting("show_chat_menu", True):
                self._add_chat_menu_item()
        except Exception:
            pass
        # Adiciona item ao menu de contexto se habilitado
        try:
            if self.get_setting("enable_context_menu", False):
                self._add_context_menu_item()
        except Exception:
            pass
        # Adiciona item ‘Circle to Search’ ao menu do chat se habilitado
        try:
            if self.get_setting("show_circle_chat_menu", True):
                self._add_circle_chat_menu_item()
        except Exception:
            pass
        # Adiciona item ‘Circle to Search’ ao menu de contexto se habilitado
        try:
            if self.get_setting("enable_circle_context_menu", False):
                self._add_circle_context_menu_item()
        except Exception:
            pass

    def on_send_message_hook(self, account, params) -> HookResult:
        try:
            if not hasattr(params, 'message') or not isinstance(params.message, str):
                return HookResult()

            msg = params.message.strip()
            if len(msg) == 0:
                return HookResult()

            lower = msg.lower()
            # Comando para selecionar provedor (.select)
            if lower.startswith(".select"):
                try:
                    run_on_ui_thread(self._show_provider_select_sheet)
                except Exception:
                    self._show_provider_select_sheet()
                return HookResult(strategy=HookStrategy.CANCEL, params=params)
            # Open settings panel
            if lower.startswith(".panel"):
                self._open_plugin_settings()
                return HookResult(strategy=HookStrategy.CANCEL, params=params)

            # Comando .circle: aciona Circle to Search
            if lower.startswith(".circle"):
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                try:
                    run_on_ui_thread(lambda: self._trigger_circle_to_search(activity))
                except Exception:
                    self._trigger_circle_to_search(activity)
                return HookResult(strategy=HookStrategy.CANCEL, params=params)

            # Comando .open: reabrir a última página exibida
            if lower.startswith(".open"):
                # Priorizar URL do arquivo local, depois configurações, depois memória
                last = self._load_last_url_from_file()
                if not last:
                    try:
                        last = str(self.get_setting("searchit_last_url", "") or "")
                    except Exception:
                        last = None
                if not last:
                    try:
                        last = getattr(self, "_last_url", None)
                    except Exception:
                        last = None
                if not last:
                    try:
                        BulletinHelper.show_info(self._t("open_no_last_url"))
                    except Exception:
                        pass
                    return HookResult(strategy=HookStrategy.CANCEL, params=params)
                
                # Verificar se deve usar navegador nativo
                try:
                    use_native_browser = self.get_setting("use_native_browser", False)
                    if use_native_browser and ApplicationLoader and Browser:
                        # Abrir no navegador nativo
                        try:
                            app_context = ApplicationLoader.applicationContext
                            if app_context:
                                run_on_ui_thread(lambda: Browser.openUrl(app_context, last))
                                return HookResult(strategy=HookStrategy.CANCEL, params=params)
                        except Exception:
                            pass
                except Exception:
                    pass
                
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
                
                # Verificar modo de exibição
                try:
                    is_float = bool(self.get_setting("floating_window_mode", False))
                except Exception:
                    is_float = False
                
                try:
                    is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
                except Exception:
                    is_fullscreen = False
                
                # Escolher método de exibição baseado nas configurações
                try:
                    if is_float:
                        run_on_ui_thread(lambda: self._show_search_overlay(activity, last))
                    else:
                        # Usar _show_search_dialog que já lida com fullscreen e outros modos
                        run_on_ui_thread(lambda: self._show_url_dialog(activity, last))
                except Exception:
                    try:
                        if is_float:
                            self._show_search_overlay(activity, last)
                        else:
                            self._show_url_dialog(activity, last)
                    except Exception:
                        pass
                return HookResult(strategy=HookStrategy.CANCEL, params=params)

            # Handle history command (.his)
            if lower.startswith(".his"):
                try:
                    # Debug temporário
                    BulletinHelper.show_info("Comando .his detectado!")
                    run_on_ui_thread(lambda: self._show_search_history())
                except Exception as e:
                    try:
                        BulletinHelper.show_error(f"Erro .his: {str(e)}")
                        self._show_search_history()
                    except Exception:
                        pass
                return HookResult(strategy=HookStrategy.CANCEL, params=params)

            # Handle command (.sr, alias .de, or custom)
            try:
                command_mode = int(self.get_setting("command_mode", 0) or 0)
            except Exception:
                command_mode = 0
            default_cmd = ".sr"
            alias_cmd = ".de"
            custom_cmd = str(self.get_setting("custom_command", default_cmd) or default_cmd).strip()
            base_cmds = [default_cmd, alias_cmd]
            commands = base_cmds if command_mode == 0 else (base_cmds + ([custom_cmd] if custom_cmd else []))

            for cmd in commands:
                if lower.startswith(cmd.lower()):
                    try:
                        query = msg[len(cmd):].strip()
                    except Exception:
                        query = ""
                    if not query:
                        # Sem termo: abrir o painel de input igual ao menu de chat
                        try:
                            run_on_ui_thread(lambda: self._open_chat_search_panel())
                        except Exception:
                            self._open_chat_search_panel()
                        return HookResult(strategy=HookStrategy.CANCEL, params=params)

                    # Subcomandos diretos: YouTube (yr/yt) e VK Vídeo (vk)
                    provider_override = None
                    term = query
                    try:
                        ql = query.lower()
                        # Formatos aceitos: "yr + termo", "yt + termo", "vk + termo", "tk + termo" ou sem '+'
                        if ql.startswith("yr ") or ql.startswith("yr+") or ql.startswith("yt ") or ql.startswith("yt+"):
                            provider_override = "youtube"
                            if "+" in query:
                                try:
                                    term = query.split("+", 1)[1].strip()
                                except Exception:
                                    term = query[2:].strip()
                            else:
                                term = query[2:].strip()
                        elif ql.startswith("vk ") or ql.startswith("vk+"):
                            provider_override = "vkvideo"
                            if "+" in query:
                                try:
                                    term = query.split("+", 1)[1].strip()
                                except Exception:
                                    term = query[2:].strip()
                            else:
                                term = query[2:].strip()
                        elif ql.startswith("tk ") or ql.startswith("tk+"):
                            provider_override = "tiktok"
                            if "+" in query:
                                try:
                                    term = query.split("+", 1)[1].strip()
                                except Exception:
                                    term = query[2:].strip()
                            else:
                                term = query[2:].strip()
                    except Exception:
                        provider_override = None
                        term = query

                    fragment = get_last_fragment()
                    activity = fragment.getParentActivity() if fragment else None
                    try:
                        run_on_ui_thread(lambda: self._show_search_dialog(activity, term, provider_override))
                    except Exception:
                        self._show_search_dialog(activity, term, provider_override)
                    return HookResult(strategy=HookStrategy.CANCEL, params=params)

            return HookResult()
        except Exception:
            return HookResult()

    def _show_provider_select_sheet(self):
        # Mostra BottomSheet para selecionar provedor de busca
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)

            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(self._t("select_provider_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            providers = [
                "Google", "Bing", "DuckDuckGo", "Yahoo", "Yandex", "Brave", "Ecosia", "Startpage", "Qwant", "Custom"
            ]

            # Lista de itens clicáveis
            for i, name in enumerate(providers):
                item = SimpleTextView(ctx)
                item.setText(name)
                item.setTextSize(16)
                try:
                    item.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                except Exception:
                    pass
                item.setGravity(Gravity.START | Gravity.CENTER_VERTICAL)

                def make_click(index, prov_name):
                    def _on_click(v):
                        try:
                            self.set_setting("search_provider", index)
                            try:
                                BulletinHelper.show_success(self._t("provider_selected").format(name=prov_name))
                            except Exception:
                                pass
                            try:
                                sheet.dismiss()
                            except Exception:
                                pass
                        except Exception:
                            pass
                    return OnClickListener(_on_click)

                item.setOnClickListener(make_click(i, name))
                container.addView(item, LayoutHelper.createLinear(-1, 48, Gravity.TOP, 24, 4, 24, 4))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _open_plugin_settings(self):
        try:
            def present():
                try:
                    plugin = PluginsController.getInstance().plugins.get(self.id)
                    fragment = get_last_fragment()
                    if fragment is not None:
                        fragment.presentFragment(PluginSettingsActivity(plugin))
                        return
                except Exception as e:
                    try:
                        BulletinHelper.show_error(f"{self._t('panel_open_error')}: {e}")
                    except Exception:
                        pass

            run_on_ui_thread(present)
        except Exception:
            try:
                BulletinHelper.show_error(self._t("panel_open_error"))
            except Exception:
                pass

    def on_plugin_unload(self):
        try:
            if self.hook_fill_action_mode_menu_ref:
                self.unhook_method(self.hook_fill_action_mode_menu_ref)
                self.hook_fill_action_mode_menu_ref = None
            if self.hook_perform_menu_action_ref:
                self.unhook_method(self.hook_perform_menu_action_ref)
                self.hook_perform_menu_action_ref = None
            if self.hook_message_text_touch_ref:
                self.unhook_method(self.hook_message_text_touch_ref)
                self.hook_message_text_touch_ref = None
        except Exception:
            pass

    def _hook_formatting_menu(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            EditTextCaption = find_class("org.telegram.ui.Components.EditTextCaption")
            if ChatActivity is None or EditTextCaption is None:
                return

            boolean_type = find_class("java.lang.Boolean").TYPE
            fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod(
                "fillActionModeMenu",
                find_class("android.view.Menu"),
                jclass("org.telegram.tgnet.TLRPC$EncryptedChat"),
                boolean_type,
            )
            fillActionModeMenu_method.setAccessible(True)

            performMenuAction_method = EditTextCaption.getClass().getDeclaredMethod(
                "performMenuAction",
                find_class("java.lang.Integer").TYPE,
            )
            performMenuAction_method.setAccessible(True)

            self.hook_fill_action_mode_menu_ref = self.hook_method(
                fillActionModeMenu_method, SearchItActionModeMenuHook(self)
            )
            self.hook_perform_menu_action_ref = self.hook_method(
                performMenuAction_method, SearchItPerformMenuActionHook(self)
            )
        except Exception:
            pass

    def _toggle_formatting_menu(self, enabled: bool):
        # Alterna a integração no menu de formatação
        try:
            if enabled:
                self._hook_formatting_menu()
            else:
                try:
                    if self.hook_fill_action_mode_menu_ref:
                        self.unhook_method(self.hook_fill_action_mode_menu_ref)
                        self.hook_fill_action_mode_menu_ref = None
                except Exception:
                    pass
                try:
                    if self.hook_perform_menu_action_ref:
                        self.unhook_method(self.hook_perform_menu_action_ref)
                        self.hook_perform_menu_action_ref = None
                except Exception:
                    pass
        except Exception:
            pass

    def _build_search_url(self, query: str) -> str:
        # Subcomandos diretos: YouTube (yr) e VK Vídeo (vk)
        try:
            qraw = str(query or "")
            lower = qraw.lower().strip()
            if lower.startswith("yr ") or lower.startswith("youtube "):
                term = qraw.split(None, 1)[1] if len(qraw.split(None, 1)) > 1 else ""
                term = term.lstrip("+").strip()
                qq = urllib.parse.quote_plus(term)
                if term:
                    return f"https://www.youtube.com/results?search_query={qq}"
            if lower.startswith("vk ") or lower.startswith("vkvideo ") or lower.startswith("vk vídeo "):
                term = qraw.split(None, 1)[1] if len(qraw.split(None, 1)) > 1 else ""
                term = term.lstrip("+").strip()
                qq = urllib.parse.quote_plus(term)
                if term:
                    return f"https://vk.com/video?q={qq}"
        except Exception:
            pass
        providers = [
            "Google",
            "Bing",
            "DuckDuckGo",
            "Yahoo",
            "Yandex",
            "Brave",
            "Ecosia",
            "Startpage",
            "Qwant",
            "Custom",
        ]
        provider = self.get_setting("search_provider", 0)
        try:
            if isinstance(provider, int):
                provider_name = providers[provider] if 0 <= provider < len(providers) else "Google"
            else:
                provider_name = provider if provider in providers else "Google"
        except Exception:
            provider_name = "Google"

        q = urllib.parse.quote_plus(query)
        if provider_name == "Google":
            return f"https://www.google.com/search?q={q}"
        if provider_name == "Bing":
            return f"https://www.bing.com/search?q={q}"
        if provider_name == "DuckDuckGo":
            return f"https://duckduckgo.com/?q={q}"
        if provider_name == "Yahoo":
            return f"https://search.yahoo.com/search?p={q}"
        if provider_name == "Yandex":
            return f"https://yandex.com/search/?text={q}"
        if provider_name == "Brave":
            return f"https://search.brave.com/search?q={q}"
        if provider_name == "Ecosia":
            return f"https://www.ecosia.org/search?q={q}"
        if provider_name == "Startpage":
            return f"https://www.startpage.com/do/search?q={q}"
        if provider_name == "Qwant":
            return f"https://www.qwant.com/?q={q}"

        # Custom
        pattern = self.get_setting("custom_search_url", "")
        try:
            if pattern and "{q}" in pattern:
                return pattern.replace("{q}", q)
            if pattern:
                sep = "&" if "?" in pattern else "?"
                return f"{pattern}{sep}q={q}"
        except Exception:
            pass
        return f"https://www.google.com/search?q={q}"

    def _resolve_drawable_id(self, name: str) -> int:
        try:
            ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
            ctx = ApplicationLoader.applicationContext if ApplicationLoader else None
            if ctx is None:
                return 0
            res = ctx.getResources()
            pkg = ctx.getPackageName()
            return res.getIdentifier(name, "drawable", pkg)
        except Exception:
            return 0

    def _show_search_dialog(self, activity, query: str, provider_override: str = None):
        if activity is None or query is None or not str(query).strip():
            return

        # Adicionar ao histórico de pesquisas
        try:
            provider_name = "Google"  # Default
            if provider_override == "youtube":
                provider_name = "YouTube"
            elif provider_override == "vkvideo":
                provider_name = "VK Video"
            elif provider_override == "tiktok":
                provider_name = "TikTok"
            elif provider_override == "twitter":
                provider_name = "Twitter"
            else:
                # Obter nome do provider das configurações
                try:
                    provider_items = ["Google", "Bing", "DuckDuckGo", "Yahoo", "Yandex", "Brave", "Ecosia", "Startpage", "Qwant", "Custom"]
                    provider_index = self.get_setting("search_provider", 0)
                    if isinstance(provider_index, int) and 0 <= provider_index < len(provider_items):
                        provider_name = provider_items[provider_index]
                except Exception:
                    pass
            
            self._add_to_search_history(query, provider_name)
        except Exception:
            pass

        # Verificar se deve usar navegador nativo
        try:
            use_native_browser = self.get_setting("use_native_browser", False)
            if use_native_browser and ApplicationLoader and Browser:
                # Construir URL de pesquisa
                url = None
                try:
                    if provider_override == "youtube":
                        url = f"https://www.youtube.com/results?search_query={urllib.parse.quote_plus(query)}"
                    elif provider_override == "vkvideo":
                        url = f"https://vk.com/video?q={urllib.parse.quote_plus(query)}"
                    else:
                        url = self._build_search_url(query)
                except Exception:
                    url = self._build_search_url(query)
                
                # Abrir no navegador nativo
                try:
                    app_context = ApplicationLoader.applicationContext
                    if app_context:
                        run_on_ui_thread(lambda: Browser.openUrl(app_context, url))
                        return  # Sair da função após abrir no navegador nativo
                except Exception as e:
                    # Se falhar, continuar com WebView normal
                    pass
        except Exception:
            pass

        try:
            builder = AlertDialogBuilder(activity)
            builder.set_title(self._t("search_title"))

            # Se janela flutuante estiver habilitada, usar overlay em vez de diálogo
            try:
                if self.get_setting("floating_window_mode", False):
                    # Respeitar override direto para YouTube/VK quando habilitado
                    url = None
                    try:
                        if provider_override == "youtube":
                            url = f"https://www.youtube.com/results?search_query={urllib.parse.quote_plus(query)}"
                        elif provider_override == "vkvideo":
                            url = f"https://vk.com/video?q={urllib.parse.quote_plus(query)}"
                    except Exception:
                        url = None
                    if not url:
                        url = self._build_search_url(query)
                    self._show_search_overlay(activity, url)
                    return
            except Exception:
                pass

            container = LinearLayout(activity)
            container.setOrientation(LinearLayout.VERTICAL)
            pad = AndroidUtilities.dp(12)
            container.setPadding(pad, pad, pad, pad)
            # Em fullscreen sem janela flutuante, remover padding para ocupar 100% da tela
            try:
                is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
            except Exception:
                is_fullscreen = False
            try:
                is_floating = bool(self.get_setting("floating_window_mode", False))
            except Exception:
                is_floating = False
            try:
                if is_fullscreen and not is_floating:
                    container.setPadding(0, 0, 0, 0)
            except Exception:
                pass
            # Garantir que o contêiner permita foco para entrada de texto
            try:
                container.setFocusable(True)
                container.setFocusableInTouchMode(True)
            except Exception:
                pass

            # Fake input oculto para acionar IME de forma confiável
            try:
                fake_input = EditText(activity)
                fake_input.setHint("...")
                # Permitir que o EditText receba foco mesmo oculto
                try:
                    fake_input.setFocusable(True)
                    fake_input.setFocusableInTouchMode(True)
                except Exception:
                    pass
                # Padrão do Surfee (alpha version): manter GONE e apenas pedir foco após show()
                fake_input.setVisibility(8)  # GONE
                container.addView(fake_input)
            except Exception:
                fake_input = None

            webview = WebView(activity)
            try:
                webview.getSettings().setJavaScriptEnabled(True)
            except Exception:
                pass
            # Política de histórico/cache conforme configuração
            try:
                history_enabled = bool(self.get_setting("history_enabled", True))
            except Exception:
                history_enabled = True
            # WebViewClient com callback para abrir o teclado após carregar a página
            try:
                plugin_self = self  # capturar instância do plugin para persistir URL
                he = history_enabled
                class SearchItWebViewClient(dynamic_proxy(WebViewClient)):
                    def __init__(self, wv):
                        self._wv = wv
                    def onPageFinished(self, view, url):
                        try:
                            # Persistir última URL visitada para .open
                            try:
                                plugin_self._save_last_url(url)
                            except Exception:
                                pass
                            # Se histórico estiver desativado, limpar histórico após carregar
                            try:
                                if not he:
                                    view.clearHistory()
                            except Exception:
                                pass
                            view.requestFocus()
                            # Atraso maior para garantir que a página terminou de preparar inputs
                            run_on_ui_thread(lambda: AndroidUtilities.showKeyboard(view), delay=200)
                            # Forçar foco no primeiro campo de entrada via JS
                            try:
                                view.evaluateJavascript("document.querySelector('input, textarea, [contenteditable]')?.focus();", None)
                            except Exception:
                                pass
                        except Exception:
                            pass
                webview.setWebViewClient(SearchItWebViewClient(webview))
            except Exception:
                try:
                    webview.setWebViewClient(WebViewClient())
                except Exception:
                    pass
            webview.setFocusable(True)
            webview.setFocusableInTouchMode(True)
            # Solicitar foco ao WebView para permitir teclado
            try:
                webview.requestFocus()
                webview.requestFocusFromTouch()
            except Exception:
                pass
            try:
                def _on_click(v):
                    try:
                        v.requestFocus()
                    except Exception:
                        pass
                    try:
                        AndroidUtilities.showKeyboard(v)
                    except Exception:
                        pass
                webview.setOnClickListener(OnClickListener(_on_click))
            except Exception:
                pass
            # Mostrar teclado quando o WebView ganha foco
            try:
                OnFocusChangeListenerCls = find_class("android.view.View$OnFocusChangeListener")
                class SearchItFocusListener(dynamic_proxy(OnFocusChangeListenerCls)):
                    def onFocusChange(self, v, hasFocus):
                        try:
                            if hasFocus:
                                v.requestFocus()
                                AndroidUtilities.showKeyboard(v)
                        except Exception:
                            pass
                webview.setOnFocusChangeListener(SearchItFocusListener())
            except Exception:
                pass
            # Habilitar DOM Storage para compatibilidade com inputs modernos
            try:
                webview.getSettings().setDomStorageEnabled(True)
            except Exception:
                pass
            # Aplicar modo de cache conforme histórico
            try:
                webview.getSettings().setCacheMode(0 if history_enabled else 2)  # 0: DEFAULT, 2: NO_CACHE
            except Exception:
                pass
            # Se histórico desativado, limpar cache/histórico antes de carregar
            try:
                if not history_enabled:
                    webview.clearCache(True)
                    webview.clearHistory()
            except Exception:
                pass
            # Forçar foco e teclado ao tocar dentro do WebView (inclui campos de input)
            try:
                # Listener correto para toque, garantindo foco e teclado
                OnTouchListenerCls = find_class("android.view.View$OnTouchListener")
                MotionEvent = find_class("android.view.MotionEvent")
                ACTION_UP = MotionEvent.ACTION_UP if MotionEvent is not None else 1
                class SearchItTouchListener(dynamic_proxy(OnTouchListenerCls)):
                    def onTouch(self, v, event):
                        try:
                            v.requestFocus()
                        except Exception:
                            pass
                        try:
                            AndroidUtilities.showKeyboard(v)
                        except Exception:
                            pass
                        # Focar o primeiro input via JS após o toque
                        try:
                            if event is not None and event.getAction() == ACTION_UP:
                                v.evaluateJavascript("document.querySelector('input, textarea, [contenteditable]')?.focus();", None)
                        except Exception:
                            pass
                        return False
                webview.setOnTouchListener(SearchItTouchListener())
            except Exception:
                try:
                    # Fallback simples
                    def _on_touch(v, event):
                        try:
                            v.requestFocus()
                        except Exception:
                            pass
                        try:
                            AndroidUtilities.showKeyboard(v)
                        except Exception:
                            pass
                        return False
                    webview.setOnTouchListener(OnTouchListener(_on_touch))
                except Exception:
                    pass

            # Construir URL respeitando override direto (YouTube/VK) quando aplicável
            url = None
            try:
                if provider_override == "youtube":
                    url = f"https://www.youtube.com/results?search_query={urllib.parse.quote_plus(query)}"
                elif provider_override == "vkvideo":
                    url = f"https://vk.com/video?q={urllib.parse.quote_plus(query)}"
            except Exception:
                url = None
            if not url:
                url = self._build_search_url(query)
            webview.loadUrl(url)

            # Ajustar altura conforme Tela Cheia
            try:
                is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
            except Exception:
                is_fullscreen = False
            container.addView(webview, LinearLayout.LayoutParams(-1, (-1 if is_fullscreen else AndroidUtilities.dp(600))))

            builder.set_view(container)
            # Adotar exatamente o padrão Surfee: show() e configurar IME depois
            dialog = builder.show()
            try:
                w = dialog.getWindow() if dialog else None
                if w is not None:
                    WindowManagerLayoutParams = find_class("android.view.WindowManager$LayoutParams")
                    if WindowManagerLayoutParams is not None:
                        try:
                            w.clearFlags(WindowManagerLayoutParams.FLAG_ALT_FOCUSABLE_IM)
                        except Exception:
                            pass
                        w.setSoftInputMode(
                            WindowManagerLayoutParams.SOFT_INPUT_ADJUST_RESIZE |
                            WindowManagerLayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE
                        )
                        # Tela cheia: ajustar tamanho da janela para ocupar a tela
                        try:
                            if is_fullscreen:
                                w.setLayout(-1, -1)
                        except Exception:
                            pass
                        # Em fullscreen sem janela flutuante, garantir flags para ocupar toda a tela
                        try:
                            if is_fullscreen and not bool(self.get_setting("floating_window_mode", False)):
                                try:
                                    w.addFlags(
                                        WindowManagerLayoutParams.FLAG_LAYOUT_IN_SCREEN |
                                        WindowManagerLayoutParams.FLAG_LAYOUT_NO_LIMITS |
                                        WindowManagerLayoutParams.FLAG_FULLSCREEN
                                    )
                                except Exception:
                                    pass
                                # Ocultar barras do sistema para experiência truly fullscreen
                                try:
                                    ViewCls = find_class("android.view.View")
                                    decor = w.getDecorView()
                                    if ViewCls and decor:
                                        decor.setSystemUiVisibility(
                                            ViewCls.SYSTEM_UI_FLAG_LAYOUT_STABLE |
                                            ViewCls.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |
                                            ViewCls.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN |
                                            ViewCls.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
                                            ViewCls.SYSTEM_UI_FLAG_FULLSCREEN |
                                            ViewCls.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                                        )
                                except Exception:
                                    pass
                        except Exception:
                            pass
            except Exception:
                pass
            # Focar o fake_input para garantir abertura do teclado
            try:
                if fake_input:
                    fake_input.post(lambda: fake_input.requestFocus())
            except Exception:
                pass
            # (Sem chamadas extras ao teclado aqui; seguimos o comportamento simples do Surfee)
            except Exception:
                pass
            return dialog
        except Exception:
            pass

    # Abrir um diálogo com uma URL direta (usado por .open)
    def _show_url_dialog(self, activity, url: str):
        if activity is None or url is None or not str(url).strip():
            return
        try:
            builder = AlertDialogBuilder(activity)
            builder.set_title(self._t("search_title"))

            container = LinearLayout(activity)
            container.setOrientation(LinearLayout.VERTICAL)
            pad = AndroidUtilities.dp(12)
            container.setPadding(pad, pad, pad, pad)
            # Em fullscreen sem janela flutuante, remover padding para ocupar 100% da tela
            try:
                is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
            except Exception:
                is_fullscreen = False
            try:
                is_floating = bool(self.get_setting("floating_window_mode", False))
            except Exception:
                is_floating = False
            try:
                if is_fullscreen and not is_floating:
                    container.setPadding(0, 0, 0, 0)
            except Exception:
                pass

            wv = WebView(activity)
            try:
                wv.getSettings().setJavaScriptEnabled(True)
                wv.getSettings().setDomStorageEnabled(True)
            except Exception:
                pass
            # Política de histórico/cache
            try:
                history_enabled = bool(self.get_setting("history_enabled", True))
            except Exception:
                history_enabled = True
            try:
                wv.getSettings().setCacheMode(0 if history_enabled else 2)
            except Exception:
                pass
            try:
                if not history_enabled:
                    wv.clearCache(True)
                    wv.clearHistory()
            except Exception:
                pass

            # Client para persistir última URL
            try:
                plugin_self = self
                he = history_enabled
                class _DirectWebClient(dynamic_proxy(WebViewClient)):
                    def onPageFinished(self, view, u):
                        try:
                            plugin_self._save_last_url(u)
                        except Exception:
                            pass
                            if not he:
                                try:
                                    view.clearHistory()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                wv.setWebViewClient(_DirectWebClient())
            except Exception:
                try:
                    wv.setWebViewClient(WebViewClient())
                except Exception:
                    pass

            try:
                wv.loadUrl(url)
            except Exception:
                pass

            # Persistir imediatamente a URL carregada para garantir independência de modo
            try:
                self._last_url = url
                try:
                    self.set_setting("searchit_last_url", url)
                except Exception:
                    pass
            except Exception:
                pass

            try:
                container.addView(wv, LinearLayout.LayoutParams(-1, (-1 if is_fullscreen else AndroidUtilities.dp(600))))
            except Exception:
                pass
            
            # Persistir imediatamente a URL carregada para garantir independência de modo
            try:
                self._save_last_url(url)
            except Exception:
                pass
            
            dialog = None
            return dialog
        except Exception:
            pass

    def _show_search_overlay(self, activity, url: str):
        try:
            ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
            ctx = ApplicationLoader.applicationContext if ApplicationLoader else None
            if ctx is None:
                return
            # Se já existe overlay visível, encerre antes de criar outro
            try:
                if self._overlay_visible and self._overlay_root is not None:
                    self._hide_search_overlay()
            except Exception:
                pass
            WindowManager = find_class("android.view.WindowManager")
            LayoutParams = find_class("android.view.WindowManager$LayoutParams")
            Gravity = find_class("android.view.Gravity")
            ThemeCls = find_class("org.telegram.ui.ActionBar.Theme")
            TextView = find_class("android.widget.TextView")
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            ColorCls = find_class("android.graphics.Color")
            if WindowManager is None or LayoutParams is None:
                return

            # Usar WindowManager da Activity quando possível (melhora IME em overlays)
            wm = (activity.getSystemService("window") if activity else ctx.getSystemService("window"))
            if wm is None:
                return
            try:
                self._overlay_wm = wm
            except Exception:
                pass

            # Root
            root = LinearLayout(ctx)
            root.setOrientation(LinearLayout.VERTICAL)
            pad = AndroidUtilities.dp(10)
            root.setPadding(pad, pad, pad, pad)
            # Evitar disputa de foco: o overlay não deve pegar foco
            try:
                root.setFocusable(False)
                root.setFocusableInTouchMode(False)
            except Exception:
                pass
            # Fundo com estilo de cartão para organizar visualmente
            try:
                bg = GradientDrawable()
                bg.setShape(GradientDrawable.RECTANGLE)
                card_color = ThemeCls.getColor(ThemeCls.key_windowBackgroundWhite) if ThemeCls else 0xFFFFFFFF
                stroke_color = ThemeCls.getColor(ThemeCls.key_divider) if ThemeCls else 0x33000000
                bg.setColor(card_color)
                bg.setCornerRadius(float(AndroidUtilities.dp(12)))
                bg.setStroke(int(AndroidUtilities.dp(1)), stroke_color)
                root.setBackground(bg)
                # Guardar fundo e padding originais para restaurar ao expandir
                try:
                    self._overlay_bg = bg
                    self._overlay_pad = pad
                except Exception:
                    pass
            except Exception:
                pass

            # Header com ações
            header = LinearLayout(ctx)
            header.setOrientation(LinearLayout.HORIZONTAL)
            try:
                header.setPadding(pad, pad, pad, pad)
            except Exception:
                pass
            # Centralizar por padrão (horizontal e vertical)
            try:
                header.setGravity(Gravity.CENTER)
            except Exception:
                pass

            # Helper para criar botão conforme modo de exibição escolhido
            def make_icon_btn(icon_name, on_click, fallback_text=None, label_text=None):
                try:
                    mode = int(self.get_setting("overlay_buttons_mode", 0) or 0)
                except Exception:
                    mode = 0
                label = label_text if label_text is not None else (fallback_text if fallback_text is not None else "?")

                container = LinearLayout(ctx)
                try:
                    container.setOrientation(LinearLayout.HORIZONTAL)
                    container.setGravity(Gravity.CENTER_VERTICAL)
                except Exception:
                    pass

                iv = ImageView(ctx)
                rid = 0
                try:
                    rid = self._resolve_drawable_id(icon_name) if icon_name else 0
                except Exception:
                    rid = 0
                try:
                    if rid:
                        iv.setImageResource(rid)
                        iv.setScaleType(ImageView.ScaleType.CENTER_INSIDE)
                        iv.setAdjustViewBounds(True)
                        accent = ThemeCls.getColor(ThemeCls.key_dialogButtonBlue) if ThemeCls else 0xFF3D8BF7
                        iv.setColorFilter(accent)
                        p = AndroidUtilities.dp(8)
                        iv.setPadding(p, p, p, p)
                except Exception:
                    pass

                tv = TextView(ctx)
                try:
                    tv.setText(label)
                    tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                    accent = ThemeCls.getColor(ThemeCls.key_dialogButtonBlue) if ThemeCls else 0xFF3D8BF7
                    tv.setTextColor(accent)
                    tv.setSingleLine(True)
                    tv.setMaxLines(1)
                    # Evitar corte de descendentes (ex.: "d") e quebra de linha
                    tv.setIncludeFontPadding(True)
                    try:
                        TextUtils = find_class("android.text.TextUtils")
                        if TextUtils is not None:
                            tv.setEllipsize(TextUtils.TruncateAt.END)
                    except Exception:
                        pass
                    tv.setPadding(AndroidUtilities.dp(6), AndroidUtilities.dp(8), AndroidUtilities.dp(6), AndroidUtilities.dp(8))
                except Exception:
                    pass

                # Visibilidade conforme modo: 0=ícones, 1=ícone+noms, 2=nomes
                try:
                    if mode == 0:
                        if rid:
                            tv.setVisibility(8)
                        else:
                            tv.setVisibility(0)
                            iv.setVisibility(8)
                    elif mode == 1:
                        iv.setVisibility(0 if rid else 8)
                        tv.setVisibility(0)
                    else:
                        tv.setVisibility(0)
                        iv.setVisibility(8)
                except Exception:
                    pass

                try:
                    container.addView(iv, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, 0, 0, 0, 0))
                    # Espaço pequeno entre ícone e nome (6dp)
                    container.addView(tv, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, AndroidUtilities.dp(6), 0, 0, 0))
                except Exception:
                    pass
                try:
                    container.setOnClickListener(OnClickListener(on_click))
                except Exception:
                    pass
                return container

            # Botão Minimizar com ícone
            btn_min = make_icon_btn("zoom_minus", lambda v: None, fallback_text=self._t("overlay_minimize"), label_text=self._t("overlay_minimize"))

            # Estilização tipo "chip" dos botões
            def _style_btn(tv):
                try:
                    tv.setIncludeFontPadding(False)
                    tv.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(6), AndroidUtilities.dp(12), AndroidUtilities.dp(6))
                    tv.setMinimumHeight(AndroidUtilities.dp(32))
                    tv.setSingleLine(True)
                    tv.setMaxLines(1)
                except Exception:
                    pass
                try:
                    btn_bg = GradientDrawable()
                    btn_bg.setShape(GradientDrawable.RECTANGLE)
                    accent = ThemeCls.getColor(ThemeCls.key_dialogButtonBlue) if ThemeCls else 0xFF3D8BF7
                    # Estilo de borda (outline): sem preenchimento, apenas stroke
                    try:
                        btn_bg.setColor(0x00FFFFFF)
                    except Exception:
                        pass
                    try:
                        btn_bg.setStroke(int(AndroidUtilities.dp(1)), accent)
                    except Exception:
                        pass
                    btn_bg.setCornerRadius(float(AndroidUtilities.dp(16)))
                    tv.setBackground(btn_bg)
                    # Texto na cor de destaque para combinar com a borda
                    try:
                        tv.setTextColor(accent)
                    except Exception:
                        pass
                except Exception:
                    pass

            try:
                _style_btn(btn_min)
            except Exception:
                pass

            # Botões de navegação com ícones
            btn_back = make_icon_btn("msg_arrow_back", lambda v: None, fallback_text=self._t("overlay_back"), label_text=self._t("overlay_back"))
            btn_forward = make_icon_btn("msg_arrow_forward", lambda v: None, fallback_text=self._t("overlay_forward"), label_text=self._t("overlay_forward"))

            # Bolha circular com fundo visível: container + ícone
            bubble_container = FrameLayout(ctx)
            try:
                # Fundo circular no container para garantir a forma
                bubble_bg = GradientDrawable()
                try:
                    bubble_bg.setShape(GradientDrawable.OVAL)
                except Exception:
                    bubble_bg.setShape(GradientDrawable.RECTANGLE)
                    bubble_bg.setCornerRadius(float(AndroidUtilities.dp(28)))
                try:
                    accent = ThemeCls.getColor(ThemeCls.key_dialogButtonBlue) if ThemeCls else 0xFF3D8BF7
                    # Cor fixa do orbe: branco
                    bubble_bg.setColor(0xFFFFFFFF)
                    try:
                        bubble_bg.setStroke(int(AndroidUtilities.dp(2)), accent)
                    except Exception:
                        pass
                except Exception:
                    pass
                bubble_container.setBackground(bubble_bg)
                # Ícone/Sticker dentro do container (usa o mesmo ícone do plugin)
                iv_bubble = ImageView(ctx)
                try:
                    icon_name = __icon__ if '__icon__' in globals() else None
                    res_id = self._resolve_drawable_id(icon_name) if icon_name else 0
                    if not res_id:
                        # Fallback para um ícone nativo caso __icon__ não mapeie para drawable
                        res_id = self._resolve_drawable_id("msg_search_remix") or self._resolve_drawable_id("msg_info_remix")
                    if res_id:
                        iv_bubble.setImageResource(res_id)
                        try:
                            iv_bubble.setScaleType(ImageView.ScaleType.CENTER_INSIDE)
                            iv_bubble.setAdjustViewBounds(True)
                        except Exception:
                            pass
                except Exception:
                    pass
                bubble_container.addView(iv_bubble, LayoutHelper.createFrame(-1, -1, Gravity.CENTER))
                # Inicialmente oculto; será mostrado somente quando minimizado
                bubble_container.setVisibility(8)
            except Exception:
                pass

            # Ordem: bolha, <, Minimize, Close, >
            header.addView(bubble_container, LayoutHelper.createLinear(AndroidUtilities.dp(12), AndroidUtilities.dp(12), Gravity.CENTER_VERTICAL, 0, 0, 12, 0))
            # Ordem: <, Minimize, Close, > (margens consistentes)
            header.addView(btn_back, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, 0, 0, 12, 0))
            header.addView(btn_min, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, 0, 0, 12, 0))

            # Botão de fechar overlay com ícone
            btn_close = make_icon_btn("ic_layer_close", lambda v: None, fallback_text=self._t("overlay_close"), label_text=self._t("overlay_close"))
            header.addView(btn_close, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, 0, 0, 12, 0))
            header.addView(btn_forward, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_VERTICAL, 0, 0, 0, 0))
            root.addView(header, LayoutHelper.createLinear(-1, -2))

            content = LinearLayout(ctx)
            content.setOrientation(LinearLayout.VERTICAL)
            root.addView(content, LayoutHelper.createLinear(-1, -2))


            # Ações: abrir conteúdo ao expandir
            def open_webview(_):
                try:
                    # Ocultar bolha e mostrar chips ao abrir resultados
                    try:
                        bubble_container.setVisibility(8)
                        btn_min.setVisibility(0)
                        btn_close.setVisibility(0)
                    except Exception:
                        pass
                    # Garantir que os botões de navegação estejam visíveis ao abrir
                    try:
                        btn_back.setVisibility(0)
                        btn_forward.setVisibility(0)
                    except Exception:
                        pass
                    if self._overlay_webview is None:
                        # Criar WebView com contexto da Activity para melhor integração com IME
                        wv = WebView(activity if activity else ctx)
                        try:
                            wv.getSettings().setJavaScriptEnabled(True)
                            wv.getSettings().setDomStorageEnabled(True)
                            # Política de histórico/cache
                            try:
                                he = bool(self.get_setting("history_enabled", True))
                            except Exception:
                                he = True
                            try:
                                wv.getSettings().setCacheMode(0 if he else 2)
                            except Exception:
                                pass
                            try:
                                if not he:
                                    wv.clearCache(True)
                                    wv.clearHistory()
                            except Exception:
                                pass
                            # Manter navegação dentro do WebView: definir WebViewClient
                            try:
                                plugin_self = self
                                class _OverlayClient(dynamic_proxy(WebViewClient)):
                                    def onPageFinished(self, view, u):
                                        try:
                                            plugin_self._save_last_url(u)
                                        except Exception:
                                            pass
                                            if not he:
                                                try:
                                                    view.clearHistory()
                                                except Exception:
                                                    pass
                                        except Exception:
                                            pass
                                wv.setWebViewClient(_OverlayClient())
                            except Exception:
                                try:
                                    wv.setWebViewClient(WebViewClient())
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        wv.loadUrl(url)
                        try:
                            is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
                        except Exception:
                            is_fullscreen = False
                        content.addView(wv, LinearLayout.LayoutParams((-1 if is_fullscreen else AndroidUtilities.dp(360)), (-1 if is_fullscreen else AndroidUtilities.dp(500))))
                        self._overlay_webview = wv
                        self._overlay_collapsed = False
                        # Ao abrir resultados, garantir que o container de conteúdo esteja visível
                        try:
                            content.setVisibility(0)
                        except Exception:
                            pass
                        # Permitir foco/IME na WebView
                        try:
                            wv.setFocusable(True)
                            wv.setFocusableInTouchMode(True)
                            wv.requestFocus()
                            wv.requestFocusFromTouch()
                        except Exception:
                            pass
                        # Expandir a janela e torná-la focável para digitar
                        try:
                            lp2 = self._overlay_lp or lp
                            lp2.width = (-1 if is_fullscreen else -2)
                            lp2.height = (-1 if is_fullscreen else -2)
                            # Focável: não usar ALT_FOCUSABLE_IM
                            lp2.flags = (
                                LayoutParams.FLAG_LAYOUT_IN_SCREEN |
                                LayoutParams.FLAG_NOT_TOUCH_MODAL
                            )
                            try:
                                lp2.softInputMode = (
                                    LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
                                    LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE
                                )
                            except Exception:
                                pass
                            # Restaurar fundo e padding originais ao expandir
                            try:
                                if getattr(self, "_overlay_bg", None):
                                    root.setBackground(self._overlay_bg)
                                p = getattr(self, "_overlay_pad", AndroidUtilities.dp(10))
                                if is_fullscreen:
                                    root.setPadding(0, 0, 0, 0)
                                else:
                                    root.setPadding(p, p, p, p)
                            except Exception:
                                pass
                            wm.updateViewLayout(self._overlay_root, lp2)
                        except Exception:
                            pass
                    else:
                        try:
                            self._overlay_webview.setVisibility(0)
                            # Ao reabrir os resultados, voltar a mostrar o botão Minimize
                            try:
                                btn_min.setVisibility(0)
                            except Exception:
                                pass
                            # Evitar refresh ao reabrir: não chamar reload no WebView
                            self._overlay_collapsed = False
                            # Tornar o container de conteúdo visível novamente
                            try:
                                content.setVisibility(0)
                            except Exception:
                                pass
                            # Reajustar tamanho e permitir foco/IME ao abrir resultados
                            try:
                                is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
                            except Exception:
                                is_fullscreen = False
                            try:
                                lp2 = self._overlay_lp or lp
                                lp2.width = (-1 if is_fullscreen else -2)
                                lp2.height = (-1 if is_fullscreen else -2)
                                lp2.flags = (
                                    LayoutParams.FLAG_LAYOUT_IN_SCREEN |
                                    LayoutParams.FLAG_NOT_TOUCH_MODAL
                                )
                                try:
                                    lp2.softInputMode = (
                                        LayoutParams.SOFT_INPUT_ADJUST_RESIZE |
                                        LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE
                                    )
                                except Exception:
                                    pass
                                # Restaurar fundo e padding ao expandir; remover padding em fullscreen
                                try:
                                    if getattr(self, "_overlay_bg", None):
                                        root.setBackground(self._overlay_bg)
                                    p = getattr(self, "_overlay_pad", AndroidUtilities.dp(10))
                                    if is_fullscreen:
                                        root.setPadding(0, 0, 0, 0)
                                    else:
                                        root.setPadding(p, p, p, p)
                                except Exception:
                                    pass
                                wm.updateViewLayout(self._overlay_root, lp2)
                            except Exception:
                                pass
                        except Exception:
                            pass
                except Exception:
                    pass

            def toggle_minimize(_):
                try:
                    if self._overlay_webview is not None:
                        # Apenas ocultar; reabrir só com "Results"
                        self._overlay_webview.setVisibility(8)
                        self._overlay_collapsed = True
                        # Esconder o chip Minimize enquanto estiver minimizado
                        try:
                            btn_min.setVisibility(8)
                            btn_back.setVisibility(8)
                            btn_forward.setVisibility(8)
                            btn_close.setVisibility(8)
                            bubble_container.setVisibility(0)
                            try:
                                bubble_container.bringToFront()
                            except Exception:
                                pass
                        except Exception:
                            pass
                        # Ocultar toda a área de conteúdo para não cobrir o app por trás
                        try:
                            content.setVisibility(8)
                        except Exception:
                            pass
                        # Deixar root sem fundo e sem padding para destacar apenas a bolha
                        try:
                            root.setBackground(None)
                            root.setPadding(0, 0, 0, 0)
                        except Exception:
                            pass
                        # Reduzir a janela para envolver apenas o cabeçalho (menu flutuante)
                        try:
                            lp2 = self._overlay_lp or lp
                            lp2.width = -2
                            lp2.height = -2
                            # Posicionar próximo ao topo à direita, sem encostar
                            try:
                                lp2.gravity = Gravity.TOP | Gravity.LEFT
                                Point = find_class("android.graphics.Point")
                                disp = wm.getDefaultDisplay() if wm else None
                                pt = Point() if Point else None
                                if disp and pt:
                                    disp.getSize(pt)
                                    bubble = AndroidUtilities.dp(12)
                                    margin = AndroidUtilities.dp(16)
                                    extra_offset = AndroidUtilities.dp(4)
                                    extra_offset_y = AndroidUtilities.dp(48)
                                    lp2.x = max(0, int(pt.x - bubble - margin - extra_offset))
                                    lp2.y = max(0, AndroidUtilities.dp(100) + extra_offset_y)
                                # Ao minimizar, garantir que o overlay não capture foco/teclado
                                try:
                                    lp2.flags = (
                                        LayoutParams.FLAG_NOT_FOCUSABLE |
                                        LayoutParams.FLAG_LAYOUT_IN_SCREEN |
                                        LayoutParams.FLAG_NOT_TOUCH_MODAL
                                    )
                                    lp2.softInputMode = (
                                        LayoutParams.SOFT_INPUT_ADJUST_NOTHING |
                                        LayoutParams.SOFT_INPUT_STATE_UNCHANGED
                                    )
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            try:
                                wm.updateViewLayout(self._overlay_root, lp2)
                            except Exception:
                                pass
                        except Exception:
                            pass
                except Exception:
                    pass

            # Abrir resultados ao tocar na bolha
            try:
                bubble_container.setOnClickListener(OnClickListener(open_webview))
            except Exception:
                pass
            btn_min.setOnClickListener(OnClickListener(toggle_minimize))
            btn_close.setOnClickListener(OnClickListener(lambda v: self._hide_search_overlay()))
            # Navegação WebView
            def _do_back(_):
                try:
                    wv = self._overlay_webview
                    if wv is not None and wv.canGoBack():
                        wv.goBack()
                except Exception:
                    pass

            def _do_forward(_):
                try:
                    wv = self._overlay_webview
                    if wv is not None and wv.canGoForward():
                        wv.goForward()
                except Exception:
                    pass

            try:
                btn_back.setOnClickListener(OnClickListener(_do_back))
                btn_forward.setOnClickListener(OnClickListener(_do_forward))
            except Exception:
                pass
            # Não abrir resultados automaticamente (evita foco prematuro)

            # Layout params
            lp = LayoutParams()
            try:
                # Respeitar opção de tela cheia também no overlay
                try:
                    is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
                except Exception:
                    is_fullscreen = False
                lp.width = (-1 if is_fullscreen else -2)
                lp.height = (-1 if is_fullscreen else -2)
                lp.gravity = Gravity.CENTER
                try:
                    # Posição inicial
                    lp.x = 0
                    lp.y = 0
                except Exception:
                    pass
                # Estado inicial: não focável para não bloquear o teclado do app por trás
                lp.flags = (
                    LayoutParams.FLAG_NOT_FOCUSABLE |
                    LayoutParams.FLAG_LAYOUT_IN_SCREEN |
                    LayoutParams.FLAG_NOT_TOUCH_MODAL
                )
                try:
                    lp.softInputMode = (
                        LayoutParams.SOFT_INPUT_ADJUST_NOTHING |
                        LayoutParams.SOFT_INPUT_STATE_UNCHANGED
                    )
                except Exception:
                    pass
                lp.format = 1
                Build_VERSION = find_class("android.os.Build$VERSION")
                try:
                    # Preferir painel anexado ao token da Activity para IME funcionar
                    lp.type = LayoutParams.TYPE_APPLICATION_PANEL
                    lp.token = activity.getWindow().getDecorView().getWindowToken()
                except Exception:
                    if Build_VERSION and Build_VERSION.SDK_INT >= 26:
                        lp.type = LayoutParams.TYPE_APPLICATION_OVERLAY
                    else:
                        lp.type = LayoutParams.TYPE_PHONE
            except Exception:
                pass

            wm.addView(root, lp)
            self._overlay_root = root
            self._overlay_lp = lp
            self._overlay_header = header
            self._overlay_content = content
            self._overlay_visible = True

            # Pré-carregar a WebView em segundo plano para evitar lentidão no primeiro carregamento
            try:
                if self._overlay_webview is None:
                    wv = WebView(activity if activity else ctx)
                    try:
                        wv.getSettings().setJavaScriptEnabled(True)
                        wv.getSettings().setDomStorageEnabled(True)
                        try:
                            he = bool(self.get_setting("history_enabled", True))
                        except Exception:
                            he = True
                        try:
                            wv.getSettings().setCacheMode(0 if he else 2)
                        except Exception:
                            pass
                        try:
                            if not he:
                                wv.clearCache(True)
                                wv.clearHistory()
                        except Exception:
                            pass
                        try:
                            plugin_self = self
                            class _OverlayPreloadClient(dynamic_proxy(WebViewClient)):
                                def onPageFinished(self, view, u):
                                    try:
                                        plugin_self._save_last_url(u)
                                    except Exception:
                                        pass
                                        if not he:
                                            try:
                                                view.clearHistory()
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            wv.setWebViewClient(_OverlayPreloadClient())
                        except Exception:
                            try:
                                wv.setWebViewClient(WebViewClient())
                            except Exception:
                                pass
                    except Exception:
                        pass
                    try:
                        is_fullscreen = bool(self.get_setting("fullscreen_mode", False))
                    except Exception:
                        is_fullscreen = False
                    try:
                        content.addView(wv, LinearLayout.LayoutParams((-1 if is_fullscreen else AndroidUtilities.dp(360)), (-1 if is_fullscreen else AndroidUtilities.dp(500))))
                    except Exception:
                        pass
                    try:
                        wv.setVisibility(8)
                    except Exception:
                        pass
                    try:
                        wv.loadUrl(url)
                    except Exception:
                        pass
                    self._overlay_webview = wv
            except Exception:
                pass

            # Abrir resultados imediatamente ao anexar (não iniciar minimizado)
            try:
                run_on_ui_thread(lambda: open_webview(None))
            except Exception:
                pass

            # Tornar o overlay arrastável pelo cabeçalho
            try:
                MotionEvent = find_class("android.view.MotionEvent")
                ACTION_DOWN = MotionEvent.ACTION_DOWN if MotionEvent else 0
                ACTION_MOVE = MotionEvent.ACTION_MOVE if MotionEvent else 2

                def _on_header_touch(v, event):
                    try:
                        act = event.getAction()
                        if act == ACTION_DOWN:
                            self._initial_touch_x = int(event.getRawX())
                            self._initial_touch_y = int(event.getRawY())
                            return True
                        elif act == ACTION_MOVE:
                            dx = int(event.getRawX()) - getattr(self, "_initial_touch_x", int(event.getRawX()))
                            dy = int(event.getRawY()) - getattr(self, "_initial_touch_y", int(event.getRawY()))
                            self._initial_touch_x = int(event.getRawX())
                            self._initial_touch_y = int(event.getRawY())
                            lp2 = self._overlay_lp or lp
                            try:
                                lp2.x = int(lp2.x + dx)
                                lp2.y = int(lp2.y + dy)
                            except Exception:
                                pass
                            try:
                                wm.updateViewLayout(self._overlay_root, lp2)
                            except Exception:
                                pass
                            return True
                    except Exception:
                        pass
                    return False

                header.setOnTouchListener(OnTouchListener(_on_header_touch))
            except Exception:
                pass
        except Exception:
            pass

    def _hide_search_overlay(self):
        try:
            if self._overlay_root is not None and self._overlay_wm is not None:
                try:
                    self._overlay_wm.removeView(self._overlay_root)
                except Exception:
                    pass
            # Persistir última URL ao fechar overlay
            try:
                if self._overlay_webview is not None:
                    u = None
                    try:
                        u = self._overlay_webview.getUrl()
                    except Exception:
                        u = None
                    if u:
                        self._save_last_url(u)
            except Exception:
                pass
            self._overlay_root = None
            self._overlay_header = None
            self._overlay_content = None
            self._overlay_webview = None
            self._overlay_visible = False
            self._overlay_collapsed = False
        except Exception:
            pass

    def _open_chat_search_panel(self):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(self._t("search_title"))

            container = LinearLayout(activity)
            pad = AndroidUtilities.dp(12)
            container.setPadding(pad, pad, pad, pad)

            # Input field for query
            EditText = find_class("android.widget.EditText")
            if EditText is None:
                return
            query_input = EditText(activity)
            try:
                query_input.setHint(self._t("search_input_hint"))
            except Exception:
                pass
            # Ajustes de cor para modo escuro e claro (experimental, melhorias em progresso)
            try:
                Theme = find_class("org.telegram.ui.ActionBar.Theme")
                if Theme is not None:
                    # Cor do texto e do hint seguindo o tema atual
                    try:
                        query_input.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                    except Exception:
                        pass
                    try:
                        query_input.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
                    except Exception:
                        pass
            except Exception:
                pass

            # Parâmetros de layout
            lp_match = LinearLayout.LayoutParams(-1, -2)
            container.addView(query_input, lp_match)

            builder.set_view(container)

            # Botão positivo abre o diálogo de pesquisa
            builder.set_positive_button(self._t("menu_item_search"), lambda d, w: (self._show_search_dialog(activity, query_input.getText().toString()), d.dismiss()))

            builder.show()
        except Exception:
            pass

    def _add_chat_menu_item(self):
        try:
            # Evita duplicatas removendo o ID anterior salvo
            if hasattr(self, "chat_menu_item_id") and self.chat_menu_item_id:
                try:
                    self.remove_menu_item(self.chat_menu_item_id)
                except Exception:
                    pass

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text=self._t("menu_item_search"),
                icon="msg_search_remix",
                priority=5,
                on_click=lambda ctx: run_on_ui_thread(lambda: self._open_chat_search_panel())
            ))
            try:
                self.chat_menu_item_id = item_id
            except Exception:
                pass
        except Exception:
            pass

    def _toggle_chat_menu_item(self, enabled: bool):
        try:
            if enabled:
                self._add_chat_menu_item()
            else:
                if hasattr(self, "chat_menu_item_id") and self.chat_menu_item_id:
                    try:
                        self.remove_menu_item(self.chat_menu_item_id)
                    except Exception:
                        pass
                    self.chat_menu_item_id = None
        except Exception:
            pass

    def _add_context_menu_item(self):
        try:
            # Evita duplicatas
            if hasattr(self, "context_menu_item_id") and self.context_menu_item_id:
                try:
                    self.remove_menu_item(self.context_menu_item_id)
                except Exception:
                    pass

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=self._t("menu_item_search"),
                icon="menu_browser_search",
                on_click=lambda ctx: run_on_ui_thread(lambda: self._on_context_menu_click(ctx))
            ))
            try:
                self.context_menu_item_id = item_id
            except Exception:
                pass
        except Exception:
            pass

    def _toggle_context_menu_item(self, enabled: bool):
        try:
            if enabled:
                self._add_context_menu_item()
            else:
                if hasattr(self, "context_menu_item_id") and self.context_menu_item_id:
                    try:
                        self.remove_menu_item(self.context_menu_item_id)
                    except Exception:
                        pass
                    self.context_menu_item_id = None
        except Exception:
            pass

    # ----- Circle to Search integration -----
    def _add_circle_chat_menu_item(self):
        try:
            if hasattr(self, "circle_chat_menu_item_id") and self.circle_chat_menu_item_id:
                try:
                    self.remove_menu_item(self.circle_chat_menu_item_id)
                except Exception:
                    pass
            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text=self._t("ctc_menu_item"),
                icon="msg_search_remix",
                priority=6,
                on_click=lambda ctx: run_on_ui_thread(lambda: self._circle_trigger_from_chat_menu(ctx))
            ))
            try:
                self.circle_chat_menu_item_id = item_id
            except Exception:
                pass
        except Exception:
            pass

    def _circle_trigger_from_chat_menu(self, ctx=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            self._trigger_circle_to_search(activity)
        except Exception:
            pass

    def _toggle_circle_chat_menu_item(self, enabled: bool):
        try:
            if enabled:
                self._add_circle_chat_menu_item()
            else:
                if hasattr(self, "circle_chat_menu_item_id") and self.circle_chat_menu_item_id:
                    try:
                        self.remove_menu_item(self.circle_chat_menu_item_id)
                    except Exception:
                        pass
                    self.circle_chat_menu_item_id = None
        except Exception:
            pass

    def _add_circle_context_menu_item(self):
        try:
            if hasattr(self, "circle_context_menu_item_id") and self.circle_context_menu_item_id:
                try:
                    self.remove_menu_item(self.circle_context_menu_item_id)
                except Exception:
                    pass
            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=self._t("ctc_menu_item"),
                icon="menu_browser_search",
                on_click=lambda ctx: run_on_ui_thread(lambda: self._on_circle_context_menu_click(ctx))
            ))
            try:
                self.circle_context_menu_item_id = item_id
            except Exception:
                pass
        except Exception:
            pass

    def _toggle_circle_context_menu_item(self, enabled: bool):
        try:
            if enabled:
                self._add_circle_context_menu_item()
            else:
                if hasattr(self, "circle_context_menu_item_id") and self.circle_context_menu_item_id:
                    try:
                        self.remove_menu_item(self.circle_context_menu_item_id)
                    except Exception:
                        pass
                    self.circle_context_menu_item_id = None
        except Exception:
            pass

    def _on_circle_context_menu_click(self, ctx):
        try:
            activity = None
            try:
                fragment = ctx.get("fragment") if ctx else None
                activity = fragment.getParentActivity() if fragment else None
            except Exception:
                activity = None
            if activity is None:
                fragment = get_last_fragment()
                activity = fragment.getParentActivity() if fragment else None
            self._trigger_circle_to_search(activity)
        except Exception:
            pass

    def _trigger_circle_to_search(self, activity=None):
        try:
            ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
            Intent = find_class("android.content.Intent")
            Context = find_class("android.content.Context")
            PackageManager = find_class("android.content.pm.PackageManager")
            if activity is None:
                try:
                    fragment = get_last_fragment()
                    activity = fragment.getParentActivity() if fragment else None
                except Exception:
                    activity = None
            ctx = activity or (ApplicationLoader and ApplicationLoader.applicationContext)
            if ctx is None:
                return False

            # Ripple visual feedback (center of screen)
            try:
                def _make_ripple():
                    try:
                        view = None
                        try:
                            window = activity.getWindow() if activity else None
                            if window:
                                view = window.getDecorView()
                        except Exception:
                            view = None
                        try:
                            width = float(view.getWidth()) if view else float(getattr(AndroidUtilities, "displaySize").x)
                            height = float(view.getHeight()) if view else float(getattr(AndroidUtilities, "displaySize").y)
                        except Exception:
                            width = 540.0
                            height = 960.0
                        cx = width / 2.0
                        cy = height / 2.0
                        try:
                            LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                            LaunchActivity.makeRipple(float(cx), float(cy), float(3.0))
                        except Exception:
                            pass
                    except Exception:
                        pass
                try:
                    run_on_ui_thread(_make_ripple)
                except Exception:
                    _make_ripple()
            except Exception:
                pass

            pm = ctx.getPackageManager() if ctx else None

            # Prefer MiCTS if installed
            try:
                launch = pm.getLaunchIntentForPackage("com.parallelc.micts") if pm else None
            except Exception:
                launch = None
            if launch:
                try:
                    if Intent and hasattr(Intent, "FLAG_ACTIVITY_NEW_TASK"):
                        launch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                except Exception:
                    pass
                try:
                    ctx.startActivity(launch)
                    return True
                except Exception:
                    pass

            # Fallback: open Google app
            google_launch = None
            try:
                google_launch = pm.getLaunchIntentForPackage("com.google.android.googlequicksearchbox") if pm else None
            except Exception:
                google_launch = None
            if google_launch:
                try:
                    if Intent and hasattr(Intent, "FLAG_ACTIVITY_NEW_TASK"):
                        google_launch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                except Exception:
                    pass
                try:
                    ctx.startActivity(google_launch)
                    return True
                except Exception:
                    pass

            # Fallback: ACTION_ASSIST
            try:
                assist_intent = Intent("android.intent.action.ASSIST")
                if assist_intent:
                    ctx.startActivity(assist_intent)
                    return True
            except Exception:
                pass

            return False
        except Exception:
            return False

    def _on_context_menu_click(self, ctx):
        try:
            message = None
            try:
                message = ctx.get("message") if ctx else None
            except Exception:
                message = None
            if not message:
                try:
                    message = ctx.get("message_object") or ctx.get("msg") if ctx else None
                except Exception:
                    message = None
            if not message:
                return
            if not self._message_has_text(message):
                return
            # Usa o fluxo existente: extrai o texto e abre a pesquisa
            self._on_search_message_click(message)
        except Exception:
            pass

    def _show_how_to_use_sheet(self):
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)

            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(self._t("howto_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # Ícone
            try:
                iv = ImageView(ctx)
                rid = self._resolve_drawable_id("msg_info_remix") or self._resolve_drawable_id("msg_search_remix")
                if rid:
                    iv.setImageResource(rid)
                container.addView(iv, LayoutHelper.createLinear(36, 36, Gravity.TOP | Gravity.START, 24, 4, 24, 8))
            except Exception:
                pass

            # Descrição
            desc_view = TextView(ctx)
            desc_view.setText(self._t("howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 0, 24, 16))

            # Botão "Entendi" (aprimorar)
            button_container = FrameLayout(ctx)
            btn = SimpleTextView(ctx)
            btn.setText(self._t("understood"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                pass
            btn.setGravity(Gravity.CENTER)
            button_container.addView(btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))

            def _dismiss(*args):
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_dismiss))
            container.addView(button_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _message_has_text(self, m) -> bool:
        try:
            if m is None:
                return False
            # Try common fields
            txt = None
            try:
                txt = getattr(m.messageOwner, 'message', None)
            except Exception:
                txt = None
            if not txt:
                try:
                    txt = getattr(m, 'messageText', None)
                except Exception:
                    txt = None
            if not txt:
                try:
                    txt = m.getMessageText()
                except Exception:
                    txt = None
            return bool(txt and str(txt).strip())
        except Exception:
            return False

    def _extract_text_from_message(self, m) -> str:
        try:
            txt = None
            try:
                txt = getattr(m.messageOwner, 'message', None)
            except Exception:
                txt = None
            if not txt:
                try:
                    txt = getattr(m, 'messageText', None)
                except Exception:
                    txt = None
            if not txt:
                try:
                    txt = m.getMessageText()
                except Exception:
                    txt = None
            return (txt or '').strip()
        except Exception:
            return ''

    def _on_search_message_click(self, *args, **kwargs):
        try:
            # First arg is likely the MessageObject
            message = args[0] if args and args[0] is not None else None
            query = self._extract_text_from_message(message)
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            self._show_search_dialog(activity, query)
        except Exception:
            pass

    def _get_message_from_text_view(self, text_view):
        try:
            # Tenta getter direto
            try:
                return text_view.getMessageObject()
            except Exception:
                pass
            # Percorre os pais para encontrar ChatMessageCell
            parent = None
            try:
                parent = text_view.getParent()
            except Exception:
                parent = None
            depth = 0
            while parent is not None and depth < 6:
                try:
                    cls_name = parent.getClass().getName()
                except Exception:
                    cls_name = ""
                if "ChatMessageCell" in str(cls_name):
                    try:
                        msg = getattr(parent, 'currentMessageObject', None)
                        if not msg:
                            msg = getattr(parent, 'messageObject', None)
                        if msg:
                            return msg
                    except Exception:
                        pass
                try:
                    parent = parent.getParent()
                except Exception:
                    parent = None
                depth += 1
        except Exception:
            pass
        return None

    def _get_word_at_offset(self, text: str, offset: int) -> str:
        try:
            if text is None:
                return ""
            s = str(text)
            n = len(s)
            if n == 0:
                return ""
            if offset is None or offset < 0:
                offset = 0
            if offset >= n:
                offset = n - 1
            start = offset
            end = offset
            while start > 0 and s[start-1].isalnum():
                start -= 1
            while end < n and s[end].isalnum():
                end += 1
            return s[start:end]
        except Exception:
            return ""

    def _hook_message_text_touch(self):
        try:
            MessageTextView = find_class("org.telegram.ui.Components.MessageTextView")
            MotionEvent = find_class("android.view.MotionEvent")
            if MessageTextView is None or MotionEvent is None:
                return

            on_touch = MessageTextView.getClass().getDeclaredMethod(
                "onTouchEvent",
                MotionEvent,
            )
            on_touch.setAccessible(True)

            self.hook_message_text_touch_ref = self.hook_method(
                on_touch, SearchItMsgTextTouchHook(self)
            )
        except Exception:
            pass


class SearchItActionModeMenuHook:
    def __init__(self, plugin: SearchItPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            menu = param.args[0]
            if menu is None:
                return

            # Avoid duplicates
            if menu.findItem(self.plugin.menu_item_id) is not None:
                return

            title = SpannableStringBuilder(self.plugin._t("menu_item_search"))
            try:
                title.setSpan(TypefaceSpan(Typeface.DEFAULT), 0, title.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except Exception:
                pass

            # Order after common formatting items
            # Order 0 to appear early; group matches formatting items
            item = menu.add(R_tg.id.menu_groupbolditalic, self.plugin.menu_item_id, 0, title)
            try:
                # Ícone do item (msg_search_remix)
                res_id = self.plugin._resolve_drawable_id("msg_search_remix")
                if res_id:
                    item.setIcon(res_id)
            except Exception:
                pass
        except Exception:
            pass


class SearchItPerformMenuActionHook:
    def __init__(self, plugin: SearchItPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            edit_text = param.thisObject
            if item_id != self.plugin.menu_item_id:
                return

            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            if start is None or end is None or start < 0 or end < 0 or start == end:
                return

            text = edit_text.getText()
            if text is None:
                return
            try:
                selected = text.subSequence(start, end).toString()
            except Exception:
                selected = None

            activity = edit_text.getContext()
            self.plugin._show_search_dialog(activity, selected)
        except Exception:
            pass


class SearchItMsgTextTouchHook:
    def __init__(self, plugin: SearchItPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            text_view = param.thisObject
            motion_event = param.args[0]
            if text_view is None or motion_event is None:
                return

            # MotionEvent.ACTION_UP
            try:
                ACTION_UP = find_class("android.view.MotionEvent").ACTION_UP
            except Exception:
                ACTION_UP = 1

            action = motion_event.getAction()
            if action != ACTION_UP:
                return

            x = motion_event.getX()
            y = motion_event.getY()
            try:
                offset = text_view.getOffsetForPosition(x, y)
            except Exception:
                offset = None

            full_text = None
            try:
                txt = text_view.getText()
                if txt is not None:
                    full_text = txt.toString()
            except Exception:
                full_text = None

            if not full_text:
                message = self.plugin._get_message_from_text_view(text_view)
                full_text = self.plugin._extract_text_from_message(message)

            word = self.plugin._get_word_at_offset(full_text or "", offset or 0)
            if not word or not str(word).strip():
                return

            if word and str(word).strip():
                try:
                    activity = text_view.getContext()
                except Exception:
                    activity = None
                self.plugin._show_search_dialog(activity, word.strip())
        except Exception:
            pass