__id__ = "second_voice"
__name__ = "Таймер голосовых: прошедшее/общее"
__description__ = "Заменяет стандартный таймер у голосовых сообщений на формат 'прошедшее / общее' (например: 01:09 / 02:16)."
__author__ = "@buligaEplugins & @incLu_01"
__version__ = "1.2.0"
__icon__ = "BuligaPlugins/3"
__min_version__ = "11.12.0"

import math
import time
from typing import Any

from base_plugin import BasePlugin
from android_utils import log
from hook_utils import find_class, get_private_field, set_private_field


from java.lang import Math as JMath, String as JString
from android.text import StaticLayout
from android.text import Layout
from org.telegram.messenger import AndroidUtilities, MediaController, MessageObject
from org.telegram.ui.ActionBar import Theme


class _UpdateProgressAfterHook:
    def __init__(self, plugin_instance: BasePlugin):
        self.plugin = plugin_instance

    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            if cell is None:
                return
            msg = get_private_field(cell, "currentMessageObject")
            if msg is None:
                return
            self.plugin._apply_override_from_progress(cell, msg)
        except Exception as e:
            log(f"[second_voice] after_hooked_method error: {e}")


class _SetMessageAfterHook:
    def __init__(self, plugin_instance: BasePlugin):
        self.plugin = plugin_instance

    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            if cell is None:
                return
            msg = get_private_field(cell, "currentMessageObject")
            if msg is None:
                return
            try:
                self.plugin._on_cell_bind(cell, msg)
            except Exception:
                pass
            try:
                self.plugin._apply_override_if_playing(cell, msg)
            except Exception:
                try:
                    self.plugin._apply_total_only(cell, msg)
                except Exception:
                    pass
            try:
                self.plugin._schedule_total_fix(cell)
            except Exception:
                pass
        except Exception as e:
            log(f"[second_voice] setMessage after_hook error: {e}")


class VoiceTimerPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._cell_cache = {}
        self._last_update_ts = {}
        self._cache_order = []
        self._cache_capacity = 16
        self._settings_cache_data = None
        self._settings_cache_time = 0
        self._fix_attempts = {}
        self._pending_updates = {}

    def _message_key(self, msg) -> str:
        try:
            return f"{int(msg.getDialogId())}_{int(msg.getId())}"
        except Exception:
            return "0_0"

    def _schedule_total_fix(self, cell):
        key = id(cell)
        if self._fix_attempts.get(key, 0) >= 2:
            return
        self._fix_attempts[key] = self._fix_attempts.get(key, 0) + 1

        def _run():
            try:
                c = cell
                msg = get_private_field(c, "currentMessageObject")
                if msg is None:
                    return
                try:
                    total = int(msg.getDuration())
                except:
                    total = 0
                if total <= 1:
                    self._apply_override_if_playing(c, msg)
                    if self._fix_attempts.get(key, 0) < 2:
                        AndroidUtilities.runOnUIThread(_run, 120)
                else:
                    self._apply_override_if_playing(c, msg)
            except:
                pass

        try:
            AndroidUtilities.runOnUIThread(_run, 120)
        except:
            try:
                msg = get_private_field(cell, "currentMessageObject")
                if msg is not None:
                    self._apply_override_if_playing(cell, msg)
            except:
                pass

    def _apply_override_from_progress(self, cell, msg):
        throttle_ms = 35
        key = id(cell)

        if not self._is_playing(msg):
            try:
                self._force_hide_unread_dot(msg)
                self._apply_total_only(cell, msg)
                self._pending_updates.pop(key, None)
            except:
                pass
            return

        try:
            curr_id = int(msg.getId())
            curr_did = int(msg.getDialogId())
            new_elapsed = int(getattr(msg, "audioProgressSec", -1))
        except:
            return

        prev = self._cell_cache.get(key)
        if prev is None or prev[6] != curr_id or prev[7] != curr_did or (prev[3] is not None and "/" not in str(prev[3])):
            self._apply_override(cell, msg)
            return

        if new_elapsed == prev[0]:
            try:
                if msg.isVoice() and prev[4] is not None:
                    pass
                if prev[5] is not None:
                    set_private_field(cell, "durationLayout", prev[5])
                cell.invalidate()
            except:
                pass
            return

        try:
            pend = self._pending_updates.get(key)
            if pend and pend[0] == curr_did and pend[1] == curr_id and pend[2] == new_elapsed:
                return
            self._pending_updates[key] = (curr_did, curr_id, new_elapsed)
            
            def runner():
                try:
                    c = cell
                    m = get_private_field(c, "currentMessageObject")
                    if m is None:
                        return
                    if int(m.getDialogId()) == curr_did and int(m.getId()) == curr_id:
                        self._apply_override(c, m)
                finally:
                    self._pending_updates.pop(key, None)
            
            AndroidUtilities.runOnUIThread(runner, throttle_ms)
        except:
            self._apply_override(cell, msg)


    def _get_settings(self):
        try:
            now_ms = int(time.time() * 1000)
            if now_ms - self._settings_cache_time < 1000 and self._settings_cache_data is not None:
                return self._settings_cache_data
            data = {
                "invert_order": bool(self.get_setting("invert_order", False)),
            }
            self._settings_cache_data = data
            self._settings_cache_time = now_ms
            return data
        except Exception:
            return {
                "invert_order": False,
            }

    def _on_cell_bind(self, cell, msg):
        key = id(cell)
        try:
            self._cell_cache.pop(key, None)
        except Exception:
            pass
        try:
            self._last_update_ts.pop(key, None)
        except Exception:
            pass
        try:
            self._fix_attempts.pop(key, None)
        except Exception:
            pass
        try:
            self._pending_updates.pop(key, None)
        except Exception:
            pass

    def _is_playing(self, msg) -> bool:
        try:
            return bool(MediaController.getInstance().isPlayingMessage(msg))
        except Exception:
            return False

    def _force_hide_unread_dot(self, msg):
        try:
            try:
                owner = getattr(msg, "messageOwner", None)
            except Exception:
                owner = None
            if owner is not None:
                try:
                    set_private_field(owner, "media_unread", False)
                except Exception:
                    try:
                        setattr(owner, "media_unread", False)
                    except Exception:
                        pass
            try:
                set_private_field(msg, "contentUnread", False)
            except Exception:
                try:
                    setattr(msg, "contentUnread", False)
                except Exception:
                    pass
        except Exception:
            pass

    def _apply_override_if_playing(self, cell, msg):
        if not self._is_playing(msg):
            try:
                self._force_hide_unread_dot(msg)
                self._apply_total_only(cell, msg)
                self._pending_updates.pop(id(cell), None)
            except:
                pass
            return
        
        throttle_ms = 35
        key = id(cell)
        
        try:
            curr_id = int(msg.getId())
            curr_did = int(msg.getDialogId())
            new_elapsed = int(getattr(msg, "audioProgressSec", -1))
        except:
            return
            
        prev = self._cell_cache.get(key)
        if prev is not None and prev[6] == curr_id and prev[7] == curr_did and new_elapsed == prev[0]:
            try:
                if msg.isVoice() and prev[4] is not None:
                    pass
                if prev[5] is not None:
                    set_private_field(cell, "durationLayout", prev[5])
                cell.invalidate()
            except:
                pass
            return
            
        try:
            pend = self._pending_updates.get(key)
            if pend and pend[0] == curr_did and pend[1] == curr_id and pend[2] == new_elapsed:
                return
            self._pending_updates[key] = (curr_did, curr_id, new_elapsed)

            def runner():
                try:
                    c = cell
                    m = get_private_field(c, "currentMessageObject")
                    if m is None:
                        return
                    if int(m.getDialogId()) == curr_did and int(m.getId()) == curr_id:
                        self._apply_override(c, m)
                finally:
                    self._pending_updates.pop(key, None)

            AndroidUtilities.runOnUIThread(runner, throttle_ms)
        except:
            self._apply_override(cell, msg)

    def _apply_total_only(self, cell, msg):
        try:
            is_voice = msg.isVoice()
        except:
            is_voice = False
        try:
            total_sec = int(msg.getDuration())
        except:
            total_sec = 0
        def fmt(v: int) -> str:
            m, s = divmod(max(0, int(v)), 60)
            return f"{m:02d}:{s:02d}"
        try:
            total_text = AndroidUtilities.formatLongDuration(int(total_sec))
        except:
            total_text = fmt(total_sec)
        paint = Theme.chat_audioTimePaint if is_voice else Theme.chat_timePaint
        try:
            width = int(math.floor(paint.measureText(total_text)) + 1)
        except:
            try:
                width = int(JMath.floor(paint.measureText(total_text)) + 1)
            except:
                width = int(max(1, len(total_text) * 10))
        if is_voice:
            pass
        try:
            layout = StaticLayout(total_text, paint, width, Layout.Alignment.ALIGN_NORMAL, 1.0, 0.0, False)
            set_private_field(cell, "durationLayout", layout)
        except:
            return
        key = id(cell)
        try:
            curr_id = int(msg.getId())
        except:
            curr_id = 0
        try:
            curr_did = int(msg.getDialogId())
        except:
            curr_did = 0
        self._cell_cache[key] = (0, total_sec, False, total_text, int(width), layout, curr_id, curr_did)
        try:
            cell.invalidate()
        except:
            pass

    def _apply_override(self, cell, msg):
        try:
            try:
                is_voice = msg.isVoice()
            except:
                is_voice = False
            settings = self._get_settings()
            if not is_voice:
                return

            try:
                self._force_hide_unread_dot(msg)
            except:
                pass

            invert = bool(settings.get("invert_order", False))

            def fmt(v: int) -> str:
                m, s = divmod(max(0, int(v)), 60)
                return f"{m:02d}:{s:02d}"

            try:
                total_sec = int(msg.getDuration())
            except:
                total_sec = 0
            try:
                elapsed_raw = getattr(msg, "audioProgressSec", 0)
                elapsed_sec = int(elapsed_raw if elapsed_raw is not None else 0)
            except:
                elapsed_sec = 0

            if invert:
                try:
                    left = AndroidUtilities.formatLongDuration(int(total_sec))
                except:
                    left = fmt(total_sec)
                try:
                    right = AndroidUtilities.formatLongDuration(int(elapsed_sec))
                except:
                    right = fmt(elapsed_sec)
                time_text = f"{left} / {right}"
            else:
                try:
                    left = AndroidUtilities.formatLongDuration(int(elapsed_sec))
                except:
                    left = fmt(elapsed_sec)
                try:
                    right = AndroidUtilities.formatLongDuration(int(total_sec))
                except:
                    right = fmt(total_sec)
                time_text = f"{left} / {right}"

            key = id(cell)
            prev = self._cell_cache.get(key)
            try:
                curr_id = int(msg.getId())
            except:
                curr_id = 0
            try:
                curr_did = int(msg.getDialogId())
            except:
                curr_did = 0
            if prev and len(prev) >= 8 and prev[6] == curr_id and prev[7] == curr_did and prev[0] == elapsed_sec and prev[1] == total_sec and prev[2] == invert and prev[3] == time_text:
                return

            paint = Theme.chat_audioTimePaint if is_voice else Theme.chat_timePaint
            try:
                width = int(math.floor(paint.measureText(time_text)) + 1)
            except:
                try:
                    width = int(JMath.floor(paint.measureText(time_text)) + 1)
                except:
                    width = int(max(1, len(time_text.replace("\n", "")) * 10))
            if is_voice:
                pass
            try:
                layout = StaticLayout(time_text, paint, width, Layout.Alignment.ALIGN_NORMAL, 1.0, 0.0, False)
                set_private_field(cell, "durationLayout", layout)
            except:
                return
            last_width = None
            try:
                last_width = int(get_private_field(cell, "timeWidthAudio")) if is_voice else int(width)
            except:
                last_width = int(width)
            self._cell_cache[key] = (elapsed_sec, total_sec, invert, time_text, int(last_width), layout, curr_id, curr_did)
            try:
                if key in self._cache_order:
                    self._cache_order.remove(key)
                self._cache_order.append(key)
                if len(self._cache_order) > self._cache_capacity:
                    old_key = self._cache_order.pop(0)
                    self._cell_cache.pop(old_key, None)
                    self._last_update_ts.pop(old_key, None)
            except:
                pass
            try:
                cell.invalidate()
            except:
                pass
            try:
                if is_voice and total_sec > 0 and elapsed_sec >= total_sec:
                    self._schedule_final_refresh(cell)
            except:
                pass
        except:
            pass

    def on_plugin_load(self):
        try:
            ChatMessageCell = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if not ChatMessageCell:
                log("[second_voice] ChatMessageCell class not found")
                return

            try:
                methods = None
                try:
                    methods = ChatMessageCell.getDeclaredMethods()
                    log("[second_voice] Retrieved methods via getDeclaredMethods()")
                except Exception as e0:
                    log(f"[second_voice] getDeclaredMethods() failed: {e0}, trying getClass().getDeclaredMethods()")
                    try:
                        methods = ChatMessageCell.getClass().getDeclaredMethods()
                        log("[second_voice] Retrieved methods via getClass().getDeclaredMethods()")
                    except Exception as e1:
                        log(f"[second_voice] getClass().getDeclaredMethods() failed: {e1}")
                        methods = []

                upd = None
                setm = None
                for m in methods:
                    try:
                        name = m.getName()
                        if name == "updatePlayingMessageProgress" and len(m.getParameterTypes()) == 0:
                            upd = m
                        elif name == "setMessageObject" and len(m.getParameterTypes()) == 4:
                            setm = m
                    except Exception:
                        continue

                if upd is not None:
                    upd.setAccessible(True)
                    self.hook_method(upd, _UpdateProgressAfterHook(self))
                    log("[second_voice] Hook installed: ChatMessageCell.updatePlayingMessageProgress()")
                else:
                    log("[second_voice] updatePlayingMessageProgress() not found")
                if setm is not None:
                    setm.setAccessible(True)
                    self.hook_method(setm, _SetMessageAfterHook(self))
                    log("[second_voice] Hook installed: ChatMessageCell.setMessageObject(...) (after)")
                else:
                    log("[second_voice] setMessageObject(...) not found")
            except Exception as e:
                log(f"[second_voice] Failed to scan/hook ChatMessageCell methods: {e}")
            
        except Exception as e:
            log(f"[second_voice] on_plugin_load error: {e}")

    def create_settings(self):
        from ui.settings import Header, Switch, Text, Divider
        return [
            Header(text="Таймер голосовых"),
            Switch(
                key="invert_order",
                text="Инвертировать порядок",
                default=False,
                subtext="Показывать 'общее / прошедшее' вместо 'прошедшее / общее'",
                icon="msg_sort",
            ),
            Divider(),
            Text(text="Авторы: @buligaEplugins, @incLu_01", icon="msg_info"),
        ]

    def _schedule_final_refresh(self, cell):
        def run():
            try:
                c = cell
                msg = get_private_field(c, "currentMessageObject")
                if msg is not None:
                    self._apply_override_if_playing(c, msg)
            except:
                pass
        try:
            AndroidUtilities.runOnUIThread(run, 60)
        except:
            run()
