__id__ = "osuManualPlays"
__name__ = "osu! Manual Plays"
__description__ = "Ручной учёт дневных osu!-плеев + календарь и графики"
__author__ = "@nanoPrograms"
__version__ = "1.0.0"
__icon__ = "osuManual/1"
__min_version__ = "12.1.1"

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import send_message, run_on_queue
from android_utils import log
import os
import json
import io
import calendar
from datetime import datetime
from PIL import Image, ImageDraw
from ui.settings import Header, Input, Switch, Text
from ui.bulletin import BulletinHelper
from typing import Any

class OsuManualPlays(BasePlugin):
    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.data_dir = self.get_setting("data_dir", os.path.join(os.path.dirname(__file__), "osu_data"))
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir, exist_ok=True)
        log("osuManualPlays loaded")

    def create_settings(self):
        def on_prefix_change(new_value: str):
            if new_value:
                self.set_setting("prefix", new_value.strip())

        return [
            Header(text="Настройки osu! Plays"),
            Input(
                key="prefix",
                text="Префикс команд",
                default=self.get_setting("prefix", "/"),
                subtext="Например: / или .osu",
                icon="msg_mention",
                on_change=on_prefix_change
            ),
            Input(
                key="data_dir",
                text="Папка для данных",
                default=self.data_dir,
                subtext="Не меняйте, если не уверены",
                icon="msg_folder"
            ),
            Switch(
                key="bulletins",
                text="Всплывающие уведомления",
                default=self.get_setting("bulletins", True),
                subtext="Для ошибок и подтверждений",
                icon="msg_info"
            ),
            Text(
                text="Команды: /add <число> | /set <день> <число> | /stats | /month | /chart",
                icon="msg_list"
            )
        ]

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        msg = params.message if isinstance(params.message, str) else ""
        prefix = self.get_setting("prefix", "/")
        if not msg.startswith(prefix):
            return HookResult()

        args = msg[len(prefix):].strip().split()
        if not args:
            return HookResult(strategy=HookStrategy.CANCEL)

        cmd = args[0].lower()
        rest = " ".join(args[1:]).strip()

        run_on_queue(lambda: self._process_command(cmd, rest, params.peer))
        return HookResult(strategy=HookStrategy.CANCEL)

    def _process_command(self, cmd: str, rest: str, peer: Any):
        try:
            if cmd == "add":
                self._cmd_add(rest, peer)
            elif cmd == "set":
                self._cmd_set(rest, peer)
            elif cmd == "stats":
                self._cmd_stats(peer)
            elif cmd == "month":
                self._cmd_month(peer)
            elif cmd == "chart":
                self._cmd_chart(peer)
            else:
                self._reply(peer, "Неизвестная команда. Команды: add, set, stats, month, chart")
        except Exception as e:
            log(f"osuManualPlays error: {e}")
            self._reply(peer, f"Ошибка: {str(e)}")

    def _get_user_id(self, peer: Any) -> str:
        return str(peer)

    def _month_filename(self, user_id: str, year: int, month: int):
        safe = user_id.replace('/', '_')
        return os.path.join(self.data_dir, f"{safe}-{year}-{str(month).zfill(2)}.json")

    def _load_month(self, user_id: str, year: int, month: int):
        fn = self._month_filename(user_id, year, month)
        days_in_month = calendar.monthrange(year, month)[1]
        if os.path.exists(fn):
            try:
                with open(fn, 'r', encoding='utf-8') as f:
                    d = json.load(f)
                d['days'] = (d.get('days', []) + [0] * days_in_month)[:days_in_month]
                return d
            except:
                pass
        return {'user_id': user_id, 'year': year, 'month': month, 'days': [0] * days_in_month}

    def _save_month(self, data: dict):
        fn = self._month_filename(data['user_id'], data['year'], data['month'])
        with open(fn, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)

    def _cmd_add(self, rest: str, peer: Any):
        if not rest.isdigit():
            self._reply(peer, "Использование: add <число>")
            return
        num = int(rest)
        now = datetime.now()
        user_id = self._get_user_id(peer)
        data = self._load_month(user_id, now.year, now.month)
        data['days'][now.day - 1] += num
        self._save_month(data)
        self._reply(peer, f"Добавлено {num} плеев. Сегодня: {data['days'][now.day - 1]}")

    def _cmd_set(self, rest: str, peer: Any):
        parts = rest.split()
        if len(parts) != 2 or not all(p.isdigit() for p in parts):
            self._reply(peer, "Использование: set <день> <число>")
            return
        day, num = map(int, parts)
        now = datetime.now()
        days_in_month = calendar.monthrange(now.year, now.month)[1]
        if not (1 <= day <= days_in_month):
            self._reply(peer, f"День должен быть 1-{days_in_month}")
            return
        user_id = self._get_user_id(peer)
        data = self._load_month(user_id, now.year, now.month)
        data['days'][day - 1] = num
        self._save_month(data)
        self._reply(peer, f"День {day} установлен: {num}")

    def _cmd_stats(self, peer: Any):
        now = datetime.now()
        user_id = self._get_user_id(peer)
        data = self._load_month(user_id, now.year, now.month)
        total = sum(data['days'])
        lines = [f"Статистика за {now.month}.{now.year}:\n"]
        for i, v in enumerate(data['days'], start=1):
            lines.append(f"{i:2d}: {v}")
        lines.append(f"\nИтого: {total} плеев")
        self._reply(peer, "\n".join(lines))

    def _cmd_month(self, peer: Any):
        now = datetime.now()
        user_id = self._get_user_id(peer)
        data = self._load_month(user_id, now.year, now.month)
        cal_text = self._render_month_with_plays(now.year, now.month, data['days'])
        self._reply(peer, cal_text)

    def _cmd_chart(self, peer: Any):
        now = datetime.now()
        user_id = self._get_user_id(peer)
        data = self._load_month(user_id, now.year, now.month)
        values = data['days']
        max_val = max(values) or 1
        width, height = 600, 300
        img = Image.new('RGB', (width, height), color='white')
        draw = ImageDraw.Draw(img)
        days = len(values)
        x_step = width / max(1, days - 1)
        y_step = height / max_val
        prev_x, prev_y = 0, height - (values[0] * y_step)
        for i in range(1, days):
            x = i * x_step
            y = height - (values[i] * y_step)
            draw.line((prev_x, prev_y, x, y), fill='blue', width=2)
            prev_x, prev_y = x, y
        buf = io.BytesIO()
        img.save(buf, format='PNG')
        buf.seek(0)
        self._send_image(peer, buf)

    def _render_month_with_plays(self, year: int, month: int, plays_list: list):
        firstweekday = 0
        cal = calendar.Calendar(firstweekday=firstweekday)
        weeks = cal.monthdayscalendar(year, month)
        today = datetime.today()
        header = f"{year}-{str(month).zfill(2)}"
        days_ru = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]
        lines = [header, " ".join(f"{d:>2}" for d in days_ru)]

        def fmt_day(d):
            if d == 0:
                return "  "
            plays = plays_list[d - 1] if d - 1 < len(plays_list) else 0
            text = f"{d:02}"
            if plays > 0:
                text = f"{text}({plays})"
            if today.year == year and today.month == month and today.day == d:
                text = f"[{text}]"
            return text

        for w in weeks:
            row = [f"{fmt_day(d):>6}" for d in w]
            lines.append("".join(row))
        return "\n".join(lines)

    def _reply(self, peer: Any, text: str):
        if self.get_setting("bulletins", True):
            BulletinHelper.show_info(text)
        else:
            send_message({"peer": peer, "message": text})

    def _send_image(self, peer: Any, buf: io.BytesIO):
        try:
            params = {"peer": peer, "file": buf.getvalue(), "caption": "График плеев"}
            send_message(params)
        except Exception as e:
            log(f"Send image error: {e}")
            temp_fn = os.path.join(self.data_dir, "temp_chart.png")
            with open(temp_fn, "wb") as f:
                f.write(buf.getvalue())
            send_message({"peer": peer, "file": temp_fn, "caption": "График плеев"})
            os.remove(temp_fn)