__id__ = "sticker_cloner"
__name__ = "Sticker pack cloner"
__author__ = "@ametist1337"
__version__ = "1.6.1"
__description__ = "ÐŸÐ¸Ð·Ð´Ð¸Ñ‚ Ð¿Ð°Ðº Ð¸ Ð¿Ñ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ ÐµÐ³Ð¾ Ð² Ð²Ð°Ñˆ ÑÐ¿Ð¸ÑÐ¾Ðº. Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÐµÐ³Ð¾ Ð¼ÐµÐ½ÑÑ‚ÑŒ Ð¸ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ÐµÑÑŒ ÐµÐ³Ð¾ Ð°Ð²Ñ‚Ð¾Ñ€Ð¾Ð¼. .scopy ÑÑÑ‹Ð»ÐºÐ°"

import threading
import time
import random
import string
from typing import Any

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_last_fragment
from ui.bulletin import BulletinHelper
from org.telegram.messenger import MessagesController, UserConfig, MediaDataController
from org.telegram.tgnet import TLRPC, ConnectionsManager, RequestDelegate
from android_utils import run_on_ui_thread
from java import dynamic_proxy
from java.util import ArrayList

PyRequestDelegate = dynamic_proxy(RequestDelegate)

class StickerClonerPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._is_working = False

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.log(f"[{__name__}] Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½ v1.0.5")

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:
            if not params or not hasattr(params, 'message') or params.message is None:
                return HookResult()
            text = str(params.message).strip()
            if not text.lower().startswith(".scopy"):
                return HookResult()
            
            args = text.split()
            if len(args) <= 1:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ð’Ð²ÐµÐ´Ð¸ Ð¸Ð¼Ñ Ð¿Ð°ÐºÐ°!", get_last_fragment()))
                return HookResult(strategy=HookStrategy.CANCEL)
            
            raw_target = args[1].strip().strip("'\"")
            target_name = raw_target.split('/')[-1].strip("'\" ")
            
            if self._is_working:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ð£Ð¶Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽ!", get_last_fragment()))
            else:
                threading.Thread(target=self._clone_process, args=(target_name,), daemon=True).start()
            
            return HookResult(strategy=HookStrategy.CANCEL)
        except Exception as e:
            self.log(f"Hook Error: {e}")
        return HookResult()

    def _clone_process(self, short_name):
        self._is_working = True
        account = UserConfig.selectedAccount
        msg_controller = MessagesController.getInstance(account)
        md_controller = MediaDataController.getInstance(account)
        
        try:
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"ÐšÐ¾Ð¿Ð¸Ñ€ÑƒÑŽ {short_name}...", get_last_fragment()))
            
            # 1. ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ ÑÑ‚Ð¸ÐºÐµÑ€Ñ‹ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»Ð°
            wait_event = threading.Event()
            set_res = {"set": None, "pack": None, "error": None}

            class GetSetCallback(PyRequestDelegate):
                def run(self, response, error):
                    if error: set_res["error"] = error.text
                    else:
                        set_res["set"] = response.set
                        p_list = []
                        if response.documents:
                            for i in range(response.documents.size()):
                                p_list.append(response.documents.get(i))
                        set_res["pack"] = p_list
                    wait_event.set()

            req_get = TLRPC.TL_messages_getStickerSet()
            input_set = TLRPC.TL_inputStickerSetShortName()
            input_set.short_name = short_name
            req_get.stickerset = input_set
            req_get.hash = 0
            ConnectionsManager.getInstance(account).sendRequest(req_get, GetSetCallback())
            
            if not wait_event.wait(20) or set_res["error"]:
                raise Exception(set_res["error"] or "Timeout")

            # 2. ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð²
            items = ArrayList()
            for doc in set_res["pack"]:
                input_doc = TLRPC.TL_inputDocument()
                input_doc.id = doc.id
                input_doc.access_hash = doc.access_hash
                input_doc.file_reference = doc.file_reference
                
                emoji_str = "ðŸ˜€"
                if doc.attributes:
                    for i in range(doc.attributes.size()):
                        attr = doc.attributes.get(i)
                        if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                            if attr.alt: emoji_str = attr.alt
                            break
                
                item = TLRPC.TL_inputStickerSetItem()
                item.document = input_doc
                item.emoji = emoji_str
                items.add(item)

            # 3. Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ð°ÐºÐ°
            rnd = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
            new_short_name = f"c{UserConfig.getInstance(account).getClientUserId()}_{int(time.time())}_{rnd}"
            
            wait_create = threading.Event()
            create_res = {"error": None, "result_set": None}

            class CreateCallback(PyRequestDelegate):
                def run(self, response, error):
                    if error: create_res["error"] = error.text
                    else: create_res["result_set"] = response # Ð­Ñ‚Ð¾ TL_messages_stickerSet
                    wait_create.set()

            req_create = TLRPC.TL_stickers_createStickerSet()
            req_create.user_id = msg_controller.getInputUser(msg_controller.getUser(UserConfig.getInstance(account).getClientUserId()))
            req_create.title = f"{set_res['set'].title} (Clone)"
            req_create.short_name = new_short_name
            req_create.stickers = items
            
            ConnectionsManager.getInstance(account).sendRequest(req_create, CreateCallback())
            if not wait_create.wait(60) or create_res["error"]:
                raise Exception(create_res["error"] or "Create Timeout")

            # 4. Ð¤Ð˜ÐÐÐ›Ð¬ÐÐ«Ð™ Ð¨ÐÐ“: Ð˜Ð½ÑÑ‚Ð°Ð»Ð»Ð¸Ð¼ Ð¿Ð°Ðº, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð½ ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð»ÑÑ
            wait_install = threading.Event()
            
            class InstallCallback(PyRequestDelegate):
                def run(self, response, error):
                    wait_install.set()

            install_req = TLRPC.TL_messages_installStickerSet()
            new_input_set = TLRPC.TL_inputStickerSetShortName()
            new_input_set.short_name = new_short_name
            install_req.stickerset = new_input_set
            install_req.archived = False
            
            ConnectionsManager.getInstance(account).sendRequest(install_req, InstallCallback())
            wait_install.wait(10)

            # ÐŸÑ€Ð¸Ð½ÑƒÐ´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ UI ÑÑ‚Ð¸ÐºÐµÑ€Ð¾Ð²
            run_on_ui_thread(lambda: md_controller.loadStickers(0, True, True))

            link = f"https://t.me/addstickers/{new_short_name}"
            run_on_ui_thread(lambda: BulletinHelper.show_success(f"ÐŸÐ°Ðº ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½!", get_last_fragment()))
            self.log(f"SUCCESS: {link}")
            
        except Exception as e:
            self.log(f"FAIL: {e}")
            run_on_ui_thread(lambda m=str(e): BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ°: {m}", get_last_fragment()))
        finally:
            self._is_working = False

    def on_plugin_unload(self):
        self._is_working = False
