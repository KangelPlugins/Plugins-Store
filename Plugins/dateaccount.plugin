"""
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â¡¿â Ÿâ ‹â ‰â ‰â ‰â ‰â ›â ¿â£¿â£¿â£¿â£¿â¡¿â ›â ‰â ‰â „â ˆâ ‰â ™â ¿â£¿â£¿â£¿â£¿
â£¿â£¿â¡¿â ‹â „â£ â£¶â£¿â£¿â£¿â£·â£¦â£„â ˆâ ›â¢Ÿâ¢â£ â£¤â£´â£¶â£¤â£„â „â „â „â ˆâ¢¿â£¿â£¿
â£¿â¡¿â â¢ â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿â£¦â£€â ˆâ ›â ›â ‹â£¸â£¿â£¿â£·â¡„â „â „â „â¢»â£¿
â£¿â â¢€â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ‹â „â „â£¿â£¿â£¿â£¿â£¶â£¶â£¾â£¿â£¿â£¿â£¿â£§â „â „â „â „â£¿
â£¿â „â¢¸â£¿â£¿â£¿â£¿â£¿â Ÿâ â „â „â „â „â ™â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â „â „â „â „â£¿
â£¿â „â ˜â£¿â£¿â£¿â£¿â¡â „â „â „â „â „â „â „â ¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â „â „â „â „â£¿
â£¿â „â „â¢»â£¿â£¿â£¿â â „â „â „â „â „â „â „â¢ â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â „â „â „â¢€â£¿
â£¿â¡†â „â ˆâ ¿â ¿â ‹â „â „â „â „â „â „â¢°â£¶â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â „â „â „â£¸â£¿
â£¿â£¿â¡€â „â „â „â „â „â „â „â „â „â „â ¸â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡‡â „â „â£°â£¿â£¿
â£¿â£¿â£·â¡„â „â „â „â „â „â „â „â „â „â „â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡Ÿâ „â „â£°â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£„â „â „â „â „â „â „â „â „â£°â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â â „â¢€â£´â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£·â£„â „â „â „â „â „â£°â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â ƒâ „â£ â£¾â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£„â „â „â „â¢¿â£¿â£¿â£¿â£¿â£¿â¡¿â ‹â¢€â£ â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¦â£€â „â ™â¢¿â£¿â Ÿâ ‹â£ â£¶â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£¦â£„â£¨â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿
â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿

by @mihailkotovski
"""

import requests
import json
import time
import threading
import traceback
import os
from datetime import datetime
from base_plugin import HookResult, HookStrategy, BasePlugin, MenuItemData, MenuItemType
from client_utils import send_message, run_on_queue, get_last_fragment, run_on_ui_thread, get_messages_controller, send_request, RequestCallback
from markdown_utils import parse_markdown
from ui.settings import Header, Input, Switch, Text, Divider
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from java.util import Locale
from org.telegram.messenger import MessageObject
from org.telegram.ui.ActionBar import AlertDialog
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from org.telegram.tgnet.tl import TL_fragment
from org.telegram.tgnet import TLRPC

__id__ = "account_age_checker"
__name__ = "Account Age Checker"
__description__ = "Check the age of a Telegram account. Features free mode (local data only) and API mode with cache. Includes profile button for quick account info access. Now with NFT/collectible username support from Fragment!"
__author__ = "@mihailkotovski & @mew_help"
__min_version__ = "11.12.1"
__icon__ = "DateRegBot_by_MoiStikiBot/10"
__version__ = "4.5.0 [api+nft+redesign]"
__copyright__ = "Â© 2025. All rights reserved. Copying, modification, or redistribution of this plugin code is strictly prohibited."

PREMIUM_EMOJI_MAP = {
    "ğŸ“Š": "[ğŸ“Š](5190806721286657692)",
    "ğŸ‘¤": "[ğŸ‘¤](5260399854500191689)",
    "ğŸ“…": "[ğŸ“…](5890937706803894250)",
    "ğŸ¯": "[ğŸ’¯](5206318837489743801)",
    "â³": "[ğŸ•”](5255971360965930740)",
    "âš™ï¸": "[âš™ï¸](5253952855185829086)",
    "ğŸŸ¢": "[âœ…](5021905410089550576)",
    "ğŸŸ¡": "[âš¡ï¸](4997289591011544358)",
    "ğŸŸ ": "[ğŸ“º](5350513667144163474)",
    "ğŸ”´": "[â—ï¸](4927486932113425461)",
    "ğŸªª": "[ğŸªª](5303360582706015886)",
    "ğŸ”—": "[ğŸ”—](5253490441826870592)",
    "ğŸ–¥": "[ğŸ“²](5330325869154022988)",
    "ğŸ³ï¸": "[ğŸ³ï¸](5391183322355357915)",
    "ğŸ‰": "[ğŸ‰](5357257143756005264)",
    "ğŸ“±": "[ğŸªª](5936017305585586269)",
    "âš ï¸": "[âš ï¸](5447644880824181073)",
    "ğŸ†“": "[ğŸ†“](5406756500108501710)",
    "ğŸ’": "[ğŸ’](5471952986970267163)"
}

DC_REGION_MAP = {
    1: "Miami, FL",
    2: "Amsterdam, NL",
    3: "Miami, FL",
    4: "Amsterdam, NL",
    5: "Singapore, SG"
}

def replace_with_premium_emoji(text: str) -> str:
    result = text
    for regular_emoji, premium_emoji in PREMIUM_EMOJI_MAP.items():
        result = result.replace(regular_emoji, premium_emoji)
    return result

def get_regular_emoji_for_bulletin(text: str) -> str:
    result = text
    for regular_emoji, premium_emoji in PREMIUM_EMOJI_MAP.items():
        result = result.replace(premium_emoji, regular_emoji)
    return result

def get_account_name_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller
        from org.telegram.messenger import UserObject

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            return "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

        first_name = ""
        last_name = ""

        if hasattr(user, 'first_name') and user.first_name:
            first_name = user.first_name.strip()

        if hasattr(user, 'last_name') and user.last_name:
            last_name = user.last_name.strip()

        if first_name and last_name:
            full_name = f"{first_name} {last_name}"
        elif first_name:
            full_name = first_name
        elif last_name:
            full_name = last_name
        else:
            full_name = ""

        if full_name and full_name != "DELETED":
            return full_name

        public_username = UserObject.getPublicUsername(user)
        if public_username:
            return f"@{public_username}"

        return "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

    except Exception as e:
        _log(f"Error getting account name from Telegram: {e}")
        return "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾"

def get_username_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller
        from org.telegram.messenger import UserObject

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            return ""

        public_username = UserObject.getPublicUsername(user)
        if public_username:
            return str(public_username).strip()

        return ""

    except Exception as e:
        _log(f"Error getting username from Telegram: {e}")
        return ""

def get_all_usernames_display(user_id: str) -> str:
    try:
        all_usernames = get_all_usernames_from_telegram(user_id)
        if not all_usernames:
            return ""
        
        active_usernames = [u["username"] for u in all_usernames if u.get("active", False)]
        
        if not active_usernames:
            active_usernames = [u["username"] for u in all_usernames]
        
        if not active_usernames:
            return ""
        
        return ", ".join([f"@{u}" for u in active_usernames])
    
    except Exception as e:
        _log(f"Error getting all usernames display: {e}")
        return ""

def get_all_usernames_from_telegram(user_id: str) -> list:
    try:
        from client_utils import get_messages_controller

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            return []

        usernames_list = []

        if hasattr(user, 'usernames') and user.usernames and user.usernames.size() > 0:
            for i in range(user.usernames.size()):
                u = user.usernames.get(i)
                if u and hasattr(u, 'username') and u.username:
                    username_str = str(u.username).strip()
                    if username_str:
                        usernames_list.append({
                            "username": username_str,
                            "active": getattr(u, 'active', True),
                            "editable": getattr(u, 'editable', True)
                        })
        elif hasattr(user, 'username') and user.username:
            usernames_list.append({
                "username": str(user.username).strip(),
                "active": True,
                "editable": True
            })

        _log(f"Found {len(usernames_list)} usernames for user {user_id}: {usernames_list}")
        return usernames_list

    except Exception as e:
        _log(f"Error getting all usernames from Telegram: {e}")
        return []

def get_collectible_info_sync(username: str, callback_fn):
    try:
        req = TL_fragment.TL_getCollectibleInfo()
        input_collectible = TL_fragment.TL_inputCollectibleUsername()
        input_collectible.username = username
        req.collectible = input_collectible

        def on_response(response, error):
            if error:
                _log(f"Error getting collectible info for @{username}: {error.text if hasattr(error, 'text') else error}")
                callback_fn(None)
                return

            if response and isinstance(response, TL_fragment.TL_collectibleInfo):
                info = {
                    "purchase_date": response.purchase_date,
                    "currency": response.currency,
                    "amount": response.amount,
                    "crypto_currency": response.crypto_currency,
                    "crypto_amount": response.crypto_amount,
                    "url": response.url
                }
                _log(f"Collectible info for @{username}: {info}")
                callback_fn(info)
            else:
                _log(f"No collectible info found for @{username}")
                callback_fn(None)

        send_request(req, RequestCallback(on_response))

    except Exception as e:
        _log(f"Exception getting collectible info for @{username}: {e}")
        callback_fn(None)

def format_collectible_info(info: dict, language: str = "ru") -> str:
    if not info:
        return ""

    try:
        purchase_date = info.get("purchase_date", 0)
        if purchase_date > 0:
            from datetime import datetime
            dt = datetime.fromtimestamp(purchase_date)
            if language == "ru":
                months_ru = ["", "ÑĞ½Ğ²Ğ°Ñ€Ñ", "Ñ„ĞµĞ²Ñ€Ğ°Ğ»Ñ", "Ğ¼Ğ°Ñ€Ñ‚Ğ°", "Ğ°Ğ¿Ñ€ĞµĞ»Ñ", "Ğ¼Ğ°Ñ", "Ğ¸ÑĞ½Ñ",
                            "Ğ¸ÑĞ»Ñ", "Ğ°Ğ²Ğ³ÑƒÑÑ‚Ğ°", "ÑĞµĞ½Ñ‚ÑĞ±Ñ€Ñ", "Ğ¾ĞºÑ‚ÑĞ±Ñ€Ñ", "Ğ½Ğ¾ÑĞ±Ñ€Ñ", "Ğ´ĞµĞºĞ°Ğ±Ñ€Ñ"]
                date_str = f"{dt.day} {months_ru[dt.month]} {dt.year}"
            else:
                date_str = dt.strftime("%B %d, %Y")
        else:
            date_str = "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if language == "ru" else "Unknown"

        currency = info.get("currency", "")
        amount = info.get("amount", 0)
        price_str = f"{amount / 100:.2f} {currency}" if amount > 0 else ""

        crypto_currency = info.get("crypto_currency", "")
        crypto_amount = info.get("crypto_amount", 0)
        if crypto_amount > 0 and crypto_currency:
            crypto_price_str = f"{crypto_amount / 1000000000:.4f} {crypto_currency}"
        else:
            crypto_price_str = ""

        url = info.get("url", "")

        return {
            "date": date_str,
            "price": price_str,
            "crypto_price": crypto_price_str,
            "url": url
        }

    except Exception as e:
        _log(f"Error formatting collectible info: {e}")
        return {}

def get_user_phone_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller

        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            _log(f"User {user_id} not found")
            return ""

        if hasattr(user, 'phone') and user.phone:
            phone = user.phone.strip()
            if phone:

                if not phone.startswith("+"):
                    phone = "+" + phone
                _log(f"Phone found for user {user_id}: {phone}")
                return phone

        _log(f"No phone found for user {user_id}")
        return ""

    except Exception as e:
        _log(f"Error getting phone from Telegram for user {user_id}: {e}")
        return ""

def get_user_birthday_from_telegram(user_id: str) -> str:
    try:
        from client_utils import get_messages_controller


        user_full = get_messages_controller().getUserFull(int(user_id))
        if user_full is None:
            _log(f"UserFull not found for user {user_id}")
            return ""


        if not hasattr(user_full, 'birthday') or user_full.birthday is None:
            _log(f"No birthday found for user {user_id}")
            return ""

        birthday = user_full.birthday


        if not hasattr(birthday, 'day') or not hasattr(birthday, 'month'):
            _log(f"Invalid birthday structure for user {user_id}")
            return ""

        day = birthday.day
        month = birthday.month


        if day < 1 or day > 31 or month < 1 or month > 12:
            _log(f"Invalid birthday values for user {user_id}: day={day}, month={month}")
            return ""


        months_ru = [
            "", "ÑĞ½Ğ²Ğ°Ñ€Ñ", "Ñ„ĞµĞ²Ñ€Ğ°Ğ»Ñ", "Ğ¼Ğ°Ñ€Ñ‚Ğ°", "Ğ°Ğ¿Ñ€ĞµĞ»Ñ", "Ğ¼Ğ°Ñ", "Ğ¸ÑĞ½Ñ",
            "Ğ¸ÑĞ»Ñ", "Ğ°Ğ²Ğ³ÑƒÑÑ‚Ğ°", "ÑĞµĞ½Ñ‚ÑĞ±Ñ€Ñ", "Ğ¾ĞºÑ‚ÑĞ±Ñ€Ñ", "Ğ½Ğ¾ÑĞ±Ñ€Ñ", "Ğ´ĞµĞºĞ°Ğ±Ñ€Ñ"
        ]
        months_en = [
            "", "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ]


        current_language = Locale.getDefault().getLanguage()
        month_names = months_ru if current_language == "ru" else months_en
        month_name = month_names[month] if month < len(month_names) else str(month)


        if hasattr(birthday, 'flags') and hasattr(birthday, 'year') and (birthday.flags & 1) != 0:
            year = birthday.year
            if year > 0:
                _log(f"Birthday found for user {user_id}: {day} {month_name} {year}")
                return f"{day} {month_name} {year}"


        _log(f"Birthday found for user {user_id} (no year): {day} {month_name}")
        return f"{day} {month_name}"

    except Exception as e:
        _log(f"Error getting birthday from Telegram for user {user_id}: {e}")
        return ""

def get_user_datacenter_id(user_id: str) -> int:
    try:
        from client_utils import get_messages_controller


        user = get_messages_controller().getUser(int(user_id))
        if user is None:
            _log(f"User {user_id} not found in cache")
            return 0


        if hasattr(user, 'photo') and user.photo and hasattr(user.photo, 'dc_id'):
            dc_id = user.photo.dc_id
            _log(f"User {user_id} datacenter from user photo: {dc_id}")
            return dc_id


        try:
            user_full = get_messages_controller().getUserFull(int(user_id))
            if user_full:

                if hasattr(user_full, 'profile_photo') and user_full.profile_photo:
                    if hasattr(user_full.profile_photo, 'dc_id'):
                        dc_id = user_full.profile_photo.dc_id
                        _log(f"User {user_id} datacenter from full profile photo: {dc_id}")
                        return dc_id


                if hasattr(user_full, 'personal_photo') and user_full.personal_photo:
                    if hasattr(user_full.personal_photo, 'dc_id'):
                        dc_id = user_full.personal_photo.dc_id
                        _log(f"User {user_id} datacenter from personal photo: {dc_id}")
                        return dc_id


                if hasattr(user_full, 'fallback_photo') and user_full.fallback_photo:
                    if hasattr(user_full.fallback_photo, 'dc_id'):
                        dc_id = user_full.fallback_photo.dc_id
                        _log(f"User {user_id} datacenter from fallback photo: {dc_id}")
                        return dc_id

        except Exception as e:
            _log(f"Could not get full user info: {e}")


        user_id_int = int(user_id)


        if user_id_int < 10000000:
            estimated_dc = 2
        elif user_id_int < 100000000:
            estimated_dc = 1
        elif user_id_int < 500000000:
            estimated_dc = 2
        elif user_id_int < 1000000000:
            estimated_dc = 4
        elif user_id_int < 1500000000:
            estimated_dc = 5
        else:
            estimated_dc = 5

        _log(f"Estimated datacenter for user {user_id}: {estimated_dc} (heuristic, may be inaccurate)")
        return estimated_dc

    except Exception as e:
        _log(f"Error getting datacenter ID for user {user_id}: {e}")
        return 0

def get_region_from_datacenter(dc_id: int) -> str:
    return DC_REGION_MAP.get(dc_id, "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾")

def _log(message: str):
    if AccountAgePlugin.is_debug_globally_enabled():
        from android_utils import log as extera_log
        extera_log(f"[{__name__}] {message}")

class CacheManager:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.cache_file = self._get_cache_file_instance()
        self.cache = self.cache_file.content

    def _get_cache_file_instance(self):
        _log("Using local JsonCacheFile implementation for caching.")
        class LocalJsonCacheFile:
            cache_dir_name = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")
            def __init__(self, filename: str, default: dict):
                self.filename = filename
                self.path = os.path.join(self.cache_dir_name, filename)
                self.content = default.copy()
                self.default = default.copy()
                os.makedirs(self.cache_dir_name, exist_ok=True)
                self.read()
            def read(self):
                try:
                    with open(self.path, 'r', encoding='utf-8') as f: self.content = json.load(f)
                except: self.wipe()
            def write(self):
                try:
                    with open(self.path, 'w', encoding='utf-8') as f: json.dump(self.content, f, ensure_ascii=False, indent=4)
                except Exception as e: _log(f"Cache write error: {e}")
            def wipe(self):
                self.content = self.default.copy()
                self.write()
        return LocalJsonCacheFile(f"{__id__}_cache.json", {})

    def get(self, user_id: str, method: str):
        cache_duration = int(self.plugin.get_setting("cache_duration", "86400"))
        cache_key = f"{user_id}_{method}"

        if cache_key in self.cache:
            cached_data = self.cache[cache_key]
            if (time.time() - cached_data.get("timestamp", 0)) < cache_duration:
                _log(f"Cache hit for user_id: {user_id}, method: {method}")
                return cached_data.get("data")
        _log(f"Cache miss for user_id: {user_id}, method: {method}")
        return None

    def set(self, user_id: str, method: str, data: dict):
        cache_key = f"{user_id}_{method}"
        self.cache[cache_key] = {
            "timestamp": time.time(),
            "data": data
        }
        self.cache_file.write()
        _log(f"Saved to cache for user_id: {user_id}, method: {method}")

    def delete(self, user_id: str):
        user_id_str = str(user_id)
        keys_to_delete = [
            key for key in self.cache
            if key.startswith(f"{user_id_str}_")
        ]

        if not keys_to_delete:
            _log(f"No cache entries found to delete for user_id: {user_id_str}")
            return False

        for key in keys_to_delete:
            del self.cache[key]

        self.cache_file.write()
        _log(f"Deleted {len(keys_to_delete)} cache entries for user_id: {user_id_str}")
        return True

    def prune_expired(self):
        cache_duration = int(self.plugin.get_setting("cache_duration", "86400"))
        now = time.time()
        keys_to_delete = [
            key for key, value in self.cache.items()
            if (now - value.get("timestamp", 0)) >= cache_duration
        ]
        if not keys_to_delete: return
        for key in keys_to_delete: del self.cache[key]
        self.cache_file.write()
        _log(f"Pruned {len(keys_to_delete)} expired entries from cache.")

    def clear(self):
        self.cache_file.wipe()
        self.cache = self.cache_file.content
        _log("Cache cleared by user.")

    def get_all_entries(self) -> list:
        entries = []
        cache_duration = int(self.plugin.get_setting("cache_duration", "86400"))
        now = time.time()
        
        for key, value in self.cache.items():
            try:
                parts = key.rsplit("_", 1)
                if len(parts) != 2:
                    continue
                user_id, method = parts
                timestamp = value.get("timestamp", 0)
                data = value.get("data", {})
                
                time_left = cache_duration - (now - timestamp)
                is_expired = time_left <= 0
                
                account_name = get_account_name_from_telegram(user_id)
                username = get_username_from_telegram(user_id)
                
                entries.append({
                    "key": key,
                    "user_id": user_id,
                    "method": method,
                    "timestamp": timestamp,
                    "time_left": max(0, time_left),
                    "is_expired": is_expired,
                    "account_name": account_name,
                    "username": username,
                    "creation_date": data.get("creation_date", "N/A"),
                    "accuracy_percent": data.get("accuracy_percent", 0)
                })
            except Exception as e:
                _log(f"Error parsing cache entry {key}: {e}")
                continue
        
        entries.sort(key=lambda x: x["timestamp"], reverse=True)
        return entries

    def get_unique_users(self) -> list:
        users = {}
        for entry in self.get_all_entries():
            user_id = entry["user_id"]
            if user_id not in users:
                users[user_id] = entry
            elif entry["timestamp"] > users[user_id]["timestamp"]:
                users[user_id] = entry
        return list(users.values())

    def get_stats(self) -> dict:
        entries = self.get_all_entries()
        unique_users = self.get_unique_users()
        
        total_entries = len(entries)
        unique_users_count = len(unique_users)
        expired_count = sum(1 for e in entries if e["is_expired"])
        
        fast_count = sum(1 for e in entries if e["method"] == "fast")
        smart_count = sum(1 for e in entries if e["method"] == "smart")
        
        try:
            cache_size = os.path.getsize(self.cache_file.path)
            if cache_size < 1024:
                size_str = f"{cache_size} B"
            elif cache_size < 1024 * 1024:
                size_str = f"{cache_size / 1024:.1f} KB"
            else:
                size_str = f"{cache_size / (1024 * 1024):.2f} MB"
        except:
            size_str = "N/A"
        
        return {
            "total_entries": total_entries,
            "unique_users": unique_users_count,
            "expired_count": expired_count,
            "fast_count": fast_count,
            "smart_count": smart_count,
            "cache_size": size_str
        }


class AgeCheckerAPI:
    DEFAULT_BASE_URL = "https://api.datereg.pro/api/v1"
    def __init__(self, api_key, custom_url=None):
        self.api_key = api_key
        self.base_url = custom_url.strip().rstrip('/') if custom_url else self.DEFAULT_BASE_URL
        self.session = requests.Session()
        self.session.headers.update({"User-Agent": f"ExteraPlugin/{__id__}/{__version__}"})

    def _handle_request_exception(self, e, context):
        _log(f"Network error during {context}: {e}")
        return {"success": False, "error": f"Network error: {e}"}

    def _handle_api_error(self, response, context):
        error_message = f"API request failed for {context} with status code {response.status_code}: {response.text}"
        try: error_data = response.json(); error_message = error_data.get('detail', error_message)
        except: pass
        if response.status_code == 401: error_message = "Invalid API key."
        elif response.status_code == 402: error_message = "Insufficient balance."
        elif response.status_code == 404: error_message = "User not found."
        _log(error_message)
        return {"success": False, "error": error_message}

    def resolve_username(self, username):
        _log(f"Resolving username '{username}'...")
        endpoint = f"{self.base_url}/users/resolveUsername"
        params = {"token": self.api_key, "username": username.lstrip('@')}
        try:
            response = self.session.get(endpoint, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                if data.get('id'):
                    _log(f"Username '{username}' resolved to ID: {data['id']}")
                    return {"success": True, "data": data}
                return {"success": False, "error": "Could not resolve username."}
            return self._handle_api_error(response, f"resolve_username for '{username}'")
        except requests.exceptions.RequestException as e:
            return self._handle_request_exception(e, f"resolve_username for '{username}'")

    def get_info(self, user_id, method="fast"):
        _log(f"Requesting creation date for ID '{user_id}' with method '{method}'")
        endpoint = f"{self.base_url}/users/getCreationDateSmart" if method == "smart" else f"{self.base_url}/users/getCreationDateFast"
        params = {"token": self.api_key, "user_id": user_id}
        try:
            response = self.session.get(endpoint, params=params, timeout=20)
            if response.status_code == 200:
                data = response.json()
                if data.get('creation_date'):
                    _log(f"API success for '{user_id}': {data}")
                    return {"success": True, "data": data}
                _log(f"API error for '{user_id}': Creation date not found in response.")
                return {"success": False, "error": data.get("error", "Creation date not found")}
            return self._handle_api_error(response, f"get_info for '{user_id}'")
        except requests.exceptions.RequestException as e:
            return self._handle_request_exception(e, f"get_info for '{user_id}'")


class LocalizationManager:
    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self._get_supported_languages() else "en"
    def get_string(self, string): return self.strings[self.language][string]
    def _get_supported_languages(self): return self.strings.keys()
    strings = {
        "ru": {
            "USAGE_EXAMPLE": "âš ï¸ *Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ:* `.age [Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ/ID]`\n`.age smart [Ğ¸Ğ¼Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ/ID]` Ğ´Ğ»Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ°",
            "API_ERROR": "â›” *ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞµ Ğº API:*\n\n`{0}`",
            "RESULT": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_WITH_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{12}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_WITH_BIRTHDAY": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{11}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{12}`
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{11}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_NO_USERNAME": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{12}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_BIRTHDAY": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{11}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•*

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{10}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{8}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{12}`
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{11}`
*ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ:* `{2}`
*ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ:* {5} {3}
*â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{4}`
*âš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´:* `{6}`""",
            "CODE_ERROR": "â›” *ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ¾ÑˆĞ»Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ğ² ĞºĞ¾Ğ´Ğµ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ°:*\n\n`{0}`",
            "API_KEY_TITLE": "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ API",
            "API_KEY_DESCRIPTION": "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ²Ğ°Ñˆ API ĞºĞ»ÑÑ‡ Ğ´Ğ»Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº API. ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ ĞºĞ»ÑÑ‡ Ğ² Ğ±Ğ¾Ñ‚Ğµ @dateregbot",
            "NO_API_KEY": "âš ï¸ *API ĞºĞ»ÑÑ‡ Ğ½Ğµ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞ½.* ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚Ğµ API ĞºĞ»ÑÑ‡ Ğ² Ğ±Ğ¾Ñ‚Ğµ @dateregbot Ğ¸ ÑƒĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ĞµĞ³Ğ¾ Ğ² Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ñ… Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ°.",
            "CUSTOM_API_URL_TITLE": "URL API",
            "CUSTOM_API_URL_DESCRIPTION": "Ğ£ĞºĞ°Ğ¶Ğ¸Ñ‚Ğµ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ URL API (Ğ¾ÑÑ‚Ğ°Ğ²ÑŒÑ‚Ğµ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ)",
            "FAQ_COMMAND": "faq",
            "FAQ_CONTENT": """â“ Ğ§ĞĞ¡Ğ¢Ğ Ğ—ĞĞ”ĞĞ’ĞĞ•ĞœĞ«Ğ• Ğ’ĞĞŸĞ ĞĞ¡Ğ« (FAQ)

1. Ğ§Ñ‚Ğ¾ Ğ´ĞµĞ»Ğ°ĞµÑ‚ ÑÑ‚Ğ¾Ñ‚ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½?
ĞŸĞ»Ğ°Ğ³Ğ¸Ğ½ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ğ½ÑƒÑ Ğ´Ğ°Ñ‚Ñƒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Telegram Ğ¿Ğ¾ ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼Ñƒ Ğ¸Ğ»Ğ¸ ID.

2. ĞšĞ°Ğº Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ¾Ñ‚ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½?
Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ .age [ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼/ID] Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ .age
Ğ”Ğ»Ñ Ğ±Ğ¾Ğ»ĞµĞµ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ: .age smart [ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼/ID]

3. ĞŸĞ¾Ñ‡ĞµĞ¼Ñƒ Ğ½ÑƒĞ¶ĞµĞ½ API ĞºĞ»ÑÑ‡?
API ĞºĞ»ÑÑ‡ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ´Ğ»Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº ÑĞµÑ€Ğ²Ğ¸ÑÑƒ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ´Ğ°Ñ‚Ñƒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°.

4. Ğ“Ğ´Ğµ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ API ĞºĞ»ÑÑ‡?
API ĞºĞ»ÑÑ‡ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ² Ğ±Ğ¾Ñ‚Ğµ @dateregbot

5. ĞĞ°ÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹?
Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ÑÑ Ğ² ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğµ Ğ¸ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ñ‚ Ğ¾Ñ‚ Ğ¼Ğ½Ğ¾Ğ³Ğ¸Ñ… Ñ„Ğ°ĞºÑ‚Ğ¾Ñ€Ğ¾Ğ².
ğŸŸ¢ - Ğ²Ñ‹ÑĞ¾ĞºĞ°Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ (87-100%)
ğŸŸ¡ - ÑÑ€ĞµĞ´Ğ½ÑÑ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ (70-86%)
ğŸŸ  - Ğ½Ğ¸Ğ·ĞºĞ°Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ (50-69%)
ğŸ”´ - Ğ¾Ñ‡ĞµĞ½ÑŒ Ğ½Ğ¸Ğ·ĞºĞ°Ñ Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ (<50%)

6. Ğ§Ñ‚Ğ¾ Ğ¾Ğ·Ğ½Ğ°Ñ‡Ğ°ĞµÑ‚ "Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ" Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ…?
Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ°Ğ´ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ğ¸ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ Ğ´Ğ°Ñ‚Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°.

7. Ğ•ÑÑ‚ÑŒ Ğ»Ğ¸ Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ Ğ½Ğ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ?
Ğ”Ğ°, Ğ»Ğ¸Ğ¼Ğ¸Ñ‚Ñ‹ Ğ·Ğ°Ğ²Ğ¸ÑÑÑ‚ Ğ¾Ñ‚ Ğ²Ğ°ÑˆĞµĞ³Ğ¾ API ĞºĞ»ÑÑ‡Ğ° Ğ¸ Ñ‚Ğ°Ñ€Ğ¸Ñ„Ğ° Ñƒ @dateregbot.

8. Ğ§ĞµĞ¼ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ°ÑÑ‚ÑÑ Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ‹ Fast Ğ¸ Smart?
Fast - Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹, Ğ½Ğ¾ Ğ¼ĞµĞ½ĞµĞµ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´
Smart - Ğ±Ğ¾Ğ»ĞµĞµ Ñ‚Ğ¾Ñ‡Ğ½Ñ‹Ğ¹, Ğ½Ğ¾ Ğ±Ğ¾Ğ»ĞµĞµ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¼ĞµÑ‚Ğ¾Ğ´""",
            "PROCESSING": "ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ, Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ ĞµÑ‰Ğµ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ...",
            "LOADING_TITLE": "ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ²Ğ¾Ğ·Ñ€Ğ°ÑÑ‚Ğ° Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°...",
            "CACHED_RESULT_HINT": "_(Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¸Ğ· ĞºÑÑˆĞ°)_",
            "SETTINGS_DEBUG_MODE": "Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸",
            "SETTINGS_DEBUG_MODE_SUBTEXT": "Ğ’ĞºĞ»ÑÑ‡Ğ°ĞµÑ‚ Ğ¿Ğ¾Ğ´Ñ€Ğ¾Ğ±Ğ½Ñ‹Ğµ Ğ»Ğ¾Ğ³Ğ¸ Ğ² logcat Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ¸ Ğ² Ñ€ĞµÑˆĞµĞ½Ğ¸Ğ¸ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼.",
            "SETTINGS_CACHE_DURATION": "Ğ’Ñ€ĞµĞ¼Ñ Ğ¶Ğ¸Ğ·Ğ½Ğ¸ ĞºÑÑˆĞ° (Ğ² ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…)",
            "SETTINGS_CACHE_DURATION_SUBTEXT": "ĞšĞ°Ğº Ğ´Ğ¾Ğ»Ğ³Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹. 86400 = 24 Ñ‡Ğ°ÑĞ°.",
            "SETTINGS_CLEAR_CACHE": "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ ĞºÑÑˆ",
            "SETTINGS_CACHE_CLEARED": "ĞšÑÑˆ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½.",
            "CACHE_DELETE_SUCCESS": "ĞšÑÑˆ Ğ´Ğ»Ñ ID {0} ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½.",
            "CACHE_DELETE_NOT_FOUND": "ĞšÑÑˆ Ğ´Ğ»Ñ ID {0} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.",
            "CACHE_DELETE_USAGE": "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ: .cache <ID>",
            "FAQ_TITLE": "â“ FAQ",
            "SETTINGS_MENU_BUTTON": "ĞšĞ½Ğ¾Ğ¿ĞºĞ° Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ² Ğ¼ĞµĞ½Ñ",
            "SETTINGS_SHOW_BUTTON_DESC": "Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµÑ‚ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾ĞµĞº Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ° Ğ² Ğ¼ĞµĞ½Ñ",
            "SETTINGS_TITLE": "ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Account Age",
            "USE_PREMIUM_EMOJI_TITLE": "ĞŸÑ€ĞµĞ¼Ğ¸ÑƒĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸",
            "USE_PREMIUM_EMOJI_SUBTEXT": "Ğ—Ğ°Ğ¼ĞµĞ½ÑÑ‚ÑŒ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğµ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ½Ğ° Ğ°Ğ½Ğ¸Ğ¼Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ¼Ğ¸ÑƒĞ¼ ÑĞ¼Ğ¾Ğ´Ğ·Ğ¸ Ğ² Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ°Ñ….",
            "DONATE_TITLE": "ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºÑƒ",
            "DONATE_INFO": "Ğ”Ñ€ÑƒĞ³Ğ°Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¸ Ñ€ĞµĞºĞ²Ğ¸Ğ·Ğ¸Ñ‚Ñ‹",
            "FREE_MODE_TITLE": "Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ",
            "FREE_MODE_SUBTEXT": "Ğ‘ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ñ‹Ğ¹ Ñ€ĞµĞ¶Ğ¸Ğ¼ Ğ¿Ğ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ (Ğ±ĞµĞ· Ğ´Ğ°Ñ‚Ñ‹ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ)",
            "FREE_MODE_RESULT": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{4}""",
            "FREE_MODE_RESULT_WITH_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{4}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{5}`""",
            "FREE_MODE_RESULT_WITH_BIRTHDAY": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{4}
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{5}`""",
            "FREE_MODE_RESULT_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* @{4}
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{5}`
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{6}`""",
            "FREE_MODE_NO_USERNAME": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚""",
            "FREE_MODE_NO_USERNAME_WITH_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{4}`""",
            "FREE_MODE_NO_USERNAME_WITH_BIRTHDAY": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{4}`""",
            "FREE_MODE_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š Ğ˜ĞĞ¤ĞĞ ĞœĞĞ¦Ğ˜Ğ¯ ĞĞ‘ ĞĞšĞšĞĞ£ĞĞ¢Ğ•:* (ğŸ†“)

*ğŸªª Ğ˜Ğ¼Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½:* `{3}`
*ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼:* Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚
*ğŸªª ĞĞ¾Ğ¼ĞµÑ€ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:* `{4}`
*ğŸ‰ Ğ”Ğ°Ñ‚Ğ° Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ:* `{5}`""",
            "NFT_USERNAME_HEADER": "ğŸ’ *NFT:*",
            "NFT_USERNAME_ITEM": "â€¢ `@{0}` â€” ĞºÑƒĞ¿Ğ»ĞµĞ½ {1} Ğ·Ğ° {2}",
            "NFT_USERNAME_ITEM_CRYPTO": "â€¢ `@{0}` â€” ĞºÑƒĞ¿Ğ»ĞµĞ½ {1} Ğ·Ğ° {2} ({3})",
            "NFT_USERNAME_LINK": "[Fragment]({0})",
            "NFT_NO_INFO": "â€¢ `@{0}` â€” Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°",
            "SHOW_NFT_USERNAMES": "ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ NFT ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼Ñ‹",
            "SHOW_NFT_USERNAMES_SUBTEXT": "ĞÑ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ Ğ¿Ğ¾ĞºÑƒĞ¿Ğ½Ñ‹Ñ… ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼Ğ°Ñ… Ñ Fragment",
            "USE_COLLAPSIBLE_QUOTE": "Ğ¡Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼Ğ°Ñ Ñ†Ğ¸Ñ‚Ğ°Ñ‚Ğ°",
            "USE_COLLAPSIBLE_QUOTE_SUBTEXT": "ĞĞ±Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ Ğ² ÑĞ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ÑƒÑ Ñ†Ğ¸Ñ‚Ğ°Ñ‚Ñƒ (blockquote)",
            "PLUGIN_INFO_TITLE": "Ğ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğµ",
            "PLUGIN_INFO_WELCOME": "Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ, {name}!\n\nAccount Age Checker Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ ÑƒĞ·Ğ½Ğ°Ñ‚ÑŒ Ğ´Ğ°Ñ‚Ñƒ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ° Telegram. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ .age [username/ID] Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑŒÑ‚Ğµ Ğ½Ğ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ¾Ğ¹ .age",
            "PLUGIN_INFO_VERSION": "Ğ’ĞµÑ€ÑĞ¸Ñ: {version}",
            "PLUGIN_INFO_AUTHOR": "ĞĞ²Ñ‚Ğ¾Ñ€: {author}",
            "PLUGIN_INFO_BUTTON": "ĞŸĞ¾Ğ½ÑÑ‚Ğ½Ğ¾",
            "PLUGIN_CHANNEL": "ĞšĞ°Ğ½Ğ°Ğ» Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ°",
            "PLUGIN_SUPPORT": "ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°",
            "CACHE_MANAGEMENT": "Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ ĞºĞµÑˆĞµĞ¼",
            "CACHE_VIEW_USERS": "ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ ĞºĞµÑˆĞ°",
            "CACHE_VIEW_USERS_SUBTEXT": "ĞŸÑ€Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ·Ğ°ĞºĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑĞ¼Ğ¸",
            "CACHE_STATS": "Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ĞºĞµÑˆĞ°",
            "CACHE_STATS_TOTAL": "Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {0}",
            "CACHE_STATS_USERS": "Ğ£Ğ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹: {0}",
            "CACHE_STATS_EXPIRED": "Ğ˜ÑÑ‚ĞµĞºÑˆĞ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹: {0}",
            "CACHE_STATS_FAST": "Fast Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²: {0}",
            "CACHE_STATS_SMART": "Smart Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²: {0}",
            "CACHE_STATS_SIZE": "Ğ Ğ°Ğ·Ğ¼ĞµÑ€ ĞºĞµÑˆĞ°: {0}",
            "CACHE_USER_ITEM": "{0} (ID: {1})",
            "CACHE_USER_DETAILS": "ğŸ‘¤ {0}\nğŸ†” ID: {1}\nğŸ”— @{2}\nğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ: {3}\nğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ: {4}%\nâš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´: {5}\nâ± ĞšĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {6}\nâ³ ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {7}",
            "CACHE_USER_DETAILS_NO_USERNAME": "ğŸ‘¤ {0}\nğŸ†” ID: {1}\nğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ: {2}\nğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ: {3}%\nâš™ï¸ ĞœĞµÑ‚Ğ¾Ğ´: {4}\nâ± ĞšĞµÑˆĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½: {5}\nâ³ ĞÑÑ‚Ğ°Ğ»Ğ¾ÑÑŒ: {6}",
            "CACHE_TIME_LEFT": "{0}Ñ‡ {1}Ğ¼",
            "CACHE_TIME_LEFT_MINUTES": "{0}Ğ¼",
            "CACHE_EXPIRED": "Ğ˜ÑÑ‚Ñ‘Ğº",
            "CACHE_DELETE_USER": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ· ĞºĞµÑˆĞ°",
            "CACHE_DELETE_CONFIRM": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {0} Ğ¸Ğ· ĞºĞµÑˆĞ°?",
            "CACHE_EMPTY": "ĞšĞµÑˆ Ğ¿ÑƒÑÑ‚",
            "CACHE_PRUNE_EXPIRED": "ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¸ÑÑ‚ĞµĞºÑˆĞ¸Ğµ",
            "CACHE_PRUNE_EXPIRED_SUBTEXT": "Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ñ Ğ¸ÑÑ‚ĞµĞºÑˆĞ¸Ğ¼ ÑÑ€Ğ¾ĞºĞ¾Ğ¼ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ",
            "CACHE_PRUNED": "Ğ£Ğ´Ğ°Ğ»ĞµĞ½Ğ¾ {0} Ğ¸ÑÑ‚ĞµĞºÑˆĞ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹",
            "CACHE_NO_EXPIRED": "ĞĞµÑ‚ Ğ¸ÑÑ‚ĞµĞºÑˆĞ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹",
        },
        "en": {
            "USAGE_EXAMPLE": "âš ï¸ *Usage:* `.age [username/ID]`\n`.age smart [username/ID]` for more accurate analysis",
            "API_ERROR": "â›” *An error occurred while querying the API:*\n\n`{0}`",
            "RESULT": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_WITH_PHONE": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸªª Phone Number:* `{12}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_WITH_BIRTHDAY": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸ‰ Birthday:* `{11}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸªª Phone Number:* `{12}`
*ğŸ‰ Birthday:* `{11}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_NO_USERNAME": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_PHONE": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸªª Phone Number:* `{12}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_BIRTHDAY": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸ‰ Birthday:* `{11}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "RESULT_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š ACCOUNT INFORMATION*

*ğŸªª Account Name:* `{7}`
*ğŸ‘¤ ID:* `{0}`
*ğŸ–¥ DC:* `{9}`
*ğŸ³ï¸ Region:* `{10}`
*ğŸ”— Username:* @{8}
*ğŸªª Phone Number:* `{12}`
*ğŸ‰ Birthday:* `{11}`
*ğŸ“… Creation Date:* `{2}`
*ğŸ¯ Accuracy:* {5} {3}
*â³ Account Age:* `{4}`
*âš™ï¸ Method:* `{6}`""",
            "CODE_ERROR": "â›” *An error occurred in the plugin code:*\n\n`{0}`",
            "API_KEY_TITLE": "API Settings",
            "API_KEY_DESCRIPTION": "Enter your API key for API access. Get a key from @dateregbot",
            "NO_API_KEY": "âš ï¸ *API key not configured.* Get an API key from @dateregbot and set it in the plugin settings.",
            "CUSTOM_API_URL_TITLE": "API URL",
            "CUSTOM_API_URL_DESCRIPTION": "Specify custom API URL (leave empty to use default)",
            "FAQ_COMMAND": "faq",
            "FAQ_CONTENT": """â“ FREQUENTLY ASKED QUESTIONS (FAQ)

1. What does this plugin do?
This plugin checks the approximate creation date of a Telegram account by username or ID.

2. How do I use this plugin?
Use the command .age [username/ID] or reply to a message with .age
For more accurate analysis use: .age smart [username/ID]

3. Why do I need an API key?
The API key is required to access the service that determines account creation dates.

4. How do I get an API key?
You can obtain an API key from the bot @dateregbot

5. How accurate are the results?
Accuracy is indicated in each result and depends on various factors.
ğŸŸ¢ - high accuracy (87-100%)
ğŸŸ¡ - medium accuracy (70-86%)
ğŸŸ  - low accuracy (50-69%)
ğŸ”´ - very low accuracy (<50%)

6. What does "accuracy" in the results mean?
It's an indicator of how reliable the account creation date determination is.

7. Are there any usage limits?
Yes, limits depend on your API key and service plan from @dateregbot.

8. What's the difference between Fast and Smart methods?
Fast - quick but less accurate method
Smart - more accurate but slower method""",
            "PROCESSING": "Please wait, the previous request is still being processed...",
            "LOADING_TITLE": "Checking Account Age...",
            "CACHED_RESULT_HINT": "_(Result from cache)_",
            "SETTINGS_DEBUG_MODE": "Debug Mode",
            "SETTINGS_DEBUG_MODE_SUBTEXT": "Enables detailed logs in logcat to help with troubleshooting.",
            "SETTINGS_CACHE_DURATION": "Cache Lifetime (in seconds)",
            "SETTINGS_CACHE_DURATION_SUBTEXT": "How long to store results. 86400 = 24 hours.",
            "SETTINGS_CLEAR_CACHE": "Clear Cache",
            "SETTINGS_CACHE_CLEARED": "Cache cleared successfully.",
            "CACHE_DELETE_SUCCESS": "Cache for ID {0} cleared successfully.",
            "CACHE_DELETE_NOT_FOUND": "No cache found for ID {0}.",
            "CACHE_DELETE_USAGE": "Usage: .cache <ID>",
            "FAQ_TITLE": "â“ FAQ",
            "SETTINGS_MENU_BUTTON": "Settings button in menu",
            "SETTINGS_SHOW_BUTTON_DESC": "Adds plugin settings button to menu",
            "SETTINGS_TITLE": "Account Age Settings",
            "USE_PREMIUM_EMOJI_TITLE": "Premium emoji",
            "USE_PREMIUM_EMOJI_SUBTEXT": "Replace regular emoji with animated premium emoji in results.",
            "DONATE_TITLE": "Support development",
            "DONATE_INFO": "Other info and requisites",
            "FREE_MODE_TITLE": "Usage Mode",
            "FREE_MODE_SUBTEXT": "Free mode shows only local data (without creation date)",
            "FREE_MODE_RESULT": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* @{4}""",
            "FREE_MODE_RESULT_WITH_PHONE": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* @{4}
*ğŸªª Phone Number:* `{5}`""",
            "FREE_MODE_RESULT_WITH_BIRTHDAY": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* @{4}
*ğŸ‰ Birthday:* `{5}`""",
            "FREE_MODE_RESULT_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* @{4}
*ğŸªª Phone Number:* `{5}`
*ğŸ‰ Birthday:* `{6}`""",
            "FREE_MODE_NO_USERNAME": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* not available""",
            "FREE_MODE_NO_USERNAME_WITH_PHONE": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* not available
*ğŸªª Phone Number:* `{4}`""",
            "FREE_MODE_NO_USERNAME_WITH_BIRTHDAY": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* not available
*ğŸ‰ Birthday:* `{4}`""",
            "FREE_MODE_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE": """*ğŸ“Š ACCOUNT INFORMATION:* (ğŸ†“)

*ğŸªª Account Name:* `{0}`
*ğŸ‘¤ ID:* `{1}`
*ğŸ–¥ DC:* `{2}`
*ğŸ³ï¸ Region:* `{3}`
*ğŸ”— Username:* not available
*ğŸªª Phone Number:* `{4}`
*ğŸ‰ Birthday:* `{5}`""",
            "NFT_USERNAME_HEADER": "ğŸ’ *NFT USERNAMES:*",
            "NFT_USERNAME_ITEM": "â€¢ `@{0}` â€” purchased {1} for {2}",
            "NFT_USERNAME_ITEM_CRYPTO": "â€¢ `@{0}` â€” purchased {1} for {2} ({3})",
            "NFT_USERNAME_LINK": "[Fragment]({0})",
            "NFT_NO_INFO": "â€¢ `@{0}` â€” info unavailable",
            "SHOW_NFT_USERNAMES": "Show NFT usernames",
            "SHOW_NFT_USERNAMES_SUBTEXT": "Display information about purchased usernames from Fragment",
            "USE_COLLAPSIBLE_QUOTE": "Collapsible quote",
            "USE_COLLAPSIBLE_QUOTE_SUBTEXT": "Wrap report in a collapsible quote (blockquote)",
            "PLUGIN_INFO_TITLE": "About Plugin",
            "PLUGIN_INFO_WELCOME": "Welcome, {name}!\n\nAccount Age Checker allows you to find out the creation date of a Telegram account. Use the command .age [username/ID] or reply to a message with .age",
            "PLUGIN_INFO_VERSION": "Version: {version}",
            "PLUGIN_INFO_AUTHOR": "Author: {author}",
            "PLUGIN_INFO_BUTTON": "Got it",
            "PLUGIN_CHANNEL": "Plugin Channel",
            "PLUGIN_SUPPORT": "Support",
            "CACHE_MANAGEMENT": "Cache Management",
            "CACHE_VIEW_USERS": "View Cache",
            "CACHE_VIEW_USERS_SUBTEXT": "View and manage cached users",
            "CACHE_STATS": "Cache Statistics",
            "CACHE_STATS_TOTAL": "Total entries: {0}",
            "CACHE_STATS_USERS": "Unique users: {0}",
            "CACHE_STATS_EXPIRED": "Expired entries: {0}",
            "CACHE_STATS_FAST": "Fast requests: {0}",
            "CACHE_STATS_SMART": "Smart requests: {0}",
            "CACHE_STATS_SIZE": "Cache size: {0}",
            "CACHE_USER_ITEM": "{0} (ID: {1})",
            "CACHE_USER_DETAILS": "ğŸ‘¤ {0}\nğŸ†” ID: {1}\nğŸ”— @{2}\nğŸ“… Creation date: {3}\nğŸ¯ Accuracy: {4}%\nâš™ï¸ Method: {5}\nâ± Cached: {6}\nâ³ Time left: {7}",
            "CACHE_USER_DETAILS_NO_USERNAME": "ğŸ‘¤ {0}\nğŸ†” ID: {1}\nğŸ“… Creation date: {2}\nğŸ¯ Accuracy: {3}%\nâš™ï¸ Method: {4}\nâ± Cached: {5}\nâ³ Time left: {6}",
            "CACHE_TIME_LEFT": "{0}h {1}m",
            "CACHE_TIME_LEFT_MINUTES": "{0}m",
            "CACHE_EXPIRED": "Expired",
            "CACHE_DELETE_USER": "Delete from cache",
            "CACHE_DELETE_CONFIRM": "Delete user {0} data from cache?",
            "CACHE_EMPTY": "Cache is empty",
            "CACHE_PRUNE_EXPIRED": "Clear expired",
            "CACHE_PRUNE_EXPIRED_SUBTEXT": "Remove entries with expired storage time",
            "CACHE_PRUNED": "Removed {0} expired entries",
            "CACHE_NO_EXPIRED": "No expired entries",
        }
    }
locali = LocalizationManager()


class AccountAgePlugin(BasePlugin):
    _debug_enabled = False

    def __init__(self):
        super().__init__()
        self.is_processing = False
        self.api_client = None
        self.alert_dialog = None
        self.cache_manager = CacheManager(self)
        self._drawer_settings_item = None
        self._chat_settings_item = None
        self.profile_menu_item_id = None

    @classmethod
    def is_debug_globally_enabled(cls):
        return cls._debug_enabled

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.load_config()
        self.cache_manager.prune_expired()
        _log("Plugin loaded and cache pruned.")
        try:
            if self.get_setting("show_settings_buttons", True):
                self._add_settings_menu_items()
        except Exception as e:
            _log(f"Failed to add settings menu items on load: {e}")


        try:
            self.profile_menu_item_id = self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.PROFILE_ACTION_MENU,
                    item_id="account_info_button",
                    text="Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ",
                    icon="msg_info",
                    on_click=self._handle_profile_info_click,
                    condition="user != null"
                )
            )
            _log("Profile menu item added successfully.")
        except Exception as e:
            _log(f"Failed to add profile menu item: {e}")

    def on_plugin_unload(self):
        try:
            if self._drawer_settings_item: self.remove_menu_item(self._drawer_settings_item)
            if self._chat_settings_item: self.remove_menu_item(self._chat_settings_item)
            if self.profile_menu_item_id: self.remove_menu_item(self.profile_menu_item_id)
        except Exception as e: _log(f"Error removing menu items on unload: {e}")
        _log("Plugin unloaded.")

    def load_config(self, _=None):
        AccountAgePlugin._debug_enabled = self.get_setting("debug_mode", False)
        api_key = self.get_setting("api_key", "").strip()
        custom_url = self.get_setting("custom_api_url", "").strip()
        if api_key: self.api_client = AgeCheckerAPI(api_key, custom_url); _log("API client configured.")
        else: self.api_client = None; _log("API key is not set. API client is disabled.")

    def create_settings(self):
        user_name = self._get_current_user_name()
        welcome_text = locali.get_string("PLUGIN_INFO_WELCOME").format(name=user_name)
        
        return [
            Divider(text=welcome_text),
            Header(locali.get_string("FREE_MODE_TITLE")),
            Switch(key="free_mode", text=locali.get_string("FREE_MODE_TITLE"), subtext=locali.get_string("FREE_MODE_SUBTEXT"), default=True, on_change=self.load_config, icon="msg_calendar_solar"),
            Switch(key="show_nft_usernames", text=locali.get_string("SHOW_NFT_USERNAMES"), subtext=locali.get_string("SHOW_NFT_USERNAMES_SUBTEXT"), default=True, icon="menu_feature_premium"),
            Switch(key="use_collapsible_quote", text=locali.get_string("USE_COLLAPSIBLE_QUOTE"), subtext=locali.get_string("USE_COLLAPSIBLE_QUOTE_SUBTEXT"), default=False, icon="menu_quote_solar"),
            Divider(),
            Header(locali.get_string("API_KEY_TITLE")),
            Input(key="api_key", text=locali.get_string("API_KEY_TITLE"), subtext=locali.get_string("API_KEY_DESCRIPTION"), default="", on_change=self.load_config, icon="msg_pin_code"),
            Input(key="custom_api_url", text=locali.get_string("CUSTOM_API_URL_TITLE"), subtext=locali.get_string("CUSTOM_API_URL_DESCRIPTION"), default="", on_change=self.load_config, icon="msg_link"),
            Divider(), Header(locali.get_string("CACHE_MANAGEMENT")),
            Input(key="cache_duration", text=locali.get_string("SETTINGS_CACHE_DURATION"), subtext=locali.get_string("SETTINGS_CACHE_DURATION_SUBTEXT"), default="86400", icon="msg_stories_timer"),
            Text(text=locali.get_string("CACHE_VIEW_USERS"), icon="msg_contacts", on_click=self._show_cache_users_dialog),
            Text(text=locali.get_string("CACHE_STATS"), icon="msg_stats", on_click=self._show_cache_stats_dialog),
            Text(text=locali.get_string("CACHE_PRUNE_EXPIRED"), icon="msg_clearcache", on_click=self._prune_expired_cache),
            Text(text=locali.get_string("SETTINGS_CLEAR_CACHE"), icon="msg_delete", red=True, on_click=self._clear_cache),
            Divider(), Header("Debug"),
            Switch(key="debug_mode", text=locali.get_string("SETTINGS_DEBUG_MODE"), subtext=locali.get_string("SETTINGS_DEBUG_MODE_SUBTEXT"), default=False, on_change=self.load_config, icon="msg_log"),
            Switch(key="show_settings_buttons", text=locali.get_string("SETTINGS_MENU_BUTTON"), icon="msg_reorder", default=True, subtext=locali.get_string("SETTINGS_SHOW_BUTTON_DESC"), on_change=self._on_show_settings_buttons_change),
            Switch(key="use_premium_emoji", text=locali.get_string("USE_PREMIUM_EMOJI_TITLE"), subtext=locali.get_string("USE_PREMIUM_EMOJI_SUBTEXT"), icon="menu_feature_reactions_remix", default=False),
            Divider(),
            Text(text=locali.get_string("PLUGIN_INFO_TITLE"), icon="msg_info", on_click=lambda view: self._show_plugin_info_sheet()),
            Text(text=locali.get_string("PLUGIN_CHANNEL"), icon="msg_channel", accent=True, on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("mishabotov", get_last_fragment(), 1))),
            Text(text=locali.get_string("PLUGIN_SUPPORT"), icon="msg_help", accent=True, on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("mew_help", get_last_fragment(), 1))),
            Divider(), Header(text=locali.get_string("DONATE_TITLE")),
            Text(text="CRYPTO [Crypto Bot]", icon="menu_cashtag", accent=True, on_click=lambda view: run_on_ui_thread(lambda: self._copy_to_clipboard("CRYPTO", "http://t.me/send?start=IVhqWW9Mz8MU"))),
            Text(text=locali.get_string("DONATE_INFO"), icon="menu_feature_reactions", accent=True, on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("mishabotov", get_last_fragment(), 1)))
        ]

    def _get_current_user_name(self) -> str:
        try:
            from org.telegram.messenger import UserConfig, ContactsController, MessagesController
            account = getattr(UserConfig, 'selectedAccount', 0)
            mc = MessagesController.getInstance(account)
            me = UserConfig.getInstance(account)
            user = mc.getUser(me.getClientUserId()) if mc and me else None
            if user:
                try:
                    return ContactsController.formatName(user.first_name, user.last_name).replace('\n', ' ')
                except Exception:
                    if user.first_name:
                        return user.first_name
            return ""
        except Exception as e:
            _log(f"Error getting current user name: {e}")
            return ""

    def _show_plugin_info_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            from org.telegram.messenger import AndroidUtilities
            from android.widget import LinearLayout, TextView, FrameLayout, ScrollView
            from android.view import Gravity, ViewGroup
            from android.util import TypedValue
            from android_utils import OnClickListener
            
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            
            scroll_view = ScrollView(ctx)
            
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)
            
            MATCH_PARENT = ViewGroup.LayoutParams.MATCH_PARENT
            WRAP_CONTENT = ViewGroup.LayoutParams.WRAP_CONTENT

            title_view = TextView(ctx)
            title_view.setText(__name__)
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            title_view.setGravity(Gravity.CENTER)
            lp_title = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT)
            lp_title.setMargins(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(4))
            container.addView(title_view, lp_title)

            info_view = TextView(ctx)
            info_view.setText(f"v{__version__} â€¢ {__author__}")
            try:
                info_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            except Exception:
                pass
            info_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            info_view.setGravity(Gravity.CENTER)
            lp_info = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT)
            lp_info.setMargins(AndroidUtilities.dp(24), 0, AndroidUtilities.dp(24), AndroidUtilities.dp(16))
            container.addView(info_view, lp_info)

            faq_view = TextView(ctx)
            faq_view.setText(locali.get_string("FAQ_CONTENT"))
            try:
                faq_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            faq_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            faq_view.setGravity(Gravity.START)
            faq_view.setLineSpacing(AndroidUtilities.dp(2), 1.0)
            lp_faq = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT)
            lp_faq.setMargins(AndroidUtilities.dp(24), 0, AndroidUtilities.dp(24), AndroidUtilities.dp(24))
            container.addView(faq_view, lp_faq)

            button_container = FrameLayout(ctx)
            try:
                from android.graphics.drawable import GradientDrawable
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(AndroidUtilities.dp(8))
                try:
                    button_bg.setStroke(AndroidUtilities.dp(2), Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(AndroidUtilities.dp(2), 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(locali.get_string("PLUGIN_INFO_BUTTON"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))
            if button_bg:
                btn.setBackground(button_bg)
            
            lp_btn = FrameLayout.LayoutParams(MATCH_PARENT, AndroidUtilities.dp(48))
            lp_btn.gravity = Gravity.CENTER
            button_container.addView(btn, lp_btn)

            def _on_click(*args):
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            lp_btn_container = LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT)
            lp_btn_container.setMargins(AndroidUtilities.dp(24), AndroidUtilities.dp(8), AndroidUtilities.dp(24), AndroidUtilities.dp(24))
            container.addView(button_container, lp_btn_container)

            scroll_view.addView(container, LinearLayout.LayoutParams(MATCH_PARENT, WRAP_CONTENT))
            
            sheet.setCustomView(scroll_view)
            run_on_ui_thread(sheet.show)
        except Exception as e:
            _log(f"Error showing plugin info sheet: {e}")

    def _clear_cache(self, _=None):
        self.cache_manager.clear()
        message = locali.get_string("SETTINGS_CACHE_CLEARED")
        BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))

    def _show_cache_users_dialog(self, _=None):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            users = self.cache_manager.get_unique_users()
            
            if not users:
                BulletinHelper.show_info(locali.get_string("CACHE_EMPTY"))
                return
            
            items = []
            for user in users:
                name = user["account_name"] if user["account_name"] != "ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" else f"ID: {user['user_id']}"
                items.append(locali.get_string("CACHE_USER_ITEM").format(name, user["user_id"]))
            
            def on_user_click(builder, index):
                builder.dismiss()
                selected_user = users[index]
                run_on_ui_thread(lambda: self._show_user_cache_details(selected_user))
            
            builder = AlertDialogBuilder(fragment.getParentActivity())
            builder.set_title(locali.get_string("CACHE_VIEW_USERS"))
            builder.set_items(items, on_user_click)
            builder.set_negative_button("OK", lambda b, w: b.dismiss())
            run_on_ui_thread(builder.show)
            
        except Exception as e:
            _log(f"Error showing cache users dialog: {e}")
            BulletinHelper.show_error(f"Error: {str(e)}")

    def _show_user_cache_details(self, user_entry: dict):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            cached_time = datetime.fromtimestamp(user_entry["timestamp"])
            cached_str = cached_time.strftime("%d.%m.%Y %H:%M")
            
            time_left = user_entry["time_left"]
            if time_left <= 0:
                time_left_str = locali.get_string("CACHE_EXPIRED")
            elif time_left >= 3600:
                hours = int(time_left // 3600)
                minutes = int((time_left % 3600) // 60)
                time_left_str = locali.get_string("CACHE_TIME_LEFT").format(hours, minutes)
            else:
                minutes = int(time_left // 60)
                time_left_str = locali.get_string("CACHE_TIME_LEFT_MINUTES").format(minutes)
            
            if user_entry["username"]:
                details = locali.get_string("CACHE_USER_DETAILS").format(
                    user_entry["account_name"],
                    user_entry["user_id"],
                    user_entry["username"],
                    user_entry["creation_date"],
                    user_entry["accuracy_percent"],
                    user_entry["method"].capitalize(),
                    cached_str,
                    time_left_str
                )
            else:
                details = locali.get_string("CACHE_USER_DETAILS_NO_USERNAME").format(
                    user_entry["account_name"],
                    user_entry["user_id"],
                    user_entry["creation_date"],
                    user_entry["accuracy_percent"],
                    user_entry["method"].capitalize(),
                    cached_str,
                    time_left_str
                )
            
            def on_delete_click(builder, which):
                builder.dismiss()
                self._confirm_delete_user_cache(user_entry)
            
            builder = AlertDialogBuilder(fragment.getParentActivity())
            builder.set_title(user_entry["account_name"])
            builder.set_message(details)
            builder.set_positive_button("OK", lambda b, w: b.dismiss())
            builder.set_negative_button(locali.get_string("CACHE_DELETE_USER"), on_delete_click)
            builder.make_button_red(AlertDialogBuilder.BUTTON_NEGATIVE)
            run_on_ui_thread(builder.show)
            
        except Exception as e:
            _log(f"Error showing user cache details: {e}")
            BulletinHelper.show_error(f"Error: {str(e)}")

    def _confirm_delete_user_cache(self, user_entry: dict):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            def on_confirm(builder, which):
                builder.dismiss()
                if self.cache_manager.delete(user_entry["user_id"]):
                    message = locali.get_string("CACHE_DELETE_SUCCESS").format(user_entry["user_id"])
                    BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))
                else:
                    message = locali.get_string("CACHE_DELETE_NOT_FOUND").format(user_entry["user_id"])
                    BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))
            
            builder = AlertDialogBuilder(fragment.getParentActivity())
            builder.set_title(locali.get_string("CACHE_DELETE_USER"))
            builder.set_message(locali.get_string("CACHE_DELETE_CONFIRM").format(user_entry["account_name"]))
            builder.set_positive_button("OK", on_confirm)
            builder.set_negative_button("Cancel", lambda b, w: b.dismiss())
            builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
            run_on_ui_thread(builder.show)
            
        except Exception as e:
            _log(f"Error confirming delete user cache: {e}")

    def _show_cache_stats_dialog(self, _=None):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            stats = self.cache_manager.get_stats()
            
            stats_text = "\n".join([
                locali.get_string("CACHE_STATS_TOTAL").format(stats["total_entries"]),
                locali.get_string("CACHE_STATS_USERS").format(stats["unique_users"]),
                locali.get_string("CACHE_STATS_EXPIRED").format(stats["expired_count"]),
                locali.get_string("CACHE_STATS_FAST").format(stats["fast_count"]),
                locali.get_string("CACHE_STATS_SMART").format(stats["smart_count"]),
                locali.get_string("CACHE_STATS_SIZE").format(stats["cache_size"])
            ])
            
            builder = AlertDialogBuilder(fragment.getParentActivity())
            builder.set_title(locali.get_string("CACHE_STATS"))
            builder.set_message(stats_text)
            builder.set_positive_button("OK", lambda b, w: b.dismiss())
            run_on_ui_thread(builder.show)
            
        except Exception as e:
            _log(f"Error showing cache stats dialog: {e}")
            BulletinHelper.show_error(f"Error: {str(e)}")

    def _prune_expired_cache(self, _=None):
        try:
            stats_before = self.cache_manager.get_stats()
            expired_count = stats_before["expired_count"]
            
            if expired_count == 0:
                BulletinHelper.show_info(locali.get_string("CACHE_NO_EXPIRED"))
                return
            
            self.cache_manager.prune_expired()
            message = locali.get_string("CACHE_PRUNED").format(expired_count)
            BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))
            
        except Exception as e:
            _log(f"Error pruning expired cache: {e}")
            BulletinHelper.show_error(f"Error: {str(e)}")

    def _format_age(self, creation_date_str):
        if not creation_date_str: return "N/A"
        try: month, year = map(int, creation_date_str.split('.'))
        except: return "N/A"
        now = datetime.now()
        year_diff, month_diff = now.year - year, now.month - month
        if month_diff < 0: year_diff -= 1; month_diff += 12
        if locali.language == "ru":
            if year_diff > 0:
                y_str = f"{year_diff} Ğ³Ğ¾Ğ´" if year_diff == 1 else (f"{year_diff} Ğ³Ğ¾Ğ´Ğ°" if 1 < year_diff < 5 else f"{year_diff} Ğ»ĞµÑ‚")
                if month_diff > 0:
                    m_str = f"{month_diff} Ğ¼ĞµÑÑÑ†" if month_diff == 1 else (f"{month_diff} Ğ¼ĞµÑÑÑ†Ğ°" if 1 < month_diff < 5 else f"{month_diff} Ğ¼ĞµÑÑÑ†ĞµĞ²")
                    return f"{y_str} Ğ¸ {m_str}"
                return y_str
            else:
                return "Ğ¼ĞµĞ½ĞµĞµ Ğ¼ĞµÑÑÑ†Ğ°" if month_diff == 0 else (f"{month_diff} Ğ¼ĞµÑÑÑ†" if month_diff == 1 else (f"{month_diff} Ğ¼ĞµÑÑÑ†Ğ°" if 1 < month_diff < 5 else f"{month_diff} Ğ¼ĞµÑÑÑ†ĞµĞ²"))
        else:
            y_str, m_str = f"{year_diff} year" + ("s" if year_diff != 1 else ""), f"{month_diff} month" + ("s" if month_diff != 1 else "")
            if year_diff > 0 and month_diff > 0: return f"{y_str} and {m_str}"
            elif year_diff > 0: return y_str
            elif month_diff > 0: return m_str
            else: return "less than a month"

    def _format_response_data(self, data, method):
        age_str = self._format_age(data.get('creation_date', ''))
        accuracy_percent = data.get('accuracy_percent', 0)
        accuracy_emoji = self.get_accuracy_emoji(accuracy_percent)
        display_username = data.get('username')
        accuracy_text = f"_{data.get('accuracy_text', 'Unknown')}_"

        account_name = get_account_name_from_telegram(str(data.get('user_id', '')))
        all_usernames_display = get_all_usernames_display(str(data.get('user_id', '')))
        telegram_username = all_usernames_display if all_usernames_display else get_username_from_telegram(str(data.get('user_id', '')))

        user_id = str(data.get('user_id', ''))
        dc_id = get_user_datacenter_id(user_id)
        region = get_region_from_datacenter(dc_id)

        birthday = get_user_birthday_from_telegram(user_id)
        has_birthday = bool(birthday)

        phone_number = ""
        has_phone = False

        try:
            from client_utils import get_user_config
            current_user_id = get_user_config().getClientUserId()
            if int(user_id) != current_user_id:
                phone_number = get_user_phone_from_telegram(user_id)
                has_phone = bool(phone_number)
        except Exception as e:
            _log(f"Error checking current user: {e}")

        
        dc_display = str(dc_id) if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")
        region_display = region if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")

        if telegram_username:
            if telegram_username.startswith("@"):
                username_display = telegram_username[1:]
            else:
                username_display = telegram_username
        elif display_username and display_username.lower() != "n/a":
            username_display = display_username
        else:
            username_display = "Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚" if locali.language == "ru" else "not available"

        if display_username and display_username.lower() != "n/a":
            if has_birthday and has_phone:
                result = locali.get_string("RESULT_WITH_BIRTHDAY_AND_PHONE").format(
                    data.get('user_id'), display_username, data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, birthday, phone_number
                )
            elif has_birthday:
                result = locali.get_string("RESULT_WITH_BIRTHDAY").format(
                    data.get('user_id'), display_username, data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, birthday
                )
            elif has_phone:
                result = locali.get_string("RESULT_WITH_PHONE").format(
                    data.get('user_id'), display_username, data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, "", phone_number
                )
            else:
                result = locali.get_string("RESULT").format(
                    data.get('user_id'), display_username, data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display
                )
        else:
            if has_birthday and has_phone:
                result = locali.get_string("RESULT_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE").format(
                    data.get('user_id'), "", data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, birthday, phone_number
                )
            elif has_birthday:
                result = locali.get_string("RESULT_NO_USERNAME_WITH_BIRTHDAY").format(
                    data.get('user_id'), "", data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, birthday
                )
            elif has_phone:
                result = locali.get_string("RESULT_NO_USERNAME_WITH_PHONE").format(
                    data.get('user_id'), "", data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display, "", phone_number
                )
            else:
                result = locali.get_string("RESULT_NO_USERNAME").format(
                    data.get('user_id'), "", data.get('creation_date'),
                    accuracy_text, age_str, accuracy_emoji, method.capitalize(), account_name, username_display, dc_display, region_display
                )

        use_premium_emoji = self.get_setting("use_premium_emoji", False)
        if use_premium_emoji:
            result = replace_with_premium_emoji(result)

        return result

    def _format_free_mode_response(self, user_id: str) -> str:
        try:
            account_name = get_account_name_from_telegram(user_id)
            all_usernames_display = get_all_usernames_display(user_id)
            telegram_username = all_usernames_display if all_usernames_display else get_username_from_telegram(user_id)

            dc_id = get_user_datacenter_id(user_id)
            region = get_region_from_datacenter(dc_id)

            birthday = get_user_birthday_from_telegram(user_id)
            has_birthday = bool(birthday)

            phone_number = ""
            has_phone = False

            try:
                from client_utils import get_user_config
                current_user_id = get_user_config().getClientUserId()
                if int(user_id) != current_user_id:
                    phone_number = get_user_phone_from_telegram(user_id)
                    has_phone = bool(phone_number)
            except Exception as e:
                _log(f"Error checking current user: {e}")

            
            dc_display = str(dc_id) if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")
            region_display = region if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")

            if telegram_username:
                if telegram_username.startswith("@"):
                    username_display = telegram_username[1:]
                else:
                    username_display = telegram_username
            else:
                username_display = "Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚" if locali.language == "ru" else "not available"

            if telegram_username:
                if has_birthday and has_phone:
                    result = locali.get_string("FREE_MODE_RESULT_WITH_BIRTHDAY_AND_PHONE").format(
                        account_name, user_id, dc_display, region_display, username_display, phone_number, birthday
                    )
                elif has_birthday:
                    result = locali.get_string("FREE_MODE_RESULT_WITH_BIRTHDAY").format(
                        account_name, user_id, dc_display, region_display, username_display, birthday
                    )
                elif has_phone:
                    result = locali.get_string("FREE_MODE_RESULT_WITH_PHONE").format(
                        account_name, user_id, dc_display, region_display, username_display, phone_number
                    )
                else:
                    result = locali.get_string("FREE_MODE_RESULT").format(
                        account_name, user_id, dc_display, region_display, username_display
                    )
            else:
                if has_birthday and has_phone:
                    result = locali.get_string("FREE_MODE_NO_USERNAME_WITH_BIRTHDAY_AND_PHONE").format(
                        account_name, user_id, dc_display, region_display, phone_number, birthday
                    )
                elif has_birthday:
                    result = locali.get_string("FREE_MODE_NO_USERNAME_WITH_BIRTHDAY").format(
                        account_name, user_id, dc_display, region_display, birthday
                    )
                elif has_phone:
                    result = locali.get_string("FREE_MODE_NO_USERNAME_WITH_PHONE").format(
                        account_name, user_id, dc_display, region_display, phone_number
                    )
                else:
                    result = locali.get_string("FREE_MODE_NO_USERNAME").format(
                        account_name, user_id, dc_display, region_display
                    )

            use_premium_emoji = self.get_setting("use_premium_emoji", False)
            if use_premium_emoji:
                result = replace_with_premium_emoji(result)

            return result

        except Exception as e:
            _log(f"Error formatting free mode response: {e}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            return error_message

    def _get_nft_usernames_info(self, user_id: str, callback_fn):
        if not self.get_setting("show_nft_usernames", True):
            callback_fn([])
            return

        all_usernames = get_all_usernames_from_telegram(user_id)
        if not all_usernames:
            callback_fn([])
            return

        nft_usernames = [u for u in all_usernames if not u.get("editable", True) and u.get("active", False)]
        
        if not nft_usernames:
            _log(f"No NFT usernames found for user {user_id}")
            callback_fn([])
            return

        _log(f"Found {len(nft_usernames)} potential NFT usernames for user {user_id}: {nft_usernames}")

        nft_info_list = []
        pending_requests = [len(nft_usernames)]

        def on_collectible_info(username, info):
            if info:
                formatted = format_collectible_info(info, locali.language)
                if formatted:
                    nft_info_list.append({
                        "username": username,
                        "info": formatted
                    })
            else:
                nft_info_list.append({
                    "username": username,
                    "info": None
                })

            pending_requests[0] -= 1
            if pending_requests[0] <= 0:
                callback_fn(nft_info_list)

        for u in nft_usernames:
            username = u["username"]
            get_collectible_info_sync(username, lambda info, un=username: on_collectible_info(un, info))

    def _format_nft_usernames_section(self, nft_info_list: list) -> str:
        if not nft_info_list:
            return ""

        lines = ["\n" + locali.get_string("NFT_USERNAME_HEADER")]

        for item in nft_info_list:
            username = item["username"]
            info = item.get("info")

            if info and info.get("date"):
                price = info.get("price", "")
                crypto_price = info.get("crypto_price", "")
                url = info.get("url", "")

                if crypto_price and price:
                    line = locali.get_string("NFT_USERNAME_ITEM_CRYPTO").format(
                        username, info["date"], price, crypto_price
                    )
                elif price:
                    line = locali.get_string("NFT_USERNAME_ITEM").format(
                        username, info["date"], price
                    )
                else:
                    line = locali.get_string("NFT_NO_INFO").format(username)

                if url:
                    line += " " + locali.get_string("NFT_USERNAME_LINK").format(url)
            else:
                line = locali.get_string("NFT_NO_INFO").format(username)

            lines.append(line)

        return "\n".join(lines)

    def _process_age_request(self, params, initial_target, method):
        try:
            canonical_id = None
            if isinstance(initial_target, str) and not initial_target.isdigit():
                resolve_result = self.api_client.resolve_username(initial_target)
                if resolve_result["success"]:
                    canonical_id = str(resolve_result["data"]["id"])
                else:
                    error_msg = locali.get_string("API_ERROR").format(resolve_result["error"])
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_msg))
                    self.is_processing = False
                    self._dismiss_loading_dialog()
                    return
            else:
                canonical_id = str(initial_target)

            cached_data = self.cache_manager.get(canonical_id, method)
            is_cached = cached_data is not None

            if cached_data:
                base_message = self._format_response_data(cached_data, method)
                base_message = f"{locali.get_string('CACHED_RESULT_HINT')}\n{base_message}"
            else:
                result = self.api_client.get_info(canonical_id, method)
                if not result["success"]:
                    error_msg = locali.get_string("API_ERROR").format(result["error"])
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_msg))
                    self.is_processing = False
                    self._dismiss_loading_dialog()
                    return
                raw_data = result["data"]
                base_message = self._format_response_data(raw_data, method)
                self.cache_manager.set(canonical_id, method, raw_data)

            def on_nft_info(nft_info_list):
                try:
                    nft_section = self._format_nft_usernames_section(nft_info_list)
                    final_message = base_message + nft_section

                    use_premium_emoji = self.get_setting("use_premium_emoji", False)
                    if use_premium_emoji and nft_section:
                        final_message = base_message + replace_with_premium_emoji(nft_section)

                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, final_message))
                except Exception as e:
                    _log(f"Error adding NFT info: {e}")
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, base_message))
                finally:
                    self.is_processing = False
                    self._dismiss_loading_dialog()

            self._get_nft_usernames_info(canonical_id, on_nft_info)
            return

        except Exception as e:
            _log(f"Error in processing thread! {traceback.format_exc()}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_message))
            self.is_processing = False
            self._dismiss_loading_dialog()

    def _process_free_mode_request(self, params, initial_target):
        try:
            canonical_id = None

            if isinstance(initial_target, str) and not initial_target.isdigit():
                try:
                    from client_utils import get_messages_controller
                    user_or_chat = get_messages_controller().getUserOrChat(initial_target.lstrip('@'))
                    if user_or_chat and hasattr(user_or_chat, 'id') and not hasattr(user_or_chat, 'title'):
                        canonical_id = str(user_or_chat.id)
                    else:
                        error_msg = f"âš ï¸ Ğ’ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ @{initial_target.lstrip('@')}. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ»Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ [API Ñ€ĞµĞ¶Ğ¸Ğ¼](https://t.me/dateregbot?start=api)."
                        use_premium_emoji = self.get_setting("use_premium_emoji", False)
                        if use_premium_emoji:
                            error_msg = replace_with_premium_emoji(error_msg)
                        run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_msg))
                        return
                except Exception as e:
                    _log(f"Error finding user by username in free mode: {e}")
                    error_msg = f"âš ï¸ Ğ’ Ğ±ĞµÑĞ¿Ğ»Ğ°Ñ‚Ğ½Ğ¾Ğ¼ Ñ€ĞµĞ¶Ğ¸Ğ¼Ğµ Ğ½ĞµĞ²Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ @{initial_target.lstrip('@')}. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ID Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¸Ğ»Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚Ğµ [API Ñ€ĞµĞ¶Ğ¸Ğ¼](https://t.me/dateregbot?start=api)."
                    use_premium_emoji = self.get_setting("use_premium_emoji", False)
                    if use_premium_emoji:
                        error_msg = replace_with_premium_emoji(error_msg)
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_msg))
                    return
            else:
                canonical_id = str(initial_target)

            base_message = self._format_free_mode_response(canonical_id)

            def on_nft_info(nft_info_list):
                try:
                    nft_section = self._format_nft_usernames_section(nft_info_list)
                    final_message = base_message + nft_section

                    use_premium_emoji = self.get_setting("use_premium_emoji", False)
                    if use_premium_emoji and nft_section:
                        final_message = base_message + replace_with_premium_emoji(nft_section)

                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, final_message))
                except Exception as e:
                    _log(f"Error adding NFT info: {e}")
                    run_on_ui_thread(lambda: self._reply_with_formatted_text(params, base_message))
                finally:
                    self.is_processing = False
                    self._dismiss_loading_dialog()

            self._get_nft_usernames_info(canonical_id, on_nft_info)
            return

        except Exception as e:
            _log(f"Error in free mode processing thread! {traceback.format_exc()}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            run_on_ui_thread(lambda: self._reply_with_formatted_text(params, error_message))
            self.is_processing = False
            self._dismiss_loading_dialog()

    def on_send_message_hook(self, account, params) -> HookResult:
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message_text = params.message.strip()
        peer_id = getattr(params, "peer", None)
        if not peer_id: return HookResult()

        if message_text.startswith(".cache "):
            parts = message_text.split(" ", 1)
            if len(parts) < 2:
                message = locali.get_string("CACHE_DELETE_USAGE")
                BulletinHelper.show_error(get_regular_emoji_for_bulletin(message))
                return HookResult(strategy=HookStrategy.CANCEL)

            target_id = parts[1].strip()
            if self.cache_manager.delete(target_id):
                message = locali.get_string("CACHE_DELETE_SUCCESS").format(target_id)
                BulletinHelper.show_success(get_regular_emoji_for_bulletin(message))
            else:
                message = locali.get_string("CACHE_DELETE_NOT_FOUND").format(target_id)
                BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))

            return HookResult(strategy=HookStrategy.CANCEL)

        if not message_text.startswith(".age"):
            return HookResult()

        if self.is_processing:
            message = locali.get_string("PROCESSING")
            BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))
            return HookResult(strategy=HookStrategy.CANCEL)

        try:
            parts = message_text.split(" ", 2)
            if len(parts) > 1 and parts[1].strip().lower() == locali.get_string("FAQ_COMMAND"):
                self._show_info_alert(locali.get_string("FAQ_TITLE"), locali.get_string("FAQ_CONTENT"))
                return HookResult(strategy=HookStrategy.CANCEL)

            free_mode = self.get_setting("free_mode", False)

            if free_mode:
                use_smart = len(parts) > 1 and parts[1].lower() == "smart"
                target = parts[2].strip() if use_smart and len(parts) > 2 else (parts[1].strip() if len(parts) > 1 and not use_smart else None)

                if not target:
                    target = self._get_user_id_from_reply(params)

                if not target:
                    usage_msg = locali.get_string("USAGE_EXAMPLE")
                    use_premium_emoji = self.get_setting("use_premium_emoji", False)
                    if use_premium_emoji:
                        usage_msg = replace_with_premium_emoji(usage_msg)
                    self._reply_with_formatted_text(params, usage_msg)
                    return HookResult(strategy=HookStrategy.CANCEL)

                self.is_processing = True
                self._show_loading_dialog()
                run_on_queue(lambda: self._process_free_mode_request(params, target))
            else:
                if not self.api_client:
                    self._reply_with_formatted_text(params, locali.get_string("NO_API_KEY"))
                    return HookResult(strategy=HookStrategy.CANCEL)

                use_smart = len(parts) > 1 and parts[1].lower() == "smart"
                target = parts[2].strip() if use_smart and len(parts) > 2 else (parts[1].strip() if len(parts) > 1 and not use_smart else None)

                if not target:
                    target = self._get_user_id_from_reply(params)

                if not target:
                    usage_msg = locali.get_string("USAGE_EXAMPLE")
                    use_premium_emoji = self.get_setting("use_premium_emoji", False)
                    if use_premium_emoji:
                        usage_msg = replace_with_premium_emoji(usage_msg)
                    self._reply_with_formatted_text(params, usage_msg)
                    return HookResult(strategy=HookStrategy.CANCEL)

                method = "smart" if use_smart else "fast"

                self.is_processing = True
                self._show_loading_dialog()
                run_on_queue(lambda: self._process_age_request(params, target, method))

            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            self.is_processing = False
            self._dismiss_loading_dialog()
            _log(f"Error in hook! {traceback.format_exc()}")
            error_message = locali.get_string("CODE_ERROR").format(str(e))
            self._reply_with_formatted_text(params, error_message)
            return HookResult(strategy=HookStrategy.CANCEL)

    def _copy_to_clipboard(self, label, text):
        from org.telegram.messenger import AndroidUtilities
        if AndroidUtilities.addToClipboard(text):
            message = f"Copied {label} to clipboard"
            BulletinHelper.show_info(get_regular_emoji_for_bulletin(message))

    def _open_plugin_settings(self, java_plugin):
        try: get_last_fragment().presentFragment(PluginSettingsActivity(java_plugin))
        except Exception as e: _log(f"Error opening plugin settings: {e}")

    def _add_settings_menu_items(self):
        try:
            if not self._drawer_settings_item: self._drawer_settings_item = self.add_menu_item(MenuItemData(menu_type=MenuItemType.DRAWER_MENU, text=locali.get_string("SETTINGS_TITLE"), icon="msg_settings_14", priority=5, on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))))
            if not self._chat_settings_item: self._chat_settings_item = self.add_menu_item(MenuItemData(menu_type=MenuItemType.CHAT_ACTION_MENU, text=locali.get_string("SETTINGS_TITLE"), icon="msg_settings_14", priority=5, on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings(PluginsController.getInstance().plugins.get(self.id)))))
        except Exception as e: _log(f"Failed to add settings menu items: {e}")

    def _on_show_settings_buttons_change(self, enabled: bool):
        def _toggle():
            try:
                if enabled: self._add_settings_menu_items()
                else:
                    if self._drawer_settings_item: self.remove_menu_item(self._drawer_settings_item); self._drawer_settings_item = None
                    if self._chat_settings_item: self.remove_menu_item(self._chat_settings_item); self._chat_settings_item = None
            except Exception as e: _log(f"Failed toggling settings buttons: {e}")
        run_on_ui_thread(_toggle)

    def get_accuracy_emoji(self, accuracy_percent):
        if not isinstance(accuracy_percent, (int, float)): return "â“"
        if accuracy_percent >= 87: return "ğŸŸ¢"
        elif accuracy_percent >= 70: return "ğŸŸ¡"
        elif accuracy_percent >= 50: return "ğŸŸ "
        else: return "ğŸ”´"

    def _get_user_id_from_reply(self, params):
        if hasattr(params, "replyToMsg") and params.replyToMsg:
            msg_owner = params.replyToMsg.messageOwner
            if msg_owner and hasattr(msg_owner, "from_id") and msg_owner.from_id and hasattr(msg_owner.from_id, "user_id"):
                return str(msg_owner.from_id.user_id)
        return None

    def _reply_with_formatted_text(self, params, markdown_text):
        try:
            parsed = parse_markdown(markdown_text)
            entities = [e.to_tlrpc_object() for e in parsed.entities]
            
            use_collapsible_quote = self.get_setting("use_collapsible_quote", False)
            if use_collapsible_quote:
                blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                blockquote_entity.offset = 0
                blockquote_entity.length = len(parsed.text.encode('utf-16-le')) // 2
                blockquote_entity.collapsed = True
                entities.insert(0, blockquote_entity)
            
            message_payload = {
                "peer": params.peer,
                "message": parsed.text,
                "entities": entities,
                "searchLinks": False,
            }
            reply_to_msg = getattr(params, "replyToMsg", None)
            reply_to_top_msg = getattr(params, "replyToTopMsg", None)
            if reply_to_msg is not None:
                message_payload["replyToMsg"] = reply_to_msg
            if reply_to_top_msg is not None:
                message_payload["replyToTopMsg"] = reply_to_top_msg
            send_message(message_payload)
        except Exception as e:
            error_str = str(e)
            if "notify" not in error_str.lower():
                _log(f"Markdown parse/send error: {e}")
            plain_text = markdown_text.replace("*", "").replace("`", "").replace("_", "")
            
            entities = []
            use_collapsible_quote = self.get_setting("use_collapsible_quote", False)
            if use_collapsible_quote:
                blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                blockquote_entity.offset = 0
                blockquote_entity.length = len(plain_text.encode('utf-16-le')) // 2
                blockquote_entity.collapsed = True
                entities.append(blockquote_entity)
            
            message_payload = {
                "peer": params.peer,
                "message": plain_text,
                "entities": entities if entities else None,
                "searchLinks": False,
            }
            reply_to_msg = getattr(params, "replyToMsg", None)
            reply_to_top_msg = getattr(params, "replyToTopMsg", None)
            if reply_to_msg is not None:
                message_payload["replyToMsg"] = reply_to_msg
            if reply_to_top_msg is not None:
                message_payload["replyToTopMsg"] = reply_to_top_msg
            try:
                send_message(message_payload)
            except Exception as send_err:
                if "notify" not in str(send_err).lower():
                    _log(f"Send message error: {send_err}")

    def _show_info_alert(self, title, message):
        fragment = get_last_fragment()
        if not fragment: return
        builder = AlertDialogBuilder(fragment.getParentActivity())
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button("Close", None)
        run_on_ui_thread(builder.show)

    def _show_loading_dialog(self):
        fragment = get_last_fragment()
        if not fragment or self.alert_dialog: return
        run_on_ui_thread(lambda: self.__show_loading_dialog_on_ui(fragment.getParentActivity()))

    def __show_loading_dialog_on_ui(self, context):
        self.alert_dialog = AlertDialog(context, 3)
        self.alert_dialog.setCanCancel(False)
        self.alert_dialog.show()
        self.alert_dialog.setTitle(locali.get_string("LOADING_TITLE"))

    def _dismiss_loading_dialog(self):
        def dismiss_action():
            if self.alert_dialog:
                try:
                    self.alert_dialog.dismiss()
                except Exception as e:
                    _log(f"Error dismissing dialog: {e}")
                finally:
                    self.alert_dialog = None
        run_on_ui_thread(dismiss_action)

    def _handle_profile_info_click(self, context):
        try:
            user = context.get("user")
            if not user:
                _log("User not found in profile context")
                return

            user_id = str(user.id)
            _log(f"Profile info button clicked for user: {user.first_name} (ID: {user_id})")

            self._show_profile_info_dialog(user_id)

        except Exception as e:
            _log(f"Error in profile info click handler: {str(e)}")
            self._show_error_dialog(f"ĞÑˆĞ¸Ğ±ĞºĞ°: {str(e)}")

    def _show_profile_info_dialog(self, user_id: str):
        try:
            free_mode = self.get_setting("free_mode", True)

            if free_mode or not self.api_client:
                info_text = self._format_profile_info_for_dialog(user_id, None)
                title = "ğŸ“Š Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ)"
                self._show_info_alert(title, info_text)
            else:
                self._show_loading_dialog()
                run_on_queue(lambda: self._fetch_profile_info_with_api(user_id))

        except Exception as e:
            _log(f"Error showing profile info dialog: {str(e)}")
            self._show_error_dialog(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸: {str(e)}")

    def _fetch_profile_info_with_api(self, user_id: str):
        try:
            cached_data = self.cache_manager.get(user_id, "fast")

            if cached_data:
                _log(f"Using cached data for profile dialog: {user_id}")
                run_on_ui_thread(lambda: self._show_profile_info_with_api_data(user_id, cached_data, True))
                return

            _log(f"Making API request for profile dialog: {user_id}")
            api_result = self.api_client.get_info(user_id, "fast")

            if api_result["success"]:
                self.cache_manager.set(user_id, "fast", api_result["data"])
                run_on_ui_thread(lambda: self._show_profile_info_with_api_data(user_id, api_result["data"], False))
            else:
                _log(f"API error for profile dialog: {api_result['error']}")
                run_on_ui_thread(lambda: self._show_profile_info_api_error(user_id, api_result["error"]))

        except Exception as e:
            _log(f"Exception in _fetch_profile_info_with_api: {str(e)}")
            run_on_ui_thread(lambda: self._show_profile_info_api_error(user_id, str(e)))
        finally:
            run_on_ui_thread(lambda: self._dismiss_loading_dialog())

    def _show_profile_info_with_api_data(self, user_id: str, api_data: dict, from_cache: bool):
        try:
            info_text = self._format_profile_info_for_dialog(user_id, api_data)
            cache_hint = " (Ğ¸Ğ· ĞºÑÑˆĞ°)" if from_cache else ""
            title = f"ğŸ“Š Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ{cache_hint}"
            self._show_info_alert(title, info_text)
        except Exception as e:
            _log(f"Error showing profile info with API data: {str(e)}")
            self._show_error_dialog(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸: {str(e)}")

    def _show_profile_info_api_error(self, user_id: str, error_message: str):
        try:
            info_text = self._format_profile_info_for_dialog(user_id, None)
            title = "ğŸ“Š Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ± Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğµ (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ)"
            error_note = f"\n\nâš ï¸ ĞÑˆĞ¸Ğ±ĞºĞ° API: {error_message}"
            self._show_info_alert(title, info_text + error_note)
        except Exception as e:
            _log(f"Error showing profile info with API error: {str(e)}")
            self._show_error_dialog(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸: {str(e)}")

    def _format_profile_info_for_dialog(self, user_id: str, api_data: dict = None) -> str:
        try:
            account_name = get_account_name_from_telegram(user_id)
            all_usernames_display = get_all_usernames_display(user_id)
            telegram_username = all_usernames_display if all_usernames_display else get_username_from_telegram(user_id)

            dc_id = get_user_datacenter_id(user_id)
            region = get_region_from_datacenter(dc_id)

            birthday = get_user_birthday_from_telegram(user_id)
            has_birthday = bool(birthday)

            phone_number = ""
            has_phone = False

            try:
                from client_utils import get_user_config
                current_user_id = get_user_config().getClientUserId()
                if int(user_id) != current_user_id:
                    phone_number = get_user_phone_from_telegram(user_id)
                    has_phone = bool(phone_number)
            except Exception as e:
                _log(f"Error checking current user: {e}")

            dc_display = str(dc_id) if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")
            region_display = region if dc_id > 0 else ("ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ğ¾" if locali.language == "ru" else "Unknown")

            if telegram_username:
                username_display = telegram_username
            else:
                username_display = "Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚" if locali.language == "ru" else "not available"

            info_lines = []
            info_lines.append(f"ğŸ‘¤ Ğ˜Ğ¼Ñ: {account_name}")
            info_lines.append(f"ğŸ†” ID: {user_id}")
            info_lines.append(f"ğŸ”— Ğ®Ğ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼: {username_display}")

            if has_phone:
                info_lines.append(f"ğŸ“± Ğ¢ĞµĞ»ĞµÑ„Ğ¾Ğ½: {phone_number}")

            if has_birthday:
                info_lines.append(f"ğŸ‚ Ğ”ĞµĞ½ÑŒ Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ: {birthday}")

            if api_data and api_data.get('creation_date'):
                creation_date = api_data.get('creation_date')
                age_str = self._format_age(creation_date)
                accuracy_percent = api_data.get('accuracy_percent', 0)
                accuracy_emoji = self.get_accuracy_emoji(accuracy_percent)
                accuracy_text = api_data.get('accuracy_text', 'Unknown')

                info_lines.append(f"ğŸ“… Ğ”Ğ°Ñ‚Ğ° ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ: {creation_date}")
                info_lines.append(f"â³ Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ°: {age_str}")
                info_lines.append(f"ğŸ¯ Ğ¢Ğ¾Ñ‡Ğ½Ğ¾ÑÑ‚ÑŒ: {accuracy_emoji} {accuracy_text}")

            info_lines.append(f"ğŸ–¥ Ğ”Ğ°Ñ‚Ğ°Ñ†ĞµĞ½Ñ‚Ñ€: {dc_display}")
            info_lines.append(f"ğŸŒ Ğ ĞµĞ³Ğ¸Ğ¾Ğ½: {region_display}")

            if self.get_setting("show_nft_usernames", True):
                all_usernames = get_all_usernames_from_telegram(user_id)
                nft_usernames = [u for u in all_usernames if not u.get("editable", True) and u.get("active", False)]
                if nft_usernames:
                    nft_header = "ğŸ’ NFT ÑĞ·ĞµÑ€Ğ½ĞµĞ¹Ğ¼Ñ‹:" if locali.language == "ru" else "ğŸ’ NFT usernames:"
                    info_lines.append("")
                    info_lines.append(nft_header)
                    for u in nft_usernames:
                        info_lines.append(f"  â€¢ @{u['username']}")

            result = "\n".join(info_lines)

            return result

        except Exception as e:
            _log(f"Error formatting profile info for dialog: {e}")
            return f"ĞÑˆĞ¸Ğ±ĞºĞ° Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸: {str(e)}"

    def _show_error_dialog(self, message: str):
        title = "âŒ ĞÑˆĞ¸Ğ±ĞºĞ°"
        self._show_info_alert(title, message)