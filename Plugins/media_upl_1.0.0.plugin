__id__ = "mediaupl"
__name__ = "MediaUPL"
__description__ = "Добавляет кнопку 'Получить ссылку' в меню сообщения для загрузки медиа на хостинг upl.yufic.ru.\n\nAdds a 'Get link' button to the message menu to upload media to upl.yufic.ru."
__version__ = "1.0.0"
__author__ = "@RnPlugins & @YouRooni"
__icon__ = "sPluginIDE/20"
__min_version__ = "11.12.0"

import os
import json
import time
import requests
import traceback
import threading
from typing import Any, Dict, Optional

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Divider, Switch

from org.telegram.messenger import FileLoader, LocaleController, UserConfig, AndroidUtilities, ApplicationLoader
from android.content import Context, ClipData, ClipboardManager
from android.widget import EditText, LinearLayout
from android.graphics import Color

class MediaUplPlugin(BasePlugin):
    def on_plugin_load(self):
        s = self._get_strings()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text=s["menu_item_text"],
            on_click=self._handle_menu_click,
            icon="msg_link",
            condition='message.isDocument() || message.isPhoto() || message.isVideo() || message.isSticker()'
        ))

    def _get_strings(self) -> dict:
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        is_ru = lang.startswith('ru')

        return {
            "menu_item_text": "Получить ссылку" if is_ru else "Get link",
            "no_api_key": "💼 **API ключ не настроен.**\nНастройте его в плагине." if is_ru else "💼 **API key not configured.**\nSet it up in the plugin settings.",
            "loading_dialog_title": "Загрузка..." if is_ru else "Uploading...",
            "success_dialog_title": "✅ Успешно" if is_ru else "✅ Success",
            "error_dialog_title": "❌ Ошибка" if is_ru else "❌ Error",
            "copy_button": "Копировать" if is_ru else "Copy",
            "ok_button": "OK",
            "continue_button": "Продолжить" if is_ru else "Continue",
            "cancel_button": "Отмена" if is_ru else "Cancel",
            "filename_dialog_title": "Имя файла (без расширения)" if is_ru else "Filename (no extension)",
            "filename_dialog_hint": "Введите имя файла (необязательно)" if is_ru else "Enter filename (optional)",
            "link_copied": "Ссылка скопирована" if is_ru else "Link copied",
            "error_copied": "Ошибка скопирована" if is_ru else "Error copied",
            "error_401": "🔑 Ошибка авторизации (401).\nПроверьте правильность API ключа." if is_ru else "🔑 Authorization Error (401).\nPlease check your API key.",
            "config_api_key_title": "API ключ" if is_ru else "API Key",
            "config_api_key_subtext": "Ваш API ключ от хостинга upl.yufic.ru" if is_ru else "Your API key from upl.yufic.ru hosting",
            "settings_header": "Настройки MediaUPL" if is_ru else "MediaUPL Settings",
            "ask_filename_title": "Запрашивать имя файла" if is_ru else "Ask for filename",
            "ask_filename_subtext": "Показывать диалог для ввода имени файла перед загрузкой" if is_ru else "Show a dialog to enter a filename before uploading",
            "error_file_not_found": "Файл не найден на устройстве. Сначала загрузите его." if is_ru else "File not found on device. Download it first."
        }

    def create_settings(self):
        s = self._get_strings()
        return [
            Header(s["settings_header"]),
            Input(
                key="api_key",
                text=s["config_api_key_title"],
                subtext=s["config_api_key_subtext"],
                icon="msg_secret"
            ),
            Switch(
                key="ask_for_filename",
                text=s["ask_filename_title"],
                subtext=s["ask_filename_subtext"],
                default=True,
                icon="msg_edit"
            ),
            Divider("Адаптация плагина @RnPlugins")
        ]

    def _handle_menu_click(self, context: Dict[str, Any]):
        s = self._get_strings()
        api_key = self.get_setting("api_key")

        if not api_key:
            run_on_ui_thread(lambda: BulletinHelper.show_error(s["no_api_key"]))
            return
        
        message = context.get("message")
        if not message: return

        if self.get_setting("ask_for_filename", True):
            self._show_filename_input_dialog(message)
        else:
            self._start_upload(message)

    def _get_original_filename(self, message: Any) -> str:
        doc = message.getDocument()
        
        if message.isRoundVideo():
            return f"round_video_{message.getId()}.mp4"
        
        if message.isSticker() and doc:
            mime = getattr(doc, 'mime_type', '')
            ext = '.webp'
            if 'tgsticker' in mime: ext = '.tgs'
            elif 'webm' in mime: ext = '.webm'
            return f"sticker_{doc.id}{ext}"
        
        if (message.isVideo() or message.isDocument()) and doc:
            if hasattr(doc, 'file_name_fixed') and doc.file_name_fixed:
                return doc.file_name_fixed
            if message.isVideo():
                return f"video_{message.getId()}.mp4"

        if message.isPhoto():
            return f"photo_{message.getId()}.jpg"
            
        return f"upload_{message.getId()}.bin"
    
    def _show_filename_input_dialog(self, message: Any):
        s = self._get_strings()
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        filename_input = EditText(activity)
        original_full_filename = self._get_original_filename(message)
        original_name_no_ext, _ = os.path.splitext(original_full_filename)
        filename_input.setText(original_name_no_ext)
        filename_input.setHint(s["filename_dialog_hint"])
        filename_input.setTextColor(Color.WHITE)
        filename_input.setHintTextColor(Color.GRAY)

        def on_continue(builder, which):
            custom_filename_base = filename_input.getText().toString().strip()
            self._start_upload(message, custom_filename_base)
            builder.dismiss()

        def build_dialog():
            layout = LinearLayout(activity)
            layout.setOrientation(LinearLayout.VERTICAL)
            padding = AndroidUtilities.dp(24)
            layout.setPadding(padding, AndroidUtilities.dp(16), padding, AndroidUtilities.dp(8))
            layout.addView(filename_input)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(s["filename_dialog_title"])
            builder.set_view(layout)
            builder.set_positive_button(s["continue_button"], on_continue)
            builder.set_negative_button(s["cancel_button"], lambda b, w: b.dismiss())
            builder.show()

        run_on_ui_thread(build_dialog)

    def _start_upload(self, message: Any, custom_filename_base: Optional[str] = None):
        s = self._get_strings()
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        loading_dialog = AlertDialogBuilder(activity, AlertDialogBuilder.ALERT_TYPE_LOADING)
        loading_dialog.set_title(s["loading_dialog_title"])
        loading_dialog.set_cancelable(False)
        loading_dialog.show()
        
        api_key = self.get_setting("api_key")

        upload_thread = threading.Thread(
            target=self._upload_task,
            args=(message, api_key, activity, loading_dialog, custom_filename_base),
            daemon=True
        )
        upload_thread.start()

    def _get_file_path(self, account: int, message: Any) -> Optional[str]:
        file_loader = FileLoader.getInstance(account)
        file_path_obj = file_loader.getPathToMessage(message.messageOwner)

        if not file_path_obj or not os.path.exists(file_path_obj.toString()):
            attach = None
            if message.isPhoto():
                photo = message.getPhoto()
                if photo and photo.sizes:
                    biggest_size = max(photo.sizes, key=lambda s: getattr(s, 'w', 0) * getattr(s, 'h', 0))
                    attach = biggest_size.location
            else:
                attach = message.getDocument()

            if attach:
                file_loader.loadFile(attach, message, None, FileLoader.PRIORITY_HIGH, 1)

        for _ in range(300):
            current_path_obj = file_loader.getPathToMessage(message.messageOwner)
            if current_path_obj and os.path.exists(current_path_obj.toString()):
                return current_path_obj.toString()
            time.sleep(0.1)
        return None

    def _upload_task(self, message: Any, api_key: str, activity: Any, loading_dialog: AlertDialogBuilder, custom_filename_base: Optional[str]):
        s = self._get_strings()
        account = UserConfig.selectedAccount
        try:
            file_path = self._get_file_path(account, message)
            if not file_path:
                run_on_ui_thread(loading_dialog.dismiss)
                self._show_result_dialog(activity, s["error_dialog_title"], s["error_file_not_found"])
                return

            original_full_filename = self._get_original_filename(message)
            _, original_ext = os.path.splitext(original_full_filename)
            
            final_name_base = custom_filename_base or os.path.splitext(original_full_filename)[0]
            final_full_filename = final_name_base + original_ext

            mime_type = "application/octet-stream"
            doc = message.getDocument()
            if doc and hasattr(doc, 'mime_type'):
                mime_type = doc.mime_type
            elif message.isPhoto():
                mime_type = "image/jpeg"
            
            with open(file_path, "rb") as f: media_bytes = f.read()

            files = {'image': (final_full_filename, media_bytes, mime_type)}
            data = {'filename': final_name_base}
            url, headers = "https://upl.yufic.ru/api/upload.php", {"Authorization": f"Bearer {api_key}"}

            response = requests.post(url, headers=headers, data=data, files=files, timeout=60)
            
            run_on_ui_thread(loading_dialog.dismiss)

            if response.status_code == 401:
                self._show_result_dialog(activity, s["error_dialog_title"], s["error_401"])
                return
            
            response.raise_for_status()
            
            result_json = response.json()
            link = result_json.get("url")

            if link:
                self._show_result_dialog(activity, s["success_dialog_title"], link)
            else:
                self._show_result_dialog(activity, s["error_dialog_title"], result_json.get("error", str(result_json)))

        except requests.exceptions.HTTPError as e:
            error_details = f"Код: {e.response.status_code}\nОтвет: {e.response.text}"
            log(f"HTTP Error: {error_details}")
            run_on_ui_thread(loading_dialog.dismiss)
            self._show_result_dialog(activity, s["error_dialog_title"], error_details)
        except Exception as e:
            log(f"Upload task failed: {traceback.format_exc()}")
            run_on_ui_thread(loading_dialog.dismiss)
            self._show_result_dialog(activity, s["error_dialog_title"], f"{type(e).__name__}")
    
    def _show_result_dialog(self, activity: Any, title: str, text: str):
        s = self._get_strings()
        
        def copy_action(builder, which):
            try:
                context = ApplicationLoader.applicationContext
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("MediaUPL", text)
                clipboard.setPrimaryClip(clip)
                is_error = title == s["error_dialog_title"]
                BulletinHelper.show_info(s["error_copied"] if is_error else s["link_copied"])
            except Exception as e: log(f"Copy failed: {e}")

        def show_dialog():
            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_message(text)
            builder.set_positive_button(s["ok_button"], lambda b, w: b.dismiss())
            builder.set_negative_button(s["copy_button"], copy_action)
            builder.set_cancelable(False)
            builder.set_canceled_on_touch_outside(False)
            builder.show()

        run_on_ui_thread(show_dialog)