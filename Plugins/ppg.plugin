import requests, threading, re, os, uuid, time, math, traceback, colorsys, random

from typing import Any, Optional

try: from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance, ImageOps
except ImportError: raise ImportError("Для работы этого плагина необходима библиотека Pillow (PIL).")

from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from client_utils import send_message, get_send_messages_helper, get_last_fragment
from android_utils import run_on_ui_thread, log
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Selector, Switch, Divider, Text
from markdown_utils import parse_markdown
from java.io import File
from java.util import Locale
from org.telegram.messenger import ApplicationLoader, MessageObject, FileLoader, UserConfig, ImageLocation, SendMessagesHelper, R, AndroidUtilities
from org.telegram.tgnet import TLRPC
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from org.telegram.ui.ActionBar import Theme
from android.widget import LinearLayout, TextView

__id__ = "ppg"
__name__ = "Palette Generator"
__author__ = "@lisurgut"
__version__ = "7.0"
__description__ = "Генерирует цветовые палитры по текстовому запросу с помощью AI, извлекает из изображения или создаёт случайный градиент."
__min_version__ = "11.12.1"
__icon__ = "HDkolobok/14"

TEMP_DIR_NAME = "ai_color_palettes"
FONT_URL = "https://github.com/Igroshka/-/raw/refs/heads/main/font/couriercyrps.ttf"
FONT_NAME = "CourierNew.ttf"

API_PROVIDERS = {
    "openrouter": {
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "models": [
            "mistralai/mistral-small-3.2-24b-instruct:free",
            "google/gemini-2.0-flash-exp:free",
            "qwen/qwen3-coder:free",
            "meta-llama/llama-3.2-3b-instruct:free",
            "anthropic/claude-3.5-haiku:free"
        ],
        "display_names": [
            "Mistral Small 3.2",
            "Gemini 2.0 Flash",
            "Qwen3 Coder",
            "Llama 3.2 3B",
            "Claude 3.5 Haiku"
        ]
    },
    "groq": {
        "url": "https://api.groq.com/openai/v1/chat/completions",
        "models": [
            "llama-3.3-70b-versatile",
            "llama-3.1-70b-versatile",
            "mixtral-8x7b-32768",
            "gemma2-9b-it"
        ],
        "display_names": [
            "Llama 3.3 70B",
            "Llama 3.1 70B",
            "Mixtral 8x7B",
            "Gemma 2 9B"
        ]
    },
    "gemini": {
        "url": "https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent?key={api_key}",
        "models": [
            "gemini-2.0-flash-exp",
            "gemini-1.5-flash",
            "gemini-1.5-pro"
        ],
        "display_names": [
            "Gemini 2.0 Flash",
            "Gemini 1.5 Flash",
            "Gemini 1.5 Pro"
        ]
    },
    "huggingface": {
        "url": "https://api-inference.huggingface.co/models/{model}",
        "models": [
            "meta-llama/Llama-3.2-3B-Instruct",
            "mistralai/Mistral-7B-Instruct-v0.3",
            "google/gemma-2-2b-it"
        ],
        "display_names": [
            "Llama 3.2 3B (HF)",
            "Mistral 7B (HF)",
            "Gemma 2 2B (HF)"
        ]
    }
}

COLOR_FORMATS_DISPLAY_PB = [
    "HEX (#RRGGBB)", "RGB (r,g,b)", "HSL (h,s,l)", "HSV (h,s,v)", "CMYK (c,m,y,k)", "CSS (rgb(r,g,b))"
]

class LocalizationManager:
    strings = {
        "ru": {
            "SETTINGS_HEADER": "Настройки генератора палитр",
            "ENABLE_PLUGIN": "Включить плагин",
            "SHOW_SETTINGS_IN_MENU": "Кнопка настроек в меню чата",
            "AI_HEADER": "Генерация по тексту (AI)",
            "CMD_PREFIX": "Команда для генерации по тексту",
            "TITLE_TEMPLATE": "Шаблон заголовка",
            "TITLE_TEMPLATE_SUB": "Используйте {prompt} для запроса.",
            "AI_MODEL": "Модель нейросети",
            "COLOR_COUNT": "Количество цветов в палитре (AI)",
            "IMAGE_HEADER": "Генерация из фото",
            "CMD_FROM_IMAGE": "Команда для генерации из фото",
            "TITLE_FROM_IMAGE_TEMPLATE": "Шаблон заголовка (из фото)",
            "EXTRACT_COLOR_COUNT": "Количество цветов для извлечения",
            "QUANTIZE_METHOD": "Метод извлечения цветов",
            "QUANTIZE_ITEMS": ["Макс. покрытие", "Срез по медиане", "Быстрое дерево (рекомендуется)"],
            "COLOR_SORT": "Сортировка цветов из фото",
            "COLOR_SORT_ITEMS": ["Нет", "По оттенку", "По яркости", "По насыщенности"],
            "BLUR_RADIUS": "Радиус размытия фона",
            "BG_DARKNESS": "Затемнение фона (в %)",
            "IMAGE_STYLE_HEADER": "Настройки вида изображения",
            "PALETTE_LAYOUT": "Расположение палитры",
            "LAYOUT_ITEMS": ["Сетка", "Горизонтально", "Вертикально"],
            "SWATCH_SHAPE": "Форма плашек с цветом",
            "SHAPE_ITEMS": ["Закругленный квадрат", "Квадрат", "Круг"],
            "SQUARE_SIZE": "Размер плашки (px)",
            "PADDING": "Отступ между плашками (px)",
            "OUTER_PADDING": "Внешний отступ от края (px)",
            "SOLID_BG_COLOR": "Цвет фона (для AI, HEX)",
            "SOLID_BG_COLOR_SUB": "Напр. #121212. Оставьте пустым для черного.",
            "BORDER_ENABLE": "Включить обводку плашек",
            "BORDER_WIDTH": "Толщина обводки (px)",
            "BORDER_COLOR": "Цвет обводки (HEX)",
            "CODES_ON_IMAGE": "Показывать коды на изображении",
            "FONT_SIZE": "Размер шрифта на изображении",
            "FONT_COLOR": "Цвет шрифта на изображении (HEX)",
            "IMAGE_FORMAT": "Формат итогового изображения",
            "FORMAT_ITEMS": ["PNG (качество)", "JPG (сжатие)"],
            "SENDING_HEADER": "Настройки отправки сообщения",
            "CAPTION_HEADER": "Настройки подписи",
            "SEND_MODE": "Режим отправки",
            "SEND_MODE_ITEMS": ["Фото + Текст", "Фото с подписью", "Файл + Текст"],
            "CODE_FORMAT": "Формат кодов цветов в тексте",
            "CODE_SEPARATOR": "Разделитель кодов",
            "SEPARATOR_ITEMS": ["Новая строка", "Запятая и пробел", "Тире", "Вертикальная черта", "Точка-маркер", "Двойной перенос", "Пробел"],
            "CODE_LINE_TEMPLATE": "Шаблон строки с кодом",
            "CODE_LINE_TEMPLATE_SUB": "Используйте {code} и {name}.",
            "FOOTER_TEXT": "Дополнительный текст в конце",
            "AUTO_GRID_ENABLE": "Авто-сетка",
            "AUTO_GRID_ENABLE_SUB": "Автоматически подбирает размер плашек под разрешение.",
            "TARGET_RESOLUTION": "Разрешение изображения",
            "TARGET_RESOLUTION_SUB": "Формат: ШиринаxВысота, напр. 1920x1080",
            "AI_TEMPERATURE": "Температура AI (креативность)",
            "AI_TEMPERATURE_SUB": "От 0.0 (точно) до 2.0 (очень креативно)",
            "AUTO_FONT_COLOR": "Авто-цвет шрифта на плашке",
            "AUTO_FONT_COLOR_SUB": "Автоматически выбирает черный/белый цвет.",
            "SWATCH_SHADOW": "Тень у плашек",
            "SWATCH_SHADOW_SUB": "Добавляет тень для объема.",
            "SWATCH_RADIUS": "Радиус скругления (px)",
            "SWATCH_RADIUS_SUB": "Для 'Закругленного квадрата'.",
            "ADVANCED_HEADER": "Дополнительные настройки",
            "SHOW_PROCESSING_TIME": "Показывать время генерации",
            "SHOW_PROCESSING_TIME_SUB": "Добавляет время в конец сообщения.",
            "ADD_COLOR_NAMES": "Добавлять названия цветов",
            "ADD_COLOR_NAMES_SUB": "Делает запрос к TheColorAPI для каждого цвета.",
            "OPENROUTER_API_KEY": "OpenRouter API Key",
            "OPENROUTER_API_KEY_SUB": "Получите ключ на openrouter.ai (Settings -> Keys). Обязательно для работы AI-генерации.",
            "OPENROUTER_KEY_REQUIRED": "API Key OpenRouter не введен. Введите ключ, чтобы разблокировать настройки AI.",
            "AI_GEN_FAILED_GENERAL": "AI генерация не удалась.",
            "AI_GEN_FAILED_API_KEY": "AI генерация не удалась: API Key OpenRouter не установлен или недействителен.",
            "IMAGE_DOWNLOAD_FAILED": "Загрузка изображения не удалась.",
            "COLOR_EXTRACTION_FAILED": "Извлечение цветов не удалось.",
            "IMAGE_CREATION_FAILED": "Создание изображения палитры не удалось.",
            "RESULT_SEND_FAILED": "Отправка результатов не удалась.",
            "ERROR_IN_CHAT": "Ошибка в чате",
            "CHECK_LOGS_FOR_DETAILS": "_Подробнее в логах плагина._",
            "NO_PROMPT_PROVIDED": "Укажите запрос.",
            "REPLY_TO_PHOTO_REQUIRED": "Ответьте на сообщение с фото этой командой.",
            "PALETTE_IMAGE_CREATION_FAILED": "Создание изображения палитры не удалось.",
            "RANDOM_GEN_FAILED": "Генерация случайного градиента не удалась.",
            "BUSY_PROCESSING": "Подождите, предыдущий запрос еще выполняется.",
            "RANDOM_HEADER": "Случайная генерация",
            "CMD_RANDOM_GRADIENT": "Команда для случайного градиента",
            "TITLE_RANDOM_TEMPLATE": "Шаблон заголовка (случайный)",
            "RANDOM_COLOR_COUNT": "Количество цветов (случайный)"
        },
        "en": {
            "SETTINGS_HEADER": "Palette Generator Settings",
            "ENABLE_PLUGIN": "Enable Plugin",
            "SHOW_SETTINGS_IN_MENU": "Settings button in chat menu",
            "AI_HEADER": "Text Generation (AI)",
            "CMD_PREFIX": "Command for text generation",
            "TITLE_TEMPLATE": "Title template",
            "TITLE_TEMPLATE_SUB": "Use {prompt} for the prompt.",
            "AI_MODEL": "AI Model",
            "COLOR_COUNT": "Number of colors in palette (AI)",
            "IMAGE_HEADER": "Image Generation",
            "CMD_FROM_IMAGE": "Command for image generation",
            "TITLE_FROM_IMAGE_TEMPLATE": "Title template (from image)",
            "EXTRACT_COLOR_COUNT": "Number of colors to extract",
            "QUANTIZE_METHOD": "Color extraction method",
            "QUANTIZE_ITEMS": ["Max Coverage", "Median Cut", "Fast Octree (recommended)"],
            "COLOR_SORT": "Sort colors from photo",
            "COLOR_SORT_ITEMS": ["None", "By Hue", "By Brightness", "By Saturation"],
            "BLUR_RADIUS": "Background blur radius",
            "BG_DARKNESS": "Background darkness (%)",
            "IMAGE_STYLE_HEADER": "Image Style Settings",
            "PALETTE_LAYOUT": "Palette Layout",
            "LAYOUT_ITEMS": ["Grid", "Horizontal", "Vertical"],
            "SWATCH_SHAPE": "Color swatch shape",
            "SHAPE_ITEMS": ["Rounded Square", "Square", "Circle"],
            "SQUARE_SIZE": "Swatch size (px)",
            "PADDING": "Padding between swatches (px)",
            "OUTER_PADDING": "Outer padding (px)",
            "SOLID_BG_COLOR": "Background color (for AI, HEX)",
            "SOLID_BG_COLOR_SUB": "E.g. #121212. Leave empty for black.",
            "BORDER_ENABLE": "Enable swatch border",
            "BORDER_WIDTH": "Border width (px)",
            "BORDER_COLOR": "Border color (HEX)",
            "CODES_ON_IMAGE": "Show codes on image",
            "FONT_SIZE": "Font size on image",
            "FONT_COLOR": "Font color on image (HEX)",
            "IMAGE_FORMAT": "Output image format",
            "FORMAT_ITEMS": ["PNG (quality)", "JPG (compression)"],
            "SENDING_HEADER": "Message Sending Settings",
            "CAPTION_HEADER": "Caption Settings",
            "SEND_MODE": "Sending mode",
            "SEND_MODE_ITEMS": ["Photo + Text", "Photo with Caption", "File + Text"],
            "CODE_FORMAT": "Color code format in text",
            "CODE_SEPARATOR": "Code Separator",
            "SEPARATOR_ITEMS": ["New Line", "Comma and Space", "Dash", "Pipe", "Bullet Point", "Double New Line", "Space"],
            "CODE_LINE_TEMPLATE": "Code line template",
            "CODE_LINE_TEMPLATE_SUB": "Use {code} and {name}.",
            "FOOTER_TEXT": "Additional text at the end",
            "AUTO_GRID_ENABLE": "Auto-Grid",
            "AUTO_GRID_ENABLE_SUB": "Automatically adjusts swatch size to fit resolution.",
            "TARGET_RESOLUTION": "Image Resolution",
            "TARGET_RESOLUTION_SUB": "Format: WidthxHeight, e.g. 1920x1080",
            "AI_TEMPERATURE": "AI Temperature (creativity)",
            "AI_TEMPERATURE_SUB": "From 0.0 (precise) to 2.0 (very creative).",
            "AUTO_FONT_COLOR": "Auto font color on swatch",
            "AUTO_FONT_COLOR_SUB": "Automatically chooses black/white color.",
            "SWATCH_SHADOW": "Swatch shadow",
            "SWATCH_SHADOW_SUB": "Adds a shadow for volume.",
            "SWATCH_RADIUS": "Corner radius (px)",
            "SWATCH_RADIUS_SUB": "For 'Rounded Square'.",
            "ADVANCED_HEADER": "Advanced Settings",
            "SHOW_PROCESSING_TIME": "Show generation time",
            "SHOW_PROCESSING_TIME_SUB": "Adds time to the end of the message.",
            "ADD_COLOR_NAMES": "Add color names",
            "ADD_COLOR_NAMES_SUB": "Makes a request to TheColorAPI for each color.",
            "OPENROUTER_API_KEY": "OpenRouter API Key",
            "OPENROUTER_API_KEY_SUB": "Get your key from openrouter.ai (Settings -> Keys). Required for AI generation.",
            "OPENROUTER_KEY_REQUIRED": "OpenRouter API Key not entered. Enter the key to unlock AI settings.",
            "AI_GEN_FAILED_GENERAL": "AI generation failed.",
            "AI_GEN_FAILED_API_KEY": "AI generation failed: OpenRouter API Key not set or invalid.",
            "IMAGE_DOWNLOAD_FAILED": "Image download failed.",
            "COLOR_EXTRACTION_FAILED": "Color extraction failed.",
            "IMAGE_CREATION_FAILED": "Palette image creation failed.",
            "RESULT_SEND_FAILED": "Sending results failed.",
            "ERROR_IN_CHAT": "Error in chat",
            "CHECK_LOGS_FOR_DETAILS": "_Check plugin logs for details._",
            "NO_PROMPT_PROVIDED": "Please provide a prompt.",
            "REPLY_TO_PHOTO_REQUIRED": "Reply to a message with a photo using this command.",
            "PALETTE_IMAGE_CREATION_FAILED": "Palette image creation failed.",
            "RANDOM_GEN_FAILED": "Random gradient generation failed.",
            "BUSY_PROCESSING": "Please wait, the previous request is still being processed.",
            "RANDOM_HEADER": "Random Generation",
            "CMD_RANDOM_GRADIENT": "Command for random gradient",
            "TITLE_RANDOM_TEMPLATE": "Title template (random)",
            "RANDOM_COLOR_COUNT": "Number of colors (random)"
        }
    }
    
    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = "ru" if self.language.startswith("ru") else "en"
    
    def get_string(self, key):
        return self.strings[self.language].get(key, self.strings["en"].get(key, key))

Z = LocalizationManager()

def _hex_to_rgb_pb(hex_code: str) -> tuple:
    hex_code = hex_code.lstrip('#')
    return tuple(int(hex_code[i:i+2], 16) for i in (0, 2, 4))

def _rgb_to_hsl_pb(r, g, b) -> tuple:
    r /= 255.0; g /= 255.0; b /= 255.0
    cmax, cmin = max(r, g, b), min(r, g, b)
    diff = cmax - cmin
    h, s, l = 0.0, 0.0, (cmax + cmin) / 2.0
    if diff != 0:
        s = diff / (2.0 - cmax - cmin) if l > 0.5 else diff / (cmax + cmin)
        if cmax == r: h = (g - b) / diff + (6.0 if g < b else 0.0)
        elif cmax == g: h = (b - r) / diff + 2.0
        else: h = (r - g) / diff + 4.0
        h /= 6.0
    return int(h * 360), int(s * 100), int(l * 100)

def _rgb_to_hsv_pb(r, g, b) -> tuple:
    r /= 255.0; g /= 255.0; b /= 255.0
    cmax, cmin = max(r, g, b), min(r, g, b)
    diff = cmax - cmin
    h, s, v = 0.0, 0.0, cmax
    if cmax != 0: s = diff / cmax
    if diff != 0:
        if cmax == r: h = (g - b) / diff + (6.0 if g < b else 0.0)
        elif cmax == g: h = (b - r) / diff + 2.0
        else: h = (r - g) / diff + 4.0
        h /= 6.0
    return int(h * 360), int(s * 100), int(v * 100)

def _rgb_to_cmyk_pb(r, g, b) -> tuple:
    if r == g == b == 0: return 0, 0, 0, 100
    c, m, y = 1.0 - r / 255.0, 1.0 - g / 255.0, 1.0 - b / 255.0
    min_cmy = min(c, m, y)
    k_div = (1.0 - min_cmy)
    c = int(((c - min_cmy) / k_div) * 100) if k_div != 0 else 0
    m = int(((m - min_cmy) / k_div) * 100) if k_div != 0 else 0
    y = int(((y - min_cmy) / k_div) * 100) if k_div != 0 else 0
    k = int(min_cmy * 100)
    return c, m, y, k

def _get_hsv(rgb): return colorsys.rgb_to_hsv(rgb[0]/255, rgb[1]/255, rgb[2]/255)

def _get_hue(hex_code): return _get_hsv(_hex_to_rgb_pb(hex_code))[0]

def _get_saturation(hex_code): return _get_hsv(_hex_to_rgb_pb(hex_code))[1]

def _get_brightness(hex_code): return _get_hsv(_hex_to_rgb_pb(hex_code))[2]

def _get_luminance(rgb_tuple): return (0.299 * rgb_tuple[0] + 0.587 * rgb_tuple[1] + 0.114 * rgb_tuple[2]) / 255

class ColorPalettePlugin(BasePlugin):
    separators = ["\n", ", ", " - ", " | ", " • ", "\n\n", " "]
    
    def __init__(self):
        super().__init__()
        self.pg_temp_dir = None
        self.pg_is_processing = False
        self.pg_font_path = None
        self._menu_item = None
    
    def on_plugin_load(self):
        self._setup_temp_dir()
        if self.pg_temp_dir:
            self.add_on_send_message_hook()
            threading.Thread(target=self._fetch_font, daemon=True).start()
            self._update_settings_menu_item_visibility(self.get_setting("show_settings_in_menu", True))
            log(f"[{__id__}] плагин загружен.")
        else:
            log(f"[{__id__}] ОШИБКА: Не удалось создать временную папку.")
    
    def on_plugin_unload(self):
        self._remove_menu_item()
    
    def _update_settings_menu_item_visibility(self, show: bool):
        if show:
            self._add_menu_item()
        else:
            self._remove_menu_item()
    
    def _add_menu_item(self):
        if self._menu_item: return
        self._menu_item = self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text=Z.get_string("SETTINGS_HEADER"),
            icon="menu_edit_appearance_solar",
            on_click=self._open_settings
        ))
    
    def _remove_menu_item(self):
        if self._menu_item:
            self.remove_menu_item(self._menu_item)
            self._menu_item = None
    
    def _open_settings(self, context):
        fragment = get_last_fragment()
        if not fragment: return
        java_plugin = PluginsController.getInstance().plugins.get(self.id)
        if java_plugin:
            fragment.presentFragment(PluginSettingsActivity(java_plugin))
    
    def _refresh_settings_page(self):
        """Принудительно обновляет экран настроек плагина."""
        run_on_ui_thread(lambda: BulletinHelper.show_info("Обновление настроек..."))
        try:
            fragment = get_last_fragment()
            if isinstance(fragment, PluginSettingsActivity) and fragment.getPluginId() == self.id:
                fragment.rebuild(False)
        except Exception as e:
            log(f"[{__id__}] Ошибка при обновлении страницы настроек: {e}")
    
    def _create_ai_settings(self):
        ai_settings_list = [
            Selector(key="ai_provider", text="API провайдер", default=0, items=["OpenRouter", "Groq", "Google Gemini", "Hugging Face"], icon="msg_folders_archive_solar", on_change=lambda v: self._refresh_settings_page()),
            Divider(),
        ]
        
        provider_idx = self.get_setting("ai_provider", 0)
        provider_keys = list(API_PROVIDERS.keys())
        current_provider = provider_keys[provider_idx] if provider_idx < len(provider_keys) else "openrouter"
        
        if current_provider == "openrouter":
            key_setting = "openrouter_api_key"
            key_label = "OpenRouter API Key"
            key_subtext = "Получите ключ на openrouter.ai (Settings -> Keys)"
        elif current_provider == "groq":
            key_setting = "groq_api_key"
            key_label = "Groq API Key"
            key_subtext = "Получите бесплатный ключ на console.groq.com"
        elif current_provider == "gemini":
            key_setting = "gemini_api_key"
            key_label = "Google Gemini API Key"
            key_subtext = "Получите ключ на ai.google.dev"
        else:  # huggingface
            key_setting = "huggingface_api_key"
            key_label = "Hugging Face API Key"
            key_subtext = "Получите ключ на huggingface.co/settings/tokens"
        
        ai_settings_list.append(
            Input(key=key_setting, text=key_label, default="", icon="msg_pin_code_solar", subtext=key_subtext, on_change=lambda v: self._refresh_settings_page())
        )
        ai_settings_list.append(Divider())
        
        pg_api_key = self.get_setting(key_setting, "").strip()
        
        if not pg_api_key:
            ai_settings_list.append(Text(text=f"{key_label} не введен. Введите ключ для разблокировки настроек.", icon="msg_info_solar", accent=True))
            return ai_settings_list
        
        display_items = API_PROVIDERS[current_provider]["display_names"]
        ai_settings_list.extend([
            Input(key="command_prefix", text=Z.get_string("CMD_PREFIX"), default=".palette", icon="input_bot1_solar"),
            Input(key="title_template", text=Z.get_string("TITLE_TEMPLATE"), default="*«{prompt}»*", icon="msg_edit", subtext=Z.get_string("TITLE_TEMPLATE_SUB")),
            Selector(key="ai_model", text=Z.get_string("AI_MODEL"), default=0, items=display_items, icon="msg_folders_bots_solar"),
            Input(key="color_count", text=Z.get_string("COLOR_COUNT"), default="15", icon="menu_profile_colors_solar"),
            Input(key="ai_temperature", text=Z.get_string("AI_TEMPERATURE"), default="0.8", icon="msg_emoji_objects_solar", subtext=Z.get_string("AI_TEMPERATURE_SUB")),
            Divider("Поддержка нескольких провайдеров AI для гибкости."),
        ])
        
        return ai_settings_list
    
    def _create_image_gen_settings(self):
        return [
            Input(key="command_from_image", text=Z.get_string("CMD_FROM_IMAGE"), default=".pfrom", icon="input_bot1_solar"),
            Input(key="title_from_image_template", text=Z.get_string("TITLE_FROM_IMAGE_TEMPLATE"), default="*Изображение*", icon="msg_edit"),
            Input(key="extract_color_count", text=Z.get_string("EXTRACT_COLOR_COUNT"), default="7", icon="menu_profile_colors_solar"),
            Selector(key="quantization_method", text=Z.get_string("QUANTIZE_METHOD"), default=0, items=Z.get_string("QUANTIZE_ITEMS"), icon="menu_edit_appearance_solar"),
            Selector(key="color_sort_method", text=Z.get_string("COLOR_SORT"), default=0, items=Z.get_string("COLOR_SORT_ITEMS"), icon="tabs_reorder_solar"),
            Input(key="background_blur_radius", text=Z.get_string("BLUR_RADIUS"), default="50", icon="flash_off_solar"),
            Input(key="background_darkness", text=Z.get_string("BG_DARKNESS"), default="40", icon="msg_brightness_low_solar"),
        ]
    
    def _create_random_gen_settings(self):
        return [
            Input(key="command_random_gradient", text=Z.get_string("CMD_RANDOM_GRADIENT"), default=".randpal", icon="input_bot1_solar"),
            Input(key="title_random_template", text=Z.get_string("TITLE_RANDOM_TEMPLATE"), default="*Случайный градиент*", icon="msg_edit"),
            Input(key="random_color_count", text=Z.get_string("RANDOM_COLOR_COUNT"), default="5", icon="menu_profile_colors_solar"),
        ]
    
    def _create_style_settings(self):
        return [
            Switch(key="auto_grid_enable", text=Z.get_string("AUTO_GRID_ENABLE"), default=True, icon="msg_customize_s", subtext=Z.get_string("AUTO_GRID_ENABLE_SUB")),
            Input(key="target_resolution", text=Z.get_string("TARGET_RESOLUTION"), default="1280x720", icon="media_dual_camera2_solar", subtext=Z.get_string("TARGET_RESOLUTION_SUB")),
            Selector(key="palette_layout", text=Z.get_string("PALETTE_LAYOUT"), default=0, items=Z.get_string("LAYOUT_ITEMS"), icon="ic_outinline_solar"),
            Selector(key="swatch_shape", text=Z.get_string("SWATCH_SHAPE"), default=0, items=Z.get_string("SHAPE_ITEMS"), icon="msg_photo_crop_solar"),
            Input(key="swatch_radius", text=Z.get_string("SWATCH_RADIUS"), default="20", icon="msg_photo_curve_solar", subtext=Z.get_string("SWATCH_RADIUS_SUB")),
            Input(key="square_size", text=Z.get_string("SQUARE_SIZE"), default="150", icon="msg_photo_crop_solar"),
            Input(key="padding", text=Z.get_string("PADDING"), default="20", icon="msg_photo_flip_solar"),
            Input(key="outer_padding", text=Z.get_string("OUTER_PADDING"), default="50", icon="msg_photo_flip_solar"),
            Input(key="solid_bg_color", text=Z.get_string("SOLID_BG_COLOR"), default="", icon="menu_profile_colors_solar", subtext=Z.get_string("SOLID_BG_COLOR_SUB")),
            Switch(key="swatch_border_enable", text=Z.get_string("BORDER_ENABLE"), default=False, icon="menu_select_quote_solar"),
            Input(key="swatch_border_width", text=Z.get_string("BORDER_WIDTH"), default="5", icon="photo_paint_brush_solar"),
            Input(key="swatch_border_color", text=Z.get_string("BORDER_COLOR"), default="#FFFFFF", icon="menu_profile_colors_solar"),
            Switch(key="swatch_shadow", text=Z.get_string("SWATCH_SHADOW"), default=False, icon="media_dual_camera2_shadow_solar", subtext=Z.get_string("SWATCH_SHADOW_SUB")),
            Switch(key="show_codes_on_image", text=Z.get_string("CODES_ON_IMAGE"), default=True, icon="msg_photo_text2_solar"),
            Input(key="font_size_on_image", text=Z.get_string("FONT_SIZE"), default="18", icon="msg_contacts_name_remix"),
            Input(key="font_color_on_image", text=Z.get_string("FONT_COLOR"), default="#FFFFFF", icon="menu_profile_colors_solar"),
            Switch(key="auto_font_color", text=Z.get_string("AUTO_FONT_COLOR"), default=False, icon="ic_colorpicker_solar", subtext=Z.get_string("AUTO_FONT_COLOR_SUB")),
            Divider("При включении данного пункта могут возникнуть ошибки с демонстрацей кода(-ов) цвета(-ов) на предоставляемом фото."),
            Selector(key="image_format", text=Z.get_string("IMAGE_FORMAT"), default=0, items=Z.get_string("FORMAT_ITEMS"), icon="msg_copy_photo_solar"),
        ]
    
    def _create_caption_settings(self):
        return [
            Selector(key="send_mode", text=Z.get_string("SEND_MODE"), default=1, items=Z.get_string("SEND_MODE_ITEMS"), icon="filled_button_share_solar"),
            Selector(key="code_format", text=Z.get_string("CODE_FORMAT"), default=0, items=COLOR_FORMATS_DISPLAY_PB, icon="msg_pin_code_solar"),
            Selector(key="code_separator", text=Z.get_string("CODE_SEPARATOR"), default=6, items=Z.get_string("SEPARATOR_ITEMS"), icon="tabs_reorder_solar"),
            Input(key="code_line_template", text=Z.get_string("CODE_LINE_TEMPLATE"), default="{code}", icon="msg_pin_code_solar", subtext=Z.get_string("CODE_LINE_TEMPLATE_SUB")),
            Input(key="custom_footer_text", text=Z.get_string("FOOTER_TEXT"), default="", icon="msg_edit"),
        ]
    
    def _create_advanced_settings(self):
        return [
            Switch(key="add_color_names", text=Z.get_string("ADD_COLOR_NAMES"), default=False, icon="msg_info_filled_solar", subtext=Z.get_string("ADD_COLOR_NAMES_SUB")),
            Switch(key="show_processing_time", text=Z.get_string("SHOW_PROCESSING_TIME"), default=False, icon="menu_premium_clock_solar", subtext=Z.get_string("SHOW_PROCESSING_TIME_SUB")),
        ]
    
    def create_settings(self):
        return [
            Header(text=Z.get_string("SETTINGS_HEADER")),
            Switch(key="enabled", text=Z.get_string("ENABLE_PLUGIN"), default=True, icon="msg_instant_link_solar"),
            Switch(key="show_settings_in_menu", text=Z.get_string("SHOW_SETTINGS_IN_MENU"), default=True, icon="tabs_reorder_solar", on_change=self._update_settings_menu_item_visibility),
            Text(text=Z.get_string("AI_HEADER"), icon="ai_chat_solar", create_sub_fragment=self._create_ai_settings),
            Text(text=Z.get_string("IMAGE_HEADER"), icon="filled_add_photo_solar", create_sub_fragment=self._create_image_gen_settings),
            Text(text=Z.get_string("RANDOM_HEADER"), icon="msg_stories_closefriends_solar", create_sub_fragment=self._create_random_gen_settings),
            Text(text=Z.get_string("IMAGE_STYLE_HEADER"), icon="menu_edit_appearance_solar", create_sub_fragment=self._create_style_settings),
            Text(text=Z.get_string("CAPTION_HEADER"), icon="msg_edit", create_sub_fragment=self._create_caption_settings),
            Text(text=Z.get_string("ADVANCED_HEADER"), icon="etg_settings_solar", create_sub_fragment=self._create_advanced_settings),
        ]
    
    def _setup_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir: return
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists():
                temp_dir.mkdirs()
            self.pg_temp_dir = temp_dir
            self.pg_font_path = File(temp_dir, FONT_NAME).getAbsolutePath()
        except Exception as e:
            log(f"[{__id__}] Ошибка при настройке временной папки: {e}")
    
    def _fetch_font(self):
        if not self.pg_font_path or os.path.exists(self.pg_font_path): return
        try:
            response = requests.get(FONT_URL, timeout=15)
            response.raise_for_status()
            with open(self.pg_font_path, "wb") as f: f.write(response.content)
            log(f"[{__id__}] Шрифт успешно загружен в {self.pg_font_path}")
        except Exception as e:
            log(f"[{__id__}] Не удалось загрузить шрифт: {e}")
    
    def _get_font(self, size: int):
        try:
            if self.pg_font_path and os.path.exists(self.pg_font_path):
                return ImageFont.truetype(self.pg_font_path, size)
        except Exception as e:
            log(f"[{__id__}] Ошибка загрузки кастомного шрифта: {e}. Используется шрифт по умолчанию.")
        return ImageFont.load_default()
    
    def _format_code(self, hex_code: str) -> str:
        format_index_pb = self.get_setting("code_format", 0)
        r_pb, g_pb, b_pb = _hex_to_rgb_pb(hex_code)
        if format_index_pb == 0: return hex_code
        if format_index_pb == 1: return f"{r_pb},{g_pb},{b_pb}"
        if format_index_pb == 2: h_pb, s_pb, l_pb = _rgb_to_hsl_pb(r_pb, g_pb, b_pb); return f"{h_pb},{s_pb},{l_pb}"
        if format_index_pb == 3: h_pb, s_pb, v_pb = _rgb_to_hsv_pb(r_pb, g_pb, b_pb); return f"{h_pb},{s_pb},{v_pb}"
        if format_index_pb == 4: c_pb, m_pb, y_pb, k_pb = _rgb_to_cmyk_pb(r_pb, g_pb, b_pb); return f"{c_pb},{m_pb},{y_pb},{k_pb}"
        if format_index_pb == 5: return f"rgb({r_pb},{g_pb},{b_pb})"
        return hex_code
    
    def _send_error_message(self, params: Any, title_key: str, details_key: Optional[str] = None, e: Optional[Exception] = None):
        """Отправляет сообщение об ошибке в чат и BulletinHelper."""
        error_title = Z.get_string(title_key)
        error_details = Z.get_string(details_key) if details_key else ""
        full_log_message = f"[{__id__}] Ошибка: {error_title}"
        if error_details:
            full_log_message += f" Детали: {error_details}"
        if e:
            full_log_message += f"\n{traceback.format_exc()}"
        log(full_log_message)
        
        run_on_ui_thread(lambda: BulletinHelper.show_error(error_title, get_last_fragment()))
        
        chat_message_text = f"❌ *{error_title}*"
        if error_details:
            chat_message_text += f"\n{error_details}"
        chat_message_text += f"\n{Z.get_string('CHECK_LOGS_FOR_DETAILS')}"
        
        parsed_error_message = parse_markdown(chat_message_text)
        send_message({
            "peer": params.peer,
            "message": parsed_error_message.text,
            "entities": [entity.to_tlrpc_object() for entity in parsed_error_message.entities],
            "replyToMsg": params.replyToMsg,
            "replyToTopMsg": params.replyToTopMsg,
        })
    
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not self.get_setting("enabled", True): return HookResult()
        if not hasattr(params, 'message') or not isinstance(params.message, str): return HookResult()
        
        msg_text_pb = params.message.strip()
        
        if self.pg_is_processing:
            self._send_error_message(params, "BUSY_PROCESSING")
            return HookResult(strategy=HookStrategy.CANCEL)
        
        try:
            command_prefix = self.get_setting("command_prefix", ".palette").strip()
            if msg_text_pb.lower().startswith(command_prefix.lower() + " "):
                prompt_pb = msg_text_pb[len(command_prefix) + 1:].strip()
                if not prompt_pb:
                    self._send_error_message(params, "NO_PROMPT_PROVIDED", f"Пример: {command_prefix} закат в горах")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                provider_idx = self.get_setting("ai_provider", 0)
                provider_keys = list(API_PROVIDERS.keys())
                current_provider = provider_keys[provider_idx] if provider_idx < len(provider_keys) else "openrouter"
                
                key_map = {
                    "openrouter": "openrouter_api_key",
                    "groq": "groq_api_key",
                    "gemini": "gemini_api_key",
                    "huggingface": "huggingface_api_key"
                }
                
                api_key = self.get_setting(key_map.get(current_provider, "openrouter_api_key"), "").strip()
                if not api_key:
                    self._send_error_message(params, "AI_GEN_FAILED_API_KEY")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                run_on_ui_thread(lambda: BulletinHelper.show_info(f"Генерирую палитру для «{prompt_pb}»..."))
                threading.Thread(target=self._generate_and_send_ai, args=(prompt_pb, params), daemon=True).start()
                return HookResult(strategy=HookStrategy.CANCEL)
            
            image_command_prefix = self.get_setting("command_from_image", ".pfrom").strip()
            if msg_text_pb.lower().startswith(image_command_prefix.lower()):
                if not params.replyToMsg or not self._has_photo(params.replyToMsg):
                    self._send_error_message(params, "REPLY_TO_PHOTO_REQUIRED")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                run_on_ui_thread(lambda: BulletinHelper.show_info("Извлекаю цвета из изображения..."))
                threading.Thread(target=self._generate_from_image_and_send, args=(params,), daemon=True).start()
                return HookResult(strategy=HookStrategy.CANCEL)
            
            random_gradient_command_prefix = self.get_setting("command_random_gradient", ".randpal").strip()
            if msg_text_pb.lower().startswith(random_gradient_command_prefix.lower()):
                run_on_ui_thread(lambda: BulletinHelper.show_info("Генерирую случайный градиент..."))
                threading.Thread(target=self._generate_random_colors_and_send, args=(params,), daemon=True).start()
                return HookResult(strategy=HookStrategy.CANCEL)
        
        except Exception as e:
            self._send_error_message(params, "ERROR_IN_CHAT", f"{type(e).__name__}: {e}", e)
            return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()
    
    def _sort_colors(self, hex_codes: list) -> list:
        sort_method = self.get_setting("color_sort_method", 0)
        if sort_method == 0: return hex_codes
        if sort_method == 1: return sorted(hex_codes, key=_get_hue)
        if sort_method == 2: return sorted(hex_codes, key=_get_brightness)
        if sort_method == 3: return sorted(hex_codes, key=_get_saturation)
        return hex_codes
    
    def _generate_and_send_ai(self, prompt: str, params: Any):
        start_time = time.time()
        self.pg_is_processing = True
        try:
            hex_codes = self._get_hex_codes_from_ai(prompt)
            if not hex_codes:
                return
            
            image_path_pb = self._create_palette_image(hex_codes)
            if not image_path_pb:
                self._send_error_message(params, "PALETTE_IMAGE_CREATION_FAILED", "Не удалось создать изображение палитры.")
                return
            
            title_pb = self.get_setting("title_template", "*«{prompt}»*").format(prompt=prompt)
            self._send_results(params, image_path_pb, hex_codes, title_pb, start_time)
        
        except Exception as e_pb:
            self._send_error_message(params, "AI_GEN_FAILED_GENERAL", f"{type(e_pb).__name__}: {e_pb}", e_pb)
        finally:
            self.pg_is_processing = False
    
    def _generate_from_image_and_send(self, params: Any):
        start_time = time.time()
        self.pg_is_processing = True
        try:
            replied_msg_pb = params.replyToMsg
            photo_path_pb = self._download_photo_sync(replied_msg_pb)
            
            if not photo_path_pb:
                return
            
            count_pb = int(self.get_setting("extract_color_count", "7"))
            quant_method = self.get_setting("quantization_method", 0)
            hex_codes_pb = self._extract_colors_from_image(photo_path_pb, count_pb, quant_method)
            
            if not hex_codes_pb:
                return
            
            hex_codes_pb = self._sort_colors(hex_codes_pb)
            image_path_final_pb = self._create_palette_image(hex_codes_pb, bg_image_path=photo_path_pb)
            
            if not image_path_final_pb:
                self._send_error_message(params, "PALETTE_IMAGE_CREATION_FAILED", "Не удалось создать изображение.")
                return
            
            title_pb = self.get_setting("title_from_image_template", "*Изображение*")
            self._send_results(params, image_path_final_pb, hex_codes_pb, title_pb, start_time)
        
        except Exception as e_pb:
            self._send_error_message(params, "IMAGE_CREATION_FAILED", f"{type(e_pb).__name__}: {e_pb}", e_pb)
        finally:
            self.pg_is_processing = False
    
    def _generate_random_colors_and_send(self, params: Any):
        start_time = time.time()
        self.pg_is_processing = True
        try:
            color_count = int(self.get_setting("random_color_count", "5"))
            hex_codes_pb = []
            for _ in range(color_count):
                r = random.randint(0, 255)
                g = random.randint(0, 255)
                b = random.randint(0, 255)
                hex_codes_pb.append(f"#{r:02x}{g:02x}{b:02x}".upper())
            
            image_path_pb = self._create_palette_image(hex_codes_pb)
            if not image_path_pb:
                self._send_error_message(params, "PALETTE_IMAGE_CREATION_FAILED", "Не удалось создать изображение случайной палитры.")
                return
            
            title_pb = self.get_setting("title_random_template", "*Случайный градиент*")
            self._send_results(params, image_path_pb, hex_codes_pb, title_pb, start_time)
        
        except Exception as e_pb:
            self._send_error_message(params, "RANDOM_GEN_FAILED", f"{type(e_pb).__name__}: {e_pb}", e_pb)
        finally:
            self.pg_is_processing = False
    
    def _create_palette_image(self, hex_codes: list, bg_image_path: str = None) -> str:
        if not self.pg_temp_dir or not hex_codes: return ""
        
        try:
            auto_grid_enabled = self.get_setting("auto_grid_enable", True)
            layout_idx = self.get_setting("palette_layout", 0)
            shape_idx = self.get_setting("swatch_shape", 0)
            padding = int(self.get_setting("padding", "20"))
            outer_padding = int(self.get_setting("outer_padding", "50"))
            show_codes = self.get_setting("show_codes_on_image", True)
            font_size = int(self.get_setting("font_size_on_image", "18"))
            font_color_hex = self.get_setting("font_color_on_image", "#FFFFFF")
            auto_font_color = self.get_setting("auto_font_color", False)
            border_enabled = self.get_setting("swatch_border_enable", False)
            border_width = int(self.get_setting("swatch_border_width", "5"))
            border_color = self.get_setting("swatch_border_color", "#FFFFFF")
            shadow_enabled = self.get_setting("swatch_shadow", False)
            radius = int(self.get_setting("swatch_radius", "20"))
            
            font = self._get_font(font_size)
            
            text_height_per_swatch = 0
            if show_codes:
                sample_text_for_measure = self._format_code("#000000")
                bbox_sample_text = font.getbbox(sample_text_for_measure)
                actual_text_content_height = bbox_sample_text[3] - bbox_sample_text[1]
                text_height_per_swatch = actual_text_content_height + 10
            
            num_colors = len(hex_codes)
            
            if auto_grid_enabled and layout_idx == 0:
                try:
                    res_str = self.get_setting("target_resolution", "1280x720")
                    canvas_w, canvas_h = map(int, res_str.lower().split('x'))
                except (ValueError, IndexError):
                    canvas_w, canvas_h = 1280, 720
                
                available_w = canvas_w - 2 * outer_padding
                available_h = canvas_h - 2 * outer_padding
                
                best_layout = {'cols': 1, 'rows': num_colors, 'size': 0}
                for cols_candidate in range(1, num_colors + 1):
                    rows_candidate = math.ceil(num_colors / cols_candidate)
                    size_w = (available_w - (cols_candidate - 1) * padding) / cols_candidate
                    size_h = (available_h - (rows_candidate - 1) * padding) / rows_candidate - text_height_per_swatch
                    current_size = min(size_w, size_h)
                    if current_size > best_layout['size']:
                        best_layout['size'] = current_size
                        best_layout['cols'] = cols_candidate
                        best_layout['rows'] = rows_candidate
                
                square_size = int(best_layout['size'])
                cols = best_layout['cols']
                rows = best_layout['rows']
                
                content_w = (square_size * cols) + (padding * (cols - 1))
                content_h = rows * (square_size + text_height_per_swatch) + (padding * (rows - 1))
                
                final_outer_padding_w = (canvas_w - content_w) / 2
                final_outer_padding_h = (canvas_h - content_h) / 2
            else:
                square_size = int(self.get_setting("square_size", "150"))
                final_outer_padding_w = outer_padding
                final_outer_padding_h = outer_padding
                
                if layout_idx == 0:
                    cols = int(math.ceil(math.sqrt(num_colors)))
                    rows = int(math.ceil(num_colors / cols))
                    content_w = (square_size * cols) + (padding * (cols - 1))
                    content_h = rows * (square_size + text_height_per_swatch) + (padding * (rows - 1))
                elif layout_idx == 1:
                    cols, rows = num_colors, 1
                    content_w = (square_size * cols) + (padding * (cols - 1))
                    content_h = square_size + text_height_per_swatch
                else:
                    cols, rows = 1, num_colors
                    content_w = square_size
                    content_h = (square_size + text_height_per_swatch) * rows + (padding * (rows - 1))
                
                canvas_w = content_w + outer_padding * 2
                canvas_h = content_h + outer_padding * 2
            
            if bg_image_path and os.path.exists(bg_image_path):
                bg_img = Image.open(bg_image_path).convert("RGB")
                resized_bg = ImageOps.fit(bg_img, (canvas_w, canvas_h), Image.Resampling.LANCZOS)
                blur = int(self.get_setting("background_blur_radius", "50"))
                if blur > 0: resized_bg = resized_bg.filter(ImageFilter.GaussianBlur(radius=blur))
                darkness = int(self.get_setting("background_darkness", "40"))
                if darkness > 0: resized_bg = ImageEnhance.Brightness(resized_bg).enhance(1.0 - darkness / 100.0)
                final_canvas = resized_bg
            else:
                bg_color = self.get_setting("solid_bg_color", "") or "#000000"
                final_canvas = Image.new("RGB", (canvas_w, canvas_h), bg_color)
            
            shadow_layer = Image.new('RGBA', final_canvas.size, (0,0,0,0))
            shadow_draw = ImageDraw.Draw(shadow_layer)
            
            for i, code in enumerate(hex_codes):
                if layout_idx == 0: col, row = i % cols, i // cols
                elif layout_idx == 1: col, row = i, 0
                else: col, row = 0, i
                
                x0 = final_outer_padding_w + col * (square_size + padding)
                y0 = final_outer_padding_h + row * (square_size + text_height_per_swatch + padding)
                x1, y1 = x0 + square_size, y0 + square_size
                
                if shadow_enabled:
                    shadow_offset = int(square_size * 0.05)
                    s_x0, s_y0, s_x1, s_y1 = x0 + shadow_offset, y0 + shadow_offset, x1 + shadow_offset, y1 + shadow_offset
                    shadow_color = (0, 0, 0, 100)
                    if shape_idx == 0: shadow_draw.rounded_rectangle([s_x0, s_y0, s_x1, s_y1], radius=radius, fill=shadow_color)
                    elif shape_idx == 1: shadow_draw.rectangle([s_x0, s_y0, s_x1, s_y1], fill=shadow_color)
                    elif shape_idx == 2: shadow_draw.ellipse([s_x0, s_y0, s_x1, s_y1], fill=shadow_color)
            
            if shadow_enabled:
                shadow_layer = shadow_layer.filter(ImageFilter.GaussianBlur(radius=5))
                final_canvas.paste(shadow_layer, (0,0), shadow_layer)
            
            draw = ImageDraw.Draw(final_canvas)
            
            for i, code in enumerate(hex_codes):
                if layout_idx == 0: col, row = i % cols, i // cols
                elif layout_idx == 1: col, row = i, 0
                else: col, row = 0, i
                
                x0 = final_outer_padding_w + col * (square_size + padding)
                y0 = final_outer_padding_h + row * (square_size + text_height_per_swatch + padding)
                x1, y1 = x0 + square_size, y0 + square_size
                
                if border_enabled:
                    b_x0, b_y0 = x0 - border_width, y0 - border_width
                    b_x1, b_y1 = x1 + border_width, y1 + border_width
                    if shape_idx == 0: draw.rounded_rectangle([b_x0, b_y0, b_x1, b_y1], radius=radius + border_width, fill=border_color)
                    elif shape_idx == 1: draw.rectangle([b_x0, b_y0, b_x1, b_y1], fill=border_color)
                    elif shape_idx == 2: draw.ellipse([b_x0, b_y0, b_x1, b_y1], fill=border_color)
                
                if shape_idx == 0: draw.rounded_rectangle([x0, y0, x1, y1], radius=radius, fill=code)
                elif shape_idx == 1: draw.rectangle([x0, y0, x1, y1], fill=code)
                elif shape_idx == 2: draw.ellipse([x0, y0, x1, y1], fill=code)
                
                if show_codes:
                    text_to_draw = self._format_code(code)
                    current_text_bbox = font.getbbox(text_to_draw)
                    text_w = current_text_bbox[2] - current_text_bbox[0]
                    text_x = x0 + (square_size - text_w) / 2
                    text_y_draw_origin = (y1 + 5) - current_text_bbox[1]
                    
                    final_font_color = font_color_hex
                    if auto_font_color:
                        final_font_color = "#000000" if _get_luminance(_hex_to_rgb_pb(code)) > 0.5 else "#FFFFFF"
                    
                    draw.text((text_x, text_y_draw_origin), text_to_draw, font=font, fill=final_font_color)
            
            img_format = self.get_setting("image_format", 0)
            file_ext = "png" if img_format == 0 else "jpg"
            save_format = "PNG" if img_format == 0 else "JPEG"
            path = File(self.pg_temp_dir, f"palette_{uuid.uuid4()}.{file_ext}").getAbsolutePath()
            final_canvas.save(path, save_format, quality=95 if save_format == "JPEG" else None)
            
            return path
        
        except Exception as e:
            log(f"[{__id__}] Ошибка при создании изображения палитры: {e}\n{traceback.format_exc()}")
            raise RuntimeError("Failed to create palette image.") from e
    
    def _get_hex_codes_from_ai(self, prompt: str) -> list:
        try:
            provider_idx = self.get_setting("ai_provider", 0)
            provider_keys = list(API_PROVIDERS.keys())
            current_provider = provider_keys[provider_idx] if provider_idx < len(provider_keys) else "openrouter"
            
            key_map = {
                "openrouter": "openrouter_api_key",
                "groq": "groq_api_key",
                "gemini": "gemini_api_key",
                "huggingface": "huggingface_api_key"
            }
            
            api_key = self.get_setting(key_map.get(current_provider, "openrouter_api_key"), "").strip()
            if not api_key:
                raise ValueError(f"{current_provider} API Key is not set.")
            
            color_count = int(self.get_setting("color_count", "15"))
            model_idx = self.get_setting("ai_model", 0)
            provider_config = API_PROVIDERS[current_provider]
            ai_model = provider_config["models"][model_idx] if model_idx < len(provider_config["models"]) else provider_config["models"][0]
            temp = float(self.get_setting("ai_temperature", "0.8"))
            
            ai_prompt = f"Generate a color palette for '{prompt}'. Provide exactly {color_count} HEX color codes, comma-separated, and nothing else. Example: #RRGGBB, #RRGGBB"
            
            if current_provider == "gemini":
                api_url = provider_config["url"].format(model=ai_model, api_key=api_key)
                payload = {
                    "contents": [{"parts": [{"text": ai_prompt}]}],
                    "generationConfig": {"temperature": temp}
                }
                headers = {"Content-Type": "application/json"}
                response = requests.post(api_url, json=payload, headers=headers, timeout=45)
                response.raise_for_status()
                content = response.json()['candidates'][0]['content']['parts'][0]['text']
            
            elif current_provider == "huggingface":
                api_url = provider_config["url"].format(model=ai_model)
                payload = {"inputs": ai_prompt, "parameters": {"temperature": temp, "max_new_tokens": 250}}
                headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json"}
                response = requests.post(api_url, json=payload, headers=headers, timeout=60)
                response.raise_for_status()
                result = response.json()
                content = result[0]['generated_text'] if isinstance(result, list) else result.get('generated_text', '')
            
            else:
                api_url = provider_config["url"]
                payload = {"model": ai_model, "messages": [{"role": "user", "content": ai_prompt}], "temperature": temp}
                headers = {
                    "Authorization": f"Bearer {api_key}",
                    "Content-Type": "application/json"
                }
                response = requests.post(api_url, json=payload, headers=headers, timeout=45)
                response.raise_for_status()
                content = response.json()['choices'][0]['message']['content']
            
            hex_codes = [f"#{code.upper()}" for code in re.findall(r'#([A-Fa-f0-9]{6})', content)]
            
            if not hex_codes:
                raise ValueError("AI returned no valid HEX color codes.")
            
            return hex_codes
        
        except requests.exceptions.RequestException as e:
            log(f"[{__id__}] Ошибка API {current_provider}: {e}\n{traceback.format_exc()}")
            if hasattr(e, 'response') and e.response is not None:
                log(f"[{__id__}] Ответ API: {e.response.text}")
                if e.response.status_code in [401, 403]:
                    raise RuntimeError("API Key invalid or forbidden.") from e
            raise RuntimeError("API request failed.") from e
        except Exception as e:
            log(f"[{__id__}] Непредвиденная ошибка при получении HEX-кодов от AI: {e}\n{traceback.format_exc()}")
            raise RuntimeError("Unexpected error from AI.") from e
    
    def _has_photo(self, message_obj: MessageObject) -> bool:
        if not message_obj or not message_obj.messageOwner: return False
        media_pb = message_obj.messageOwner.media
        return isinstance(media_pb, TLRPC.TL_messageMediaPhoto) and media_pb.photo is not None
    
    def _download_photo_sync(self, message_obj: MessageObject) -> str:
        try:
            photo = message_obj.messageOwner.media.photo
            sizes = list(photo.sizes.toArray())
            largest = max(sizes, key=lambda s: getattr(s, 'w', 0) * getattr(s, 'h', 0))
            
            loader = FileLoader.getInstance(UserConfig.selectedAccount)
            path_obj = loader.getPathToAttach(largest, True)
            
            if path_obj.exists() and path_obj.length() > 0: return path_obj.getAbsolutePath()
            
            loc = ImageLocation.getForPhoto(largest, photo)
            loader.loadFile(loc, message_obj, "jpg", FileLoader.PRIORITY_HIGH, 1)
            
            for _ in range(20):
                if path_obj.exists() and path_obj.length() > 0: return path_obj.getAbsolutePath()
                time.sleep(1)
            
            raise TimeoutError("Photo download timed out.")
        
        except Exception as e:
            log(f"[{__id__}] Ошибка загрузки фото: {e}\n{traceback.format_exc()}")
            raise RuntimeError("Failed to download photo.") from e
    
    def _extract_colors_from_image(self, image_path: str, count: int, method_idx: int) -> list:
        methods = [Image.MAXCOVERAGE, Image.MEDIANCUT, Image.FASTOCTREE]
        try:
            with Image.open(image_path) as img_pb:
                thumb = img_pb.convert("RGB").resize((150, 150), Image.Resampling.BILINEAR)
                quantized = thumb.quantize(colors=count, method=methods[method_idx])
                palette = quantized.getpalette()[:count * 3]
                hex_codes = [f"#{palette[i]:02x}{palette[i+1]:02x}{palette[i+2]:02x}".upper() for i in range(0, len(palette), 3)]
                
                if not hex_codes:
                    raise ValueError("No colors extracted from image.")
                
                return hex_codes
        
        except Exception as e:
            log(f"[{__id__}] Ошибка извлечения цветов: {e}\n{traceback.format_exc()}")
            raise RuntimeError("Failed to extract colors from image.") from e
    
    def _get_color_names(self, hex_codes: list) -> list:
        names = []
        if not self.get_setting("add_color_names", False):
            return [""] * len(hex_codes)
        
        for code in hex_codes:
            try:
                hex_clean = code.lstrip('#')
                response = requests.get(f"https://www.thecolorapi.com/id?hex={hex_clean}", timeout=5)
                if response.status_code == 200:
                    names.append(response.json()['name']['value'])
                else:
                    names.append("Unknown")
            except Exception as e:
                log(f"[{__id__}] Ошибка при получении имени цвета для {code}: {e}")
                names.append("Unknown")
        
        return names
    
    def _send_results(self, params: Any, image_path: str, hex_codes: list, title: str, start_time: float):
        try:
            color_names = self._get_color_names(hex_codes)
            send_mode = self.get_setting("send_mode", 1)
            separator_idx = self.get_setting("code_separator", 6)
            separator = self.separators[separator_idx]
            code_template = self.get_setting("code_line_template", "{code}")
            
            formatted_codes = [code_template.format(code=self._format_code(code), name=name) for code, name in zip(hex_codes, color_names)]
            codes_string = separator.join(formatted_codes)
            
            footer = self.get_setting("custom_footer_text", "")
            final_text = f"{title}\n\n{codes_string}"
            
            if self.get_setting("show_processing_time", False):
                processing_time = time.time() - start_time
                footer += f"\n\n_Сгенерировано за {processing_time:.2f} сек._"
            
            if footer.strip(): final_text += f"\n\n{footer.strip()}"
            
            parsed_text = parse_markdown(final_text)
            entities = [entity.to_tlrpc_object() for entity in parsed_text.entities]
            
            if send_mode == 2:
                SendMessagesHelper.prepareSendingDocument(UserConfig.selectedAccount, image_path, image_path, None, None, "image/png", params.peer, params.replyToMsg, params.replyToTopMsg, None, None, None, True, 0, None, None, 0, False)
                time.sleep(0.2)
                send_message({"peer": params.peer, "message": parsed_text.text, "entities": entities, "replyToMsg": params.replyToMsg})
            else:
                photo_sizes = get_send_messages_helper().generatePhotoSizes(image_path, None)
                if not photo_sizes:
                    raise RuntimeError("Failed to create photo preview.")
                
                if send_mode == 1:
                    send_message({"peer": params.peer, "photo": photo_sizes, "path": image_path, "caption": parsed_text.text, "entities": entities, "replyToMsg": params.replyToMsg})
                else:
                    send_message({"peer": params.peer, "photo": photo_sizes, "path": image_path, "replyToMsg": params.replyToMsg})
                    time.sleep(0.2)
                    send_message({"peer": params.peer, "message": parsed_text.text, "entities": entities, "replyToMsg": params.replyToMsg})
        
        except Exception as e_pb:
            log(f"[{__id__}] Ошибка при отправке результатов: {e_pb}\n{traceback.format_exc()}")
            raise RuntimeError("Failed to send results message.") from e_pb
        finally:
            self._delete_file_delayed(image_path)
    
    def _delete_file_delayed(self, path: str, delay: int = 10):
        def action_pb():
            try:
                time.sleep(delay)
                if os.path.exists(path):
                    os.remove(path)
            except OSError as e:
                log(f"[{__id__}] Не удалось удалить временный файл {path}: {e}")
        
        threading.Thread(target=action_pb, daemon=True).start()