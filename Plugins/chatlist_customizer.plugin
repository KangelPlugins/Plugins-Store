from datetime import datetime
from java.util import Locale
from base_plugin import BasePlugin
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from client_utils import get_last_fragment, get_messages_controller, send_request
from android_utils import run_on_ui_thread, log
from org.telegram.messenger import LocaleController, R

# Metadados do plugin
__id__ = "chatlist_customizer"
__name__ = "ChatList Customizer"
__description__ = "Customizes the Chat List text with dynamic time-based greetings and custom text.\n\nНастраивает текст списка чатов с динамическими приветствиями по времени и пользовательским текстом."
__author__ = "@AGeekApple"
__version__ = "1.0.0"
__min_version__ = "11.12.1"
__icon__ = "ApplePlugins/18"
__priority__ = 0

# Dicionário de traduções simplificado
TRANSLATIONS = {
    "chatlist_customizer": {
        "pt": "ChatList Customizer",
        "en": "ChatList Customizer", 
        "ru": "Настройщик списка чатов"
    },
    "welcome_message": {
        "pt": "Personalize o título da sua Chat List com saudações dinâmicas e texto customizado.",
        "en": "Customize your Chat List title with dynamic greetings and custom text.",
        "ru": "Настройте заголовок списка чатов с динамическими приветствиями и пользовательским текстом."
    },
    "enable_greeting": {
        "pt": "Ativar Saudação",
        "en": "Enable Greeting",
        "ru": "Включить приветствие"
    },
    "enable_greeting_desc": {
        "pt": "Ativa saudações dinâmicas baseadas no horário (manhã, tarde, noite)",
        "en": "Enable dynamic greetings based on time of day (morning, afternoon, evening)",
        "ru": "Включить динамические приветствия в зависимости от времени суток (утро, день, вечер)"
    },
    "display_name_option": {
        "pt": "Título Exibido",
        "en": "Display Title",
        "ru": "Отображаемый заголовок"
    },
    "name_option_none": {
        "pt": "Nenhum",
        "en": "None",
        "ru": "Нет"
    },
    "name_option_my_name": {
        "pt": "First Name",
        "en": "First Name",
        "ru": "Имя"
    },
    "name_option_my_username": {
        "pt": "Username",
        "en": "Username", 
        "ru": "Username"
    },
    "name_option_custom": {
        "pt": "Personalizado",
        "en": "Custom",
        "ru": "Пользовательский"
    },
    "custom_name_input": {
        "pt": "Nome Personalizado",
        "en": "Custom Name",
        "ru": "Пользовательское имя"
    },
    "custom_name_desc": {
        "pt": "Digite o nome que deseja exibir na saudação",
        "en": "Enter the name you want to display in the greeting",
        "ru": "Введите имя, которое хотите отображать в приветствии"
    },
    "fix_title": {
        "pt": "Fixar Título",
        "en": "Fix Title",
        "ru": "Зафиксировать заголовок"
    },
    "fix_title_desc": {
        "pt": "Tenta manter o título personalizado visível",
        "en": "Tries to keep the custom title visible",
        "ru": "Пытается удерживать пользовательский заголовок видимым"
    },
    
    # Dialog de restart
    "restart_required_title": {
        "pt": "Reinicialização Necessária",
        "en": "Restart Required",
        "ru": "Требуется перезапуск"
    },
    "restart_required_message": {
        "pt": "Reiniciar ajuda a aplicar as alterações.",
        "en": "Restarting helps apply changes.",
        "ru": "Перезапуск помогает применить изменения."
    },
    "restart_button": {
        "pt": "Reiniciar",
        "en": "Restart",
        "ru": "Перезапустить"
    },
    "cancel_button": {
        "pt": "Cancelar",
        "en": "Cancel",
        "ru": "Отмена"
    },
    
    # Seções da interface
    "greeting_settings_section": {
        "pt": "Configurações de Saudação",
        "en": "Greeting Settings",
        "ru": "Настройки приветствия"
    },
    "display_settings_section": {
        "pt": "Configurações de Exibição",
        "en": "Display Settings",
        "ru": "Настройки отображения"
    },
    "advanced_settings_section": {
        "pt": "Extra",
        "en": "Extra",
        "ru": "Дополнительно"
    },
    
    # Créditos Dotted - Apple
    "credits": {
        "pt": "Dotted Plugins",
        "en": "Dotted Plugins",
        "ru": "Dotted Plugins"
    },
    "good_morning": {
        "pt": "Bom dia",
        "en": "Good morning",
        "ru": "Доброе утро"
    },
    "good_afternoon": {
        "pt": "Boa tarde",
        "en": "Good afternoon", 
        "ru": "Добрый день"
    },
    "good_evening": {
        "pt": "Boa noite",
        "en": "Good evening",
        "ru": "Добрый вечер"
    },
    "user_fallback": {
        "pt": "Usuário",
        "en": "User",
        "ru": "Пользователь"
    },
    "default_title": {
        "pt": "Conversas",
        "en": "Chats",
        "ru": "Чаты"
    },
    "default_custom_text": {
        "pt": "Hey, configure-me!",
        "en": "Hey, set me up!",
        "ru": "Эй, настрой меня!"
    }
}

# Variável global para idioma atual
_LANG = "en"

def _detect_lang():
    """Detecta o idioma do sistema"""
    try:
        code = Locale.getDefault().getLanguage()
        if str(code).startswith("pt"):
            return "pt"
        if str(code).startswith("ru"):
            return "ru"
    except Exception:
        pass
    return "en"

def tr(key):
    """Função de tradução"""
    try:
        d = TRANSLATIONS.get(key, {})
        return d.get(_LANG) or d.get("en") or key
    except Exception:
        return key


class ChatListCustomizerPlugin(BasePlugin):
    """Plugin para personalizar o título da Chat List do TG"""
    
    def __init__(self):
        super().__init__()
        self._refresh_worker_thread = None
        self._refresh_worker_stop = None

    def _get_user_first_name(self):
        """Obtém o primeiro nome do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'first_name', None):
                    return str(user.first_name)
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleName", R.string.ActionBarTitleName))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _get_user_username(self):
        """Obtém o username do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'username', None):
                    username = str(user.username)

                    return f"@{username}" if not username.startswith("@") else username
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleUsername", R.string.ActionBarTitleUsername))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _handle_custom_name_change(self, value):
        """Lida com mudanças no nome customizado"""
        try:
            # Salvar o valor
            self.set_setting("custom_name", value)
            self._apply_settings()
            
            # Se o valor não está vazio, mostrar dialog de restart
            if value.strip():
                self._show_restart_dialog()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança de nome customizado: {e}")

    def _show_restart_dialog(self):
        """Mostra dialog perguntando se quer reiniciar o tg"""
        try:
            from ui.alert import AlertDialogBuilder
            from android.content import Intent
            from android.net import Uri
            from org.telegram.messenger import ApplicationLoader
            
            fragment = get_last_fragment()
            if not fragment:
                return
                
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            if not ctx:
                return
            
            def restart_telegram():
                try:
                    # Usar tg://restart para reiniciar
                    intent = Intent(Intent.ACTION_VIEW, Uri.parse("tg://restart"))
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    ctx.startActivity(intent)
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao reiniciar: {e}")
            
            def show_dialog():
                try:
                    builder = AlertDialogBuilder(ctx)
                    builder.set_title(tr("restart_required_title"))
                    builder.set_message(tr("restart_required_message"))
                    builder.set_positive_button(tr("restart_button"), lambda: restart_telegram())
                    builder.set_negative_button(tr("cancel_button"), None)
                    builder.show()
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao mostrar dialog: {e}")
            
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no dialog de restart: {e}")

    def _get_default_chat_list_title(self):
        """Obtém o título padrão da Chat List usando string do sistema"""
        try:
            # Usar string do sistema
            return str(LocaleController.getString("ListOfChats", R.string.ListOfChats))
        except Exception:
            return tr("default_title")

    def _get_display_name_by_option(self):
        """Obtém o nome baseado na opção selecionada"""
        try:
            name_option = self.get_setting("display_name_option", 0)
            
            if name_option == 0:  # Custom (agora é a primeira opção)
                custom_name = self.get_setting("custom_name", "").strip()
                if not custom_name:
                    # Se não há custom name, usar o texto padrão
                    return tr("default_custom_text")
                return custom_name
            elif name_option == 1:  # None
                return None
            elif name_option == 2:  # First Name
                return self._get_user_first_name()
            elif name_option == 3:  # Username
                return self._get_user_username()
            else:
                return tr("default_custom_text")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao obter display name: {e}")
            return tr("default_custom_text")

    def _get_time_based_greeting(self):
        """Retorna saudação baseada no horário atual"""
        try:
            now = datetime.now()
            hour = now.hour
            
            if hour < 12:
                return tr("good_morning")
            elif hour < 18:
                return tr("good_afternoon")
            else:
                return tr("good_evening")
        except Exception:
            return tr("good_morning")

    def _build_final_title(self):
        """Constrói título final baseado nas configurações"""
        try:
            display_name = self._get_display_name_by_option()
            
            # Se display_name é None (opção "None" selecionada), não mostrar nada customizado
            if display_name is None:
                return None
            
            enable_greeting = self.get_setting("enable_greeting", False)
            
            if enable_greeting:
                greeting = self._get_time_based_greeting()
                result = f"{greeting}, {display_name}!"
                return result
            else:
                # Se greeting está desabilitado, mas display_name não é None, mostrar só o nome
                return display_name
        except Exception as e:
            log(f"[ChatListCustomizer] Error building title: {e}")
            return None

    def _set_chat_list_title(self, title):
        """Aplica título personalizado na Chat List"""
        try:
            log(f"[ChatListCustomizer] Tentando aplicar título: {title}")
            fragment = get_last_fragment()
            log(f"[ChatListCustomizer] Fragment obtido: {fragment}")
            
            if fragment:
                fragment_name = fragment.getClass().getName()
                log(f"[ChatListCustomizer] Fragment name: {fragment_name}")
                
                if "DialogsActivity" in fragment_name:
                    action_bar = fragment.getActionBar()
                    log(f"[ChatListCustomizer] ActionBar obtido: {action_bar}")
                    
                    if action_bar:
                        def apply_title():
                            try:
                                # Primeiro tentar TextView do título
                                try:
                                    title_view = action_bar.getTitleTextView()
                                    if title_view:
                                        title_view.setText(title)
                                        log(f"[ChatListCustomizer] Título aplicado via TextView: {title}")
                                        return
                                except Exception as e:
                                    log(f"[ChatListCustomizer] TextView falhou: {e}")
                                
                                # Fallback para setTitle diretamente
                                action_bar.setTitle(title)
                                log(f"[ChatListCustomizer] Título aplicado via ActionBar: {title}")
                                
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")
                        
                        run_on_ui_thread(apply_title)
                        log(f"[ChatListCustomizer] Comando de aplicação enviado: {title}")
                    else:
                        log("[ChatListCustomizer] ActionBar é None!")
                else:
                    log(f"[ChatListCustomizer] Fragment não é DialogsActivity: {fragment_name}")
            else:
                log("[ChatListCustomizer] Fragment é None!")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")

    def _restore_chat_list_title(self):
        """Restaura o título original usando strings do sistema"""
        try:
            orig = self.get_setting("_original_title", "")
            if not orig:
                # Usar string do sistema como fallback
                orig = self._get_default_chat_list_title()
            self._set_chat_list_title(orig)
            log(f"[ChatListCustomizer] Título original restaurado: {orig}")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao restaurar título: {e}")

    def _toggle_customizer(self, should_be_active):
        """Ativa/desativa o customizador do título baseado se há algo para mostrar"""
        try:
            log(f"[ChatListCustomizer] Toggle customizer: {should_be_active}")
            
            if should_be_active:
                # Capturar título original quando habilitar
                try:
                    fragment = get_last_fragment()
                    if fragment and "DialogsActivity" in fragment.getClass().getName():
                        action_bar = fragment.getActionBar()
                        if action_bar and not self.get_setting("_original_title", ""):
                            try:
                                current_title = str(action_bar.getTitle())
                                if current_title:
                                    self.set_setting("_original_title", current_title)
                                    log(f"[ChatListCustomizer] Título original capturado: {current_title}")
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao capturar título: {e}")
                except Exception:
                    pass
                
                # Aplicar título customizado imediatamente
                final_title = self._build_final_title()
                if final_title:
                    self._set_chat_list_title(final_title)
                
                # Iniciar worker de refresh periódico (15s)
                self._start_refresh_worker(15)
                    
            else:
                # Parar worker e restaurar título original quando desabilitar
                self._stop_refresh_worker()
                self._restore_chat_list_title()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no toggle: {e}")

    def _apply_settings(self):
        """Aplica configurações - chamado quando algo muda"""
        try:
            # Verificar se deve estar ativo baseado se há algo para mostrar
            final_title = self._build_final_title()
            should_be_active = final_title is not None
            
            log(f"[ChatListCustomizer] Should be active: {should_be_active}, final_title: {final_title}")
            self._toggle_customizer(should_be_active)
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar configurações: {e}")
    
    def _start_refresh_worker(self, interval_sec=15):
        """Inicia worker de refresh periódico"""
        try:
            # Parar worker anterior
            self._stop_refresh_worker()
            
            import threading
            import time
            
            stop_event = threading.Event()
            self._refresh_worker_stop = stop_event
            
            def _run():
                try:
                    while not stop_event.is_set():
                        # Verificar se deve aplicar título baseado se há algo para mostrar
                        final_title = self._build_final_title()
                        should_be_active = final_title is not None
                        
                        if should_be_active:
                            # Tentar aplicar título
                            fragment = get_last_fragment()
                            if fragment and "DialogsActivity" in fragment.getClass().getName():
                                # Verificar título atual
                                action_bar = fragment.getActionBar()
                                if action_bar:
                                    try:
                                        current_title = str(action_bar.getTitle())
                                        # Aplicar baseado na configuração Fix Title
                                        fix_title = self.get_setting("fix_title", False)
                                        if fix_title or current_title != final_title:
                                            self._set_chat_list_title(final_title)
                                            if fix_title:
                                                log(f"[ChatListCustomizer] Título fixado aplicado: {final_title}")
                                    except Exception:
                                        self._set_chat_list_title(final_title)
                        
                        # Aguardar próximo ciclo
                        try:
                            fix_title = self.get_setting("fix_title", False)
                            # Intervalo baseado na configuração Fix Title
                            cycle_time = 3 if fix_title else (int(interval_sec) if interval_sec and interval_sec > 0 else 15)
                            
                            for _ in range(cycle_time):
                                if stop_event.is_set():
                                    break
                                time.sleep(1)
                        except Exception:
                            time.sleep(15)
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro no worker: {e}")
            
            t = threading.Thread(target=_run, name="ChatListCustomizerRefresh", daemon=True)
            self._refresh_worker_thread = t
            t.start()
            

            fix_title = self.get_setting("fix_title", False)
            if fix_title:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo fixo - 3s)")
            else:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo normal - 15s)")
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao iniciar worker: {e}")

    def _stop_refresh_worker(self):
        """Para o worker de refresh"" CÓPIA EXATA do nowfy.plugin"""
        try:
            if self._refresh_worker_stop:
                self._refresh_worker_stop.set()
                self._refresh_worker_stop = None
            
            if self._refresh_worker_thread:
                self._refresh_worker_thread = None
                
            log("[ChatListCustomizer] Worker de refresh parado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao parar worker: {e}")

    def create_settings(self):
        """Cria interface de configurações do plugin"""
        try:
            settings = []
            
            # Seção de Configurações de Exibição
            settings.append(Divider(text=tr("display_settings_section")))
            settings.append(Selector(
                key="display_name_option",
                text=tr("display_name_option"),
                default=self.get_setting("display_name_option", 0),
                items=[
                    tr("name_option_custom"),
                    tr("name_option_none"),
                    tr("name_option_my_name"),
                    tr("name_option_my_username")
                ],
                icon="msg_filled_menu_users",
                on_change=lambda v: (
                    self.set_setting("display_name_option", int(v)),
                    self._apply_settings(),
                    # Só mostrar restart se não for "Custom" (opção 0) e não for "None" (opção 1)
                    self._show_restart_dialog() if int(v) != 0 and int(v) != 1 else None,
                    self.reload_settings()
                )
            ))
            

            if self.get_setting("display_name_option", 0) == 0:  # Custom option (agora é a primeira)
                settings.append(Input(
                    key="custom_name",
                    text=tr("custom_name_input"),
                    subtext=tr("custom_name_desc"),
                    default=self.get_setting("custom_name", tr("default_custom_text")),
                    icon="msg_edit",
                    on_change=lambda v: self._handle_custom_name_change(str(v))
                ))
            
            # Seção de Configurações de Saudação
            settings.append(Divider(text=tr("greeting_settings_section")))
            settings.append(Switch(
                key="enable_greeting",
                text=tr("enable_greeting"),
                subtext=tr("enable_greeting_desc"),
                default=self.get_setting("enable_greeting", False),
                icon="menu_feature_status",
                on_change=lambda v: (
                    self.set_setting("enable_greeting", bool(v)),
                    self._apply_settings(),
                    self._show_restart_dialog(),
                    self.reload_settings()
                )
            ))
                
            # Seção de Configurações Avançadas - só mostrar se não for "None" (agora opção 1)
            if self.get_setting("display_name_option", 0) != 1:
                settings.append(Divider(text=tr("advanced_settings_section")))
                settings.append(Switch(
                    key="fix_title",
                    text=tr("fix_title"),
                    subtext=tr("fix_title_desc"),
                    default=self.get_setting("fix_title", False),
                    icon="msg_pin",
                    on_change=lambda v: (
                        self.set_setting("fix_title", bool(v)),
                        self._apply_settings(),
                        self._show_restart_dialog(),
                        self.reload_settings()
                    )
                ))
            
            settings.append(Divider())
            settings.append(Text(
                text=tr("credits") if "credits" in TRANSLATIONS else "Dotted Plugins",
                icon="etg_settings",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
            ))
            
            return settings
            
        except Exception as e:
            log(f"[ChatListCustomizer] Error creating settings: {e}")
            return [
                Header(text="ChatList Customizer"),
                Text(text=(tr("error_loading_settings") if "error_loading_settings" in TRANSLATIONS else "Error loading settings") + f": {e}")
            ]

    def on_plugin_loaded(self):
        """Executado quando o plugin é carregado"""
        try:
            global _LANG
            _LANG = _detect_lang()
            log(f"[ChatListCustomizer] Plugin loaded with language: {_LANG}")
            
            # Definir texto padrão se não existir
            if not self.get_setting("custom_name", ""):
                self.set_setting("custom_name", tr("default_custom_text"))
            
            # Aplicar configurações se houver algo para mostrar
            self._apply_settings()
            
        except Exception as e:
            log(f"[ChatListCustomizer] Error during load: {e}")

    def on_plugin_unloaded(self):
        """Executado quando o plugin é descarregado"""
        try:
            log("[ChatListCustomizer] Unloading plugin...")
            # Parar worker e restaurar título
            self._stop_refresh_worker()
            self._restore_chat_list_title()
            log("[ChatListCustomizer] Plugin descarregado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no descarregamento: {e}")