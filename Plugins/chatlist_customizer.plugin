from datetime import datetime
from java.util import Locale
from java.util import Calendar, TimeZone
from base_plugin import BasePlugin
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from client_utils import get_last_fragment, get_messages_controller, send_request
from android_utils import run_on_ui_thread, log
from org.telegram.messenger import LocaleController, R, AndroidUtilities
from hook_utils import find_class
import requests

__id__ = "chatlist_customizer"
__name__ = "ChatList Customizer"
__description__ = (
    "Enhances your Chat List with dynamic time-based greetings, customizable titles, and live Now Playing integration. "
    "Fully supports stats.fm and Last.fm for real-time music updates.\n\n"
    "Расширяет список чатов динамическими приветствиями по времени суток, настраиваемыми заголовками "
    "и функцией Now Playing. Полная интеграция со stats.fm и Last.fm для обновлений в реальном времени."
)
__author__ = "@AGeekApple"
__version__ = "1.0.1"
__min_version__ = "11.12.1"
__icon__ = "ApplePlugins/18"
__priority__ = 0

# URL do JSON de Smart Messages (raw). Em desenvolvimento, servimos localmente.
SMART_MESSAGES_URL = "https://raw.githubusercontent.com/soumaki/chalist/refs/heads/main/smart_messages.json"

# Dicionário de traduções simplificado
TRANSLATIONS = {
    "chatlist_customizer": {
        "pt": "ChatList Customizer",
        "en": "ChatList Customizer", 
        "ru": "ChatList Customizer"
    },
    "welcome_message": {
        "pt": "Personalize o título da sua Chat List com saudações dinâmicas e texto customizado.",
        "en": "Customize your Chat List title with dynamic greetings and custom text.",
        "ru": "Настройте заголовок списка чатов с динамическими приветствиями и пользовательским текстом."
    },
    "enable_greeting": {
        "pt": "Ativar Saudação",
        "en": "Enable Greeting",
        "ru": "Включить приветствие"
    },
    "enable_greeting_desc": {
        "pt": "Ativa saudações dinâmicas baseadas no horário (manhã, tarde, noite)",
        "en": "Enable dynamic greetings based on time of day (morning, afternoon, evening)",
        "ru": "Включить динамические приветствия в зависимости от времени суток (утро, день, вечер)"
    },
    # Smart Messages — novo selector
    "smart_messages_label": {
        "pt": "Mensagens Inteligentes",
        "en": "Smart Messages",
        "ru": "Умные сообщения"
    },
    "smart_messages_activate": {
        "pt": "Ativado",
        "en": "Activated",
        "ru": "Включено"
    },
    "smart_messages_deactivate": {
        "pt": "Desativar",
        "en": "Deactivate",
        "ru": "Деактивировать"
    },
    "display_name_option": {
        "pt": "Título Exibido",
        "en": "Display Title",
        "ru": "Отображаемый заголовок"
    },
    "name_option_none": {
        "pt": "Nenhum",
        "en": "None",
        "ru": "Нет"
    },
    "name_option_my_name": {
        "pt": "Nome",
        "en": "First Name",
        "ru": "Имя"
    },
    "name_option_my_username": {
        "pt": "Nome de usuário",
        "en": "Username",
        "ru": "Имя пользователя"
    },
    "name_option_custom": {
        "pt": "Personalizado",
        "en": "Custom",
        "ru": "Пользовательский"
    },
    "custom_name_input": {
        "pt": "Nome Personalizado",
        "en": "Custom Name",
        "ru": "Пользовательское имя"
    },
    "custom_name_desc": {
        "pt": "Digite o nome que deseja exibir na saudação",
        "en": "Enter the name you want to display in the greeting",
        "ru": "Введите имя, которое хотите отображать в приветствии"
    },
    "fix_title": {
        "pt": "Fixar Título",
        "en": "Fix Title",
        "ru": "Зафиксировать заголовок"
    },
    "fix_title_desc": {
        "pt": "Tenta manter o título personalizado visível",
        "en": "Tries to keep the custom title visible",
        "ru": "Пытается удерживать пользовательский заголовок видимым"
    },
    
    # Dialog de restart
    "restart_required_title": {
        "pt": "Reinicialização Necessária",
        "en": "Restart Required",
        "ru": "Требуется перезапуск"
    },
    "restart_required_message": {
        "pt": "Reiniciar ajuda a aplicar as alterações.",
        "en": "Restarting helps apply changes.",
        "ru": "Перезапуск помогает применить изменения."
    },
    "restart_button": {
        "pt": "Reiniciar",
        "en": "Restart",
        "ru": "Перезапустить"
    },
    "cancel_button": {
        "pt": "Cancelar",
        "en": "Cancel",
        "ru": "Отмена"
    },
    
    # Seções da interface
    "greeting_settings_section": {
        "pt": "Configurações de Saudação",
        "en": "Greeting Settings",
        "ru": "Настройки приветствия"
    },
    "display_settings_section": {
        "pt": "Configurações de Exibição",
        "en": "Display Settings",
        "ru": "Настройки отображения"
    },
    "advanced_settings_section": {
        "pt": "Extra",
        "en": "Extra",
        "ru": "Дополнительно"
    },
    # Fuso horário e aparência
    "time_settings_section": {
        "pt": "Configurações de Fuso Horário",
        "en": "Time Zone Settings",
        "ru": "Настройки часового пояса"
    },
    "timezone_label": {
        "pt": "Fuso Horário",
        "en": "Time Zone",
        "ru": "Часовой пояс"
    },
    "timezone_system": {
        "pt": "Sistema",
        "en": "System Default",
        "ru": "Системный"
    },
    "timezone_utc": {
        "pt": "UTC",
        "en": "UTC",
        "ru": "UTC"
    },
    "timezone_moscow": {
        "pt": "Europa/Moscou (UTC+3)",
        "en": "Europe/Moscow (UTC+3)",
        "ru": "Европа/Москва (UTC+3)"
    },
    "timezone_sao_paulo": {
        "pt": "América/São Paulo (UTC-3)",
        "en": "America/São Paulo (UTC-3)",
        "ru": "Америка/Сан-Паулу (UTC-3)"
    },
    "timezone_custom_offset": {
        "pt": "Fuso Personalizado",
        "en": "Custom Offset",
        "ru": "Пользовательский часовой сдвиг"
    },
    "timezone_offset_label": {
        "pt": "Fuso (horas)",
        "en": "Offset (hours)",
        "ru": "Смещение (часы)"
    },
    "timezone_offset_desc": {
        "pt": "Selecione o fuso horário UTC (ex.: +3 para Moscou)",
        "en": "Select UTC offset (e.g., +3 for Moscow)",
        "ru": "Выберите смещение UTC (например, +3 для Москвы)"
    },
    
    # Títulos e seções avançadas
    "advanced_settings_link": {
        "pt": "Opções avançadas",
        "en": "Advanced options",
        "ru": "Расширенные параметры"
    },
    "appearance_section": {
        "pt": "Aparência",
        "en": "Appearance",
        "ru": "Внешний вид"
    },
    "behavior_section": {
        "pt": "Comportamento",
        "en": "Behavior",
        "ru": "Поведение"
    },
    "now_playing_filter_titles_label": {
        "pt": "Filtrar títulos (Tocando Agora)",
        "en": "Filter titles (Now Playing)",
        "ru": "Фильтровать названия (Сейчас играет)"
    },
    "now_playing_filter_titles_desc": {
        "pt": "Remove parênteses e 'feat./ft.' dos nomes de músicas.",
        "en": "Removes parentheses and 'feat./ft.' from song titles.",
        "ru": "Удаляет скобки и 'feat./ft.' из названий треков."
    },
    
    # Now Playing (Stats.fm)
    "now_playing_section": {
        "pt": "Tocando Agora",
        "en": "Now Playing",
        "ru": "Сейчас играет"
    },
    "now_playing_label": {
        "pt": "Tocando Agora",
        "en": "Now Playing",
        "ru": "Сейчас играет"
    },
    "statsfm_username_label": {
        "pt": "Usuário do Stats.fm",
        "en": "Stats.fm Username",
        "ru": "Имя пользователя Stats.fm"
    },
    "now_playing_style_label": {
        "pt": "Estilo do Tocando Agora",
        "en": "Now Playing Style",
        "ru": "Стиль Сейчас играет"
    },
    "now_playing_style_single": {
        "pt": "Padrão",
        "en": "Default",
        "ru": "По умолчанию"
    },
    "now_playing_style_typing": {
        "pt": "Digitando",
        "en": "Typing",
        "ru": "Печать"
    },
    "now_playing_style_music_only": {
        "pt": "Somente Música",
        "en": "Music Only",
        "ru": "Только трек"
    },
    "now_playing_provider_label": {
        "pt": "Fonte do Tocando Agora",
        "en": "Now Playing Source",
        "ru": "Источник Сейчас играет"
    },
    "provider_statsfm": {
        "pt": "Stats.fm",
        "en": "Stats.fm",
        "ru": "Stats.fm"
    },
    "provider_lastfm": {
        "pt": "Last.fm",
        "en": "Last.fm",
        "ru": "Last.fm"
    },
    "lastfm_username_label": {
        "pt": "Usuário do Last.fm",
        "en": "Last.fm Username",
        "ru": "Имя пользователя Last.fm"
    },
    "lastfm_api_key_label": {
        "pt": "API Key",
        "en": "API Key",
        "ru": "API-ключ"
    },
    "api_key_option_show": {
        "pt": "Exibir Key",
        "en": "Show Key",
        "ru": "Показать ключ"
    },
    "api_key_option_hide": {
        "pt": "Ocultar Key",
        "en": "Hide Key",
        "ru": "Скрыть ключ"
    },
    "now_playing_divider_source": {
        "pt": "Fonte",
        "en": "Source",
        "ru": "Источник"
    },
    "now_playing_divider_credentials": {
        "pt": "Credenciais",
        "en": "Credentials",
        "ru": "Учетные данные"
    },
    "api_key_selector_label": {
        "pt": "Token de Acesso",
        "en": "Access Token",
        "ru": "Токен доступа"
    },    
    
    # Estilo do título (shape)
    "title_style": {
        "pt": "Estilo do título",
        "en": "Title style",
        "ru": "Стиль заголовка"
    },
    "title_style_none": {
        "pt": "Sem shape",
        "en": "None",
        "ru": "Без бейджа"
    },
    "title_style_dark": {
        "pt": "Shape escuro arredondado",
        "en": "Dark rounded shape",
        "ru": "Тёмный скруглённый бейдж"
    },
    
    # Créditos Dotted - Apple
    "credits": {
        "pt": "Dotted Plugins",
        "en": "Dotted Plugins",
        "ru": "Dotted Plugins"
    },
    "good_morning": {
        "pt": "Bom dia",
        "en": "Good morning",
        "ru": "Доброе утро"
    },
    "good_afternoon": {
        "pt": "Boa tarde",
        "en": "Good afternoon", 
        "ru": "Добрый день"
    },
    "good_evening": {
        "pt": "Boa noite",
        "en": "Good evening",
        "ru": "Добрый вечер"
    },
    "user_fallback": {
        "pt": "Usuário",
        "en": "User",
        "ru": "Пользователь"
    },
    "default_title": {
        "pt": "Conversas",
        "en": "Chats",
        "ru": "Чаты"
    },
    "default_custom_text": {
        "pt": "Hey, configure-me!",
        "en": "Hey, set me up!",
        "ru": "Эй, настрой меня!"
    }
}

# Variável global para idioma atual
_LANG = "en"

def _detect_lang():
    """Detecta o idioma do sistema"""
    try:
        code = Locale.getDefault().getLanguage()
        if str(code).startswith("pt"):
            return "pt"
        if str(code).startswith("ru"):
            return "ru"
    except Exception:
        pass
    return "en"

def tr(key):
    """Função de tradução"""
    try:
        d = TRANSLATIONS.get(key, {})
        return d.get(_LANG) or d.get("en") or key
    except Exception:
        return key


class ChatListCustomizerPlugin(BasePlugin):
    """Plugin para personalizar o título da Chat List do TG"""
    
    def __init__(self):
        super().__init__()
        self._refresh_worker_thread = None
        self._refresh_worker_stop = None
        # Flags e refs para hooks no ActionBar
        self._is_setting_title = False
        self._hook_set_title_ref = None
        self._hook_set_title_anim_ref = None

    def _setup_actionbar_hooks(self):
        """Configura hooks para interceptar mudanças de título do ActionBar"""
        try:
            ActionBarCls = find_class("org.telegram.ui.ActionBar.ActionBar")
            if not ActionBarCls:
                log("[ChatListCustomizer] ActionBar class not found for hooks")
                return

            # Procurar métodos relevantes por nome
            methods = ActionBarCls.getClass().getDeclaredMethods()
            set_title = None
            set_title_anim = None
            try:
                for m in methods:
                    try:
                        name = str(m.getName())
                        params_len = 0
                        try:
                            params_len = m.getParameterTypes().length
                        except Exception:
                            pass
                        if name == "setTitle" and params_len == 1:
                            set_title = m
                        elif name == "setTitleAnimated" and params_len == 3:
                            set_title_anim = m
                    except Exception:
                        pass
            except Exception:
                pass

            # Instalar hooks, se encontrados
            if set_title:
                try:
                    set_title.setAccessible(True)
                    self._hook_set_title_ref = self.hook_method(set_title, _ActionBarTitleHook(self))
                except Exception as e:
                    log(f"[ChatListCustomizer] Failed to hook setTitle: {e}")
            if set_title_anim:
                try:
                    set_title_anim.setAccessible(True)
                    self._hook_set_title_anim_ref = self.hook_method(set_title_anim, _ActionBarTitleHook(self))
                except Exception as e:
                    log(f"[ChatListCustomizer] Failed to hook setTitleAnimated: {e}")

            if self._hook_set_title_ref or self._hook_set_title_anim_ref:
                log("[ChatListCustomizer] ActionBar title hooks installed")
            else:
                log("[ChatListCustomizer] No ActionBar title methods hooked")
        except Exception as e:
            log(f"[ChatListCustomizer] Failed to setup ActionBar hooks: {e}")

    def _get_user_first_name(self):
        """Obtém o primeiro nome do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'first_name', None):
                    return str(user.first_name)
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleName", R.string.ActionBarTitleName))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _get_user_username(self):
        """Obtém o username do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'username', None):
                    username = str(user.username)

                    return f"@{username}" if not username.startswith("@") else username
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleUsername", R.string.ActionBarTitleUsername))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _handle_custom_name_change(self, value):
        """Lida com mudanças no nome customizado"""
        try:
            # Salvar o valor
            self.set_setting("custom_name", value)
            self._apply_settings()
            
            # Se o valor não está vazio, mostrar dialog de restart
            if value.strip():
                self._show_restart_dialog()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança de nome customizado: {e}")

    def _show_restart_dialog(self):
        """Mostra dialog perguntando se quer reiniciar o tg"""
        try:
            from ui.alert import AlertDialogBuilder
            from android.content import Intent
            from android.net import Uri
            from org.telegram.messenger import ApplicationLoader
            
            fragment = get_last_fragment()
            if not fragment:
                return
                
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            if not ctx:
                return
            
            def restart_telegram():
                try:
                    # Usar tg://restart para reiniciar
                    intent = Intent(Intent.ACTION_VIEW, Uri.parse("tg://restart"))
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    ctx.startActivity(intent)
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao reiniciar: {e}")
            
            def show_dialog():
                try:
                    builder = AlertDialogBuilder(ctx)
                    builder.set_title(tr("restart_required_title"))
                    builder.set_message(tr("restart_required_message"))
                    builder.set_positive_button(tr("restart_button"), lambda: restart_telegram())
                    builder.set_negative_button(tr("cancel_button"), None)
                    builder.show()
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao mostrar dialog: {e}")
            
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no dialog de restart: {e}")

    def _get_default_chat_list_title(self):
        """Obtém o título padrão da Chat List usando string do sistema"""
        try:
            # Usar string do sistema
            return str(LocaleController.getString("ListOfChats", R.string.ListOfChats))
        except Exception:
            return tr("default_title")

    def _get_display_name_by_option(self):
        """Obtém o nome baseado na opção selecionada"""
        try:
            name_option = self.get_setting("display_name_option", 0)
            
            if name_option == 0:  # Custom (agora é a primeira opção)
                custom_name = self.get_setting("custom_name", "").strip()
                if not custom_name:
                    # Se não há custom name, usar o texto padrão
                    return tr("default_custom_text")
                return custom_name
            elif name_option == 1:  # None
                return None
            elif name_option == 2:  # First Name
                return self._get_user_first_name()
            elif name_option == 3:  # Username
                return self._get_user_username()
            else:
                return tr("default_custom_text")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao obter display name: {e}")
            return tr("default_custom_text")

    def _get_time_based_greeting(self):
        """Retorna saudação baseada no horário atual"""
        try:
            hour = self._get_local_hour()
            
            if hour < 12:
                return tr("good_morning")
            elif hour < 18:
                return tr("good_afternoon")
            else:
                return tr("good_evening")
        except Exception:
            return tr("good_morning")

    # Smart Messages
    def _fetch_smart_messages(self):
        """Busca JSON remoto (raw) de frases curtas por período.
        Obs.: usamos um link raw e leitura direta do conteúdo.
        Cache simples em memória para reduzir chamadas.
        """
        try:
            # Reutiliza cache se já carregado
            cached = getattr(self, "_smart_messages_cache", None)
            if isinstance(cached, dict) and cached:
                return cached
            r = requests.get(SMART_MESSAGES_URL, timeout=10)
            if r.status_code != 200:
                raise Exception(f"HTTP {r.status_code}")
            data = r.json()
            # Guardar em cache
            self._smart_messages_cache = data
            return data
        except Exception as e:
            log(f"[ChatListCustomizer] Smart Messages fetch error: {e}")
            return None

    def _get_smart_phrase(self):
        """Retorna uma frase curta de acordo com o horário local e idioma atual.
        Períodos: morning (<12), afternoon (<18), evening (<23), night (>=23 ou <5).
        """
        try:
            data = self._fetch_smart_messages()
            if not isinstance(data, dict):
                return None
            # Idioma atual do app
            try:
                lang = str(LocaleController.getInstance().currentLocale.language)
            except Exception:
                lang = "en"
            if lang not in data:
                lang = "en"
            hour = self._get_local_hour()
            # Mapear período
            if hour < 12:
                bucket = "morning"
            elif hour < 18:
                bucket = "afternoon"
            elif hour < 23:
                bucket = "evening"
            else:
                bucket = "night"
            phrases = data.get(lang, {}).get(bucket, [])
            if not phrases:
                return None
            # Alternar frase de forma simples usando um índice cíclico
            idx = int(getattr(self, "_smart_phrase_index", 0)) % len(phrases)
            phrase = str(phrases[idx])
            # Avançar índice para próxima alternância
            self._smart_phrase_index = (idx + 1) % len(phrases)
            return phrase
        except Exception as e:
            log(f"[ChatListCustomizer] Smart phrase error: {e}")
            return None

    def _get_local_hour(self):
        """Obtém hora local conforme seleção de fuso horário"""
        try:
            sel = int(self.get_setting("timezone_selection", 0))
            if sel == 0:  # System Default
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 1:  # UTC
                cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 2:  # Europe/Moscow
                cal = Calendar.getInstance(TimeZone.getTimeZone("Europe/Moscow"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 3:  # America/Sao_Paulo
                cal = Calendar.getInstance(TimeZone.getTimeZone("America/Sao_Paulo"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 4:  # Custom Offset (horas)
                try:
                    # Base em UTC e aplica offset de horas
                    cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
                    hour = int(cal.get(Calendar.HOUR_OF_DAY))
                    off = int(self.get_setting("timezone_offset_hours", 0))
                    return (hour + off) % 24
                except Exception:
                    cal = Calendar.getInstance()
                    return int(cal.get(Calendar.HOUR_OF_DAY))
            else:
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
        except Exception:
            try:
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
            except Exception:
                return datetime.now().hour

    def _build_final_title(self):
        """Constrói título final baseado nas configurações"""
        try:
            # Now Playing: se ativado, tenta obter música atual do Stats.fm
            try:
                np_enabled = bool(self.get_setting("now_playing_enabled", False))
                # Seletor de provedor: 0=Stats.fm, 1=Last.fm
                provider = int(self.get_setting("now_playing_provider", 0))
                stats_user = str(self.get_setting("statsfm_username", "")).strip()
                last_user = str(self.get_setting("lastfm_username", "")).strip()
                last_key = str(self.get_setting("lastfm_api_key", "")).strip()
            except Exception:
                np_enabled, provider, stats_user, last_user, last_key = False, 0, "", "", ""

            if np_enabled:
                # Decide a fonte de dados (Stats.fm ou Last.fm)
                track = None
                if provider == 0 and stats_user:
                    track = self._get_statsfm_current_track(stats_user)
                elif provider == 1 and last_user and last_key:
                    track = self._get_lastfm_current_track(last_user, last_key)
                if track and track.get('title') and track.get('artist'):
                    style = int(self.get_setting("now_playing_style", 0))
                    song = str(track.get('title'))
                    artist = str(track.get('artist'))

                    # Sanitização opcional do título da música (Now Playing)
                    try:
                        if bool(self.get_setting("now_playing_filter_titles", True)):
                            song = self._sanitize_now_playing_title(song)
                    except Exception:
                        pass

                    # Implementar comportamentos por estilo
                    if style == 0:
                        # Padrão: alterna entre música e artista (sem marquee)
                        tgl = 0
                        try:
                            tgl = int(getattr(self, "_np_toggle_state", 0))
                        except Exception:
                            tgl = 0
                        return song if tgl == 0 else artist
                    elif style == 1:
                        # Digitando: digita a música até completar, depois digita o artista
                        try:
                            prev_song = str(getattr(self, "_typing_prev_song", ""))
                            prev_artist = str(getattr(self, "_typing_prev_artist", ""))
                        except Exception:
                            prev_song, prev_artist = "", ""
                        # Reiniciar fases se a faixa mudou
                        if song != prev_song or artist != prev_artist:
                            self._typing_phase = 0
                            self._typing_index = 0
                            self._typing_prev_song = song
                            self._typing_prev_artist = artist
                        try:
                            phase = int(getattr(self, "_typing_phase", 0))  # 0 = música, 1 = artista
                        except Exception:
                            phase = 0
                        try:
                            idx = int(getattr(self, "_typing_index", 0))
                        except Exception:
                            idx = 0
                        source = song if phase == 0 else artist
                        # Garantir limite e avançar
                        if idx < len(source):
                            fragment = source[:max(1, idx + 1)]
                            self._typing_index = idx + 1
                            return fragment
                        else:
                            # Trocar fase quando completar e reiniciar índice
                            self._typing_phase = 1 if phase == 0 else 0
                            self._typing_index = 0
                            # Retornar pelo menos primeiro caractere da próxima fonte
                            next_source = song if self._typing_phase == 0 else artist
                            return next_source[:1] if next_source else ""
                    elif style == 2:
                        # Somente Música: mostrar apenas o título
                        return song

            display_name = self._get_display_name_by_option()
            enable_greeting = self.get_setting("enable_greeting", False)
            # Smart Messages selector: 0=Ativar, 1=Desativar
            smart_sel = int(self.get_setting("smart_messages_enabled", 1))
            smart_on = (smart_sel == 0)

            # Quando saudação está ativa, alternar com Smart Messages se habilitado
            if enable_greeting:
                # Alternância: saudação vs frase curta conforme toggle
                toggle = int(getattr(self, "_smart_toggle_state", 0))
                if smart_on and toggle == 1:
                    phrase = self._get_smart_phrase()
                    if phrase:
                        return phrase
                # Fallback para saudação padrão
                greeting = self._get_time_based_greeting()
                if display_name is None:
                    return f"{greeting}!"
                else:
                    return f"{greeting}, {display_name}!"
            else:
                # Sem saudação: respeitar escolha de nome
                if display_name is None:
                    return None
                return display_name
        except Exception as e:
            log(f"[ChatListCustomizer] Error building title: {e}")
            return None

    def _sanitize_now_playing_title(self, title: str) -> str:
        """Remove conteúdo entre parênteses e qualquer sufixo de 'feat./ft./featuring'."""
        try:
            import re
            t = str(title or "")
            # Remover conteúdo entre parênteses, múltiplas ocorrências
            t = re.sub(r"\([^\)]*\)", "", t)
            # Remover sufixos de feat/ft/featuring e tudo depois disso
            t = re.sub(r"\b(feat(?:uring)?|ft)\b\.?\s*.*$", "", t, flags=re.IGNORECASE)
            # Limpar separadores residuais no fim
            t = re.sub(r"[\-–|•\/]+\s*$", "", t)
            # Normalizar espaços
            t = re.sub(r"\s+", " ", t).strip()
            return t
        except Exception:
            return str(title or "")

    def _get_statsfm_current_track(self, username):
        """Consulta a API do Stats.fm e retorna a música atual.
        Retorna dict com 'title' e 'artist' quando estiver tocando; caso contrário, None.
        """
        try:
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "ChatListCustomizer/1.0"
            }
            data = None
            try:
                import requests
                resp = requests.get(url, headers=headers, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                else:
                    return None
            except Exception:
                # Fallback mínimo usando Java URLConnection (ambiente Android)
                try:
                    import json
                    from java.net import URL
                    u = URL(url)
                    con = u.openConnection()
                    con.setRequestProperty("Accept", "application/json")
                    con.setRequestProperty("User-Agent", "ChatListCustomizer/1.0")
                    con.setConnectTimeout(5000)
                    con.setReadTimeout(5000)
                    stream = con.getInputStream()
                    try:
                        from java.io import BufferedReader, InputStreamReader
                        reader = BufferedReader(InputStreamReader(stream))
                        sb = []
                        line = reader.readLine()
                        while line is not None:
                            sb.append(line)
                            line = reader.readLine()
                        reader.close()
                        raw = "".join(sb)
                        data = json.loads(raw)
                    finally:
                        stream.close()
                except Exception as e2:
                    log(f"[ChatListCustomizer] Stats.fm fallback error: {str(e2)}")
                    return None

            try:
                item = data.get("item") if isinstance(data, dict) else None
                if item and item.get("isPlaying"):
                    track_info = item.get("track", {})
                    # Extrair nomes dos artistas
                    artists_raw = track_info.get("artists", [])
                    artists = []
                    try:
                        artists = [a.get("name", "") for a in artists_raw]
                    except Exception:
                        pass
                    # Limitar a 1-2 artistas para evitar listas longas (feat.)
                    artists = [s for s in artists if s][:2]
                    title = track_info.get("name", "")
                    artist = ", ".join(artists)
                    if title and artist:
                        return { 'title': title, 'artist': artist }
            except Exception as e3:
                log(f"[ChatListCustomizer] Stats.fm parse error: {str(e3)}")
                return None

            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Stats.fm error: {str(e)}")
            return None

    def _get_lastfm_current_track(self, username, api_key):
        """Consulta a API do Last.fm e retorna a música atual.
        Retorna dict com 'title' e 'artist' quando estiver tocando; caso contrário, None.
        Observação: a API do Last.fm requer API Key.
        """
        try:
            if not username or not api_key:
                return None
            # Endpoint para obter faixa recente e verificar se está tocando agora
            url = (
                "https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks"
                f"&user={username}&api_key={api_key}&format=json&limit=1"
            )
            headers = {
                "Accept": "application/json",
                "User-Agent": "ChatListCustomizer/1.0"
            }
            data = None
            try:
                import requests
                resp = requests.get(url, headers=headers, timeout=5)
                if resp.status_code == 200:
                    data = resp.json()
                else:
                    log(f"[ChatListCustomizer] Last.fm HTTP {resp.status_code}")
            except Exception as e:
                log(f"[ChatListCustomizer] Last.fm request error: {str(e)}")
                return None

            if not data:
                return None

            try:
                recent = data.get("recenttracks", {})
                tracks = recent.get("track", [])
                # Quando limit=1, 'track' pode ser dict ou lista com um item
                item = None
                if isinstance(tracks, list):
                    item = tracks[0] if tracks else None
                elif isinstance(tracks, dict):
                    item = tracks
                if not item:
                    return None

                # Verificar se está tocando agora via atributo @attr.nowplaying
                attrs = item.get("@attr", {}) if isinstance(item, dict) else {}
                is_playing = False
                try:
                    is_playing = bool(attrs.get("nowplaying", False))
                except Exception:
                    is_playing = False
                if not is_playing:
                    return None

                # Extrair título e artista, limitando artistas
                title = str(item.get("name", ""))
                artist_obj = item.get("artist", {})
                artist_name = ""
                try:
                    artist_name = str(artist_obj.get("#text", ""))
                except Exception:
                    artist_name = ""

                artists = []
                if artist_name:
                    # Last.fm geralmente retorna um único artista; manter o nome
                    artists = [artist_name]
                # Limitar a 1–2 artistas por legibilidade
                artists = [s for s in artists if s][:2]
                artist = ", ".join(artists)

                if title and artist:
                    return { 'title': title, 'artist': artist }
            except Exception as e3:
                log(f"[ChatListCustomizer] Last.fm parse error: {str(e3)}")
                return None

            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Last.fm error: {str(e)}")
            return None

    def _set_chat_list_title(self, title):
        """Aplica título personalizado na Chat List"""
        try:
            log(f"[ChatListCustomizer] Tentando aplicar título: {title}")
            fragment = get_last_fragment()
            log(f"[ChatListCustomizer] Fragment obtido: {fragment}")
            
            if fragment:
                fragment_name = fragment.getClass().getName()
                log(f"[ChatListCustomizer] Fragment name: {fragment_name}")
                
                if "DialogsActivity" in fragment_name:
                    action_bar = fragment.getActionBar()
                    log(f"[ChatListCustomizer] ActionBar obtido: {action_bar}")
                    
                    if action_bar:
                        def apply_title():
                            try:
                                # Primeiro tentar TextView do título
                                try:
                                    title_view = action_bar.getTitleTextView()
                                    if title_view:
                                        title_view.setText(title)
                                        try:
                                            # Aplicar estilo visual do título (badge/shape)
                                            style_idx = int(self.get_setting("title_style", 0))
                                            if style_idx == 1:
                                                from android.graphics.drawable import GradientDrawable
                                                shape = GradientDrawable()
                                                shape.setColor(0x66000000)
                                                shape.setCornerRadius(float(AndroidUtilities.dp(8)))
                                                title_view.setBackground(shape)
                                                pad_h = int(AndroidUtilities.dp(8))
                                                pad_v = int(AndroidUtilities.dp(4))
                                                title_view.setPadding(pad_h, pad_v, pad_h, pad_v)
                                            else:
                                                try:
                                                    title_view.setBackground(None)
                                                except Exception:
                                                    pass
                                                title_view.setPadding(0, 0, 0, 0)
                                            # Configuração padrão de elipsização (sem rolamento)
                                            try:
                                                from android.text import TextUtils
                                                # SimpleTextView não possui setSingleLine; usar setMaxLines(1)
                                                title_view.setMaxLines(1)
                                                title_view.setHorizontallyScrolling(False)
                                                title_view.setEllipsize(TextUtils.TruncateAt.END)
                                                title_view.setMarqueeRepeatLimit(0)
                                            except Exception as e3:
                                                log(f"[ChatListCustomizer] Ellipsize setup failed: {e3}")
                                        except Exception as e2:
                                            log(f"[ChatListCustomizer] Title style apply failed: {e2}")
                                        log(f"[ChatListCustomizer] Título aplicado via TextView: {title}")
                                        return
                                except Exception as e:
                                    log(f"[ChatListCustomizer] TextView falhou: {e}")
                                
                                # Fallback para setTitle diretamente
                                action_bar.setTitle(title)
                                log(f"[ChatListCustomizer] Título aplicado via ActionBar: {title}")
                                
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")
                        
                        run_on_ui_thread(apply_title)
                        log(f"[ChatListCustomizer] Comando de aplicação enviado: {title}")
                    else:
                        log("[ChatListCustomizer] ActionBar é None!")
                else:
                    log(f"[ChatListCustomizer] Fragment não é DialogsActivity: {fragment_name}")
            else:
                log("[ChatListCustomizer] Fragment é None!")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")

    def _restore_chat_list_title(self):
        """Restaura o título original usando strings do sistema"""
        try:
            orig = self.get_setting("_original_title", "")
            if not orig:
                # Usar string do sistema como fallback
                orig = self._get_default_chat_list_title()
            self._set_chat_list_title(orig)
            log(f"[ChatListCustomizer] Título original restaurado: {orig}")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao restaurar título: {e}")

    def _toggle_customizer(self, should_be_active):
        """Ativa/desativa o customizador do título baseado se há algo para mostrar"""
        try:
            log(f"[ChatListCustomizer] Toggle customizer: {should_be_active}")
            
            if should_be_active:
                # Capturar título original quando habilitar
                try:
                    fragment = get_last_fragment()
                    if fragment and "DialogsActivity" in fragment.getClass().getName():
                        action_bar = fragment.getActionBar()
                        if action_bar and not self.get_setting("_original_title", ""):
                            try:
                                current_title = str(action_bar.getTitle())
                                if current_title:
                                    self.set_setting("_original_title", current_title)
                                    log(f"[ChatListCustomizer] Título original capturado: {current_title}")
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao capturar título: {e}")
                except Exception:
                    pass
                
                # Aplicar título customizado imediatamente
                final_title = self._build_final_title()
                if final_title:
                    self._set_chat_list_title(final_title)
                
                # Iniciar worker de refresh periódico (15s)
                self._start_refresh_worker(15)
                    
            else:
                # Parar worker e restaurar título original quando desabilitar
                self._stop_refresh_worker()
                self._restore_chat_list_title()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no toggle: {e}")

    def _apply_settings(self):
        """Aplica configurações - chamado quando algo muda"""
        try:
            # Verificar se deve estar ativo baseado se há algo para mostrar
            final_title = self._build_final_title()
            # Forçar ativação quando Now Playing estiver habilitado e configurado
            try:
                np_enabled = bool(self.get_setting("now_playing_enabled", False))
                provider = int(self.get_setting("now_playing_provider", 0))
                stats_user = str(self.get_setting("statsfm_username", "")).strip()
                last_user = str(self.get_setting("lastfm_username", "")).strip()
                last_key = str(self.get_setting("lastfm_api_key", "")).strip()
                np_configured = (provider == 0 and bool(stats_user)) or (provider == 1 and bool(last_user) and bool(last_key))
            except Exception:
                np_enabled, np_configured = False, False
            should_be_active = (final_title is not None) or (np_enabled and np_configured)
            
            log(f"[ChatListCustomizer] Should be active: {should_be_active}, final_title: {final_title}")
            self._toggle_customizer(should_be_active)
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar configurações: {e}")
    
    def _start_refresh_worker(self, interval_sec=15):
        """Inicia worker de refresh periódico"""
        try:
            # Parar worker anterior
            self._stop_refresh_worker()
            
            import threading
            import time
            
            stop_event = threading.Event()
            self._refresh_worker_stop = stop_event
            
            def _run():
                try:
                    while not stop_event.is_set():
                        # Alternar estado de Now Playing apenas para estilos que alternam
                        try:
                            np_style = int(self.get_setting("now_playing_style", 0))
                            if np_style == 0:
                                current = int(getattr(self, "_np_toggle_state", 0))
                                self._np_toggle_state = 1 if current == 0 else 0
                            else:
                                # Reset alternância para estilos que não alternam
                                self._np_toggle_state = 0
                        except Exception:
                            self._np_toggle_state = 0
                        # Alternância de Smart Messages: 0/1 para alternar entre saudação e frase
                        try:
                            sel = int(self.get_setting("smart_messages_enabled", 1))
                            if sel == 0:  # Ativado
                                s_cur = int(getattr(self, "_smart_toggle_state", 0))
                                self._smart_toggle_state = 1 if s_cur == 0 else 0
                            else:
                                self._smart_toggle_state = 0
                        except Exception:
                            self._smart_toggle_state = 0
                        # Verificar se deve aplicar título baseado se há algo para mostrar
                        final_title = self._build_final_title()
                        should_be_active = final_title is not None
                        
                        if should_be_active:
                            # Tentar aplicar título
                            fragment = get_last_fragment()
                            if fragment and "DialogsActivity" in fragment.getClass().getName():
                                # Verificar título atual
                                action_bar = fragment.getActionBar()
                                if action_bar:
                                    try:
                                        current_title = str(action_bar.getTitle())
                                        # Aplicar baseado na configuração Fix Title
                                        fix_title = self.get_setting("fix_title", False)
                                        if fix_title or current_title != final_title:
                                            self._set_chat_list_title(final_title)
                                            if fix_title:
                                                log(f"[ChatListCustomizer] Título fixado aplicado: {final_title}")
                                    except Exception:
                                        self._set_chat_list_title(final_title)
                        
                        # Aguardar próximo ciclo (suporta sub-segundos para estilo Digitando)
                        try:
                            fix_title = self.get_setting("fix_title", False)
                            np_enabled = bool(self.get_setting("now_playing_enabled", False))
                            np_style = int(self.get_setting("now_playing_style", 0))
                            # Intervalo base
                            base_secs = float(interval_sec) if interval_sec and interval_sec > 0 else 15.0
                            if np_enabled:
                                base_secs = 5.0
                            # Ajustar por fix_title
                            cycle_secs = 3.0 if fix_title else base_secs
                            # Estilo Digitando usa intervalo curto para efeito de digitação
                            if np_style == 1:
                                cycle_secs = 0.06
                            # Espera com possibilidade de interrupção
                            if stop_event.wait(cycle_secs):
                                break
                        except Exception:
                            if stop_event.wait(15.0):
                                break
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro no worker: {e}")
            
            t = threading.Thread(target=_run, name="ChatListCustomizerRefresh", daemon=True)
            self._refresh_worker_thread = t
            t.start()
            

            fix_title = self.get_setting("fix_title", False)
            if fix_title:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo fixo - 3s)")
            else:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo normal - 15s)")
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao iniciar worker: {e}")

    def _stop_refresh_worker(self):
        """Para o worker de refresh"" CÓPIA EXATA do nowfy.plugin"""
        try:
            if self._refresh_worker_stop:
                self._refresh_worker_stop.set()
                self._refresh_worker_stop = None
            
            if self._refresh_worker_thread:
                self._refresh_worker_thread = None
                
            log("[ChatListCustomizer] Worker de refresh parado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao parar worker: {e}")

    def create_settings(self):
        """Cria interface de configurações do plugin"""
        try:
            settings = []
            
            # Seção de Configurações de Exibição
            settings.append(Divider(text=tr("display_settings_section")))
            settings.append(Selector(
                key="display_name_option",
                text=tr("display_name_option"),
                default=self.get_setting("display_name_option", 0),
                items=[
                    tr("name_option_custom"),
                    tr("name_option_none"),
                    tr("name_option_my_name"),
                    tr("name_option_my_username")
                ],
                icon="msg_filled_menu_users",
                on_change=lambda v: (
                    self.set_setting("display_name_option", int(v)),
                    self._apply_settings(),
                    # Só mostrar restart se não for "Custom" (opção 0) e não for "None" (opção 1)
                    self._show_restart_dialog() if int(v) != 0 and int(v) != 1 else None,
                    self.reload_settings()
                )
            ))
            

            if self.get_setting("display_name_option", 0) == 0:  # Custom option (agora é a primeira)
                settings.append(Input(
                    key="custom_name",
                    text=tr("custom_name_input"),
                    subtext=tr("custom_name_desc"),
                    default=self.get_setting("custom_name", tr("default_custom_text")),
                    icon="msg_edit",
                    on_change=lambda v: self._handle_custom_name_change(str(v))
                ))
            
            # Seção de Configurações de Saudação
            settings.append(Divider(text=tr("greeting_settings_section")))
            settings.append(Switch(
                key="enable_greeting",
                text=tr("enable_greeting"),
                subtext=tr("enable_greeting_desc"),
                default=self.get_setting("enable_greeting", False),
                icon="menu_feature_status",
                on_change=lambda v: (
                    self.set_setting("enable_greeting", bool(v)),
                    self._apply_settings(),
                    self._show_restart_dialog(),
                    self.reload_settings()
                )
            ))
            # Smart Messages: selector após "Enable Greeting" (sem subtext)
            settings.append(Selector(
                key="smart_messages_enabled",
                text=tr("smart_messages_label"),
                default=self.get_setting("smart_messages_enabled", 1),
                items=[
                    tr("smart_messages_activate"),
                    tr("smart_messages_deactivate")
                ],
                icon="input_message",
                on_change=lambda v: (
                    self.set_setting("smart_messages_enabled", int(v)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))
            
            # Now Playing: novo divider e switch que expande para username e estilo
            settings.append(Divider(text=tr("now_playing_section")))
            settings.append(Switch(
                key="now_playing_enabled",
                text=tr("now_playing_label"),
                default=self.get_setting("now_playing_enabled", False),
                icon="filled_widget_music",
                on_change=lambda v: (
                    self.set_setting("now_playing_enabled", bool(v)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))
            if bool(self.get_setting("now_playing_enabled", False)):
                # Divisor: Fonte
                settings.append(Divider(text=tr("now_playing_divider_source")))
                # Seletor de provedor (sem subtext em selector)
                settings.append(Selector(
                    key="now_playing_provider",
                    text=tr("now_playing_provider_label"),
                    default=self.get_setting("now_playing_provider", 0),
                    items=[
                        tr("provider_statsfm"),
                        tr("provider_lastfm")
                    ],
                    icon="msg_noise_on_solar",
                    on_change=lambda v: (
                        self.set_setting("now_playing_provider", int(v)),
                        self._apply_settings(),
                        self.reload_settings()
                    )
                ))
                prov = int(self.get_setting("now_playing_provider", 0))
                # Divisor: Credenciais
                settings.append(Divider(text=tr("now_playing_divider_credentials")))
                if prov == 0:
                    # Stats.fm: solicitar somente username
                    settings.append(Input(
                        key="statsfm_username",
                        text=tr("statsfm_username_label"),
                        default=self.get_setting("statsfm_username", ""),
                        icon="menu_username_change",
                        on_change=lambda v: (
                            self.set_setting("statsfm_username", str(v).strip()),
                            self._apply_settings()
                        )
                    ))
                else:
                    # Last.fm: solicitar username e API key
                    settings.append(Input(
                        key="lastfm_username",
                        text=tr("lastfm_username_label"),
                        default=self.get_setting("lastfm_username", ""),
                        icon="menu_username_change",
                        on_change=lambda v: (
                            self.set_setting("lastfm_username", str(v).strip()),
                            self._apply_settings()
                        )
                    ))
                    # Selector que controla apenas a visibilidade do campo de API Key
                    settings.append(Selector(
                        key="api_key_visibility",
                        text=tr("api_key_selector_label"),
                        default=self.get_setting("api_key_visibility", 0),
                        items=[
                            tr("api_key_option_show"),
                            tr("api_key_option_hide")
                        ],
                        icon="msg2_proxy_on",
                        on_change=lambda v: (
                            self.set_setting("api_key_visibility", int(v)),
                            self.reload_settings()
                        )
                    ))
                    # Mostrar campo API Key apenas se visibilidade = Exibir
                    if int(self.get_setting("api_key_visibility", 0)) == 0:
                        settings.append(Input(
                            key="lastfm_api_key",
                            text=tr("lastfm_api_key_label"),
                            default=self.get_setting("lastfm_api_key", ""),
                            icon="msg2_permissions",
                            on_change=lambda v: (
                                self.set_setting("lastfm_api_key", str(v).strip()),
                                self._apply_settings()
                            )
                        ))
                # Divisor: Estilo
                settings.append(Selector(
                    key="now_playing_style",
                    text=tr("now_playing_style_label"),
                    default=self.get_setting("now_playing_style", 0),
                    items=[
                        tr("now_playing_style_single"),
                        tr("now_playing_style_typing"),
                        tr("now_playing_style_music_only")
                    ],
                    icon="msg_theme_remix",
                    on_change=lambda v: (
                        self.set_setting("now_playing_style", int(v)),
                        self._apply_settings()
                    )
                ))
            # Configurações de fuso horário
            settings.append(Divider(text=tr("time_settings_section")))
            settings.append(Selector(
                key="timezone_selection",
                text=tr("timezone_label"),
                default=self.get_setting("timezone_selection", 0),
                items=[
                    tr("timezone_system"),
                    tr("timezone_utc"),
                    tr("timezone_moscow"),
                    tr("timezone_sao_paulo"),
                    tr("timezone_custom_offset")
                ],
                icon="menu_premium_clock",
                on_change=lambda v: (
                    self.set_setting("timezone_selection", int(v)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))
            # Mostrar seletor de offset quando Custom Offset estiver selecionado
            if int(self.get_setting("timezone_selection", 0)) == 4:
                # Lista de offsets de -12 a +14
                offset_items = []
                for h in range(-12, 15):
                    label = f"UTC{h:+d}"
                    offset_items.append(label)
                current_off = int(self.get_setting("timezone_offset_hours", 0))
                current_index = current_off + 12  # map -12..+14 to 0..26
                settings.append(Selector(
                    key="timezone_offset_hours",
                    text=tr("timezone_offset_label"),
                    default=current_index,
                    items=offset_items,
                    icon="filled_premium_hours",
                    on_change=lambda idx: (
                        self.set_setting("timezone_offset_hours", int(idx) - 12),
                        self._apply_settings(),
                        self.reload_settings()
                    )
                ))
                
            # Separador e link para Opções Avançadas em subfragmento
            settings.append(Divider(text=tr("advanced_settings_section")))
            settings.append(Text(
                text=tr("advanced_settings_link"),
                icon="msg_settings",
                # Abre página secundária de configurações avançadas
                create_sub_fragment=self._create_advanced_subfragment
            ))
            
            settings.append(Divider())
            settings.append(Text(
                text=tr("credits") if "credits" in TRANSLATIONS else "Dotted Plugins",
                icon="etg_settings",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
            ))
            
            return settings
            
        except Exception as e:
            log(f"[ChatListCustomizer] Error creating settings: {e}")
            return [
                Header(text="ChatList Customizer"),
                Text(text=(tr("error_loading_settings") if "error_loading_settings" in TRANSLATIONS else "Error loading settings") + f": {e}")
            ]

    def _create_advanced_subfragment(self, parent_view=None):
        """Cria subfragmento de Opções Avançadas"""
        try:
            advanced = []

            # Seção de Aparência
            advanced.append(Divider(text=tr("appearance_section")))
            advanced.append(Selector(
                key="title_style",
                text=tr("title_style"),
                # Obs.: 0 = sem shape, 1 = shape escuro arredondado
                default=self.get_setting("title_style", 0),
                items=[
                    tr("title_style_none"),
                    tr("title_style_dark"),
                ],
                icon="msg_channel_14_solar",
                on_change=lambda idx: (
                    self.set_setting("title_style", int(idx)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))

            # Seção de Comportamento
            advanced.append(Divider(text=tr("behavior_section")))
            advanced.append(Switch(
                key="fix_title",
                text=tr("fix_title"),
                subtext=tr("fix_title_desc"),
                default=self.get_setting("fix_title", False),
                icon="msg_pin",
                # Ao alterar, aplicar e sugerir reinício
                on_change=lambda v: (
                    self.set_setting("fix_title", bool(v)),
                    self._apply_settings(),
                    self._show_restart_dialog(),
                    self.reload_settings()
                )
            ))

            # Filtro de títulos para Now Playing
            advanced.append(Switch(
                key="now_playing_filter_titles",
                text=tr("now_playing_filter_titles_label"),
                subtext=tr("now_playing_filter_titles_desc"),
                default=self.get_setting("now_playing_filter_titles", True),
                icon="filled_widget_music",
                on_change=lambda v: (
                    self.set_setting("now_playing_filter_titles", bool(v)),
                    self._apply_settings()
                )
            ))

            return advanced
        except Exception as e:
            log(f"[ChatListCustomizer] Erro criando subfragmento avançado: {e}")
            return [
                Header(text=tr("advanced_settings_page")),
                Text(text=f"Erro: {e}")
            ]

    def on_plugin_loaded(self):
        """Executado quando o plugin é carregado"""
        try:
            global _LANG
            _LANG = _detect_lang()
            log(f"[ChatListCustomizer] Plugin loaded with language: {_LANG}")
            
            # Definir texto padrão se não existir
            if not self.get_setting("custom_name", ""):
                self.set_setting("custom_name", tr("default_custom_text"))
            
            # Aplicar configurações e iniciar worker para manter ativo mesmo após reinícios
            self._apply_settings()
            try:
                self._start_refresh_worker(15)
                log("[ChatListCustomizer] Refresh worker bootstrapped on load")
            except Exception as e:
                log(f"[ChatListCustomizer] Error bootstrapping worker: {e}")
            # Instalar hooks do ActionBar para forçar título
            try:
                self._setup_actionbar_hooks()
            except Exception as e:
                log(f"[ChatListCustomizer] Error setting up hooks: {e}")
        
        except Exception as e:
            log(f"[ChatListCustomizer] Error during load: {e}")

    def on_plugin_unloaded(self):
        """Executado quando o plugin é descarregado"""
        try:
            log("[ChatListCustomizer] Unloading plugin...")
            # Parar worker e restaurar título
            self._stop_refresh_worker()
            self._restore_chat_list_title()
            # Remover hooks
            try:
                if self._hook_set_title_ref:
                    self.unhook_method(self._hook_set_title_ref)
                    self._hook_set_title_ref = None
                if self._hook_set_title_anim_ref:
                    self.unhook_method(self._hook_set_title_anim_ref)
                    self._hook_set_title_anim_ref = None
            except Exception as e:
                log(f"[ChatListCustomizer] Error removing hooks: {e}")
            log("[ChatListCustomizer] Plugin descarregado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no descarregamento: {e}")

    # Compatibilidade com nomenclatura alternativa do engine
    def on_plugin_load(self):
        try:
            self.on_plugin_loaded()
        except Exception as e:
            log(f"[ChatListCustomizer] Error in on_plugin_load: {e}")

    def on_plugin_unload(self):
        try:
            self.on_plugin_unloaded()
        except Exception as e:
            log(f"[ChatListCustomizer] Error in on_plugin_unload: {e}")


class _ActionBarTitleHook:
    """Hook para forçar o título da ActionBar em DialogsActivity/FilterChatlistActivity"""
    def __init__(self, plugin: ChatListCustomizerPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        # Não precisamos alterar argumentos antes da chamada
        pass

    def after_hooked_method(self, param):
        try:
            # Evitar recursão ao definir título dentro do hook
            if getattr(self.plugin, "_is_setting_title", False):
                return

            fragment = get_last_fragment()
            if not fragment:
                return
            fragment_name = fragment.getClass().getName()
            if ("DialogsActivity" not in fragment_name) and ("FilterChatlistActivity" not in fragment_name):
                return

            final_title = self.plugin._build_final_title()
            if final_title is None:
                return

            self.plugin._is_setting_title = True
            try:
                action_bar = fragment.getActionBar()
                if action_bar:
                    try:
                        title_view = action_bar.getTitleTextView()
                        if title_view:
                            title_view.setText(final_title)
                        else:
                            action_bar.setTitle(final_title)
                    except Exception:
                        action_bar.setTitle(final_title)
            except Exception as e:
                log(f"[ChatListCustomizer] Hook apply error: {e}")
            finally:
                self.plugin._is_setting_title = False
        except Exception as e:
            log(f"[ChatListCustomizer] Hook error: {e}")