import json
from markdown_utils import parse_markdown
import os
import time
from typing import Any, Dict, Optional, List

from android_utils import log
from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_user_config, get_account_instance, run_on_queue, send_message
from ui.bulletin import BulletinHelper
from org.telegram.tgnet import TLRPC
from java.net import URL
from java.io import BufferedReader, InputStreamReader, OutputStreamWriter

__id__ = "webgotchi"
__name__ = "webgotchi"
__description__ = "Something about .t commands and virtual pets"
__author__ = "@koshbko"
__version__ = "release"
__icon__ = "AndergraundDolbayobov/62"
__min_version__ = "11.9.0"


class TamagotchiApiPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.api_base_url = "http://46.181.21.204:2028" 
        self._cache: Dict[str, Any] = {}
        self._cache_timeout = 300

    def on_plugin_load(self):
        try:
            self.add_on_send_message_hook()
        except Exception as e:
            self.log(f"Failed to add on_send_message_hook: {e}")
        try:
            self.add_hook("TL_messages_sendMessage", match_substring=False, priority=0)
        except Exception as e:
            self.log(f"add_hook failed: {e}")

    def _get_telegram_id(self, account: int) -> str:
        try:
            user_config = get_user_config()
            if user_config and hasattr(user_config, 'getCurrentUser'):
                user = user_config.getCurrentUser()
                if user and hasattr(user, 'id'):
                    return str(user.id)
        except Exception as e:
            self.log(f"get telegram id error: {e}")
        return str(account)

    def _send_message(self, peer_id: int, message: str):
        try:
            params = {
                "peer": peer_id,
                "message": None,
                "entities": []
            }
            try:
                parsed = parse_markdown(message)
                params["message"] = parsed.text
                params["entities"] = [e.to_tlrpc_object() for e in getattr(parsed, "entities", [])]
            except Exception as e:
                self.log(f"Markdown parse error: {e}")
                params["message"] = message
            send_message(params)
            self.log(f"Sent message to peer {peer_id}: {params['message'][:50]}...")
        except Exception as e:
            self.log(f"Error sending message: {e}")

    def _show_bulletin_error(self, message: str):
        try:
            BulletinHelper.show_error(message)
        except Exception as e:
            self.log(f"Failed to show bulletin error: {e}")

    def _show_bulletin_success(self, message: str):
        try:
            BulletinHelper.show_success(message)
        except Exception as e:
            self.log(f"Failed to show bulletin success: {e}")

    def _http(self, method: str, path: str, body: Optional[Dict] = None) -> Any:
        try:
            url = URL(f"{self.api_base_url}{path}")
            conn = url.openConnection()
            conn.setRequestMethod(method)
            conn.setRequestProperty("Content-Type", "application/json")
            conn.setConnectTimeout(10000)
            conn.setReadTimeout(15000)
            
            if method in ("POST", "PUT") and body is not None:
                conn.setDoOutput(True)
                writer = OutputStreamWriter(conn.getOutputStream(), "UTF-8")
                writer.write(json.dumps(body))
                writer.close()
            
            code = conn.getResponseCode()
            self.log(f"HTTP {method} {path} -> {code}")
            
            if 200 <= code < 300:
                reader = BufferedReader(InputStreamReader(conn.getInputStream(), "UTF-8"))
                buf = []
                line = reader.readLine()
                while line is not None:
                    buf.append(line)
                    line = reader.readLine()
                reader.close()
                text = "\n".join(buf).strip()
                return json.loads(text) if text else {}
            else:
                try:
                    error_reader = BufferedReader(InputStreamReader(conn.getErrorStream(), "UTF-8"))
                    error_buf = []
                    error_line = error_reader.readLine()
                    while error_line is not None:
                        error_buf.append(error_line)
                        error_line = error_reader.readLine()
                    error_reader.close()
                    error_text = "\n".join(error_buf).strip()
                    self.log(f"HTTP error response: {error_text}")
                except:
                    pass
                return {"error": f"HTTP {code}", "status_code": code}
        except Exception as e:
            self.log(f"http error {method} {path}: {e}")
            return {"error": str(e), "status_code": 0}

    def _ensure_user(self, telegram_id: str) -> bool:
        try:
            user_config = get_user_config()
            username = None
            if user_config and hasattr(user_config, 'getCurrentUser'):
                user = user_config.getCurrentUser()
                if user:
                    if hasattr(user, 'username') and user.username:
                        username = user.username
                        self.log(f"Got username: {username}")
                    else:
                        name_parts = []
                        if hasattr(user, 'first_name') and user.first_name:
                            name_parts.append(user.first_name)
                        if hasattr(user, 'last_name') and user.last_name:
                            name_parts.append(user.last_name)
                        if name_parts:
                            username = ' '.join(name_parts)
                            self.log(f"Using display name as fallback: {username}")
                        else:
                            username = None
            user_data = {"telegram_id": telegram_id, "username": username}
            result = self._http("POST", "/api/users", user_data)
            return result is not None and not (isinstance(result, dict) and result.get("error"))
        except Exception as e:
            self.log(f"Failed to ensure user {telegram_id}: {e}")
            return False

    def _get_pet(self, telegram_id: str) -> Optional[Dict]:
        cached = self._cache.get(telegram_id)
        if cached and (time.time() - cached[1] < self._cache_timeout):
            return cached[0]
        username = self._get_username()
        url = f"/api/users/{telegram_id}/pet"
        if username:
            from urllib.parse import quote
            url += f"?username={quote(username)}"
        data = self._http("GET", url)
        if data is not None and not (isinstance(data, dict) and data.get("error")):
            self._cache[telegram_id] = (data, time.time())
        return data

    def _update_pet(self, telegram_id: str, updates: Dict[str, Any]) -> Optional[Dict]:
        username = self._get_username()
        url = f"/api/users/{telegram_id}/pet"
        if username:
            from urllib.parse import quote
            url += f"?username={quote(username)}"
        data = self._http("PUT", url, updates)
        if data is not None and not (isinstance(data, dict) and data.get("error")):
            self._cache[telegram_id] = (data, time.time())
            self.log(f"Updated pet for user {telegram_id}: {updates}")
        else:
            self.log(f"Failed to update pet for user {telegram_id}")
        return data
    def _get_username(self) -> Optional[str]:
        try:
            user_config = get_user_config()
            if user_config and hasattr(user_config, 'getCurrentUser'):
                user = user_config.getCurrentUser()
                if user:
                    if hasattr(user, 'username') and user.username:
                        return user.username
                    name_parts = []
                    if hasattr(user, 'first_name') and user.first_name:
                        name_parts.append(user.first_name)
                    if hasattr(user, 'last_name') and user.last_name:
                        name_parts.append(user.last_name)
                    if name_parts:
                        return ' '.join(name_parts)
        except Exception as e:
            self.log(f"get_username error: {e}")
        return None

    def _get_top_pets(self, limit: int = 10) -> Optional[List[Dict]]:
        data = self._http("GET", f"/api/pets/top?limit={limit}")
        self.log(f"Top pets raw data: {type(data)} - {str(data)[:200]}...")
        
        if data is None:
            return None
            
        if isinstance(data, list):
            return data
            
        if isinstance(data, dict) and data.get("error"):
            self.log(f"Error in top pets response: {data.get('error')}")
            return None
            
        if isinstance(data, dict) and 'pets' in data:
            return data['pets']
            
        self.log(f"Unexpected top pets data format: {type(data)} - {data}")
        return None

    def _ensure_pet(self, telegram_id: str) -> Optional[Dict]:
        if not self._ensure_user(telegram_id):
            self.log(f"Failed to ensure user {telegram_id} exists")
            return None
        
        pet = self._get_pet(telegram_id)
        if pet is not None and not (isinstance(pet, dict) and pet.get("error")):
            return pet
        
        self.log(f"Pet not found for user {telegram_id}, backend will create it")
        time.sleep(1)
        pet = self._get_pet(telegram_id)
        
        if pet is None or (isinstance(pet, dict) and pet.get("error")):
            return {
                "name": "Error",
                "hunger": 0,
                "happiness": 0,
                "health": 0,
                "cleanliness": 0,
                "error": "Server connection failed"
            }
        
        return pet

    def _format_stats(self, pet: Dict[str, Any]) -> str:
        if isinstance(pet, dict) and pet.get("error"):
            return "❌ **Server Error**\n> {}\n\nПроверьте соединение с сервером.".format(pet['error'])
        
        text = (
            f"🐾 **{pet.get('name', 'Unknown')}**\n\n"
            f"🍖 **Голод:** `{pet.get('hunger', 0)}%`\n"
            f"🎉 **Счастье:** `{pet.get('happiness', 0)}%`\n"
            f"💊 **Здоровье:** `{pet.get('health', 0)}%`\n"
            f"🧼 **Чистота:** `{pet.get('cleanliness', 0)}%`\n\n"
        )
        return text

    def _format_top_pets(self, top_pets: List[Dict]) -> str:
        if not top_pets:
            return "🏆 **Топ питомцев**\n\n*No pets found in the ranking.*"
        
        message = "🏆 **Чемпионы WEBGOTCHI** 🏆\n\n"
        
        if isinstance(top_pets, list) and len(top_pets) > 0:
            for i, pet in enumerate(top_pets, 1):
                if not isinstance(pet, dict):
                    self.log(f"Skipping non-dict pet item: {type(pet)}")
                    continue
                    
                rank = i
                rank_emoji = "🥇" if rank == 1 else "🥈" if rank == 2 else "🥉" if rank == 3 else f"`{rank}.`"
                
                name = pet.get('name', 'Unknown Pet')
                username = pet.get('username', 'Anonymous')
                bp = pet.get('battle_points', 0)
                lifetime_stats = pet.get('lifetime_stats', '0h')
                hunger = pet.get('hunger', 0)
                happiness = pet.get('happiness', 0)
                health = pet.get('health', 0)
                cleanliness = pet.get('cleanliness', 0)
                
                message += (
                    f"{rank_emoji} **{name}** (@{username})\n"
                    f"   *ОС:* `{bp}` • ⏳ *{lifetime_stats}*\n"
                    f"   🍖`{hunger}%` 🎉`{happiness}%` 💊`{health}%` 🧼`{cleanliness}%`\n\n"
                )
        else:
            return "🏆 **Топ питомцев**\n\n*Получены неверные данные.*"
        
        message += "> *Соревнуйтесь с реальными пользователями!*"
        return message
        

    def _apply_action(self, telegram_id: str, pet: Dict[str, Any], action: str, arg: Optional[str] = None) -> Optional[str]:
        if isinstance(pet, dict) and pet.get("error"):
            return "❌ **Cannot perform actions**\n> {}".format(pet['error'])

        action = (action or "").lower()
        updates: Dict[str, Any] = {}
        msg: Optional[str] = None

        if action in ("feed", "eat"):
            current_hunger = pet.get("hunger", 50)
            updates["hunger"] = max(0, current_hunger - 25)
            self._show_bulletin_success("🍗 Покормили! Голод -25%")
        elif action == "play":
            current_happiness = pet.get("happiness", 50)
            updates["happiness"] = min(100, current_happiness + 30)
            self._show_bulletin_success("🎾 Поиграли! Счастье +30%")
        elif action in ("wash", "clean"):
            current_cleanliness = pet.get("cleanliness", 50)
            updates["cleanliness"] = min(100, current_cleanliness + 40)
            self._show_bulletin_success("🛁 Помыли! Чистота +40%")
        elif action in ("heal", "med"):
            current_health = pet.get("health", 50)
            updates["health"] = min(100, current_health + 50)
            self._show_bulletin_success("💊 Вылечили! Здоровье +50%")
        elif action in ("name", "rename"):
            if arg:
                updates["name"] = arg.strip()[:24]
                msg = f"📝 **Имя изменено!**\n> *Теперь питомца зовут **{updates['name']}***\n\n*Очень мило!*"
            else:
                self._show_bulletin_error("Usage: .t rename <name>")
        elif action in ("stats", "show"):
            msg = self._format_stats(pet)
        elif action == "top":
            top_pets = self._get_top_pets(10)
            if top_pets is not None:
                msg = self._format_top_pets(top_pets)
            else:
                msg = None
                self._show_bulletin_error("Ошибка при получении топа питомцев")
        else:
            msg = (
                "🤖 **WebGotchi команды**\n\n"
                "🍗 `.t feed` - Покормить питомца\n"
                "🎾 `.t play` - Поиграть с питомцем\n"
                "🛁 `.t wash` - Вымыть питомца\n"
                "💊 `.t heal` - Вылечить питомца\n"
                "📝 `.t rename <name>` - переименовать\n"
                "📊 `.t stats` - Показать статистику\n"
                "🏆 `.t top` - Список лидеров!Ы\n\n"
            )

        if updates:
            updated = self._update_pet(telegram_id, updates)
            if updated is not None and not (isinstance(updated, dict) and updated.get("error")):
                pet.update(updates)
                if telegram_id in self._cache:
                    del self._cache[telegram_id]
            else:
                if msg:
                    msg += "\n\n⚠️ *Внимание! Данные не сохранены на сервере!*"
        return msg

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:
            text = getattr(params, "message", None)
            if not isinstance(text, str) or not text.startswith(".t"):
                return HookResult()
            
            telegram_id = self._get_telegram_id(account)
            peer_id = getattr(params, "peer", None) or getattr(params, "peer_id", None)
            
            if not peer_id:
                self.log("No peer_id found in params")
                self._show_bulletin_error("❌ Error: Cannot determine chat ID")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            self.log(f"Processing .t command for user {telegram_id} in peer {peer_id}")
            
            def process_pet_command():
                try:
                    parts = text.strip().split(" ", 2)
                    action = parts[1] if len(parts) >= 2 else "stats"

                    if action == "top":
                        top_pets = self._get_top_pets(10)
                        if top_pets is not None:
                            reply = self._format_top_pets(top_pets)
                        else:
                            reply = "❌ **Server Error**\n> *Failed to fetch top pets*\n\n*Please try again later.*"
                            self._show_bulletin_error("Failed to fetch top pets")
                    else:
                        pet = self._ensure_pet(telegram_id)
                        if pet is None:
                            self._show_bulletin_error("❌ Ошибка подключения. Попробуйте позже.")
                            return
                        arg = parts[2] if len(parts) >= 3 else None
                        reply = self._apply_action(telegram_id, pet, action, arg)

                    # Не отправлять сообщение, если reply пустой или None
                    if reply:
                        self._send_message(peer_id, reply)

                except Exception as e:
                    self.log(f"Background pet processing error: {e}")
                    import traceback
                    self.log(f"Traceback: {traceback.format_exc()}")
                    self._show_bulletin_error(f"❌ Plugin error: {str(e)}")

            run_on_queue(process_pet_command)
            
            return HookResult(strategy=HookStrategy.CANCEL)
            
        except Exception as e:
            self.log(f"on_send_message_hook error: {e}")
            self._show_bulletin_error(f"❌ Plugin error: {str(e)}")
            return HookResult(strategy=HookStrategy.CANCEL)

    def on_update_hook(self, update_name: str, account: int, update: Any) -> HookResult:
        try:
            if update_name == "TL_updateNewMessage" and hasattr(update, "message"):
                msg = getattr(update.message, "message", "") or ""
                if "@pet" in msg:
                    try:
                        telegram_id = self._get_telegram_id(account)
                        peer_id = getattr(update.message, "peer_id", None)
                        
                        if not peer_id:
                            self.log("No peer_id found in update")
                            return HookResult()
                        
                        def auto_reply():
                            try:
                                pet = self._ensure_pet(telegram_id)
                                if pet is None:
                                    self._show_bulletin_error("❌ Failed to connect to server.")
                                    return
                                reply = self._format_stats(pet)
                                self._send_message(peer_id, reply)
                            except Exception as inner:
                                self.log(f"auto-reply failed: {inner}")
                                self._show_bulletin_error(f"Auto-reply failed: {str(inner)}")
                        
                        run_on_queue(auto_reply)
                    except Exception as inner:
                        self.log(f"auto-reply setup failed: {inner}")
            return HookResult()
        except Exception as e:
            self.log(f"on_update_hook error: {e}")
            return HookResult()

    def pre_request_hook(self, request_name: str, account: int, request: Any) -> HookResult:
        try:
            if request_name == "TL_messages_sendMessage" and hasattr(request, "message") and isinstance(request.message, str):
                if request.message.startswith(".t"):
                    request.message = f"{request.message} ⁣#tgchi"
                    return HookResult(strategy=HookStrategy.MODIFY, request=request)
            return HookResult()
        except Exception as e:
            self.log(f"pre_request_hook error: {e}")
            return HookResult()

    def post_request_hook(self, request_name: str, account: int, response: Any, error: Any) -> HookResult:
        try:
            if request_name == "TL_messages_sendMessage":
                if error:
                    self.log(f"Tamagotchi sendMessage failed: {getattr(error, 'text', error)}")
                elif response:
                    self.log(f"Tamagotchi sendMessage ok: {type(response)}")
            return HookResult()
        except Exception as e:
            self.log(f"post_request_hook error: {e}")
            return HookResult()