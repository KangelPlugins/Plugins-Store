__id__ = "ex_tool"
__name__ = "Ex Tool"
__description__ = "–ù–µ–±–æ–ª—å—à–∏–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è Telegram –æ—Ç Ex"
__author__ = "@oxd5f & @explugin"
__version__ = "1.0"
__icon__ = "pyDevSticker/2"
__min_version__ = "11.12.0"

from base_plugin import BasePlugin, HookStrategy, MenuItemData, MenuItemType, HookResult, MethodHook, MethodReplacement
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment, get_messages_controller
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch, Input, Selector
from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import MessagesController, UserConfig
from java.util import Locale, ArrayList
from java.lang import Integer, Long as JLong, Boolean as JBoolean
from markdown_utils import parse_markdown
import re
import json
import requests
from typing import Any, Dict, List
from hook_utils import find_class, get_private_field, set_private_field
from android_utils import log
from java import jclass, jint

TRANSLATION_MAPS = {
	"small_caps": {
		"–∞": "·¥Ä", "–±": " ô", "–≤": "·¥†", "–≥": "…¢", "–¥": "·¥Ö", "–µ": "·¥á", "—ë": "·¥áÃà",
		"–∂": "·¥ä", "–∑": "·¥¢", "–∏": "…™", "–π": "…™ÃÜ", "–∫": "·¥ã", "–ª": " ü", "–º": "·¥ç",
		"–Ω": "…¥", "–æ": "·¥è", "–ø": "·¥ò", "—Ä": " Ä", "—Å": "Íú±", "—Ç": "·¥õ", "—É": "·¥ú",
		"—Ñ": "Íú∞", "—Ö": "x", "—Ü": "·¥Ñ", "—á": "·¥Ñ ú", "—à": "Íú± ú", "—â": "Íú±·¥Ñ ú",
		"—ä": "—ä", "—ã": " è", "—å": "—å", "—ç": "·¥á", "—é": " è·¥ú", "—è": " è·¥Ä"
	},
	"fraktur": {
		"–∞": "ùñÜ", "–±": "ùñá", "–≤": "ùñõ", "–≥": "ùñå", "–¥": "ùñâ", "–µ": "ùñä", "—ë": "ùñäÃà",
		"–∂": "ùñè", "–∑": "ùñü", "–∏": "ùñé", "–π": "ùñéÃÜ", "–∫": "ùñê", "–ª": "ùñë", "–º": "ùñí",
		"–Ω": "ùñì", "–æ": "ùñî", "–ø": "ùñï", "—Ä": "ùñó", "—Å": "ùñò", "—Ç": "ùñô", "—É": "ùñö",
		"—Ñ": "ùñã", "—Ö": "ùñù", "—Ü": "ùñà", "—á": "ùñàùñç", "—à": "ùñòùñç", "—â": "ùñòùñàùñç",
		"—ä": "—ä", "—ã": "ùñû", "—å": "—å", "—ç": "ùñä", "—é": "ùñûùñö", "—è": "ùñûùñÜ"
	},
	"special": {
		"–∞": "√•", "–±": "√ü", "–≤": "v", "–≥": "g", "–¥": "√ê", "–µ": "√™", "—ë": "√™Ãà",
		"–∂": "j", "–∑": "z", "–∏": "√Ø", "–π": "√ØÃÜ", "–∫": "k", "–ª": "l", "–º": "m",
		"–Ω": "√±", "–æ": "√∞", "–ø": "√æ", "—Ä": "r", "—Å": "¬ß", "—Ç": "‚Ä†", "—É": "¬µ",
		"—Ñ": "¬£", "—Ö": "x", "—Ü": "¬¢", "—á": "¬¢h", "—à": "¬ßh", "—â": "¬ß¬¢h",
		"—ä": "—ä", "—ã": "¬•", "—å": "—å", "—ç": "√™", "—é": "¬•¬µ", "—è": "¬•√•"
	},
	"standard": {
		"–∞": "a", "–±": "b", "–≤": "v", "–≥": "g", "–¥": "d", "–µ": "e", "—ë": "e",
		"–∂": "j", "–∑": "z", "–∏": "i", "–π": "i", "–∫": "k", "–ª": "l", "–º": "m",
		"–Ω": "n", "–æ": "o", "–ø": "p", "—Ä": "r", "—Å": "s", "—Ç": "t", "—É": "u",
		"—Ñ": "f", "—Ö": "x", "—Ü": "c", "—á": "ch", "—à": "sh", "—â": "sch",
		"—ä": "—ä", "—ã": "y", "—å": "—å", "—ç": "e", "—é": "yu", "—è": "ya"
	}
}

LANGUAGE_PACKS = {
	"en": {
		"title": "Ex Tool",
		"auto_translate": "Auto translate Russian ‚Üí Ex Tool",
		"translate_menu": "Translate / restore original",
		"style_header": "Alphabet Style",
		"alphabet_style_type": "Alphabet type",
		"use_small_caps": "Small Caps (·¥Ä ô·¥Ñ)",
		"use_fraktur": "Fraktur (ùñÜùñáùñà)",
		"use_special": "Special (√•√ü¬¢)",
		"use_standard": "Standard (abc)",
		"signature_header": "Auto Signature",
		"enable_signature": "Enable auto signature",
		"signature_text": "Signature text",
		"signature_start": "Signature at start",
		"signature_end": "Signature at end",
		"enable_for_private": "Enable in private chats",
		"enable_for_groups": "Enable in groups",
		"enable_for_channels": "Enable in channels",
		"antispoiler_header": "Anti-Spoiler",
		"enable_antispoiler": "Remove spoilers from text and media",
		"link_cleaner_header": "Link Cleaner",
		"enable_link_cleaner": "Remove http:// and https:// from links",
		"enable_link_shortener": "Shorten links via TinyURL",
		"enable_link_cleanup": "Clean tracking parameters from links",
		"text_formatter_header": "Text Formatter",
		"enable_ai_correction": "AI: grammar and punctuation correction",
		"enable_capitalize": "Capitalize first letter in sentences",
		"enable_final_dot": "Add period at the end",
		"writing_style_header": "Writing Style",
		"enable_writing_style": "Enable writing style conversion",
		"writing_style_type": "Style type",
		"style_business": "Business",
		"style_casual": "Casual",
		"style_official": "Official",
		"style_bydlo": "Street",
		"unlimited_pins_header": "Unlimited Pins",
		"enable_unlimited_pins": "Enable unlimited pinned chats",
		"unlimited_pins_max": "Max pinned count",
		"round_video_header": "Round Video Settings",
		"enable_round_video_settings": "Enable custom round video settings",
		"round_video_resolution": "Resolution, px",
		"round_video_bitrate": "Bitrate, kbit/s",
		"forward_limit_header": "Forward Limit",
		"enable_no_forward_limit": "Remove 100 messages limit",
		"unlimited_gifs_header": "Unlimited GIFs",
		"enable_unlimited_gifs": "Remove saved GIFs limit",
		"success": "Translation successful",
		"error": "Translation failed"
	},
	"ru": {
		"title": "Ex Tool",
		"auto_translate": "–ê–≤—Ç–æ–ø–µ—Ä–µ–≤–æ–¥ –†—É—Å—Å–∫–∏–π ‚Üí Ex Tool",
		"translate_menu": "–ü–µ—Ä–µ–≤–µ—Å—Ç–∏ / –≤–µ—Ä–Ω—É—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª",
		"style_header": "–°—Ç–∏–ª—å –∞–ª—Ñ–∞–≤–∏—Ç–∞",
		"alphabet_style_type": "–¢–∏–ø –∞–ª—Ñ–∞–≤–∏—Ç–∞",
		"use_small_caps": "–ú–∞–ª—ã–µ –∑–∞–≥–ª–∞–≤–Ω—ã–µ (·¥Ä ô·¥Ñ)",
		"use_fraktur": "–§—Ä–∞–∫—Ç—É—Ä–∞ (ùñÜùñáùñà)",
		"use_special": "–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ (√•√ü¬¢)",
		"use_standard": "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π (abc)",
		"signature_header": "–ê–≤—Ç–æ–ø–æ–¥–ø–∏—Å—å",
		"enable_signature": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–ø–æ–¥–ø–∏—Å—å",
		"signature_text": "–¢–µ–∫—Å—Ç –ø–æ–¥–ø–∏—Å–∏",
		"signature_start": "–ü–æ–¥–ø–∏—Å—å –≤ –Ω–∞—á–∞–ª–µ",
		"signature_end": "–ü–æ–¥–ø–∏—Å—å –≤ –∫–æ–Ω—Ü–µ",
		"enable_for_private": "–í–∫–ª—é—á–∏—Ç—å –≤ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–∞—Ö",
		"enable_for_groups": "–í–∫–ª—é—á–∏—Ç—å –≤ –≥—Ä—É–ø–ø–∞—Ö",
		"enable_for_channels": "–í–∫–ª—é—á–∏—Ç—å –≤ –∫–∞–Ω–∞–ª–∞—Ö",
		"antispoiler_header": "–ê–Ω—Ç–∏—Å–ø–æ–π–ª–µ—Ä",
		"enable_antispoiler": "–£–±–∏—Ä–∞—Ç—å —Å–ø–æ–π–ª–µ—Ä—ã —Å —Ç–µ–∫—Å—Ç–∞ –∏ –º–µ–¥–∏–∞",
		"link_cleaner_header": "–û—á–∏—Å—Ç–∫–∞ —Å—Å—ã–ª–æ–∫",
		"enable_link_cleaner": "–£–±–∏—Ä–∞—Ç—å http:// –∏ https:// –∏–∑ —Å—Å—ã–ª–æ–∫",
		"enable_link_shortener": "–°–æ–∫—Ä–∞—â–∞—Ç—å —Å—Å—ã–ª–∫–∏ —á–µ—Ä–µ–∑ TinyURL",
		"enable_link_cleanup": "–û—á–∏—â–∞—Ç—å —Å—Å—ã–ª–∫–∏ –æ—Ç —Ç—Ä–µ–∫–∏–Ω–≥–∞ –∏ utm-–º–µ—Ç–æ–∫",
		"text_formatter_header": "–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞",
		"enable_ai_correction": "–ò–ò: –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ä—Ñ–æ–≥—Ä–∞—Ñ–∏–∏ –∏ –ø—É–Ω–∫—Ç—É–∞—Ü–∏–∏",
		"enable_capitalize": "–ó–∞–≥–ª–∞–≤–Ω–∞—è –±—É–∫–≤–∞ –≤ –Ω–∞—á–∞–ª–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π",
		"enable_final_dot": "–î–æ–±–∞–≤–ª—è—Ç—å —Ç–æ—á–∫—É –≤ –∫–æ–Ω—Ü–µ",
		"writing_style_header": "–°—Ç–∏–ª—å –ø–∏—Å—å–º–∞",
		"enable_writing_style": "–í–∫–ª—é—á–∏—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç–∏–ª—è –ø–∏—Å—å–º–∞",
		"writing_style_type": "–¢–∏–ø —Å—Ç–∏–ª—è",
		"style_business": "–î–µ–ª–æ–≤–æ–π",
		"style_casual": "–†–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π",
		"style_official": "–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π",
		"style_bydlo": "–ë—ã–¥–ª–æ",
		"unlimited_pins_header": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω–æ–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ",
		"enable_unlimited_pins": "–í–∫–ª—é—á–∏—Ç—å –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∏–µ —á–∞—Ç–æ–≤",
		"unlimited_pins_max": "–ú–∞–∫—Å–∏–º—É–º –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã—Ö",
		"round_video_header": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—Ä—É–≥–ª—ã—Ö –≤–∏–¥–µ–æ",
		"enable_round_video_settings": "–í–∫–ª—é—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—Ä—É–≥–ª—ã—Ö –≤–∏–¥–µ–æ",
		"round_video_resolution": "–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ, px",
		"round_video_bitrate": "–ë–∏—Ç—Ä–µ–π—Ç, –∫–±–∏—Ç/—Å",
		"forward_limit_header": "–õ–∏–º–∏—Ç –ø–µ—Ä–µ—Å—ã–ª–∫–∏",
		"enable_no_forward_limit": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç 100 —Å–æ–æ–±—â–µ–Ω–∏–π",
		"unlimited_gifs_header": "–ë–µ–∑–ª–∏–º–∏—Ç–Ω—ã–µ GIF",
		"enable_unlimited_gifs": "–£–±—Ä–∞—Ç—å –ª–∏–º–∏—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö GIF",
		"success": "–ü–µ—Ä–µ–≤–æ–¥ —É—Å–ø–µ—à–µ–Ω",
		"error": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–≤–µ—Å—Ç–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ"
	},
	"de": {
		"title": "Ex Tool",
		"auto_translate": "Auto-√úbersetzung Russisch ‚Üí Ex Tool",
		"translate_menu": "√úbersetzen / Original wiederherstellen",
		"style_header": "Alphabetstil",
		"alphabet_style_type": "Alphabettyp",
		"use_small_caps": "Kapit√§lchen (·¥Ä ô·¥Ñ)",
		"use_fraktur": "Fraktur (ùñÜùñáùñà)",
		"use_special": "Spezial (√•√ü¬¢)",
		"use_standard": "Standard (abc)",
		"signature_header": "Auto-Signatur",
		"enable_signature": "Auto-Signatur aktivieren",
		"signature_text": "Signaturtext",
		"signature_start": "Signatur am Anfang",
		"signature_end": "Signatur am Ende",
		"enable_for_private": "In privaten Chats aktivieren",
		"enable_for_groups": "In Gruppen aktivieren",
		"enable_for_channels": "In Kan√§len aktivieren",
		"antispoiler_header": "Anti-Spoiler",
		"enable_antispoiler": "Spoiler von Text und Medien entfernen",
		"link_cleaner_header": "Link-Reiniger",
		"enable_link_cleaner": "http:// und https:// aus Links entfernen",
		"enable_link_shortener": "Links √ºber TinyURL k√ºrzen",
		"enable_link_cleanup": "Links von Tracking und utm-Tags bereinigen",
		"text_formatter_header": "Textformatierung",
		"enable_ai_correction": "KI: Grammatik- und Zeichensetzungskorrektur",
		"enable_capitalize": "Gro√üer Anfangsbuchstabe in S√§tzen",
		"enable_final_dot": "Punkt am Ende hinzuf√ºgen",
		"writing_style_header": "Schreibstil",
		"enable_writing_style": "Schreibstilkonvertierung aktivieren",
		"writing_style_type": "Stiltyp",
		"style_business": "Gesch√§ftlich",
		"style_casual": "Umgangssprachlich",
		"style_official": "Offiziell",
		"style_bydlo": "Stra√üenslang",
		"unlimited_pins_header": "Unbegrenzte Pins",
		"enable_unlimited_pins": "Unbegrenzte angepinnte Chats aktivieren",
		"unlimited_pins_max": "Maximale Anzahl angepinnter",
		"round_video_header": "Rundvideo-Einstellungen",
		"enable_round_video_settings": "Benutzerdefinierte Rundvideo-Einstellungen aktivieren",
		"round_video_resolution": "Aufl√∂sung, px",
		"round_video_bitrate": "Bitrate, kbit/s",
		"forward_limit_header": "Weiterleitungslimit",
		"enable_no_forward_limit": "Limit von 100 Nachrichten entfernen",
		"unlimited_gifs_header": "Unbegrenzte GIFs",
		"enable_unlimited_gifs": "Limit f√ºr gespeicherte GIFs entfernen",
		"success": "√úbersetzung erfolgreich",
		"error": "√úbersetzung fehlgeschlagen"
	}
}

ROUND_VIDEO_RESOLUTIONS = [128, 256, 384, 512, 640]
ROUND_VIDEO_BITRATES = [600, 800, 1000, 1200, 1400]

WRITING_STYLES = {
	"business": {
		"–ø—Ä–∏–≤–µ—Ç": "–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ",
		"—Å–ø–∞—Å–∏–±–æ": "–±–ª–∞–≥–æ–¥–∞—Ä—é",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã",
		"–¥–∞": "—Å–æ–≥–ª–∞—Å–µ–Ω",
		"–Ω–µ—Ç": "–Ω–µ –º–æ–≥—É —Å–æ–≥–ª–∞—Å–∏—Ç—å—Å—è",
		"—Ö–æ—Ä–æ—à–æ": "–ø—Ä–∏–µ–º–ª–µ–º–æ",
		"–ø–ª–æ—Ö–æ": "–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ",
		"—Å–¥–µ–ª–∞—é": "–≤—ã–ø–æ–ª–Ω—é",
		"—Å–∫–∞–∂–∏": "—Å–æ–æ–±—â–∏—Ç–µ",
		"–Ω–∞–ø–∏—à–∏": "–Ω–∞–ø—Ä–∞–≤—å—Ç–µ",
		"–∂–¥–∏": "–æ–∂–∏–¥–∞–π—Ç–µ",
		"–±—ã—Å—Ç—Ä–æ": "–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —Å—Ä–æ–∫–∏",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ",
		"–æ—à–∏–±–∫–∞": "–Ω–µ–¥–æ—á–µ—Ç",
		"–¥–µ–Ω–µ–≥": "—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤",
		"—Ä–∞–±–æ—Ç–∞": "–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
		"–Ω—É–∂–Ω–æ": "–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ",
		"–Ω–∞–¥–æ": "—Ç—Ä–µ–±—É–µ—Ç—Å—è",
		"–º–æ–∂–Ω–æ": "–¥–æ–ø—É—Å—Ç–∏–º–æ",
		"–Ω–µ–ª—å–∑—è": "–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ",
		"–∫—É–ø–∏—Ç—å": "–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏",
		"–ø—Ä–æ–¥–∞—Ç—å": "—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å",
		"–≤—Å—Ç—Ä–µ—á–∞": "–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–±–µ—Å–µ–¥–∞",
		"–∑–≤–æ–Ω–æ–∫": "—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫",
		"–ø–∏—Å—å–º–æ": "–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ",
		"–¥—É–º–∞—é": "–ø–æ–ª–∞–≥–∞—é",
		"–∑–Ω–∞—é": "–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω",
		"–ø–æ–Ω—è–ª": "—É—è—Å–Ω–∏–ª",
		"–ø–æ–º–æ–≥—É": "–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ",
		"–æ–±—ä—è—Å–Ω–∏": "—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ",
		"—É–∑–Ω–∞–π": "—É—Ç–æ—á–Ω–∏—Ç–µ",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ",
		"–∂–¥—É": "–æ–∂–∏–¥–∞—é",
		"—Ö–æ—á—É": "–∂–µ–ª–∞—é",
		"–±—É–¥—É": "–Ω–∞–º–µ—Ä–µ–Ω",
		"–≤–æ–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å",
		"–æ—Ç–≤–µ—Ç": "–æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è",
		"—Ñ–∞–π–ª": "—Ñ–∞–π–ª –¥–æ–∫—É–º–µ–Ω—Ç–∞",
		"–æ—Ç–ø—Ä–∞–≤—å": "–Ω–∞–ø—Ä–∞–≤—å—Ç–µ",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–µ–Ω–æ",
		"–ø–æ–Ω—è—Ç–Ω–æ": "—è—Å–Ω–æ"
	},
	"casual": {
		"–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ": "–ø—Ä–∏–≤–µ—Ç",
		"–±–ª–∞–≥–æ–¥–∞—Ä—é": "—Å–ø–∞—Å–∏–±–æ",
		"–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã": "–ø–æ–∂–∞–ª—É–π—Å—Ç–∞",
		"—Å–æ–≥–ª–∞—Å–µ–Ω": "–æ–∫",
		"–Ω–µ –º–æ–≥—É —Å–æ–≥–ª–∞—Å–∏—Ç—å—Å—è": "–Ω–µ",
		"–ø—Ä–∏–µ–º–ª–µ–º–æ": "–Ω–æ—Ä–º",
		"–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ": "–Ω–µ –æ—á–µ–Ω—å",
		"–≤—ã–ø–æ–ª–Ω—é": "—Å–¥–µ–ª–∞—é",
		"—Å–æ–æ–±—â–∏—Ç–µ": "—Å–∫–∞–∂–∏",
		"–Ω–∞–ø—Ä–∞–≤—å—Ç–µ": "–æ—Ç–ø—Ä–∞–≤—å",
		"–æ–∂–∏–¥–∞–π—Ç–µ": "–ø–æ–¥–æ–∂–¥–∏",
		"–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ": "–±—ã—Å—Ç—Ä–æ",
		"–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ": "–ø—Ä–æ–±–ª–µ–º–∞",
		"–Ω–µ–¥–æ—á–µ—Ç": "–∫–æ—Å—è–∫",
		"—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤": "–¥–µ–Ω–µ–≥",
		"–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å": "—Ä–∞–±–æ—Ç–∞",
		"–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ": "–Ω–∞–¥–æ",
		"—Ç—Ä–µ–±—É–µ—Ç—Å—è": "–Ω—É–∂–Ω–æ",
		"–¥–æ–ø—É—Å—Ç–∏–º–æ": "–º–æ–∂–Ω–æ",
		"–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ": "–Ω–µ–ª—å–∑—è",
		"–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏": "–∫—É–ø–∏—Ç—å",
		"—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å": "–ø—Ä–æ–¥–∞—Ç—å",
		"–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞": "–≤—Å—Ç—Ä–µ—á–∞",
		"–±–µ—Å–µ–¥–∞": "—Ä–∞–∑–≥–æ–≤–æ—Ä",
		"—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫": "–∑–≤–æ–Ω–æ–∫",
		"–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–æ",
		"–ø–æ–ª–∞–≥–∞—é": "–¥—É–º–∞—é",
		"–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω": "–∑–Ω–∞—é",
		"—É—è—Å–Ω–∏–ª": "–ø–æ–Ω—è–ª",
		"–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ": "–ø–æ–º–æ–≥—É",
		"—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ": "–æ–±—ä—è—Å–Ω–∏",
		"—É—Ç–æ—á–Ω–∏—Ç–µ": "—É–∑–Ω–∞–π",
		"–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å": "–ø–æ—Å–º–æ—Ç—Ä–∏",
		"–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ": "—Ä–∞—Å—Å–∫–∞–∂–∏",
		"–æ–∂–∏–¥–∞—é": "–∂–¥—É",
		"–∂–µ–ª–∞—é": "—Ö–æ—á—É",
		"–Ω–∞–º–µ—Ä–µ–Ω": "–±—É–¥—É",
		"—Ñ–∞–π–ª –¥–æ–∫—É–º–µ–Ω—Ç–∞": "—Ñ–∞–π–ª",
		"–ø–æ–ª—É—á–µ–Ω–æ": "–ø–æ–ª—É—á–∏–ª",
		"—è—Å–Ω–æ": "–ø–æ–Ω—è—Ç–Ω–æ"
	},
	"official": {
		"–ø—Ä–∏–≤–µ—Ç": "–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é",
		"—Å–ø–∞—Å–∏–±–æ": "–≤—ã—Ä–∞–∂–∞—é –±–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–ø—Ä–æ—à—É –í–∞—Å",
		"–¥–∞": "—É—Ç–≤–µ—Ä–¥–∏—Ç–µ–ª—å–Ω–æ",
		"–Ω–µ—Ç": "–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ",
		"—Ö–æ—Ä–æ—à–æ": "—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ",
		"–ø–ª–æ—Ö–æ": "–Ω–µ–ø—Ä–∏–µ–º–ª–µ–º–æ",
		"—Å–¥–µ–ª–∞—é": "–∏—Å–ø–æ–ª–Ω—é",
		"—Å–∫–∞–∂–∏": "–¥–æ–≤–µ–¥–∏—Ç–µ –¥–æ —Å–≤–µ–¥–µ–Ω–∏—è",
		"–Ω–∞–ø–∏—à–∏": "–ø—Ä–æ—Å–∏–º –Ω–∞–ø—Ä–∞–≤–∏—Ç—å",
		"–∂–¥–∏": "–ø—Ä–æ—Å–∏–º –æ–∂–∏–¥–∞—Ç—å",
		"–±—ã—Å—Ç—Ä–æ": "–≤ –∫—Ä–∞—Ç—á–∞–π—à–∏–µ —Å—Ä–æ–∫–∏",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–≤ —Ç–µ—á–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–∏–æ–¥–∞",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–∑–∞—Ç—Ä—É–¥–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏—Ç—É–∞—Ü–∏—è",
		"–æ—à–∏–±–∫–∞": "–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ",
		"–¥–µ–Ω–µ–≥": "–¥–µ–Ω–µ–∂–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤",
		"—Ä–∞–±–æ—Ç–∞": "—Ç—Ä—É–¥–æ–≤–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
		"–Ω—É–∂–Ω–æ": "–Ω–∞–¥–ª–µ–∂–∏—Ç",
		"–Ω–∞–¥–æ": "—Å–ª–µ–¥—É–µ—Ç",
		"–º–æ–∂–Ω–æ": "–∏–º–µ–µ—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å",
		"–Ω–µ–ª—å–∑—è": "–Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω—ã–º",
		"–∫—É–ø–∏—Ç—å": "–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–∞–∫—É–ø–∫—É",
		"–ø—Ä–æ–¥–∞—Ç—å": "–æ—Å—É—â–µ—Å—Ç–≤–∏—Ç—å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é",
		"–≤—Å—Ç—Ä–µ—á–∞": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –≤—Å—Ç—Ä–µ—á–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –±–µ—Å–µ–¥–∞",
		"–∑–≤–æ–Ω–æ–∫": "—Ç–µ–ª–µ—Ñ–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ",
		"–ø–∏—Å—å–º–æ": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–µ –ø–æ—Å–ª–∞–Ω–∏–µ",
		"–¥—É–º–∞—é": "–ø–æ–ª–∞–≥–∞—é –≤–æ–∑–º–æ–∂–Ω—ã–º",
		"–∑–Ω–∞—é": "–∏–º–µ—é —Å–≤–µ–¥–µ–Ω–∏—è",
		"–ø–æ–Ω—è–ª": "—É—Å–≤–æ–∏–ª –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é",
		"–ø–æ–º–æ–≥—É": "–æ–∫–∞–∂—É –Ω–∞–¥–ª–µ–∂–∞—â–µ–µ —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ",
		"–æ–±—ä—è—Å–Ω–∏": "–ø—Ä–æ—Å–∏–º —Ä–∞–∑—ä—è—Å–Ω–∏—Ç—å",
		"—É–∑–Ω–∞–π": "–ø—Ä–æ—Å–∏–º –≤—ã—è—Å–Ω–∏—Ç—å",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–ø—Ä–æ—Å–∏–º —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "–ø—Ä–æ—Å–∏–º –ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å",
		"–∂–¥—É": "–Ω–∞—Ö–æ–∂—É—Å—å –≤ –æ–∂–∏–¥–∞–Ω–∏–∏",
		"—Ö–æ—á—É": "–∏–∑—ä—è–≤–ª—è—é –∂–µ–ª–∞–Ω–∏–µ",
		"–±—É–¥—É": "–Ω–∞–º–µ—Ä–µ–≤–∞—é—Å—å",
		"–≤–æ–ø—Ä–æ—Å": "–∑–∞–ø—Ä–æ—Å",
		"–æ—Ç–≤–µ—Ç": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è",
		"—Ñ–∞–π–ª": "—ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç",
		"–æ—Ç–ø—Ä–∞–≤—å": "–ø—Ä–æ—Å–∏–º –Ω–∞–ø—Ä–∞–≤–∏—Ç—å",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–µ–Ω–æ –∫ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—é",
		"–ø–æ–Ω—è—Ç–Ω–æ": "–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø—Ä–∏–Ω—è—Ç–∞ –∫ —Å–≤–µ–¥–µ–Ω–∏—é"
	},
	"bydlo": {
		"–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ": "–∑–¥–∞—Ä–æ–≤–∞",
		"–ø—Ä–∏–≤–µ—Ç": "–∑–¥–∞—Ä–æ–≤–∞",
		"—Å–ø–∞—Å–∏–±–æ": "—Å–ø–∞—Å–∏–±–∫–∏",
		"–±–ª–∞–≥–æ–¥–∞—Ä—é": "–ø–∞—Å–∏–±",
		"–ø–æ–∂–∞–ª—É–π—Å—Ç–∞": "–Ω–µ –∑–∞ —á—Ç–æ",
		"–±—É–¥—å—Ç–µ –ª—é–±–µ–∑–Ω—ã": "–¥–∞–≤–∞–π",
		"–¥–∞": "–∞–≥–∞",
		"–Ω–µ—Ç": "–Ω–µ",
		"—Å–æ–≥–ª–∞—Å–µ–Ω": "–Ω–æ—Ä–º",
		"—Ö–æ—Ä–æ—à–æ": "—á–µ—Ç–∫–æ",
		"–ø–ª–æ—Ö–æ": "—Ö—Ä–µ–Ω–æ–≤–æ",
		"–æ—Ç–ª–∏—á–Ω–æ": "–æ–≥–æ–Ω—å",
		"–ø—Ä–∏–µ–º–ª–µ–º–æ": "–∫–∞–Ω–∞–µ—Ç",
		"–Ω–µ—É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–∏—Ç–µ–ª—å–Ω–æ": "–æ—Ç—Å—Ç–æ–π",
		"—Å–¥–µ–ª–∞—é": "—Å–¥–µ–ª–∞—é",
		"–≤—ã–ø–æ–ª–Ω—é": "–∑–∞–º—É—á—É",
		"—Å–∫–∞–∂–∏": "—Å–∫–∞–∂–∏",
		"—Å–æ–æ–±—â–∏—Ç–µ": "—Å–∫–∞–∂–∏",
		"–Ω–∞–ø–∏—à–∏": "–Ω–∞–ø–∏—à–∏",
		"–Ω–∞–ø—Ä–∞–≤—å—Ç–µ": "–∫–∏–Ω—å",
		"–∂–¥–∏": "–∂–¥–∏",
		"–æ–∂–∏–¥–∞–π—Ç–µ": "–ø–æ–≥–æ–¥–∏",
		"–±—ã—Å—Ç—Ä–æ": "—à—É—Å—Ç—Ä–æ",
		"–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ": "–∂–∏–≤–æ",
		"–º–µ–¥–ª–µ–Ω–Ω–æ": "–Ω–µ —Ç–æ—Ä–æ–ø—è—Å—å",
		"–ø—Ä–æ–±–ª–µ–º–∞": "–ø—Ä–æ–±–ª–µ–º–∞",
		"–∑–∞—Ç—Ä—É–¥–Ω–µ–Ω–∏–µ": "–∑–∞—Å–∞–¥–∞",
		"–æ—à–∏–±–∫–∞": "–∫–æ—Å—è–∫",
		"–Ω–µ–¥–æ—á–µ—Ç": "–Ω–∞–∫–æ—Å—è—á–∏–ª",
		"–¥–µ–Ω–µ–≥": "–±–∞–±–æ–∫",
		"–¥–µ–Ω—å–≥–∏": "–±–∞–±–∫–∏",
		"—Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤": "–∫–∞–ø—É—Å—Ç—ã",
		"—Ä–∞–±–æ—Ç–∞": "—Ä–∞–±–æ—Ç–∞",
		"–¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å": "–¥–≤–∏–∂—É—Ö–∞",
		"–Ω—É–∂–Ω–æ": "–Ω–∞–¥–∞",
		"–Ω–∞–¥–æ": "–Ω–∞–¥–∞",
		"–Ω–µ–æ–±—Ö–æ–¥–∏–º–æ": "–Ω–∞–¥–∞",
		"—Ç—Ä–µ–±—É–µ—Ç—Å—è": "–Ω—É–∂–Ω–æ",
		"–º–æ–∂–Ω–æ": "–º–æ–∂–Ω–æ",
		"–¥–æ–ø—É—Å—Ç–∏–º–æ": "–∫–∞—Ç–∏—Ç",
		"–Ω–µ–ª—å–∑—è": "–Ω–∏–∑—è",
		"–Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ": "–Ω–µ–ª—å–∑—è",
		"–∫—É–ø–∏—Ç—å": "–≤–∑—è—Ç—å",
		"–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏": "–≤–∑—è—Ç—å",
		"–ø—Ä–æ–¥–∞—Ç—å": "—Ç–æ–ª–∫–Ω—É—Ç—å",
		"—Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å": "—Å–±—ã—Ç—å",
		"–≤—Å—Ç—Ä–µ—á–∞": "–≤—Å—Ç—Ä–µ—á–∞",
		"–¥–µ–ª–æ–≤–∞—è –≤—Å—Ç—Ä–µ—á–∞": "—Å—Ö–æ–¥–∫–∞",
		"—Ä–∞–∑–≥–æ–≤–æ—Ä": "–±–∞–∑–∞—Ä",
		"–±–µ—Å–µ–¥–∞": "—Ä–∞–∑–≥–æ–≤–æ—Ä",
		"–∑–≤–æ–Ω–æ–∫": "–∑–≤–æ–Ω–æ–∫",
		"—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫": "–ø–æ–∑–≤–æ–Ω",
		"–ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–æ",
		"–¥–µ–ª–æ–≤–æ–µ –ø–∏—Å—å–º–æ": "–ø–∏—Å—å–º–µ—Ü–æ",
		"–¥—É–º–∞—é": "–¥—É–º–∞—é",
		"–ø–æ–ª–∞–≥–∞—é": "–º–Ω–µ –∫–∞–∂–µ—Ç—Å—è",
		"–∑–Ω–∞—é": "–∑–Ω–∞—é",
		"–æ—Å–≤–µ–¥–æ–º–ª–µ–Ω": "–≤ –∫—É—Ä—Å–µ",
		"–ø–æ–Ω—è–ª": "–ø–æ–Ω—è–ª",
		"—É—è—Å–Ω–∏–ª": "–≤—Ä—É–±–∏–ª—Å—è",
		"–ø–æ–º–æ–≥—É": "–ø–æ–º–æ–≥—É",
		"–æ–∫–∞–∂—É —Å–æ–¥–µ–π—Å—Ç–≤–∏–µ": "–ø–æ–¥—Å–æ–±–ª—é",
		"–æ–±—ä—è—Å–Ω–∏": "–æ–±—ä—è—Å–Ω–∏",
		"—Ä–∞–∑—ä—è—Å–Ω–∏—Ç–µ": "—Ä–∞—Å—Ç–æ–ª–∫—É–π",
		"—É–∑–Ω–∞–π": "—É–∑–Ω–∞–π",
		"—É—Ç–æ—á–Ω–∏—Ç–µ": "—Ä–∞–∑—É–∑–Ω–∞–π",
		"–ø–æ—Å–º–æ—Ç—Ä–∏": "–≥–ª—è–Ω—å",
		"–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å": "–ø–æ—Å–º–æ—Ç—Ä–∏",
		"—Ä–∞—Å—Å–∫–∞–∂–∏": "—Ä–∞—Å—Å–∫–∞–∂–∏",
		"–ø—Ä–æ–∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–π—Ç–µ": "–¥–æ–ª–æ–∂–∏",
		"–∂–¥—É": "–∂–¥—É",
		"–æ–∂–∏–¥–∞—é": "–∂–¥—É",
		"—Ö–æ—á—É": "—Ö–æ—á—É",
		"–∂–µ–ª–∞—é": "—Ö–æ—á—É",
		"–±—É–¥—É": "–±—É–¥—É",
		"–Ω–∞–º–µ—Ä–µ–Ω": "—Å–æ–±–∏—Ä–∞—é—Å—å",
		"–≤–æ–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å",
		"–∑–∞–ø—Ä–æ—Å": "–≤–æ–ø—Ä–æ—Å–∏–∫",
		"–æ—Ç–≤–µ—Ç": "–æ—Ç–≤–µ—Ç",
		"–¥–æ–∫—É–º–µ–Ω—Ç": "–±—É–º–∞–≥–∞",
		"–¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è": "–±—É–º–∞–∂–∫–∏",
		"—Ñ–∞–π–ª": "—Ñ–∞–π–ª",
		"–æ—Ç–ø—Ä–∞–≤—å": "–∫–∏–Ω—å",
		"–ø–æ–ª—É—á–∏–ª": "–ø–æ–ª—É—á–∏–ª",
		"–ø–æ–ª—É—á–µ–Ω–æ": "–ø—Ä–∏—à–ª–æ",
		"–ø–æ–Ω—è—Ç–Ω–æ": "–ø–æ–Ω—è—Ç–Ω–æ",
		"—è—Å–Ω–æ": "—è—Å–Ω–µ–Ω—å–∫–æ",
		"—á–µ–ª–æ–≤–µ–∫": "—á–µ–ª",
		"–ª—é–¥–∏": "–Ω–∞—Ä–æ–¥",
		"–¥—Ä—É–≥": "–∫–æ—Ä–µ—à",
		"—Ç–æ–≤–∞—Ä–∏—â": "–±—Ä–∞—Ç–∞–Ω",
		"–∫–æ–ª–ª–µ–≥–∞": "–∫–æ–ª–ª–µ–≥–∞",
		"–Ω–∞—á–∞–ª—å–Ω–∏–∫": "–Ω–∞—á–∞–ª—å–Ω–∏–∫",
		"—Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å": "—à–µ—Ñ",
		"—Å–æ—Ç—Ä—É–¥–Ω–∏–∫": "—Ä–∞–±–æ—Ç–Ω–∏–∫",
		"–∫–ª–∏–µ–Ω—Ç": "–∫–ª–∏–µ–Ω—Ç",
		"–ø–∞—Ä—Ç–Ω–µ—Ä": "–ø–∞—Ä—Ç–Ω–µ—Ä",
		"–¥–æ–≥–æ–≤–æ—Ä": "–¥–æ–≥–æ–≤–æ—Ä",
		"–∫–æ–Ω—Ç—Ä–∞–∫—Ç": "–±—É–º–∞–≥–∏",
		"—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ": "–¥–æ–≥–æ–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å",
		"–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ": "–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ",
		"–∑–∞–∫–∞–∑": "–∑–∞–∫–∞–∑",
		"—É—Å–ª—É–≥–∞": "—É—Å–ª—É–≥–∞",
		"—Ç–æ–≤–∞—Ä": "—Ç–æ–≤–∞—Ä",
		"–ø—Ä–æ–¥—É–∫—Ç": "–ø—Ä–æ–¥—É–∫—Ç",
		"—Ü–µ–Ω–∞": "—Ü–µ–Ω–∞",
		"—Å—Ç–æ–∏–º–æ—Å—Ç—å": "—Å—Ç–æ–∏–º–æ—Å—Ç—å",
		"–æ–ø–ª–∞—Ç–∞": "–æ–ø–ª–∞—Ç–∞",
		"–ø–ª–∞—Ç–µ–∂": "–ø–ª–∞—Ç–µ–∂",
		"—Å—á–µ—Ç": "—Å—á–µ—Ç"
	}
}

def get_locale(key):
	lang = Locale.getDefault().getLanguage()
	locale_dict = LANGUAGE_PACKS.get(lang, LANGUAGE_PACKS["en"])
	return locale_dict.get(key, key)

def translate_text(text, to_latin=True, style="small_caps"):
	if not text or not isinstance(text, str):
		return text
	
	translation_map = TRANSLATION_MAPS.get(style, TRANSLATION_MAPS["small_caps"])
	
	if not to_latin:
		translation_map = {v: k for k, v in translation_map.items()}
	
	sorted_map = dict(sorted(translation_map.items(), key=lambda x: len(x[0]), reverse=True))
	result = text
	
	for source, target in sorted_map.items():
		upper_source = source.upper()
		upper_target = translation_map.get(upper_source, target.upper())
		result = result.replace(upper_source, upper_target)
		result = result.replace(source, target)
	
	return result

def capitalize_first_letter(text):
	for i, char in enumerate(text):
		if char.isalpha():
			return text[:i] + text[i].upper() + text[i+1:]
	return text

def format_text_basic(text, capitalize=False, add_dot=False):
	if not text or not isinstance(text, str):
		return text
	
	result = text
	
	if capitalize:
		sentence_pattern = re.compile(r'(?<=[\.\!\?])\s+')
		parts = sentence_pattern.split(result)
		formatted_parts = []
		for part in parts:
			stripped = part.lstrip()
			if not stripped:
				formatted_parts.append(part)
				continue
			leading_len = len(part) - len(stripped)
			leading = part[:leading_len]
			content = capitalize_first_letter(part[leading_len:])
			formatted_parts.append(leading + content)
		result = " ".join([p.strip() for p in formatted_parts]).strip()
	
	if add_dot and result and result[-1] not in ".!?":
		result = result + "."
	
	return result

def apply_writing_style(text, style="business"):
	if not text or not isinstance(text, str):
		return text
	
	style_dict = WRITING_STYLES.get(style, {})
	if not style_dict:
		return text
	
	result = text.lower()
	
	sorted_replacements = sorted(style_dict.items(), key=lambda x: len(x[0]), reverse=True)
	
	for original, replacement in sorted_replacements:
		pattern = r'\b' + re.escape(original) + r'\b'
		result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)
	
	return result

def fix_text_with_ai(text):
	try:
		api_url = "https://keyboard.yandex.net/gpt/fix"
		payload = {"text": text}
		headers = {
			"Content-Type": "application/json; charset=utf-8",
			"User-Agent": "okhttp/4.12.0",
			"Connection": "Keep-Alive",
			"Accept-Encoding": "gzip"
		}
		
		response = requests.post(
			api_url,
			headers=headers,
			data=json.dumps(payload, ensure_ascii=False).encode("utf-8"),
			timeout=8
		)
		
		if response.status_code == 200:
			data = response.json()
			fixed = data.get("response", "").strip()
			if fixed:
				return fixed
	except Exception:
		pass
	
	return text

def shorten_links(text):
	url_pattern = re.compile(r'https?://[^\s]+')
	
	def shorten_url(match):
		original_url = match.group(0)
		try:
			response = requests.get(
				f"https://tinyurl.com/api-create.php?url={original_url}",
				timeout=5
			)
			if response.status_code == 200:
				shortened = response.text.strip()
				if shortened and shortened.startswith("http"):
					return shortened
		except Exception:
			pass
		return original_url
	
	return url_pattern.sub(shorten_url, text)

def cleanup_links(text):
	tracking_params = [
		'utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content',
		'fbclid', 'gclid', 'yclid', 'msclkid', '_ga', 'mc_cid', 'mc_eid',
		'ref', 'referrer', 'source', 'campaign', 'affiliate', 'click_id',
		'igshid', 'igsh', 'si', 'feature', 'app', 'track', 'tracking'
	]
	
	url_pattern = re.compile(r'https?://[^\s]+')
	
	def clean_url(match):
		url = match.group(0)
		if '?' not in url:
			return url
		
		try:
			base_url, query_string = url.split('?', 1)
			params = query_string.split('&')
			cleaned_params = []
			
			for param in params:
				if '=' in param:
					key = param.split('=', 1)[0].lower()
					if key not in tracking_params:
						cleaned_params.append(param)
				else:
					cleaned_params.append(param)
			
			if cleaned_params:
				return base_url + '?' + '&'.join(cleaned_params)
			else:
				return base_url
		except Exception:
			return url
	
	return url_pattern.sub(clean_url, text)

class _ExToolTextHook:
	def __init__(self, plugin: "ExToolPlugin"):
		self.plugin = plugin
		try:
			self.style_span_class = jclass("org.telegram.ui.Components.TextStyleSpan")
			self.spannable_class = jclass("android.text.Spannable")
		except Exception:
			self.style_span_class = None
			self.spannable_class = None

	def after_hooked_method(self, param: Any) -> None:
		if not self.plugin.get_setting("enable_antispoiler", True):
			return
		
		try:
			text_content = None
			try:
				text_content = param.args[0]
			except Exception:
				return

			if text_content is None:
				return

			try:
				if self.spannable_class is not None and not self.spannable_class.isInstance(text_content):
					return
			except Exception:
				pass

			if self.style_span_class is None:
				return

			content_length = 0
			try:
				content_length = text_content.length()
			except Exception:
				return

			text_spans = None
			try:
				text_spans = text_content.getSpans(0, content_length, self.style_span_class)
			except Exception:
				return

			if not text_spans:
				return

			for current_span in list(text_spans):
				try:
					if current_span is None:
						continue
					has_spoiler = False
					try:
						has_spoiler = bool(current_span.isSpoiler())
					except Exception:
						try:
							span_flags = int(getattr(current_span, "getStyleFlags")())
							has_spoiler = (span_flags & 256) != 0
						except Exception:
							has_spoiler = False

					if not has_spoiler:
						continue
					try:
						text_content.removeSpan(current_span)
					except Exception:
						pass
				except Exception:
					pass
		except Exception:
			pass


class _ForwardLimitHook(MethodHook):
	def __init__(self, plugin):
		self.plugin = plugin
		self.limit_reached_hooked = False
	
	def after_hooked_method(self, param):
		try:
			if self.limit_reached_hooked:
				return
			
			chat_list_view = get_private_field(param.thisObject, "chatListView")
			if not chat_list_view:
				return
			
			selection_listener = get_private_field(chat_list_view, "multiSelectionListener")
			if not selection_listener:
				return
			
			limit_method = selection_listener.getClass().getMethod("limitReached")
			if limit_method:
				self.plugin.hook_method(limit_method, _BypassLimitReachedHook())
				self.limit_reached_hooked = True
				log("[ExTool] Hooked limitReached method")
		except Exception as e:
			log(f"[ExTool] Failed to hook limitReached: {e}")


class _BypassLimitReachedHook:
	def replace_hooked_method(self, param):
		return False


class _RoundVideoResolutionHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		setting_index = self.plugin.get_setting("round_video_resolution", 2)
		resolution_value = ROUND_VIDEO_RESOLUTIONS[setting_index]
		return jint(resolution_value)


class _RoundVideoBitrateHook:
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		setting_index = self.plugin.get_setting("round_video_bitrate", 2)
		bitrate_value = ROUND_VIDEO_BITRATES[setting_index]
		return jint(bitrate_value)


class _AddRecentGifReplacement(MethodReplacement):
	def __init__(self, plugin):
		self.plugin = plugin
	
	def replace_hooked_method(self, param):
		try:
			this_obj = param.thisObject
			document = param.args[0]
			
			if document is None:
				return None
			
			recentGifs_field = this_obj.getClass().getDeclaredField("recentGifs")
			recentGifs_field.setAccessible(True)
			recentGifs = recentGifs_field.get(this_obj)
			
			i2 = 0
			while i2 < recentGifs.size():
				document2 = recentGifs.get(i2)
				if document2.id == document.id:
					recentGifs.remove(i2)
					recentGifs.add(0, document2)
					break
				i2 += 1
			else:
				recentGifs.add(0, document)
			
			arrayList = ArrayList()
			arrayList.add(document)
			
			try:
				from java.lang import Class
				J_Boolean = jclass("java.lang.Boolean")
				ArrayList_class = Class.forName("java.util.ArrayList")
				processMethod = this_obj.getClass().getDeclaredMethod(
					"processLoadedRecentDocuments",
					Integer.TYPE,
					ArrayList_class,
					J_Boolean.TYPE,
					Integer.TYPE,
					J_Boolean.TYPE
				)
				processMethod.setAccessible(True)
				processMethod.invoke(this_obj, 0, arrayList, True, param.args[1], False)
			except Exception as e:
				log(f"[ExTool] Error calling processLoadedRecentDocuments: {e}")
		except Exception as e:
			log(f"[ExTool] Error in GIF replacement: {e}")
		
		return None


class _MessagesControllerInitHook(MethodHook):
	def __init__(self, plugin):
		self.plugin = plugin
	
	def after_hooked_method(self, param):
		try:
			this_obj = param.thisObject
			if this_obj:
				this_obj.savedGifsLimitDefault = 999999
				this_obj.savedGifsLimitPremium = 999999
				log("[ExTool] GIF limits set to unlimited")
		except Exception as e:
			log(f"[ExTool] Error setting GIF limits: {e}")


class ExToolPlugin(BasePlugin):
	def __init__(self):
		super().__init__()
		self.message_cache = {}
		self.hook_storage = []
		self._unlimited_pins_original_limits = []
	
	def _read_pin_limits(self) -> List[int]:
		controller = get_messages_controller()
		if controller is None:
			return []
		return [
			int(getattr(controller, "maxPinnedDialogsCountDefault", 0) or 0),
			int(getattr(controller, "maxPinnedDialogsCountPremium", 0) or 0),
			int(getattr(controller, "maxFolderPinnedDialogsCountDefault", 0) or 0),
			int(getattr(controller, "maxFolderPinnedDialogsCountPremium", 0) or 0),
			int(getattr(controller, "dialogFiltersPinnedLimitDefault", 0) or 0),
			int(getattr(controller, "dialogFiltersPinnedLimitPremium", 0) or 0),
		]
	
	def _apply_pin_limits(self, value: int) -> None:
		controller = get_messages_controller()
		if controller is None:
			return
		try:
			set_private_field(controller, "maxPinnedDialogsCountDefault", Integer(value))
			set_private_field(controller, "maxPinnedDialogsCountPremium", Integer(value))
			set_private_field(controller, "maxFolderPinnedDialogsCountDefault", Integer(value))
			set_private_field(controller, "maxFolderPinnedDialogsCountPremium", Integer(value))
			set_private_field(controller, "dialogFiltersPinnedLimitDefault", Integer(value))
			set_private_field(controller, "dialogFiltersPinnedLimitPremium", Integer(value))
			log(f"[ExTool] Applied unlimited pin limits: {value}")
		except Exception as e:
			log(f"[ExTool] Failed to apply pin limits: {e}")
	
	def _restore_pin_limits(self) -> None:
		if not self._unlimited_pins_original_limits:
			return
		controller = get_messages_controller()
		if controller is None:
			return
		try:
			d_def, d_pre, f_def, f_pre, df_def, df_pre = self._unlimited_pins_original_limits
			set_private_field(controller, "maxPinnedDialogsCountDefault", Integer(d_def))
			set_private_field(controller, "maxPinnedDialogsCountPremium", Integer(d_pre))
			set_private_field(controller, "maxFolderPinnedDialogsCountDefault", Integer(f_def))
			set_private_field(controller, "maxFolderPinnedDialogsCountPremium", Integer(f_pre))
			set_private_field(controller, "dialogFiltersPinnedLimitDefault", Integer(df_def))
			set_private_field(controller, "dialogFiltersPinnedLimitPremium", Integer(df_pre))
			log("[ExTool] Restored original pin limits")
		except Exception as e:
			log(f"[ExTool] Failed to restore pin limits: {e}")
	
	def _on_unlimited_pins_change(self, enabled: bool):
		try:
			if enabled:
				max_val = int(self.get_setting("unlimited_pins_max", 100000))
				self._apply_pin_limits(max_val)
			else:
				self._restore_pin_limits()
		except Exception as e:
			log(f"[ExTool] unlimited_pins_change error: {e}")
	
	def _on_unlimited_pins_max_change(self, new_value: str):
		try:
			value = int(new_value)
			if value < 1:
				value = 100000
			if self.get_setting("enable_unlimited_pins", False):
				self._apply_pin_limits(value)
		except Exception as e:
			log(f"[ExTool] unlimited_pins_max_change error: {e}")
	
	def _on_round_video_settings_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_round_video_settings()
			else:
				for hook_item in list(self.hook_storage):
					try:
						self.unhook_method(hook_item)
					except Exception:
						pass
				self.hook_storage.clear()
		except Exception as e:
			log(f"[ExTool] round_video_settings_change error: {e}")
	
	def _on_unlimited_gifs_change(self, enabled: bool):
		try:
			if enabled:
				self._hook_unlimited_gifs()
			else:
				mc = get_messages_controller()
				if mc:
					mc.savedGifsLimitDefault = 200
					mc.savedGifsLimitPremium = 400
					log("[ExTool] Restored default GIF limits")
		except Exception as e:
			log(f"[ExTool] unlimited_gifs_change error: {e}")
	
	def on_plugin_load(self):
		self._unlimited_pins_original_limits = self._read_pin_limits()
		
		if self.get_setting("enable_unlimited_pins", False):
			max_val = int(self.get_setting("unlimited_pins_max", 100000))
			self._apply_pin_limits(max_val)
		
		if self.get_setting("enable_antispoiler", True):
			try:
				self._hook_add_entities_methods()
				self._hook_media_spoilers()
			except Exception:
				pass
		
		if self.get_setting("enable_round_video_settings", False):
			self._hook_round_video_settings()
		
		if self.get_setting("enable_no_forward_limit", True):
			self._hook_forward_limit()
		
		if self.get_setting("enable_unlimited_gifs", False):
			self._hook_unlimited_gifs()
		
		self.add_menu_item(
			MenuItemData(
				menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
				text=get_locale("translate_menu"),
				on_click=self._process_menu_action,
				icon="msg_translate"
			)
		)
		
		self.add_on_send_message_hook()
	
	def _hook_forward_limit(self):
		try:
			chat_activity_class = find_class("org.telegram.ui.ChatActivity")
			if not chat_activity_class:
				return
			
			try:
				multi_selector_method = chat_activity_class.getClass().getDeclaredMethod("startMultiselect", Integer.TYPE)
				multi_selector_method.setAccessible(True)
				hook_ref = self.hook_method(multi_selector_method, _ForwardLimitHook(self))
				self.hook_storage.append(hook_ref)
				log("[ExTool] Hooked forward limit bypass")
			except Exception as e:
				log(f"[ExTool] Failed to hook forward limit: {e}")
		except Exception as e:
			log(f"[ExTool] Failed to setup forward limit hook: {e}")
	
	def _hook_round_video_settings(self):
		try:
			system_utils = find_class("com.exteragram.messenger.utils.SystemUtils")
			if not system_utils:
				return
			
			try:
				resolution_method = system_utils.getClass().getDeclaredMethod("getRoundVideoResolution")
				if resolution_method:
					hook_ref = self.hook_method(resolution_method, _RoundVideoResolutionHook(self))
					self.hook_storage.append(hook_ref)
			except Exception as e:
				log(f"[ExTool] Failed to hook round video resolution: {e}")
			
			try:
				bitrate_method = system_utils.getClass().getDeclaredMethod("getRoundVideoBitrate")
				if bitrate_method:
					hook_ref = self.hook_method(bitrate_method, _RoundVideoBitrateHook(self))
					self.hook_storage.append(hook_ref)
			except Exception as e:
				log(f"[ExTool] Failed to hook round video bitrate: {e}")
		except Exception as e:
			log(f"[ExTool] Failed to hook round video settings: {e}")
	
	def _hook_unlimited_gifs(self):
		try:
			mc = get_messages_controller()
			if mc:
				mc.savedGifsLimitDefault = 999999
				mc.savedGifsLimitPremium = 999999
				log("[ExTool] Set GIF limits immediately")
		except Exception as e:
			log(f"[ExTool] Could not set GIF limits immediately: {e}")
		
		try:
			MessagesController = find_class("org.telegram.messenger.MessagesController")
			if not MessagesController:
				log("[ExTool] MessagesController class not found!")
				return
			
			try:
				constructor = MessagesController.getClass().getDeclaredConstructor(Integer.TYPE)
				handler = _MessagesControllerInitHook(self)
				hook_ref = self.hook_method(constructor, handler)
				if hook_ref:
					self.hook_storage.append(hook_ref)
					log("[ExTool] Hooked MessagesController constructor for GIFs")
			except Exception as e:
				log(f"[ExTool] Error hooking MessagesController constructor: {e}")
			
			try:
				from java.lang import Class
				J_Boolean = jclass("java.lang.Boolean")
				MediaDataControllerClass = Class.forName("org.telegram.messenger.MediaDataController")
				TLRPCDocumentClass = Class.forName("org.telegram.tgnet.TLRPC$Document")
				
				add_gif_method = MediaDataControllerClass.getDeclaredMethod(
					"addRecentGif",
					TLRPCDocumentClass,
					Integer.TYPE,
					J_Boolean.TYPE
				)
				add_gif_method.setAccessible(True)
				
				gif_handler = _AddRecentGifReplacement(self)
				hook_ref = self.hook_method(add_gif_method, gif_handler)
				if hook_ref:
					self.hook_storage.append(hook_ref)
					log("[ExTool] Hooked addRecentGif method")
			except Exception as e:
				log(f"[ExTool] Error hooking addRecentGif: {e}")
		except Exception as e:
			log(f"[ExTool] Error in _hook_unlimited_gifs: {e}")

	def on_plugin_unload(self):
		self._restore_pin_limits()
		
		try:
			for hook_item in list(self.hook_storage):
				try:
					self.unhook_method(hook_item)
				except Exception:
					pass
			self.hook_storage.clear()
		except Exception:
			pass

	def create_settings(self):
		return [
			Header(text=get_locale("title")),
			Switch(
				key="auto_translate_enabled",
				text=get_locale("auto_translate"),
				default=True
			),
			Header(text=get_locale("style_header")),
			Selector(
				key="alphabet_style_type",
				text=get_locale("alphabet_style_type"),
				items=[get_locale("use_small_caps"), get_locale("use_fraktur"), get_locale("use_special"), get_locale("use_standard")],
				default=0
			),
			
			Header(text=""),
			Header(text=get_locale("signature_header")),
			Switch(
				key="enable_signature",
				text=get_locale("enable_signature"),
				default=False
			),
			Input(
				key="signature_line_1",
				text="–°—Ç—Ä–æ–∫–∞ 1",
				default=""
			),
			Input(
				key="signature_line_2",
				text="–°—Ç—Ä–æ–∫–∞ 2",
				default=""
			),
			Input(
				key="signature_line_3",
				text="–°—Ç—Ä–æ–∫–∞ 3",
				default=""
			),
			Input(
				key="signature_line_4",
				text="–°—Ç—Ä–æ–∫–∞ 4",
				default=""
			),
			Input(
				key="signature_line_5",
				text="–°—Ç—Ä–æ–∫–∞ 5",
				default=""
			),
			Switch(
				key="signature_at_start",
				text=get_locale("signature_start"),
				default=False
			),
			Switch(
				key="signature_at_end",
				text=get_locale("signature_end"),
				default=True
			),
			Switch(
				key="enable_for_private",
				text=get_locale("enable_for_private"),
				default=True
			),
			Switch(
				key="enable_for_groups",
				text=get_locale("enable_for_groups"),
				default=True
			),
			Switch(
				key="enable_for_channels",
				text=get_locale("enable_for_channels"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("antispoiler_header")),
			Switch(
				key="enable_antispoiler",
				text=get_locale("enable_antispoiler"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("link_cleaner_header")),
			Switch(
				key="enable_link_cleaner",
				text=get_locale("enable_link_cleaner"),
				default=False
			),
			Switch(
				key="enable_link_shortener",
				text=get_locale("enable_link_shortener"),
				default=False
			),
			Switch(
				key="enable_link_cleanup",
				text=get_locale("enable_link_cleanup"),
				default=False
			),
			
			Header(text=""),
			Header(text=get_locale("text_formatter_header")),
			Switch(
				key="enable_ai_correction",
				text=get_locale("enable_ai_correction"),
				default=False
			),
			Switch(
				key="enable_capitalize",
				text=get_locale("enable_capitalize"),
				default=False
			),
			Switch(
				key="enable_final_dot",
				text=get_locale("enable_final_dot"),
				default=False
			),
			
			Header(text=""),
			Header(text=get_locale("writing_style_header")),
			Switch(
				key="enable_writing_style",
				text=get_locale("enable_writing_style"),
				default=False
			),
			Selector(
				key="writing_style_type",
				text=get_locale("writing_style_type"),
				items=[get_locale("style_business"), get_locale("style_casual"), get_locale("style_official"), get_locale("style_bydlo")],
				default=0
			),
			
			Header(text=""),
			Header(text=get_locale("unlimited_pins_header")),
			Switch(
				key="enable_unlimited_pins",
				text=get_locale("enable_unlimited_pins"),
				default=False,
				on_change=self._on_unlimited_pins_change
			),
			Input(
				key="unlimited_pins_max",
				text=get_locale("unlimited_pins_max"),
				default="100000",
				on_change=self._on_unlimited_pins_max_change
			),
			
			Header(text=""),
			Header(text=get_locale("round_video_header")),
			Switch(
				key="enable_round_video_settings",
				text=get_locale("enable_round_video_settings"),
				default=False,
				on_change=self._on_round_video_settings_change
			),
			Selector(
				key="round_video_resolution",
				text=get_locale("round_video_resolution"),
				items=[str(r) for r in ROUND_VIDEO_RESOLUTIONS],
				default=2
			),
			Selector(
				key="round_video_bitrate",
				text=get_locale("round_video_bitrate"),
				items=[str(b) for b in ROUND_VIDEO_BITRATES],
				default=2
			),
			
			Header(text=""),
			Header(text=get_locale("forward_limit_header")),
			Switch(
				key="enable_no_forward_limit",
				text=get_locale("enable_no_forward_limit"),
				default=True
			),
			
			Header(text=""),
			Header(text=get_locale("unlimited_gifs_header")),
			Switch(
				key="enable_unlimited_gifs",
				text=get_locale("enable_unlimited_gifs"),
				default=False,
				on_change=self._on_unlimited_gifs_change
			)
		]
	
	def _hook_add_entities_methods(self) -> None:
		try:
			msg_obj_class = find_class("org.telegram.messenger.MessageObject")
			if msg_obj_class is None:
				return

			class_ref = msg_obj_class.getClass()
			method_list = []
			try:
				method_list = list(class_ref.getDeclaredMethods())
			except Exception:
				method_list = []

			hooks_installed = 0
			for method_item in method_list:
				try:
					if method_item is None:
						continue
					method_name = None
					try:
						method_name = method_item.getName()
					except Exception:
						method_name = None
					if method_name != "addEntitiesToText":
						continue
					method_item.setAccessible(True)
					hook_ref = self.hook_method(method_item, _ExToolTextHook(self))
					if hook_ref is not None:
						self.hook_storage.append(hook_ref)
						hooks_installed += 1
				except Exception:
					pass
		except Exception:
			pass

	def _hook_media_spoilers(self) -> None:
		try:
			msg_obj_class = find_class("org.telegram.messenger.MessageObject")
			if msg_obj_class is None:
				return
			class_ref = msg_obj_class.getClass()
			media_method = class_ref.getDeclaredMethod("hasMediaSpoilers")
			media_method.setAccessible(True)

			class _ExToolMediaHook:
				def __init__(self, plugin: "ExToolPlugin"):
					self.plugin = plugin

				def before_hooked_method(self, param: Any) -> None:
					if not self.plugin.get_setting("enable_antispoiler", True):
						return
					
					try:
						message_obj = param.thisObject
						msg_owner = None
						try:
							msg_owner = getattr(message_obj, "messageOwner")
						except Exception:
							msg_owner = None
						if msg_owner is None:
							msg_owner = get_private_field(message_obj, "messageOwner")
						if msg_owner is None:
							return

						msg_media = None
						try:
							msg_media = getattr(msg_owner, "media")
						except Exception:
							msg_media = None
						if msg_media is None:
							return

						has_spoiler_flag = False
						try:
							has_spoiler_flag = bool(getattr(msg_media, "spoiler"))
						except Exception:
							has_spoiler_flag = False

						if has_spoiler_flag:
							try:
								setattr(message_obj, "isMediaSpoilersRevealed", True)
							except Exception:
								pass
							try:
								setattr(message_obj, "isMediaSpoilersRevealedInSharedMedia", True)
							except Exception:
								pass
							try:
								setattr(message_obj, "revealingMediaSpoilers", False)
							except Exception:
								pass

							try:
								setattr(msg_media, "spoiler", False)
							except Exception:
								pass

							param.setResult(False)
					except Exception:
						pass

			hook_ref = self.hook_method(media_method, _ExToolMediaHook(self))
			if hook_ref is not None:
				self.hook_storage.append(hook_ref)
		except Exception:
			pass
	
	def _get_alphabet_style(self):
		style_index = self.get_setting("alphabet_style_type", 0)
		style_names = ["small_caps", "fraktur", "special", "standard"]
		if 0 <= style_index < len(style_names):
			return style_names[style_index]
		return "small_caps"
	
	def _determine_chat_type(self, peer_id):
		if peer_id > 0:
			return True, False, False
		
		try:
			msg_controller = get_messages_controller()
			chat_info = msg_controller.getChat(abs(peer_id))
			if chat_info:
				if isinstance(chat_info, TLRPC.TL_channel):
					if getattr(chat_info, "megagroup", False):
						return False, True, False
					else:
						return False, False, True
				if isinstance(chat_info, TLRPC.TL_chat):
					return False, True, False
		except:
			pass
		
		return False, False, False
	
	def _extract_peer_id(self, params_peer):
		try:
			if isinstance(params_peer, int):
				return params_peer
			return int(params_peer)
		except:
			pass
		
		try:
			msg_ctrl = get_messages_controller()
			if hasattr(msg_ctrl, "getPeerId"):
				peer_result = msg_ctrl.getPeerId(params_peer)
				if isinstance(peer_result, int):
					return peer_result
		except:
			pass
		
		try:
			if hasattr(params_peer, "user_id") and params_peer.user_id:
				return int(params_peer.user_id)
			if hasattr(params_peer, "chat_id") and params_peer.chat_id:
				return -int(abs(params_peer.chat_id))
			if hasattr(params_peer, "channel_id") and params_peer.channel_id:
				return int(f"-100{params_peer.channel_id}")
		except:
			pass
		
		return 0
	
	def _apply_signature(self, original_text, original_entities):
		enable_signature = self.get_setting("enable_signature", False)
		if not enable_signature:
			return original_text, original_entities
		
		signature_lines = []
		for i in range(1, 6):
			line = self.get_setting(f"signature_line_{i}", "").strip()
			if line:
				signature_lines.append(line)
		
		if not signature_lines:
			return original_text, original_entities
		
		signature_text = "\n".join(signature_lines)
		
		try:
			parsed = parse_markdown(signature_text)
			signature_plain = parsed.text
			signature_entities = parsed.entities
		except:
			signature_plain = signature_text
			signature_entities = []
		
		if not signature_plain:
			return original_text, original_entities
		
		signature_position_start = self.get_setting("signature_at_start", False)
		signature_position_end = self.get_setting("signature_at_end", True)
		
		combined_entities = ArrayList()
		
		def shift_entities(entity_list, source_list, text_offset):
			if not source_list:
				return
			for idx in range(source_list.size()):
				source_entity = source_list.get(idx)
				copied_entity = source_entity.getClass().getConstructor().newInstance()
				copied_entity.offset = source_entity.offset + text_offset
				copied_entity.length = source_entity.length
				if hasattr(source_entity, "url"):
					copied_entity.url = source_entity.url
				if hasattr(source_entity, "language"):
					copied_entity.language = source_entity.language
				if hasattr(source_entity, "user_id"):
					copied_entity.user_id = source_entity.user_id
				entity_list.add(copied_entity)
		
		def shift_parsed_entities(entity_list, parsed_list, text_offset):
			for parsed_item in parsed_list:
				tlrpc_entity = parsed_item.to_tlrpc_object()
				tlrpc_entity.offset += text_offset
				entity_list.add(tlrpc_entity)
		
		if signature_position_start and signature_position_end:
			result_text = f"{signature_plain}\n\n{original_text}\n\n{signature_plain}"
			shift_parsed_entities(combined_entities, signature_entities, 0)
			if original_entities:
				shift_entities(combined_entities, original_entities, len(signature_plain) + 2)
			shift_parsed_entities(combined_entities, signature_entities, len(signature_plain) + 2 + len(original_text) + 2)
		elif signature_position_start:
			result_text = f"{signature_plain}\n\n{original_text}"
			shift_parsed_entities(combined_entities, signature_entities, 0)
			if original_entities:
				shift_entities(combined_entities, original_entities, len(signature_plain) + 2)
		elif signature_position_end:
			result_text = f"{original_text}\n\n{signature_plain}"
			if original_entities:
				for idx in range(original_entities.size()):
					combined_entities.add(original_entities.get(idx))
			shift_parsed_entities(combined_entities, signature_entities, len(original_text) + 2)
		else:
			return original_text, original_entities
		
		return result_text, combined_entities

	def on_send_message_hook(self, account, params):
		if not hasattr(params, "message") or not params.message:
			return HookResult()
		
		stripped = params.message.lstrip()
		if stripped.startswith("/") or stripped.startswith("!"):
			return HookResult()
		
		target_peer = self._extract_peer_id(params.peer)
		is_private, is_group, is_channel = self._determine_chat_type(target_peer)
		
		private_enabled = self.get_setting("enable_for_private", True)
		groups_enabled = self.get_setting("enable_for_groups", True)
		channels_enabled = self.get_setting("enable_for_channels", True)
		
		chat_type_allowed = (is_private and private_enabled) or \
		                    (is_group and groups_enabled) or \
		                    (is_channel and channels_enabled)
		
		if chat_type_allowed:
			if self.get_setting("enable_writing_style", False):
				style_index = self.get_setting("writing_style_type", 0)
				style_names = ["business", "casual", "official", "bydlo"]
				if 0 <= style_index < len(style_names):
					params.message = apply_writing_style(params.message, style_names[style_index])
			
			if self.get_setting("enable_ai_correction", False):
				params.message = fix_text_with_ai(params.message)
			
			capitalize_enabled = self.get_setting("enable_capitalize", False)
			final_dot_enabled = self.get_setting("enable_final_dot", False)
			if capitalize_enabled or final_dot_enabled:
				params.message = format_text_basic(params.message, capitalize_enabled, final_dot_enabled)
			
			if self.get_setting("auto_translate_enabled", True):
				current_style = self._get_alphabet_style()
				params.message = translate_text(params.message, to_latin=True, style=current_style)
			
			params.message, params.entities = self._apply_signature(params.message, params.entities)
		
		if self.get_setting("enable_link_cleanup", False):
			params.message = cleanup_links(params.message)
		
		if self.get_setting("enable_link_shortener", False):
			params.message = shorten_links(params.message)
		
		if self.get_setting("enable_link_cleaner", False):
			params.message = params.message.replace("https://", "").replace("http://", "")
		
		return HookResult(strategy=HookStrategy.MODIFY, params=params)

	def _process_menu_action(self, context):
		target_message = context.get("message")
		if not target_message:
			return
		
		message_id = target_message.getId()
		message_text = target_message.messageText.toString()
		
		if not message_text:
			return
		
		current_fragment = get_last_fragment()
		
		if message_id in self.message_cache and self.message_cache[message_id][1] == current_fragment:
			restored_text = self.message_cache[message_id][0]
			del self.message_cache[message_id]
		else:
			active_style = self._get_alphabet_style()
			restored_text = translate_text(message_text, to_latin=False, style=active_style)
			self.message_cache[message_id] = (message_text, current_fragment)
		
		run_on_ui_thread(lambda: self._refresh_message_view(target_message, restored_text))

	def _refresh_message_view(self, message, new_text):
		if not new_text or not isinstance(new_text, str) or not new_text.strip():
			BulletinHelper.show_error(get_locale("error"))
			return
		
		message.applyNewText(new_text)
		message.forceUpdate = True
		
		active_fragment = get_last_fragment()
		if isinstance(active_fragment, ChatActivity):
			message_cell = active_fragment.findMessageCell(message.getId(), False)
			if message_cell:
				message_cell.getMessageObject().applyNewText(new_text)
				message_cell.getMessageObject().forceUpdate = True
				message_cell.invalidate()
				BulletinHelper.show_success(get_locale("success"))
