"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 Кража кода без указания авторства является публичным неуважением к работе автора.
  Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
   Берёте — но делайте это с уважением :)
"""

from base_plugin import BasePlugin
from client_utils import get_last_fragment, get_messages_controller, get_user_config, run_on_queue
from android_utils import run_on_ui_thread, OnClickListener, OnLongClickListener
from ui.settings import Header, Switch, Selector, Input, Text, Divider
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from org.telegram.messenger import AndroidUtilities, LocaleController, R, DialogObject, UserObject, ChatObject, BotWebViewVibrationEffect
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import Theme, ActionBarPopupWindow
from org.telegram.ui.Components import LineProgressView
from android.graphics.drawable import GradientDrawable
from android.os import Bundle
from android.util import TypedValue
from android.view import Gravity, ViewGroup, View
from android.widget import LinearLayout, TextView, CheckBox

__id__ = "dialogs_cleanup"
__name__ = "Dialogs Cleanup"
__description__ = "Удаляет чаты, каналы и ботов по заданным фильтрам"
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "2.0 [visual+preview]"
__icon__ = "LightningBug/1"
__min_version__ = "11.12.0"

DEFAULT_MAX_COUNT = "20"
DEFAULT_QUERY = ""
DEFAULT_COOLDOWN_MS = "250"
DEFAULT_ORDER = 0
DEFAULT_INCLUDE_ARCHIVED = False
DEFAULT_EXCLUDE_PINNED = True
DEFAULT_ONLY_UNREAD = False
DEFAULT_EXCLUDE_CONTACTS = True
DEFAULT_REVOKE_PRIVATE = False
DEFAULT_INCLUDE_PRIVATE = True
DEFAULT_INCLUDE_GROUPS = True
DEFAULT_INCLUDE_CHANNELS = True
DEFAULT_INCLUDE_BOTS = True

LOCALIZATION = {
    "ru": {
        "plugin_description": "Удаление чатов, каналов и ботов по фильтрам с предварительным просмотром.",
        "types_header": "Типы",
        "type_private": "Личные чаты",
        "type_groups": "Группы",
        "type_channels": "Каналы",
        "type_bots": "Боты",
        "filters_header": "Фильтры",
        "query_label": "Имя содержит",
        "query_subtext": "Подстрока для поиска",
        "only_unread": "Только непрочитанные",
        "exclude_pinned": "Исключать закрепленные",
        "exclude_contacts": "Исключать контакты",
        "include_archived": "Включать архив",
        "order_label": "Порядок",
        "order_newest": "Новые -> старые",
        "order_oldest": "Старые -> новые",
        "action_header": "Действия",
        "open_panel": "Открыть панель фильтрации",
        "run_now": "Удалить сейчас",
        "cooldown_label": "Задержка между удалениями (мс)",
        "cooldown_subtext": "0 = без задержки",
        "max_count_label": "Лимит удалений",
        "max_count_subtext": "Максимум за один запуск",
        "revoke_private": "Удалять для обеих сторон",
        "warning": "Удаление необратимо. Проверьте фильтры перед запуском.",
        "loading": "Сбор диалогов...",
        "no_context": "Не удалось получить контекст",
        "busy": "Операция уже выполняется",
        "empty": "Подходящих диалогов нет",
        "panel_title": "Фильтрованная очистка",
        "panel_found_label": "Найдено",
        "panel_selected_label": "К удалению",
        "panel_limit_label": "Лимит",
        "panel_found": "Найдено: {count}",
        "panel_selected": "К удалению: {count}",
        "panel_filters": "Фильтры: {filters}",
        "panel_order": "Порядок: {order}",
        "list_header": "Список диалогов",
        "list_header_count": "Список диалогов ({count})",
        "panel_list_hint": "Нажатие по строке - выбор. Удержание названия - предпросмотр чата.",
        "panel_warning_compact": "Удаление необратимо. Перепроверьте выбор.",
        "select_all": "Выбрать все",
        "clear_all": "Снять все",
        "select_unread": "Непрочит.",
        "delete": "Удалить",
        "cancel": "Отмена",
        "confirm_title": "Подтвердите удаление",
        "confirm_message": "Удалить {count} диалогов? Действие нельзя отменить.",
        "deleting": "Удаление диалогов...",
        "progress_text": "Удалено: {done}/{total}",
        "cooldown_wait": "Следующий через {sec} сек",
        "done": "Удалено диалогов: {count}",
        "invalid_number": "Некорректное число",
        "limit_exceeded": "Выбрано {count}, лимит {limit}.",
        "type_private_short": "личные",
        "type_groups_short": "группы",
        "type_channels_short": "каналы",
        "type_bots_short": "боты",
        "summary_unread": "непрочитанные",
        "summary_no_pinned": "без закрепленных",
        "summary_no_contacts": "без контактов",
        "summary_archive": "с архивом",
        "type_private_label": "личные",
        "type_groups_label": "группы",
        "type_channels_label": "каналы",
        "type_bots_label": "боты",
        "tag_unread": "непрочит.",
        "tag_pinned": "закреп.",
        "preview_failed": "Не удалось открыть предпросмотр",
    },
    "en": {
        "plugin_description": "Filtered cleanup for chats, channels and bots.",
        "types_header": "Types",
        "type_private": "Private chats",
        "type_groups": "Groups",
        "type_channels": "Channels",
        "type_bots": "Bots",
        "filters_header": "Filters",
        "query_label": "Name contains",
        "query_subtext": "Substring to match",
        "only_unread": "Unread",
        "exclude_pinned": "Exclude pinned",
        "exclude_contacts": "Exclude contacts",
        "include_archived": "Include archived",
        "order_label": "Order",
        "order_newest": "Newest -> oldest",
        "order_oldest": "Oldest -> newest",
        "action_header": "Actions",
        "open_panel": "Open filter panel",
        "run_now": "Delete now",
        "cooldown_label": "Cooldown between deletions (ms)",
        "cooldown_subtext": "0 = no delay",
        "max_count_label": "Deletion limit",
        "max_count_subtext": "Max per run",
        "revoke_private": "Delete for both sides",
        "warning": "Deletion is irreversible. Review filters first.",
        "loading": "Collecting dialogs...",
        "no_context": "Failed to get context",
        "busy": "Operation already running",
        "empty": "No matching dialogs",
        "panel_title": "Filtered cleanup",
        "panel_found_label": "Found",
        "panel_selected_label": "To delete",
        "panel_limit_label": "Limit",
        "panel_found": "Found: {count}",
        "panel_selected": "To delete: {count}",
        "panel_filters": "Filters: {filters}",
        "panel_order": "Order: {order}",
        "list_header": "Dialogs list",
        "list_header_count": "Dialogs list ({count})",
        "panel_list_hint": "Tap row to select. Long press on title to open chat preview.",
        "panel_warning_compact": "Deletion is irreversible. Recheck selection before proceeding.",
        "select_all": "Select all",
        "clear_all": "Clear all",
        "select_unread": "Unread only",
        "delete": "Delete",
        "cancel": "Cancel",
        "confirm_title": "Confirm deletion",
        "confirm_message": "Delete {count} dialogs? This cannot be undone.",
        "deleting": "Deleting dialogs...",
        "progress_text": "Deleted: {done}/{total}",
        "cooldown_wait": "Next in {sec} sec",
        "done": "Deleted dialogs: {count}",
        "invalid_number": "Invalid number",
        "limit_exceeded": "Selected {count}, limit {limit}.",
        "type_private_short": "private",
        "type_groups_short": "groups",
        "type_channels_short": "channels",
        "type_bots_short": "bots",
        "summary_unread": "unread",
        "summary_no_pinned": "no-pinned",
        "summary_no_contacts": "no-contacts",
        "summary_archive": "archive",
        "type_private_label": "private",
        "type_groups_label": "groups",
        "type_channels_label": "channels",
        "type_bots_label": "bots",
        "tag_unread": "unread",
        "tag_pinned": "pinned",
        "preview_failed": "Failed to open preview",
    },
}


class LocalizedText:
    def __init__(self, localization_map):
        self._map = localization_map

    def _lang(self):
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            if lang and str(lang).lower().startswith("ru"):
                return "ru"
        except Exception:
            pass
        return "en"

    def t(self, key):
        lang = self._lang()
        try:
            if lang in self._map and key in self._map[lang]:
                return self._map[lang][key]
            if "ru" in self._map and key in self._map["ru"]:
                return self._map["ru"][key]
            if "en" in self._map and key in self._map["en"]:
                return self._map["en"][key]
        except Exception:
            pass
        return key


_t = LocalizedText(LOCALIZATION).t


class FilteredDialogCleanupPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._busy = False

    def on_plugin_load(self):
        try:
            self.description = _t("plugin_description")
        except Exception:
            pass

    def create_settings(self):
        return [
            Header(text=_t("types_header")),
            Switch(
                key="include_private",
                text=_t("type_private"),
                default=DEFAULT_INCLUDE_PRIVATE,
                icon="msg_contacts",
            ),
            Switch(
                key="include_groups",
                text=_t("type_groups"),
                default=DEFAULT_INCLUDE_GROUPS,
                icon="msg_groups",
            ),
            Switch(
                key="include_channels",
                text=_t("type_channels"),
                default=DEFAULT_INCLUDE_CHANNELS,
                icon="msg_channel",
            ),
            Switch(
                key="include_bots",
                text=_t("type_bots"),
                default=DEFAULT_INCLUDE_BOTS,
                icon="msg_bot",
            ),
            Divider(),
            Header(text=_t("filters_header")),
            Input(
                key="query",
                text=_t("query_label"),
                default=DEFAULT_QUERY,
                subtext=_t("query_subtext"),
                icon="msg_search",
            ),
            Switch(
                key="only_unread",
                text=_t("only_unread"),
                default=DEFAULT_ONLY_UNREAD,
                icon="menu_hide_gift",
            ),
            Switch(
                key="exclude_pinned",
                text=_t("exclude_pinned"),
                default=DEFAULT_EXCLUDE_PINNED,
                icon="msg_pin",
            ),
            Switch(
                key="exclude_contacts",
                text=_t("exclude_contacts"),
                default=DEFAULT_EXCLUDE_CONTACTS,
                icon="msg_contacts",
            ),
            Switch(
                key="include_archived",
                text=_t("include_archived"),
                default=DEFAULT_INCLUDE_ARCHIVED,
                icon="msg_archive",
            ),
            Selector(
                key="order",
                text=_t("order_label"),
                default=DEFAULT_ORDER,
                items=[_t("order_newest"), _t("order_oldest")],
                icon="msg_list_solar",
            ),
            Divider(),
            Header(text=_t("action_header")),
            Input(
                key="max_count",
                text=_t("max_count_label"),
                default=DEFAULT_MAX_COUNT,
                subtext=_t("max_count_subtext"),
                icon="msg_delete",
                on_change=self._on_max_count_change,
            ),
            Input(
                key="cooldown_ms",
                text=_t("cooldown_label"),
                default=DEFAULT_COOLDOWN_MS,
                subtext=_t("cooldown_subtext"),
                icon="msg_contacts_time_solar",
                on_change=self._on_cooldown_change,
            ),
            Switch(
                key="revoke_private",
                text=_t("revoke_private"),
                default=DEFAULT_REVOKE_PRIVATE,
                icon="menu_feature_tradable",
            ),
            Text(
                text=_t("open_panel"),
                icon="msg_delete",
                accent=True,
                on_click=self._open_panel,
            ),
            Text(
                text=_t("run_now"),
                icon="msg_delete",
                red=True,
                on_click=self._run_now,
            ),
            Divider(text=_t("warning")),
        ]

    def _on_max_count_change(self, value):
        count = self._parse_int(value, 1, 1, 10000)
        self.set_setting("max_count", str(count))

    def _on_cooldown_change(self, value):
        cooldown_ms = self._parse_int(value, 0, 0, 60000)
        self.set_setting("cooldown_ms", str(cooldown_ms))

    def _parse_int(self, value, default, min_value, max_value):
        try:
            parsed = int(str(value).strip())
        except Exception:
            return default
        return max(min_value, min(max_value, parsed))

    def _open_panel(self, _=None):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return

        fragment = get_last_fragment()
        if not fragment:
            BulletinHelper.show_error(_t("no_context"))
            return
        context = fragment.getParentActivity()
        if not context:
            BulletinHelper.show_error(_t("no_context"))
            return

        loading = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        loading.set_title(_t("loading"))
        loading.show()

        def on_ready(result):
            def ui():
                try:
                    loading.dismiss()
                except Exception:
                    pass
                self._show_panel(context, result)

            run_on_ui_thread(ui)

        run_on_queue(lambda: on_ready(self._collect_filtered_dialogs()))

    def _run_now(self, _=None):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return
        fragment = get_last_fragment()
        if not fragment:
            BulletinHelper.show_error(_t("no_context"))
            return
        context = fragment.getParentActivity()
        if not context:
            BulletinHelper.show_error(_t("no_context"))
            return

        result = self._collect_filtered_dialogs()
        if not result:
            BulletinHelper.show_info(_t("empty"))
            return
        max_count = self._get_max_count()
        targets = result[:max_count]
        self._confirm_delete(context, targets)

    def _show_panel(self, context, dialogs):
        if not dialogs:
            BulletinHelper.show_info(_t("empty"))
            return

        panel_state = {"dialog": None}
        max_count = self._get_max_count()
        for index, info in enumerate(dialogs):
            info["selected"] = index < max_count

        order_text = _t("order_newest") if self._get_order() == 0 else _t("order_oldest")
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        padding_h = AndroidUtilities.dp(20)
        container.setPadding(padding_h, AndroidUtilities.dp(8), padding_h, AndroidUtilities.dp(12))

        stats_row = LinearLayout(context)
        stats_row.setOrientation(LinearLayout.HORIZONTAL)
        stats_row.setGravity(Gravity.START)

        def build_stat(value_text, label_text, value_color_key):
            block = LinearLayout(context)
            block.setOrientation(LinearLayout.VERTICAL)

            value_view = TextView(context)
            value_view.setText(value_text)
            value_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            value_view.setGravity(Gravity.START)
            try:
                value_view.setTextColor(Theme.getColor(value_color_key))
                value_view.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except Exception:
                pass

            label_view = TextView(context)
            label_view.setText(label_text)
            label_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
            label_view.setGravity(Gravity.START)
            try:
                label_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            except Exception:
                pass

            block.addView(value_view)
            block.addView(label_view)
            return block, value_view

        found_block, _ = build_stat(
            str(len(dialogs)),
            _t("panel_found_label"),
            Theme.key_dialogTextBlack,
        )
        selected_block, selected_value = build_stat(
            "0",
            _t("panel_selected_label"),
            Theme.key_windowBackgroundWhiteBlueText,
        )
        limit_block, _ = build_stat(
            str(max_count),
            _t("panel_limit_label"),
            Theme.key_dialogTextBlack,
        )

        warning_note = TextView(context)
        warning_note.setText(_t("panel_warning_compact"))
        warning_note.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        warning_note.setGravity(Gravity.START)
        warning_note.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(9), AndroidUtilities.dp(12), AndroidUtilities.dp(9))
        try:
            warning_color = Theme.getColor(Theme.key_text_RedBold)
        except Exception:
            warning_color = self._to_java_color_int(0xFFD94040)
        warning_bg = GradientDrawable()
        warning_bg.setCornerRadius(AndroidUtilities.dp(12))
        warning_bg.setColor(self._alpha_color(warning_color, 22))
        warning_bg.setStroke(AndroidUtilities.dp(1), self._alpha_color(warning_color, 120))
        warning_note.setBackground(warning_bg)
        try:
            warning_note.setTextColor(self._to_java_color_int(warning_color))
        except Exception:
            pass

        filters = TextView(context)
        filters.setText(
            _t("panel_filters").format(filters=self._filters_summary())
            + "\n"
            + _t("panel_order").format(order=order_text)
        )
        filters.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        filters.setGravity(Gravity.START)
        try:
            filters.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        actions_row = LinearLayout(context)
        actions_row.setOrientation(LinearLayout.HORIZONTAL)
        actions_row.setGravity(Gravity.START)

        select_all = self._create_action_chip(context, _t("select_all"), Theme.key_windowBackgroundWhiteBlueText, filled=True)
        clear_all = self._create_action_chip(context, _t("clear_all"), Theme.key_windowBackgroundWhiteGrayText, filled=False)
        select_unread = self._create_action_chip(context, _t("select_unread"), Theme.key_windowBackgroundWhiteBlueText, filled=False)

        list_header = TextView(context)
        list_header.setText(_t("list_header_count").format(count=len(dialogs)))
        list_header.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        list_header.setGravity(Gravity.START)
        try:
            list_header.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            list_header.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
        except Exception:
            pass

        list_hint = TextView(context)
        list_hint.setText(_t("panel_list_hint"))
        list_hint.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        list_hint.setGravity(Gravity.START)
        try:
            list_hint.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        list_container = LinearLayout(context)
        list_container.setOrientation(LinearLayout.VERTICAL)
        rows = []
        selected_state = {"count": 0}

        def on_limit_hit():
            try:
                AndroidUtilities.shakeView(selected_value)
            except Exception:
                pass
            try:
                BotWebViewVibrationEffect.APP_ERROR.vibrate()
            except Exception:
                pass

        def update_selected_count():
            selected = len([item for item in dialogs if item.get("selected")])
            selected_state["count"] = selected
            selected_value.setText(str(selected))
            limit_reached = max_count > 0 and selected >= max_count
            try:
                if limit_reached:
                    selected_value.setTextColor(Theme.getColor(Theme.key_text_RedBold))
                else:
                    selected_value.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueText))
            except Exception:
                pass
            for item in rows:
                is_selected = bool(item["info"].get("selected"))
                allow = (not limit_reached) or is_selected
                try:
                    item["refresh"](allow)
                except Exception:
                    pass

        def apply_selection(value):
            if value and max_count > 0:
                for idx, info in enumerate(dialogs):
                    info["selected"] = idx < max_count
            else:
                for info in dialogs:
                    info["selected"] = value
            for item in rows:
                item["cb"].setChecked(bool(item["info"].get("selected")))
                item["refresh"](True)
            if value and max_count > 0 and len(dialogs) > max_count:
                on_limit_hit()
            update_selected_count()

        def select_unread_click(_=None):
            selected = 0
            unread_total = 0
            for info in dialogs:
                has_unread = bool(info.get("unread", False))
                if has_unread:
                    unread_total += 1
                can_take = max_count <= 0 or selected < max_count
                new_value = has_unread and can_take
                info["selected"] = new_value
                if new_value:
                    selected += 1
            for item in rows:
                item["cb"].setChecked(bool(item["info"].get("selected")))
                item["refresh"](True)
            if max_count > 0 and unread_total > max_count:
                on_limit_hit()
            update_selected_count()

        def select_all_click(_=None):
            apply_selection(True)

        def clear_all_click(_=None):
            apply_selection(False)

        def on_row_preview(info):
            def ui():
                try:
                    if panel_state["dialog"] is not None:
                        panel_state["dialog"].dismiss()
                except Exception:
                    pass
                self._open_dialog_preview(info)

            run_on_ui_thread(ui)
            return True

        select_all.setOnClickListener(OnClickListener(select_all_click))
        clear_all.setOnClickListener(OnClickListener(clear_all_click))
        select_unread.setOnClickListener(OnClickListener(select_unread_click))

        for info in dialogs:
            row, cb, refresh = self._build_dialog_row(
                context,
                info,
                update_selected_count,
                lambda: max_count <= 0 or selected_state["count"] < max_count,
                on_limit_hit,
                on_row_preview,
            )
            rows.append({"cb": cb, "info": info, "row": row, "refresh": refresh})
            row_lp = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT,
            )
            row_lp.bottomMargin = AndroidUtilities.dp(6)
            list_container.addView(row, row_lp)

        lp_full = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_block = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_block.setMargins(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6))
        lp_stats = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_stats.setMargins(0, 0, 0, AndroidUtilities.dp(4))
        lp_warning = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_warning.setMargins(0, AndroidUtilities.dp(2), 0, AndroidUtilities.dp(8))
        lp_list = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_list.setMargins(0, AndroidUtilities.dp(2), 0, AndroidUtilities.dp(2))

        stat_lp = LinearLayout.LayoutParams(
            0,
            ViewGroup.LayoutParams.WRAP_CONTENT,
            1.0,
        )
        stat_lp.rightMargin = AndroidUtilities.dp(12)
        stats_row.addView(found_block, stat_lp)
        stats_row.addView(selected_block, stat_lp)
        stats_row.addView(
            limit_block,
            LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0),
        )

        container.addView(stats_row, lp_stats)
        container.addView(warning_note, lp_warning)
        container.addView(filters, lp_block)
        container.addView(actions_row, lp_block)
        container.addView(list_header, lp_block)
        container.addView(list_hint, lp_stats)
        container.addView(list_container, lp_list)

        lp_action = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_action.rightMargin = AndroidUtilities.dp(8)
        actions_row.addView(select_all, lp_action)
        clear_lp = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        clear_lp.rightMargin = AndroidUtilities.dp(8)
        actions_row.addView(clear_all, clear_lp)
        actions_row.addView(
            select_unread,
            LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT,
            ),
        )

        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(_t("panel_title"))
        builder.set_view(container)
        builder.set_positive_button(
            _t("delete"),
            lambda d, _w: (
                d.dismiss(),
                self._confirm_selected(context, dialogs, max_count),
            ),
        )
        builder.set_negative_button(_t("cancel"), lambda d, _w: d.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        try:
            builder.set_blurred_background(True)
        except Exception:
            pass
        try:
            top_bg = Theme.getColor(Theme.key_dialogTopBackground)
            builder.set_top_image(R.drawable.msg_delete, top_bg)
        except Exception:
            pass
        panel_state["dialog"] = builder
        update_selected_count()
        builder.show()

    def _confirm_delete(self, context, dialogs):
        if not dialogs:
            BulletinHelper.show_info(_t("empty"))
            return

        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(_t("confirm_title"))
        builder.set_message(_t("confirm_message").format(count=len(dialogs)))
        builder.set_positive_button(
            _t("delete"),
            lambda d, _w: (
                d.dismiss(),
                self._run_delete(context, dialogs),
            ),
        )
        builder.set_negative_button(_t("cancel"), lambda d, _w: d.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        try:
            top_bg = Theme.getColor(Theme.key_dialogTopBackground)
            builder.set_top_image(R.drawable.msg_delete, top_bg)
        except Exception:
            pass
        builder.show()

    def _confirm_selected(self, context, dialogs, max_count):
        selected = [item for item in dialogs if item.get("selected")]
        if not selected:
            BulletinHelper.show_info(_t("empty"))
            return
        if max_count > 0 and len(selected) > max_count:
            BulletinHelper.show_error(_t("limit_exceeded").format(count=len(selected), limit=max_count))
            return
        self._confirm_delete(context, selected)

    def _run_delete(self, context, dialogs):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return

        self._busy = True
        revoke_private = bool(self.get_setting("revoke_private", DEFAULT_REVOKE_PRIVATE))
        cooldown_ms = self._get_cooldown_ms()

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        padding_h = AndroidUtilities.dp(20)
        container.setPadding(padding_h, AndroidUtilities.dp(8), padding_h, AndroidUtilities.dp(12))

        progress_text = TextView(context)
        progress_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        progress_text.setGravity(Gravity.START)
        try:
            progress_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        except Exception:
            pass

        progress_bar = LineProgressView(context)
        try:
            progress_bar.setProgressColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            progress_bar.setBackColor(Theme.getColor(Theme.key_dialogLineProgressBackground))
        except Exception:
            pass
        progress_bar.setProgress(0.0, False)

        countdown_text = TextView(context)
        countdown_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        countdown_text.setGravity(Gravity.START)
        try:
            countdown_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        lp_full = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_full.setMargins(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6))
        lp_bar = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            AndroidUtilities.dp(6),
        )
        lp_bar.setMargins(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))

        container.addView(progress_text, lp_full)
        container.addView(progress_bar, lp_bar)
        container.addView(countdown_text, lp_full)

        progress_dialog = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        progress_dialog.set_title(_t("deleting"))
        progress_dialog.set_view(container)
        progress_dialog.set_cancelable(False)
        progress_dialog.show()

        progress_state = {"token": 0}

        def update_progress(done, total):
            def ui():
                progress_text.setText(_t("progress_text").format(done=done, total=total))
                if total > 0:
                    progress_bar.setProgress(float(done) / float(total), True)
            run_on_ui_thread(ui)

        def start_countdown(seconds):
            progress_state["token"] += 1
            token = progress_state["token"]
            seconds = max(0, int(seconds))

            def tick(remaining):
                if token != progress_state["token"]:
                    return
                if remaining <= 0:
                    countdown_text.setText("")
                    return
                countdown_text.setText(_t("cooldown_wait").format(sec=remaining))
                run_on_ui_thread(lambda: tick(remaining - 1), delay=1000)

            run_on_ui_thread(lambda: tick(seconds))

        def finish(message, success):
            def ui():
                try:
                    progress_state["token"] += 1
                    progress_dialog.dismiss()
                except Exception:
                    pass
                if success:
                    BulletinHelper.show_success(message)
                else:
                    BulletinHelper.show_error(message)
                self._busy = False

            run_on_ui_thread(ui)

        update_progress(0, len(dialogs))
        start_countdown(0)

        def delete_next(index, deleted):
            if index >= len(dialogs):
                finish(_t("done").format(count=deleted), True)
                return

            did = dialogs[index]["id"]

            def do_delete():
                mc = None
                try:
                    mc = get_messages_controller()
                except Exception:
                    mc = None
                if mc is None:
                    return

                if did < 0:
                    chat = None
                    try:
                        chat = mc.getChat(-did)
                    except Exception:
                        chat = None

                    if chat is not None and not ChatObject.isNotInChat(chat):
                        try:
                            me_user = get_user_config().getCurrentUser()
                            if me_user is None:
                                me_id = int(get_user_config().getClientUserId())
                                me_user = mc.getUser(me_id)
                            mc.deleteParticipantFromChat(-did, me_user, None, False, False)
                            return
                        except Exception:
                            pass

                try:
                    mc.deleteDialog(did, 0, revoke_private if did > 0 else False)
                except Exception:
                    pass

            run_on_ui_thread(do_delete)
            new_deleted = deleted + 1
            update_progress(new_deleted, len(dialogs))
            remaining = len(dialogs) - new_deleted
            if remaining > 0 and cooldown_ms > 0:
                seconds = int((int(cooldown_ms) + 999) / 1000)
                start_countdown(seconds)
            run_on_queue(lambda: delete_next(index + 1, new_deleted), delay=cooldown_ms)

        run_on_queue(lambda: delete_next(0, 0))

    def _collect_filtered_dialogs(self):
        mc = get_messages_controller()
        dialogs = []
        dialogs.extend(self._to_list_safe(self._get_dialogs_by_folder(mc, 0)))
        if self._get_include_archived():
            dialogs.extend(self._to_list_safe(self._get_dialogs_by_folder(mc, 1)))

        query = str(self.get_setting("query", DEFAULT_QUERY) or "").strip().lower()
        only_unread = bool(self.get_setting("only_unread", DEFAULT_ONLY_UNREAD))
        exclude_pinned = bool(self.get_setting("exclude_pinned", DEFAULT_EXCLUDE_PINNED))
        exclude_contacts = bool(self.get_setting("exclude_contacts", DEFAULT_EXCLUDE_CONTACTS))

        include_private = bool(self.get_setting("include_private", DEFAULT_INCLUDE_PRIVATE))
        include_groups = bool(self.get_setting("include_groups", DEFAULT_INCLUDE_GROUPS))
        include_channels = bool(self.get_setting("include_channels", DEFAULT_INCLUDE_CHANNELS))
        include_bots = bool(self.get_setting("include_bots", DEFAULT_INCLUDE_BOTS))

        result = []
        for dialog in dialogs:
            info = self._extract_dialog_info(mc, dialog, exclude_contacts)
            if not info:
                continue
            dtype = info["type"]
            if dtype == "private" and not include_private:
                continue
            if dtype == "group" and not include_groups:
                continue
            if dtype == "channel" and not include_channels:
                continue
            if dtype == "bot" and not include_bots:
                continue

            if exclude_pinned and info.get("pinned", False):
                continue
            if only_unread and not info.get("unread", False):
                continue
            if query and query not in info.get("title_lower", ""):
                continue

            result.append(info)

        order = self._get_order()
        result.sort(key=lambda item: item.get("last_date", 0), reverse=(order == 0))
        return result

    def _get_dialogs_by_folder(self, mc, folder_id):
        try:
            return mc.getDialogs(folder_id)
        except Exception:
            return []

    def _to_list_safe(self, java_list):
        items = []
        try:
            size = java_list.size()
        except Exception:
            return items
        for i in range(size):
            try:
                items.append(java_list.get(i))
            except Exception:
                continue
        return items

    def _extract_dialog_info(self, mc, dialog, exclude_contacts):
        if dialog is None:
            return None
        try:
            did = dialog.id
        except Exception:
            return None
        if did == 0:
            return None
        if DialogObject.isFolderDialogId(did) or DialogObject.isEncryptedDialog(did):
            return None

        pinned = bool(getattr(dialog, "pinned", False))
        unread = False
        try:
            unread = int(getattr(dialog, "unread_count", 0)) > 0 or bool(getattr(dialog, "unread_mark", False))
        except Exception:
            unread = False

        last_date = 0
        try:
            last_date = int(getattr(dialog, "last_message_date", 0))
        except Exception:
            last_date = 0

        if did > 0:
            user = mc.getUser(did)
            if user is None:
                return None
            if UserObject.isUserSelf(user) or UserObject.isReplyUser(user):
                return None
            if exclude_contacts and UserObject.isContact(user):
                return None
            if UserObject.isBot(user):
                dtype = "bot"
            else:
                dtype = "private"
            title = UserObject.getUserName(user)
        else:
            chat = mc.getChat(-did)
            if chat is None:
                return None
            if ChatObject.isChannel(chat) and not ChatObject.isMegagroup(chat):
                dtype = "channel"
            else:
                dtype = "group"
            title = chat.title or ""

        return {
            "id": did,
            "title": title,
            "title_lower": str(title).lower(),
            "type": dtype,
            "pinned": pinned,
            "unread": unread,
            "last_date": last_date,
        }

    def _filters_summary(self):
        parts = []
        if self.get_setting("include_private", DEFAULT_INCLUDE_PRIVATE):
            parts.append(_t("type_private_short"))
        if self.get_setting("include_groups", DEFAULT_INCLUDE_GROUPS):
            parts.append(_t("type_groups_short"))
        if self.get_setting("include_channels", DEFAULT_INCLUDE_CHANNELS):
            parts.append(_t("type_channels_short"))
        if self.get_setting("include_bots", DEFAULT_INCLUDE_BOTS):
            parts.append(_t("type_bots_short"))

        query = str(self.get_setting("query", DEFAULT_QUERY) or "").strip()
        if query:
            parts.append('"' + query + '"')
        if self.get_setting("only_unread", DEFAULT_ONLY_UNREAD):
            parts.append(_t("summary_unread"))
        if self.get_setting("exclude_pinned", DEFAULT_EXCLUDE_PINNED):
            parts.append(_t("summary_no_pinned"))
        if self.get_setting("exclude_contacts", DEFAULT_EXCLUDE_CONTACTS):
            parts.append(_t("summary_no_contacts"))
        if self.get_setting("include_archived", DEFAULT_INCLUDE_ARCHIVED):
            parts.append(_t("summary_archive"))
        if not parts:
            return "-"
        return ", ".join(parts)

    def _type_label(self, dtype):
        if dtype == "private":
            return _t("type_private_label")
        if dtype == "group":
            return _t("type_groups_label")
        if dtype == "channel":
            return _t("type_channels_label")
        if dtype == "bot":
            return _t("type_bots_label")
        return dtype

    def _get_order(self):
        try:
            return int(self.get_setting("order", DEFAULT_ORDER))
        except Exception:
            return DEFAULT_ORDER

    def _get_max_count(self):
        return self._parse_int(self.get_setting("max_count", DEFAULT_MAX_COUNT), 1, 1, 10000)

    def _get_cooldown_ms(self):
        return self._parse_int(self.get_setting("cooldown_ms", DEFAULT_COOLDOWN_MS), 0, 0, 60000)

    def _get_include_archived(self):
        return bool(self.get_setting("include_archived", DEFAULT_INCLUDE_ARCHIVED))

    def _to_java_color_int(self, color):
        value = int(color) & 0xFFFFFFFF
        if value >= 0x80000000:
            value -= 0x100000000
        return value

    def _alpha_color(self, color, alpha):
        argb = ((int(alpha) & 0xFF) << 24) | (int(color) & 0x00FFFFFF)
        return self._to_java_color_int(argb)

    def _create_action_chip(self, context, text, color_key, filled=False):
        chip = TextView(context)
        chip.setText(text)
        chip.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        chip.setGravity(Gravity.CENTER)
        chip.setPadding(AndroidUtilities.dp(10), AndroidUtilities.dp(6), AndroidUtilities.dp(10), AndroidUtilities.dp(6))

        try:
            base_color = Theme.getColor(color_key)
        except Exception:
            base_color = self._to_java_color_int(0xFF4A90E2)

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(14))
        bg.setStroke(AndroidUtilities.dp(1), self._alpha_color(base_color, 120))
        if filled:
            bg.setColor(self._alpha_color(base_color, 24))
        else:
            bg.setColor(self._to_java_color_int(0x00000000))
        chip.setBackground(bg)

        try:
            chip.setTextColor(self._to_java_color_int(base_color))
        except Exception:
            pass
        return chip

    def _open_dialog_preview(self, info):
        fragment = get_last_fragment()
        if fragment is None:
            BulletinHelper.show_error(_t("no_context"))
            return True

        try:
            did = int(info.get("id", 0) or 0)
        except Exception:
            did = 0
        if did == 0:
            BulletinHelper.show_error(_t("preview_failed"))
            return True

        args = Bundle()
        if did > 0:
            args.putLong("user_id", did)
        else:
            args.putLong("chat_id", -did)

        mc = None
        try:
            mc = get_messages_controller()
        except Exception:
            mc = None
        try:
            if mc is not None and not mc.checkCanOpenChat(args, fragment):
                return True
        except Exception:
            pass

        def open_preview():
            chat_activity = ChatActivity(args)
            try:
                chat_activity.allowExpandPreviewByClick = True
            except Exception:
                pass

            opened = False
            try:
                preview_menu = ActionBarPopupWindow.ActionBarPopupWindowLayout(
                    fragment.getParentActivity()
                )
                opened = bool(
                    fragment.presentFragmentAsPreviewWithMenu(
                        chat_activity,
                        preview_menu,
                    )
                )
            except Exception:
                opened = False
            if not opened:
                try:
                    fallback_activity = ChatActivity(args)
                    try:
                        fallback_activity.allowExpandPreviewByClick = True
                    except Exception:
                        pass
                    opened = bool(fragment.presentFragmentAsPreview(fallback_activity))
                except Exception:
                    opened = False
            if not opened:
                BulletinHelper.show_error(_t("preview_failed"))

        run_on_ui_thread(open_preview)
        return True

    def _build_dialog_row(self, context, info, on_change, can_select=None, on_limit_hit=None, on_preview=None):
        row = LinearLayout(context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER_VERTICAL)
        row.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(10), AndroidUtilities.dp(12), AndroidUtilities.dp(10))

        row_bg = GradientDrawable()
        row_bg.setCornerRadius(AndroidUtilities.dp(12))
        row.setBackground(row_bg)

        cb = CheckBox(context)
        cb.setChecked(bool(info.get("selected", False)))
        cb.setMinWidth(AndroidUtilities.dp(24))
        cb.setMinHeight(AndroidUtilities.dp(24))
        cb_lp = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        cb_lp.rightMargin = AndroidUtilities.dp(12)
        row.addView(cb, cb_lp)

        col = LinearLayout(context)
        col.setOrientation(LinearLayout.VERTICAL)

        title = TextView(context)
        title.setText(str(info.get("title", "")))
        title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
        try:
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
        except Exception:
            pass
        col.addView(title)

        badge_parts = []
        if info.get("unread", False):
            badge_parts.append(_t("tag_unread"))
        if info.get("pinned", False):
            badge_parts.append(_t("tag_pinned"))

        subtitle_text = self._type_label(info.get("type", ""))
        if badge_parts:
            subtitle_text += " | " + ", ".join(badge_parts)

        subtitle = TextView(context)
        subtitle.setText(subtitle_text)
        subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        try:
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass
        slp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        slp.topMargin = AndroidUtilities.dp(2)
        col.addView(subtitle, slp)

        row.addView(col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1))

        def title_long_click(_=None):
            if on_preview is not None:
                return on_preview(info)
            return self._open_dialog_preview(info)

        title.setOnLongClickListener(OnLongClickListener(title_long_click))

        def refresh_row_state(enabled=True):
            try:
                normal_bg = Theme.getColor(Theme.key_dialogBackground)
            except Exception:
                normal_bg = self._to_java_color_int(0xFFFFFFFF)
            try:
                divider_color = Theme.getColor(Theme.key_divider)
            except Exception:
                divider_color = self._to_java_color_int(0xFFD9D9D9)
            try:
                selected_color = Theme.getColor(Theme.key_text_RedBold)
            except Exception:
                selected_color = self._to_java_color_int(0xFFD94040)

            is_selected = bool(info.get("selected", False))
            if is_selected:
                row_bg.setColor(self._alpha_color(selected_color, 26))
                row_bg.setStroke(AndroidUtilities.dp(1), self._alpha_color(selected_color, 165))
            else:
                row_bg.setColor(normal_bg)
                row_bg.setStroke(AndroidUtilities.dp(1), self._alpha_color(divider_color, 140))

            try:
                row.setAlpha(1.0 if enabled else 0.45)
                cb.setEnabled(enabled)
            except Exception:
                pass

        def row_toggle(_=None):
            if not info.get("selected", False):
                if can_select is not None and not can_select():
                    if on_limit_hit:
                        on_limit_hit()
                    return
            info["selected"] = not info.get("selected", False)
            cb.setChecked(info["selected"])
            refresh_row_state(True)
            on_change()

        def checkbox_toggle(_=None):
            if cb.isChecked():
                if can_select is not None and not can_select():
                    cb.setChecked(False)
                    if on_limit_hit:
                        on_limit_hit()
                    return
            info["selected"] = cb.isChecked()
            refresh_row_state(True)
            on_change()

        row.setOnClickListener(OnClickListener(row_toggle))
        cb.setOnClickListener(OnClickListener(checkbox_toggle))
        refresh_row_state(True)
        return row, cb, refresh_row_state


plugin = FilteredDialogCleanupPlugin()
