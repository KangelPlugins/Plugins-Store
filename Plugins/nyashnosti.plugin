# -*- coding: utf-8 -*-
from enum import Enum
import traceback
import weakref
from random import choice

from java.chaquopy import dynamic_proxy

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.bulletin import BulletinHelper
from client_utils import send_message
from markdown_utils import parse_markdown

from android_utils import log, run_on_ui_thread

from org.telegram.messenger import NotificationCenter
from org.telegram.tgnet import TLRPC
from client_utils import (
    get_messages_controller,
    get_account_instance,
    get_user_config,
    run_on_queue,
)

# --- Plugin Metadata ---
__id__ = "nyashnosti"
__name__ = "Няшности"
__description__ ="18+ плагин Няшности \nдля @fergntye\n[ .nsfw .sfw .femboy .loli ]"
__author__ = "@stdflush & @fergntye"
__version__ = "1.1.1"
__min_version__ = "11.9.1"
__icon__ = "forkozeki_by_fStikBot/4"

# --- аьвфьы константы ---
FERGANTEUS_BOT_USERNAME = "ferganteusbot"
KAOMOJI = [
    "ᯠ ¯᎔ ⥿ ᎔¯ ᯄ ੭", "≽^ฮ̴ꈊฮ̴^≼", "₍˄꜆𓈒˕𓈒꜀˄₎",
    "≽^𓏼︲˕︲𓏼^≼", "₍^꜆◡ꄃ◡⁠꜀^₎☆", "₍˄ ᖛ ʷ̣̫ - ˄₎✦",
    "(ˆ  ◝ꄃ◜  ˆ)", "^   ᐢ ⥿ ᐢ   ^ฅ", "ᓚ(^︲˕︲^)",
    "꜀(^ .ܸ ꈊ .ܸ^꜀ )꜆੭", "ミ^ ̷ ̷^⩊^ ̷ ̷^彡", "(ˆ꜆𓈒ฮ̴˔ฮ̴ˆ)꜆",
    "꒰^´𓈒. ݂ .𓈒  ^ྀི ꒱੭", "⚞ ੬^𓏼´•⚻•𓏼^𑇓 ⚟",
    "₍^̮-̣^̮₎ zᶻ", "₍^̣-̮^̣₎", "/ᐠ. .ᐟ\\ฅ    ⸝⸝",
    "₊˚⊹ ꒰^. .^꒱☆⋆｡", "≽(-⩊-マ≼", "₍^꜆-˕-꜀^₎",
    "ᓚ/ᐠ꜆-˕-꜀ᐟ\\", "≽ ^⎚ ˕ ⎚^ ≼", "ฅ ◝⩊◜ฅ",
    "≽₍^_ ‸ _ ^₎≼⟆", "/⁠ᐠ⁠｡⁠ꞈ⁠｡⁠ᐟ⁠\\ <3", ">^•-•^<"
]
CREDITS = parse_markdown(
    "[няшности](https://t.me/fergntye) {}"
)
class Commands(Enum):
    nsfw = "rc"
    sfw = "rct"
    femboy = "fm"
    loli = "lh"

def to_signed_32(n):
    n = n & 0xFFFFFFFF
    return n if n < 0x80000000 else n - 0x100000000

class MessageListener(dynamic_proxy(NotificationCenter.NotificationCenterDelegate)):
        def __init__(self, plugin):
            super().__init__()
            self.plugin_ref = weakref.ref(plugin)

        def didReceivedNotification(self, id, account, args):
            plugin = self.plugin_ref()
            if not plugin or id != NotificationCenter.didReceiveNewMessages:
                return

            messages_list = args[1]
            for i in range(messages_list.size()):
                messageObject = messages_list.get(i)
                if not messageObject or not hasattr(messageObject, "messageOwner"):
                    continue

                fromId = 0
                try:
                    if (
                        hasattr(messageObject.messageOwner, "from_id")
                        and messageObject.messageOwner.from_id
                    ):
                        fromId = getattr(messageObject.messageOwner.from_id, "user_id", 0)
                    else:
                        fromId = getattr(
                            getattr(messageObject.messageOwner, "peer_id", None), "user_id", 0
                        )
                except Exception:
                    fromId = 0

                if fromId == plugin.botId:
                    media = getattr(messageObject.messageOwner, "media", None)
                    if not media:
                        return

                    plugin._handle(messageObject)
                    return

class NyashnostiPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.botId = 0
        self.listener = None
        self.task = {}

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._registerObserver()
        run_on_queue(self._resolveBotId)

    def on_plugin_unload(self):
        self._unregisterObserver()

    def on_send_message_hook(self, account, params):
        message: list = getattr(params, "message", "").split()
        command = message[0][1:]
        if not command or command not in [command.name for command in Commands]:
            return HookResult()


        if self.botId == 0:
            BulletinHelper.show_error(
                f"няшность не найдена, попробуй написать @{FERGANTEUS_BOT_USERNAME} хз"
            )
            return HookResult(strategy=HookStrategy.CANCEL)

        destination = self._get_id(params.peer)
        reply = getattr(params, "replyToMsg", None)

        self.task = {
            "destination": destination,
            "reply": reply
        }
        send_message({
            "peer": self.botId,
            "message": f"/{getattr(Commands, command, Commands.nsfw).value}"
        })

        return HookResult(strategy=HookStrategy.CANCEL)

    def _handle(self, messageObject):
        if self.task == {}: return
        if not (messageObject and getattr(messageObject, "messageOwner", None)):
            return

        message = \
            f"{CREDITS.text} ".format(choice(KAOMOJI)) + "\n" + \
            str(getattr(messageObject.messageOwner, "message", None))
        reply = self._getReply(self.task["destination"], self.task["reply"])
        photo = getattr(messageObject.messageOwner.media, "photo", None)
        # call it video dumbass api maker
        document = getattr(messageObject.messageOwner.media, "document", None)
        contentType = "caption" if photo or document else "message"

        params = {
            **({contentType: message} if message else {}),
            "peer": self.task["destination"],
            **({"replyToMsg": reply} if reply else {}),
            **({"photo": photo} if photo else {}),
            **({"document": document} if document else {}),
            "entities": []
        }
        for raw in CREDITS.entities:
            entity = raw.to_tlrpc_object()
            params["entities"].append(entity)

        send_message(params)
        self.task = {}

    def _getReply(self, dialogId, messageId):
        if messageId == 0:
            return None
        try:
            return get_messages_controller().getMessageObject(
                dialogId, messageId, False, 0, False
            )
        except Exception:
            return None

    def _registerObserver(self):
        if not self.listener:
            self.listener = MessageListener(self)
            run_on_ui_thread(
                lambda: get_account_instance()
                .getNotificationCenter()
                .addObserver(
                    self.listener, NotificationCenter.didReceiveNewMessages
                )
            )

    def _unregisterObserver(self):
        if self.listener:
            run_on_ui_thread(
                lambda: get_account_instance()
                .getNotificationCenter()
                .removeObserver(
                    self.listener, NotificationCenter.didReceiveNewMessages
                )
            )
            self.listener = None

    def _resolveBotId(self):
        try:
            bot = get_messages_controller().getUserOrChat(FERGANTEUS_BOT_USERNAME)
            if bot and isinstance(bot, TLRPC.TL_user):
                self.botId = bot.id
        except Exception:
            log(
                f"Exception while resolving bot ID: {traceback.format_exc()}"
            )

    def _get_id(self, peer):
            if isinstance(peer, int):
                return peer
            elif isinstance(peer, TLRPC.TL_inputPeerChannel):
                return to_signed_32(-1000000000000 - peer.channel_id)
            elif isinstance(peer, TLRPC.TL_inputPeerUser):
                return peer.user_id
            elif isinstance(peer, TLRPC.TL_inputPeerChat):
                return -peer.chat_id
            elif isinstance(peer, TLRPC.TL_inputPeerSelf):
                return get_user_config().getClientUserId()
