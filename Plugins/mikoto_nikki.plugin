from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread, log
from hook_utils import find_class
from java import dynamic_proxy

LinearLayout = find_class("android.widget.LinearLayout")
TextView = find_class("android.widget.TextView")
Button = find_class("android.widget.Button")
ScrollView = find_class("android.widget.ScrollView")
Theme = find_class("org.telegram.ui.ActionBar.Theme")
AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
Gravity = find_class("android.view.Gravity")
Typeface = find_class("android.graphics.Typeface")

from android.view import View, ViewGroup
from android.widget import FrameLayout, ImageView
from android.os import Handler, Looper
from android.graphics import Bitmap, Canvas, ColorMatrix, ColorMatrixColorFilter, Paint

__id__ = "mikoto_nikki"
__name__ = "Дневник Микото"
__description__ = "Адапцатия новвелы 2013 года внутри ЭКСТЕРАГРАМ"
__author__ = "@KangelPlugins & @TomokoPlugins"
__version__ = "Release"
__min_version__ = "11.12.0"
__icon__ = "yunochkaaaaaaa/78"

DEFAULT_SHOW_IN_CHAT_ACTION = True
DEFAULT_SHOW_IN_DRAWER = True

class VisualNovelDemoPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._sessions = {} 
        self._dbg = False
        self._active_overlay = None
        self._anim_handler = None
        self._black_overlay = None

    def on_plugin_load(self):
        self._update_menu_items()
        self._dlog("loaded")

    def on_plugin_unload(self):
        self._dlog("unloaded")
        try:
            for s in list(self._sessions.values()):
                try:
                    dlg = s.get("dialog")
                    if dlg:
                        self._safe_dismiss_dialog(dlg)
                except Exception:
                    pass
            self._sessions.clear()
        except Exception:
            pass
        try:
            if self._active_overlay is not None:
                overlay = self._active_overlay
                self._active_overlay = None
                run_on_ui_thread(lambda: self._safe_remove_overlay(overlay))
            if getattr(self, "_black_overlay", None) is not None:
                ov = self._black_overlay
                self._black_overlay = None
                run_on_ui_thread(lambda: self._safe_remove_overlay(ov))
        except Exception:
            pass

    def _dlog(self, msg: str):
        try:
            if getattr(self, "_dbg", False):
                log(f"[VN] {msg}")
        except Exception:
            pass


    def _update_menu_items(self):
        try:
            for i in getattr(self, "_menu_item_ids", []):
                try:
                    self.remove_menu_item(i)
                except Exception:
                    pass
        except Exception:
            pass
        self._menu_item_ids = []
        self._menu_item_ids.append(self.add_menu_item(MenuItemData(menu_type=MenuItemType.CHAT_ACTION_MENU, text="Дневник Микото", icon="msg_groups_hw_remix", on_click=self._open_demo)))
        self._menu_item_ids.append(self.add_menu_item(MenuItemData(menu_type=MenuItemType.DRAWER_MENU, text="Дневник Микото", icon="msg_groups_hw_remix", on_click=self._open_demo)))

    def _open_demo(self, context: dict):
        chat_id = context.get("dialog_id")
        fragment = get_last_fragment()
        activity = fragment and fragment.getParentActivity()
        if not activity:
            return
        self._dlog(f"open_vn chat={chat_id}")

        builder = AlertDialogBuilder(activity)
        builder.set_title("Дневник Микото")

        main = LinearLayout(activity)
        main.setOrientation(LinearLayout.VERTICAL)
        pad = AndroidUtilities.dp(16)
        main.setPadding(pad, pad, pad, pad)

        text_view = TextView(activity)
        text_view.setTextSize(16)
        text_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        text_view.setTypeface(None, Typeface.BOLD)
        text_view.setPadding(0, 0, 0, AndroidUtilities.dp(12))

        choices = LinearLayout(activity)
        choices.setOrientation(LinearLayout.VERTICAL)
        choices.setPadding(0, AndroidUtilities.dp(6), 0, 0)

        def make_btn(label, cb):
            btn = Button(activity)
            btn.setText(label)
            btn.setAllCaps(False)
            btn.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            btn.setBackgroundColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))
            # OnClickListener via dynamic proxy
            OnClickListenerInterface = find_class("android.view.View$OnClickListener")
            class _L(dynamic_proxy(OnClickListenerInterface)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                def onClick(self, v):
                    try:
                        self.fn()
                    except Exception as e:
                        log(f"[VN] click error: {e}")
            btn.setOnClickListener(_L(cb))
            return btn

        main.addView(text_view)
        main.addView(choices)
        builder.set_view(main)
        dialog = builder.show()

        self._sessions[chat_id] = {
            "dialog": dialog,
            "text": text_view,
            "choices": choices,
            "state": "prologue1",
            "flags": {"happy": False, "flash": False},
            "di_idx": 0
        }
        self._render_state(chat_id)

    def _render_state(self, chat_id):
        s = self._sessions.get(chat_id)
        if not s:
            return
        tv = s["text"]
        ch = s["choices"]
        try:
            ch.removeAllViews()
        except Exception:
            pass
        st = s["state"]
        flags = s.get("flags", {})
        self._dlog(f"render state={st}")

        def add_choice(label, handler):
            btn = Button(ch.getContext())
            btn.setText(label)
            btn.setAllCaps(False)
            btn.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            btn.setBackgroundColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))
            OnClickListenerInterface = find_class("android.view.View$OnClickListener")
            class _L(dynamic_proxy(OnClickListenerInterface)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                def onClick(self, v):
                    try:
                        self.fn()
                    except Exception as e:
                        log(f"[VN Demo] click error: {e}")
            btn.setOnClickListener(_L(handler))
            params = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT)
            params.setMargins(0, AndroidUtilities.dp(6), 0, 0)
            btn.setLayoutParams(params)
            ch.addView(btn)

        if st == "prologue1":
            tv.setText("Пролог.\n\nМатаро набирается смелости и смотрит Микото в глаза. Что сказать?\n\n")
            add_choice("Я люблю тебя всем сердцем!", lambda: self._set_state(chat_id, "prologue2"))
            add_choice("…Я давно хотел это сказать…", lambda: self._set_state(chat_id, "prologue2"))
        elif st == "prologue2":
            tv.setText("Микото мягко улыбается.\n\nОна: «Хорошо…»\n\nТы отвечаешь?\n")
            add_choice("Пожалуйста, будь добра ко мне тоже.", lambda: (self._on_window_glitch(chat_id), self._set_state(chat_id, "prologue3")))
        elif st == "prologue3":
            tv.setText("И ещё одна мысль вслух — что ты по‑настоящему хочешь?\n")
            add_choice("Я хочу сделать Микото счастливой.", lambda: (flags.__setitem__("happy", True), self._set_state(chat_id, "entry")))
            add_choice("Я хочу быть с Микото навсегда.", lambda: (flags.__setitem__("happy", False), self._set_state(chat_id, "entry")))
        elif st == "entry":
            tv.setText("У дома Микото. Она приглашает внутрь.\n\nЧто ответить по пути?\n")
            add_choice("Прошу прощения за вторжение.", lambda: self._set_state(chat_id, "entry_reply1"))
            add_choice("Мне нравится здесь.", lambda: self._set_state(chat_id, "entry_reply2"))
            add_choice("Как поздно можно остаться?", lambda: self._set_state(chat_id, "entry_reply3"))
            add_choice("Что будешь готовить?", lambda: self._set_state(chat_id, "entry_reply4"))
        elif st == "entry_reply1":
            tv.setText("Ты: «Прошу прощения за вторжение.»\n\nМикото: «Глупыш, я рада, что ты пришёл.»\nЕё голос спокойный, почти шёпот." )
            add_choice("Дальше", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "entry_reply2":
            tv.setText("Ты: «Мне нравится здесь.»\n\nМикото: «Правда? Я старалась поддерживать уют… для особенных гостей.»" )
            add_choice("Дальше", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "entry_reply3":
            tv.setText("Ты: «Как поздно можно остаться?»\n\nМикото: «Не тороплю. Можешь остаться… сколько захочешь.»\nВзгляд залипает на закрытом шкафу." )
            # Лёгкий предвестник — короткий глитч
            self._on_window_glitch(chat_id)
            add_choice("Дальше", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "entry_reply4":
            tv.setText("Ты: «Что будешь готовить?»\n\nМикото: «Омлет с рисом… И мускатный чай. Думаю, тебе понравится.»" )
            add_choice("Дальше", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "kitchen_opt":
            tv.setText("Кухня. Микото ставит чайник и заглядывает в холодильник.\n")
            add_choice("Поговорить о чае", lambda: self._set_state(chat_id, "kitchen_tea"))
            add_choice("Поговорить о еде", lambda: self._set_state(chat_id, "kitchen_food"))
            add_choice("Пойти исследовать дом", lambda: self._set_state(chat_id, "diaries_intro"))
        elif st == "kitchen_tea":
            tv.setText("Ты: «Чёрный? Персиковый? Что любишь?»\nМикото: «Для гостей у меня всегда есть персиковый. Но… сегодня, может, мускатный?»\n")
            add_choice("Кивнуть", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "kitchen_food":
            tv.setText("Ты: «Чем угостишь?»\nМикото: «Омлет с рисом — моя коронка. Говорят, вкусно… Тогда я стараюсь ещё сильнее.»\n")
            add_choice("Улыбнуться", lambda: self._set_state(chat_id, "kitchen_opt"))
        elif st == "diaries_intro":
            tv.setText("Ты выходишь в коридор. На полу — клочок бумаги.\n«…Дневник?»\n\nСобери обрывки, чтобы понять, что происходит.\n")
            add_choice("Начать читать обрывки", lambda: (s.__setitem__("di_idx", 1), self._on_window_glitch(chat_id), self._set_state(chat_id, "diary_show")))
        elif st == "diary_show":
            idx = int(s.get("di_idx", 1))
            scraps = self._get_diary_scraps_ru()
            total = len(scraps)
            idx = max(1, min(idx, total))
            title, lines = scraps[idx-1]
            tv.setText(f"{title}\n\n" + "\n".join(lines))
            if idx < total:
                add_choice("Далее", lambda: (s.__setitem__("di_idx", idx+1), self._set_state(chat_id, "diary_show")))
            else:
                add_choice("Дальше", lambda: self._set_state(chat_id, "pre_closet"))
        elif st == "pre_closet":
            tv.setText("В кладовке заперто. Кажется, где‑то должен быть фонарик…\n\nВзять его перед тем, как идти?\n")
            add_choice("Взять фонарик", lambda: (flags.__setitem__("flash", True), self._set_state(chat_id, "closet")))
            add_choice("Идти к шкафу", lambda: self._set_state(chat_id, "closet"))
        elif st == "closet":
            tv.setText("Замок поддаётся. Внутри — мрак и тяжёлый запах. Несколько тел…\n\nМикото, шёпотом: «Я заперла родителей… они называли меня чудовищем. Потом — Юкимару. Я думала, он поймёт…»\nОна: «Ты убежишь, как он?»\n")
            if not flags.get("g_closet", False):
                flags.__setitem__("g_closet", True)
                self._on_window_glitch(chat_id)
            if not flags.get("flash", False):
                add_choice("Зайти без фонарика", lambda: self._set_state(chat_id, "bad_noflash"))
            add_choice("Убежать", lambda: self._set_state(chat_id, "bad_run"))
            add_choice("Остаться с Микото", lambda: self._set_state(chat_id, "bad_stay"))
            add_choice("Обнять Микото", lambda: self._set_state(chat_id, "true_end"))
        elif st == "bad_noflash":
            tv.setText("Темнота. Удар сзади.\n\nМикото: «В тьме надо смотреть по сторонам…»\n«Я убью тебя.»\n\nПлохая концовка: Без фонарика.")
            self._schedule(3000, self._exit_app)
        elif st == "bad_run":
            tv.setText("Ты бросаешься бежать. За спиной — быстрые шаги.\n\nМрак сгущается. Исход предрешён.\n\nПлохая концовка: Сзади.")
            self._schedule(3000, self._exit_app)
        elif st == "bad_stay":
            tv.setText("Ты: «Я останусь.»\n\nМикото: «Тогда я буду готовить для тебя много‑много…»\nЩелчок замка. Внутри — тишина.\n\nПлохая концовка: Чего ты хотел.")
            def _start_fade_and_exit():
                run_on_ui_thread(lambda: self._blackout_fade(2200, on_done=self._exit_app))
            self._schedule(3500, _start_fade_and_exit)
            try:
                dlg = s.get("dialog")
                if dlg:
                    self._safe_dismiss_dialog(dlg)
            except Exception:
                pass
        elif st == "true_end":
            extra = " Я хочу, чтобы ты была счастлива." if flags.get("happy", False) else ""
            tv.setText("Ты обнимаешь её, несмотря ни на что.\n\nМикото: «Прости… за всё.»\nПроходят месяцы. Вы лепите снеговика. Она становится спокойнее.\n" + extra + "\n\nИстинная концовка.")
            add_choice("Сыграть снова", lambda: self._reset_and_restart(chat_id))
    
        else:
            tv.setText("(Неизвестное состояние)")
            add_choice("В начало", lambda: self._set_state(chat_id, "start"))

    def _reset_and_restart(self, chat_id):
        s = self._sessions.get(chat_id)
        if not s:
            return
        s["flags"] = {"happy": False, "flash": False}
        s["di_idx"] = 0
        self._set_state(chat_id, "prologue1")

    def _get_diary_scraps_ru(self):
        return [
            ("Обрывок дневника #1", [
                "Сегодня в школе был тест.",
                "Конечно, я справилась так же хорошо, как и со всеми остальными!",
                "Я гений — нет задачи, которую я не решу!",
                "— «Подойди к входу»."
            ]),
            ("Обрывок дневника #2", [
                "Готовка, учёба, красиво одеваться…",
                "Микото обожала всё это и занималась при каждом удобном случае!",
                "Но‑но‑но! Кошелёк… *плачет*",
                "Денег никогда не хватало. Раз карманных не давали — пришлось подрабатывать.",
                "Тяжело… Интересно, кто‑нибудь придёт и спасёт меня?",
                "Что я хочу прямо сейчас?.. Хм…",
                "Одежду, сумку, справочник, тетрадь и ручки, кулинарную книгу… слишком много всего!",
                "— «Любишь чёрный чай?»"
            ]),
            ("Обрывок дневника #3", [
                "Опять в меня влюбились!",
                "Сложно быть такой популярной!",
                "Но… он всерьёз? А вдруг это просто «встречаться ради галочки». Подходит ли он мне вообще?..",
                "А‑а‑а! Хочу настоящих чувств!",
                "Я… я не смогу встречаться, если не влюблюсь по‑настоящему.",
                "Я не позволю играть со мной первому встречному! Хм!",
                "— «Остаёшься с ночёвкой?»"
            ]),
            ("Обрывок дневника #4", [
                "Думаю… Как было бы здорово — счастливая жизнь…",
                "Любимый человек, хорошая работа, самая счастливая семья! А с детьми я бы играла целыми днями.",
                "Каждый день — как праздник!",
                "А вечером — в постель к чудесному мужу!",
                "…Нет, не в «том» смысле!",
                "— «Это для гостей»."
            ]),
            ("Обрывок дневника #5", [
                "О‑о‑о! Сегодня отличные новости!",
                "Есть один парень, который мне нравился. Его зовут Юкимару.",
                "И угадайте? Он признался мне! Муфуфу. Мне признались!",
                "Поэтому у меня просто чудесное настроение.",
                "Парней, которые говорят, что нравлюсь, много…",
                "Но это никогда не те, от кого я действительно хотела бы услышать признание. Обидно.",
                "Я решила дать этому увлечению шанс расцвести.",
                "Вот только… поймёт ли меня Юкимару?",
                "— «Холодный взгляд»."
            ]),
            ("Обрывок дневника #6", [
                "Никто меня не понимает.",
                "Ни папа, ни мама, ни друзья. Ни один человек не понимает меня.",
                "— «Учиться»."
            ]),
            ("Обрывок дневника #7", [
                "Знаете, я правда стараюсь. Очень.",
                "Зачем? Чтобы порадовать маму и папу. …Так я себе говорю.",
                "Я…",
                "Не знаю, зачем я так стараюсь.",
                "Я ведь не особо умная.",
                "И всё равно — учусь, учусь, учусь. Меня заставляют, но в этом нет смысла.",
                "Тихо! ТИХО! ТИХО!! АААААААААААААААААААААА…",
                "— «Разобьёшь — заплатишь»."
            ]),
            ("Обрывок дневника #8", [
                "Знаете…",
                "Я люблю готовить!",
                "Омлет с рисом — моя специальность. Любого покорю одним кусочком!",
                "…Шучу!",
                "Но правда: все говорят, что вкусно! И тогда хочется готовить ещё больше.",
                "Когда‑нибудь я открою своё заведение.",
                "Не знаю когда, но однажды… Я стану супер‑поваром, и все будут завидовать!",
                "— «Вечернее пальто»."
            ]),
            ("Обрывок дневника #9", [
                "Меня зовут Такашики Микото. Я ученица старшей школы. Вечная семнадцатилетняя!",
                "Моя сильная сторона — готовка. Я, конечно, в кулинарном клубе! В теннисный тоже записана, но почти не хожу.",
                "Почему‑то меня называют популярной… неужели я и правда такая обаятельная?",
                "Я в этом плохо разбираюсь, да и специально нравиться — утомительно.",
                "Зато уроки не прогуливаю! И учусь как нужно! Тесты — всегда на первом месте.",
                "Когда я лучшая — мама с папой счастливы.",
                "А когда нет…",
                "— «Выбросить?»"
            ]),
            ("Обрывок дневника #10", [
                "Эй‑эй‑эй!",
                "С того самого дня стало как‑то веселее.",
                "Я уже не понимаю, что говорит мама.",
                "И папа — тоже.",
                "Так смешно‑смешно‑смешно. Мне смешно.",
                "В тот момент я подумала: «Теперь тихо». Может, больше ничего мне не сделают?",
                "Как будто камень с души. Кажется, теперь мне всё по плечу!",
                "— «Выйди в сад»."
            ]),
            ("Обрывок дневника #11", [
                "Всё равно меня никто‑ни‑ко‑го не поймёт.",
                "Я…",
                "учу‑учу‑учу‑учу ВСЕГДА, и, кажется, я чуть‑чуть сошла с ума.",
                "ч то я д е л а ю",
                "« »",
                "— «М О Я Ф И Г У Р А»."
            ]),
            ("Обрывок дневника #12", [
                "Сегодня я пригласила Юкимару — особенный гость. Приготовила ему лучшее блюдо. Сказал, вкусно! Я была так рада.",
                "Я думала и про персиковый чай, конечно, но Юкимару казался… другим. Так что я сделала мускатный.",
                "Он всё спрашивал, что у меня в шкафу. Это злило.",
                "Мне было страшно, но он не отставал! Какой противный!",
                "Я думала, он поймёт… Так что… просто оставила его одного.",
                "Юкимару больше нет.",
                "— «Странное лекарство»."
            ])
        ]

    def _set_state(self, chat_id, new_state):
        s = self._sessions.get(chat_id)
        if not s:
            return
        s["state"] = new_state
        self._render_state(chat_id)

    def _on_window_glitch(self, chat_id):
        s = self._sessions.get(chat_id)
        duration, intensity = self._glitch_params_for(s)
        self._dlog(f"glitch requested d={duration} i={intensity}")
        run_on_ui_thread(lambda: self._play_glitch(duration, intensity))

    def _schedule(self, delay_ms: int, fn):
        try:
            handler = Handler(Looper.getMainLooper())
            RunnableIntf = dynamic_proxy(find_class("java.lang.Runnable"))
            class _R(RunnableIntf):
                def __init__(self, f):
                    super().__init__(); self.f = f
                def run(self):
                    try: self.f()
                    except Exception as e: log(f"[VN] schedule err: {e}")
            handler.postDelayed(_R(fn), int(delay_ms))
        except Exception as e:
            log(f"[VN] schedule setup err: {e}")

    def _exit_app(self):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if activity is None:
                return
            # Пытаемся корректно закрыть приложение
            try:
                activity.finishAndRemoveTask()
                return
            except Exception:
                pass
            try:
                activity.finishAffinity()
                return
            except Exception:
                pass
            try:
                activity.moveTaskToBack(True)
                return
            except Exception:
                pass
        except Exception as e:
            log(f"[VN] exit app err: {e}")

    def _blackout(self):
        try:
            if self._black_overlay is not None:
                return
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if activity is None:
                return
            window = activity.getWindow()
            decor = window.getDecorView()
            ov = FrameLayout(activity)
            ov.setLayoutParams(ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
            ov.setClickable(True)
            # Чёрный фон
            from android.graphics import Color
            ov.setBackgroundColor(Color.parseColor("#FF000000"))
            if isinstance(decor, ViewGroup):
                decor.addView(ov)
                self._black_overlay = ov
        except Exception as e:
            log(f"[VN] blackout err: {e}")

    def _blackout_fade(self, duration_ms: int = 1500, on_done=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if activity is None:
                return
            window = activity.getWindow()
            decor = window.getDecorView()
            if self._black_overlay is None:
                ov = FrameLayout(activity)
                ov.setLayoutParams(ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
                ov.setClickable(True)
                from android.graphics import Color
                ov.setBackgroundColor(Color.parseColor("#FF000000"))
                ov.setAlpha(0.0)
                if isinstance(decor, ViewGroup):
                    decor.addView(ov)
                    self._black_overlay = ov
                else:
                    return
            ov = self._black_overlay
            start_ts = self._now_ms()
            handler = Handler(Looper.getMainLooper())
            RunnableIntf = dynamic_proxy(find_class("java.lang.Runnable"))
            class _Step(RunnableIntf):
                def __init__(self, fn):
                    super().__init__(); self.fn = fn
                def run(self):
                    try: self.fn()
                    except Exception as e: log(f"[VN] fade err: {e}")
            def step():
                if ov is None:
                    return
                elapsed = self._now_ms() - start_ts
                if elapsed >= int(duration_ms):
                    ov.setAlpha(1.0)
                    try:
                        if callable(on_done):
                            on_done()
                    finally:
                        return
                # 60 FPS шаг
                prog = max(0.0, min(1.0, float(elapsed) / float(max(1, int(duration_ms)))))
                ov.setAlpha(prog)
                handler.postDelayed(_Step(step), 16)
            handler.postDelayed(_Step(step), 0)
        except Exception as e:
            log(f"[VN] blackout_fade err: {e}")

    def _safe_dismiss_dialog(self, dlg):
        try:
            if dlg is None:
                return
            def _do():
                try:
                    # Проверяем, что диалог всё ещё привязан к окну
                    is_showing = False
                    try:
                        is_showing = dlg.isShowing()
                    except Exception:
                        pass
                    if not is_showing:
                        return
                    try:
                        win = dlg.getWindow()
                    except Exception:
                        win = None
                    if win is None:
                        return
                    dlg.dismiss()
                except Exception as e:
                    log(f"[VN] dlg dismiss err: {e}")
            run_on_ui_thread(_do)
        except Exception:
            pass

    def _glitch_params_for(self, session):
        try:
            st = (session or {}).get("state", "")
            duration, intensity = 500, 14
            if st == "prologue2":
                duration, intensity = 350, 8
            elif st == "diaries_intro":
                duration, intensity = 520, 15
            elif st == "diary_show":
                idx = int((session or {}).get("di_idx", 1))
                idx = max(1, min(idx, 12))
                duration = 520 + idx * 45
                intensity = min(26, 12 + idx)
            elif st == "pre_closet":
                duration, intensity = 850, 22
            elif st == "closet":
                duration, intensity = 1100, 28
            return int(duration), int(intensity)
        except Exception:
            return 500, 14

    def _play_glitch(self, duration_ms: int, intensity_px: int):
        try:
            if self._active_overlay is not None:
                return
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if activity is None:
                return
            window = activity.getWindow()
            decor = window.getDecorView()
            root_view = decor.getRootView()
            width = root_view.getWidth()
            height = root_view.getHeight()
            if width <= 0 or height <= 0:
                return
            bmp = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            Canvas(bmp).drawColor(0x00000000)
            c = Canvas(bmp)
            root_view.draw(c)
            paint_r, paint_g, paint_b = Paint(), Paint(), Paint()
            cm_r = ColorMatrix([1,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,1,0])
            cm_g = ColorMatrix([0,0,0,0,0, 0,1,0,0,0, 0,0,0,0,0, 0,0,0,1,0])
            cm_b = ColorMatrix([0,0,0,0,0, 0,0,0,0,0, 0,0,1,0,0, 0,0,0,1,0])
            paint_r.setColorFilter(ColorMatrixColorFilter(cm_r))
            paint_g.setColorFilter(ColorMatrixColorFilter(cm_g))
            paint_b.setColorFilter(ColorMatrixColorFilter(cm_b))
            bmp_r = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            bmp_g = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            bmp_b = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            Canvas(bmp_r).drawBitmap(bmp, 0, 0, paint_r)
            Canvas(bmp_g).drawBitmap(bmp, 0, 0, paint_g)
            Canvas(bmp_b).drawBitmap(bmp, 0, 0, paint_b)
            overlay = FrameLayout(activity)
            overlay.setLayoutParams(ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
            overlay.setClickable(True)
            iv_r, iv_g, iv_b = ImageView(activity), ImageView(activity), ImageView(activity)
            iv_r.setImageBitmap(bmp_r)
            iv_g.setImageBitmap(bmp_g)
            iv_b.setImageBitmap(bmp_b)
            for iv in (iv_b, iv_g, iv_r):
                iv.setLayoutParams(ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
                overlay.addView(iv)
            if isinstance(decor, ViewGroup):
                decor.addView(overlay)
            else:
                return
            self._active_overlay = overlay
            handler = Handler(Looper.getMainLooper())
            RunnableIntf = dynamic_proxy(find_class("java.lang.Runnable"))
            import random
            start_ts = self._now_ms()
            class _Step(RunnableIntf):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                def run(self):
                    try: self.fn()
                    except Exception as e: log(f"[VN] step err: {e}")
            def step():
                if self._active_overlay is None:
                    return
                elapsed = self._now_ms() - start_ts
                if elapsed >= duration_ms:
                    self._finish_overlay(overlay, [bmp, bmp_r, bmp_g, bmp_b])
                    return
                m = max(1, int(intensity_px))
                for iv in (iv_r, iv_g, iv_b):
                    iv.setTranslationX(float(random.randint(-m, m)))
                    iv.setTranslationY(float(random.randint(-m, m)))
                if random.random() < 0.3:
                    try:
                        overlay.removeAllViews();
                        for iv in random.sample([iv_r, iv_g, iv_b], 3): overlay.addView(iv)
                    except Exception: pass
                handler.postDelayed(_Step(step), random.randint(14, 28))
            handler.postDelayed(_Step(step), 0)
        except Exception as e:
            log(f"[VN] glitch play error: {e}")
            try:
                if self._active_overlay is not None:
                    self._finish_overlay(self._active_overlay, [])
            except Exception:
                pass

    def _finish_overlay(self, overlay: FrameLayout, bitmaps):
        try:
            self._active_overlay = None
            if self._anim_handler is not None:
                try:
                    self._anim_handler.removeCallbacksAndMessages(None)
                except Exception:
                    pass
                self._anim_handler = None
            self._safe_remove_overlay(overlay)
        finally:
            for b in bitmaps:
                try:
                    if isinstance(b, Bitmap) and not b.isRecycled():
                        b.recycle()
                except Exception:
                    pass

    def _safe_remove_overlay(self, overlay: FrameLayout):
        try:
            parent = overlay.getParent()
            if isinstance(parent, ViewGroup):
                parent.removeView(overlay)
        except Exception:
            pass

    def _now_ms(self) -> int:
        try:
            from java.lang import System as JavaSystem
            return int(JavaSystem.currentTimeMillis())
        except Exception:
            import time
            return int(time.time() * 1000)
