__id__ = "blockblast_beta"
__name__ = "BlockBlast"
__author__ = "@pl_meow"
__version__ = "1.3.2"
__description__ = """BlockBlast Ð² Ñ‚ÐµÐ»ÐµÐ³Ñ€Ð°Ð¼Ðµ :D
CÐ´ÐµÐ»Ð°Ð½Ð¾ Ð² ðŸ¤@PluginIDEðŸ¤
"""

import re
import random
import json
import traceback
import math
import colorsys
import time
import weakref
import threading
from typing import Any, Dict, List, Tuple, Optional, Callable

from base_plugin import BasePlugin, MenuItemData, MenuItemType, MethodHook, HookResult, HookStrategy
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread, log
from hook_utils import find_class
from java import dynamic_proxy, jarray, cast
from java.util import ArrayList
from java.lang import Integer as JInteger
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Input, Divider, Header, Selector, Switch, Text
from org.telegram.tgnet import TLRPC

from org.telegram.messenger import MessagesController, UserConfig
from android.content import Intent, ClipData
from android.net import Uri
from android.os import Build, Handler, Looper
from android.view.animation import LinearInterpolator, OvershootInterpolator, AccelerateInterpolator, DecelerateInterpolator
from android.view import WindowManager
from java.lang import String as JString 


try:
    Theme = find_class("org.telegram.ui.ActionBar.Theme")
except Exception:
    class Theme:
        @staticmethod
        def getColor(key): return Color.parseColor("#FFFFFF") 



__icon__ = "Ksisjshsksms_by_fStikBot/0"
__min_version__ = "11.12.1"


pg_data_handler = 0

try:
    View = find_class("android.view.View")
    Gravity = find_class("android.view.Gravity")
    LinearLayout = find_class("android.widget.LinearLayout")
    Button = find_class("android.widget.Button")
    TextView = find_class("android.widget.TextView")
    Typeface = find_class("android.graphics.Typeface")
    Color = find_class("android.graphics.Color")
    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    Runnable = find_class("java.lang.Runnable")
    MotionEvent = find_class("android.view.MotionEvent")
    DialogInterface = find_class("android.content.DialogInterface")
    FrameLayout = find_class("android.widget.FrameLayout")
    LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
    Context = find_class("android.content.Context")
    HapticFeedbackConstants = find_class("android.view.HapticFeedbackConstants")
    ViewGroup = find_class("android.view.ViewGroup")
    SeekBar = find_class("android.widget.SeekBar")
    ScrollView = find_class("android.widget.ScrollView")
    EditText = find_class("android.widget.EditText")
    CompoundButton = find_class("android.widget.CompoundButton")
    AndroidSwitch = find_class("android.widget.Switch")
    WindowManager = find_class("android.view.WindowManager")
    Handler = find_class("android.os.Handler")
    Looper = find_class("android.os.Looper")
    JavaSystem = find_class("java.lang.System")
    LinearInterpolator = find_class("android.view.animation.LinearInterpolator")
    OvershootInterpolator = find_class("android.view.animation.OvershootInterpolator")
    AccelerateInterpolator = find_class("android.view.animation.AccelerateInterpolator")
    DecelerateInterpolator = find_class("android.view.animation.DecelerateInterpolator")

    OnClickListener = find_class("android.view.View$OnClickListener")
    OnTouchListener = find_class("android.view.View$OnTouchListener")
    OnDismissListener = find_class("android.content.DialogInterface$OnDismissListener")
    OnCheckedChangeListener = find_class("android.widget.CompoundButton$OnCheckedChangeListener")
    AlertDialog = find_class("org.telegram.ui.ActionBar.AlertDialog")
    Browser = find_class("org.telegram.messenger.browser.Browser")
    
    JInteger = find_class("java.lang.Integer")
    jint = JInteger.TYPE
    LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
    ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")

    android_R_id = find_class("android.R$id")
    android_R_id_content = android_R_id.content

    UI_CLASSES_LOADED = all([
        View, Gravity, LinearLayout, Button, TextView, Typeface, Color,
        GradientDrawable, AndroidUtilities, Runnable, MotionEvent, DialogInterface,
        FrameLayout, LayoutHelper, Context, HapticFeedbackConstants, ViewGroup, SeekBar,
        ScrollView, EditText, CompoundButton, AndroidSwitch, WindowManager, Handler, Looper,
        OnClickListener, OnTouchListener, OnDismissListener, OnCheckedChangeListener, AlertDialog,
        Browser, JInteger, jint, LaunchActivity, ApplicationLoader, JavaSystem,
        LinearInterpolator, OvershootInterpolator, AccelerateInterpolator, DecelerateInterpolator,
    ])
except Exception as e:
    log(f"[{__name__}] ÐšÐ Ð˜Ð¢Ð˜Ð§Ð•Ð¡ÐšÐÐ¯ ÐžÐ¨Ð˜Ð‘ÐšÐ: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð°Ð¹Ñ‚Ð¸ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ðµ ÐºÐ»Ð°ÑÑÑ‹ Android: {e}")
    UI_CLASSES_LOADED = False
    jint = None
    class AndroidUtilities:
        @staticmethod
        def dp(val): return int(val * 3)
    class FrameLayout: pass
    class LayoutHelper:
        @staticmethod
        def createFrame(*args): return FrameLayout.LayoutParams(-2, -2)
    class MotionEvent:
        ACTION_DOWN, ACTION_MOVE, ACTION_UP, ACTION_CANCEL = 0, 1, 2, 3
    class DialogInterface: pass
    class OnClickListener: pass
    class OnTouchListener: pass
    class OnDismissListener: pass
    class OnCheckedChangeListener: pass
    class Runnable: pass
    class AlertDialog: pass
    class Context: pass
    class HapticFeedbackConstants:
        KEYBOARD_TAP = 3
    class ViewGroup: pass
    class LaunchActivity:
        instance = None
    class Browser:
        @staticmethod
        def openUrl(context, uri, internal): pass
    class SeekBar: pass
    class ScrollView: pass
    class EditText: pass
    class CompoundButton: pass
    class AndroidSwitch: pass
    class Handler: pass
    class Looper: pass
    class WindowManager: pass
    class Theme:
        @staticmethod
        def getColor(key): return Color.parseColor("#FFFFFF")
    class JavaSystem:
        @staticmethod
        def currentTimeMillis(): return int(time.time() * 1000)
    class LinearInterpolator: pass
    class OvershootInterpolator: pass
    class AccelerateInterpolator: pass
    class DecelerateInterpolator: pass

PG_GRID_SIZE = 9

_BASE_BLOCK_COLORS = {
    0: "#21262d", 1: "#f85149", 2: "#34c759", 3: "#007aff", 4: "#8b949e", 99: "#d9534f",
}

PG_THEMES = {
    "Dark (Default)": {
        "grid_bg": "#161b22", "cell_empty": _BASE_BLOCK_COLORS[0], "cell_block_1": _BASE_BLOCK_COLORS[1],
        "cell_block_2": _BASE_BLOCK_COLORS[2], "cell_block_3": _BASE_BLOCK_COLORS[3], "cell_block_4": _BASE_BLOCK_COLORS[4],
        "cell_error": _BASE_BLOCK_COLORS[99], "error_cross": "#FFFFFF", "cell_preview": "#3c4756", "cell_clear": "#FFD700", "cell_restart": "#FFA500",
        "game_over": "#FF0000", "score_text": "#FFFFFF", "high_score_text": "#8b949e",
        "button_bg": "#2f6feb", "button_text": "#FFFFFF", "selected_shape_border": "#58a6ff",
        "placeholder_shape_bg": "#30363d", "cube_bg": "#161b22", "cube_border": "#58a6ff",
    }
}

PG_BLOCK_COLOR_IDS = [1, 2, 3, 4]

PG_DRAG_THRESHOLD = AndroidUtilities.dp(8)
PG_PARTICLE_ANIM_DURATION = 150
PG_CLEAR_ANIM_DURATION = 300
PG_GAME_OVER_BLINKS = 5
PG_BLINK_STEP_DURATION = 150
PG_MINIMIZE_ANIMATION_DURATION = 250
PG_SHAPES = {
    1: [(0, 0)], 2: [(0, 0), (0, 1)], 3: [(0, 0), (1, 0)], 4: [(0, 0), (0, 1), (0, 2)],
    5: [(0, 0), (1, 0), (2, 0)], 6: [(0, 0), (0, 1), (0, 2), (0, 3)], 7: [(0, 0), (1, 0), (2, 0), (3, 0)],
    8: [(0, 0), (0, 1), (1, 0), (1, 1)], 9: [(0, 0), (1, 0), (2, 0), (0, 1)], 10: [(0, 1), (1, 1), (2, 1), (2, 0)],
    11: [(0, 0), (1, 0), (2, 0), (1, 1)], 12: [(0, 1), (1, 0), (1, 1), (2, 0)], 13: [(0, 0), (0, 1), (1, 0), (2, 0), (2, 1)],
    14: [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)], 15: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)],
    16: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)], 17: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)],
}
PG_SHAPE_SETS = [
    [1, 8, 16], [4, 9, 14], [12, 10, 17], [2, 7, 15], [3, 6, 13], [5, 11, 17], [1, 14, 15]
]
PG_GRID_INFO: Dict[str, Any] = {
    "cell_size": 0, "margin": 0, "location": (0, 0), "size": 0
}

BLUR_RADIUS_MAP = [0, 5, 10, 15, 20]

class Locales:
    strings = {
        'ru': {
            'settings_header_cat_love': "Ð¡Ð´ÐµÐ»Ð°Ð½Ð¾ Ñ Ð»ÑŽÐ±Ð¾Ð²ÑŒÑŽ Ðº ÐºÐ¾Ñ‚Ð¸ÐºÐ°Ð¼ >^-^<",
            'settings_footer_versions': "Ð¡Ð¾Ð±Ñ€Ð°Ð½Ð¾ Ð´Ð»Ñ [11.12.1 | 12.0.1]", 'settings_main_header': "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ BlockBlast",
            'links_section_header': "Ð¡ÑÑ‹Ð»ÐºÐ¸", 'author_link_text': "ÐÐ²Ñ‚Ð¾Ñ€ðŸ¤", 'details_link_text': "ÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½ÐµÐµðŸ”Ž",
            'display_section': "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ", 'game_section': "Ð˜Ð³Ñ€Ð°", 'theme_section': "Ð¢ÐµÐ¼Ð°",
            'plugin_settings_section': "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸",
            'style_section': "Ð¡Ñ‚Ð¸Ð»ÑŒ",
            'sizes_section': "Ð Ð°Ð·Ð¼ÐµÑ€Ñ‹",
            'show_in_drawer': "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ‚ÑŒ ÑÐ±Ð¾ÐºÑƒ", 'show_in_chat_action': "ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ‚ÑŒ Ð² Ñ‡Ð°Ñ‚Ðµ",
            'show_exit_button': "ÐšÐ½Ð¾Ð¿ÐºÐ° Â«Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒÂ» Ð² Ð¸Ð³Ñ€Ðµ", 'exit_btn': "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",
            'show_settings_button': "ÐšÐ½Ð¾Ð¿ÐºÐ° Â«ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸Â» Ð² Ð¸Ð³Ñ€Ðµ",
            'show_minimize_button': "ÐšÐ½Ð¾Ð¿ÐºÐ° Â«Ð¡Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒÂ» Ð² Ð¸Ð³Ñ€Ðµ", 'restore_setting': "Ð ÐµÐ¶Ð¸Ð¼ Ñ€Ð°Ð·Ð²ÐµÑ€Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ",
            'restore_1_click': "1 ÐºÐ»Ð¸Ðº", 'restore_2_click': "2 ÐºÐ»Ð¸ÐºÐ°", 'restart_btn': "Ð ÐµÑÑ‚Ð°Ñ€Ñ‚",
            'game_name': "Block Puzzle", 'start_game': "ÐÐ°Ñ‡Ð°Ñ‚ÑŒ Ð¸Ð³Ñ€Ñƒ", 'high_score': "Ð ÐµÐºÐ¾Ñ€Ð´: {score}",
            'current_score': "ÐžÑ‡ÐºÐ¸: {score}", 'game_over': "Ð˜Ð³Ñ€Ð° Ð¾ÐºÐ¾Ð½Ñ‡ÐµÐ½Ð°! ðŸ’”", 'new_high': "ÐÐžÐ’Ð«Ð™ Ð Ð•ÐšÐžÐ Ð”! ðŸŽ‰",
            'select_shape': "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ„Ð¸Ð³ÑƒÑ€Ñƒ:", 'place_hint': "ÐšÐ»Ð¸ÐºÐ½Ð¸Ñ‚Ðµ Ð´Ð»Ñ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð°/Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ñ",
            'info_title': "ÐžÐ± Ð¸Ð³Ñ€Ðµ", 'info_text': "Ð Ð°Ð·Ð¼ÐµÑ‰Ð°Ð¹Ñ‚Ðµ Ñ„Ð¸Ð³ÑƒÑ€Ñ‹, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°Ð¿Ð¾Ð»Ð½ÑÑ‚ÑŒ Ð¸ Ð¾Ñ‡Ð¸Ñ‰Ð°Ñ‚ÑŒ Ð¿Ð¾Ð»Ð½Ñ‹Ðµ ÑÑ‚Ñ€Ð¾ÐºÐ¸ Ð¸Ð»Ð¸ ÑÑ‚Ð¾Ð»Ð±Ñ†Ñ‹. Ð˜Ð³Ñ€Ð° Ð¾ÐºÐ¾Ð½Ñ‡ÐµÐ½Ð°, ÐºÐ¾Ð³Ð´Ð° Ð½ÐµÑ‚ Ð¼ÐµÑÑ‚Ð° Ð´Ð»Ñ Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ñ Ð¾ÑÑ‚Ð°Ð²ÑˆÐ¸Ñ…ÑÑ Ñ„Ð¸Ð³ÑƒÑ€.",
            'save_error': "ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ñ€ÐµÐºÐ¾Ñ€Ð´Ð°", 'clear': "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ",
            'place_commit': "ÐšÐ»Ð¸ÐºÐ½Ð¸Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð· Ð´Ð»Ñ Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ñ", 'place_failed': "âŒ ÐÐµÐ»ÑŒÐ·Ñ Ñ€Ð°Ð·Ð¼ÐµÑÑ‚Ð¸Ñ‚ÑŒ Ð·Ð´ÐµÑÑŒ",
            'mode_setting': "Ð¡Ð¿Ð¾ÑÐ¾Ð± ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸", 'mode_click': "ÐšÐ»Ð¸Ðº", 'mode_drag': "ÐŸÐµÑ€ÐµÑ‚Ð°ÑÐºÐ¸Ð²Ð°Ð½Ð¸Ðµ",
            'mode_combined': "ÐšÐ»Ð¸Ðº + Drag",
            'error_highlight': "Ð—Ð°Ð½ÑÑ‚Ð¾!", 'dismiss_alert': "Ð ÐµÐºÐ¾Ñ€Ð´ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½", 'minimize_btn': "Ð¡Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ",
            'minimized_info': "Ð˜Ð³Ñ€Ð° ÑÐ²ÐµÑ€Ð½ÑƒÑ‚Ð°. ÐžÑ‡ÐºÐ¸: {score}", 'minimized_game_over': "Ð˜Ð³Ñ€Ð° Ð¾ÐºÐ¾Ð½Ñ‡ÐµÐ½Ð°",
            'theme_setting': "Ð¦Ð²ÐµÑ‚Ð¾Ð²Ð°Ñ ÑÑ…ÐµÐ¼Ð°", 'custom_theme_edit_button': "Ð ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ", 'custom_theme_info': "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹Ñ‚Ðµ Ñ†Ð²ÐµÑ‚Ð° ÑÐ²Ð¾ÐµÐ¹ Ñ‚ÐµÐ¼Ñ‹",
            'color_grid_bg': "Ð¤Ð¾Ð½ ÑÐµÑ‚ÐºÐ¸", 'color_cell_empty': "ÐŸÑƒÑÑ‚Ð°Ñ ÑÑ‡ÐµÐ¹ÐºÐ°", 'color_cell_block_1': "Ð‘Ð»Ð¾Ðº 1",
            'color_cell_block_2': "Ð‘Ð»Ð¾Ðº 2", 'color_cell_block_3': "Ð‘Ð»Ð¾Ðº 3", 'color_cell_block_4': "Ð‘Ð»Ð¾Ðº 4",
            'color_cell_error': "ÐžÑˆÐ¸Ð±ÐºÐ°", 'color_error_cross': "ÐšÑ€ÐµÑÑ‚Ð¸Ðº Ð¾ÑˆÐ¸Ð±ÐºÐ¸", 'color_cell_preview': "ÐŸÑ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€", 'color_cell_clear': "ÐžÑ‡Ð¸ÑÑ‚ÐºÐ° Ð»Ð¸Ð½Ð¸Ð¸", 'color_cell_restart': "Ð ÐµÑÑ‚Ð°Ñ€Ñ‚",
            'color_game_over': "ÐŸÐ¾Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ", 'color_score_text': "Ð¢ÐµÐºÑÑ‚ Ð¾Ñ‡ÐºÐ¾Ð²", 'color_high_score_text': "Ð¢ÐµÐºÑÑ‚ Ñ€ÐµÐºÐ¾Ñ€Ð´Ð°",
            'color_button_bg': "Ð¤Ð¾Ð½ ÐºÐ½Ð¾Ð¿ÐºÐ¸", 'color_button_text': "Ð¢ÐµÐºÑÑ‚ ÐºÐ½Ð¾Ð¿ÐºÐ¸",
            'color_selected_shape_border': "Ð’Ñ‹Ð±Ð¾Ñ€ Ñ„Ð¸Ð³ÑƒÑ€Ñ‹", 'color_placeholder_shape_bg': "Ð¤Ð¾Ð½ Ñ„Ð¸Ð³ÑƒÑ€Ñ‹",
            'color_cube_bg': "Ð¤Ð¾Ð½ Ð²Ð¸Ð´Ð¶ÐµÑ‚Ð°", 'color_cube_border': "Ð“Ñ€Ð°Ð½Ð¸Ñ†Ð° Ð²Ð¸Ð´Ð¶ÐµÑ‚Ð°",
            'open_palette_button': "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð°Ð»Ð¸Ñ‚Ñ€Ñƒ", 'select_from_palette': "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ†Ð²ÐµÑ‚", 'done_button': "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾",
            'blur_effect_setting': "Ð­Ñ„Ñ„ÐµÐºÑ‚ Ð·Ð°Ñ‚ÐµÐ¼Ð½ÐµÐ½Ð¸Ñ", 'blur_options': ["ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½", "Ð¡Ð»Ð°Ð±Ñ‹Ð¹", "Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹", "Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ð¹", "ÐœÐ°ÐºÑÐ¸Ð¼ÑƒÐ¼"],
            'custom_theme_tab_window': "ÐžÐºÐ½Ð¾", 'custom_theme_tab_blocks': "Ð‘Ð»Ð¾ÐºÐ¸", 'custom_theme_tab_effects': "Ð­Ñ„Ñ„ÐµÐºÑ‚Ñ‹", 'custom_theme_tab_widget': "Ð’Ð¸Ð´Ð¶ÐµÑ‚",
            'show_cube_drag_border': "Ð“Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ Ð²Ð¸Ð´Ð¶ÐµÑ‚Ð° (Drag)",
            'emoji_style_setting': "Ð­Ð¼Ð¾Ð´Ð·Ð¸ ÑÑ‚Ð¸Ð»ÑŒ",
            'theme_preset_select': "ÐŸÑ€ÐµÑÐµÑ‚ Ñ‚ÐµÐ¼Ñ‹:",
            'cell_size_scale': "Ð Ð°Ð·Ð¼ÐµÑ€ ÐºÐ»ÐµÑ‚Ð¾Ðº (%)",
            'button_size_scale_restart': "Ð Ð°Ð·Ð¼ÐµÑ€ ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ð ÐµÑÑ‚Ð°Ñ€Ñ‚",
            'button_size_scale_choices': "Ð Ð°Ð·Ð¼ÐµÑ€ ÐºÐ½Ð¾Ð¿Ð¾Ðº Ð²Ñ‹Ð±Ð¾Ñ€Ð°",
            'button_size_scale_top': "Ð Ð°Ð·Ð¼ÐµÑ€ Ð²ÐµÑ€Ñ…Ð½Ð¸Ñ… ÐºÐ½Ð¾Ð¿Ð¾Ðº",
            'corner_radius_blocks_cells': "Ð—Ð°ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ¾Ð² Ð¸ ÐºÐ»ÐµÑ‚Ð¾Ðº (%)",
            'corner_radius_widget': "Ð—Ð°ÐºÑ€ÑƒÐ³Ð»ÐµÐ½Ð¸Ðµ Ð²Ð¸Ð´Ð¶ÐµÑ‚Ð° (%)",
            'combo_text': " x{count} ÐšÐžÐœÐ‘Ðž!",
            'gradient_button': "Ð“Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚ ðŸŒˆ",
            'gradient_editor_title': "Ð ÐµÐ´Ð°ÐºÑ‚Ð¾Ñ€ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚Ð°",
            'select_point_prompt': "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ñ‚Ð¾Ñ‡ÐºÑƒ {num} (Ð¸Ð»Ð¸ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð½Ð° Ð²Ñ‹Ð±Ñ€Ð°Ð½Ð½ÑƒÑŽ Ð´Ð»Ñ ÑÐ±Ñ€Ð¾ÑÐ°):",
            'point_selector_reset': "Ð¡Ð±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ Ñ‚Ð¾Ñ‡ÐºÐ¸",
            'point_select_tooltip': "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ 2 Ñ‚Ð¾Ñ‡ÐºÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°Ð´Ð°Ñ‚ÑŒ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚",
            'point_select_1': "Ð¢Ð¾Ñ‡ÐºÐ° 1", 'point_select_2': "Ð¢Ð¾Ñ‡ÐºÐ° 2",
            'point_set_color': "Ð’Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ Ñ†Ð²ÐµÑ‚ {num}",
            'point_selected': "Ð’Ñ‹Ð±Ñ€Ð°Ð½Ð¾",
            'theme_create_new_title': "Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð¹ Ñ‚ÐµÐ¼Ñ‹",
            'theme_create_name_prompt': "Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¸Ð¼Ñ Ñ‚ÐµÐ¼Ñ‹ (2-20 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²):",
            'theme_create_preset_prompt': "Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ñ€ÐµÑÐµÑ‚ Ð´Ð»Ñ Ð¾ÑÐ½Ð¾Ð²Ñ‹:",
            'theme_create_button': "Ð¡Ð¾Ð·Ð´Ð°Ñ‚ÑŒ",
            'theme_cancel_button': "ÐžÑ‚Ð¼ÐµÐ½Ð°",
            'theme_delete_button': "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ",
            'theme_delete_confirm_title': "Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ?",
            'share_theme_button': "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ñ‚ÐµÐ¼Ð¾Ð¹",
            'theme_copied': "Ð¡ÑÑ‹Ð»ÐºÐ° Ð½Ð° Ñ‚ÐµÐ¼Ñƒ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°!",
            'theme_imported': "Ð¢ÐµÐ¼Ð° '{name}' ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð°!",
            'theme_import_error': "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° Ñ‚ÐµÐ¼Ñ‹: {error}",
            'catalog_button': "ÐšÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ñ‚ÐµÐ¼", 'catalog_title': "ÐšÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ñ‚ÐµÐ¼", 'tab_themes': "Ð¢ÐµÐ¼Ñ‹", 'tab_add': "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ",
            'catalog_loading': "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð°...", 'catalog_error': "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸", 'theme_preview_title': "ÐŸÑ€ÐµÐ´Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ Ñ‚ÐµÐ¼Ñ‹",
            'install_theme': "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ", 'publish_confirm_title': "ÐŸÑƒÐ±Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ", 'publish_confirm_text': "Ð’Ñ‹ Ñ‚Ð¾Ñ‡Ð½Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¾Ð¿ÑƒÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ '{name}'?",
            'publish_success': "Ð¢ÐµÐ¼Ð° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð° Ð½Ð° Ð¼Ð¾Ð´ÐµÑ€Ð°Ñ†Ð¸ÑŽ!", 'theme_fetch_error': "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ", 'theme_preview_info': "Ð¦Ð²ÐµÑ‚Ð° Ñ‚ÐµÐ¼Ñ‹:",
            'alert_success': "Ð£ÑÐ¿ÐµÑˆÐ½Ð¾ DÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ >^ - ^<", 'alert_error': "ÐžÑˆÐ¸Ð±ÐºÐ° >T - T<",
            'alert_already_added': "Ð£Ð¶Ðµ dÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ >^~^<", 'catalog_count': "Ð’ÑÐµÐ³Ð¾ Ñ‚ÐµÐ¼: {count}/200",
            'theme_delete_confirm_text': "Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ '{theme_name}'? Ð­Ñ‚Ð¾ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð½ÐµÐ¾Ð±Ñ€Ð°Ñ‚Ð¸Ð¼Ð¾.",
        },
        'en': {
            'settings_header_cat_love': "Made with love for kitties >^-^<",
            'settings_footer_versions': "Built for [11.12.1 | 12.0.1]", 'settings_main_header': "BlockBlast Settings",
            'links_section_header': "Links", 'author_link_text': "AuthorðŸ¤", 'details_link_text': "DetailsðŸ”Ž",
            'display_section': "Display", 'game_section': "Game", 'theme_section': "Theme",
            'plugin_settings_section': "Plugin Settings",
            'style_section': "Style",
            'sizes_section': "Sizes",
            'show_in_drawer': "Show in Side Menu", 'show_in_chat_action': "Show in Chat Action",
            'show_exit_button': "Show 'Close' Button", 'exit_btn': "Close",
            'show_settings_button': "Show 'Settings' Button",
            'show_minimize_button': "Show 'Minimize' Button", 'restore_setting': "Maximize Mode",
            'restore_1_click': "1 Click", 'restore_2_click': "2 Clicks", 'restart_btn': "Restart",
            'game_name': "Block Puzzle", 'start_game': "Start Game", 'high_score': "High Score: {score}",
            'current_score': "Score: {score}", 'game_over': "Game Over! ðŸ’”", 'new_high': "NEW HIGH SCORE! ðŸŽ‰",
            'select_shape': "Select shape:", 'place_hint': "Click cell for preview/placement",
            'info_title': "About Game", 'info_text': "Place blocks to fill and clear complete rows or columns. Game Over when there is no room left for remaining shapes.",
            'save_error': "Error saving high score", 'clear': "Clear",
            'place_commit': "Click again to place", 'place_failed': "âŒ Cannot place here",
            'mode_setting': "Placement Mode", 'mode_click': "Click", 'mode_drag': "Drag",
            'mode_combined': "Combined",
            'error_highlight': "Occupied!", 'dismiss_alert': "High score saved", 'minimize_btn': "Minimize",
            'minimized_info': "Game minimized. Score: {score}", 'minimized_game_over': "Game Over",
            'theme_setting': "Color Scheme", 'custom_theme_edit_button': "Edit", 'custom_theme_info': "Customize your theme colors",
            'color_grid_bg': "Grid Background", 'color_cell_empty': "Empty Cell", 'cell_block_1': "Block 1",
            'color_cell_block_2': "Block 2", 'color_cell_block_3': "Block 3", 'color_cell_block_4': "Block 4",
            'color_cell_error': "Error", 'color_error_cross': "Error Cross", 'color_cell_preview': "Preview", 'color_cell_clear': "Line Clear", 'color_cell_restart': "Restart",
            'color_game_over': "Defeat", 'color_score_text': "Score Text", 'color_high_score_text': "High Score Text",
            'color_button_bg': "Button Background", 'color_button_text': "Button Text",
            'color_selected_shape_border': "Shape Selection", 'color_placeholder_shape_bg': "Shape Placeholder",
            'color_cube_bg': "Widget Background", 'color_cube_border': "Widget Border",
            'open_palette_button': "Open Palette", 'select_from_palette': "Select Color", 'done_button': "Done",
            'blur_effect_setting': "Dimming Effect", 'blur_options': ["Disabled", "Low", "Medium", "High", "Max"],
            'custom_theme_tab_window': "Window", 'custom_theme_tab_blocks': "Blocks", 'custom_theme_tab_effects': "Effects", 'custom_theme_tab_widget': "Widget",
            'show_cube_drag_border': "Widget Border (Drag)",
            'emoji_style_setting': "Emoji Style",
            'theme_preset_select': "Theme Preset:",
            'cell_size_scale': "Cell Size (%)",
            'button_size_scale_restart': "Restart Button Size",
            'button_size_scale_choices': "Choices Button Size",
            'button_size_scale_top': "Top Buttons Size",
            'corner_radius_blocks_cells': "Block/Cell Corner Radius (%)",
            'corner_radius_widget': "Widget Corner Radius (%)",
            'combo_text': " x{count} COMBO!",
            'gradient_button': "Gradient ðŸŒˆ",
            'gradient_editor_title': "Gradient Editor",
            'select_point_prompt': "Select Point {num} (or tap selected to reset):",
            'point_selector_reset': "Reset Points",
            'point_select_tooltip': "Select 2 points to define the gradient",
            'point_select_1': "Point 1", 'point_select_2': "Point 2",
            'point_set_color': "Select Color {num}",
            'point_selected': "Selected",
            'theme_create_new_title': "Create New Theme",
            'theme_create_name_prompt': "Enter theme name (2-20 characters):",
            'theme_create_preset_prompt': "Select a base preset:",
            'theme_create_button': "Create",
            'theme_cancel_button': "Cancel",
            'theme_delete_button': "Delete Theme",
            'theme_delete_confirm_title': "Delete Theme?",
            'share_theme_button': "Share Theme",
            'theme_copied': "Theme link copied!",
            'theme_imported': "Theme '{name}' imported successfully!",
            'theme_import_error': "Theme import error: {error}",
            'catalog_button': "Theme Catalog", 'catalog_title': "Theme Catalog", 'tab_themes': "Themes", 'tab_add': "Add",
            'catalog_loading': "Loading catalog...", 'catalog_error': "Load error", 'theme_preview_title': "Theme Preview",
            'install_theme': "Add", 'publish_confirm_title': "Publish", 'publish_confirm_text': "Are you sure you want to publish theme '{name}'?",
            'publish_success': "Theme sent for moderation!", 'theme_fetch_error': "Failed to fetch theme", 'theme_preview_info': "Theme colors:",
            'alert_success': "Successfully Added >^ - ^<", 'alert_error': "Error >T - T<",
            'alert_already_added': "Already added >^~^<", 'catalog_count': "Total themes: {count}/200",
            'theme_delete_confirm_text': "Are you sure you want to delete the theme '{theme_name}'? This action cannot be undone.",
        }
    }
    @classmethod
    def get(cls, key: str, **kwargs):
        from org.telegram.messenger import LocaleController
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        lang_key = 'ru' if lang.startswith('ru') else 'en'
        text = cls.strings.get(lang_key, cls.strings['en']).get(key, key)
        return text.format(**kwargs) if kwargs and isinstance(text, str) else text

EMOJI_MAP = {
    "grid_bg": "â¬œ", "cell_empty": "â¬›", "cell_block_1": "ðŸŸ¥", "cell_block_2": "ðŸŸ©",
    "cell_block_3": "ðŸŸ¦", "cell_block_4": "ðŸŸ¨", "cell_error": "âŒ", "error_cross": "âœ–ï¸", "cell_preview": "ðŸ‘€",
    "cell_clear": "âœ”ï¸", "cell_restart": "â™»ï¸", "game_over": "ðŸ’”", "score_text": "â­",
    "high_score_text": "ðŸŽ‰", "button_bg": "ðŸŽ¨", "button_text": "âœï¸",
    "selected_shape_border": "ðŸ”µ", "placeholder_shape_bg": "ðŸ”³", "cube_bg": "ðŸ§Š",
    "cube_border": "ðŸ”¹",
}

PLUGIN_SETTING_TABS_EMOJI = ["ðŸ“±", "âš™ï¸", "ðŸŽ®", "ðŸŽ¨"]
CUSTOM_THEME_TABS_EMOJI = ["ðŸ–¥ï¸", "ðŸš¥", "âœ¨", "ðŸ“Ÿ"]

GRADIENT_POINTS_MAP = {
    0: (GradientDrawable.Orientation.TOP_BOTTOM, [0, 1]), 
    1: (GradientDrawable.Orientation.LEFT_RIGHT, [0, 8]),  
    2: (GradientDrawable.Orientation.TR_BL, [2, 6]),       
    3: (GradientDrawable.Orientation.TL_BR, [0, 8]),       
    4: (GradientDrawable.Orientation.BOTTOM_TOP, [8, 0]), 
    5: (GradientDrawable.Orientation.RIGHT_LEFT, [8, 0]), 
    6: (GradientDrawable.Orientation.BR_TL, [8, 0]),       
    7: (GradientDrawable.Orientation.BL_TR, [6, 2]),       
    8: (GradientDrawable.Orientation.TOP_BOTTOM, [1, 7]),  
    9: (GradientDrawable.Orientation.LEFT_RIGHT, [3, 5]),  
}

def hsv_to_rgb(h, s, v):
    return tuple(round(i * 255) for i in colorsys.hsv_to_rgb(h, s, v))
def rgb_to_hsv(r, g, b):
    return colorsys.rgb_to_hsv(r/255., g/255., b/255.)
def color_to_hsv(r, g, b):
    return rgb_to_hsv(r, g, b)
def generate_shades(r, g, b, count=8):
    shades = []
    h, s, v = color_to_hsv(r, g, b)
    for i in range(count):
        shade_v = max(0, v - (i * 0.1))
        shades.append(hsv_to_rgb(h, s, shade_v))
    return shades
def generate_hsv_matrix(r, g, b, size=8):
    h, s, v = color_to_hsv(r, g, b)
    matrix = []
    for row in range(size):
        row_colors = []
        for col in range(size):
            new_s = max(0.0, min(1.0, col / (size - 1.0)))
            new_v = max(0.0, min(1.0, 1.0 - (row / (size - 1.0))))
            row_colors.append(hsv_to_rgb(h, s, new_v))
        matrix.append(row_colors)
    return matrix

if UI_CLASSES_LOADED:





    GRADIENT_ORIENTATION_MAP = {
        (0, 8): GradientDrawable.Orientation.TL_BR, (8, 0): GradientDrawable.Orientation.BR_TL,
        (2, 6): GradientDrawable.Orientation.TR_BL, (6, 2): GradientDrawable.Orientation.BL_TR,
        (1, 7): GradientDrawable.Orientation.TOP_BOTTOM, (7, 1): GradientDrawable.Orientation.BOTTOM_TOP,
        (3, 5): GradientDrawable.Orientation.LEFT_RIGHT, (5, 3): GradientDrawable.Orientation.RIGHT_LEFT,
        (0, 2): GradientDrawable.Orientation.LEFT_RIGHT, (2, 0): GradientDrawable.Orientation.RIGHT_LEFT,
        (6, 8): GradientDrawable.Orientation.LEFT_RIGHT, (8, 6): GradientDrawable.Orientation.RIGHT_LEFT,
        (0, 6): GradientDrawable.Orientation.TOP_BOTTOM, (6, 0): GradientDrawable.Orientation.BOTTOM_TOP,
        (2, 8): GradientDrawable.Orientation.TOP_BOTTOM, (8, 2): GradientDrawable.Orientation.BOTTOM_TOP,
        (4, 0): GradientDrawable.Orientation.BOTTOM_TOP, (0, 4): GradientDrawable.Orientation.TOP_BOTTOM, 

        (1, 8): GradientDrawable.Orientation.TL_BR, (8, 1): GradientDrawable.Orientation.BR_TL, 
        (0, 7): GradientDrawable.Orientation.BL_TR, (7, 0): GradientDrawable.Orientation.TR_BL, 

    }
    

    POINT_COORDINATES = {
        0: (0, 0), 1: (50, 0), 2: (100, 0),
        3: (0, 50), 4: (50, 50), 5: (100, 50),
        6: (0, 100), 7: (50, 100), 8: (100, 100),
    }
    
    def get_gradient_orientation(point1: int, point2: int):
        """ÐŸÑ‹Ñ‚Ð°ÐµÑ‚ÑÑ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¾Ð´Ð½Ñƒ Ð¸Ð· 8 Ð¾ÑÐ½Ð¾Ð²Ð½Ñ‹Ñ… Ð¾Ñ€Ð¸ÐµÐ½Ñ‚Ð°Ñ†Ð¸Ð¹ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚Ð°."""
        if point1 == point2: return GradientDrawable.Orientation.TOP_BOTTOM 


        key = tuple(sorted([point1, point2]))
        

        if key == (0, 8): return GradientDrawable.Orientation.TL_BR
        if key == (2, 6): return GradientDrawable.Orientation.TR_BL
        

        if key == (1, 7): return GradientDrawable.Orientation.TOP_BOTTOM
        if key == (3, 5): return GradientDrawable.Orientation.LEFT_RIGHT
        

        if (point1 == 0 or point1 == 3 or point1 == 6) and (point2 == 2 or point2 == 5 or point2 == 8): 
            return GradientDrawable.Orientation.LEFT_RIGHT
        if (point1 == 0 or point1 == 1 or point1 == 2) and (point2 == 6 or point2 == 7 or point2 == 8): 
            return GradientDrawable.Orientation.TOP_BOTTOM


        return GradientDrawable.Orientation.TL_BR

    class SeekBarChangeListener(dynamic_proxy(SeekBar.OnSeekBarChangeListener)):
        def __init__(self, update_callback: Callable, min_value: int, step_size: int):
            super().__init__()
            self.update_callback = update_callback
            self.min_value = min_value
            self.step_size = step_size
        def onProgressChanged(self, seekBar: SeekBar, progress: int, fromUser: bool):
            if fromUser:
                actual_value = progress * self.step_size + self.min_value
                self.update_callback(seekBar, actual_value)
        def onStartTrackingTouch(self, seekBar: SeekBar): pass
        def onStopTrackingTouch(self, seekBar: SeekBar):
            actual_value = seekBar.getProgress() * self.step_size + self.min_value
            self.update_callback(seekBar, actual_value)
    
    class CheckedChangeListenerProxy(dynamic_proxy(CompoundButton.OnCheckedChangeListener)):
        def __init__(self, callback: Callable[[bool], None]):
            super().__init__()
            self.callback = callback
        def onCheckedChanged(self, buttonView: CompoundButton, isChecked: bool):
            try:
                if self.callback: self.callback(isChecked)
            except Exception as e:
                log(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² CheckedChangeListener:\n{traceback.format_exc()}")

    def CubeDrawable(color_hex, theme_border_color):
        drawable = GradientDrawable()
        drawable.setShape(GradientDrawable.RECTANGLE)
        drawable.setCornerRadius(AndroidUtilities.dp(2))
        drawable.setColor(Color.parseColor(color_hex))
        drawable.setStroke(AndroidUtilities.dp(2), Color.parseColor(theme_border_color))
        return drawable
else:
    class SeekBarChangeListener: pass
    class CheckedChangeListenerProxy: pass
    class CubeDrawable:
        def __init__(self, color_hex, theme_border_color): pass


if UI_CLASSES_LOADED:
    class ClickListenerProxy(dynamic_proxy(OnClickListener)):
        def __init__(self, plugin: 'BlockBlastPlugin', callback: Callable):
            super().__init__()
            self.plugin = plugin
            self.callback = callback
        def onClick(self, view):
            try:
                self.plugin._animate_button_press(view)
                if self.callback:
                    self.callback(view)
            except Exception as e:
                log(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² ClickListener:\n{traceback.format_exc()}")

    class RunnableProxy(dynamic_proxy(Runnable)):
        def __init__(self, callback): super().__init__(); self.callback = callback
        def run(self):
            try:
                if self.callback: self.callback()
            except Exception: log(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Runnable:\n{traceback.format_exc()}")

    class DismissListenerProxy(dynamic_proxy(OnDismissListener)):
        def __init__(self, callback): super().__init__(); self.callback = callback
        def onDismiss(self, dialog):
            try:
                plugin = self.callback()
                if plugin:
                     plugin._on_game_dialog_dismiss_internal()
            except Exception:
                log(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² DismissListener:\n{traceback.format_exc()}")

    class FloatingCubeTouchListener(dynamic_proxy(OnTouchListener)):
        def __init__(self, cube_view, plugin_instance):
            super().__init__()
            self.plugin = plugin_instance
            self.cube_view = cube_view
            self.last_tap_time = 0
            self.is_dragging = False
            self.initial_x, self.initial_y = 0, 0
            self.initial_view_x, self.initial_view_y = 0, 0
            self.double_tap_timeout = 300
            self.drag_threshold = AndroidUtilities.dp(5)

        def onTouch(self, view, event):
            action = event.getAction()
            lp = view.getLayoutParams()
            if not isinstance(lp, FrameLayout.LayoutParams): return False

            restore_mode = self.plugin.get_setting("restore_mode_pg", 1)
            show_drag_border = self.plugin.get_setting("show_cube_drag_border_pg", True)

            if action == MotionEvent.ACTION_DOWN:
                self.plugin._animate_view_press_down(view)
                self.initial_x, self.initial_y = event.getRawX(), event.getRawY()
                self.initial_view_x, self.initial_view_y = lp.leftMargin, lp.topMargin
                self.is_dragging = False
                self.drag_start_time = JavaSystem.currentTimeMillis()
                current_time = int(time.time() * 1000)

                if show_drag_border:
                    self.plugin.pg_floating_cube.set_dragging_border_state(True)

                if restore_mode == 1:
                    if current_time - self.last_tap_time < self.double_tap_timeout:
                        self.last_tap_time = 0
                        self.plugin._safe_restore_from_touch()
                        return True
                    self.last_tap_time = current_time
                else: self.last_tap_time = current_time
                return True

            elif action == MotionEvent.ACTION_MOVE:
                dx = event.getRawX() - self.initial_x
                dy = event.getRawY() - self.initial_y
                if not self.is_dragging and (abs(dx) > self.drag_threshold or abs(dy) > self.drag_threshold):
                    self.is_dragging = True
                if self.is_dragging:
                    new_x = int(self.initial_view_x + dx)
                    new_y = int(self.initial_view_y + dy)
                    screen_w, screen_h = AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y
                    view_w, view_h = view.getMeasuredWidth(), view.getMeasuredHeight()
                    status_bar_height = AndroidUtilities.statusBarHeight
                    max_x, max_y = screen_w - view_w, screen_h - view_h
                    lp.leftMargin = max(0, min(new_x, max_x))
                    lp.topMargin = max(status_bar_height, min(new_y, max_y))
                    view.requestLayout()
                return True

            elif action == MotionEvent.ACTION_UP:
                self.plugin._animate_view_release_up(view)
                if show_drag_border:
                    self.plugin.pg_floating_cube.set_dragging_border_state(False)
                    
                if restore_mode == 0 and not self.is_dragging:
                    self.plugin._safe_restore_from_touch()
                    return True
                self.plugin._save_cube_position(lp.leftMargin, lp.topMargin)
                self.is_dragging = False
                return True
            
            elif action == MotionEvent.ACTION_CANCEL:
                self.plugin._animate_view_release_up(view)
                if show_drag_border:
                    self.plugin.pg_floating_cube.set_dragging_border_state(False)
                self.is_dragging = False
                return False
                
            return False

    class OnDragDropListenerProxy(dynamic_proxy(OnTouchListener)):
        def __init__(self, plugin_instance):
            super().__init__()
            self.plugin = plugin_instance
            self.is_dragging = False
            self.initial_x, self.initial_y = 0, 0
            self.dragged_shape_index = -1
            self.original_visibility = View.VISIBLE
            self.drag_start_time = 0
            self.last_grid_pos = None
            self.was_selected = False
            self.last_move_time = 0

        def onTouch(self, view, event):
            try:
                mode = self.plugin.get_setting("placement_mode_pg", 0)
                if mode not in [1, 2] or self.plugin.pg_game_over:
                    return False
                action = event.getAction()
                if action == MotionEvent.ACTION_DOWN:
                    self.plugin._animate_view_press_down(view)
                    self.dragged_shape_index = view.getTag()
                    self.was_selected = (self.plugin.pg_selected_shape_index == self.dragged_shape_index)
                    if self.plugin.pg_current_shapes[self.dragged_shape_index] is None:
                        self.dragged_shape_index = -1; return False
                    self.initial_x, self.initial_y = event.getRawX(), event.getRawY(); self.is_dragging = False
                    self.drag_start_time = time.time()
                    self.last_grid_pos = None
                    self.plugin.pg_selected_shape_index = self.dragged_shape_index
                    self.plugin._clear_preview(); 
                    self.plugin._draw_shapes() 

                    shape_id, color_id = self.plugin.pg_current_shapes[self.dragged_shape_index], self.dragged_shape_index + 1
                    self.plugin._perform_haptic(view); self.plugin._start_drag_visual(view.getContext(), shape_id, color_id, self.initial_x, self.initial_y); view.setAlpha(0.3)
                    return True
                elif action == MotionEvent.ACTION_MOVE:
                    if self.dragged_shape_index == -1: return False
                    dx, dy = event.getRawX() - self.initial_x, event.getRawY() - self.initial_y

                    if not self.is_dragging and (abs(dx) > PG_DRAG_THRESHOLD or abs(dy) > PG_DRAG_THRESHOLD):
                        self.is_dragging = True
                        self.plugin._update_status(Locales.get('place_hint'))

                    if self.is_dragging:
                        self.plugin._update_drag_visual_position(event.getRawX(), event.getRawY())

                        current_time = JavaSystem.currentTimeMillis()
                        if current_time - getattr(self, 'last_move_time', 0) < 50:
                            return True
                        self.last_move_time = current_time

                        r, c = self._map_to_grid(event.getRawX(), event.getRawY())
                        current_pos = (r, c)

                        if self.last_grid_pos == current_pos:
                            return True
                        self.last_grid_pos = current_pos

                        self.plugin._reset_temporary_errors()

                        shape_id = self.plugin.pg_current_shapes[self.dragged_shape_index]
                        if not shape_id: return True
                        shape_cells = PG_SHAPES.get(shape_id)

                        if r is not None and c is not None:
                            can_place = self.plugin._check_placement(r, c, shape_cells)
                            new_preview_cells = [(r + dr, c + dc) for dr, dc in shape_cells]
                            self.plugin._update_preview_on_grid(new_preview_cells, is_error=not can_place)
                            self.plugin.pg_last_preview_start_cell = (r, c)
                            self.plugin._update_status(Locales.get('place_failed') if not can_place else Locales.get('place_hint'))
                        else:
                            self.plugin._update_preview_on_grid([])
                            self.plugin.pg_last_preview_start_cell = None
                            self.plugin._update_status("")
                    return True
                elif action in [MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL]:
                    self.plugin._animate_view_release_up(view)
                    view.setAlpha(1.0)
                    if self.dragged_shape_index == -1: return False
                    if self.plugin.is_highlighting_error: return False
                    
                    self.plugin._end_drag_visual();
                    
                    is_tap = time.time() - self.drag_start_time < 0.5 and not self.is_dragging
                    
                    if self.is_dragging and self.plugin.pg_last_preview_start_cell is not None:
                        r, c = self.plugin.pg_last_preview_start_cell
                        shape_id = self.plugin.pg_current_shapes[self.dragged_shape_index]; shape_cells = PG_SHAPES.get(shape_id)
                        
                        if self.plugin._check_placement(r, c, shape_cells):
                            self.plugin._commit_placement(r, c, shape_cells); 
                            self.plugin._update_status("")
                        else: 

                            self.plugin._highlight_error(self.plugin._get_occupied_cells(r, c, shape_cells))
                            self.plugin._update_status(Locales.get('place_failed'))

                    elif is_tap:
                        if mode == 2:
                            self.plugin._end_drag_visual()
                            if self.was_selected:
                                self.plugin.pg_selected_shape_index = -1
                                self.plugin._clear_preview()
                                self.plugin._update_status("")
                            else:
                                self.plugin._update_status(Locales.get('place_hint'))
                            
                            self.plugin._draw_grid()
                            self.plugin._draw_shapes()
                            self.is_dragging = False; self.dragged_shape_index = -1; self.last_grid_pos = None
                            return True
                        
                    self.plugin.pg_selected_shape_index = -1; self.plugin._clear_preview(); 
                    self.plugin._draw_grid();
                    
                    self.plugin._draw_shapes()
                    self.plugin._update_status("")
                    self.is_dragging = False; self.dragged_shape_index = -1; self.last_grid_pos = None
                    return True
                return False
            except Exception as e:
                log(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² OnDragDropListenerProxy: {e}\n{traceback.format_exc()}")
                if hasattr(self, 'plugin') and self.plugin: self.plugin._end_drag_visual()
                view.setVisibility(View.VISIBLE)
                if hasattr(self, 'plugin'):
                    self.plugin.pg_selected_shape_index = -1; self.plugin._clear_preview(); self.plugin._draw_grid(); self.plugin._draw_shapes()
                    self.plugin._update_status("Error in Drag Mode!")
                self.is_dragging = False; self.dragged_shape_index = -1
                return False
        def _map_to_grid(self, raw_x, raw_y) -> Tuple[Optional[int], Optional[int]]:
            info = PG_GRID_INFO
            if info["cell_size"] == 0: return None, None
            loc = info["location"]; cell_total_size = info["cell_size"] + 2 * info["margin"]
            if not (loc[0] <= raw_x <= loc[0] + info["size"] and loc[1] <= raw_y <= loc[1] + info["size"]):
                return None, None
            relative_x, relative_y = raw_x - loc[0], raw_y - loc[1]
            c, r = math.floor(relative_x / cell_total_size), math.floor(relative_y / cell_total_size)
            if 0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE:
                return r, c
            return None, None
else:
    class ClickListenerProxy: pass
    class RunnableProxy: pass
    class DismissListenerProxy: pass
    class FloatingCubeTouchListener: pass
    class OnDragDropListenerProxy: pass
    class SeekBarChangeListener: pass
    class CheckedChangeListenerProxy: pass


class FloatingGameCube:
    CUBE_SIZE = AndroidUtilities.dp(60)
    DEFAULT_MARGIN = AndroidUtilities.dp(16)
    def __init__(self, plugin_instance: 'BlockBlastPlugin'):
        self.plugin, self.view, self.score_text_view, self.root_view = plugin_instance, None, None, None
        self.is_attached, self.pg_bg_drawable, self.block_views, self.block_grid, self.content_container = False, None, [], None, None
    def _create_block_grid(self, context) -> Tuple[LinearLayout, List[View]]:
        grid, block_views = LinearLayout(context), []; grid.setOrientation(LinearLayout.VERTICAL); grid.setGravity(Gravity.CENTER)

        border_width = AndroidUtilities.dp(2)
        content_size = self.CUBE_SIZE - (2 * border_width)
        margin = AndroidUtilities.dp(2)
        cell_size = (content_size - margin) // 2

        for r in range(2):
            row_layout = LinearLayout(context); row_layout.setOrientation(LinearLayout.HORIZONTAL)
            for c in range(2):
                block, bg = View(context), GradientDrawable(); bg.setShape(GradientDrawable.RECTANGLE)
                bg.setCornerRadius(0)
                block.setBackground(bg)
                params = LinearLayout.LayoutParams(cell_size, cell_size)
                right_margin = margin if c == 0 else 0
                bottom_margin = margin if r == 0 else 0
                params.setMargins(0, 0, right_margin, bottom_margin)
                block.setLayoutParams(params)
                block_views.append(block); row_layout.addView(block)
            grid.addView(row_layout)
        return grid, block_views
    def _draw_blocks(self):
        if not self.block_views: return
        colors = self.plugin.pg_cube_colors
        for i, block in enumerate(self.block_views):
            bg = block.getBackground()
            color_hex = colors[i] if i < len(colors) else self.plugin.pg_empty_color
            if isinstance(bg, GradientDrawable): bg.setColor(Color.parseColor(color_hex))
    
    def set_dragging_border_state(self, is_dragging: bool):
        if not self.view:
            return
        self.update_display(is_dragging=is_dragging)
    def attach(self, activity):
        if self.is_attached: return
        try:
            if LaunchActivity.instance:
                decor_view = LaunchActivity.instance.getWindow().getDecorView(); root_view = decor_view.findViewById(android_R_id_content) or decor_view
            else: return
            if not root_view or not isinstance(root_view, ViewGroup): log(f"[{__name__}] Root view not found or invalid type."); return

            self.root_view, self.view = root_view, FrameLayout(activity)
            self.view.setLayoutParams(FrameLayout.LayoutParams(self.CUBE_SIZE, self.CUBE_SIZE)); self.view.setElevation(AndroidUtilities.dp(8))
            self.content_container = FrameLayout(activity)
            border_width = AndroidUtilities.dp(2)
            content_params = FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT)
            content_params.setMargins(border_width, border_width, border_width, border_width)
            self.view.addView(self.content_container, content_params)

            self.block_grid, self.block_views = self._create_block_grid(activity)
            self.content_container.addView(self.block_grid, LayoutHelper.createFrame(-2, -2, Gravity.CENTER))

            self.score_text_view = TextView(activity)
            self.score_text_view.setTextColor(Color.WHITE)
            self.score_text_view.setTextSize(14)
            self.score_text_view.setTypeface(None, Typeface.BOLD)
            self.score_text_view.setGravity(Gravity.CENTER)
            self.content_container.addView(self.score_text_view, LayoutHelper.createFrame(-1, -1))

            percentage = self.plugin.get_setting("corner_radius_widget_pg", 0) / 100.0
            base_radius_px = AndroidUtilities.dp(2)
            max_radius_px = self.CUBE_SIZE / 2.0
            radius = base_radius_px + (max_radius_px - base_radius_px) * percentage

            bg_border = GradientDrawable()
            bg_border.setShape(GradientDrawable.RECTANGLE)
            bg_border.setCornerRadius(radius)
            bg_border.setColor(Color.TRANSPARENT)
            self.view.setBackground(bg_border)

            bg_content = GradientDrawable()
            bg_content.setShape(GradientDrawable.RECTANGLE)
            bg_content.setCornerRadius(radius - border_width if radius > border_width else radius)
            bg_content.setColor(Color.parseColor(self.plugin._get_themed_color("cube_bg")))
            self.content_container.setBackground(bg_content)

            if Build.VERSION.SDK_INT >= 21:
                self.view.setClipToOutline(True)
                if self.content_container:
                    self.content_container.setClipToOutline(True)

            x, y = self.plugin._load_cube_position()
            screen_w, screen_h = AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y
            if x == -1: x = screen_w - self.CUBE_SIZE - self.DEFAULT_MARGIN
            if y == -1: y = screen_h - self.CUBE_SIZE - self.DEFAULT_MARGIN - AndroidUtilities.statusBarHeight
            params = FrameLayout.LayoutParams(self.CUBE_SIZE, self.CUBE_SIZE, Gravity.TOP | Gravity.LEFT)
            params.leftMargin = x
            params.topMargin = y
            self.view.setLayoutParams(params); self.view.setOnTouchListener(FloatingCubeTouchListener(self.view, self.plugin)); self.view.setClickable(True)
            root_view.addView(self.view); self.is_attached = True; self.update_display()
        except Exception as e: log(f"Error attaching floating cube: {e}\n{traceback.format_exc()}"); self.detach()
    def detach(self):
        if not self.is_attached: return
        try:
            if self.root_view and self.view and hasattr(self.root_view, 'removeView'): self.root_view.removeView(self.view)
        except: pass
        finally: self.root_view, self.view, self.score_text_view, self.pg_bg_drawable, self.block_views, self.block_grid, self.is_attached, self.content_container = None, None, None, None, [], None, False, None
    def update_display(self, is_dragging: bool = False):
        if not self.view or not self.score_text_view:
            return

        self.score_text_view.setText(str(self.plugin.pg_score))
        self.score_text_view.setTextColor(Color.parseColor(self.plugin._get_themed_color("score_text")))
        
        bg_border = self.view.getBackground()
        bg_content = self.content_container.getBackground() if self.content_container else None

        if not isinstance(bg_border, GradientDrawable):
            bg_border = GradientDrawable()
            bg_border.setShape(GradientDrawable.RECTANGLE)
            self.view.setBackground(bg_border)
            if Build.VERSION.SDK_INT >= 21:
                self.view.setClipToOutline(True)

        if self.content_container and not isinstance(bg_content, GradientDrawable):
            bg_content = GradientDrawable()
            bg_content.setShape(GradientDrawable.RECTANGLE)
            self.content_container.setBackground(bg_content)
            if Build.VERSION.SDK_INT >= 21:
                self.content_container.setClipToOutline(True)

        percentage = self.plugin.get_setting("corner_radius_widget_pg", 0) / 100.0
        base_radius_px = AndroidUtilities.dp(2)
        max_radius_px = self.CUBE_SIZE / 2.0
        border_width = AndroidUtilities.dp(2)
        radius = base_radius_px + (max_radius_px - base_radius_px) * percentage
        
        bg_border.setCornerRadius(radius)
        if bg_content:
            bg_content.setCornerRadius(radius - border_width if radius > border_width else radius)
        
        is_drag_border_on = is_dragging and self.plugin.get_setting("show_cube_drag_border_pg", True) and not self.plugin.pg_game_over
        
        if not self.plugin.pg_game_over:
            self._draw_blocks()
            self.score_text_view.setAlpha(0.8)
            if self.block_grid: self.block_grid.setVisibility(View.VISIBLE)
            
            if bg_content: bg_content.setColor(Color.parseColor(self.plugin._get_themed_color("cube_bg")))
            
            if is_drag_border_on:
                border_color = self.plugin._get_themed_color("cube_border")
                bg_border.setColor(Color.parseColor(border_color))
            else:
                bg_border.setColor(Color.TRANSPARENT)
        else:
            self.score_text_view.setAlpha(1.0)
            self.score_text_view.setText(Locales.get('minimized_game_over'))
            if self.block_grid: self.block_grid.setVisibility(View.GONE)
            
            if bg_content: bg_content.setColor(Color.parseColor(self.plugin._get_themed_color("cube_bg")))
            bg_border.setColor(Color.parseColor(self.plugin._get_themed_color("game_over")))



class BlockBlastDeepLinkHook(MethodHook):
    def __init__(self, plugin):

        self.plugin = weakref.ref(plugin)

    def before_hooked_method(self, param):
        plugin = self.plugin()
        if not plugin:
            return
        
        try:
            intent = param.args[0]
            if not intent or not intent.getData():
                return

            uri = intent.getData()
            scheme = uri.getScheme()
            host = uri.getHost()

            if scheme == "tg" and host == "blockblast":
                JList = find_class("java.util.List")
                path_segments = cast(JList, uri.getPathSegments())
                # Expected: /theme/{name}/{data}
                if path_segments and path_segments.size() >= 3 and path_segments.get(0) == "theme":
                    theme_name = path_segments.get(1)
                    theme_data = path_segments.get(2)
                    plugin._import_theme_from_link(theme_name, theme_data)
                    param.setResult(None) # Consume event
        except Exception as e:
            log(f"[BlockBlast] Deep link error: {e}")
class BlockBlastBrowserHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = weakref.ref(plugin)

    def before_hooked_method(self, param):
        plugin = self.plugin()
        if not plugin:
            return
        
        try:
            if len(param.args) < 2:
                return
            
            url_arg = param.args[1]
            if url_arg is None:
                return
            
            url_str = str(url_arg.toString())
            if "tg://blockblast" in url_str:
                # Parse manually as Uri if needed, or just string manipulate
                # Format: tg://blockblast/theme/{name}/{data}
                # We can use Android Uri to parse
                uri = Uri.parse(url_str)
                JList = find_class("java.util.List")
                path_segments = cast(JList, uri.getPathSegments())
                
                if path_segments and path_segments.size() >= 3 and path_segments.get(0) == "theme":
                    theme_name = path_segments.get(1)
                    theme_data = path_segments.get(2)
                    plugin._import_theme_from_link(theme_name, theme_data)
                    param.setResult(None) # Consume event
        except Exception as e:
            log(f"[BlockBlast] Browser hook error: {e}")



class BlockBlastPlugin(BasePlugin):
    pg_iterator_index = 0
    DIALOG_BASE, DIALOG_SHADES, DIALOG_MATRIX = 0, 1, 2
    pg_current_r, pg_current_g, pg_current_b = 255, 0, 0
    pg_preview_view, pg_hex_display, pg_r_bar, pg_g_bar, pg_b_bar = None, None, None, None, None
    pg_palette_dialog, pg_active_palette_tab, pg_content_wrapper = None, DIALOG_BASE, None
    pg_tab_buttons, pg_palette_target_key = {}, None
    gui_custom_theme_dialog = None
    is_refreshing_ui = False
    full_screen_blur_overlay = None
    
    gui_settings_dialog = None
    gui_settings_active_tab = 0
    gui_settings_tab_buttons = {}
    gui_settings_tab_content_frames = {}
    gui_settings_custom_theme_button = None
    
    animation_thread = None
    animation_thread_running = False
    _anim_start_time = JavaSystem.currentTimeMillis()
    

    GRADIENT_EDITOR_DIALOG = None
    GRADIENT_PREVIEW_VIEW = None
    GRADIENT_POINT_BUTTONS = {}
    GRADIENT_COLOR_BUTTONS = {}
    
    
    GRADIENT_POINT_MAPPINGS = {
        0: "TopLeft", 1: "TopCenter", 2: "TopRight",
        3: "CenterLeft", 4: "Center", 5: "CenterRight",
        6: "BottomLeft", 7: "BottomCenter", 8: "BottomRight",
    }
    
    grad_state = {
        'active_point_index': -1,  
        'point_1_id': -1,          
        'point_2_id': -1,          
        'color_1_hex': "#000000",
        'color_2_hex': "#FFFFFF",
        'gradient_dialog': None,
        'main_view': None,
    }
    def _get_id_clean(self, val):
        v = str(val).strip()
        if "mockapi.io" in v:
            try: return v.split(".mockapi.io")[0].split("//")[-1]
            except: return v
        return v

    def _make_u_url(self, n):
        ul = globals().get("users", [])
        if not ul: return ""
        idx = (n - 1) // 2
        if idx >= len(ul): return ""
        uid = self._get_id_clean(ul[idx])
        s = "" if n == 1 else str(n)
        return f"https://{uid}.mockapi.io/board/users{s}"

    @property
    def USERS_API_URL_1(self): return self._make_u_url(1)
    @property
    def USERS_API_URL_2(self): return self._make_u_url(2)
    @property
    def USERS_API_URL_3(self): return self._make_u_url(3)
    @property
    def USERS_API_URL_4(self): return self._make_u_url(4)

    @property
    def CATALOG_API_URL(self):
        tl = globals().get("themes", [])
        if not tl: return ""
        tid = self._get_id_clean(tl[0])
        return f"https://{tid}.mockapi.io/theme/themes"
    # ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ð°Ð½Ð¾Ð½Ð¸Ð¼Ð½ÑƒÑŽ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ (ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ‚ÐµÐ¼/Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹) Ð½Ð° mockapi Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ð¸Ñ‚Ð¸ÐºÐ¸ Ñ€Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ°.
    # Sends anonymous stats (count of themes/users) to mockapi for developer analytics.
    def _report_admin_stats(self):
        def task():
            try:
                import requests
                ul = globals().get("users", [])
                tl = globals().get("themes", [])
                
                u_local = [self._get_id_clean(x) for x in ul if x]
                t_local = [self._get_id_clean(x) for x in tl if x]
                
                base_url = "https://6927367326e7e41498fd7bc9.mockapi.io/secret/admin"
                
                existing_u, existing_t = [], []
                is_update = False
                
                try:
                    r = requests.get(f"{base_url}/1", timeout=10, verify=False)
                    if r.status_code == 200:
                        d = r.json()
                        existing_u = [x.strip() for x in d.get("users_url", "").split(",") if x.strip()]
                        existing_t = [x.strip() for x in d.get("themes_url", "").split(",") if x.strip()]
                        is_update = True
                except: pass
                
                final_u = list(existing_u)
                for u in u_local:
                    if u not in final_u: final_u.append(u)
                        
                final_t = list(existing_t)
                for t in t_local:
                    if t not in final_t: final_t.append(t)
                
                payload = {
                    "users_max": str(len(final_u) * 200),
                    "themes_max": str(len(final_t) * 200),
                    "users_url": ",".join(final_u),
                    "themes_url": ",".join(final_t)
                }
                
                try:
                    if is_update: requests.put(f"{base_url}/1", json=payload, timeout=10, verify=False)
                    else: requests.post(base_url, json=payload, timeout=10, verify=False)
                except Exception as e: log(f"[BlockBlast] Admin sync failed: {e}")
            except Exception as e:
                log(f"[BlockBlast] Admin stats error: {e}")
        threading.Thread(target=task).start()





    def __init__(self):
        super().__init__()
        self.animation_thread = None # ÐŸÐ¾Ñ‚Ð¾Ðº Ð´Ð»Ñ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¹
        self.dialog, self.pg_grid = None, [[0] * PG_GRID_SIZE for _ in range(PG_GRID_SIZE)]
        self.pg_score, self.pg_high_score, self.pg_game_over = 0, self._load_high_score(), True
        self.pg_current_shapes, self.pg_selected_shape_index = [None, None, None], -1
        self.pg_is_starting_new_game, self.pg_should_recheck_game_over = False, False
        self.pg_game_over_handler = None
        self.pg_preview_cells, self.pg_last_preview_start_cell, self.pg_preview_is_error = [], None, False
        self.pg_combo_count = 0 
        self.score_view, self.high_score_view, self.status_view = None, None, None
        self.grid_buttons, self.shape_buttons, self.pg_grid_container = [], [], None
        self.pg_context, self.pg_floating_cube, self.pg_drag_view, self.pg_drag_listener_instance = None, None, None, None
        self.pg_cube_colors, self.pg_drag_view, self.pg_drag_listener_instance = [], None, None
        self.pg_shape_preview_containers = []
        self._drawer_menu_id, self._chat_action_menu_id, self._dismiss_listener_ref = None, None, None
        self.hook_browser_refs = []
        self.hook_deep_link_ref = None
        self.pg_palette_target_key = None
        self.gui_custom_theme_color_rows = {}
        self.shape_button_states = {}
        self.is_highlighting_error = False
        self._is_checking_game_over = False
    def _get_current_username(self):
        try:
            user = UserConfig.getInstance(0).getCurrentUser()
            if user and user.username:
                return "@" + user.username
            elif user and user.first_name:
                return user.first_name
            return "Unknown"
        except:
            return "Unknown"
    # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ ID Ð¸ Ð˜Ð¼Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð´Ð»Ñ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ Ñ€ÐµÐºÐ¾Ñ€Ð´Ð° Ð² Ð¿ÑƒÐ±Ð»Ð¸Ñ‡Ð½Ð¾Ð¹ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ðµ Ð»Ð¸Ð´ÐµÑ€Ð¾Ð² (mockapi).
    # Uses User ID and Name to save the high score in the public leaderboard (mockapi).
    def _upload_high_score(self, score):
        def task():
            try:
                import requests
                my_id = str(UserConfig.getInstance(0).clientUserId)
                username = self._get_current_username()
                
                # Helper to find user
                target_url = None
                existing_record = None
                
                # Check 1
                try:
                    resp1 = requests.get(f"{self.USERS_API_URL_1}?author_id={my_id}", timeout=5, verify=False)
                    if resp1.status_code == 200:
                        data1 = resp1.json()
                        if isinstance(data1, list) and len(data1) > 0:
                            existing_record = data1[0]
                            target_url = self.USERS_API_URL_1
                except: pass
                
                # Check 2 if not found
                if not existing_record:
                    try:
                        resp2 = requests.get(f"{self.USERS_API_URL_2}?author_id={my_id}", timeout=5, verify=False)
                        if resp2.status_code == 200:
                            data2 = resp2.json()
                            if isinstance(data2, list) and len(data2) > 0:
                                existing_record = data2[0]
                                target_url = self.USERS_API_URL_2
                    except: pass

                # Check 3 if not found
                if not existing_record:
                    try:
                        resp3 = requests.get(f"{self.USERS_API_URL_3}?author_id={my_id}", timeout=5, verify=False)
                        if resp3.status_code == 200:
                            data3 = resp3.json()
                            if isinstance(data3, list) and len(data3) > 0:
                                existing_record = data3[0]
                                target_url = self.USERS_API_URL_3
                    except: pass

                # Check 4 if not found
                if not existing_record:
                    try:
                        resp4 = requests.get(f"{self.USERS_API_URL_4}?author_id={my_id}", timeout=5, verify=False)
                        if resp4.status_code == 200:
                            data4 = resp4.json()
                            if isinstance(data4, list) and len(data4) > 0:
                                existing_record = data4[0]
                                target_url = self.USERS_API_URL_4
                    except: pass
                
                if existing_record:
                    # Update score if higher
                    current_score = int(existing_record.get('score', 0))
                    if score > current_score:
                        requests.put(f"{target_url}/{existing_record['id']}", json={"score": score, "author": username}, timeout=10, verify=False)
                else:
                    # Create new. Check capacity of 1.
                    create_url = self.USERS_API_URL_1
                    try:
                        check_cap = requests.get(self.USERS_API_URL_1, timeout=5, verify=False)
                        if check_cap.status_code == 200 and len(check_cap.json()) >= 100:
                            create_url = self.USERS_API_URL_2
                            check_cap2 = requests.get(self.USERS_API_URL_2, timeout=5, verify=False)
                            if check_cap2.status_code == 200 and len(check_cap2.json()) >= 100:
                                create_url = self.USERS_API_URL_3
                                check_cap3 = requests.get(self.USERS_API_URL_3, timeout=5, verify=False)
                                if check_cap3.status_code == 200 and len(check_cap3.json()) >= 100:
                                    create_url = self.USERS_API_URL_4
                    except: pass
                    
                    requests.post(create_url, json={
                        "author": username,
                        "author_id": my_id,
                        "score": score,
                        "themes_num": 0,
                        "themes": ""
                    }, timeout=10, verify=False)
                    
            except Exception as e:
                log(f"[BlockBlast] High score upload error: {e}")
        threading.Thread(target=task).start()
    # Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñƒ Ð»Ð¸Ð´ÐµÑ€Ð¾Ð² Ð¸Ð· mockapi.
    # Loads the leaderboard from mockapi.
    def _show_leaderboard(self):
        fragment = get_last_fragment()
        context = fragment.getParentActivity() if fragment else self.pg_context
        if not context: return

        loading_dialog = AlertDialogBuilder(context).set_title("Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ°...").set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None).show()

        def fetch_and_show():
            try:
                import requests
                all_users = []
                
                # Fetch 1
                try:
                    r1 = requests.get(self.USERS_API_URL_1, timeout=5, verify=False)
                    if r1.status_code == 200: all_users.extend(r1.json())
                except: pass
                
                # Fetch 2
                try:
                    r2 = requests.get(self.USERS_API_URL_2, timeout=5, verify=False)
                    if r2.status_code == 200: all_users.extend(r2.json())
                except: pass

                # Fetch 3
                try:
                    r3 = requests.get(self.USERS_API_URL_3, timeout=5, verify=False)
                    if r3.status_code == 200: all_users.extend(r3.json())
                except: pass

                # Fetch 4
                try:
                    r4 = requests.get(self.USERS_API_URL_4, timeout=5, verify=False)
                    if r4.status_code == 200: all_users.extend(r4.json())
                except: pass
                
                if not all_users:
                    raise Exception("No data")

                # Sort by score
                all_users.sort(key=lambda x: int(x.get('score', 0)), reverse=True)
                top_15 = all_users[:15]
                
                sb = []
                for idx, item in enumerate(top_15, 1):
                    name = item.get('author', 'Unknown')
                    score = item.get('score', 0)
                    medal = "ðŸ¥‡" if idx == 1 else "ðŸ¥ˆ" if idx == 2 else "ðŸ¥‰" if idx == 3 else f"{idx}."
                    sb.append(f"{medal} {name}: {score}")
                
                msg = "\n".join(sb) if sb else "ÐŸÐ¾ÐºÐ° Ð¿ÑƒÑÑ‚Ð¾ :("
                
                run_on_ui_thread(lambda: (loading_dialog.dismiss(), AlertDialogBuilder(context) \
                    .set_title("ðŸ† Ð¢Ð¾Ð¿ 15 Ð˜Ð³Ñ€Ð¾ÐºÐ¾Ð²") \
                    .set_message(msg) \
                    .set_positive_button("OK", None) \
                    .show()))
            except Exception as e:
                run_on_ui_thread(lambda err=e: (loading_dialog.dismiss(), BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ‚Ð¾Ð¿Ð°: {err}", get_last_fragment())))
        
        threading.Thread(target=fetch_and_show).start()
    # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÑ‚ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ (ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ñ… Ñ‚ÐµÐ¼) Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð»Ð¸Ð´ÐµÑ€Ð¾Ð².
    # Updates user statistics (number of created themes) in the leaderboard database.
    def _update_user_stats(self, theme_name):
        def task():
            try:
                import requests
                my_id = str(UserConfig.getInstance(0).clientUserId)
                username = self._get_current_username()
                
                # 1. Fetch verified stats from Catalog
                real_themes = []
                try:
                    # Check Endpoint 1
                    resp1 = requests.get(self.CATALOG_API_URL, timeout=10, verify=False)
                    if resp1.status_code == 200:
                        data1 = resp1.json()
                        if isinstance(data1, list):
                            real_themes.extend([t for t in data1 if str(t.get('author_id')) == my_id])
                    
                    # Check Endpoint 2 (Overflow)
                    url2 = re.sub(r'/themes/?$', '/themes2', self.CATALOG_API_URL)
                    if url2 != self.CATALOG_API_URL:
                        resp2 = requests.get(url2, timeout=10, verify=False)
                        if resp2.status_code == 200:
                            data2 = resp2.json()
                            if isinstance(data2, list):
                                real_themes.extend([t for t in data2 if str(t.get('author_id')) == my_id])
                except Exception as e:
                    log(f"[BlockBlast] Error fetching catalog stats: {e}")
                    # Fallback to just adding the current one if catalog fetch fails is dangerous for consistency,
                    # so we might skip or try a simple append. But the user asked to "verify".
                    # Let's assume if catalog fetch fails, we can't verify, so we abort update to avoid corruption.
                    return

                real_count = len(real_themes)
                real_names = ", ".join([t.get('name', 'Unknown') for t in real_themes])

                # 2. Update User Record
                target_url = None
                existing_record = None
                
                # Check 1
                try:
                    resp1 = requests.get(f"{self.USERS_API_URL_1}?author_id={my_id}", timeout=5, verify=False)
                    if resp1.status_code == 200 and isinstance(resp1.json(), list) and len(resp1.json()) > 0:
                        existing_record = resp1.json()[0]
                        target_url = self.USERS_API_URL_1
                except: pass
                
                # Check 2
                if not existing_record:
                    try:
                        resp2 = requests.get(f"{self.USERS_API_URL_2}?author_id={my_id}", timeout=5, verify=False)
                        if resp2.status_code == 200 and isinstance(resp2.json(), list) and len(resp2.json()) > 0:
                            existing_record = resp2.json()[0]
                            target_url = self.USERS_API_URL_2
                    except: pass

                # Check 3
                if not existing_record:
                    try:
                        resp3 = requests.get(f"{self.USERS_API_URL_3}?author_id={my_id}", timeout=5, verify=False)
                        if resp3.status_code == 200 and isinstance(resp3.json(), list) and len(resp3.json()) > 0:
                            existing_record = resp3.json()[0]
                            target_url = self.USERS_API_URL_3
                    except: pass

                # Check 4
                if not existing_record:
                    try:
                        resp4 = requests.get(f"{self.USERS_API_URL_4}?author_id={my_id}", timeout=5, verify=False)
                        if resp4.status_code == 200 and isinstance(resp4.json(), list) and len(resp4.json()) > 0:
                            existing_record = resp4.json()[0]
                            target_url = self.USERS_API_URL_4
                    except: pass
                
                if existing_record:
                    requests.put(f"{target_url}/{existing_record['id']}", json={
                        "author": username,
                        "themes_num": real_count,
                        "themes": real_names
                    }, timeout=10, verify=False)
                else:
                    # Create new
                    create_url = self.USERS_API_URL_1
                    try:
                        check = requests.get(self.USERS_API_URL_1, timeout=5, verify=False)
                        if check.status_code == 200 and len(check.json()) >= 100:
                            create_url = self.USERS_API_URL_2
                            check2 = requests.get(self.USERS_API_URL_2, timeout=5, verify=False)
                            if check2.status_code == 200 and len(check2.json()) >= 100:
                                create_url = self.USERS_API_URL_3
                                check3 = requests.get(self.USERS_API_URL_3, timeout=5, verify=False)
                                if check3.status_code == 200 and len(check3.json()) >= 100:
                                    create_url = self.USERS_API_URL_4
                    except: pass
                    
                    requests.post(create_url, json={
                        "author": username,
                        "author_id": my_id,
                        "themes_num": real_count,
                        "themes": real_names,
                        "score": 0
                    }, timeout=10, verify=False)
            except Exception as e:
                log(f"[BlockBlast] User stats update error: {e}")
        threading.Thread(target=task).start()
    # Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÑ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ Ð² Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð»Ð¸Ð´ÐµÑ€Ð¾Ð² (mockapi) Ð´Ð»Ñ ÑƒÑ‡Ð°ÑÑ‚Ð¸Ñ Ð² Ñ€ÐµÐ¹Ñ‚Ð¸Ð½Ð³Ðµ.
    # Registers the user in the leaderboard database (mockapi) to participate in the ranking.
    def _ensure_user_registered(self):
        def task():
            try:
                import requests
                my_id = str(UserConfig.getInstance(0).clientUserId)
                username = self._get_current_username()
                
                found = False
                # Check 1
                try:
                    resp1 = requests.get(f"{self.USERS_API_URL_1}?author_id={my_id}", timeout=5, verify=False)
                    if resp1.status_code == 200 and isinstance(resp1.json(), list) and len(resp1.json()) > 0:
                        found = True
                except: pass
                
                # Check 2
                if not found:
                    try:
                        resp2 = requests.get(f"{self.USERS_API_URL_2}?author_id={my_id}", timeout=5, verify=False)
                        if resp2.status_code == 200 and isinstance(resp2.json(), list) and len(resp2.json()) > 0:
                            found = True
                    except: pass

                # Check 3
                if not found:
                    try:
                        resp3 = requests.get(f"{self.USERS_API_URL_3}?author_id={my_id}", timeout=5, verify=False)
                        if resp3.status_code == 200 and isinstance(resp3.json(), list) and len(resp3.json()) > 0:
                            found = True
                    except: pass

                # Check 4
                if not found:
                    try:
                        resp4 = requests.get(f"{self.USERS_API_URL_4}?author_id={my_id}", timeout=5, verify=False)
                        if resp4.status_code == 200 and isinstance(resp4.json(), list) and len(resp4.json()) > 0:
                            found = True
                    except: pass
                if not found:
                    create_url = self.USERS_API_URL_1
                    try:
                        check = requests.get(self.USERS_API_URL_1, timeout=5, verify=False)
                        if check.status_code == 200 and len(check.json()) >= 100:
                            create_url = self.USERS_API_URL_2
                            check2 = requests.get(self.USERS_API_URL_2, timeout=5, verify=False)
                            if check2.status_code == 200 and len(check2.json()) >= 100:
                                create_url = self.USERS_API_URL_3
                                check3 = requests.get(self.USERS_API_URL_3, timeout=5, verify=False)
                                if check3.status_code == 200 and len(check3.json()) >= 100:
                                    create_url = self.USERS_API_URL_4
                    except: pass
                    
                    requests.post(create_url, json={
                        "author": username,
                        "author_id": my_id,
                        "score": 0,
                        "themes_num": 0,
                        "themes": ""
                    }, timeout=10, verify=False)
            except Exception as e:
                log(f"[BlockBlast] Registration error: {e}")
        threading.Thread(target=task).start()

    @staticmethod
    def _get_color_safe(key: str, fallback: int) -> int:
        try:
            return Theme.getColor(key)
        except Exception:
            return fallback
            
    def _load_custom_themes(self) -> Dict[str, Any]:
        themes_json = self.get_setting("custom_themes_pg", "{}")
        try:
            return json.loads(themes_json)
        except json.JSONDecodeError:
            return {}

    def _save_custom_themes(self, themes: Dict[str, Any]):
        self.set_setting("custom_themes_pg", json.dumps(themes))

    def _get_all_theme_names(self) -> List[str]:
        return list(PG_THEMES.keys()) + sorted(list(self._load_custom_themes().keys())) + ["Custom"]

    def _get_current_theme_name(self) -> str:
        all_names = self._get_all_theme_names()
        index = self.get_setting("game_theme_pg", 0)
        if not all_names: return list(PG_THEMES.keys())[0]
        if index >= len(all_names):
            index = 0
            self.set_setting("game_theme_pg", 0)
        return all_names[index]

    def _get_custom_gradient_state(self):
        """Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÑ‚ Ð¸Ð»Ð¸ Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚Ð° Ð´Ð»Ñ Custom Ñ‚ÐµÐ¼Ñ‹."""
        state_json = self.get_setting("custom_gradient_state_pg", None)
        default_color = self._get_themed_color("grid_bg") 
        
        default_state = {
            'is_gradient': False,
            'point_1_id': -1,
            'point_2_id': -1,
            'color_1_hex': "#000000",
            'color_2_hex': "#FFFFFF",
        }
        
        if state_json:
            try:
                state = json.loads(state_json)
                if isinstance(state, dict):
                    return {**default_state, **state}
            except:
                pass
        return default_state

    def _save_custom_gradient_state(self, state: Dict[str, Any]):
        """Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð³Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚Ð° Ð´Ð»Ñ Custom Ñ‚ÐµÐ¼Ñ‹."""
        self.set_setting("custom_gradient_state_pg", json.dumps(state))

    @property
    def pg_block_colors(self) -> Dict[int, str]:
        block_colors = {i: self._get_themed_color(f"cell_block_{i}") for i in PG_BLOCK_COLOR_IDS}
        block_colors[0] = self._get_themed_color("cell_empty")
        block_colors[99] = self._get_themed_color("cell_error")
        return block_colors

    def _get_themed_color(self, key: str) -> str:
        theme_name = self._get_current_theme_name()

        if theme_name in PG_THEMES:
            return PG_THEMES[theme_name].get(key, "#FFFFFF")

        custom_themes = self._load_custom_themes()
        if theme_name in custom_themes:
            return custom_themes[theme_name].get(key, PG_THEMES["Dark (Default)"].get(key, "#FFFFFF"))

        return PG_THEMES["Dark (Default)"].get(key, "#FFFFFF")
    @property
    def pg_empty_color(self) -> str: return self._get_themed_color("cell_empty")
    @property
    def pg_bright_colors(self) -> List[str]: return [self.pg_block_colors[id] for id in PG_BLOCK_COLOR_IDS if id != 4]
    @property
    def pg_block_colors_for_cube(self) -> List[str]: return self.pg_bright_colors + [self.pg_empty_color]
    @property
    def pg_error_color(self) -> str: return self._get_themed_color("cell_error")
    @property
    def pg_clear_color(self) -> str: return self._get_themed_color("cell_clear")
    @property
    def pg_restart_color(self) -> str: return self._get_themed_color("cell_restart")
    @property
    def pg_game_over_color(self) -> str: return self._get_themed_color("game_over")
    @property
    def pg_placeholder_color(self) -> str: return self._get_themed_color("placeholder_shape_bg")
    @property
    def pg_preview_color(self) -> str: return self._get_themed_color("cell_preview")

    def _is_dialog_showing(self, dialog_builder: Optional[AlertDialogBuilder]) -> bool:
        if dialog_builder is None:
            return False
        try:
            java_dialog = dialog_builder.get_dialog()
            return java_dialog is not None and java_dialog.isShowing()
        except Exception:
            return False


    def _apply_and_redraw_ui(self, activity_context: Optional[Context] = None):
        game_dialog_was_open = self.dialog and self._is_dialog_showing(self.dialog)

        if self.gui_settings_dialog and self._is_dialog_showing(self.gui_settings_dialog):
            self.gui_settings_dialog.dismiss()

        self.pg_cube_colors = [random.choice(self.pg_block_colors_for_cube) for _ in range(4)]
        self._save_game_state()
        self.rebuild_settings()

        if game_dialog_was_open:
            self.is_refreshing_ui = True
            current_activity = self.dialog.get_dialog().getContext() if self.dialog and self.dialog.get_dialog() else self.pg_context

            def post_transition_action():
                self.is_refreshing_ui = False
                run_on_ui_thread(self._safe_show_game_dialog)

            if current_activity:
                try:
                    java_dialog = self.dialog.get_dialog()
                    java_dialog.setOnDismissListener(None)

                    if dialog_view := java_dialog.findViewById(android_R_id_content):
                        if content_view := dialog_view.getChildAt(0):
                            content_view.animate().alpha(0.0).scaleX(0.9).scaleY(0.9).setDuration(PG_MINIMIZE_ANIMATION_DURATION).start()

                    run_on_ui_thread(lambda: self._show_spinning_gear_overlay(current_activity, "âš™ï¸", 800, post_transition_action))
                    run_on_ui_thread(java_dialog.dismiss, PG_MINIMIZE_ANIMATION_DURATION + 50)
                    self.dialog = None
                except Exception as e:
                    log(f"Error applying settings with animation: {e}")
                    if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
                        self.dialog.dismiss()
                        self.dialog = None
                    post_transition_action()
            else:
                post_transition_action()
        elif self.pg_floating_cube:
             self.pg_floating_cube.update_display()


    def _on_theme_changed(self, new_value_index: int):
        all_theme_names = self._get_all_theme_names()
        theme_name = all_theme_names[new_value_index]

        if theme_name == "Custom":
            if self._is_dialog_showing(self.gui_settings_dialog):
                activity = self.gui_settings_dialog.get_dialog().getContext()
                self._start_new_theme_creation_flow(activity)
            # We don't set the theme, as "Custom" is a trigger, not a theme.
            # The UI will revert to the previous selection, which is intended.
            return

        self.set_setting("game_theme_pg", new_value_index)

        if self._is_dialog_showing(self.gui_settings_dialog):
            self._update_custom_theme_button_visibility()
        
        if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
            self._draw_grid()
            self._draw_shapes()
            self._update_score_display()
        
        self.rebuild_settings()

    def rebuild_settings(self):
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, 'rebuildAllFragments'):
            run_on_ui_thread(lambda: fragment.rebuildAllFragments(True))

    def _create_custom_theme_settings_subfragment(self):
        return []

    def _open_link(self, target: str):
        fragment = get_last_fragment()
        if not fragment or not fragment.getParentActivity(): 
            run_on_ui_thread(lambda: BulletinHelper.show_error("Cannot find active screen to open link."))
            return

        context = fragment.getParentActivity()

        try:
            if target.startswith("http") or target.startswith("https"):

                if "telegra.ph" in target:

                    if UI_CLASSES_LOADED and Browser:
                        Browser.openUrl(context, Uri.parse(target), True, True, True, None, None, False, False, False)
                        return
                
                intent = Intent(Intent.ACTION_VIEW)
                intent.setData(Uri.parse(target))
                context.startActivity(intent)
                
            elif target.startswith("@"):

                username = target.lstrip("@")
                MessagesController.getInstance(0).openByUserName(username, fragment, 1)
            else:

                MessagesController.getInstance(0).openByUserName(target, fragment, 1)
        except Exception as e:
            log(f"[{__name__}] Error opening link {target}: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Failed to open link: {target}"))


    def _perform_haptic(self, view: View):
        try:
            view.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
        except Exception:
            pass

    def _animate_button_press(self, view: View):
        if not view or not UI_CLASSES_LOADED: return
        try:
            view.animate().cancel()
            view.animate().scaleX(0.95).scaleY(0.95).setDuration(80).setInterpolator(DecelerateInterpolator()) \
                .withEndAction(RunnableProxy(lambda: view.animate().scaleX(1.0).scaleY(1.0).setDuration(120).setInterpolator(OvershootInterpolator()).start())) \
                .start()
        except Exception as e: log(f"[{__name__}] Button animation error: {e}")

    def _animate_view_press_down(self, view: View):
        if not view or not UI_CLASSES_LOADED: return
        try:
            view.animate().cancel()
            view.animate().scaleX(0.95).scaleY(0.95).setDuration(80).setInterpolator(DecelerateInterpolator()).start()
        except Exception as e: log(f"[{__name__}] Button animation error: {e}")

    def _animate_view_release_up(self, view: View):
        if not view or not UI_CLASSES_LOADED: return
        try:
            view.animate().cancel()
            view.animate().scaleX(1.0).scaleY(1.0).setDuration(120).setInterpolator(OvershootInterpolator()).start()
        except Exception as e: log(f"[{__name__}] Button animation error: {e}")


    def _get_root_content_view(self, activity: Context) -> Optional[ViewGroup]:
        try:
            if LaunchActivity.instance:
                decor_view = LaunchActivity.instance.getWindow().getDecorView(); root_view = decor_view.findViewById(android_R_id_content) or decor_view
            else: return
            
            if not root_view or not isinstance(root_view, ViewGroup):
                 log(f"[{__name__}] Root view not found or invalid type.")
                 return
            
            if isinstance(root_view, ViewGroup):
                 return root_view

            return None
        except Exception:
            return None

    def _create_drag_view_content(self, context: Context, shape_id: int, color_id: int):
        container = FrameLayout(context)
        container.setLayoutParams(FrameLayout.LayoutParams(AndroidUtilities.dp(70), AndroidUtilities.dp(70)))
        container.setAlpha(0.75) 

        preview_grid = LinearLayout(context)
        preview_grid.setOrientation(LinearLayout.VERTICAL)
        preview_grid.setGravity(Gravity.CENTER)
        
        cells_5x5 = []
        cell_size = AndroidUtilities.dp(5) 
        margin = AndroidUtilities.dp(0.5)

        for r in range(5):
            row_layout = LinearLayout(context)
            row_layout.setOrientation(LinearLayout.HORIZONTAL)
            row_layout.setGravity(Gravity.CENTER)
            for c in range(5):
                cell = View(context)
                cell_bg = GradientDrawable()
                cell_bg.setShape(GradientDrawable.RECTANGLE)
                cell_bg.setCornerRadius(AndroidUtilities.dp(1))
                cell.setBackground(cell_bg)
                
                cell_params = LinearLayout.LayoutParams(cell_size, cell_size)
                cell_params.setMargins(margin, margin, margin, margin)
                cell.setLayoutParams(cell_params)

                row_layout.addView(cell)
                cells_5x5.append(cell)
            preview_grid.addView(row_layout)
        
        container.addView(preview_grid, LayoutHelper.createFrame(-2, -2, Gravity.CENTER))

        self._draw_single_shape_preview(cells_5x5, color_id - 1, shape_id) 
        
        return container
        
    def _start_drag_visual(self, context: Context, shape_id: int, color_id: int, start_raw_x: float, start_raw_y: float):
        if self.pg_drag_view:
            self._end_drag_visual()
            
        self.pg_drag_view = self._create_drag_view_content(context, shape_id, color_id)
        
        root_view = self._get_root_content_view(context)
        if not root_view:
            return

        center_offset_x = AndroidUtilities.dp(35) 
        center_offset_y = AndroidUtilities.dp(35)
        
        params = FrameLayout.LayoutParams(AndroidUtilities.dp(70), AndroidUtilities.dp(70), Gravity.TOP | Gravity.LEFT)
        params.leftMargin = int(start_raw_x - center_offset_x)
        params.topMargin = int(start_raw_y - center_offset_y)
        
        root_view.addView(self.pg_drag_view, params)
        
    def _update_drag_visual_position(self, raw_x: float, raw_y: float):
        if self.pg_drag_view:
            center_offset_x = AndroidUtilities.dp(35)
            center_offset_y = AndroidUtilities.dp(35)
            
            params = self.pg_drag_view.getLayoutParams()
            if isinstance(params, FrameLayout.LayoutParams):
                params.leftMargin = int(raw_x - center_offset_x)
                params.topMargin = int(raw_y - center_offset_y)
                self.pg_drag_view.requestLayout()

    def _end_drag_visual(self):
        if self.pg_drag_view:
            drag_view_to_remove = self.pg_drag_view
            self.pg_drag_view = None 

            try:
                context = drag_view_to_remove.getContext()
                root_view = self._get_root_content_view(context)

                def remove_action():
                    
                    if root_view and drag_view_to_remove.getParent() == root_view:
                        root_view.removeView(drag_view_to_remove)
                        log(f"[{__name__}] Drag visual successfully removed.")
                    elif drag_view_to_remove.getParent() is not None:
                        
                        parent = drag_view_to_remove.getParent()
                        if isinstance(parent, ViewGroup):
                             parent.removeView(drag_view_to_remove)

                run_on_ui_thread(remove_action)
            except Exception as e:
                log(f"Error removing drag view: {e}")
    def _show_tos_alert(self):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity and LaunchActivity.instance: activity = LaunchActivity.instance
        if not activity: return

        builder = AlertDialogBuilder(activity)
        builder.set_title("BlockBlast")
        builder.set_message('Ð Ð°Ð·Ñ€ÐµÑˆÐ¸Ñ‚ÑŒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÑƒ userid dÐ»Ñ Ñ‚Ð°Ð±Ð»Ð¸Ñ†Ñ‹ Ð»Ð¸dÐµÑ€Ð¾Ð²? [Ð½Ð°Ð¶Ð°Ñ‚Ð¸Ðµ "Ð½ÐµÑ‚" Ð·Ð°Ð¼Ð¾Ñ€Ð¾Ð·Ð¸Ñ‚ Ð¿Ð»Ð°Ð³Ð¸Ð½]')
        
        def on_yes(d, w):
            self.set_setting("tos_accepted_v1", True)
            self._complete_plugin_load()
            
        def on_no(d, w):
            try:
                d.dismiss()
                # Try to get ID from instance, fallback to global __id__
                pid = getattr(self, "id", __id__)
                
                PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                if PC:
                    controller = PC.getInstance()
                    # Standard delete
                    controller.deletePlugin(pid)
                    
                    # Fallback manual file deletion
                    try:
                        path = controller.getPluginPath(pid)
                        if path:
                            FileClass = find_class("java.io.File")
                            f = FileClass(path)
                            if f.exists():
                                f.delete()
                    except Exception:
                        pass
            except Exception as e:
                log(f"[BlockBlast] Delete error: {e}")

        builder.set_positive_button("ÐžÐºÐµ >^ - ^<", on_yes)
        builder.set_negative_button("Ð½ÐµÑ‚ >T - T<", on_no)
        
        builder.show()
        builder.set_cancelable(False)
        builder.set_canceled_on_touch_outside(False)

    def _complete_plugin_load(self):
        self._update_menu_visibility()
        
        if self.get_setting("is_minimized_pg", False):
             run_on_ui_thread(lambda: self._try_restore_floating_state())
        
        self._start_selector_animations()
        self._ensure_user_registered()
        self._report_admin_stats()
             
        log(f"[{__name__}] Plugin loaded. High Score: {self.pg_high_score}")


    def on_plugin_load(self):
        try:
            # Fix: Use correct types for reflection (boolean != int in Java signatures)
            JBoolean = find_class("java.lang.Boolean")
            jboolean = JBoolean.TYPE if JBoolean else None
            BrowserProgress = find_class("org.telegram.messenger.browser.Browser$Progress")

            if LaunchActivity and not self.hook_deep_link_ref and jboolean and BrowserProgress:
                try:
                    # Try hooking handleIntent with correct signature
                    # (Intent, boolean, boolean, boolean, Browser.Progress, boolean, boolean)
                    handle_intent_method = LaunchActivity.getClass().getDeclaredMethod(
                        "handleIntent", 
                        Intent, jboolean, jboolean, jboolean, BrowserProgress, jboolean, jboolean
                    )
                    self.hook_deep_link_ref = self.hook_method(handle_intent_method, BlockBlastDeepLinkHook(self))
                except Exception as e:
                    log(f"[BlockBlast] handleIntent hook failed: {e}")

            if Browser:
                browser_cls = Browser.getClass()
                
                def hook_safe(method_name, *types):
                    try:
                        m = browser_cls.getDeclaredMethod(method_name, *types)
                        self.hook_browser_refs.append(self.hook_method(m, BlockBlastBrowserHook(self)))
                    except Exception:
                        pass

                # Hook simple openUrl variants (Context, String/Uri)
                hook_safe("openUrl", Context, JString)
                hook_safe("openUrl", Context, Uri)
                
                # Hook complex openUrl variants if types are available
                if jboolean and BrowserProgress:
                    hook_safe("openUrl", Context, JString, jboolean, jboolean, jboolean, BrowserProgress, JString, jboolean, jboolean, jboolean)
                    hook_safe("openUrl", Context, Uri, jboolean, jboolean, jboolean, BrowserProgress, JString, jboolean, jboolean, jboolean)

        except Exception as e:
            log(f"[BlockBlast] Hook setup error: {e}")
        self.add_on_send_message_hook()
        if self.get_setting("tos_accepted_v1", False):
            self._complete_plugin_load()
        else:
            run_on_ui_thread(self._show_tos_alert)

    def _start_selector_animations(self):
        if self.animation_thread_running: return
        self.animation_thread_running = True
        
        # Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ†Ð¸ÐºÐ» Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¹ Ð² Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾Ð¼ Ñ„Ð¾Ð½Ð¾Ð²Ð¾Ð¼ Ð¿Ð¾Ñ‚Ð¾ÐºÐµ
        self.animation_thread = threading.Thread(target=self._animation_loop)
        self.animation_thread.daemon = True
        self.animation_thread.start()

    def _stop_selector_animations(self):
        # ÐŸÐ¾Ð´Ð°ÐµÐ¼ ÑÐ¸Ð³Ð½Ð°Ð» Ð¿Ð¾Ñ‚Ð¾ÐºÑƒ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸ Ð½Ð° Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ðµ
        self.animation_thread_running = False
        
        # Ð¡Ð±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ Ñ‚Ñ€Ð°Ð½ÑÑ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ ÐºÐ½Ð¾Ð¿Ð¾Ðº Ð² UI-Ð¿Ð¾Ñ‚Ð¾ÐºÐµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð½Ð¸ Ð½Ðµ "Ð·Ð°ÑÑ‚Ñ‹Ð»Ð¸"
        def reset_buttons_state():
            for btn in self.shape_buttons:
                try:
                    # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ñ‡Ñ‚Ð¾ ÐºÐ½Ð¾Ð¿ÐºÐ° Ð²ÑÐµ ÐµÑ‰Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚ Ð² Ð¸ÐµÑ€Ð°Ñ€Ñ…Ð¸Ð¸
                    if btn and btn.getParent():
                        btn.animate().cancel()
                        btn.setTranslationX(0.0)
                        btn.setRotation(0.0)
                        btn.setScaleX(1.0)
                        btn.setScaleY(1.0)
                except Exception:
                    pass # ÐšÐ½Ð¾Ð¿ÐºÐ° Ð¼Ð¾Ð³Ð»Ð° Ð±Ñ‹Ñ‚ÑŒ ÑƒÐ¶Ðµ ÑƒÐ´Ð°Ð»ÐµÐ½Ð°
        
        run_on_ui_thread(reset_buttons_state)
        log(f"[{__name__}] Selector animations stopped.")
        
    def _animation_loop(self):
        """ÐžÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ñ†Ð¸ÐºÐ» Ð¿Ð¾Ñ‚Ð¾ÐºÐ° Ð´Ð»Ñ Ñ„Ð¾Ð½Ð¾Ð²Ñ‹Ñ… Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¹ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, Ð²Ð¾Ð»Ð½Ð¾Ð²Ð¾Ðµ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ðµ ÐºÐ½Ð¾Ð¿Ð¾Ðº)."""
        while self.animation_thread_running:
            try:
                if not self.shape_buttons:
                    time.sleep(0.1)
                    continue

                updates = []
                current_time = JavaSystem.currentTimeMillis()
                if not hasattr(self, '_anim_start_time'):
                    self._anim_start_time = current_time
                time_elapsed = (current_time - self._anim_start_time) / 1000.0

                max_translation = AndroidUtilities.dp(2.0)
                max_rotation = 2.5
                frequency = 2 * math.pi / 3.0

                for i, btn in enumerate(self.shape_buttons):
                    angle = time_elapsed * frequency + i
                    translation_x = math.sin(angle) * max_translation
                    rotation = math.cos(angle) * max_rotation
                    updates.append((btn, translation_x, rotation))

                def apply_updates_on_ui():
                    if not self.animation_thread_running:
                        return
                    for btn, tx, rot in updates:
                        try:
                            if btn and btn.getParent():
                                btn.setTranslationX(tx)
                                btn.setRotation(rot)
                        except Exception:
                            pass
                
                run_on_ui_thread(apply_updates_on_ui)
                time.sleep(1/60.0)
            except Exception as e:
                log(f"[{__name__}] Error in animation loop: {e}")
                time.sleep(1)
        log(f"[{__name__}] Animation thread has stopped.")

    def _animate_selector_item(self, view: View, is_selected: bool):
        pass

    def _animate_pulse_next(self, view: View):
        pass

    def _update_menu_visibility(self, value: Any = None):
        show_in_drawer = self.get_setting("show_in_drawer_pg", True)
        show_in_chat_action = self.get_setting("show_in_chat_action_pg", True)
        
        if show_in_drawer and not self._drawer_menu_id:
            menu_item = MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                text=Locales.get('game_name'), 
                icon=__icon__,
                on_click=self._safe_show_game_dialog
            )
            self._drawer_menu_id = self.add_menu_item(menu_item)
        elif not show_in_drawer and self._drawer_menu_id:
            self.remove_menu_item(self._drawer_menu_id)
            self._drawer_menu_id = None

        if show_in_chat_action and not self._chat_action_menu_id:
            menu_item = MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU, 
                text=Locales.get('game_name'), 
                icon=__icon__, 
                on_click=self._safe_show_game_dialog
            )
            self._chat_action_menu_id = self.add_menu_item(menu_item)
        elif not show_in_chat_action and self._chat_action_menu_id:
            self.remove_menu_item(self._chat_action_menu_id)
            self._chat_action_menu_id = None

    def on_plugin_unload(self):
        self._stop_selector_animations()
        if self.pg_floating_cube:
            run_on_ui_thread(self.pg_floating_cube.detach)
            self.pg_floating_cube = None
            log(f"[{__name__}] Floating cube detached on unload.")
        
        if self.pg_drag_view:
            self._end_drag_visual()
        
        self.set_setting("is_minimized_pg", False)
        
        if not self.pg_game_over:
             self._save_game_state()
        else:
             self.set_setting("blockblast_state_pg", None)
        
        if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
            try:
                run_on_ui_thread(self.dialog.dismiss)
            except Exception: pass
            self.dialog = None
        
        if self.gui_settings_dialog and self._is_dialog_showing(self.gui_settings_dialog):
            try:
                run_on_ui_thread(self.gui_settings_dialog.dismiss)
            except Exception: pass
            self.gui_settings_dialog = None
        
        if self.gui_custom_theme_dialog and self._is_dialog_showing(self.gui_custom_theme_dialog):
            try:
                run_on_ui_thread(self.gui_custom_theme_dialog.dismiss)
            except Exception: pass
            self.gui_custom_theme_dialog = None
        
        if self.GRADIENT_EDITOR_DIALOG and self._is_dialog_showing(self.GRADIENT_EDITOR_DIALOG):
             try:
                 run_on_ui_thread(self.GRADIENT_EDITOR_DIALOG.dismiss)
             except Exception: pass
             self.GRADIENT_EDITOR_DIALOG = None
        if self.hook_deep_link_ref:
            self.unhook_method(self.hook_deep_link_ref)
            self.hook_deep_link_ref = None
        for hook in self.hook_browser_refs:
            self.unhook_method(hook)
        self.hook_browser_refs.clear()


        if self._drawer_menu_id: self.remove_menu_item(self._drawer_menu_id)
        if self._chat_action_menu_id: self.remove_menu_item(self._chat_action_menu_id)
        self._drawer_menu_id = None
        self._chat_action_menu_id = None

        log(f"[{__name__}] Plugin unloaded completely.")
        
    def _try_restore_floating_state(self):
        def _restore_on_launch_activity(activity):
            if self._load_game_state(): 
                self.pg_context = activity
                self.pg_floating_cube = FloatingGameCube(self)
                self.pg_floating_cube.attach(activity)
                self.pg_data_handler += 1
                self._update_score_display()
            else:
                 self.set_setting("is_minimized_pg", False)
        
        try:
            if LaunchActivity.instance:
                activity = LaunchActivity.instance
                _restore_on_launch_activity(activity)
            else:
                fragment = get_last_fragment()
                if fragment and fragment.getParentActivity():
                    _restore_on_launch_activity(fragment.getParentActivity())
                
        except Exception as e:
            self.set_setting("is_minimized_pg", False)
            log(f"Failed to restore floating game state: {e}")
            
    def _save_game_state(self):
        state = {
            "grid": self.pg_grid,
            "score": self.pg_score,
            "high_score": self.pg_high_score,
            "shapes": self.pg_current_shapes,
            "game_over": self.pg_game_over,
            "cube_colors": self.pg_cube_colors,
            "combo_count": self.pg_combo_count,
        }
        self.set_setting("blockblast_state_pg", json.dumps(state))
        log(f"[{__name__}] Game state saved.")

    def _load_game_state(self):
        state_json = self.get_setting("blockblast_state_pg", None)
        if state_json:
            try:
                state = json.loads(state_json)
                self.pg_grid = state.get("grid", [[0] * PG_GRID_SIZE for _ in range(PG_GRID_SIZE)])
                self.pg_score = state.get("score", 0)
                self.pg_high_score = state.get("high_score", self._load_high_score())
                self.pg_current_shapes = state.get("shapes", [None, None, None])
                self.pg_game_over = state.get("game_over", True)
                self.pg_cube_colors = state.get("cube_colors", [])
                self.pg_combo_count = state.get("combo_count", 0) 
                
                self.pg_is_starting_new_game = False
                self.pg_selected_shape_index = -1
                log(f"[{__name__}] Game state loaded. Score: {self.pg_score}")
                return True
            except (json.JSONDecodeError, KeyError) as e:
                log(f"Error loading game state: {e}")
                self.set_setting("blockblast_state_pg", None)
                return False
        return False
        
    def _save_cube_position(self, x, y):
        pos = {"x": x, "y": y}
        self.set_setting("cube_position_pg", json.dumps(pos))

    def _load_cube_position(self):
        pos_json = self.get_setting("cube_position_pg", None)
        if pos_json:
            try:
                pos = json.loads(pos_json)
                return pos.get("x", -1), pos.get("y", -1)
            except:
                pass
        return -1, -1

    def _safe_restore_from_touch(self):
        run_on_ui_thread(self._restore_game)

    def _minimize_game(self):
        self._stop_selector_animations()

        if not UI_CLASSES_LOADED:
             run_on_ui_thread(lambda: BulletinHelper.show_error("UI classes not loaded."))
             return

        if self.pg_game_over:
            run_on_ui_thread(lambda: BulletinHelper.show_info(Locales.get('game_over'), get_last_fragment()))
            return

        self.pg_cube_colors = [random.choice(self.pg_block_colors_for_cube) for _ in range(4)]
        self._save_game_state() 

        try:
            if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
                dialog_view = self.dialog.get_dialog().findViewById(android_R_id_content)
                if dialog_view and dialog_view.getChildAt(0):
                    content_view = dialog_view.getChildAt(0)
                    content_view.animate() \
                        .scaleX(0.0) \
                        .scaleY(0.0) \
                        .alpha(0.0) \
                        .setDuration(PG_MINIMIZE_ANIMATION_DURATION) \
                        .withEndAction(RunnableProxy(self._on_minimize_animation_end)) \
                        .start()
                else:
                    self.dialog.dismiss()
                    run_on_ui_thread(self._attach_cube_and_notify)
        except Exception as e:
            log(f"Error minimizing game (UI error, falling back): {e}\n{traceback.format_exc()}")
            if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
                 self.dialog.dismiss()
            run_on_ui_thread(self._attach_cube_and_notify)
            
    def _on_minimize_animation_end(self):
        if self.dialog and self.dialog.get_dialog():
            try:
                self.dialog.get_dialog().setOnDismissListener(None)
                self.dialog.dismiss()
            except Exception:
                pass
            self.dialog = None
        
        if getattr(self, 'is_refreshing_ui', False):
            self.is_refreshing_ui = False
            run_on_ui_thread(self._restore_game, delay=50)
        else:
            self._attach_cube_and_notify()

    def _attach_cube_and_notify(self):
        self.set_setting("is_minimized_pg", True)
        
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        
        if not activity: 
            if LaunchActivity.instance:
                activity = LaunchActivity.instance
            else:
                return

        self.pg_context = activity
        self.pg_floating_cube = FloatingGameCube(self)
        
        try:
            self.pg_floating_cube.attach(activity)
        except Exception as e:
            log(f"[{__name__}] Failed to attach floating cube via direct attach: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Failed to attach floating cube: {e}"))
            self.set_setting("is_minimized_pg", False)
            return

        BulletinHelper.show_info(Locales.get('minimized_info', score=self.pg_score), get_last_fragment())

    def _restore_game(self):
        try:
            if self.pg_floating_cube:
                self.pg_floating_cube.detach()
                self.pg_floating_cube = None
            
            self.set_setting("is_minimized_pg", False)
            
            self._safe_show_game_dialog()
            
            if self.full_screen_blur_overlay and self.full_screen_blur_overlay.getParent():
                root_view = self.full_screen_blur_overlay.getParent()
                self.full_screen_blur_overlay.animate().alpha(0.0).setDuration(200).withEndAction(RunnableProxy(lambda: root_view.removeView(self.full_screen_blur_overlay))).start()
                self.full_screen_blur_overlay = None
            
        except Exception as e:
            log(f"Error restoring game: {e}\n{traceback.format_exc()}")
            self.set_setting("is_minimized_pg", False)
            self.pg_game_over = True 
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not isinstance(params.message, str): return HookResult()
        msg = params.message
        
        # Pattern for link with tag
        # Matches: (full_url) (encoded_name)
        pattern = r"(tg://blockblast/theme/([^/]+)/[^\[]+)\[Iam_text\]"
        match = re.search(pattern, msg)
        
        if match:
            full_url = match.group(1)
            encoded_name = match.group(2)
            try:
                from java.net import URLDecoder
                theme_name = URLDecoder.decode(encoded_name, "UTF-8")
            except:
                theme_name = "Theme"
            
            # Replace link+tag with theme name
            new_text = msg.replace(match.group(0), theme_name)
            
            # Calculate offset
            start_pos = msg.find(match.group(0))
            
            # Create text url entity
            entity = TLRPC.TL_messageEntityTextUrl()
            entity.offset = start_pos
            entity.length = len(theme_name)
            entity.url = full_url
            
            params.message = new_text
            
            if params.entities is None:
                params.entities = ArrayList()
            
            params.entities.add(entity)
            
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
            
        return HookResult()
    def _share_custom_theme(self, context: Context, theme_name: str):
        try:
            custom_themes = self._load_custom_themes()
            if theme_name not in custom_themes:
                BulletinHelper.show_error(Locales.get('theme_import_error', error="Theme not found"))
                return

            theme_data = custom_themes[theme_name]
            data_str = ";".join([f"{k}:{v}" for k, v in theme_data.items()])
            
            from java.net import URLEncoder
            encoded_name = URLEncoder.encode(theme_name, "UTF-8")
            encoded_data = URLEncoder.encode(data_str, "UTF-8")
            link = f"tg://blockblast/theme/{encoded_name}/{encoded_data}[Iam_text]"
            
            # Immediate copy
            try:
                clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("BlockBlast Theme", link)
                clipboard.setPrimaryClip(clip)
            except Exception as e:
                log(f"Clipboard error: {e}")
            
            # Show success dialog (Popup GUI)
            AlertDialogBuilder(context) \
                .set_title(Locales.get('share_theme_button')) \
                .set_message(Locales.get('theme_copied')) \
                .set_positive_button("OK", None) \
                .show()
                
        except Exception as e:
            log(f"[BlockBlast] Share error: {e}")
                
    def _import_theme_from_link(self, encoded_name: str, encoded_data: str, metadata: Optional[Dict] = None):
        try:
            from java.net import URLDecoder
            name = URLDecoder.decode(encoded_name, "UTF-8")
            data_str = URLDecoder.decode(encoded_data, "UTF-8")
            
            theme_data = {}
            pairs = data_str.split(";")
            for pair in pairs:
                if ":" in pair:
                    k, v = pair.split(":", 1)
                    theme_data[k] = v
            
            if not theme_data:
                raise Exception("Empty data")
                
            # Fix: Dynamically resolve context
            ctx = None
            fragment = get_last_fragment()
            if fragment:
                ctx = fragment.getParentActivity()
            
            if not ctx and LaunchActivity.instance:
                ctx = LaunchActivity.instance
                
            if not ctx:
                 raise Exception("No active Activity found")

            run_on_ui_thread(lambda: self._show_theme_preview_dialog(ctx, name, theme_data, metadata))
                 
        except Exception as e:
            log(f"[BlockBlast] Import error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(Locales.get('theme_import_error', error=str(e)), get_last_fragment()))


    def create_settings(self):
        pg_settings_list = [
            Header(Locales.get('settings_header_cat_love')),
            Divider(),
            Text(
                text="ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ BlockBlast",
                icon="msg_customize", 
                on_click=lambda v: self._show_custom_gui_settings()
            ),
            Divider(),
            Header(Locales.get('links_section_header')),
            Text(
                text=Locales.get('author_link_text'),
                icon="msg_contacts_name_solar", 
                on_click=lambda v: self._open_link("@Playerqwe") 
            ),
            Text(
                text=Locales.get('details_link_text'),
                icon="msg_info_solar", 
                on_click=lambda v: self._open_link("https://telegra.ph/BlockBlast-10-25-2")
            ),
            Divider(text=Locales.get('settings_footer_versions'))
        ]
        return pg_settings_list

    def _show_catalog_dialog(self, context: Context):
        if self._is_dialog_showing(getattr(self, 'catalog_dialog', None)): return
        
        builder = AlertDialogBuilder(context)
        builder.set_title(Locales.get('catalog_title'))
        
        main_layout = LinearLayout(context); main_layout.setOrientation(LinearLayout.VERTICAL)
        
        tabs = [Locales.get('tab_themes'), Locales.get('tab_add')]
        tab_bar = self._create_gui_tab_bar(context, tabs, force_no_emoji=True)
        main_layout.addView(tab_bar)
        
        content_frame = FrameLayout(context)
        content_frame.setLayoutParams(LinearLayout.LayoutParams(-1, AndroidUtilities.dp(400)))
        main_layout.addView(content_frame)
        
        self.catalog_content = content_frame
        self.catalog_active_tab = 0
        
        def switch_tab(index):
            self.catalog_active_tab = index
            content_frame.removeAllViews()
            for i, btn in self.gui_settings_tab_buttons.items():
                 is_active = (i == index)
                 btn.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE) if is_active else self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))
                 btn.setTypeface(None, Typeface.BOLD if is_active else Typeface.NORMAL)
            
            if index == 0:
                self._render_catalog_content(context)
            else:
                self._render_catalog_add_tab(context)
                
        # Override click listeners for catalog tabs
        for i, btn in self.gui_settings_tab_buttons.items():
             btn.setOnClickListener(ClickListenerProxy(self, lambda v, idx=i: switch_tab(idx)))
             
        switch_tab(0)
        
        builder.set_view(main_layout)
        builder.set_negative_button(Locales.get('theme_cancel_button'), None)
        self.catalog_dialog = builder.show()
    def _render_catalog_content(self, context):
        import threading, json, requests
        
        self.catalog_content.removeAllViews()
        loading = TextView(context)
        loading.setText(Locales.get('catalog_loading'))
        loading.setGravity(Gravity.CENTER); loading.setTextColor(Color.WHITE)
        self.catalog_content.addView(loading)
        
        def fetch():
            try:
                if not self.CATALOG_API_URL:
                    raise Exception("API URL not configured")
                
                url1 = self.CATALOG_API_URL
                url2 = re.sub(r'/themes/?$', '/themes2', url1)
                
                themes = []
                errors = []
                
                # Fetch 1 (Main)
                try:
                    resp1 = requests.get(url1, timeout=10, verify=False)
                    if resp1.status_code == 200:
                        data1 = resp1.json()
                        if isinstance(data1, list):
                            for x in data1:
                                if isinstance(x, dict) and x.get('name'):
                                    x['_api_url'] = url1
                                    themes.append(x)
                    else:
                        errors.append(f"Main: HTTP {resp1.status_code}")
                except Exception as e1:
                    errors.append(f"Main: {e1}")

                # Fetch 2 (Overflow)
                if url1 != url2:
                    try:
                        resp2 = requests.get(url2, timeout=10, verify=False)
                        if resp2.status_code == 200:
                            data2 = resp2.json()
                            if isinstance(data2, list):
                                for x in data2:
                                    if isinstance(x, dict) and x.get('name'):
                                        x['_api_url'] = url2
                                        themes.append(x)
                    except Exception as e2:
                        pass

                if not themes and errors:
                     raise Exception("; ".join(errors))

                run_on_ui_thread(lambda: self._display_catalog_list(context, themes))
            except Exception as e:
                log(f"Catalog fetch error: {e}")
                def show_err():
                    loading.setText(f"{Locales.get('catalog_error')}: {e}")
                    loading.setTextColor(Color.RED)
                run_on_ui_thread(show_err)
        threading.Thread(target=fetch).start()
                
    def _display_catalog_list(self, context, themes):
        self.catalog_content.removeAllViews()
        if not themes:
            empty = TextView(context)
            empty.setText("Ð¡Ð¿Ð¸ÑÐ¾Ðº Ñ‚ÐµÐ¼ Ð¿ÑƒÑÑ‚ / No themes found")
            empty.setGravity(Gravity.CENTER)
            self.catalog_content.addView(empty)
            return

        scroll = ScrollView(context)
        list_layout = LinearLayout(context); list_layout.setOrientation(LinearLayout.VERTICAL)
        
        count_view = TextView(context)
        count_view.setText(Locales.get('catalog_count', count=len(themes)))
        count_view.setGravity(Gravity.CENTER)
        count_view.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
        count_view.setTextColor(self._get_color_safe(Theme.key_windowBackgroundWhiteGrayText, Color.GRAY))
        list_layout.addView(count_view)
        
        from java.net import URLEncoder
        from org.telegram.messenger import UserConfig
        my_id = UserConfig.getInstance(0).clientUserId
        installed_themes = self._load_custom_themes()

        for item in themes:
            name = item.get('name', 'Unknown')
            theme_data_str = item.get('data', '')
            author_id = str(item.get('author_id', ''))
            
            is_installed = name in installed_themes
            is_author = author_id == str(my_id)
            
            suffix = ""
            if is_installed:
                suffix += " ðŸ’š"
            else:
                suffix += " ðŸ¤"
            
            if is_author:
                suffix += " ðŸ‘‘"
            
            row = TextView(context)
            row.setText(name + suffix)
            row.setTextSize(16)
            row.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
            row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))
            row.setBackground(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector), 2))
            try:
                encoded_name = URLEncoder.encode(name, "UTF-8")
            except:
                encoded_name = name
            
            def on_theme_click(v, n=encoded_name, d=theme_data_str, i=item):
                self._import_theme_from_link(n, d, i)

            row.setOnClickListener(ClickListenerProxy(self, on_theme_click))
            list_layout.addView(row)
            
        scroll.addView(list_layout)
        self.catalog_content.addView(scroll)

    def _render_catalog_add_tab(self, context):
        self.catalog_content.removeAllViews()
        custom_themes = self._load_custom_themes()
        
        scroll = ScrollView(context)
        list_layout = LinearLayout(context); list_layout.setOrientation(LinearLayout.VERTICAL)
        
        for name in custom_themes.keys():
            row = TextView(context)
            row.setText(name)
            row.setTextSize(16)
            row.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
            row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))
            row.setBackground(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector), 2))
            
            row.setOnClickListener(ClickListenerProxy(self, lambda v, n=name: self._publish_theme_flow(context, n)))
            list_layout.addView(row)
            
        if not custom_themes:
            empty = TextView(context)
            empty.setText("No custom themes")
            empty.setGravity(Gravity.CENTER)
            empty.setPadding(0, AndroidUtilities.dp(20), 0, 0)
            list_layout.addView(empty)
            
        scroll.addView(list_layout)
        self.catalog_content.addView(scroll)
    # ÐŸÑƒÐ±Ð»Ð¸ÐºÑƒÐµÑ‚ Ñ‚ÐµÐ¼Ñƒ Ð² Ð¾Ð±Ñ‰Ð¸Ð¹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³ (mockapi), ÑÐ¾Ñ…Ñ€Ð°Ð½ÑÑ Ð°Ð²Ñ‚Ð¾Ñ€ÑÑ‚Ð²Ð¾ (ID Ð¸ Ð˜Ð¼Ñ).
    # Publishes the theme to the public catalog (mockapi), preserving authorship (ID and Name).
    def _publish_theme_flow(self, context, name):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity and isinstance(context, Activity):
                activity = context
            
            if not activity:
                return

            def start_upload(d, w):
                try:
                    d.dismiss()
                except:
                    pass
                
                if not self.CATALOG_API_URL:
                    BulletinHelper.show_error("API URL Error", fragment)
                    return

                loading_dialog = AlertDialogBuilder(activity).set_title("ÐŸÑƒÐ±Ð»Ð¸ÐºÐ°Ñ†Ð¸Ñ...").show()
                loading_dialog.set_cancelable(False)

                def upload_task():
                    try:
                        import requests
                        custom_themes = self._load_custom_themes()
                        if name not in custom_themes:
                            run_on_ui_thread(lambda: loading_dialog.dismiss())
                            return

                        theme_data = custom_themes[name]
                        data_str = ";".join([f"{k}:{v}" for k, v in theme_data.items()])
                        
                        from java.net import URLEncoder
                        encoded_name = URLEncoder.encode(name, "UTF-8")
                        encoded_data = URLEncoder.encode(data_str, "UTF-8")
                        
                        payload = {
                            "name": name,
                            "data": encoded_data,
                            "author": self._get_current_username(),
                            "author_id": UserConfig.getInstance(0).clientUserId
                        }
                        
                        url1 = self.CATALOG_API_URL
                        url2 = re.sub(r'/themes/?$', '/themes2', url1)
                        
                        target_url = None
                        try:
                            # Check Endpoint 1
                            resp1 = requests.get(url1, timeout=10, verify=False)
                            list1 = resp1.json() if resp1.status_code == 200 and isinstance(resp1.json(), list) else []
                            
                            for item in list1:
                                if item.get('name') == name:
                                    run_on_ui_thread(lambda: (loading_dialog.dismiss(), AlertDialogBuilder(activity).set_title(Locales.get('alert_already_added')).set_positive_button("OK", None).show()))
                                    return
                            
                            if len(list1) < 100:
                                target_url = url1
                            else:
                                # Check Endpoint 2
                                resp2 = requests.get(url2, timeout=10, verify=False)
                                list2 = resp2.json() if resp2.status_code == 200 and isinstance(resp2.json(), list) else []
                                
                                for item in list2:
                                    if item.get('name') == name:
                                        run_on_ui_thread(lambda: (loading_dialog.dismiss(), AlertDialogBuilder(activity).set_title(Locales.get('alert_already_added')).set_positive_button("OK", None).show()))
                                        return
                                
                                if len(list2) < 100:
                                    target_url = url2
                                else:
                                    run_on_ui_thread(lambda: (loading_dialog.dismiss(), BulletinHelper.show_error("ÐšÐ°Ñ‚Ð°Ð»Ð¾Ð³ Ð¿ÐµÑ€ÐµÐ¿Ð¾Ð»Ð½ÐµÐ½ >.<", fragment)))
                                    return
                        except Exception as e:
                            run_on_ui_thread(lambda: loading_dialog.dismiss())
                            raise e

                        if target_url:
                            resp = requests.post(target_url, json=payload, timeout=15, verify=False)
                            if resp.status_code >= 200 and resp.status_code < 300:
                                def show_success_alert():
                                    loading_dialog.dismiss()
                                    self._update_user_stats(name)
                                    AlertDialogBuilder(activity).set_title("Ð£ÑÐ¿ÐµÑ…").set_message(Locales.get('publish_success')).set_positive_button("OK", None).show()
                                run_on_ui_thread(show_success_alert)
                            else:
                                raise Exception(f"HTTP {resp.status_code}")

                    except Exception as e:
                        log(f"[BlockBlast] Publish error: {e}")
                        run_on_ui_thread(lambda: (loading_dialog.dismiss(), BulletinHelper.show_error(Locales.get('alert_error'), fragment)))

                threading.Thread(target=upload_task).start()

            AlertDialogBuilder(activity) \
                .set_title(Locales.get('publish_confirm_title')) \
                .set_message(Locales.get('publish_confirm_text', name=name)) \
                .set_positive_button("OK", start_upload) \
                .set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None) \
                .show()

        except Exception as e:
            log(f"[BlockBlast] Publish flow error: {e}")
    def _show_theme_preview_dialog(self, context, name, theme_data, metadata=None, mode="catalog"):
        builder = AlertDialogBuilder(context)
        builder.set_title(Locales.get('theme_preview_title') + f": {name}")
        
        main = LinearLayout(context); main.setOrientation(LinearLayout.VERTICAL)
        main.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(10), AndroidUtilities.dp(16), AndroidUtilities.dp(10))
        
        installed_themes = self._load_custom_themes()
        is_installed = name in installed_themes
        
        status_text = "âœ… Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾" if is_installed else "âŒ ÐÐµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾"
        status_color = Color.GREEN if is_installed else Color.RED
        status_view = TextView(context)
        status_view.setText(status_text)
        status_view.setTextColor(status_color)
        status_view.setTextSize(14)
        status_view.setPadding(0, 0, 0, AndroidUtilities.dp(8))
        main.addView(status_view)
        
        info = TextView(context)
        info.setText(Locales.get('theme_preview_info'))
        info.setTextColor(Color.WHITE)
        main.addView(info)
        
        scroll = ScrollView(context)
        colors_layout = LinearLayout(context); colors_layout.setOrientation(LinearLayout.VERTICAL)
        
        for key, color in theme_data.items():
            if key.startswith("_"): continue
            row = LinearLayout(context); row.setOrientation(LinearLayout.HORIZONTAL); row.setGravity(Gravity.CENTER_VERTICAL)
            row.setPadding(0, AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4))
            
            preview = View(context)
            bg = GradientDrawable(); bg.setShape(GradientDrawable.OVAL)
            try:
                bg.setColor(Color.parseColor(color))
                bg.setStroke(AndroidUtilities.dp(1), Color.GRAY)
            except: pass
            preview.setBackground(bg)
            
            row.addView(preview, LinearLayout.LayoutParams(AndroidUtilities.dp(24), AndroidUtilities.dp(24)))
            
            label = TextView(context)
            clean_key = key.replace('cell_', '').replace('color_', '').replace('_', ' ').title()
            label.setText(f"{clean_key}: {color}")
            label.setTextColor(Color.WHITE)
            label.setPadding(AndroidUtilities.dp(12), 0, 0, 0)
            row.addView(label)
            colors_layout.addView(row)
            
        scroll.addView(colors_layout)
        main.addView(scroll, LinearLayout.LayoutParams(-1, AndroidUtilities.dp(300)))
        
        builder.set_view(main)
        
        # --- Logic for Buttons ---
        
        # 1. Local Settings Preview (Mode: Local)
        if mode == "local":
            def on_delete(d, w):
                AlertDialogBuilder(context) \
                    .set_title(Locales.get('theme_delete_confirm_title')) \
                    .set_message(Locales.get('theme_delete_confirm_text', theme_name=name)) \
                    .set_positive_button("OK", lambda d2, w2: (self._delete_theme(name, context), d2.dismiss(), d.dismiss())) \
                    .set_negative_button(Locales.get('theme_cancel_button'), None) \
                    .show()

            builder.set_positive_button("ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ñ‚ÐµÐ¼Ð¾Ð¹", lambda d, w: self._share_custom_theme(context, name))
            builder.set_neutral_button("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ", on_delete)
            builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None)

        # 2. Catalog / Link Preview (Mode: Catalog)
        else:
            my_id = UserConfig.getInstance(0).clientUserId
            is_author = False
            if metadata and metadata.get('author_id'):
                is_author = str(metadata['author_id']) == str(my_id)
            
            def install_theme():
                all_themes = self._load_custom_themes()
                theme_data['_tag'] = 'cat'
                all_themes[name] = theme_data
                self._save_custom_themes(all_themes)
                
                self._apply_and_redraw_ui()
                
                # Refresh catalog if open
                if self._is_dialog_showing(getattr(self, 'catalog_dialog', None)):
                    self._render_catalog_content(context)
                
                # Close preview
                if self.preview_dialog:
                    self.preview_dialog.dismiss()
                
                AlertDialogBuilder(context).set_title("Ð£ÑÐ¿ÐµÑ…").set_message(Locales.get('theme_imported', name=name)).set_positive_button("OK", None).show()
            def remove_from_cloud():
                if not (metadata and metadata.get('id') and metadata.get('_api_url')):
                    return

                def perform_delete(d, w):
                    try:
                        import requests
                        resp = requests.delete(f"{metadata['_api_url']}/{metadata['id']}", timeout=10, verify=False)
                        if resp.status_code == 200:
                            self._update_user_stats(name)
                            AlertDialogBuilder(context).set_title("Ð£ÑÐ¿ÐµÑ…").set_message("Ð¢ÐµÐ¼Ð° ÑƒÐ´Ð°Ð»ÐµÐ½Ð° Ð¸Ð· ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð°!").set_positive_button("OK", None).show()
                            if self._is_dialog_showing(getattr(self, 'catalog_dialog', None)):
                                self._render_catalog_content(context)
                            if self.preview_dialog: self.preview_dialog.dismiss()
                        else:
                            BulletinHelper.show_error(f"Error: {resp.status_code}", get_last_fragment())
                    except Exception as e:
                        BulletinHelper.show_error(f"Error: {e}", get_last_fragment())
                
                AlertDialogBuilder(context) \
                    .set_title("Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ Ñ‚ÐµÐ¼Ñ‹") \
                    .set_message(f"Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ñ‚ÐµÐ¼Ñƒ '{name}' Ð¸Ð· ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð°?") \
                    .set_positive_button("Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ", perform_delete) \
                    .set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None) \
                    .show()

            if not is_author:
                if is_installed:
                    builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None)
                else:
                    builder.set_positive_button("Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ", lambda d, w: install_theme())
                    builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None)
            else:
                # I am author
                if not is_installed:
                    builder.set_positive_button("Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ", lambda d, w: install_theme())
                    builder.set_neutral_button("Remove", lambda d, w: remove_from_cloud())
                    builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None)
                else:
                    builder.set_neutral_button("Remove", lambda d, w: remove_from_cloud())
                    builder.set_negative_button("ÐžÑ‚Ð¼ÐµÐ½Ð°", None)

        self.preview_dialog = builder.show()

    def _delete_theme(self, name, context):
        all_themes = self._load_custom_themes()
        if name in all_themes:
            del all_themes[name]
            self._save_custom_themes(all_themes)
        if self.get_setting("game_theme_pg", 0) != 0:
             self.set_setting("game_theme_pg", 0)
        self._show_custom_gui_settings(context, start_tab=3)
        AlertDialogBuilder(context).set_title("Ð£ÑÐ¿ÐµÑ…").set_message(f"Ð¢ÐµÐ¼Ð° '{name}' ÑƒÐ´Ð°Ð»ÐµÐ½Ð°!").set_positive_button("OK", None).show()
    def _safe_show_game_dialog(self, context: Optional[Dict[str, Any]] = None):
        if not UI_CLASSES_LOADED: 
            run_on_ui_thread(lambda: BulletinHelper.show_error("UI classes not loaded. Plugin cannot run."))
            return
        
        if self.get_setting("is_minimized_pg", False) and self.pg_floating_cube:
            self._restore_game()
            return

        try:
            fragment = get_last_fragment()
            if not fragment:
                if isinstance(context, dict):
                    fragment = self._get_fragment_from_context(context)

            activity = None
            if fragment:
                activity = fragment.getParentActivity()
            elif LaunchActivity.instance:
                activity = LaunchActivity.instance
            
            if not activity:
                log(f"[{__name__}] Could not find a valid activity to show dialog.")
                return
            
            self.pg_context = activity
            is_resumed = self._load_game_state() and not self.pg_game_over
            self.show_game_dialog(activity, is_resumed)
            
        except Exception as e:
            log(f"[{__name__}] ÐšÐ Ð˜Ð¢Ð˜Ð§Ð•Ð¡ÐšÐÐ¯ ÐžÐ¨Ð˜Ð‘ÐšÐ Ð² show_game_dialog: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda err=e: BulletinHelper.show_error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ° Ð¸Ð³Ñ€Ñ‹: {err}"))

    def _get_fragment_from_context(self, context: Dict[str, Any]) -> Optional[Any]:
        return context.get("fragment") or get_last_fragment()

    def _calculate_grid_dimensions(self, activity: Context) -> Tuple[int, int]:
        if not UI_CLASSES_LOADED:
            return AndroidUtilities.dp(30), AndroidUtilities.dp(1)

        screen_dim = min(AndroidUtilities.displaySize.x, AndroidUtilities.displaySize.y)
        max_dialog_content_width = screen_dim - AndroidUtilities.dp(40) 

        min_margin_px = AndroidUtilities.dp(1)
        
        raw_cell_size_px = (max_dialog_content_width - 10 * min_margin_px) // PG_GRID_SIZE

        base_dp_unit = AndroidUtilities.dp(1) if UI_CLASSES_LOADED else 3
        cell_size_px_unscaled = raw_cell_size_px
        if base_dp_unit > 0:
            cell_size_px_unscaled = int(raw_cell_size_px / base_dp_unit) * base_dp_unit
        
        scale_factor_percent = self.get_setting("cell_size_scale_pg", 85)
        scale_multiplier = scale_factor_percent / 100.0

        final_cell_size_px = int(cell_size_px_unscaled * scale_multiplier)
        
        max_limit = AndroidUtilities.dp(35)
        if final_cell_size_px > max_limit:
            final_cell_size_px = max_limit
        elif final_cell_size_px < AndroidUtilities.dp(15):
            final_cell_size_px = AndroidUtilities.dp(15)

        return final_cell_size_px, min_margin_px
    
    def show_game_dialog(self, activity: Any, is_resumed: bool = False):
        if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing() and not self.pg_is_starting_new_game:
            return
        
        cell_size_px, margin_px = self._calculate_grid_dimensions(activity) 
        
        main_layout = LinearLayout(activity)
        main_layout.setOrientation(LinearLayout.VERTICAL)
        main_layout.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16))
        main_layout.setGravity(Gravity.CENTER_HORIZONTAL)
        
        if UI_CLASSES_LOADED:
             main_layout.setLayerType(View.LAYER_TYPE_SOFTWARE, None)

        dialog_bg = GradientDrawable()
        dialog_bg.setCornerRadius(AndroidUtilities.dp(12))
        
        theme_name = self._get_current_theme_name()
        if theme_name not in PG_THEMES:
            grad_state = self._get_custom_gradient_state()
            if grad_state.get('is_gradient') and grad_state.get('point_1_id', -1) != -1 and grad_state.get('point_2_id', -1) != -1:
                color1 = Color.parseColor(grad_state['color_1_hex'])
                color2 = Color.parseColor(grad_state['color_2_hex'])
                orientation = get_gradient_orientation(grad_state['point_1_id'], grad_state['point_2_id'])
                colors_jarray = jarray(jint)([color1, color2])
                dialog_bg = GradientDrawable(orientation, colors_jarray)
                dialog_bg.setCornerRadius(AndroidUtilities.dp(12))
            else:
                dialog_bg.setColor(Color.parseColor(self._get_themed_color("grid_bg")))
        else:
            dialog_bg.setColor(Color.parseColor(self._get_themed_color("grid_bg")))
        main_layout.setBackground(dialog_bg)
        
        main_layout.addView(self._create_header_content(activity))
        
        self.status_view = None
        
        self.pg_grid_container = self._create_board_view(activity, cell_size_px, margin_px)
        main_layout.addView(self.pg_grid_container)
        
        if UI_CLASSES_LOADED and self.pg_drag_listener_instance is None:
             self.pg_drag_listener_instance = OnDragDropListenerProxy(self)
        
        main_layout.addView(self._create_shape_selector(activity))
        self._update_shape_listeners() 

        new_game_button = self._create_new_game_button(activity)
        main_layout.addView(new_game_button)

        builder = AlertDialogBuilder(activity)
        builder.set_view(main_layout)
        
        self._dismiss_listener_ref = DismissListenerProxy(lambda: self) 
        
        self.dialog = builder.create()
        self.dialog.set_on_dismiss_listener(self._dismiss_listener_ref)
        
        self.dialog.show()
        self._start_selector_animations()
        if self.full_screen_blur_overlay and self.full_screen_blur_overlay.getParent():
            overlay_to_remove = self.full_screen_blur_overlay
            self.full_screen_blur_overlay = None

            def remove_blur_action():
                try:
                    parent_view = overlay_to_remove.getParent()
                    if parent_view and overlay_to_remove.getParent() == parent_view:
                         overlay_to_remove.animate().alpha(0.0).setDuration(300).withEndAction(RunnableProxy(
                             lambda: parent_view.removeView(overlay_to_remove)
                         )).start()
                except Exception as e:
                    log(f"Error removing transition blur overlay: {e}")

            run_on_ui_thread(remove_blur_action)


        
        if is_resumed:
            self._draw_grid()
            self._draw_shapes()
            self._update_score_display()
            self._update_status("")
        else:
             self.start_new_game()

        if hasattr(self, '_cache_grid_layout_info'):
            self._cache_grid_layout_info(self.pg_grid_container)
        else:
            log(f"[{__name__}] FATAL ERROR: _cache_grid_layout_info method is missing.")


    def _get_fragment_from_context(self, context: Dict[str, Any]) -> Optional[Any]:
        return context.get("fragment") or get_last_fragment()

    def _cache_grid_layout_info(self, grid_container: View):
        if grid_container is None: return

        def get_info():
            try:
                if not grid_container.isShown():
                    run_on_ui_thread(get_info, delay=50) 
                    return
                    
                if UI_CLASSES_LOADED:
                    location = jarray(jint)(2)
                else:
                    return

                grid_container.getLocationOnScreen(location)
                
                grid_size = grid_container.getMeasuredWidth() 
                margin = AndroidUtilities.dp(1)
                cell_size_px, _ = self._calculate_grid_dimensions(grid_container.getContext()) 

                PG_GRID_INFO["cell_size"] = cell_size_px
                PG_GRID_INFO["margin"] = margin
                PG_GRID_INFO["location"] = (int(location[0]), int(location[1]))
                PG_GRID_INFO["size"] = grid_size
                
            except Exception as e:
                log(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ PG_GRID_INFO: {e}\n{traceback.format_exc()}")
        
        run_on_ui_thread(get_info, delay=500)
        
    def _on_game_dialog_dismiss_internal(self):
        log(f"[{__name__}] Game dialog dismissed. Current score: {self.pg_score}")
        self._stop_selector_animations()

        self.pg_is_starting_new_game = False
        
        if not self.pg_game_over and not self.get_setting("is_minimized_pg", False):
            self._save_game_state() 
            self._update_status("")
        
        elif self.pg_game_over:
             self.set_setting("blockblast_state_pg", None)

        if self.pg_floating_cube:
             self.pg_floating_cube.update_display()

    def _create_header_content(self, context):
        scale = self.get_setting("top_buttons_size_scale_pg", 100) / 100.0

        header_container = LinearLayout(context)
        header_container.setOrientation(LinearLayout.HORIZONTAL)
        header_container.setGravity(Gravity.TOP | Gravity.CENTER_VERTICAL)
        header_container.setPadding(0, AndroidUtilities.dp(4), 0, 0)

        left_controls = LinearLayout(context)
        left_controls.setOrientation(LinearLayout.VERTICAL)
        left_controls.setGravity(Gravity.CENTER_HORIZONTAL)
        
        scaled_control_dim = int(AndroidUtilities.dp(48) * scale)
        
        if self.get_setting("show_minimize_button_pg", True):
            minimize_button = TextView(context)
            minimize_button.setText("â€”")
            minimize_button.setTextColor(Color.parseColor(self._get_themed_color("score_text")))
            minimize_button.setTextSize(int(20 * scale))
            minimize_button.setTypeface(None, Typeface.BOLD)

            minimize_button.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), AndroidUtilities.dp(2))
            minimize_button.setOnClickListener(ClickListenerProxy(self, lambda v: self._minimize_game()))
            left_controls.addView(minimize_button)

        if self.get_setting("show_settings_button_pg", True):
            settings_button = TextView(context)
            settings_button.setText("âš™ï¸")
            settings_button.setTextColor(Color.parseColor(self._get_themed_color("score_text")))
            settings_button.setTextSize(int(16 * scale))
            settings_button.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0)
            settings_button.setOnClickListener(ClickListenerProxy(self, lambda v: self._show_custom_gui_settings(context)))
            left_controls.addView(settings_button)
        
        header_container.addView(left_controls, LinearLayout.LayoutParams(scaled_control_dim, -2))

        score_container = LinearLayout(context)
        score_container.setOrientation(LinearLayout.VERTICAL)
        score_container.setGravity(Gravity.CENTER_HORIZONTAL)
        
        self.score_view = TextView(context)
        self.score_view.setTextSize(int(15 * scale))
        self.score_view.setTypeface(None, Typeface.BOLD)
        score_container.addView(self.score_view)

        self.high_score_view = TextView(context)
        self.high_score_view.setTextSize(int(12 * scale))
        self.high_score_view.setOnClickListener(ClickListenerProxy(self, lambda v: self._show_leaderboard()))
        score_container.addView(self.high_score_view)
        
        score_params = LinearLayout.LayoutParams(0, -2, 1.0)
        score_params.gravity = Gravity.CENTER_VERTICAL
        header_container.addView(score_container, score_params)

        if self.get_setting("show_exit_button_pg", True):
            exit_button = TextView(context)
            exit_button.setText("Ã—")
            exit_button.setTextColor(Color.parseColor(self._get_themed_color("score_text")))
            exit_button.setTextSize(int(24 * scale))
            exit_button.setTypeface(None, Typeface.BOLD)
            exit_button.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0)
            exit_button.setOnClickListener(ClickListenerProxy(self, lambda v: self.dialog.dismiss() if self.dialog else None))
            header_container.addView(exit_button, LinearLayout.LayoutParams(scaled_control_dim, -2))
        else:
            placeholder = View(context)
            header_container.addView(placeholder, LinearLayout.LayoutParams(scaled_control_dim, -2))

        self._update_score_display()
        return header_container
        
    def _create_board_view(self, context, cell_size_px: int, margin_px: int):
        board_container = LinearLayout(context)
        board_container.setOrientation(LinearLayout.VERTICAL)
        
        board_container.setLayoutParams(LinearLayout.LayoutParams(-2, -2))
        
        PG_GRID_INFO["cell_size"] = cell_size_px 
        PG_GRID_INFO["margin"] = margin_px 
        PG_GRID_INFO["size"] = PG_GRID_SIZE * cell_size_px + (PG_GRID_SIZE + 1) * margin_px

        self.grid_buttons = [[None] * PG_GRID_SIZE for _ in range(PG_GRID_SIZE)]
        

        text_size_sp = max(14, int(cell_size_px / AndroidUtilities.dp(1) * 0.7))

        
        for r in range(PG_GRID_SIZE):
            row_layout = LinearLayout(context)
            row_layout.setOrientation(LinearLayout.HORIZONTAL)
            
            for c in range(PG_GRID_SIZE):
                button = TextView(context)
                button.setText("")
                button.setTextSize(text_size_sp) 
                button.setTypeface(None, Typeface.BOLD) 
                button.setTextColor(Color.parseColor(self._get_themed_color("score_text")))
                button.setGravity(Gravity.CENTER)
                button.setPadding(0, 0, 0, 0)
                
                bg = GradientDrawable()
                bg.setShape(GradientDrawable.RECTANGLE)
                percentage = self.get_setting("corner_radius_blocks_cells_pg", 0) / 100.0
                base_radius_px = AndroidUtilities.dp(2)
                max_radius_px = cell_size_px / 2.0
                radius = base_radius_px + (max_radius_px - base_radius_px) * percentage
                bg.setCornerRadius(radius)
                button.setBackground(bg)
                
                params = LinearLayout.LayoutParams(cell_size_px, cell_size_px)
                params.setMargins(margin_px, margin_px, margin_px, margin_px)
                button.setLayoutParams(params)
                
                button.setOnClickListener(ClickListenerProxy(self, lambda v, row=r, col=c: self._on_cell_click(row, col)))
                self.grid_buttons[r][c] = button
                row_layout.addView(button)
            
            board_container.addView(row_layout)
        return board_container
        
    def _create_shape_preview_cell(self, context):
        cell_size = AndroidUtilities.dp(8)
        margin = AndroidUtilities.dp(0.5)
        
        view = View(context)
        bg = GradientDrawable()
        bg.setShape(GradientDrawable.RECTANGLE)
        bg.setCornerRadius(AndroidUtilities.dp(1))
        view.setBackground(bg)
        
        params = LinearLayout.LayoutParams(cell_size, cell_size)
        params.setMargins(margin, margin, margin, margin)
        view.setLayoutParams(params)
        
        return view

    def _create_shape_selector(self, context):
        scale = self.get_setting("shape_button_size_scale_pg", 100) / 100.0

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.HORIZONTAL)
        container.setGravity(Gravity.CENTER)
        container.setPadding(0, AndroidUtilities.dp(16), 0, 0)
        
        self.shape_buttons.clear()
        self.pg_shape_preview_containers.clear()
        
        scaled_dim = int(AndroidUtilities.dp(70) * scale)
        scaled_margin = int(AndroidUtilities.dp(8) * scale)
        
        for i in range(3):
            shape_container = FrameLayout(context)
            shape_container.setTag(i)
            
            params = LinearLayout.LayoutParams(scaled_dim, scaled_dim)
            params.setMargins(scaled_margin, 0, scaled_margin, 0)
            shape_container.setLayoutParams(params)
            
            bg = GradientDrawable()
            bg.setShape(GradientDrawable.RECTANGLE)
            bg.setCornerRadius(AndroidUtilities.dp(8))
            shape_container.setBackground(bg)
            
            preview_grid = LinearLayout(context)
            preview_grid.setOrientation(LinearLayout.VERTICAL)
            preview_grid.setGravity(Gravity.CENTER)
            
            cells_5x5 = []
            for r in range(5):
                row_layout = LinearLayout(context)
                row_layout.setOrientation(LinearLayout.HORIZONTAL)
                row_layout.setGravity(Gravity.CENTER)
                for c in range(5):
                    cell_size = int(AndroidUtilities.dp(5) * scale) 
                    margin = int(AndroidUtilities.dp(0.5) * scale)

                    cell = View(context)
                    cell_bg = GradientDrawable()
                    cell_bg.setShape(GradientDrawable.RECTANGLE)
                    percentage = self.get_setting("corner_radius_blocks_cells_pg", 0) / 100.0
                    base_radius_px = AndroidUtilities.dp(1)
                    max_radius_px = cell_size / 2.0
                    radius = base_radius_px + (max_radius_px - base_radius_px) * percentage
                    cell_bg.setCornerRadius(radius)
                    cell.setBackground(cell_bg)
                    
                    cell_params = LinearLayout.LayoutParams(cell_size, cell_size)
                    cell_params.setMargins(margin, margin, margin, margin)
                    cell.setLayoutParams(cell_params)

                    row_layout.addView(cell)
                    cells_5x5.append(cell)
                preview_grid.addView(row_layout)
            
            if UI_CLASSES_LOADED:
                shape_container.addView(preview_grid, LayoutHelper.createFrame(-2, -2, Gravity.CENTER))
            else:
                shape_container.addView(preview_grid) 
            
            self.shape_buttons.append(shape_container)
            self.pg_shape_preview_containers.append({'container': shape_container, 'cells': cells_5x5, 'index': i})
            container.addView(shape_container)

        return container

    def _create_new_game_button(self, context):
        scale = self.get_setting("restart_button_size_scale_pg", 100) / 100.0
        
        scaled_padding = int(AndroidUtilities.dp(16) * scale)
        
        new_game_button = Button(context)
        new_game_button.setText(Locales.get('restart_btn'))
        new_game_button.setTextColor(Color.parseColor(self._get_themed_color("button_text")))
        new_game_button.setTextSize(int(16 * scale))
        
        bg_new = GradientDrawable()
        bg_new.setShape(GradientDrawable.RECTANGLE)
        bg_new.setCornerRadius(AndroidUtilities.dp(8))
        bg_new.setColor(Color.parseColor(self._get_themed_color("button_bg")))
        new_game_button.setBackground(bg_new)
        
        new_game_button.setPadding(scaled_padding, int(AndroidUtilities.dp(12) * scale), scaled_padding, int(AndroidUtilities.dp(12) * scale))

        scaled_height = int(AndroidUtilities.dp(40) * scale)
        params = LinearLayout.LayoutParams(-1, scaled_height)
        params.topMargin = AndroidUtilities.dp(20)
        
        side_margin = int(AndroidUtilities.dp(40) * (1.0 - scale) * 0.5) 
        params.leftMargin = side_margin
        params.rightMargin = side_margin
        
        new_game_button.setLayoutParams(params)
        
        new_game_button.setOnClickListener(ClickListenerProxy(self, lambda v: self._handle_new_game_click()))
        return new_game_button

    def _handle_new_game_click(self):
        if self.dialog and self.dialog.get_dialog() and self.dialog.get_dialog().isShowing():
            self._animate_board_clear("cell_restart", self.start_new_game)
        
    def _load_high_score(self):
        try:
            pg_high_score_str = self.get_setting("blockblast_high_score_pg", "0")
            return int(pg_high_score_str)
        except:
            return 0

    def _save_high_score(self, show_success_bulletin: bool = False):
        is_new_high = self.pg_score > self.pg_high_score
        if is_new_high:
            self.pg_high_score = self.pg_score
            try:
                self.set_setting("blockblast_high_score_pg", str(self.pg_high_score))
                if show_success_bulletin:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(Locales.get('new_high'), get_last_fragment()))
            except Exception as e:
                log(f"Error saving high score: {e}")
                if show_success_bulletin:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(Locales.get('save_error'), get_last_fragment()))
            
            # Upload high score to server
            self._upload_high_score(self.pg_high_score)
            
        self._update_score_display()

    def _update_score_display(self):
        if self.score_view:
            self.score_view.setText(f"â­ {self.pg_score}")
            self.score_view.setTextColor(Color.parseColor(self._get_themed_color("score_text")))
        if self.high_score_view:
            self.high_score_view.setText(f"ðŸŽ‰ {self.pg_high_score}")
            self.high_score_view.setTextColor(Color.parseColor(self._get_themed_color("high_score_text")))
        if self.pg_floating_cube:
             self.pg_floating_cube.update_display()

    def _update_status(self, text):
        pass

    def start_new_game(self):
        self.pg_grid = [[0] * PG_GRID_SIZE for _ in range(PG_GRID_SIZE)]
        self.pg_score = 0
        self.pg_game_over = False
        if hasattr(self, 'pg_game_over_handler') and self.pg_game_over_handler:
            self.pg_game_over_handler.removeCallbacksAndMessages(None)
        self.pg_game_over_handler = None
        self.pg_current_shapes = [None, None, None] 
        self.pg_selected_shape_index = -1
        self.pg_should_recheck_game_over = False
        self.pg_combo_count = 0 
        self._clear_preview()
        self._update_score_display()
        self._update_status("")
        self._generate_new_shapes()
        self._draw_grid()
        self._update_shape_listeners()
        self.set_setting("blockblast_state_pg", None) 

    def _clear_preview(self):
        self.pg_preview_cells.clear()
        self.pg_last_preview_start_cell = None; self.pg_preview_is_error = False

    def _apply_preview(self, start_r, start_c, shape_cells, is_error: bool = False):
        self._clear_preview()
        for dr, dc in shape_cells:
            self.pg_preview_cells.append((start_r + dr, start_c + dc))
        self.pg_last_preview_start_cell = (start_r, start_c)
        self.pg_preview_is_error = is_error
    def _generate_new_shapes(self):
        if all(shape is None for shape in self.pg_current_shapes):
            all_shape_ids = list(PG_SHAPES.keys())
            self.pg_current_shapes = [random.choice(all_shape_ids) for _ in range(3)]
        
        self._draw_shapes()
        self._check_game_over() 
    
    def _draw_single_shape_preview(self, cells: List[View], shape_index: int, shape_id: Optional[int]):
        color_id = shape_index + 1 
        block_color_hex = self.pg_block_colors.get(color_id, self.pg_block_colors[1])
        shape_coords = PG_SHAPES.get(shape_id, [])
        
        for cell in cells:
            bg = cell.getBackground()
            if isinstance(bg, GradientDrawable):
                bg.setColor(Color.parseColor(self.pg_placeholder_color)) 
        
        if not shape_coords:
            return

        min_r = min(r for r, c in shape_coords)
        min_c = min(c for r, c in shape_coords)
        max_r = max(r for r, c in shape_coords)
        max_c = max(c for r, c in shape_coords)

        height = max_r - min_r + 1
        width = max_c - min_c + 1
        
        preview_dim = 5
        
        normalized_coords = [(r - min_r, c - min_c) for r, c in shape_coords]
        
        start_r_offset = math.floor((preview_dim - height) / 2)
        start_c_offset = math.floor((preview_dim - width) / 2)
        
        for norm_r, norm_c in normalized_coords:
            r = norm_r + start_r_offset
            c = norm_c + start_c_offset
            
            if 0 <= r < preview_dim and 0 <= c < preview_dim:
                index = r * preview_dim + c
                if index < len(cells):
                    cell = cells[index]
                    bg = cell.getBackground()
                    if isinstance(bg, GradientDrawable):
                        bg.setColor(Color.parseColor(block_color_hex))

    def _draw_shapes(self):
        for i, shape_id in enumerate(self.pg_current_shapes):
            container_info = self.pg_shape_preview_containers[i]
            btn = container_info['container']
            is_selected = i == self.pg_selected_shape_index
            
            self._draw_single_shape_preview(container_info['cells'], i, shape_id)
            
            btn.setEnabled(shape_id is not None and not self.pg_game_over)
            
            bg = btn.getBackground()
            if isinstance(bg, GradientDrawable):
                if shape_id is None:
                    bg.setColor(Color.parseColor(self.pg_empty_color))
                elif is_selected:
                    bg.setColor(Color.parseColor(self._get_themed_color("selected_shape_border"))) 
                else:
                    bg.setColor(Color.parseColor(self.pg_placeholder_color)) 
            
    def _draw_cells(self, cells_to_draw: List[Tuple[int, int]]):
        for r, c in cells_to_draw:
            if 0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE:
                btn = self.grid_buttons[r][c]
                if not btn: continue
                color_id = self.pg_grid[r][c]
                color_hex = self.pg_block_colors.get(color_id, self.pg_empty_color)
                
                btn.setText("")
                bg = btn.getBackground()
                if isinstance(bg, GradientDrawable):
                    bg.setColor(Color.parseColor(color_hex))
                
                # Stability: Reset all view properties to prevent 'disappearing' cells
                btn.animate().cancel()
                btn.setAlpha(1.0); btn.setScaleX(1.0); btn.setScaleY(1.0); btn.setTranslationX(0.0)


    def _draw_grid(self):
        for r in range(PG_GRID_SIZE):
            for c in range(PG_GRID_SIZE):
                btn = self.grid_buttons[r][c]
                color_id = self.pg_grid[r][c]
                
                is_preview_cell = (r, c) in self.pg_preview_cells
                is_preview_error = getattr(self, 'pg_preview_is_error', False)

                if is_preview_cell:
                    if is_preview_error or color_id != 0:
                        color_hex = self.pg_error_color
                        btn.setText("Ã—")
                        btn.setTextColor(Color.parseColor(self._get_themed_color("error_cross")))
                    else: # is_preview_cell and not is_preview_error and color_id == 0
                        color_hex = self.pg_preview_color
                        btn.setText("")
                elif color_id == 99:
                    color_hex = self._get_themed_color("cell_error")
                    btn.setText("Ã—")
                    btn.setTextColor(Color.parseColor(self._get_themed_color("error_cross")))
                else:
                    color_hex = self.pg_block_colors.get(color_id, self.pg_empty_color)
                    btn.setText("")
                
                bg = btn.getBackground()
                if isinstance(bg, GradientDrawable):
                    bg.setColor(Color.parseColor(color_hex))
                
                btn.animate().cancel()
                btn.setAlpha(1.0); btn.setScaleX(1.0); btn.setScaleY(1.0); btn.setTranslationX(0.0)
                btn.setEnabled(not self.pg_game_over)

    def _update_preview_on_grid(self, new_preview_cells: List[Tuple[int, int]], is_error: bool = False):
        cells_to_update = set(self.pg_preview_cells) | set(new_preview_cells)
        self.pg_preview_cells = new_preview_cells
        self.pg_preview_is_error = is_error

        for r, c in cells_to_update:
            if not (0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE):
                continue

            btn = self.grid_buttons[r][c]
            color_id = self.pg_grid[r][c]

            # Default state is the grid state
            color_hex = self.pg_block_colors.get(color_id, self.pg_empty_color)
            btn.setText("")
            if color_id == 99:
                btn.setText("Ã—")
                btn.setTextColor(Color.parseColor(self._get_themed_color("error_cross")))

            # Apply preview overlay
            if (r, c) in self.pg_preview_cells:
                if self.pg_preview_is_error:
                    color_hex = self.pg_error_color
                    btn.setText("Ã—")
                    btn.setTextColor(Color.parseColor(self._get_themed_color("error_cross")))
                else:
                    color_hex = self.pg_preview_color
            
            bg = btn.getBackground()
            if isinstance(bg, GradientDrawable):
                bg.setColor(Color.parseColor(color_hex))

    def _handle_shape_selection(self, index: int):
        if self.pg_game_over or self.pg_current_shapes[index] is None:
            return
            
        placement_mode = self.get_setting("placement_mode_pg", 0)
        
        if placement_mode == 1:
            return

        if self.pg_selected_shape_index == index:
            self.pg_selected_shape_index = -1
            self._clear_preview()
            self._update_status("")
        else:
            self.pg_selected_shape_index = index
            self._clear_preview()
            self._update_status(Locales.get('place_hint'))
            
        self._draw_grid()
        self._draw_shapes()
        
    def _update_shape_listeners(self, value: Optional[Any] = None):
        mode = self.get_setting("placement_mode_pg", 0)
        
        if UI_CLASSES_LOADED:
            drag_listener = self.pg_drag_listener_instance
        else:
            drag_listener = None
        
        for container_info in self.pg_shape_preview_containers:
            container = container_info['container']
            index = container_info['index']
            
            if mode in [1, 2] and drag_listener:
                container.setOnClickListener(None) 
                container.setOnTouchListener(drag_listener)
            else: 
                container.setOnClickListener(ClickListenerProxy(self, lambda v, i=index: self._handle_shape_selection(i)))
                container.setOnTouchListener(None)

    def _on_cell_click(self, r: int, c: int):
        if self.is_highlighting_error: return
        if self.pg_game_over or self.pg_selected_shape_index == -1:
            return
            
        placement_mode = self.get_setting("placement_mode_pg", 0)
        if placement_mode == 1:
            return

        shape_id = self.pg_current_shapes[self.pg_selected_shape_index]
        shape_cells = PG_SHAPES.get(shape_id)
        if shape_cells is None:
            return

        is_commit_click = self.pg_last_preview_start_cell == (r, c)
        can_place = self._check_placement(r, c, shape_cells)
        
        if is_commit_click:
            self._clear_preview() 
            if can_place:
                self._commit_placement(r, c, shape_cells)
                self._update_status("") 
            else:
                occupied_cells = self._get_occupied_cells(r, c, shape_cells) 
                self._highlight_error(occupied_cells)
                self._update_status(Locales.get('place_failed'))
        else:

            self._clear_preview()
            self._apply_preview(r, c, shape_cells, is_error=not can_place)
            if can_place:
                self._update_status(Locales.get('place_commit'))
            else:

                self._update_status(Locales.get('place_failed'))


        self._draw_grid()
        self._draw_shapes()
    
    def _get_occupied_cells(self, start_r, start_c, shape_cells) -> List[Tuple[int, int]]:
        occupied = []
        for dr, dc in shape_cells:
            r, c = start_r + dr, start_c + dc
            if not (0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE):
                return [] 
            if self.pg_grid[r][c] != 0:
                occupied.append((r, c))
        return occupied

    def _reset_temporary_errors(self):
        """[CORE FIX v1.8] Ð£Ð´Ð°Ð»ÑÐµÑ‚ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¼ÐµÑ‚ÐºÐ¸ Ð¾ÑˆÐ¸Ð±Ð¾Ðº (99), Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°Ñ Ð¿ÑƒÑÑ‚Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ (0).
        Ð­Ñ‚Ð¾ Ð¿Ñ€ÐµÐ´Ð¾Ñ‚Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¾ÑˆÐ¸Ð±ÐºÐ¸, ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ‹Ðµ Ð² Drag Mode, Ð¾Ñ‚ Ð·Ð°Ð»Ð¸Ð¿Ð°Ð½Ð¸Ñ."""
        for r in range(PG_GRID_SIZE):
            for c in range(PG_GRID_SIZE):
                if self.pg_grid[r][c] == 99:
                    self.pg_grid[r][c] = 0

    def _highlight_error(self, occupied_cells: List[Tuple[int, int]]):
        if self.is_highlighting_error or not occupied_cells:
            return
        self.is_highlighting_error = True

        error_color_hex = self._get_themed_color("cell_error")
        cross_color = Color.parseColor(self._get_themed_color("error_cross"))
        
        for r, c in occupied_cells:
            if 0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE:
                btn = self.grid_buttons[r][c]
                bg = btn.getBackground()
                if isinstance(bg, GradientDrawable):
                    bg.setColor(Color.parseColor(error_color_hex))
                btn.setText("Ã—")
                btn.setTextColor(cross_color)

        self._update_status(Locales.get('error_highlight'))
        
        def reset_highlight():
            try:
                if not self.pg_game_over:
                    self._draw_grid()
                    if self.pg_last_preview_start_cell is None:
                        self._update_status("")
            except Exception as e:
                log(f"Error resetting highlight: {e}")
            finally:
                self.is_highlighting_error = False

        run_on_ui_thread(RunnableProxy(reset_highlight), delay=550)
    
    def _commit_placement(self, start_r, start_c, shape_cells):
        color_id = self.pg_selected_shape_index + 1
        placed_cells = [(start_r + dr, start_c + dc) for dr, dc in shape_cells]

        for r, c in placed_cells:
            self.pg_grid[r][c] = color_id

        self._animate_placement(placed_cells, color_id)

        # Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ Ð»Ð¸Ð½Ð¸Ð¹ Ð¿Ð¾ÑÐ»Ðµ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¸Ñ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸
        run_on_ui_thread(RunnableProxy(self._check_and_clear_lines), delay=PG_PARTICLE_ANIM_DURATION + 50)

        self.pg_current_shapes[self.pg_selected_shape_index] = None
        self.pg_selected_shape_index = -1

        # ÐžÐ±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÑÐµÐ»ÐµÐºÑ‚Ð¾Ñ€ Ñ„Ð¸Ð³ÑƒÑ€, Ñ‚Ð°Ðº ÐºÐ°Ðº Ð¾Ð´Ð½Ð° Ð¸Ð· Ð½Ð¸Ñ… Ð±Ñ‹Ð»Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð°
        self._draw_shapes()
    def _animate_placement(self, placed_cells: List[Tuple[int, int]], color_id: int):
        if not UI_CLASSES_LOADED: return

        color_hex = self.pg_block_colors.get(color_id, self.pg_empty_color)
        color_int = Color.parseColor(color_hex)
        decelerate = DecelerateInterpolator()
        for r, c in placed_cells:
            btn = self.grid_buttons[r][c]

            # ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð¾Ñ‚Ñ€Ð¸ÑÐ¾Ð²ÐºÐ¸ Ð¸ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ Ð¿Ð»Ð°Ð²Ð½Ð¾ÑÑ‚Ð¸
            btn.setText("")
            bg = btn.getBackground()
            if isinstance(bg, GradientDrawable):
                bg.setColor(color_int)

            # ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ð¾Ðµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð´Ð»Ñ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸
            btn.setScaleX(0.5)
            btn.setScaleY(0.5)
            btn.setAlpha(0.0)

            # Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸ÑŽ
            btn.animate().scaleX(1.0).scaleY(1.0).alpha(1.0).setDuration(PG_PARTICLE_ANIM_DURATION + 50).setInterpolator(decelerate).withEndAction(RunnableProxy(lambda b=btn: (b.setAlpha(1.0), b.setScaleX(1.0), b.setScaleY(1.0)))).start()

    def _start_shake_animation(self, btn: View):
        if not btn or not btn.getParent():
            return
        btn.animate().translationX(-AndroidUtilities.dp(2)).setDuration(50).withEndAction(RunnableProxy(
            lambda b=btn: b.animate().translationX(AndroidUtilities.dp(2)).setDuration(100).withEndAction(RunnableProxy(
                lambda b2=b: b2.animate().translationX(0).setDuration(50).start()
            )).start()
        )).start()


    def _animate_clear_lines(self, cells_to_clear: List[Tuple[int, int]]):
        if not UI_CLASSES_LOADED or not cells_to_clear:
            self._check_all_shapes_used()
            return
            
        handler = Handler(Looper.getMainLooper())
        for i, (r, c) in enumerate(cells_to_clear):
            btn = self.grid_buttons[r][c]
            bg = btn.getBackground()
            if isinstance(bg, GradientDrawable):
                bg.setColor(Color.parseColor(self.pg_clear_color))

            # Staggered animation of a light tremor
            handler.postDelayed(RunnableProxy(lambda b=btn: self._start_shake_animation(b)), i * 15)

        def start_fade_out():
            for r, c in cells_to_clear:
                self.pg_grid[r][c] = 0
            
            # ÐžÐ¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ: Ð¿ÐµÑ€ÐµÑ€Ð¸ÑÐ¾Ð²Ñ‹Ð²Ð°ÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½Ð½Ñ‹Ðµ ÑÑ‡ÐµÐ¹ÐºÐ¸ Ð²Ð¼ÐµÑÑ‚Ð¾ Ð²ÑÐµÐ¹ ÑÐµÑ‚ÐºÐ¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸Ð·Ð±ÐµÐ¶Ð°Ñ‚ÑŒ Ð»Ð°Ð³Ð¾Ð²
            self._draw_cells(cells_to_clear)
            self._check_all_shapes_used()

        run_on_ui_thread(RunnableProxy(start_fade_out), delay=PG_CLEAR_ANIM_DURATION)

    def _check_and_clear_lines(self):
        lines_cleared = 0
        cleared_rows, cleared_cols = [], []
        
        for r in range(PG_GRID_SIZE):
            if all(self.pg_grid[r][c] != 0 for c in range(PG_GRID_SIZE)):
                cleared_rows.append(r)
        
        for c in range(PG_GRID_SIZE):
            if all(self.pg_grid[r][c] != 0 for r in range(PG_GRID_SIZE)):
                cleared_cols.append(c)

        lines_cleared = len(cleared_rows) + len(cleared_cols)
        
        cells_to_clear = []
        if lines_cleared > 0:
            
            self.pg_combo_count += 1 

            for r in cleared_rows:
                for c in range(PG_GRID_SIZE):
                    cells_to_clear.append((r, c))
            for c in cleared_cols:
                for r in range(PG_GRID_SIZE):
                    if (r, c) not in cells_to_clear:
                        cells_to_clear.append((r, c))
            

            base_score_gain = 10 * lines_cleared
            combo_bonus_base = 50 * (lines_cleared - 1) if lines_cleared > 1 else 0
            

            combo_chain_bonus = self.pg_combo_count * 20 if self.pg_combo_count > 1 else 0

            score_gain = base_score_gain + combo_bonus_base + combo_chain_bonus
            
            self.pg_score += score_gain
            
            self._update_score_display()
            self._save_high_score(show_success_bulletin=False)
            
            if self.pg_floating_cube: self.pg_floating_cube.update_display()
            

            combo_text = Locales.get('combo_text', count=self.pg_combo_count) if self.pg_combo_count > 1 else ""
            self._update_status(f"âœ¨ {Locales.get('clear')}! (+{lines_cleared} lines) {combo_text}")
            
            self.pg_should_recheck_game_over = True 
            self._animate_clear_lines(cells_to_clear)
        else:
            self.pg_combo_count = 0 
            self.pg_should_recheck_game_over = False
            self._check_all_shapes_used()

    def _check_all_shapes_used(self):
        if all(shape is None for shape in self.pg_current_shapes):
            self._generate_new_shapes() 
        else:
            self._check_game_over() 
            
        self.pg_should_recheck_game_over = False

    def _animate_board_clear(self, color_key: str, on_finish_callback: Callable):
        if not UI_CLASSES_LOADED:
            if callable(on_finish_callback): on_finish_callback()
            return
        
        emoji = "â™»ï¸" if color_key == "cell_restart" else "ðŸ’”"
        self._show_blur_overlay(self.dialog, emoji, PG_BLINK_STEP_DURATION * PG_GAME_OVER_BLINKS * 2)

        def _blink_loop(iteration):
            if iteration >= PG_GAME_OVER_BLINKS * 2:
                if callable(on_finish_callback): on_finish_callback()
                return

            is_on_state = (iteration % 2 == 0)
            target_color = self._get_themed_color(color_key) if is_on_state else self.pg_empty_color
            color_int = Color.parseColor(target_color)

            for r in range(PG_GRID_SIZE):
                for c in range(PG_GRID_SIZE):
                    btn = self.grid_buttons[r][c]
                    btn.setText("")
                    bg = btn.getBackground()
                    if isinstance(bg, GradientDrawable):
                        bg.setColor(color_int)

            run_on_ui_thread(RunnableProxy(lambda: _blink_loop(iteration + 1)), delay=PG_BLINK_STEP_DURATION // 2)

        _blink_loop(0)

    def _handle_game_over_sequence(self):
        if self.pg_floating_cube: self.pg_floating_cube.update_display()
        self._animate_board_clear("game_over", self._finish_game_over_reset)

    def _finish_game_over_reset(self):
        self.start_new_game()

    def _check_game_over(self):
        if self.pg_game_over or (hasattr(self, '_is_checking_game_over') and self._is_checking_game_over):
            return
        self._is_checking_game_over = True

        def background_check():
            # Ð­Ñ‚Ð° Ñ€ÐµÑÑƒÑ€ÑÐ¾ÐµÐ¼ÐºÐ°Ñ Ñ‡Ð°ÑÑ‚ÑŒ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ÑÑ Ð² Ñ„Ð¾Ð½Ð¾Ð²Ð¾Ð¼ Ð¿Ð¾Ñ‚Ð¾ÐºÐµ
            has_move = self._can_any_shape_be_placed()
            
            # Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð¾Ð±Ñ€Ð°Ñ‚Ð½Ð¾ Ð² Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ð¿Ð¾Ñ‚Ð¾Ðº Ð´Ð»Ñ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ UI
            run_on_ui_thread(lambda: self._finish_game_over_check_ui(has_move))

        # Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Ñ„Ð¾Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ð¾Ñ‚Ð¾Ðº Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸
        thread = threading.Thread(target=background_check)
        thread.daemon = True
        thread.start()

    def _finish_game_over_check_ui(self, has_move: bool):
        self._is_checking_game_over = False
        if self.pg_game_over: return

        if not has_move:
            self.pg_game_over = True
            self._save_high_score(show_success_bulletin=True)
            self._update_status(Locales.get('game_over'))
            self._handle_game_over_sequence()
        else:
            if self.pg_selected_shape_index == -1 and self.status_view and self.status_view.getText() != "":
                 self._update_status("")
    def _can_any_shape_be_placed(self):
        for shape_id in self.pg_current_shapes:
            if shape_id is not None:
                shape_cells = PG_SHAPES.get(shape_id)
                if shape_cells and self._can_shape_be_placed(shape_cells):
                    return True
        return False

    def _can_shape_be_placed(self, shape_cells):
        for r in range(PG_GRID_SIZE):
            for c in range(PG_GRID_SIZE):
                if self._check_placement(r, c, shape_cells):
                    return True
        return False
    
    def _check_placement(self, start_r, start_c, shape_cells):
        for dr, dc in shape_cells:
            r, c = start_r + dr, start_c + dc
            if not (0 <= r < PG_GRID_SIZE and 0 <= c < PG_GRID_SIZE): return False 
            if self.pg_grid[r][c] != 0: return False 
        return True
    
    def on_app_event(self, event_type: Any):
        if str(event_type) == "RESUME":
            self._update_shape_listeners()
            if self.pg_floating_cube: self.pg_floating_cube.update_display()
                
    def _handle_open_color_palette(self, target_key: Optional[str] = None):
        self.pg_palette_target_key = target_key
        
        current_hex = self.get_setting(target_key, "#FF0000")
        
        try:
            if current_hex.startswith('#'):
                current_hex = current_hex[1:]
            if len(current_hex) == 6:
                color_int = int(current_hex, 16)
                self.pg_current_r = (color_int >> 16) & 0xFF
                self.pg_current_g = (color_int >> 8) & 0xFF
                self.pg_current_b = color_int & 0xFF
        except Exception as e:
            log(f"Error parsing hex for palette init: {e}. Falling back to default.")
            self.pg_current_r, self.pg_current_g, self.pg_current_b = 255, 0, 0
        
        activity = None
        if self._is_dialog_showing(self.gui_custom_theme_dialog):
            try:
                activity = self.gui_custom_theme_dialog.get_dialog().getContext()
            except Exception:
                activity = None
        
        if not activity:
            try:
                last_fragment = get_last_fragment()
                if last_fragment: activity = last_fragment.getParentActivity()
            except Exception: activity = None
        
        if activity: run_on_ui_thread(lambda: self._safe_show_palette(activity, self.DIALOG_BASE))
        else: run_on_ui_thread(lambda: BulletinHelper.show_error("ÐŸÐ°Ð»Ð¸Ñ‚Ñ€Ð°: ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ."))
        
    def _safe_show_palette(self, activity: Context, target_tab: int = 0):
        if not activity: return
        self._ensure_palette_main_dialog(activity, target_tab)
        
    def _ensure_palette_main_dialog(self, activity: Context, switch_to_tab: Optional[int] = None):
        if switch_to_tab is not None: self.pg_active_palette_tab = switch_to_tab
        
        if self.pg_palette_dialog and self._is_dialog_showing(self.pg_palette_dialog):
            self.pg_palette_dialog.dismiss()
            self.pg_palette_dialog = None

        builder = AlertDialogBuilder(activity)
        pg_main_layout = LinearLayout(activity); pg_main_layout.setOrientation(LinearLayout.VERTICAL)
        header_layout = self._create_palette_tab_header(activity)
        pg_main_layout.addView(header_layout, LinearLayout.LayoutParams(-1, AndroidUtilities.dp(48)))
        self.pg_content_wrapper = LinearLayout(activity); self.pg_content_wrapper.setOrientation(LinearLayout.VERTICAL)
        self.pg_content_wrapper.setLayoutParams(LinearLayout.LayoutParams(-1, AndroidUtilities.dp(350)))
        pg_main_layout.addView(self.pg_content_wrapper); self._update_palette_content_tab(activity)
        builder.set_view(pg_main_layout); builder.set_title("ÐŸÐ°Ð»Ð¸Ñ‚Ñ€Ð° Ñ†Ð²ÐµÑ‚Ð¾Ð²")
        
        def on_set_color_click(dialog, which):
            if not self.pg_palette_target_key: dialog.dismiss(); return
            r, g, b = self.pg_current_r, self.pg_current_g, self.pg_current_b; hex_code = f"#{r:02x}{g:02x}{b:02x}"
            self.set_setting(self.pg_palette_target_key, hex_code)
            
            if self._is_dialog_showing(self.gui_custom_theme_dialog):
                if self.pg_palette_target_key in self.gui_custom_theme_color_rows:
                    row_data = self.gui_custom_theme_color_rows[self.pg_palette_target_key]
                    clean_key = self.pg_palette_target_key.replace('custom_color_', '')
                    locale_key = f'color_{clean_key}'
                    
                    emoji = EMOJI_MAP.get(clean_key, "ðŸŽ¨")
                    
                    run_on_ui_thread(lambda: (
                        row_data['color_preview_view'].getBackground().setColor(Color.parseColor(hex_code)),
                        row_data['text_label_view'].setText(f"{emoji} {Locales.get(locale_key, default=clean_key.replace('_', ' ').title())} ({hex_code.upper()})")
                    ))
            
            if self.pg_floating_cube:
                run_on_ui_thread(self.pg_floating_cube.update_display)
            

            if self.grad_state['gradient_dialog'] and self.pg_palette_target_key == 'grad_color_1_pg':
                 self.grad_state['color_1_hex'] = hex_code
                 self._update_gradient_editor_ui(activity)
            elif self.grad_state['gradient_dialog'] and self.pg_palette_target_key == 'grad_color_2_pg':
                 self.grad_state['color_2_hex'] = hex_code
                 self._update_gradient_editor_ui(activity)

            dialog.dismiss()
        
        builder.set_positive_button("Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ", on_set_color_click)
        builder.set_neutral_button("ÐšÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ HEX", lambda d, w: self._copy_current_color(activity))
        builder.set_negative_button("Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ", lambda *_: None); self.pg_palette_dialog = builder.create(); self.pg_palette_dialog.show()
        
    def _create_palette_tab_header(self, context: Context) -> LinearLayout:
        header = LinearLayout(context); header.setOrientation(LinearLayout.HORIZONTAL)
        
        is_emoji = self.get_setting("emoji_style_pg", False)
        
        def create_tab_button(text: str, tab_id: int, emoji_char: str):
            button = TextView(context)
            
            display_text = emoji_char if is_emoji else text
            if is_emoji:
                button.setTextSize(20)
            else:
                button.setTextSize(13)
                
            button.setText(display_text); 
            button.setGravity(Gravity.CENTER); 
            
            button.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(10), AndroidUtilities.dp(12), AndroidUtilities.dp(10))
            button.setOnClickListener(ClickListenerProxy(self, lambda v, tid=tab_id: self._switch_palette_tab(context, tid)))
            return button, LinearLayout.LayoutParams(0, -1, 1.0)
        
        tabs_data = [
            ("Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ", self.DIALOG_BASE, "ðŸŽ¨"), 
            ("ÐžÑ‚Ñ‚ÐµÐ½ÐºÐ¸", self.DIALOG_SHADES, "ðŸŒˆ"), 
            ("ÐœÐ°Ñ‚Ñ€Ð¸Ñ†Ð°", self.DIALOG_MATRIX, "ðŸ§©")
        ]
        
        for text, tab_id, emoji_char in tabs_data:
            btn, lp = create_tab_button(text, tab_id, emoji_char)
            header.addView(btn, lp)
        
        self.gui_settings_tab_buttons = {self.DIALOG_BASE: header.getChildAt(0), self.DIALOG_SHADES: header.getChildAt(1), self.DIALOG_MATRIX: header.getChildAt(2)}
        self._update_palette_tab_styles(); return header
        
    def _update_palette_tab_styles(self):
        for tab_id, button in self.gui_settings_tab_buttons.items():
            is_active = (tab_id == self.pg_active_palette_tab)
            button.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE) if is_active else self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))
            button.setBackground(None)
            
    def _switch_palette_tab(self, context: Context, tab_id: int):
        if self.pg_active_palette_tab == tab_id: return
        self.pg_active_palette_tab = tab_id; self._update_palette_tab_styles(); self._update_palette_content_tab(context)
        
    def _update_palette_content_tab(self, context: Context):
        self.pg_content_wrapper.removeAllViews()
        if self.pg_active_palette_tab == self.DIALOG_BASE: content_view = self._create_palette_base_picker_view(context)
        elif self.pg_active_palette_tab == self.DIALOG_SHADES: content_view = self._create_palette_shades_view(context)
        else: content_view = self._create_palette_matrix_view(context)
        scroll = ScrollView(context); scroll.addView(content_view, LinearLayout.LayoutParams(-1, -2)); self.pg_content_wrapper.addView(scroll, LinearLayout.LayoutParams(-1, -1))
        if self.pg_active_palette_tab == self.DIALOG_BASE and self.pg_r_bar and self.pg_g_bar and self.pg_b_bar:
            self.pg_r_bar.setOnSeekBarChangeListener(SeekBarChangeListener(lambda sb, p: self._on_color_change('R', p), 0, 1))
            self.pg_g_bar.setOnSeekBarChangeListener(SeekBarChangeListener(lambda sb, p: self._on_color_change('G', p), 0, 1))
            self.pg_b_bar.setOnSeekBarChangeListener(SeekBarChangeListener(lambda sb, p: self._on_color_change('B', p), 0, 1))
        self._update_color_preview()
        
    def _create_palette_base_picker_view(self, context: Context) -> LinearLayout:
        pg_layout = LinearLayout(context); pg_layout.setOrientation(LinearLayout.VERTICAL); pg_layout.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16)); pg_layout.setGravity(Gravity.CENTER_HORIZONTAL)
        self.pg_r_bar, self.pg_g_bar, self.pg_b_bar = None, None, None
        pg_layout.addView(self._create_color_slider(context, "R", Color.RED, self.pg_current_r))
        pg_layout.addView(self._create_color_slider(context, "G", Color.GREEN, self.pg_current_g))
        pg_layout.addView(self._create_color_slider(context, "B", Color.BLUE, self.pg_current_b))
        self.pg_preview_view = TextView(context); pg_preview_params = LinearLayout.LayoutParams(AndroidUtilities.dp(100), AndroidUtilities.dp(50)); pg_preview_params.topMargin = AndroidUtilities.dp(16)
        self.pg_preview_view.setLayoutParams(pg_preview_params); self.pg_preview_view.setGravity(Gravity.CENTER)
        pg_drawable = GradientDrawable(); pg_drawable.setShape(GradientDrawable.RECTANGLE); pg_drawable.setCornerRadius(AndroidUtilities.dp(8)); pg_drawable.setStroke(AndroidUtilities.dp(1), Color.GRAY); self.pg_preview_view.setBackground(pg_drawable); pg_layout.addView(self.pg_preview_view)
        return pg_layout
        
    def _create_palette_shades_view(self, context: Context) -> LinearLayout:
        pg_shades_layout = LinearLayout(context); pg_shades_layout.setOrientation(LinearLayout.VERTICAL); pg_shades_layout.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16)); pg_shades_layout.setGravity(Gravity.CENTER_HORIZONTAL)
        r, g, b = self.pg_current_r, self.pg_current_g, self.pg_current_b; shades = generate_shades(r, g, b)
        info = TextView(context); info.setText(f"ÐžÑ‚Ñ‚ÐµÐ½ÐºÐ¸ Ð´Ð»Ñ #{r:02x}{g:02x}{b:02x}"); info.setTextColor(self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY)); info.setGravity(Gravity.CENTER_HORIZONTAL); info.setTextSize(14); info.setPadding(0, 0, 0, AndroidUtilities.dp(10)); pg_shades_layout.addView(info)
        CELL_SIZE, ROW_LENGTH = AndroidUtilities.dp(40), 4
        for i in range(0, len(shades), ROW_LENGTH):
            pg_row = LinearLayout(context); pg_row.setOrientation(LinearLayout.HORIZONTAL); pg_row.setGravity(Gravity.CENTER)
            for j in range(ROW_LENGTH):
                if i + j < len(shades):
                    sr, sg, sb = shades[i + j]; pg_color_view = self._create_shades_cell(context, sr, sg, sb, GradientDrawable.RECTANGLE)
                    pg_cell_params = LinearLayout.LayoutParams(CELL_SIZE, CELL_SIZE); pg_cell_params.setMargins(AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4)); pg_row.addView(pg_color_view, pg_cell_params)
            pg_shades_layout.addView(pg_row)
        return pg_shades_layout
        
    def _create_palette_matrix_view(self, activity: Context) -> LinearLayout:
        pg_layout = LinearLayout(activity); pg_layout.setOrientation(LinearLayout.VERTICAL); pg_layout.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16)); pg_layout.setGravity(Gravity.CENTER_HORIZONTAL)
        r, g, b = self.pg_current_r, self.pg_current_g, self.pg_current_b; h, _, _ = color_to_hsv(r, g, b)
        info = TextView(activity); info.setText(f"ÐœÐ°Ñ‚Ñ€Ð¸Ñ†Ð° Ð´Ð»Ñ Hue={int(h * 360)}Â°"); info.setTextColor(self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY)); info.setGravity(Gravity.CENTER_HORIZONTAL); info.setPadding(0, 0, 0, AndroidUtilities.dp(10)); pg_layout.addView(info)
        MATRIX_SIZE, CELL_SIZE = 8, AndroidUtilities.dp(30); matrix = generate_hsv_matrix(r, g, b, size=MATRIX_SIZE)
        matrix_wrapper = LinearLayout(activity); matrix_wrapper.setOrientation(LinearLayout.VERTICAL); matrix_wrapper.setGravity(Gravity.CENTER)
        for row_index in range(MATRIX_SIZE):
            pg_row = LinearLayout(activity); pg_row.setOrientation(LinearLayout.HORIZONTAL); pg_row.setGravity(Gravity.CENTER)
            for col_index in range(MATRIX_SIZE):
                sr, sg, sb = matrix[row_index][col_index]; pg_color_view = self._create_shades_cell(activity, sr, sg, sb, GradientDrawable.RECTANGLE)
                pg_cell_params = LinearLayout.LayoutParams(CELL_SIZE, CELL_SIZE); pg_cell_params.setMargins(AndroidUtilities.dp(2), AndroidUtilities.dp(2), AndroidUtilities.dp(2), AndroidUtilities.dp(2)); pg_row.addView(pg_color_view, pg_cell_params)
            matrix_wrapper.addView(pg_row)
        pg_layout.addView(matrix_wrapper); return pg_layout
        
    def _create_shades_cell(self, context: Context, r: int, g: int, b: int, shape: int) -> View:
        pg_color, pg_cell = Color.rgb(r, g, b), View(context); pg_drawable = GradientDrawable(); pg_drawable.setShape(shape)
        if shape == GradientDrawable.RECTANGLE: pg_drawable.setCornerRadius(AndroidUtilities.dp(6))
        pg_drawable.setColor(pg_color); pg_cell.setBackground(pg_drawable)
        def on_color_selected(view): self.pg_current_r, self.pg_current_g, self.pg_current_b = r, g, b; self._switch_palette_tab(context, self.DIALOG_BASE)
        pg_cell.setOnClickListener(ClickListenerProxy(self, on_color_selected)); return pg_cell
        
    def _create_color_slider(self, context: Any, label: str, track_color: int, initial_value: int) -> LinearLayout:
        container = LinearLayout(context); container.setOrientation(LinearLayout.HORIZONTAL); container.setGravity(Gravity.CENTER_VERTICAL); container.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
        label_view = TextView(context); label_view.setText(f"{label}:"); label_view.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK)); label_view.setTextSize(16); label_view.setPadding(0, 0, AndroidUtilities.dp(8), 0); container.addView(label_view, LinearLayout.LayoutParams(AndroidUtilities.dp(30), -2))
        seek_bar = SeekBar(context); seek_bar.setMax(255); seek_bar.setProgress(initial_value); seek_bar.setTag(label)
        try:
            mode = find_class("android.graphics.PorterDuff$Mode").SRC_IN
            seek_bar.getThumb().setColorFilter(track_color, mode)
            seek_bar.getProgressDrawable().setColorFilter(track_color, mode)
        except Exception as e:
            log(f"Error setting PorterDuff mode: {e}")
            
        value_view = TextView(context); value_view.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK)); value_view.setText(str(initial_value)); value_view.setTag(f"value_{label}"); value_view.setPadding(AndroidUtilities.dp(8), 0, 0, 0)
        
        if label == 'R': self.pg_r_bar = seek_bar
        elif label == 'G': self.pg_g_bar = seek_bar
        elif label == 'B': self.pg_b_bar = seek_bar
        
        container.addView(seek_bar, LinearLayout.LayoutParams(0, -2, 1.0)); container.addView(value_view, LinearLayout.LayoutParams(AndroidUtilities.dp(40), -2)); return container
        
    def _on_color_change(self, component: str, value: int):
        value_view, target_bar = None, None
        if component == 'R': self.pg_current_r = value; target_bar = self.pg_r_bar; tag = "value_R"
        elif component == 'G': self.pg_current_g = value; target_bar = self.pg_g_bar; tag = "value_G"
        elif component == 'B': self.pg_current_b = value; target_bar = self.pg_b_bar; tag = "value_B"
        
        if target_bar and (parent_view := target_bar.getParent()):
            value_view = parent_view.findViewWithTag(tag)

        if value_view: value_view.setText(str(value))
        self._update_color_preview()
    def _update_color_preview(self):
        if not self.pg_preview_view: return
        r, g, b = self.pg_current_r, self.pg_current_g, self.pg_current_b
        new_color, hex_code = Color.rgb(r, g, b), f"#{r:02x}{g:02x}{b:02x}"
        drawable = self.pg_preview_view.getBackground()
        if isinstance(drawable, GradientDrawable): drawable.setColor(new_color)
        else: self.pg_preview_view.setBackgroundColor(new_color)
        text_color = Color.BLACK if (r*0.299 + g*0.587 + b*0.114) > 186 else Color.WHITE
        self.pg_preview_view.setTextColor(text_color); self.pg_preview_view.setText(hex_code.upper())
        
    def _copy_current_color(self, context: Any):
        r, g, b = self.pg_current_r, self.pg_current_g, self.pg_current_b; hex_code = f"#{r:02x}{g:02x}{b:02x}"
        try:
            clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE); clip = ClipData.newPlainText("Color Hex", hex_code); clipboard.setPrimaryClip(clip)
            BulletinHelper.show_copied_to_clipboard(f"Ð¦Ð²ÐµÑ‚ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½: {hex_code.upper()}")
        except Exception as e: log(f"ÐžÑˆÐ¸Ð±ÐºÐ° ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ: {e}"); BulletinHelper.show_error("ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ†Ð²ÐµÑ‚.")
    
    def _create_gui_collapsible_section(self, context: Context, title: str, setting_key: str, children: List[View]) -> View:
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)

        header = LinearLayout(context)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER_VERTICAL)
        header.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))

        title_view = TextView(context)
        title_view.setText(title)
        title_view.setTextSize(16)
        title_view.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        
        arrow_view = TextView(context)
        arrow_view.setTextSize(16)
        arrow_view.setTextColor(self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))

        header.addView(title_view, LinearLayout.LayoutParams(0, -2, 1.0))
        header.addView(arrow_view)
        
        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        for child in children:
            content.addView(child)

        is_expanded = self.get_setting(setting_key, False)
        content.setVisibility(View.VISIBLE if is_expanded else View.GONE)
        arrow_view.setText("â–²" if is_expanded else "â–¼")

        def toggle_collapse(v):
            is_currently_expanded = content.getVisibility() == View.VISIBLE
            new_expanded_state = not is_currently_expanded
            
            self.set_setting(setting_key, new_expanded_state)
            content.setVisibility(View.VISIBLE if new_expanded_state else View.GONE)
            arrow_view.setText("â–²" if new_expanded_state else "â–¼")
            self._perform_haptic(v)

        header.setOnClickListener(ClickListenerProxy(self, toggle_collapse))
        
        container.addView(header)
        container.addView(content)

        return container

    def _create_gui_section_header(self, context: Context, text: str) -> View:
        header = TextView(context)
        header.setText(text.upper())
        header.setTextSize(13)
        header.setTypeface(None, Typeface.BOLD)
        header.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.parseColor("#4299E1"))) 
        header.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
        return header

    def _create_gui_divider(self, context: Context) -> View:
        divider = View(context)
        divider.setBackgroundColor(self._get_color_safe(Theme.key_divider, Color.parseColor("#E0E0E0")))
        params = LinearLayout.LayoutParams(-1, 1)
        params.leftMargin = AndroidUtilities.dp(16)
        params.rightMargin = AndroidUtilities.dp(16)
        divider.setLayoutParams(params)
        return divider
        
    def _create_gui_switch_option(self, context: Context, key: str, text: str, default: bool, on_change: Optional[Callable] = None) -> View:
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.HORIZONTAL)
        container.setGravity(Gravity.CENTER_VERTICAL)
        container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))

        label = TextView(context)
        label.setText(text)
        label.setTextSize(16)
        label.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        container.addView(label, LinearLayout.LayoutParams(0, -2, 1.0))

        switch = AndroidSwitch(context)
        switch.setChecked(self.get_setting(key, default))
        
        def on_checked_change(is_checked: bool):
            self.set_setting(key, is_checked)
            if on_change: on_change(is_checked)
            self._perform_haptic(switch)

        switch.setOnCheckedChangeListener(CheckedChangeListenerProxy(on_checked_change))
        container.addView(switch)
        container.setOnClickListener(ClickListenerProxy(self, lambda v: switch.setChecked(not switch.isChecked())))
        return container

    def _create_gui_slider_option(self, context: Context, key: str, text: str, min_value: int, max_value: int, default: int, step_size: int, on_change: Optional[Callable] = None) -> View:
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))

        label = TextView(context)
        label.setText(text)
        label.setTextSize(16)
        label.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        container.addView(label)

        current_value = self.get_setting(key, default)
        
        value_text = TextView(context)
        value_text.setText(f"{current_value}%")
        value_text.setTextSize(14)
        value_text.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE))
        value_text.setGravity(Gravity.CENTER_HORIZONTAL)
        value_text.setTag(f"{key}_value_text") 
        container.addView(value_text)

        max_progress = (max_value - min_value) // step_size
        current_progress = (current_value - min_value) // step_size
        
        seek_bar = SeekBar(context)
        seek_bar.setMax(max_progress) 
        seek_bar.setProgress(current_progress)
        
        def update_value(sb: SeekBar, actual_value: int):
            self.set_setting(key, actual_value)
            value_text.setText(f"{actual_value}%")
            if on_change: on_change(actual_value)
            
        seek_bar.setOnSeekBarChangeListener(SeekBarChangeListener(update_value, min_value, step_size))
        
        container.addView(seek_bar, LinearLayout.LayoutParams(-1, -2)); return container
        
    def _create_gui_selector_option(self, context: Context, text: str, items: List[str], key: str, default: int, on_change: Optional[Callable] = None) -> View:
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))

        label = TextView(context)
        label.setText(text)
        label.setTextSize(16)
        label.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        container.addView(label)
        
        current_value_index = self.get_setting(key, default)
        
        value_text = TextView(context)
        current_value = items[current_value_index] if 0 <= current_value_index < len(items) else items[0]
        value_text.setText(current_value)
        value_text.setTextSize(14)
        value_text.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE))
        container.addView(value_text)
        
        def on_click(view):
            self._perform_haptic(view)
            builder = AlertDialogBuilder(context)
            builder.set_title(text)
            
            def on_item_selected(dialog, which):
                self.set_setting(key, which)
                value_text.setText(items[which])
                if on_change: on_change(which)
                self.rebuild_settings()
                dialog.dismiss()

            builder.set_items(items, on_item_selected)
            builder.show()

        container.setOnClickListener(ClickListenerProxy(self, on_click))
        return container
        
    def _show_custom_gui_settings(self, activity_context: Optional[Context] = None, start_tab: int = 0):
        activity = activity_context
        if not activity:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        if self._is_dialog_showing(self.gui_settings_dialog):
            self.gui_settings_dialog.dismiss()

        builder = AlertDialogBuilder(activity)
        builder.set_title(Locales.get('settings_main_header'))

        main_layout = LinearLayout(activity)
        main_layout.setOrientation(LinearLayout.VERTICAL)
        
        tabs = [
            Locales.get('display_section'), Locales.get('plugin_settings_section'),
            Locales.get('game_section'), Locales.get('theme_section')
        ]
        tab_bar = self._create_gui_tab_bar(activity, tabs)
        main_layout.addView(tab_bar)
        
        content_container = FrameLayout(activity)
        main_layout.addView(content_container, LinearLayout.LayoutParams(-1, -2))
        
        self.gui_settings_tab_content_frames = {
            0: self._create_gui_display_tab(activity),
            1: self._create_gui_plugin_settings_tab(activity),
            2: self._create_gui_game_tab(activity),
            3: self._create_gui_theme_tab(activity),
        }

        for i, frame in self.gui_settings_tab_content_frames.items():
            content_container.addView(frame)
        
        self.gui_settings_active_tab = start_tab
        self._switch_gui_settings_tab(start_tab)

        builder.set_view(main_layout)
        builder.set_positive_button(Locales.get('done_button'), lambda d, w: self._apply_and_redraw_ui(activity))
        
        self.gui_settings_dialog = builder.create()
        self.gui_settings_dialog.show()

    def _create_gui_tab_bar(self, context: Context, tabs: List[str], force_no_emoji: bool = False) -> LinearLayout:
        tab_bar = LinearLayout(context)
        tab_bar.setOrientation(LinearLayout.HORIZONTAL)
        tab_bar.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        self.gui_settings_tab_buttons.clear()
        is_emoji = self.get_setting("emoji_style_pg", False) and not force_no_emoji

        for i, tab_text in enumerate(tabs):
            button = TextView(context)
            
            display_text = PLUGIN_SETTING_TABS_EMOJI[i] if is_emoji else tab_text
            if is_emoji:
                button.setTextSize(20)
            else:
                button.setTextSize(13)
                
            button.setText(display_text)
            button.setGravity(Gravity.CENTER)
            
            button.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(10), AndroidUtilities.dp(12), AndroidUtilities.dp(10))
            button.setOnClickListener(ClickListenerProxy(self, lambda v, index=i: self._switch_gui_settings_tab(index)))
            
            tab_bar.addView(button, LinearLayout.LayoutParams(0, -1, 1.0))
            self.gui_settings_tab_buttons[i] = button
            
        return tab_bar
        
    def _switch_gui_settings_tab(self, index: int):
        self.gui_settings_active_tab = index
        for i, button in self.gui_settings_tab_buttons.items():
            is_active = (i == index)
            if is_active:
                button.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE))
                button.setTypeface(None, Typeface.BOLD)
            else:
                button.setTextColor(self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))
                button.setTypeface(None, Typeface.NORMAL)

        for i, frame in self.gui_settings_tab_content_frames.items():
            frame.setVisibility(View.VISIBLE if i == index else View.GONE)
            
    def _create_gui_display_tab(self, context: Context) -> View:
        layout = LinearLayout(context); layout.setOrientation(LinearLayout.VERTICAL)
        layout.addView(self._create_gui_section_header(context, Locales.get('display_section')))
        layout.addView(self._create_gui_switch_option(context, "show_in_drawer_pg", Locales.get('show_in_drawer'), True, self._update_menu_visibility))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_switch_option(context, "show_in_chat_action_pg", Locales.get('show_in_chat_action'), True, self._update_menu_visibility))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_switch_option(context, "show_exit_button_pg", Locales.get('show_exit_button'), True))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_switch_option(context, "show_minimize_button_pg", Locales.get('show_minimize_button'), True))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_switch_option(context, "show_settings_button_pg", Locales.get('show_settings_button'), True))
        
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_switch_option(context, "show_cube_drag_border_pg", Locales.get('show_cube_drag_border'), True))
        
        return layout
        
    def _create_gui_plugin_settings_tab(self, context: Context) -> View:
        layout = LinearLayout(context)
        layout.setOrientation(LinearLayout.VERTICAL)

        def on_emoji_style_change(is_checked):
            self.set_setting("emoji_style_pg", is_checked)
            start_tab = self.gui_settings_active_tab
            if self._is_dialog_showing(self.gui_settings_dialog):
                self.gui_settings_dialog.dismiss()
            self._show_custom_gui_settings(context, start_tab=start_tab)

        style_widgets = [
            self._create_gui_switch_option(context, "emoji_style_pg", Locales.get('emoji_style_setting'), False, on_emoji_style_change),
            self._create_gui_divider(context),
            self._create_gui_slider_option(context, "corner_radius_blocks_cells_pg", Locales.get('corner_radius_blocks_cells'), 0, 100, 0, 5, None),
            self._create_gui_divider(context),
            self._create_gui_slider_option(context, "corner_radius_widget_pg", Locales.get('corner_radius_widget'), 0, 100, 0, 5, None),
        ]

        style_collapsible_section = self._create_gui_collapsible_section(
            context,
            Locales.get('style_section'),
            "style_section_expanded_pg",
            style_widgets
        )
        layout.addView(style_collapsible_section)
        layout.addView(self._create_gui_divider(context))

        sliders = [
            self._create_gui_slider_option(
                context, 
                key="cell_size_scale_pg", 
                text=Locales.get('cell_size_scale'), 
                min_value=50, 
                max_value=150, 
                default=85,
                step_size=5,
                on_change=lambda val: None 
            ),
            self._create_gui_divider(context),
            self._create_gui_slider_option(
                context,
                key="restart_button_size_scale_pg",
                text=Locales.get('button_size_scale_restart'),
                min_value=70, max_value=130, default=100, step_size=5, on_change=None
            ),
            self._create_gui_divider(context),
            self._create_gui_slider_option(
                context,
                key="shape_button_size_scale_pg",
                text=Locales.get('button_size_scale_choices'),
                min_value=70, max_value=130, default=100, step_size=5, on_change=None
            ),
            self._create_gui_divider(context),
            self._create_gui_slider_option(
                context,
                key="top_buttons_size_scale_pg",
                text=Locales.get('button_size_scale_top'),
                min_value=70, max_value=130, default=100, step_size=5, on_change=None
            )
        ]

        sizes_collapsible_section = self._create_gui_collapsible_section(
            context,
            Locales.get('sizes_section'),
            "sizes_section_expanded_pg",
            sliders
        )
        layout.addView(sizes_collapsible_section)
        
        return layout
    def _create_gui_game_tab(self, context: Context) -> View:
        layout = LinearLayout(context); layout.setOrientation(LinearLayout.VERTICAL)
        layout.addView(self._create_gui_section_header(context, Locales.get('game_section')))
        layout.addView(self._create_gui_selector_option(context, Locales.get('mode_setting'), [Locales.get('mode_click'), Locales.get('mode_drag'), Locales.get('mode_combined')], "placement_mode_pg", 0, self._update_shape_listeners))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_selector_option(context, Locales.get('restore_setting'), [Locales.get('restore_1_click'), Locales.get('restore_2_click')], "restore_mode_pg", 1))
        layout.addView(self._create_gui_divider(context))
        layout.addView(self._create_gui_selector_option(context, Locales.get('blur_effect_setting'), Locales.get('blur_options'), "blur_effect_strength_pg", 1))
        return layout
        
    def _create_gui_theme_tab(self, context: Context) -> View:
        layout = LinearLayout(context); layout.setOrientation(LinearLayout.VERTICAL)
        layout.addView(self._create_gui_section_header(context, Locales.get('theme_section')))

        theme_names = self._get_all_theme_names()
        layout.addView(self._create_gui_selector_option(context, Locales.get('theme_setting'), theme_names, "game_theme_pg", 0, self._on_theme_changed))
        catalog_btn = Button(context)
        catalog_btn.setText(Locales.get('catalog_button'))
        cat_bg = GradientDrawable(); cat_bg.setCornerRadius(AndroidUtilities.dp(8)); cat_bg.setColor(self._get_color_safe(Theme.key_featuredStickers_addButton, Color.BLUE))
        catalog_btn.setBackground(cat_bg)
        catalog_btn.setTextColor(self._get_color_safe(Theme.key_featuredStickers_buttonText, Color.WHITE))
        catalog_btn.setOnClickListener(ClickListenerProxy(self, lambda v: self._show_catalog_dialog(context)))
        catalog_params = FrameLayout.LayoutParams(-1, AndroidUtilities.dp(48))
        catalog_btn.setLayoutParams(catalog_params)
        
        cat_container = FrameLayout(context)
        cat_container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))
        cat_container.addView(catalog_btn)
        layout.addView(cat_container)

        layout.addView(self._create_gui_divider(context))

        edit_container = FrameLayout(context)
        edit_container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(12), AndroidUtilities.dp(16), AndroidUtilities.dp(12))

        self.gui_settings_custom_theme_button = Button(context)
        self.gui_settings_custom_theme_button.setText(Locales.get('theme_preview_title'))
        btn_bg = GradientDrawable(); btn_bg.setCornerRadius(AndroidUtilities.dp(8)); btn_bg.setColor(self._get_color_safe(Theme.key_featuredStickers_addButton, Color.BLUE))
        self.gui_settings_custom_theme_button.setBackground(btn_bg)
        self.gui_settings_custom_theme_button.setTextColor(self._get_color_safe(Theme.key_featuredStickers_buttonText, Color.WHITE))
        
        def on_custom_theme_action(v):
            current = self._get_current_theme_name()
            custom = self._load_custom_themes()
            if current in custom:
                tag = custom[current].get('_tag', 'custom')
                if tag == 'custom':
                    self._show_gui_custom_theme_editor(context)
                else:
                    self._show_theme_preview_dialog(context, current, custom[current], mode="local")
        
        self.gui_settings_custom_theme_button.setOnClickListener(ClickListenerProxy(self, on_custom_theme_action))
        
        edit_params = FrameLayout.LayoutParams(-1, AndroidUtilities.dp(48))
        self.gui_settings_custom_theme_button.setLayoutParams(edit_params)
        edit_container.addView(self.gui_settings_custom_theme_button)

        layout.addView(edit_container)

        self._update_custom_theme_button_visibility()
        return layout

    def _update_custom_theme_button_visibility(self):
        if not self.gui_settings_custom_theme_button: return
        current_theme_name = self._get_current_theme_name()
        custom_themes = self._load_custom_themes()
        is_custom = current_theme_name in custom_themes
        
        if is_custom:
            self.gui_settings_custom_theme_button.setVisibility(View.VISIBLE)
            tag = custom_themes[current_theme_name].get('_tag', 'custom')
            if tag == 'custom':
                self.gui_settings_custom_theme_button.setText(Locales.get('custom_theme_edit_button')) # Edit
            else:
                self.gui_settings_custom_theme_button.setText(Locales.get('theme_preview_title')) # Preview
        else:
            self.gui_settings_custom_theme_button.setVisibility(View.GONE)
            
    def _show_gui_custom_theme_editor(self, context: Context):
        if self._is_dialog_showing(self.gui_custom_theme_dialog): return

        current_theme_name = self._get_current_theme_name()
        if current_theme_name in PG_THEMES:
            BulletinHelper.show_error("Cannot edit a built-in theme.")
            return

        custom_themes = self._load_custom_themes()
        theme_colors = custom_themes.get(current_theme_name, {})
        for key, color in theme_colors.items():
            self.set_setting(f"custom_color_{key}", color)
        builder = AlertDialogBuilder(context)

        # builder.set_title removed for custom title view
        
        main_layout = LinearLayout(context); main_layout.setOrientation(LinearLayout.VERTICAL)
        
        # --- Custom Title with Rename ---
        title_layout = LinearLayout(context); title_layout.setOrientation(LinearLayout.HORIZONTAL); title_layout.setGravity(Gravity.CENTER_VERTICAL)
        title_layout.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(20), AndroidUtilities.dp(24), AndroidUtilities.dp(10))
        
        title_tv = TextView(context)
        title_tv.setText(f"{Locales.get('custom_theme_edit_button')}: {current_theme_name}")
        title_tv.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        title_tv.setTextSize(20)
        title_tv.setTypeface(None, Typeface.BOLD)
        
        def on_rename_click(v):
            name_edit_layout = FrameLayout(context)
            name_input = EditText(context)
            name_input.setText(current_theme_name)
            name_input.setTextColor(Color.WHITE)
            name_edit_layout.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(10), AndroidUtilities.dp(24), AndroidUtilities.dp(10))
            name_edit_layout.addView(name_input)
            
            def on_rename_confirm(d, w):
                new_name = name_input.getText().toString().strip()
                if not (2 <= len(new_name) <= 20):
                    BulletinHelper.show_error("Invalid name length", get_last_fragment())
                    return
                
                all_themes = self._load_custom_themes()
                if new_name in all_themes and new_name != current_theme_name:
                    BulletinHelper.show_error("Name already exists", get_last_fragment())
                    return
                
                theme_data = all_themes.pop(current_theme_name)
                all_themes[new_name] = theme_data
                self._save_custom_themes(all_themes)
                
                all_names = self._get_all_theme_names()
                if new_name in all_names:
                    new_idx = all_names.index(new_name)
                    self.set_setting("game_theme_pg", new_idx)
                
                d.dismiss()
                self.gui_custom_theme_dialog.dismiss()
                self._show_custom_gui_settings(context, start_tab=3)
                
            AlertDialogBuilder(context).set_title("Rename Theme").set_view(name_edit_layout).set_positive_button("Save", on_rename_confirm).set_negative_button("Cancel", None).show()

        title_tv.setOnClickListener(ClickListenerProxy(self, on_rename_click))
        title_layout.addView(title_tv)
        main_layout.addView(title_layout)
        # ------------------------------
        
        tabs_names = [
            Locales.get('custom_theme_tab_window'), Locales.get('custom_theme_tab_blocks'),
            Locales.get('custom_theme_tab_effects'), Locales.get('custom_theme_tab_widget')
        ]
        color_keys_by_tab = {
            0: ["grid_bg", "cell_empty", "score_text", "high_score_text", "button_bg", "button_text"],
            1: ["cell_block_1", "cell_block_2", "cell_block_3", "cell_block_4", "selected_shape_border", "placeholder_shape_bg"],
            2: ["cell_error", "error_cross", "cell_preview", "cell_clear", "cell_restart", "game_over"],
            3: ["cube_bg", "cube_border"]
        }
        
        active_tab_index = [0]
        
        tab_bar = self._create_gui_color_editor_tab_bar(context, tabs_names)
        main_layout.addView(tab_bar)
        
        scroll_view = ScrollView(context)
        content_layout = LinearLayout(context); content_layout.setOrientation(LinearLayout.VERTICAL)
        scroll_view.addView(content_layout)
        main_layout.addView(scroll_view)

        def redraw_content(tab_index: int):
            content_layout.removeAllViews()
            self.gui_custom_theme_color_rows.clear()
            color_keys = color_keys_by_tab.get(tab_index, [])
            
            for key in color_keys:
                row, row_data = self._create_gui_color_picker_row(context, key, parent_dialog_callback=self._show_gui_custom_theme_editor)
                content_layout.addView(row)
                content_layout.addView(self._create_gui_divider(context))
                self.gui_custom_theme_color_rows[f"custom_color_{key}"] = row_data

        def switch_tab_and_redraw(index: int):
            active_tab_index[0] = index
            for i, button in self.gui_settings_tab_buttons.items():
                is_active = (i == index)
                button.setTextColor(self._get_color_safe(Theme.key_dialogTextBlue2, Color.BLUE) if is_active else self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))
                button.setTypeface(None, Typeface.BOLD if is_active else Typeface.NORMAL)
            redraw_content(index)
        for i, button in self.gui_settings_tab_buttons.items():
            button.setOnClickListener(ClickListenerProxy(self, lambda v, index=i: switch_tab_and_redraw(index)))
        switch_tab_and_redraw(0)
        
        builder.set_view(main_layout)

        def on_done_save(dialog, which):
            all_themes = self._load_custom_themes()
            current_theme = all_themes.get(current_theme_name, {})
            for key_group in color_keys_by_tab.values():
                for key in key_group:
                    current_theme[key] = self.get_setting(f"custom_color_{key}", PG_THEMES["Dark (Default)"].get(key))
            all_themes[current_theme_name] = current_theme
            self._save_custom_themes(all_themes)
            dialog.dismiss()
            # self._apply_and_redraw_ui() # Removed animation by request

        def on_delete_theme(dialog, which):
            def confirm_delete():
                all_themes = self._load_custom_themes()
                if current_theme_name in all_themes:
                    del all_themes[current_theme_name]
                    self._save_custom_themes(all_themes)
                self.set_setting("game_theme_pg", 0) # Revert to default
                self.gui_custom_theme_dialog.dismiss()
                self._show_custom_gui_settings(context, start_tab=3) # Refresh main settings
            
            AlertDialogBuilder(context) \
                .set_title(Locales.get('theme_delete_confirm_title')) \
                .set_message(Locales.get('theme_delete_confirm_text', theme_name=current_theme_name)) \
                .set_positive_button("OK", lambda d, w: confirm_delete()) \
                .set_negative_button(Locales.get('theme_cancel_button'), None) \
                .show()
        builder.set_neutral_button(Locales.get('share_theme_button'), lambda d, w: self._share_custom_theme(context, current_theme_name))

        builder.set_positive_button(Locales.get('done_button'), on_done_save)
        builder.set_negative_button(Locales.get('theme_delete_button'), on_delete_theme)
        
        self.gui_custom_theme_dialog = builder.create()
        self.gui_custom_theme_dialog.show()

    def _create_gui_color_editor_tab_bar(self, context: Context, tabs: List[str]) -> LinearLayout:
        tab_bar = LinearLayout(context)
        tab_bar.setOrientation(LinearLayout.HORIZONTAL)
        tab_bar.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        
        self.gui_settings_tab_buttons.clear() 

        is_emoji = self.get_setting("emoji_style_pg", False)

        for i, tab_text in enumerate(tabs):
            button = TextView(context)
            
            display_text = CUSTOM_THEME_TABS_EMOJI[i] if is_emoji else tab_text
            if is_emoji:
                button.setTextSize(20)
            else:
                button.setTextSize(13)
                
            button.setText(display_text)
            button.setGravity(Gravity.CENTER)
            
            button.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(10), AndroidUtilities.dp(12), AndroidUtilities.dp(10))
            
            tab_bar.addView(button, LinearLayout.LayoutParams(0, -1, 1.0))
            self.gui_settings_tab_buttons[i] = button
            
        return tab_bar

    def _create_gui_color_picker_row(self, context, key: str, parent_dialog_callback: Callable) -> Tuple[View, Dict]:
        setting_key = f"custom_color_{key}"
        default_color = PG_THEMES["Dark (Default)"].get(key, "#FFFFFF")
        current_color = self.get_setting(setting_key, default_color)
        
        locale_key = f'color_{key}'
        label_text = Locales.get(locale_key, default=key.replace('_', ' ').title())
        emoji = EMOJI_MAP.get(key, "ðŸŽ¨")
        
        row = LinearLayout(context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER_VERTICAL)
        row.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(10), AndroidUtilities.dp(16), AndroidUtilities.dp(10))
        

        color_preview = View(context)
        bg = GradientDrawable()
        bg.setShape(GradientDrawable.OVAL)
        bg.setColor(Color.parseColor(current_color))
        bg.setStroke(AndroidUtilities.dp(1), Color.GRAY)
        color_preview.setBackground(bg)
        
        def on_color_click(v):
            if key == "grid_bg": 
                grad_state = self._get_custom_gradient_state()
                if grad_state['is_gradient']:
                    self._save_custom_gradient_state({'is_gradient': False, 'point_1_id': -1, 'point_2_id': -1})
                    parent_dialog_callback(context) 
                    return
            self._handle_open_color_palette(target_key=setting_key)
        
        color_preview.setOnClickListener(ClickListenerProxy(self, on_color_click))
        row.addView(color_preview, LinearLayout.LayoutParams(AndroidUtilities.dp(28), AndroidUtilities.dp(28)))

        text_label = TextView(context)
        text_label.setText(f"{emoji} {label_text} ({current_color.upper()})")
        text_label.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
        text_label.setTextSize(16)
        text_params = LinearLayout.LayoutParams(0, -2, 1.0); text_params.leftMargin = AndroidUtilities.dp(16)
        row.addView(text_label, text_params)

        row_data = {'row_view': row, 'color_preview_view': color_preview, 'text_label_view': text_label}
        

        return row, row_data



    def _show_gradient_editor(self, context: Context):
        if self._is_dialog_showing(self.GRADIENT_EDITOR_DIALOG): return

        builder = AlertDialogBuilder(context)
        builder.set_title(Locales.get('gradient_editor_title'))
        

        grad_data = self._get_custom_gradient_state()
        self.grad_state.update({
            'point_1_id': grad_data['point_1_id'],
            'point_2_id': grad_data['point_2_id'],
            'color_1_hex': grad_data['color_1_hex'],
            'color_2_hex': grad_data['color_2_hex'],
        })

        main_layout = LinearLayout(context); main_layout.setOrientation(LinearLayout.VERTICAL); main_layout.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16))
        

        grid_container = self._create_gradient_point_selector(context)
        main_layout.addView(grid_container)
        

        preview_frame = FrameLayout(context)
        preview_frame.setLayoutParams(LinearLayout.LayoutParams(-1, AndroidUtilities.dp(80)))
        preview_frame.setPadding(0, AndroidUtilities.dp(16), 0, 0)
        
        self.GRADIENT_PREVIEW_VIEW = View(context)
        self.GRADIENT_PREVIEW_VIEW.setLayoutParams(FrameLayout.LayoutParams(-1, -1))
        self.GRADIENT_PREVIEW_VIEW.setBackground(self._create_gradient_drawable(self.grad_state))
        preview_frame.addView(self.GRADIENT_PREVIEW_VIEW)
        main_layout.addView(preview_frame)
        

        color_buttons_container = self._create_gradient_color_buttons(context)
        main_layout.addView(color_buttons_container)
        

        reset_button = Button(context)
        reset_button.setText(Locales.get('point_selector_reset'))
        reset_button.setTextColor(Color.WHITE)
        reset_button.setBackgroundColor(Color.parseColor("#D32F2F"))
        
        def on_reset_click(v):
            self._reset_gradient_state(context)
            
        reset_button.setOnClickListener(ClickListenerProxy(self, on_reset_click))
        params_reset = LinearLayout.LayoutParams(-1, AndroidUtilities.dp(40)); params_reset.topMargin = AndroidUtilities.dp(16)
        main_layout.addView(reset_button, params_reset)

        builder.set_view(main_layout)
        
        def on_editor_done(dialog, which):

            grad_to_save = {
                'is_gradient': self.grad_state['point_1_id'] != -1 and self.grad_state['point_2_id'] != -1,
                'point_1_id': self.grad_state['point_1_id'],
                'point_2_id': self.grad_state['point_2_id'],
                'color_1_hex': self.grad_state['color_1_hex'],
                'color_2_hex': self.grad_state['color_2_hex'],
            }
            self._save_custom_gradient_state(grad_to_save)
            dialog.dismiss()
            self._show_gui_custom_theme_editor(context)

        builder.set_positive_button(Locales.get('done_button'), on_editor_done)
        
        self.GRADIENT_EDITOR_DIALOG = builder.create()
        self.grad_state['gradient_dialog'] = self.GRADIENT_EDITOR_DIALOG 
        self.GRADIENT_EDITOR_DIALOG.show()
        
    def _create_gradient_drawable(self, state: Dict[str, Any]):
        """Ð¡Ð¾Ð·Ð´Ð°ÐµÑ‚ GradientDrawable Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ."""
        grad_drawable = GradientDrawable()
        grad_drawable.setCornerRadius(AndroidUtilities.dp(12))
        
        if state['point_1_id'] != -1 and state['point_2_id'] != -1:
            color1 = Color.parseColor(state['color_1_hex'])
            color2 = Color.parseColor(state['color_2_hex'])
            orientation = get_gradient_orientation(state['point_1_id'], state['point_2_id'])

            colors_jarray = jarray(jint)([color1, color2])
            grad_drawable = GradientDrawable(orientation, colors_jarray)
            grad_drawable.setCornerRadius(AndroidUtilities.dp(12))
        else:

            grad_drawable.setColor(Color.parseColor(self._get_themed_color("grid_bg")))
            
        return grad_drawable

    def _create_gradient_point_selector(self, context: Context) -> LinearLayout:
        
        main_layout = LinearLayout(context); main_layout.setOrientation(LinearLayout.VERTICAL); main_layout.setGravity(Gravity.CENTER)
        
        info_text = TextView(context)
        info_text.setText(Locales.get('point_select_tooltip'))
        info_text.setTextColor(self._get_color_safe(Theme.key_dialogTextGray, Color.GRAY))
        info_text.setGravity(Gravity.CENTER_HORIZONTAL)
        main_layout.addView(info_text)

        grid_layout = LinearLayout(context); grid_layout.setOrientation(LinearLayout.VERTICAL)
        grid_layout.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        
        self.GRADIENT_POINT_BUTTONS.clear()
        
        cell_size = AndroidUtilities.dp(40)
        
        for r in range(3):
            row = LinearLayout(context); row.setOrientation(LinearLayout.HORIZONTAL); row.setGravity(Gravity.CENTER)
            for c in range(3):
                point_id = r * 3 + c
                point_button = View(context)
                point_button.setTag(point_id)
                
                params = LinearLayout.LayoutParams(cell_size, cell_size); params.setMargins(AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4))
                point_button.setLayoutParams(params)
                
                def on_point_click(v, pid=point_id): self._on_gradient_point_selected(context, pid)

                point_button.setOnClickListener(ClickListenerProxy(self, on_point_click))
                row.addView(point_button)
                self.GRADIENT_POINT_BUTTONS[point_id] = point_button
            grid_layout.addView(row)
        
        main_layout.addView(grid_layout)
        self._update_gradient_point_ui()
        return main_layout

    def _create_gradient_color_buttons(self, context: Context) -> LinearLayout:
        container = LinearLayout(context); container.setOrientation(LinearLayout.VERTICAL); container.setPadding(0, AndroidUtilities.dp(16), 0, 0)
        
        self.GRADIENT_COLOR_BUTTONS.clear()
        
        for i in range(1, 3):
            color_hex = self.grad_state[f'color_{i}_hex']
            
            row = LinearLayout(context); row.setOrientation(LinearLayout.HORIZONTAL); row.setGravity(Gravity.CENTER_VERTICAL); row.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
            
            label = TextView(context); label.setText(Locales.get(f'point_select_{i}')); label.setTextSize(16); label.setTextColor(self._get_color_safe(Theme.key_dialogTextBlack, Color.BLACK))
            row.addView(label, LinearLayout.LayoutParams(0, -2, 1.0))
            
            color_button = Button(context)
            color_button.setText(f"{Locales.get('point_set_color', num=i)} ({color_hex.upper()})")
            color_button.setTextColor(Color.BLACK if (int(color_hex[1:3], 16)*0.299 + int(color_hex[3:5], 16)*0.587 + int(color_hex[5:], 16)*0.114) > 186 else Color.WHITE)
            
            color_button.setBackgroundColor(Color.parseColor(color_hex))
            
            def on_color_set_click(v, index=i):

                self.grad_state['gradient_dialog'] = self.GRADIENT_EDITOR_DIALOG 
                self._handle_open_color_palette(target_key=f"grad_color_{index}_pg")
            
            color_button.setOnClickListener(ClickListenerProxy(self, on_color_set_click))
            
            btn_params = LinearLayout.LayoutParams(-2, AndroidUtilities.dp(40)); btn_params.leftMargin = AndroidUtilities.dp(8)
            row.addView(color_button, btn_params)
            self.GRADIENT_COLOR_BUTTONS[i] = color_button
            container.addView(row)
        
        return container
        
    def _on_gradient_point_selected(self, context: Context, point_id: int):
        
        if self.grad_state['point_1_id'] == point_id:
            self.grad_state['point_1_id'] = -1
        elif self.grad_state['point_2_id'] == point_id:
            self.grad_state['point_2_id'] = -1
        elif self.grad_state['point_1_id'] == -1:
            self.grad_state['point_1_id'] = point_id
        elif self.grad_state['point_2_id'] == -1:
            self.grad_state['point_2_id'] = point_id
        
        self._update_gradient_editor_ui(context)

    def _update_gradient_editor_ui(self, context: Context):
        if self.GRADIENT_EDITOR_DIALOG is None: return
        

        self._update_gradient_point_ui()
        

        for i in range(1, 3):
            btn = self.GRADIENT_COLOR_BUTTONS.get(i)
            if btn:
                color_hex = self.grad_state[f'color_{i}_hex']
                btn.setText(f"{Locales.get('point_set_color', num=i)} ({color_hex.upper()})")
                btn.setBackgroundColor(Color.parseColor(color_hex))
                

        if self.GRADIENT_PREVIEW_VIEW:
            self.GRADIENT_PREVIEW_VIEW.setBackground(self._create_gradient_drawable(self.grad_state))


    def _update_gradient_point_ui(self):
        for point_id, button in self.GRADIENT_POINT_BUTTONS.items():
            is_p1 = self.grad_state['point_1_id'] == point_id
            is_p2 = self.grad_state['point_2_id'] == point_id
            
            bg = GradientDrawable()
            bg.setShape(GradientDrawable.OVAL)
            
            if is_p1 and is_p2: 
                 bg.setColor(Color.RED)
            elif is_p1:
                 bg.setColor(Color.parseColor(self.grad_state['color_1_hex']))
                 bg.setStroke(AndroidUtilities.dp(2), Color.WHITE)
            elif is_p2:
                 bg.setColor(Color.parseColor(self.grad_state['color_2_hex']))
                 bg.setStroke(AndroidUtilities.dp(2), Color.WHITE)
            else:

                 bg.setColor(Color.parseColor("#424242")) 
            
            button.setBackground(bg)
            
    def _reset_gradient_state(self, context: Context):
        self.grad_state.update({
            'point_1_id': -1,
            'point_2_id': -1,
            'color_1_hex': "#000000",
            'color_2_hex': "#FFFFFF",
        })
        self._save_custom_gradient_state({'is_gradient': False, 'point_1_id': -1, 'point_2_id': -1})
        self._update_gradient_editor_ui(context)
        BulletinHelper.show_info("Ð“Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚ ÑÐ±Ñ€Ð¾ÑˆÐµÐ½!", get_last_fragment())



    def _show_blur_overlay(self, dialog_instance: AlertDialog, emoji: str, duration: int):
        blur_strength_index = self.get_setting("blur_effect_strength_pg", 1)
        if blur_strength_index == 0 or not dialog_instance or not dialog_instance.get_dialog() or not dialog_instance.get_dialog().isShowing(): return

        dialog = dialog_instance.get_dialog()
        content_view_for_blur = dialog.getWindow().getDecorView().findViewById(android_R_id_content) or dialog.getWindow().getDecorView()
        if not content_view_for_blur or not isinstance(content_view_for_blur, ViewGroup): return

        alpha_map = [0, 64, 128, 192, 240]
        alpha = alpha_map[blur_strength_index]
        overlay_layout = FrameLayout(dialog.getContext())
        overlay_layout.setBackgroundColor(Color.argb(alpha, 0, 0, 0))

        emoji_view = TextView(dialog.getContext())
        emoji_view.setText(emoji); emoji_view.setTextSize(150)
        emoji_view.setTextColor(Color.WHITE); emoji_view.setGravity(Gravity.CENTER)
        
        overlay_layout.addView(emoji_view, FrameLayout.LayoutParams(-1, -1))
        content_view_for_blur.addView(overlay_layout, FrameLayout.LayoutParams(-1, -1))

        if emoji == "ðŸ’”": self._animate_heartbeat(emoji_view, duration)
        elif emoji == "â™»ï¸": self._animate_shake(emoji_view, duration)

        overlay_layout.setAlpha(0.0)
        
        def remover():
            if overlay_layout.getParent():
                overlay_layout.animate().alpha(0.0).setDuration(200).withEndAction(RunnableProxy(lambda: content_view_for_blur.removeView(overlay_layout))).start()
        
        overlay_layout.animate().alpha(1.0).setDuration(200).start()
        
        run_on_ui_thread(remover, delay=duration)

    def _show_spinning_gear_overlay(self, activity: Context, emoji: str, duration: int, on_done: Callable):
        if not hasattr(activity, 'getWindow'):
            log(f"[{__name__}] Context is not a direct Activity. Attempting fallback to LaunchActivity.instance.")
            if LaunchActivity.instance:
                 activity = LaunchActivity.instance
            else:
                 log(f"[{__name__}] Fallback failed. Cannot run blur animation.")
                 if callable(on_done): on_done()
                 return

        def _show_on_ui_thread():
            blur_strength_index = self.get_setting("blur_effect_strength_pg", 1)
            if blur_strength_index == 0:
                if callable(on_done): run_on_ui_thread(on_done)
                return

            alpha_map = [0, 64, 128, 192, 240]
            alpha = alpha_map[blur_strength_index]
            
            root_view = activity.getWindow().getDecorView()
            if not root_view or not isinstance(root_view, ViewGroup): 
                if callable(on_done): on_done()
                return

            self.full_screen_blur_overlay = FrameLayout(activity)
            self.full_screen_blur_overlay.setBackgroundColor(Color.argb(alpha, 0, 0, 0))
            self.full_screen_blur_overlay.setClickable(True)
            
            emoji_view = TextView(activity)
            emoji_view.setText(emoji); emoji_view.setTextSize(100)
            emoji_view.setTextColor(Color.WHITE); emoji_view.setGravity(Gravity.CENTER)
            
            self.full_screen_blur_overlay.addView(emoji_view, FrameLayout.LayoutParams(-1, -1))
            root_view.addView(self.full_screen_blur_overlay, FrameLayout.LayoutParams(-1, -1))
            
            self.full_screen_blur_overlay.setAlpha(0.0)
            self.full_screen_blur_overlay.animate().alpha(1.0).setDuration(200).start()
            
            total_spin_duration = duration + 250
            total_rotations = 360 * (total_spin_duration / 1000.0)
            emoji_view.animate().rotation(total_rotations).setDuration(total_spin_duration).setInterpolator(LinearInterpolator()).start()
            
            handler = Handler(Looper.getMainLooper())
            handler.postDelayed(RunnableProxy(lambda: _remove_gear_and_continue(emoji_view, handler)), duration + 50)
            
        def _remove_gear_and_continue(gear_view: View, handler: Handler):
            overlay_to_animate_out = self.full_screen_blur_overlay
            if overlay_to_animate_out is None or not overlay_to_animate_out.getParent():
                if callable(on_done): on_done()
                return

            self.full_screen_blur_overlay = None

            try:
                def final_action():
                    if overlay_to_animate_out.getParent():
                        parent = overlay_to_animate_out.getParent()
                        if isinstance(parent, ViewGroup):
                            parent.removeView(overlay_to_animate_out)
                    if callable(on_done):
                        on_done()

                overlay_to_animate_out.animate().alpha(0.0).setDuration(200).withEndAction(RunnableProxy(final_action)).start()
            except Exception as e:
                log(f"[ACW] Error removing gear overlay: {e}")
                if overlay_to_animate_out.getParent():
                    try:
                        parent = overlay_to_animate_out.getParent()
                        if isinstance(parent, ViewGroup):
                            parent.removeView(overlay_to_animate_out)
                    except: pass
                if callable(on_done): on_done()
        run_on_ui_thread(_show_on_ui_thread)

    def _animate_heartbeat(self, view: View, total_duration: int):
        handler = Handler(Looper.getMainLooper())
        start_time = time.time() * 1000

        def beat():
            elapsed = (time.time() * 1000) - start_time
            if elapsed > total_duration or not view or not view.getParent(): return
            
            view.animate().scaleX(1.1).scaleY(1.1).setDuration(150).withEndAction(RunnableProxy(
                lambda: view.animate().scaleX(1.0).scaleY(1.0).setDuration(300).start()
            )).start()
            handler.postDelayed(RunnableProxy(beat), 800)
        run_on_ui_thread(beat)

    def _animate_shake(self, view: View, total_duration: int):
        handler = Handler(Looper.getMainLooper())
        start_time = time.time() * 1000

        def shake():
            elapsed = (time.time() * 1000) - start_time
            if elapsed > total_duration or not view or not view.getParent(): return

            view.animate().translationX(-10).setDuration(50).withEndAction(RunnableProxy(
                lambda: view.animate().translationX(10).setDuration(50).withEndAction(RunnableProxy(
                    lambda: view.animate().translationX(0).setDuration(50).start()
                )).start()
            )).start()
            handler.postDelayed(RunnableProxy(shake), 400)
        run_on_ui_thread(shake)

    def _start_new_theme_creation_flow(self, context: Context):
        all_custom_themes = self._load_custom_themes()
        
        name_input_layout = FrameLayout(context)
        name_input = EditText(context)
        name_input.setHint(Locales.get('theme_create_name_prompt'))
        name_input_layout.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(10), AndroidUtilities.dp(20), AndroidUtilities.dp(10))
        name_input_layout.addView(name_input)

        def on_create_clicked(dialog, which):
            theme_name = name_input.getText().toString().strip()
            if not (2 <= len(theme_name) <= 20):
                BulletinHelper.show_error("Ð˜Ð¼Ñ Ð´Ð¾Ð»Ð¶Ð½Ð¾ ÑÐ¾Ð´ÐµÑ€Ð¶Ð°Ñ‚ÑŒ Ð¾Ñ‚ 2 Ð´Ð¾ 20 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð².")
                self._start_new_theme_creation_flow(context)
                return
            if theme_name in PG_THEMES or theme_name in all_custom_themes:
                BulletinHelper.show_error("Ð¢ÐµÐ¼Ð° Ñ Ñ‚Ð°ÐºÐ¸Ð¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚.")
                self._start_new_theme_creation_flow(context)
                return
            
            dialog.dismiss()
            self._select_preset_for_new_theme(context, theme_name)

        AlertDialogBuilder(context) \
            .set_title(Locales.get('theme_create_new_title')) \
            .set_view(name_input_layout) \
            .set_positive_button(Locales.get('theme_create_button'), on_create_clicked) \
            .set_negative_button(Locales.get('theme_cancel_button'), lambda d, w: self.rebuild_settings()) \
            .show()

    def _select_preset_for_new_theme(self, context: Context, new_theme_name: str):
        preset_names = list(PG_THEMES.keys())
        if "Custom" in preset_names: preset_names.remove("Custom")

        all_themes = self._load_custom_themes()
        def on_preset_selected(dialog, which):
            preset_name = preset_names[which]
            preset_colors = PG_THEMES[preset_name]

            all_themes[new_theme_name] = preset_colors.copy()
            all_themes[new_theme_name]['_tag'] = 'custom'
            self._save_custom_themes(all_themes)

            # Find index of new theme and set it as active
            new_theme_list = self._get_all_theme_names()
            if new_theme_name in new_theme_list:
                new_index = new_theme_list.index(new_theme_name)
                self.set_setting("game_theme_pg", new_index)
            
            dialog.dismiss()
            if self._is_dialog_showing(self.gui_settings_dialog):
                self.gui_settings_dialog.dismiss()
            self._show_custom_gui_settings(context, start_tab=3)
            BulletinHelper.show_success(f"Ð¢ÐµÐ¼Ð° '{new_theme_name}' ÑÐ¾Ð·Ð´Ð°Ð½Ð°!")

        AlertDialogBuilder(context) \
            .set_title(Locales.get('theme_create_preset_prompt')) \
            .set_items(preset_names, on_preset_selected) \
            .set_negative_button(Locales.get('theme_cancel_button'), lambda d, w: self.rebuild_settings()) \
            .show()



users = [
    "69231c4709df4a492324552c",
    "6923b71c3ad095fb847145d4",
    "6927330326e7e41498fd6e21",
    "6927356526e7e41498fd7744",
    "6927359d26e7e41498fd7820",
    "6927b3bcb35b4ffc5012c466",
    "6927b486b35b4ffc5012c6f1",
    "6927b4b2b35b4ffc5012c7f7",
    "6927b4e0b35b4ffc5012c962",
    "6927b684b35b4ffc5012cf42"
]

themes = [
    "6922544e09df4a492322329d"
]
#Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¾ Ñ Ð»ÑŽÐ±Ð¾Ð²ÑŒÑŽ Ðº ÐºÐ¾Ñ‚Ð¸ÐºÐ°Ð¼ >^ w ^<