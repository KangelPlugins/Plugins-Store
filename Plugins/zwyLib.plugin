"""
Если вы при разработке своего плагина использовали готовые фрагменты кода из моего, пожалуйста,
укажите в описании своего плагина @zwylair в качестве благодарности за вклад в разработку. Спасибо ♥

If you used code snippets from my plugin in the development of your own, please credit @zwylair
in your plugin’s description as a thank you for the contribution. Thanks ♥


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⣀⣠⣤⣤⣤⣄⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠿⠛⠛⠛⠛⠛⢿⣷⣤⣾⠿⠛⠛⠙⠛⠛⠿⠗
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡿⠁⠀⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⠀⢀⣤⣀⠀⠀⢀⣤⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣧⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠀⣿⣷⣄⣀⣤⡄⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣁⣤⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠘⠛⠛⠛⠻⣿⣿⣿⠋⠉⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠹⣿⡟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠟⢙⠛⠛⠀⠀⠀⠀⠀⠀⣀⣴⡿⠓⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠈⠻⢿⣦⣄⠀⣠⣾⡿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀
"""
import copy
import time
import json
import zlib
import shlex
import inspect
import logging
import os.path
import threading
import traceback

from packaging.version import Version
from dataclasses import dataclass, field
from typing import List, Callable, Optional, Any, Union, Dict, Tuple, Type
from typing_extensions import get_origin, get_args, deprecated, overload

import markdown_utils
from ui.bulletin import BulletinHelper as _BulletinHelper
from ui.settings import Header, Switch, Input, Text
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log as _log, run_on_ui_thread
from client_utils import get_messages_controller, get_file_loader, get_last_fragment, get_messages_storage, \
    run_on_queue, send_request

from java import cast, dynamic_proxy, jint
from java.util import Locale, ArrayList
from java.lang import Long, Integer
from org.telegram.tgnet import TLRPC
from org.telegram.ui import ChatActivity
from org.telegram.messenger import FileLoader, R, Utilities, AndroidUtilities
from com.exteragram.messenger.plugins import PluginsController, Plugin

__name__ = "ZwyLib"
__description__ = "Zwylair's library with highly used things.\nDocumentation: https://zwylib-docs.vercel.app/"
__icon__ = "zwyPluginsIcons/0"
__id__ = "zwylib"
__version__ = "1.2.3"
__author__ = "@zwylair"
__min_version__ = "11.12.1"


class SingletonMeta(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Callback1(dynamic_proxy(Utilities.Callback)):
    def __init__(self, fn: Callable[[Any], None]):
        super().__init__()
        self._fn = fn

    def run(self, arg):
        try:
            self._fn(arg)
        except:
            logger.error(f"Error in Callback1: {format_exc()}.")


class CacheFile:
    def __init__(self, filename: str, read_on_init=True, compress=False):
        self.filename = filename
        self.path = os.path.join(CACHE_DIRECTORY, filename)
        self._content: Optional[bytes] = None
        self.compress = compress
        self.logger = build_log(f"{__name__} {self.filename}")

        os.makedirs(CACHE_DIRECTORY, exist_ok=True)

        if read_on_init:
            self.read()

    def read(self):
        if not os.path.exists(self.path):
            self.logger.error(f"{self.path} does not exist, setting None value.")
            self._content = None
            return

        try:
            with open(self.path, "rb") as file:
                file_content = file.read()

            if self.compress and file_content.startswith(b"\x78\x9c"):  # zlib compressed data starts with these bytes
                file_content = zlib.decompress(file_content)
            self._content = file_content
        except Exception as e:
            self.logger.error(f"Failed to load data from {self.path}: {format_exc_only(e)}. Setting None value.")
            self._content = None

    def write(self):
        try:
            save_data = self._content
            if self.compress:
                save_data = zlib.compress(save_data, level=6)

            with open(self.path, "wb") as file:
                file.write(save_data)
        except PermissionError as e:
            self.logger.error(f"Have no permissions to edit {self.path}: {format_exc_only(e)}.")

    def wipe(self):
        self._content = None
        self.write()

    def delete(self):
        if not os.path.exists(self.path):
            self.logger.error(f"File {self.path} does not exist, nothing to delete.")
            return

        try:
            os.remove(self.path)
        except Exception as e:
            self.logger.error(f"Failed to delete {self.path}: {format_exc_only(e)}.")

    @property
    def content(self) -> Optional[bytes]:
        return self._content

    @content.setter
    def content(self, value: Optional[bytes]):
        self._content = value


class JsonCacheFile(CacheFile):
    def __init__(self, filename: str, default: Any, read_on_init=True, compress=False):
        self._default = copy.deepcopy(default)
        self.json_content = self._get_copy_of_default()
        super().__init__(filename, read_on_init, compress)

    def _get_copy_of_default(self) -> Any:
        return copy.deepcopy(self._default)

    def read(self):
        super().read()

        if not self._content:
            self.json_content = self._get_copy_of_default()
            self._content = json.dumps(self.json_content).encode()

        try:
            self.json_content = json.loads(self._content.decode("utf-8", errors="replace"))
        except (UnicodeDecodeError, json.JSONDecodeError) as e:
            self.logger.error(f"Failed to load JSON from {self.path}: {format_exc_only(e)}. Setting default value.")
            self.json_content = self._get_copy_of_default()

    def write(self):
        self._content = json.dumps(self.json_content).encode("utf-8", errors="replace")
        super().write()

    def wipe(self):
        self.json_content = self._get_copy_of_default()
        super().wipe()

    @property
    def content(self) -> Any:
        if self._content is None:
            return self._get_copy_of_default()
        return self.json_content

    @content.setter
    def content(self, value: Any):
        self.json_content = value


@dataclass
class UpdaterTask:
    plugin_id: str
    channel_id: int
    message_id: int


class AutoUpdater:
    def __init__(self):
        self.thread: Optional[threading.Thread] = None
        self.forced_stop = False
        self.forced_update_check = False
        self.tasks: List[UpdaterTask] = []
        self.msg_edited_ts_cache = JsonCacheFile("zwylib_au__msg_edited_ts", {})  # plugin_id: edit_timestamp_of_message_with_file
        self.hash = str(zlib.adler32(id(self).to_bytes(8, "little")))
        self.logger = build_log(f"{__name__} AU {self.hash}")

    def run(self):
        self.forced_stop = False

        if self.thread is None:
            self.thread = threading.Thread(target=self.cycle)
            self.thread.daemon = True

        if self.thread.is_alive():
            self.logger.warning("Tried to run already ran thread. Ignoring.")
            return

        self.thread.start()
        self.logger.info("Thread was started.")

    def force_stop(self):
        if self.thread is None:
            self.logger.warning("Ignoring: thread has not been started.")
            return
        self.forced_stop = True

    def cycle(self):
        event = threading.Event()
        event.wait(5)

        while not self.forced_stop:
            try:
                self.check_for_updates()

                start_time = time.time()
                while (time.time() - start_time) < self.get_timeout_time():
                    event.wait(1)
                    if self.forced_update_check or (time.time() - start_time) >= self.get_timeout_time():
                        break

                if self.forced_update_check:
                    self.logger.info("Forced update check was requested, checking for updates...")
                    self.forced_update_check = False
            except Exception as e:
                self.logger.error("Exception in cycle:", format_exc_only(e))

        self.thread = None
        self.logger.info("Force stopped.")

    def check_for_updates(self):
        def get_message_callback(msg: Optional[TLRPC.TL_message], plugin_task: UpdaterTask):
            if not msg or isinstance(msg, TLRPC.TL_messageEmpty):
                self.logger.info(f"Task {plugin_task.plugin_id} message has not found. Removing the task...")
                self.remove_task(plugin_task)
                return

            if not msg.media:
                self.logger.info(f"Task {plugin_task.plugin_id} message has no document attached. Removing the task...")
                self.remove_task(plugin_task)
                return

            file_loader = get_file_loader()
            document = msg.media.getDocument()
            path = file_loader.getPathToAttach(document, True)

            if not PluginsController.getInstance().isPlugin(path):
                self.logger.info(f"The document attached to task {plugin_task.plugin_id} message is not plugin. Removing task...")
                self.remove_task(plugin_task)
                return

            disable_ts_check = setting_getter("disable_ts_check", DEFAULT_EDIT_TIMESTAMP_CHECK)
            if not disable_ts_check:
                msg_edited_ts = self.msg_edited_ts_cache.content.get(plugin_task.plugin_id)

                if msg.edit_date == msg_edited_ts:
                    self.logger.info(f"Attachment for task {plugin_task.plugin_id} has not been updated. Skipping...")
                    return

            self.msg_edited_ts_cache.content[plugin_task.plugin_id] = msg.edit_date
            self.msg_edited_ts_cache.write()
            run_on_queue(lambda: download_and_install_plugin(msg, plugin_task.plugin_id))

        for task in list(self.tasks):  # iterate copy of self.tasks to prevent RuntimeError
            plugin = get_plugin(task.plugin_id)

            if plugin is None:
                self.logger.info(f"Plugin {task.plugin_id} was not found. Removing task...")
                self.remove_task(task)
                continue

            if not plugin.isEnabled():
                self.logger.info(f"Plugin {task.plugin_id} is disabled. Removing task...")
                self.remove_task(task)
                continue

            self.logger.info(f"Executing for task {task.plugin_id}.")
            Requests.get_message(-task.channel_id, task.message_id, lambda msg, process_task=task: get_message_callback(msg, process_task))

    def is_task_already_present(self, task: UpdaterTask):
        for i in list(self.tasks):
            if i.plugin_id == task.plugin_id:
                return True
        return False

    def add_task(self, task: UpdaterTask):
        if self.is_task_already_present(task):
            self.logger.warning(f"Task {task.plugin_id} is already present.")
            return

        self.tasks.append(task)
        self.logger.info(f"Added task {task.plugin_id}.")

    def remove_task(self, task: UpdaterTask):
        if task not in self.tasks:
            self.logger.warning(f"Task {task.plugin_id} is not present.")
            return

        self.tasks.remove(task)
        self.logger.info(f"Removed task {task.plugin_id}")

    def remove_task_by_id(self, plugin_id: str):
        filtered_tasks = list(filter(lambda task: task.plugin_id != plugin_id, self.tasks))
        if len(filtered_tasks) < len(self.tasks):
            self.tasks = filtered_tasks
            self.logger.info(f"Removed task {plugin_id}.")
        else:
            self.logger.warning(f"Task {plugin_id} is not present.")

    def get_timeout_time(self) -> int:
        try:
            return int(setting_getter("autoupdate_timeout", DEFAULT_AUTOUPDATE_TIMEOUT))
        except (ValueError, TypeError) as e:
            self.logger.error("Get timeout time exception:", format_exc_only(e))
            return int(DEFAULT_AUTOUPDATE_TIMEOUT)

    def force_update_check(self):
        self.logger.info("Forced update check was requested.")
        self.forced_update_check = True


def download_and_install_plugin(msg, plugin_id: str, max_tries = 10, is_queued = False, current_try = 0):
    def plugin_install_error(arg):
        if arg is None:
            return
        logger.error(f"Error installing {plugin_id}: {arg}.")
        BulletinHelper.show_error(f"Error installing {plugin_id}. More in logs.")

    file_loader = get_file_loader()
    plugins_controller = PluginsController.getInstance()
    document = msg.media.getDocument()
    path = file_loader.getPathToAttach(document, True)

    if not path.exists():
        if is_queued:
            logger.info(f"Waiting 1s for the {plugin_id} plugin file to be downloaded ({current_try}/{max_tries})...")
        else:
            logger.info(f"Started loading the {plugin_id} plugin file...")

        file_loader.loadFile(document, "new_plugin", FileLoader.PRIORITY_NORMAL, 1)

        if current_try >= max_tries:
            logger.info("Max tries reached, the installation was aborted.")
            return
        run_on_queue(lambda: download_and_install_plugin(msg, plugin_id, is_queued=True, current_try=current_try + 1), delay=1)

    logger.info(f"Installing {plugin_id}...")

    try:
        plugins_controller.loadPluginFromFile(str(path), Callback1(plugin_install_error))
    except TypeError:
        # there is 3 arguments in refactored plugin engine
        plugins_controller.loadPluginFromFile(str(path), None, Callback1(plugin_install_error))


def get_plugin(plugin_id: str) -> Optional[Plugin]:
    return PluginsController.getInstance().plugins.get(plugin_id)


@overload
@deprecated("Use add_autoupdater_task(plugin_id, channel_id, message_id) instead")
def add_autoupdater_task(plugin_id: str, channel_id: int, channel_username: str, message_id: int) -> None: ...


@overload
def add_autoupdater_task(plugin_id: str, channel_id: int, message_id: int) -> None: ...


def add_autoupdater_task(plugin_id: str, channel_id: int, arg3: Union[str, int], arg4: Optional[int] = None) -> None:
    if isinstance(arg3, str) and isinstance(arg4, int):
        logger.warning(f"Ignoring deprecated channel_username='{arg3}'.")
        message_id = arg4
    elif isinstance(arg3, int) and arg4 is None:
        message_id = arg3
    else:
        raise TypeError("Invalid arguments for add_autoupdater_task.")

    task = UpdaterTask(plugin_id, channel_id, message_id)

    if autoupdater is None:
        logger.info(f"AutoUpdater is not initialized yet, saving task {plugin_id} to pending list...")
        companion.module.autoupdates_tasks.append(task)
        return

    autoupdater.add_task(task)
    logger.info(f"Task {plugin_id} successfully added.")


def remove_autoupdater_task(plugin_id: str):
    if autoupdater is None:
        logger.info(f"AutoUpdater is not initialized. Removing {plugin_id} task from cache...")
        companion.module.autoupdates_tasks = list(
            filter(lambda task: task.plugin_id != plugin_id, companion.module.autoupdates_tasks)
        )
        return

    logger.info(f"Removing {plugin_id} task...")
    autoupdater.remove_task_by_id(plugin_id)


def cache_all_autoupdater_tasks():
    companion.module.autoupdates_tasks.clear()
    companion.module.autoupdates_tasks = autoupdater.tasks.copy()


def load_cached_autoupdater_tasks():
    autoupdater.tasks = companion.module.autoupdates_tasks.copy()
    companion.module.autoupdates_tasks.clear()


class CustomLogger(logging.Logger):
    def _log(self, level: int, msg: Any, args: Tuple[Any, ...], exc_info=None, extra=None, stack_info=False, stacklevel=1):
        caller_frame = inspect.stack()[2]
        func_name = caller_frame.function

        level_name = logging.getLevelName(level).upper()

        prefix_items = [level_name, self.name, func_name]
        prefix_items = filter(lambda i: i, prefix_items)  # filter out empty items
        prefix_items = [f"[{i}]" for i in prefix_items]  # put them in brackets
        prefix = " ".join(prefix_items)

        try:
            formatted_msg = str(msg) % args if args else str(msg)
        except (TypeError, ValueError):
            formatted_args = " ".join(map(str, args)) if args else ""
            formatted_msg = f"{msg} {formatted_args}"

        _log(f"{prefix} {formatted_msg}")


def build_log(plugin_name: str, level = logging.INFO) -> logging.Logger:
    new_logger = logging.getLogger(plugin_name)
    new_logger.setLevel(level)
    return new_logger


def copy_to_clipboard(bulletin_helper: Optional[_BulletinHelper], text_to_copy: str):
    bulletin_helper.show_copied_to_clipboard() if AndroidUtilities.addToClipboard(text_to_copy) and bulletin_helper else None


class InnerBulletinHelper(_BulletinHelper):
    def __init__(self, prefix: Optional[str] = None):
        self.prefix = "" if not prefix or not prefix.strip() else f"{prefix}:"

    def show_info(self, message: str, fragment: Optional[Any] = None):
        _BulletinHelper.show_info(f"{self.prefix} {message}", fragment)

    def show_error(self, message: str, fragment: Optional[Any] = None):
        _BulletinHelper.show_error(f"{self.prefix} {message}", fragment)

    def show_success(self, message: str, fragment: Optional[Any] = None):
        _BulletinHelper.show_success(f"{self.prefix} {message}", fragment)

    def show_with_copy(self, message: str, text_to_copy: str, icon_res_id: int):
        _BulletinHelper.show_with_button(
            f"{self.prefix} {message}" if not message.startswith(f"{self.prefix} ") else message,
            icon_res_id,
            localise("copy_button"),
            on_click=lambda: copy_to_clipboard(self, text_to_copy),
        )

    def show_info_with_copy(self, message: str, copy_text: str):
        self.show_with_copy(f"{self.prefix} {message}", str(copy_text), R.raw.info)

    def show_error_with_copy(self, message: str, copy_text: str):
        self.show_with_copy(f"{self.prefix} {message}", str(copy_text), R.raw.error)

    def show_success_with_copy(self, message: str, copy_text: str):
        self.show_with_copy(f"{self.prefix} {message}", str(copy_text), R.raw.contact_check)

    def show_with_post_redirect(self, message: str, button_text: str, peer_id: int, message_id: int, icon_res_id: int = 0):
        _BulletinHelper.show_with_button(
            f"{self.prefix} {message}",
            icon_res_id,
            button_text,
            on_click=lambda: get_last_fragment().presentFragment(ChatActivity.of(peer_id, message_id)),
        )

    def show_info_with_post_redirect(self, message: str, button_text: str, peer_id: int, message_id: int):
        self.show_with_post_redirect(message, button_text, peer_id, message_id, R.raw.info)

    def show_error_with_post_redirect(self, message: str, button_text: str, peer_id: int, message_id: int):
        self.show_with_post_redirect(message, button_text, peer_id, message_id, R.raw.error)

    def show_success_with_post_redirect(self, message: str, button_text: str, peer_id: int, message_id: int):
        self.show_with_post_redirect(message, button_text, peer_id, message_id, R.raw.contact_check)


def build_bulletin_helper(prefix: Optional[str] = None) -> "InnerBulletinHelper":
    return InnerBulletinHelper(prefix)


class Locales:
    en = {
        "autoupdater_header": "AutoUpdater",
        "autoupdate_timeout_title": "Auto update timeout",
        "autoupdate_timeout_hint": "Time in seconds between update checks",
        "disable_autoupdater_title": "Disable autoupdater",
        f"disable_autoupdater_hint": f"Auto updates will be disabled for all plugins using {__name__}.",
        "disable_timestamp_check_title": "Disable message edit check",
        "disable_timestamp_check_hint": "Plugin will be updated even if the file has not been modified.",
        "not_sufficient_zwylib_ver": "{plugin_name} needs " + __name__ + " {version}+, got {cur_ver}.",
        "update_bulletin_button": "Update",
        "debug_mode_title": "Debug mode",
        "debug_mode_hint": "Prints some info to logs.",
        "debug_message_info": "Switch the debug mode off in plugin settings.",
        "dev_header": "Dev",
        "stub_command_message": "This command is a stub for registration of subcommand. Dont use it.",
        "copy_button": "Copy",
        "command_execution_error": "An error occurred executing command '{cmd_name}'",
    }
    ru = {
        "autoupdater_header": "Автообновление",
        "autoupdate_timeout_title": "Таймаут автообновления",
        "autoupdate_timeout_hint": "Время в секундах между проверками обновлений.",
        "disable_autoupdater_title": "Отключить автообновлялку",
        "disable_autoupdater_hint": f"Автообновления будут отключены для всех плагинов, использующих {__name__}.",
        "disable_timestamp_check_title": "Отключить проверку редактирования сообщений",
        "disable_timestamp_check_hint": "Плагин будет обновлен, даже если файл не был изменен.",
        "not_sufficient_zwylib_ver": "{plugin_name} нужен " + __name__ + " {version}+, текущая {cur_ver}.",
        "update_bulletin_button": "Обновить",
        "debug_mode_title": "Режим отладки",
        "debug_mode_hint": "Разрешает написывать еще больше логов.",
        "debug_message_info": "Отключите режим отладки в настройках плагина.",
        "dev_header": "Dev",
        "stub_command_message": "Эта команда - заглушка для регистрации подкоманд. Не используйте ее.",
        "copy_button": "Скопировать",
        "command_execution_error": "Возникла ошибка при выполнении команды '{cmd_name}'",
    }
    uk = {
        "autoupdater_header": "Автооновлення",
        "autoupdate_timeout_title": "Таймаут автооновлення",
        "autoupdate_timeout_hint": "Час у секундах між перевірками оновлень.",
        "disable_autoupdater_title": "Вимкнути автооновлення",
        "disable_autoupdater_hint": f"Автооновлення будуть вимкнені для всіх плагінів, що використовують {__name__}.",
        "disable_timestamp_check_title": "Вимкнути перевірку редагування повідомлень",
        "disable_timestamp_check_hint": "Плагін буде оновлено, навіть якщо файл не було змінено.",
        "not_sufficient_zwylib_ver": "{plugin_name} потрібен " + __name__ + " {version}+, поточна {cur_ver}.",
        "update_bulletin_button": "Оновити",
        "debug_mode_title": "Режим налагодження",
        "debug_mode_hint": "Дозволяє написувати ще більше логів.",
        "debug_message_info": "Вимкніть режим налагодження у налаштуваннях плагіна.",
        "dev_header": "Dev",
        "stub_command_message": "Ця команда - заглушка для реєстрації підкоманд. Не використовуйте її.",
        "copy_button": "Скопіювати",
        "command_execution_error": "Виникла помилка під час виконання команди '{cmd_name}'",
    }
    default = en


def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, key)


def is_zwylib_version_sufficient(plugin_name: str, version: str, show_bulletin = True) -> bool:
    is_sufficient = Version(__version__) >= Version(version)

    if show_bulletin and not is_sufficient:
        BulletinHelper.show_with_button(
            localise("not_sufficient_zwylib_ver").format(plugin_name=plugin_name, version=version, cur_ver=__version__),
            R.raw.chats_infotip,
            localise("update_bulletin_button"),
            lambda: get_last_fragment().presentFragment(ChatActivity.of(-AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)),
        )

    return is_sufficient


def is_debug_mode_on() -> bool:
    global setting_getter
    if setting_getter is None:
        return DEFAULT_DEBUG_MODE
    return setting_getter("debug_mode", DEFAULT_DEBUG_MODE)


class CannotCastError(Exception):
    pass


class WrongArgumentAmountError(Exception):
    pass


class MissingRequiredArguments(Exception):
    pass


class InvalidTypeError(Exception):
    pass


def _register_command(
        target: Dict[str, "Command"],
        command: "Command",
        plugin_id: str,
        is_subcommand: bool = False,
) -> None:
    name = command.name
    log_prefix = f"Command {name}:" if is_subcommand else f"Dispatcher {plugin_id}:"
    cmd_type = "Subcommand" if is_subcommand else "Command"
    pending_commands = companion.module.pending_commands

    if not name:
        cmd_logger.error(f"{log_prefix} {cmd_type} name ({name}) cannot be empty.")
        return

    if " " in name:
        cmd_logger.error(f"{log_prefix} {cmd_type} name ({name}) cannot contain spaces")
        return

    if command_manager.temporal and not is_subcommand:
        cmd_logger.info(f"{log_prefix} {cmd_type} manager is not initialized, saving command to pending list.")

        if plugin_id not in pending_commands:
            pending_commands[plugin_id] = []

        if name in map(lambda cmd: cmd.name, pending_commands[plugin_id]):
            cmd_logger.error(f"{log_prefix} {cmd_type} '{name}' is already in pending list.")
            return

        pending_commands[plugin_id].append(command)
        return

    if name in target:
        cmd_logger.error(f"{log_prefix} {cmd_type} '{name}' is already registered.")
        return

    cmd_logger.info(f"{log_prefix} Registered {cmd_type.lower()} {name}.")
    target[name] = command


@dataclass
class CommandTestUnit:
    input: str
    arg_specs: Tuple[inspect.Parameter, ...]
    expected_args: Optional[Tuple[Any, ...]]
    should_succeed: bool
    description: str
    expected_exception: Optional[Type[Exception]] = None


@dataclass
class ArgSpec:
    name: str
    annotation: Any
    kind: inspect._ParameterKind
    default: Any = inspect.Parameter.empty
    is_optional: bool = False

    @classmethod
    def from_parameter(cls, param: inspect.Parameter) -> "ArgSpec":
        annotation = param.annotation if param.annotation != inspect.Parameter.empty else Any
        is_optional = get_origin(annotation) in (Union, Optional) and type(None) in get_args(annotation)
        return cls(
            name=param.name,
            annotation=annotation,
            kind=param.kind,
            default=param.default,
            is_optional=is_optional
        )


@dataclass
class Command:
    func: Callable
    name: str
    args: List[ArgSpec] = field(default_factory=list)
    subcommands: Dict[str, "Command"] = field(default_factory=dict)
    error_handler: Optional[Callable[[Any, int, Exception], HookResult]] = None

    def subcommand(self, name: str):
        def decorator(func: Callable[[], None]):
            sub_cmd = create_command(func=func, name=name)
            _register_command(
                target=self.subcommands,
                command=sub_cmd,
                plugin_id=self.name,
                is_subcommand=True
            )
            return sub_cmd
        return decorator

    def register_error_handler(self, func: Callable[[Any, int, Exception], HookResult]):
        cmd_logger.info(f"Registering error handler for {self.name} command...")
        signature = inspect.signature(func)
        if len(signature.parameters) != 3:
            raise MissingRequiredArguments("Error handler must have only 'param', 'account' and 'exception' arguments.")
        self.error_handler = func
        return func

    def __repr__(self):
        return f"{self.__class__.__name__}(name={self.name}, subs={list(self.subcommands.values())})"


def is_allowed_type(arg_type):
    """
    Check if the argument type is supported, including Optional and Union types with NoneType.

    :param arg_type: The type to check.
    :returns: True if the type is supported, False otherwise.
    """
    if arg_type in ALLOWED_ARG_TYPES:
        return True

    if arg_type is type(None):
        return True

    origin = get_origin(arg_type)
    if origin in ALLOWED_ORIGIN:
        return all(is_allowed_type(t) for t in get_args(arg_type))
    return False


def create_command(func: Callable, name: str) -> Command:
    signature = inspect.signature(func)
    parameters = list(signature.parameters.values())
    return_type = signature.return_annotation

    if len(parameters) < 2:
        raise MissingRequiredArguments(
            "Command must have 'param' variable as first argument and 'account' variable as second argument"
        )

    args = [ArgSpec.from_parameter(param) for param in parameters]

    for index, arg in enumerate(args):
        if arg.kind == inspect.Parameter.VAR_POSITIONAL:
            origin_type = get_origin(arg.annotation) or arg.annotation
            if not is_allowed_type(origin_type):
                raise InvalidTypeError(
                    f"Variadic argument (index: {index}) type must be one of "
                    f"{*ALLOWED_ARG_TYPES, *ALLOWED_ORIGIN}, got {arg.annotation}"
                )
        elif not is_allowed_type(arg.annotation):
            raise InvalidTypeError(
                f"Command argument (index: {index}) signature must be one of "
                f"{*ALLOWED_ARG_TYPES, *ALLOWED_ORIGIN}, got {arg.annotation}"
            )

    if return_type != HookResult:
        return_type_name = "NoneType" if return_type == inspect.Parameter.empty else return_type
        raise InvalidTypeError(f"Command function must return {HookResult} object, got {return_type_name}")

    return Command(func=func, name=name, args=args)


class Dispatcher:
    def __init__(self, plugin_id: str, prefix: str, commands_priority: int):
        self.plugin_id = plugin_id
        self.prefix = prefix
        self.commands_priority = commands_priority
        self.listeners: Dict[str, Command] = {}  # command_name -> Command

    @staticmethod
    def validate_prefix(prefix: str) -> bool:
        return prefix and " " not in prefix

    def set_prefix(self, prefix: str):
        if not self.validate_prefix(prefix):
            cmd_logger.error(f"{self.plugin_id} dp: Prefix validation failed (got '{prefix}').")
            return

        cmd_logger.info(f"{self.plugin_id} dp: Set '{prefix}' prefix.")
        self.prefix = prefix
        command_manager.update_dispatcher_prefix_cache(self.plugin_id)

    def register_command(self, name: str):
        def decorator(func: Callable[[], None]):
            command = create_command(func=func, name=name)
            _register_command(
                target=self.listeners,
                command=command,
                plugin_id=self.plugin_id,
            )
            return command
        return decorator

    def unregister_command(self, name: str):
        cmd_logger.info(f"{self.plugin_id} dp: Unregistered command '{name}'.")
        self.listeners.pop(name, None)


class CommandManager:
    def __init__(self):
        self.dispatchers: Dict[str, Dispatcher] = {}  # plugin_id -> Dispatcher
        self.temporal = True
        self.prefixes_cache = JsonCacheFile("zwylib__cmds_prefixes", {})

    def get_dispatcher(self, plugin_id: str, prefix: str = "default", commands_priority = -1) -> Dispatcher:
        if not prefix or prefix == "default":
            prefix = DEFAULT_COMMAND_PREFIX

        if plugin_id in self.prefixes_cache.content:
            prefix = self.prefixes_cache.content[plugin_id]

        if plugin_id not in self.dispatchers:
            self.dispatchers[plugin_id] = Dispatcher(
                plugin_id=plugin_id,
                prefix=prefix,
                commands_priority=commands_priority,
            )

        cmd_logger.info(f"Got dispatcher for '{plugin_id}' with prefix '{prefix}'.")
        return self.dispatchers[plugin_id]

    def remove_dispatcher(self, plugin_id: str):
        self.dispatchers.pop(plugin_id, None)
        cmd_logger.info(f"Removed dispatcher for '{plugin_id}'.")

    def sort_dispatchers(self):
        """Sorts dispatchers by their commands priority. Dispatchers with higher priority will be processed first."""
        self.dispatchers = dict(sorted(self.dispatchers.items(), key=lambda i: i[1].commands_priority, reverse=True))
        cmd_logger.info("Dispatchers sorted by commands priority.")

    def mark_not_temporal(self):
        self.temporal = False

    def load_pending_commands(self):
        pending_commands: Dict[str, List[Command]] = companion.module.pending_commands
        cmd_logger.info("Loading pending commands:", pending_commands)

        for plugin_id, commands in pending_commands.items():
            if not commands:
                continue

            cmd_logger.info(f"Loading pending commands for '{plugin_id}'...")
            dispatcher = self.get_dispatcher(plugin_id)

            for command in commands:
                cmd_logger.info(f"Registered pending command '{command.name}' for '{plugin_id}'.")
                dispatcher.listeners[command.name] = command
        pending_commands.clear()

    def save_commands_as_pending(self):
        cmd_logger.info("Saving all commands to pending list...")

        pending_commands: Dict[str, List[Command]] = companion.module.pending_commands
        for plugin_id, dp in self.dispatchers.items():
            pending_commands[plugin_id] = list(dp.listeners.values())

    def unregister_all(self):
        cmd_logger.info("Unregistering all dispatchers...")
        self.dispatchers.clear()

    def update_dispatcher_prefix_cache(self, plugin_id: str):
        cmd_logger.info(f"Updating prefix cache for '{plugin_id}'...")
        dp = self.get_dispatcher(plugin_id)

        if dp.prefix == DEFAULT_COMMAND_PREFIX:
            cmd_logger.warning(f"'{plugin_id}' prefix is the same as the default. Removing from cache.")
            self.prefixes_cache.content.pop(plugin_id, None)
            self.prefixes_cache.write()
            return

        self.prefixes_cache.content[plugin_id] = dp.prefix
        self.prefixes_cache.write()


def cast_arg(arg: str, target_type: type):
    """
    Just casts a string to the target type.
    :raises CannotCastError: If the string cannot be cast to the target type.
    """

    if target_type == str or target_type == Any:
        return arg
    elif target_type == int:
        return int(arg)
    elif target_type == float:
        return float(arg)
    elif target_type == bool:
        if arg.lower() in ("true", "1", "yes", "on"):
            return True
        elif arg.lower() in ("false", "0", "no", "off"):
            return False
        else:
            raise CannotCastError(f"Cannot cast '{arg}' to bool")
    else:
        raise CannotCastError(f"Unsupported target type: {target_type}")


def smart_cast(arg: str, annotation):
    """
    Casts the string to the type specified in the annotation, including Optional and Union.
    :raises CannotCastError: If the string cannot be cast to any of the types in Union or the annotation is not supported.
    """

    origin = get_origin(annotation)
    args = get_args(annotation)

    if annotation in ALLOWED_ARG_TYPES:
        try:
            return cast_arg(arg, annotation)
        except:
            raise CannotCastError(f"Could not cast '{arg}' to {annotation}")
    elif origin is Union:
        for possible_type in args:
            if possible_type == type(None):
                continue
            try:
                return cast_arg(arg, possible_type)
            except:
                continue
        raise CannotCastError(f"Could not cast '{arg}' to any of: {args}")
    raise CannotCastError(f"Unsupported annotation: {annotation}")


def parse_args(
    raw_args: List[str],
    command_args: List[ArgSpec]
) -> Tuple[Any, ...]:
    """
    Parses a list of raw argument strings into typed arguments based on the command's argument specifications.

    :param raw_args: List of raw argument strings.
    :param command_args: List of ArgSpec describing the expected arguments.
    :returns: Tuple of parsed arguments.
    :raises WrongArgumentAmountError: If the number of provided arguments is incorrect.
    :raises CannotCastError: If an argument cannot be cast to the expected type.
    """

    out: List[Any] = []
    required_arg_count = sum(
        1 for arg in command_args
        if not arg.is_optional and arg.default == inspect.Parameter.empty and arg.kind != inspect.Parameter.VAR_POSITIONAL
    )
    is_variadic = any(arg.kind == inspect.Parameter.VAR_POSITIONAL for arg in command_args)

    if not is_variadic and len(raw_args) > len(command_args):
        raise WrongArgumentAmountError(f"Expected at most {len(command_args)} arguments, got {len(raw_args)}.")
    if len(raw_args) < required_arg_count:
        raise WrongArgumentAmountError(f"Expected at least {required_arg_count} arguments, got {len(raw_args)}.")

    for i, cmd_arg in enumerate(command_args):
        if cmd_arg.kind == inspect.Parameter.VAR_POSITIONAL:
            variadic_args = raw_args[i:] if i < len(raw_args) else []
            if not variadic_args:
                cmd_logger.error(f"No variadic arguments provided for {cmd_arg.name}, returning empty tuple.")
                break

            for arg in variadic_args:
                cmd_logger.debug(f"Processing variadic argument: {arg}, expected type: {cmd_arg.annotation}.")
                parsed_arg = smart_cast(arg, cmd_arg.annotation)
                cmd_logger.debug(f"Variadic argument parsed successfully: {parsed_arg}.")
                out.append(parsed_arg)
            break
        elif i < len(raw_args):
            cmd_logger.debug(f"Processing argument {i}: {raw_args[i]}, expected type: {cmd_arg.annotation}.")
            parsed_arg = smart_cast(raw_args[i], cmd_arg.annotation)
            cmd_logger.debug(f"Argument {i} parsed successfully: {parsed_arg}.")
            out.append(parsed_arg)
        elif cmd_arg.default != inspect.Parameter.empty:
            cmd_logger.debug(f"Argument {i} missing, using default value: {cmd_arg.default}.")
            out.append(cmd_arg.default)
        elif cmd_arg.is_optional:
            cmd_logger.debug(f"Argument {i} missing, using None for Optional type: {cmd_arg.annotation}.")
            out.append(None)
        else:
            cmd_logger.debug(f"Argument {i} missing for non-Optional, non-default type: {cmd_arg.annotation}.")
            raise WrongArgumentAmountError(f"Expected argument {i} of type {cmd_arg.annotation}, but none provided.")
    return tuple(out)


def format_exc() -> str:
    return traceback.format_exc().strip()


def format_exc_from(e: Exception) -> str:
    return "".join(traceback.format_exception(type(e), e, e.__traceback__)).strip()


def format_exc_only(e: Exception) -> str:
    exc = traceback.format_exception_only(type(e), e)
    return "".join(exc).strip()


class Companion(metaclass=SingletonMeta):
    defaults = {
        "autoupdates_tasks": [],
        "pending_commands": {},
    }

    def __init__(self):
        self.module = None

    @staticmethod
    def create():
        lines = ["# Auto-generated zwylib companion file\n"]
        for key, default in Companion.defaults.items():
            lines.append(f"\n{key} = {repr(default)}")

        os.makedirs(os.path.dirname(COMPANION_PATH), exist_ok=True)
        with open(COMPANION_PATH, "w", encoding="utf-8") as f:
            f.writelines(lines)

    def import_it(self):
        import zwylib_companion
        self.module = zwylib_companion


def arraylist_to_list(jarray: Optional[ArrayList]) -> Optional[List[Any]]:
    return [jarray.get(i) for i in range(jarray.size())] if jarray else None


def list_to_arraylist(python_list: Optional[List[Any]], int_auto_convert=True) -> Optional[ArrayList]:
    if not python_list:
        return None

    arraylist = ArrayList()
    for item in python_list:
        if int_auto_convert and isinstance(item, int):
            arraylist.add(jint(item))
            continue
        arraylist.add(item)
    return arraylist


def request_callback_factory(custom_callback: Optional[Callable]):
    def default_callback(response, error):
        if isinstance(response, TLRPC.TL_updates):
            updates = cast(TLRPC.Updates, response) if response else None
            get_messages_controller().processUpdates(updates, False)
        custom_callback(response, error) if custom_callback else None
    return default_callback


class Requests:
    @staticmethod
    def send(req, callback: Optional[Callable], delay=None, **kwargs):
        for k, v in kwargs.items():
            setattr(req, k, v)
        run_on_queue(lambda: send_request(req, request_callback_factory(callback)), delay=delay or 0)

    @staticmethod
    def search_messages(peer_id: int, callback: Optional[Callable]=None, delay=0, **kwargs):
        msg_controller = get_messages_controller()
        from_id: Any = kwargs.pop("from_id", None)
        top_msg_id: Any = kwargs.pop("top_msg_id", None)
        saved_peer_id: Any = kwargs.pop("saved_peer_id", None)
        saved_reaction: Any = kwargs.pop("saved_reaction", None)

        req = TLRPC.TL_messages_search()
        req.peer = msg_controller.getInputPeer(peer_id)
        req.filter = kwargs.pop("filter", TLRPC.TL_inputMessagesFilterEmpty())
        if from_id:
            req.from_id = msg_controller.getInputPeer(from_id)
            req.flags |= 1
        if top_msg_id:
            req.top_msg_id = top_msg_id
            req.flags |= 2
        if saved_peer_id:
            req.saved_peer_id = msg_controller.getInputPeer(saved_peer_id)
            req.flags |= 4
        if saved_reaction:
            req.saved_reaction.add(saved_reaction.toTLReaction())
            req.flags |= 8
        Requests.send(req, callback, delay, **kwargs)

    @staticmethod
    def reload_admins(chat_id: int):
        get_messages_controller().loadChannelAdmins(chat_id, False)

    @staticmethod
    def delete_messages(messages: List[int], peer_id: int, topic_id: Optional[int]):
        get_messages_controller().deleteMessages(list_to_arraylist(messages), None, None, peer_id, topic_id or 0, True, 0)

    @staticmethod
    def unban(chat_id: int, target_peer_id: int, callback: Optional[Callable]=None, delay=0):
        messages_controller = get_messages_controller()
        Requests.send(
            TLRPC.TL_channels_editBanned(),
            callback,
            delay,
            participant=messages_controller.getInputPeer(target_peer_id),
            channel=messages_controller.getInputChannel(chat_id),
            banned_rights=TLRPC.TL_chatBannedRights()
        )

    @staticmethod
    def change_slowmode(chat_id: int, callback: Optional[Callable]=None, delay=0, seconds=0):
        req = TLRPC.TL_channels_toggleSlowMode()
        req.channel = get_messages_controller().getInputChannel(chat_id)
        req.seconds = seconds
        Requests.send(req, callback, delay)

    @staticmethod
    def get_message(
            peer_id: int,
            message_id: int,
            callback: Optional[Callable[[Union[TLRPC.TL_message, TLRPC.TL_messageEmpty, None]], None]] = None,
            get_msg_tries_limit = 10,
            wait_time_seconds = 1
    ):
        def wait_for_db_update(current_try = 0):
            method.invoke(msg_controller, list_to_arraylist([message_id]), peer_id, jint(0))
            msg = get_messages_storage().getMessage(peer_id, message_id)
            if msg:
                callback(msg) if callback else None
                return
            if current_try <= get_msg_tries_limit:
                run_on_queue(lambda: wait_for_db_update(current_try + 1), delay=wait_time_seconds)

        msg_controller = get_messages_controller()
        clazz = msg_controller.getClass()
        method = clazz.getDeclaredMethod("reloadMessages", ArrayList, Long.TYPE, Integer.TYPE)
        method.setAccessible(True)
        run_on_queue(wait_for_db_update)

    @staticmethod
    def ban(chat_id: int, peer_id: int, until_date: Optional[int] = None):
        msg_controller = get_messages_controller()
        banned_rights = TLRPC.TL_chatBannedRights()
        for attr in dir(banned_rights):
            if isinstance(getattr(banned_rights, attr), bool):
                setattr(banned_rights, attr, True)
        banned_rights.until_date = until_date or 0

        Requests.send(
            TLRPC.TL_channels_editBanned(),
            None,
            0,
            participant=msg_controller.getInputPeer(peer_id),
            channel=msg_controller.getInputChannel(msg_controller.getChat(chat_id)),
            banned_rights=banned_rights
        )

    @staticmethod
    def get_chat_participant(chat_id: int, target_peer_id: int, callback: Callable):
        msg_controller = get_messages_controller()
        Requests.send(
            TLRPC.TL_channels_getParticipant(),
            callback,
            channel=msg_controller.getInputChannel(chat_id),
            participant=msg_controller.getInputPeer(target_peer_id)
        )


def register_zwylib_commands():
    logger.info("Registering ZwyLib commands...")
    dp = command_manager.get_dispatcher(__id__)

    @dp.register_command("zwylib")
    def zwylib(params, account) -> HookResult:
        """A stub for subcommands registration."""

        BulletinHelper.show_info(localise("stub_command_message"))
        return HookResult(strategy=HookStrategy.CANCEL)

    @zwylib.subcommand("cmds")
    def zwylib_cmds(params, account) -> HookResult:
        """(dev) Prints all registered commands and subcommands recursively."""

        def collect_commands(command: Command, prefix=""):
            full_name = (prefix + " " + command.name).strip()
            names = [full_name]
            for sub in command.subcommands.values():
                names.extend(collect_commands(sub, prefix=full_name))
            return names

        lines = []
        for dispatcher in command_manager.dispatchers.values():
            lines.append(f"\n- {dispatcher.plugin_id}:")
            for cmd in dispatcher.listeners.values():
                for name in collect_commands(cmd):
                    lines.append(f"\t- {name}")

        text = "\n".join(lines)
        parsed = markdown_utils.parse_markdown(text)

        params.message = parsed.text
        for ent in parsed.entities:
            params.entities.add(ent.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

    @zwylib_cmds.subcommand("test")
    def test_command_system(params, account) -> HookResult:
        """(dev) Command for testing the argument parsing system."""

        test_cases = [
            CommandTestUnit(
                input="",
                arg_specs=(),
                expected_args=(),
                should_succeed=True,
                description="No arguments"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=inspect.Parameter.empty),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory not annotated argument"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Any),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory Any argument"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Single mandatory str argument"
            ),
            CommandTestUnit(
                input="42.5",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=float),
                ),
                expected_args=(42.5,),
                should_succeed=True,
                description="Float argument"
            ),
            CommandTestUnit(
                input="true",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=bool),
                ),
                expected_args=(True,),
                should_succeed=True,
                description="Single mandatory bool argument"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                ),
                expected_args=None,
                should_succeed=False,
                description="Missing mandatory int argument",
                expected_exception=WrongArgumentAmountError
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str, default="default"),
                ),
                expected_args=("default",),
                should_succeed=True,
                description="Argument with default value"
            ),
            CommandTestUnit(
                input="42 default 1",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                    inspect.Parameter(name="arg2", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=str),
                    inspect.Parameter(name="arg3", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=int),
                ),
                expected_args=(42, "default", 1),
                should_succeed=True,
                description="Multiple arguments with int and str"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[str]),
                ),
                expected_args=("hi",),
                should_succeed=True,
                description="Optional str argument with valid input"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[str]),
                ),
                expected_args=(None,),
                should_succeed=True,
                description="Optional str argument with no input"
            ),
            CommandTestUnit(
                input="hi",
                arg_specs=(
                    inspect.Parameter(name="arg1", kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=Optional[int]),
                ),
                expected_args=(None,),
                should_succeed=False,
                description="Optional int argument with invalid input",
                expected_exception=CannotCastError
            ),
            CommandTestUnit(
                input="1 2 3",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=int),
                ),
                expected_args=(1, 2, 3),
                should_succeed=True,
                description="Variadic int arguments"
            ),
            CommandTestUnit(
                input="1 two 3",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=int),
                ),
                expected_args=(None, None, None),
                should_succeed=False,
                description="Variadic int arguments with invalid input",
                expected_exception=CannotCastError
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=str),
                ),
                expected_args=(),
                should_succeed=True,
                description="Variadic str arguments with no input"
            ),
            CommandTestUnit(
                input="",
                arg_specs=(
                    inspect.Parameter(name="args", kind=inspect.Parameter.VAR_POSITIONAL, annotation=inspect.Parameter.empty),
                ),
                expected_args=(),
                should_succeed=True,
                description="Variadic Any arguments with no input"
            ),
        ]

        results = []
        for i, case in enumerate(test_cases):
            test_number = i + 1

            try:
                cmd_parameters = [ArgSpec.from_parameter(param) for param in case.arg_specs]
                args = shlex.split(case.input) if case.input.strip() else []
                parsed_args = parse_args(args, cmd_parameters)

                if case.should_succeed:
                    if parsed_args == case.expected_args:
                        results.append(f"Test {test_number} ({case.description}): Passed")
                    else:
                        results.append(f"Test {test_number} ({case.description}): Failed - Expected args {case.expected_args}, got {parsed_args}\nInput: {case.input}")
                else:
                    results.append(f"Test {test_number} ({case.description}): Failed - Expected to fail, but succeeded with args {parsed_args}\nInput: {case.input}")
            except Exception as e:
                if case.should_succeed:
                    results.append(f"Test {test_number} ({case.description}): Failed with {format_exc_only(e)}\nInput: {case.input}")
                elif case.expected_exception and isinstance(e, case.expected_exception):
                    results.append(f"Test {test_number} ({case.description}): Passed")
                else:
                    results.append(f"Test {test_number} ({case.description}): Failed with unexpected error {format_exc_only(e)}\nInput: {case.input}")

        text = "Command system tests:\n\n" + "\n\n".join(results)
        parsed = markdown_utils.parse_markdown(text)

        params.message = parsed.text
        for ent in parsed.entities:
            params.entities.add(ent.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

    @zwylib.subcommand("clear")
    def zwylib_clear(params, account) -> HookResult:
        """(dev) Prints a lot of empty logs."""

        for _ in range(60):
            logger.info("\n")

        BulletinHelper.show_info(localise("debug_message_info"))
        return HookResult(strategy=HookStrategy.CANCEL)

    @zwylib.subcommand("au")
    def zwylib_au(params, account) -> HookResult:
        """A stub for subcommands registration."""

        BulletinHelper.show_info(localise("stub_command_message"))
        return HookResult(strategy=HookStrategy.CANCEL)

    @zwylib_au.subcommand("list")
    def zwylib_au_list(params, account) -> HookResult:
        """(dev) Prints all added autoupdater tasks."""

        text = "ZwyLib autoupdater tasks:\n" + "\n".join([f"\t- [{i.plugin_id}](https://t.me/c/{i.channel_id}/{i.message_id})" for i in autoupdater.tasks])
        new_msg = markdown_utils.parse_markdown(text)

        params.message = new_msg.text
        for i in new_msg.entities:
            params.entities.add(i.to_tlrpc_object())

        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)


logging.setLoggerClass(CustomLogger)

AUTOUPDATE_CHANNEL_ID = 2521243181
AUTOUPDATE_MSG_ID = 48
LOG_PREFIX = __name__

DEFAULT_EDIT_TIMESTAMP_CHECK = False
DEFAULT_DISABLE_AUTOUPDATER = False
DEFAULT_DEBUG_MODE = False
DEFAULT_AUTOUPDATE_TIMEOUT = str(10 * 60)
DEFAULT_COMMAND_PREFIX = "."
LOCALE = Locale.getDefault().getLanguage()
ALLOWED_ARG_TYPES_SIGNATURE = Union[str, int, float, bool, None, Any]
ALLOWED_ARG_TYPES = (str, int, float, bool, Any)
ALLOWED_ORIGIN = (Union, Optional)
PLUGINS_DIRECTORY = PluginsController.getInstance().pluginsDir.getAbsolutePath()
CACHE_DIRECTORY = os.path.join(PLUGINS_DIRECTORY, "cache")
COMPANION_DIRECTORY = "zwylib_companion"
COMPANION_PATH = os.path.join(PLUGINS_DIRECTORY, COMPANION_DIRECTORY, "__init__.py")

setting_getter: Optional[Callable[[str, Optional[Any]], Any]] = None
autoupdater: Optional[AutoUpdater] = None
logger = build_log(LOG_PREFIX)
cmd_logger = build_log(f"{LOG_PREFIX} commands")
BulletinHelper = build_bulletin_helper(LOG_PREFIX)
command_manager = CommandManager()
companion = Companion()

companion.create()
companion.import_it()


class ZwyLib(BasePlugin):
    def create_settings(self):
        def force_update_check_onclick(_):
            if autoupdater:
                autoupdater.force_update_check()
            else:
                BulletinHelper.show_error("AutoUpdater is not initialized yet.")

        def switch_debug_mode(new_value: bool):
            logger.setLevel(logging.DEBUG if new_value else logging.INFO)
            logger.info(f"Set '{logging.getLevelName(logger.level)}' level.")
            cmd_logger.setLevel(logging.DEBUG if new_value else logging.INFO)
            cmd_logger.info(f"Set '{logging.getLevelName(cmd_logger.level)}' level.")

        return [
            Header(text=localise("autoupdater_header")),
            Text("Force update check", icon="msg_photo_switch2", on_click=force_update_check_onclick),
            Input(
                key="autoupdate_timeout",
                text=localise("autoupdate_timeout_title"),
                subtext=localise("autoupdate_timeout_hint"),
                default=DEFAULT_AUTOUPDATE_TIMEOUT,
                icon="msg2_autodelete",
            ),
            Switch(
                key="disable_autoupdate",
                text=localise("disable_autoupdater_title"),
                subtext=localise("disable_autoupdater_hint"),
                default=DEFAULT_DISABLE_AUTOUPDATER,
                icon="msg_download",
                on_change=lambda enabled: autoupdater.force_stop() if enabled else run_on_ui_thread(autoupdater.run)
            ),
            Switch(
                key="disable_ts_check",
                text=localise("disable_timestamp_check_title"),
                subtext=localise("disable_timestamp_check_hint"),
                default=DEFAULT_EDIT_TIMESTAMP_CHECK,
                icon="msg_recent",
            ),
            Header(text=localise("dev_header")),
            Switch(
                key="debug_mode",
                text=localise("debug_mode_title"),
                subtext=localise("debug_mode_hint"),
                default=DEFAULT_DEBUG_MODE,
                icon="msg_log",
                on_change=lambda new_value: switch_debug_mode(new_value)
            ),
        ]

    def on_plugin_load(self):
        global autoupdater, setting_getter, command_manager
        setting_getter = self.get_setting

        disable_autoupdate = setting_getter("disable_autoupdate", DEFAULT_DISABLE_AUTOUPDATER)
        if not disable_autoupdate:
            logger.info("Initialising AutoUpdater...")
            autoupdater = AutoUpdater()

            logger.info("Adding tasks from cache...")
            load_cached_autoupdater_tasks()
            add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)

            logger.info("Running autoupdater...")
            autoupdater.run()

        logger.info("Registering command manager...")
        command_manager.mark_not_temporal()
        command_manager.load_pending_commands()
        register_zwylib_commands()

        logger.info("Hooking...")
        self.add_on_send_message_hook(priority=999)

        logger.info("Loaded.")

    def on_plugin_unload(self):
        if autoupdater:
            logger.info("Caching all tasks to add them again after reloading the plugin...")
            cache_all_autoupdater_tasks()

            logger.info("Force-stopping the AutoUpdater...")
            autoupdater.force_stop()

        command_manager.remove_dispatcher(__id__)
        command_manager.save_commands_as_pending()
        command_manager.unregister_all()

        logger.info("Unloaded.")

    def on_send_message_hook(self, account, params):
        original_text = getattr(params, "message")
        if not original_text:
            return HookResult()

        command_manager.sort_dispatchers()
        for plugin_id, dp in command_manager.dispatchers.items():
            cmd_logger.debug(f"Searching for commands in {plugin_id} dispatcher...")

            if not original_text.startswith(dp.prefix):
                continue

            msg_text = original_text[len(dp.prefix):]
            msg_text = msg_text.lstrip()
            args: List[Any] = shlex.split(msg_text.strip())

            if not args:
                continue

            cmd = dp.listeners.get(args[0])
            if not cmd:
                continue

            cmd_logger.debug(f"Found command: {cmd.name}. Looking for subcommands...")

            args = args[1:]
            while args and args[0] in cmd.subcommands:
                cmd = cmd.subcommands[args[0]]
                args = args[1:]
                cmd_logger.debug(f"Found subcommand: {cmd.name}. Continuing to search...")

            args.insert(0, params)
            args.insert(1, account)

            try:
                cmd_logger.debug("Preparing arguments...")
                parsed_args = parse_args(args, cmd.args)
                cmd_logger.debug(f"Executing command with args {parsed_args}...")
                return cmd.func(*parsed_args)
            except Exception as e:
                if cmd.error_handler:
                    cmd_logger.debug(f"Executing error handler for command '{cmd.name}'...")
                    return cmd.error_handler(params, account, e)

                message = f"Error executing command '{cmd.name}': {format_exc()}"
                cmd_logger.error(message)
                BulletinHelper.show_error_with_copy(localise("command_execution_error").format(cmd_name=cmd.name), message)
                return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()
