__id__ = "timeGuA"
__name__ = "Bedtime"
__author__ = "@oxxximif | @GuAgram"
__version__ = "1.0.0"
__description__ = """@GuAmain"""

__icon__ = "TyanPlugins/15"
__min_version__ = "11.12.0"

import threading
import time
from datetime import datetime
from typing import Any, Dict, List, Optional
import json
import uuid

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_last_fragment
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Input, Switch, Divider, Text
from ui.bulletin import BulletinHelper
from org.telegram.messenger import LocaleController

class AutoSleepReminderPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.pi_running = False
        self.pi_worker_thread = None
        self.pi_dialog_instance = None

        self.pi_sleep_reminders_list: List[Dict[str, Any]] = []
        self.pi_reminders_shown_today: Dict[str, str] = {}
        self.pi_message_blocking_active_today = False
        self.pi_global_last_trigger_date: Optional[str] = None
        self._s: Dict[str, str] = {}

    def on_plugin_load(self):
        self.pi_running = True

        try:
            self._s = self.pi_get_localized_strings()
        except Exception as e:
            self.log(f"Ошибка при инициализации локализованных строк: {e}. Используем пустой словарь.")
            self._s = {}

        saved_reminders = self.get_setting("pi_sleep_reminders_list", "[]")
        try:
            self.pi_sleep_reminders_list = json.loads(saved_reminders)
            if not isinstance(self.pi_sleep_reminders_list, list):
                raise ValueError("Loaded reminders list is not a list")
            if not self.pi_sleep_reminders_list:
                self.pi_add_default_reminder() 
        except (json.JSONDecodeError, ValueError) as e:
            self.log(f"Ошибка загрузки списка напоминаний: {e}. Создаём напоминание по умолчанию.")
            self.pi_sleep_reminders_list = []
            self.pi_add_default_reminder()
            
        saved_shown_today = self.get_setting("pi_reminders_shown_today", "{}")
        try:
            self.pi_reminders_shown_today = json.loads(saved_shown_today)
            if not isinstance(self.pi_reminders_shown_today, dict):
                raise ValueError("Loaded shown_today is not a dict")
        except (json.JSONDecodeError, ValueError) as e:
            self.log(f"Ошибка загрузки статуса показанных напоминаний: {e}.")
            self.pi_reminders_shown_today = {}

        self.pi_global_last_trigger_date = self.get_setting("pi_global_last_trigger_date", None)
        self.pi_message_blocking_active_today = self.get_setting("pi_message_blocking_active_today", False)

        self.add_on_send_message_hook()
        self.pi_worker_thread = threading.Thread(target=self.pi_reminder_worker, daemon=True)
        self.pi_worker_thread.start()
        self.log("Плагин 'Время спать!' успешно загружен! ^_^")

    def on_plugin_unload(self):
        self.pi_running = False
        if self.pi_worker_thread and self.pi_worker_thread.is_alive():
            self.pi_worker_thread.join(timeout=5)

        self.set_setting("pi_sleep_reminders_list", json.dumps(self.pi_sleep_reminders_list))
        self.set_setting("pi_reminders_shown_today", json.dumps(self.pi_reminders_shown_today))
        self.set_setting("pi_global_last_trigger_date", self.pi_global_last_trigger_date)
        self.set_setting("pi_message_blocking_active_today", self.pi_message_blocking_active_today)

        self.log("Плагин 'Время спать!' выгружен.")

    def pi_get_localized_strings(self):
        lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        if lang.startswith("ru"):
            return {
                "header_main": "Настройки напоминания о сне",
                "add_reminder_btn": "Добавить напоминание",
                "remove_reminder_btn": "Удалить это напоминание",
                "toggle_blocking_switch": "Блокировать сообщения после напоминаний",
                "toggle_blocking_subtext": "Отправка сообщений будет блокироваться, если прошло время хотя бы одного активного напоминания сегодня.",
                "blocking_active_bulletin": "Отправка сообщений временно заблокирована, пора спать!",
                "blocking_disabled_bulletin": "Блокировка сообщений отключена.",
                "enable_switch_global": "Включить напоминания",
                "enable_subtext_global": "Активирует все настроенные ежедневные уведомления.",
                "reminder_X_header": "Напоминание #",
                "reminder_X_enable": "Включить это напоминание",
                "reminder_X_time": "Время (ЧЧ:ММ)",
                "reminder_X_title": "Заголовок",
                "reminder_X_message": "Текст уведомления",
                "error_time_format": "Ошибка: Неверный формат времени. Используйте ЧЧ:ММ.",
                "error_no_activity": "Не удалось показать диалог: нет активного экрана.",
                "button_ok": "ОК",
                "bulletin_enabled": "Напоминания о сне включены.",
                "bulletin_disabled": "Напоминания о сне выключены.",
                "no_reminders_yet": "Пока нет напоминаний. Добавьте первое!"
            }
        else:
            return {
                "header_main": "Sleep Reminder Settings",
                "add_reminder_btn": "Add Reminder",
                "remove_reminder_btn": "Remove this Reminder",
                "toggle_blocking_switch": "Block messages after reminders",
                "toggle_blocking_subtext": "Message sending will be blocked if at least one active reminder's time has passed today.",
                "blocking_active_bulletin": "Message sending is temporarily blocked, time to sleep!",
                "blocking_disabled_bulletin": "Message blocking disabled.",
                "enable_switch_global": "Enable Reminders",
                "enable_subtext_global": "Activates all configured daily notifications.",
                "reminder_X_header": "Reminder #",
                "reminder_X_enable": "Enable this reminder",
                "reminder_X_time": "Time (HH:MM)",
                "reminder_X_title": "Title",
                "reminder_X_message": "Notification Message",
                "error_time_format": "Error: Invalid time format. Use HH:MM.",
                "error_no_activity": "Failed to show dialog: no active activity.",
                "button_ok": "OK",
                "bulletin_enabled": "Sleep reminders enabled.",
                "bulletin_disabled": "Sleep reminders disabled.",
                "no_reminders_yet": "No reminders yet. Add the first one!"
            }

    def _refresh_settings_page(self):
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllFragments"):
                run_on_ui_thread(lambda: fragment.rebuildAllFragments(True))
        except Exception as e:
            self.log(f"[{self.id}] Failed to refresh settings page: {e}")

    def pi_add_default_reminder(self):
        s = self._s 
        new_reminder = {
            "id": str(uuid.uuid4()),
            "enabled": True,
            "time": "22:00",
            "title": s.get("dialog_title_default", "Время спать!"),
            "message": s.get("dialog_message_default", "Глаза слипаются? Пора отдыхать! ✨")
        }
        self.pi_sleep_reminders_list.append(new_reminder)
        self.set_setting("pi_sleep_reminders_list", json.dumps(self.pi_sleep_reminders_list))

    def pi_add_reminder(self, view: Any):
        self.pi_add_default_reminder()
        self._refresh_settings_page()

    def pi_remove_reminder(self, reminder_id: str):
        self.pi_sleep_reminders_list = [r for r in self.pi_sleep_reminders_list if r["id"] != reminder_id]
        if reminder_id in self.pi_reminders_shown_today:
            del self.pi_reminders_shown_today[reminder_id]
            self.set_setting("pi_reminders_shown_today", json.dumps(self.pi_reminders_shown_today))
        
        self.set_setting("pi_sleep_reminders_list", json.dumps(self.pi_sleep_reminders_list))
        self._refresh_settings_page()

    def pi_on_global_enable_change(self, enabled: bool):
        s = self.pi_get_localized_strings()
        if enabled:
            BulletinHelper.show_success(s["bulletin_enabled"], get_last_fragment())
        else:
            BulletinHelper.show_info(s["bulletin_disabled"], get_last_fragment())

    def pi_on_blocking_enable_change(self, enabled: bool):
        s = self.pi_get_localized_strings()
        if enabled:
            BulletinHelper.show_success(s["blocking_active_bulletin"], get_last_fragment())
        else:
            BulletinHelper.show_info(s["blocking_disabled_bulletin"], get_last_fragment())

    def pi_update_reminder_field(self, reminder_id: str, field: str, value: Any):
        for reminder in self.pi_sleep_reminders_list:
            if reminder["id"] == reminder_id:
                reminder[field] = value
                break
        self.set_setting("pi_sleep_reminders_list", json.dumps(self.pi_sleep_reminders_list))

    def create_settings(self):
        s = self.pi_get_localized_strings()
        settings_list = [
            Header(text=s["header_main"]),
            Switch(
                key="pi_global_enable_reminders",
                text=s["enable_switch_global"],
                default=True,
                subtext=s["enable_subtext_global"],
                icon="menu_premium_clock",
                on_change=self.pi_on_global_enable_change
            ),
            Switch(
                key="pi_enable_message_blocking",
                text=s["toggle_blocking_switch"],
                default=False,
                subtext=s["toggle_blocking_subtext"],
                icon="msg_block2_remix",
                on_change=self.pi_on_blocking_enable_change
            ),
            Divider(),
        ]

        if not self.pi_sleep_reminders_list:
            settings_list.append(Text(text=s["no_reminders_yet"]))
        
        for idx, reminder in enumerate(self.pi_sleep_reminders_list):
            settings_list.extend([
                Header(text=f"{s['reminder_X_header']}{idx + 1}"),
                Switch(
                    key=f"reminder_{reminder['id']}_enabled",
                    text=s["reminder_X_enable"],
                    default=reminder.get("enabled", True),
                    on_change=lambda enabled, r_id=reminder["id"]: self.pi_update_reminder_field(r_id, "enabled", enabled),
                    icon="msg_check"
                ),
                Input(
                    key=f"reminder_{reminder['id']}_time",
                    text=s["reminder_X_time"],
                    default=reminder.get("time", "22:00"),
                    on_change=lambda value, r_id=reminder["id"]: self.pi_update_reminder_field(r_id, "time", value),
                    icon="msg_calendar"
                ),
                Input(
                    key=f"reminder_{reminder['id']}_title",
                    text=s["reminder_X_title"],
                    default=reminder.get("title", s.get("dialog_title_default", "Время спать!")),
                    on_change=lambda value, r_id=reminder["id"]: self.pi_update_reminder_field(r_id, "title", value),
                    icon="msg_message"
                ),
                Input(
                    key=f"reminder_{reminder['id']}_message",
                    text=s["reminder_X_message"],
                    default=reminder.get("message", s.get("dialog_message_default", "Глаза слипаются? Пора отдыхать! ✨")),
                    on_change=lambda value, r_id=reminder["id"]: self.pi_update_reminder_field(r_id, "message", value),
                    icon="msg_message2"
                ),
            ])
            if len(self.pi_sleep_reminders_list) > 1:
                settings_list.append(
                    Text(
                        text=s["remove_reminder_btn"],
                        on_click=lambda view, r_id=reminder["id"]: self.pi_remove_reminder(r_id),
                        red=True,
                        icon="msg_delete_remix"
                    )
                )
            settings_list.append(Divider())

        settings_list.append(
            Text(
                text=s["add_reminder_btn"],
                on_click=self.pi_add_reminder,
                accent=True,
                icon="msg_addbio_solar"
            )
        )
        settings_list.append(Divider())
        
        return settings_list

    def pi_reminder_worker(self):
        while self.pi_running:
            try:
                s = self._s if self._s else self.pi_get_localized_strings()

                pi_global_enabled = self.get_setting("pi_global_enable_reminders", True)
                if not pi_global_enabled:
                    time.sleep(60)
                    continue

                current_time = datetime.now()
                current_date_str = current_time.strftime("%Y-%m-%d")

                if self.pi_global_last_trigger_date != current_date_str:
                    self.pi_message_blocking_active_today = False
                    self.pi_reminders_shown_today = {}
                    self.pi_global_last_trigger_date = current_date_str
                    self.log(f"Новый день. Сброшены флаги напоминаний и блокировки: {current_date_str}")
                    self.set_setting("pi_global_last_trigger_date", self.pi_global_last_trigger_date) 
                    self.set_setting("pi_reminders_shown_today", json.dumps(self.pi_reminders_shown_today))
                    self.set_setting("pi_message_blocking_active_today", self.pi_message_blocking_active_today)

                for reminder in self.pi_sleep_reminders_list:
                    if reminder.get("enabled", False):
                        reminder_id = reminder["id"]
                        pi_reminder_time_str = reminder.get("time", "22:00")
                        
                        if self.pi_reminders_shown_today.get(reminder_id) == current_date_str:
                            continue

                        try:
                            pi_reminder_hour, pi_reminder_minute = map(int, pi_reminder_time_str.split(':'))
                        except ValueError:
                            run_on_ui_thread(lambda: BulletinHelper.show_error(s["error_time_format"]))
                            continue

                        if current_time.hour == pi_reminder_hour and current_time.minute == pi_reminder_minute:
                            self.log(f"Напоминание '{reminder.get('title')}' сработало: {pi_reminder_time_str}.")
                            self.pi_show_sleep_dialog(reminder)
                            self.pi_reminders_shown_today[reminder_id] = current_date_str
                            self.set_setting("pi_reminders_shown_today", json.dumps(self.pi_reminders_shown_today))

                            if self.get_setting("pi_enable_message_blocking", False):
                                self.pi_message_blocking_active_today = True
                                self.set_setting("pi_message_blocking_active_today", self.pi_message_blocking_active_today)
                                self.log(f"Блокировка сообщений активирована напоминанием '{reminder.get('title')}'.")
                            
                            time.sleep(60 - current_time.second) 
                            continue

                time.sleep(10)
            except Exception as e:
                self.log(f"Ошибка в фоновом потоке напоминания: {e}")
                time.sleep(300)

    def pi_show_sleep_dialog(self, reminder_obj: Dict[str, Any]):
        s = self._s
        fragment = get_last_fragment()
        if not fragment:
            self.log(s["error_no_activity"])
            return

        activity = fragment.getParentActivity()
        if not activity:
            self.log(s["error_no_activity"])
            return

        dialog_title = reminder_obj.get("title", s.get("dialog_title_default", "Время спать!"))
        dialog_message = reminder_obj.get("message", s.get("dialog_message_default", "Глаза слипаются? Пора отдыхать! ✨"))
        button_ok = s.get("button_ok", "ОК")

        def show_dialog_action():
            if self.pi_dialog_instance and self.pi_dialog_instance.get_dialog() and self.pi_dialog_instance.get_dialog().isShowing():
                return 

            builder = AlertDialogBuilder(activity)
            builder.set_title(dialog_title)
            builder.set_message(dialog_message)
            builder.set_positive_button(button_ok, lambda d, w: self.pi_dismiss_dialog())
            builder.set_cancelable(True)
            builder.set_canceled_on_touch_outside(True)
            self.pi_dialog_instance = builder.show()

        run_on_ui_thread(show_dialog_action)

    def pi_dismiss_dialog(self):
        def dismiss_action():
            if self.pi_dialog_instance and self.pi_dialog_instance.get_dialog() and self.pi_dialog_instance.get_dialog().isShowing():
                self.pi_dialog_instance.dismiss()
                self.pi_dialog_instance = None
        run_on_ui_thread(dismiss_action)

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if self.get_setting("pi_enable_message_blocking", False) and self.pi_message_blocking_active_today:
            s = self.pi_get_localized_strings()
            run_on_ui_thread(lambda: BulletinHelper.show_error(s["blocking_active_bulletin"]))
            return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()