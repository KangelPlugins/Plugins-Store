import math
from typing import Any, Dict, Optional, Set, Tuple

from android.text import Layout, StaticLayout, TextUtils, SpannableStringBuilder
from android.text.style import RelativeSizeSpan
from android_utils import log
from base_plugin import BasePlugin, HookResult, MethodHook
from hook_utils import find_class
from java.lang import Integer
from org.telegram.messenger import AndroidUtilities, FileLoader
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import Theme
from org.telegram.ui.Cells import SharedAudioCell
from org.telegram.ui.Components import AnimatedEmojiDrawable, AnimatedEmojiSpan
from ui.settings import Divider, Header, Switch

__id__ = "audio_size_timer_xeroxdev"
__name__ = "Audio Size Timer"
__description__ = "Добавляет размер файла ко всем аудио рядом с таймером"
__author__ = "@vutarn"
__version__ = "1.0.0"
__icon__ = "sPluginIDE/18"
__min_version__ = "11.12.0"


class AudioSizeTimerPlugin(BasePlugin):
    """Adds audio file size/extension info next to timers in audio UI cells."""

    DOCUMENT_ATTACH_TYPE_AUDIO = 3
    DOCUMENT_ATTACH_TYPE_MUSIC = 5
    _MAX_EXTENSION_LEN = 8

    def __init__(self) -> None:
        """Initialize plugin state and reflection caches."""
        super().__init__()
        self.chat_message_cell_class: Optional[Any] = None
        self.shared_audio_cell_class: Optional[Any] = None
        self.message_object_class: Optional[Any] = None
        self.audio_player_cell_class: Optional[Any] = None
        self._field_cache: Dict[Tuple[str, str], Any] = {}
        self._missing_fields: Set[Tuple[str, str]] = set()
        self._method_cache: Dict[Tuple[str, str, Tuple[str, ...]], Any] = {}
        self._missing_methods: Set[Tuple[str, str, Tuple[str, ...]]] = set()
        self._logged_errors: Set[Tuple[str, ...]] = set()

    def on_plugin_load(self) -> None:
        """Install hooks and initialize class references."""
        self.add_on_send_message_hook()
        self._prepare_classes()
        self._hook_update_progress()
        self._hook_shared_audio_cell()
        self._hook_audio_player_cell()
        self._hook_measure_time()
        log("AudioSizeTimerPlugin loaded.")

    def on_plugin_unload(self) -> None:
        """Handle plugin unload."""
        log("AudioSizeTimerPlugin unloaded.")

    def _prepare_classes(self) -> None:
        self.chat_message_cell_class = find_class("org.telegram.ui.Cells.ChatMessageCell")
        self.shared_audio_cell_class = find_class("org.telegram.ui.Cells.SharedAudioCell")
        self.message_object_class = find_class("org.telegram.messenger.MessageObject")
        self.audio_player_cell_class = find_class("org.telegram.ui.Cells.AudioPlayerCell")
        if not self.chat_message_cell_class:
            log("AudioSizeTimerPlugin: ChatMessageCell not found.")
        if not self.shared_audio_cell_class:
            log("AudioSizeTimerPlugin: SharedAudioCell not found.")
        if not self.message_object_class:
            log("AudioSizeTimerPlugin: MessageObject not found.")
        if not self.audio_player_cell_class:
            log("AudioSizeTimerPlugin: AudioPlayerCell not found.")

    def _hook_update_progress(self) -> None:
        if not self.chat_message_cell_class:
            return

        try:
            method = self.chat_message_cell_class.getClass().getDeclaredMethod("updatePlayingMessageProgress")
            method.setAccessible(True)
            self.hook_method(method, self._UpdateProgressHook(self))
        except Exception as exc:
            log(f"AudioSizeTimerPlugin: hook failed: {exc}")

    def _hook_shared_audio_cell(self) -> None:
        if not self.shared_audio_cell_class:
            return
        try:
            method = self.shared_audio_cell_class.getClass().getDeclaredMethod(
                "onMeasure", Integer.TYPE, Integer.TYPE
            )
            method.setAccessible(True)
            self.hook_method(method, self._SharedAudioMeasureHook(self))
        except Exception as exc:
            log(f"AudioSizeTimerPlugin: shared audio hook failed: {exc}")

    def _hook_audio_player_cell(self) -> None:
        if not self.audio_player_cell_class:
            return
        try:
            method = self.audio_player_cell_class.getClass().getDeclaredMethod(
                "onMeasure", Integer.TYPE, Integer.TYPE
            )
            method.setAccessible(True)
            self.hook_method(method, self._AudioPlayerMeasureHook(self))
        except Exception as exc:
            log(f"AudioSizeTimerPlugin: audio player hook failed: {exc}")

    def _hook_measure_time(self) -> None:
        if not self.chat_message_cell_class or not self.message_object_class:
            return
        try:
            method = self._get_method(self.chat_message_cell_class, "measureTime", [self.message_object_class])
            if method:
                method.setAccessible(True)
                self.hook_method(method, self._MeasureTimeHook(self))
        except Exception as exc:
            log(f"AudioSizeTimerPlugin: measureTime hook failed: {exc}")

    class _UpdateProgressHook(MethodHook):
        """Refresh size info after playback progress updates."""

        def __init__(self, plugin: "AudioSizeTimerPlugin"):
            self.plugin = plugin

        def after_hooked_method(self, param: Any) -> None:
            try:
                self.plugin._append_size(param.thisObject)
            except Exception as exc:
                log(f"AudioSizeTimerPlugin: after hook error: {exc}")

    class _MeasureTimeHook(MethodHook):
        """Refresh size info after ChatMessageCell measureTime updates."""

        def __init__(self, plugin: "AudioSizeTimerPlugin"):
            self.plugin = plugin

        def after_hooked_method(self, param: Any) -> None:
            try:
                self.plugin._append_size(param.thisObject)
            except Exception as exc:
                log(f"AudioSizeTimerPlugin: measureTime hook error: {exc}")

    class _AudioPlayerMeasureHook(MethodHook):
        """Refresh size info in audio player cell after measurement."""

        def __init__(self, plugin: "AudioSizeTimerPlugin"):
            self.plugin = plugin

        def after_hooked_method(self, param: Any) -> None:
            try:
                self.plugin._append_size_audio_player(param.thisObject)
            except Exception as exc:
                log(f"AudioSizeTimerPlugin: audio player hook error: {exc}")

    class _SharedAudioMeasureHook(MethodHook):
        """Refresh size info in shared audio cell after measurement."""

        def __init__(self, plugin: "AudioSizeTimerPlugin"):
            self.plugin = plugin

        def after_hooked_method(self, param: Any) -> None:
            try:
                self.plugin._append_size_shared(param.thisObject)
            except Exception as exc:
                log(f"AudioSizeTimerPlugin: shared audio hook error: {exc}")

    def _append_size(self, cell: Any) -> None:
        document_type = self._get_int_field(cell, "documentAttachType")
        if document_type not in (self.DOCUMENT_ATTACH_TYPE_AUDIO, self.DOCUMENT_ATTACH_TYPE_MUSIC):
            return

        current_message = getattr(cell, "currentMessageObject", None)
        is_voice = bool(current_message) and getattr(current_message, "isVoice", lambda: False)()
        is_music = document_type == self.DOCUMENT_ATTACH_TYPE_MUSIC
        if not self._should_show_info(is_voice, is_music):
            return

        document = self._get_field(cell, "documentAttach")
        if document is None or not isinstance(document, TLRPC.Document):
            return

        duration_layout = self._get_field(cell, "durationLayout")
        if duration_layout is None:
            return

        time_text = str(self._get_layout_text(duration_layout)).strip()
        if not time_text:
            return

        size_text = self._build_size_text(document)

        if size_text in time_text:
            return

        paint = Theme.chat_audioTimePaint
        ext_only = self._safe_get_extension(document)
        base_text = f"{time_text}  {size_text}"
        width_main = int(math.ceil(paint.measureText(base_text)))
        available_width = self._get_int_field(cell, "availableTimeWidth") or 0
        background_width = self._get_int_field(cell, "backgroundWidth") or 0
        width_limit = self._resolve_time_width_limit(available_width, background_width, width_main)
        line1 = base_text
        if ext_only:
            prefix = f"{ext_only} • "
            if width_limit > 0:
                if paint.measureText(prefix + base_text) <= width_limit:
                    line1 = prefix + base_text
            else:
                line1 = prefix + base_text

        if width_limit > 0 and paint.measureText(line1) > width_limit:
            line1 = TextUtils.ellipsize(line1, paint, width_limit, TextUtils.TruncateAt.END)
        width_main = int(math.ceil(paint.measureText(line1)))

        layout_width = max(width_main, 1)

        new_layout = StaticLayout(line1, paint, layout_width, Layout.Alignment.ALIGN_NORMAL, 1.0, 0.0, False)

        self._set_field(cell, "durationLayout", new_layout)
        self._set_int_field(cell, "timeWidthAudio", width_main)

    def _append_size_shared(self, cell: Any) -> None:
        message = self._get_field(cell, "currentMessageObject")
        if message is None:
            return

        document = message.getDocument()
        if document is None or not isinstance(document, TLRPC.Document):
            return

        is_voice = message.isVoice() if hasattr(message, "isVoice") else False
        is_music = message.isMusic() if hasattr(message, "isMusic") else False
        is_round = message.isRoundVideo() if hasattr(message, "isRoundVideo") else False
        if not (is_voice or is_round or is_music):
            return
        if not self._should_show_info(is_voice, is_music):
            return

        description_layout = self._get_field(cell, "descriptionLayout")
        if description_layout is None:
            return

        base_text = self._get_layout_text(description_layout)

        size_text = self._build_size_text(document)
        if not size_text or size_text in str(base_text):
            return

        view_type = self._get_int_field(cell, "viewType")
        paint = self._get_field(cell, "description2TextPaint") if view_type == SharedAudioCell.VIEW_TYPE_GLOBAL_SEARCH else Theme.chat_contextResult_descriptionTextPaint
        if paint is None:
            paint = Theme.chat_contextResult_descriptionTextPaint

        layout_width = self._resolve_description_width(
            cell,
            description_layout,
            AndroidUtilities.leftBaseline + 8 + 20,
            view_type=view_type,
        )
        max_width = max(layout_width - AndroidUtilities.dp(4), 1)

        ext_text = self._safe_get_extension(document)
        combined = self._build_description_text(base_text, size_text, ext_text, paint, max_width, ext_inline=True)

        new_layout = StaticLayout(combined, paint, max_width + AndroidUtilities.dp(4), Layout.Alignment.ALIGN_NORMAL, 1.0, 0.0, False)

        left = new_layout.getLineLeft(0) if new_layout.getLineCount() > 0 else 0
        width = 0
        for i in range(new_layout.getLineCount()):
            width = max(width, new_layout.getLineWidth(i))
        self._set_field(cell, "descriptionLayout", new_layout)
        self._set_float_field(cell, "descriptionLayoutLeft", float(left))
        self._set_float_field(cell, "descriptionLayoutWidth", float(width))

        emojis = self._get_field(cell, "descriptionLayoutEmojis")
        updated = AnimatedEmojiSpan.update(AnimatedEmojiDrawable.CACHE_TYPE_MESSAGES, cell, emojis, new_layout)
        self._set_field(cell, "descriptionLayoutEmojis", updated)

    def _append_size_audio_player(self, cell: Any) -> None:
        message = self._get_field(cell, "currentMessageObject")
        if message is None:
            return

        is_voice = message.isVoice() if hasattr(message, "isVoice") else False
        is_music = message.isMusic() if hasattr(message, "isMusic") else False
        if not self._should_show_info(is_voice, is_music):
            return

        document = message.getDocument()
        if document is None or not isinstance(document, TLRPC.Document):
            return

        description_layout = self._get_field(cell, "descriptionLayout")
        if description_layout is None:
            return

        size_text = self._build_size_text(document)
        base_text = self._get_layout_text(description_layout)
        if not size_text or size_text in str(base_text):
            return

        paint = Theme.chat_contextResult_descriptionTextPaint

        layout_width = self._resolve_description_width(
            cell,
            description_layout,
            AndroidUtilities.leftBaseline + 16 + 32,
        )
        max_width = max(layout_width - AndroidUtilities.dp(4), 1)

        ext_text = self._safe_get_extension(document)
        combined = self._build_description_text(base_text, size_text, ext_text, paint, max_width, ext_inline=False)

        new_layout = StaticLayout(combined, paint, max_width + AndroidUtilities.dp(4), Layout.Alignment.ALIGN_NORMAL, 1.0, 0.0, False)
        self._set_field(cell, "descriptionLayout", new_layout)
        updated = AnimatedEmojiSpan.update(AnimatedEmojiDrawable.CACHE_TYPE_MESSAGES, cell, self._get_field(cell, "descriptionLayoutEmojis"), new_layout)
        self._set_field(cell, "descriptionLayoutEmojis", updated)

    def _log_once(self, key: Tuple[str, ...], message: str) -> None:
        if key in self._logged_errors:
            return
        self._logged_errors.add(key)
        log(message)

    def _class_name(self, obj: Any) -> str:
        try:
            class_name = str(obj.getClass().getName())
            if class_name == "java.lang.Class":
                return str(obj.getName())
            return class_name
        except Exception:
            try:
                return str(obj.getName())
            except Exception:
                return str(obj)

    def _method_key(self, clazz: Any, name: str, params: Optional[list]) -> Tuple[str, str, Tuple[str, ...]]:
        param_names = []
        if params:
            for param in params:
                try:
                    param_names.append(str(param.getName()))
                except Exception:
                    param_names.append(str(param))
        return (self._class_name(clazz), name, tuple(param_names))

    def _get_method(self, clazz: Any, name: str, params: list) -> Optional[Any]:
        key = self._method_key(clazz, name, params)
        if key in self._method_cache:
            return self._method_cache[key]
        if key in self._missing_methods:
            return None
        try:
            method = clazz.getClass().getDeclaredMethod(name, *params)
            self._method_cache[key] = method
            return method
        except Exception as exc:
            self._log_once(("method_declared",) + key, f"AudioSizeTimerPlugin: getDeclaredMethod '{name}' failed on {key[0]}: {exc}")
        try:
            for m in clazz.getClass().getDeclaredMethods():
                if str(m.getName()) == name:
                    self._method_cache[key] = m
                    return m
        except Exception as exc:
            self._log_once(("method_list",) + key, f"AudioSizeTimerPlugin: getDeclaredMethods failed on {key[0]}: {exc}")
        self._missing_methods.add(key)
        self._log_once(("method_missing",) + key, f"AudioSizeTimerPlugin: method '{name}' not found on {key[0]}")
        return None

    def _safe_get_extension(self, document: Any) -> str:
        try:
            ext = FileLoader.getDocumentExtension(document)
            if not ext:
                return ""
            ext = ext.strip()
            if "/" in ext:
                ext = ext.split("/")[-1]
            if len(ext) > self._MAX_EXTENSION_LEN:
                ext = ext[: self._MAX_EXTENSION_LEN]
            return ext
        except Exception as exc:
            log(f"AudioSizeTimerPlugin: get extension failed: {exc}")
            return ""

    def _get_field_handle(self, obj: Any, field_name: str) -> Optional[Any]:
        if obj is None:
            return None
        class_name = self._class_name(obj)
        key = (class_name, field_name)
        if key in self._field_cache:
            return self._field_cache[key]
        if key in self._missing_fields:
            return None
        try:
            field = obj.getClass().getDeclaredField(field_name)
            field.setAccessible(True)
            self._field_cache[key] = field
            return field
        except Exception as exc:
            self._missing_fields.add(key)
            self._log_once(("field_missing", class_name, field_name), f"AudioSizeTimerPlugin: field '{field_name}' not found on {class_name}: {exc}")
            return None

    def _get_int_field(self, obj: Any, field_name: str) -> Optional[int]:
        field = self._get_field_handle(obj, field_name)
        if field is None:
            return None
        try:
            value = field.get(obj)
            return int(value) if value is not None else None
        except Exception as exc:
            class_name = self._class_name(obj)
            self._log_once(("field_get_int", class_name, field_name), f"AudioSizeTimerPlugin: get int '{field_name}' failed on {class_name}: {exc}")
            return None

    def _set_int_field(self, obj: Any, field_name: str, value: int) -> None:
        field = self._get_field_handle(obj, field_name)
        if field is None:
            return
        try:
            field.setInt(obj, value)
        except Exception as exc:
            class_name = self._class_name(obj)
            self._log_once(("field_set_int", class_name, field_name), f"AudioSizeTimerPlugin: set int '{field_name}' failed on {class_name}: {exc}")

    def _set_float_field(self, obj: Any, field_name: str, value: float) -> None:
        field = self._get_field_handle(obj, field_name)
        if field is None:
            return
        try:
            field.setFloat(obj, float(value))
        except Exception as exc:
            class_name = self._class_name(obj)
            self._log_once(("field_set_float", class_name, field_name), f"AudioSizeTimerPlugin: set float '{field_name}' failed on {class_name}: {exc}")

    def _get_field(self, obj: Any, field_name: str) -> Optional[Any]:
        field = self._get_field_handle(obj, field_name)
        if field is None:
            return None
        try:
            return field.get(obj)
        except Exception as exc:
            class_name = self._class_name(obj)
            self._log_once(("field_get", class_name, field_name), f"AudioSizeTimerPlugin: get '{field_name}' failed on {class_name}: {exc}")
            return None

    def _set_field(self, obj: Any, field_name: str, value: Any) -> None:
        field = self._get_field_handle(obj, field_name)
        if field is None:
            return
        try:
            field.set(obj, value)
        except Exception as exc:
            class_name = self._class_name(obj)
            self._log_once(("field_set", class_name, field_name), f"AudioSizeTimerPlugin: set '{field_name}' failed on {class_name}: {exc}")

    def _build_size_text(self, document: Any) -> str:
        size_value = AndroidUtilities.formatFileSize(document.size)
        return size_value if size_value else ""

    def _get_layout_text(self, layout: Any) -> Any:
        try:
            text_obj = layout.getText()
            return text_obj if text_obj is not None else ""
        except Exception as exc:
            self._log_once(("layout_text", self._class_name(layout)), f"AudioSizeTimerPlugin: get layout text failed: {exc}")
            return ""

    def _resolve_description_width(
        self,
        cell: Any,
        description_layout: Any,
        base_offset: int,
        view_type: Optional[int] = None,
    ) -> int:
        layout_width = description_layout.getWidth()
        if layout_width <= 0:
            measured_width = cell.getMeasuredWidth()
            layout_width = measured_width - AndroidUtilities.dp(base_offset)
            if view_type == SharedAudioCell.VIEW_TYPE_GLOBAL_SEARCH:
                date_layout = self._get_field(cell, "dateLayout")
                if date_layout is not None:
                    layout_width -= int(math.ceil(date_layout.getWidth())) + AndroidUtilities.dp(12)
        return layout_width

    def _build_description_text(
        self,
        base_text: Any,
        size_text: str,
        ext_text: str,
        paint: Any,
        max_width: int,
        ext_inline: bool,
    ) -> Any:
        base_line = TextUtils.ellipsize(base_text if base_text is not None else "", paint, max_width, TextUtils.TruncateAt.END)
        size_line = TextUtils.ellipsize(size_text, paint, max_width, TextUtils.TruncateAt.END)
        if not ext_text:
            return TextUtils.concat(base_line, "\n", size_line)
        if ext_inline:
            bullet = " • "
            remaining = max_width - int(math.ceil(paint.measureText(str(size_line) + bullet)))
            if remaining <= 0:
                return TextUtils.concat(base_line, "\n", size_line)
            ext_line = TextUtils.ellipsize(ext_text, paint, remaining, TextUtils.TruncateAt.END)
        else:
            ext_line = TextUtils.ellipsize(ext_text, paint, max_width, TextUtils.TruncateAt.END)
        builder = SpannableStringBuilder()
        builder.append(base_line)
        builder.append("\n")
        builder.append(size_line)
        builder.append(" • " if ext_inline else "\n")
        start = builder.length()
        builder.append(ext_line)
        builder.setSpan(RelativeSizeSpan(0.9), start, builder.length(), 0)
        return builder

    def _should_show_info(self, is_voice: bool, is_music: bool) -> bool:
        if is_voice and not self.get_setting("show_voice_info", True):
            return False
        if is_music and not self.get_setting("show_audio_info", True):
            return False
        return True

    def _resolve_time_width_limit(self, available_width: int, background_width: int, fallback: int) -> int:
        widths = []
        if available_width > 0:
            widths.append(available_width)
        if background_width > 0:
            widths.append(background_width)
        if widths:
            return min(widths)
        return max(fallback, 0)

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        """Hook point for outgoing message; unused in this plugin."""
        return HookResult()

    def create_settings(self) -> list[Any]:
        """Plugin settings screen."""
        return [
            Header(text="Отображение"),
            Switch(
                key="show_voice_info",
                text="Показывать вес/расширение для голосовых",
                default=True,
            ),
            Switch(
                key="show_audio_info",
                text="Показывать вес/расширение для аудио",
                default=True,
            ),
            Divider(),
        ]
