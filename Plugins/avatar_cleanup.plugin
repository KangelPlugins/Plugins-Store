from base_plugin import BasePlugin
from client_utils import (
    send_request,
    RequestCallback,
    run_on_queue,
    get_last_fragment,
    get_messages_controller,
    get_user_config,
)
from android_utils import run_on_ui_thread, OnClickListener
from ui.bulletin import BulletinHelper
from ui.settings import Header, Input, Selector, Switch, Text, Divider
from ui.alert import AlertDialogBuilder
from hook_utils import find_class
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import AndroidUtilities, FileLoader, ImageLocation, LocaleController, R
from org.telegram.ui.ActionBar import Theme
from org.telegram.ui.Components import BackupImageView, LineProgressView
from java import dynamic_proxy
from java.util import ArrayList
from android.util import TypedValue
from android.view import Gravity, ViewGroup
from android.widget import HorizontalScrollView, LinearLayout, SeekBar, TextView

__id__ = "avatar_cleanup"
__name__ = "Avatar Cleanup"
__description__ = "Удаляет заданное количество ваших аватарок"
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "2.0 [avatar preview]"
__icon__ = "UtyaDuck/15"
__min_version__ = "11.12.0"

DEFAULT_COUNT = "3"
DEFAULT_ORDER = 0
DEFAULT_KEEP_CURRENT = True
DEFAULT_COOLDOWN_MS = "0"
PREVIEW_LIMIT = 10

LOCALIZATION = {
    "ru": {
        "plugin_description": "Удаляет заданное количество ваших аватарок через удобный интерфейс.",
        "settings_header": "Удаление аватарок",
        "count_label": "Сколько удалить",
        "count_subtext": "Укажите количество для удаления",
        "order_label": "Порядок",
        "order_newest": "Новые -> старые",
        "order_oldest": "Старые -> новые",
        "keep_current": "Не удалять текущую",
        "keep_current_subtext": "Оставляет активную аватарку",
        "cooldown_label": "Кулдаун между удалениями",
        "cooldown_subtext": "Задержка между запросами удаления (мс). 0 = без задержки",
        "open_panel": "Открыть панель очистки",
        "run_now": "Удалить сейчас",
        "warning": "Удаление необратимо - будьте осторожны.",
        "dialog_title": "Очистка аватарок",
        "dialog_info": "Всего: {total} | Доступно: {available}",
        "dialog_order": "Порядок: {order}",
        "dialog_keep": "Текущую сохранять: {value}",
        "dialog_cooldown": "Кулдаун: {ms} мс",
        "progress_text": "Удалено: {done}/{total}",
        "cooldown_wait": "Следующая через {sec} сек",
        "selected_count": "Выбрано: {count}",
        "preview_title": "Предпросмотр аватарок к удалению",
        "preview_loading": "Загружаем предпросмотр...",
        "preview_empty": "Не удалось загрузить предпросмотр",
        "preview_more": "+ еще {count}",
        "loading": "Загружаем список аватарок...",
        "deleting": "Удаляем аватарки...",
        "confirm_title": "Подтвердите удаление",
        "confirm_message": "Удалить {count} аватарок? Это действие необратимо.",
        "delete": "Удалить",
        "cancel": "Отмена",
        "nothing_to_delete": "Удалять нечего",
        "no_user": "Не удалось получить текущий аккаунт",
        "no_context": "Не удалось получить контекст",
        "request_error": "Ошибка запроса: {error}",
        "deleted_success": "Удалено аватарок: {count}",
        "invalid_count": "Некорректное число",
        "busy": "Операция уже выполняется",
        "yes": "да",
        "no": "нет",
    },
    "en": {
        "plugin_description": "Deletes a selected number of your avatars via a clean UI.",
        "settings_header": "Avatar cleanup",
        "count_label": "How many to delete",
        "count_subtext": "Enter the amount to remove",
        "order_label": "Order",
        "order_newest": "Newest -> oldest",
        "order_oldest": "Oldest -> newest",
        "keep_current": "Keep current",
        "keep_current_subtext": "Keeps the active avatar",
        "cooldown_label": "Cooldown between deletions",
        "cooldown_subtext": "Delay between delete requests (ms). 0 = no delay",
        "open_panel": "Open cleanup panel",
        "run_now": "Delete now",
        "warning": "Deletion is irreversible - be careful.",
        "dialog_title": "Avatar cleanup",
        "dialog_info": "Total: {total} | Available: {available}",
        "dialog_order": "Order: {order}",
        "dialog_keep": "Keep current: {value}",
        "dialog_cooldown": "Cooldown: {ms} ms",
        "progress_text": "Deleted: {done}/{total}",
        "cooldown_wait": "Next in {sec} sec",
        "selected_count": "Selected: {count}",
        "preview_title": "Preview of avatars to delete",
        "preview_loading": "Loading preview avatars...",
        "preview_empty": "Failed to load preview",
        "preview_more": "+ {count} more",
        "loading": "Loading avatar list...",
        "deleting": "Deleting avatars...",
        "confirm_title": "Confirm deletion",
        "confirm_message": "Delete {count} avatars? This action cannot be undone.",
        "delete": "Delete",
        "cancel": "Cancel",
        "nothing_to_delete": "Nothing to delete",
        "no_user": "Failed to get current account",
        "no_context": "Failed to get context",
        "request_error": "Request error: {error}",
        "deleted_success": "Deleted avatars: {count}",
        "invalid_count": "Invalid number",
        "busy": "Operation already running",
        "yes": "yes",
        "no": "no",
    },
}


class LocalizedText:
    def __init__(self, localization_map):
        self._map = localization_map

    def _lang(self):
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            if lang and str(lang).lower().startswith("ru"):
                return "ru"
        except Exception:
            pass
        return "en"

    def t(self, key):
        lang = self._lang()
        try:
            if lang in self._map and key in self._map[lang]:
                return self._map[lang][key]
            if "ru" in self._map and key in self._map["ru"]:
                return self._map["ru"][key]
            if "en" in self._map and key in self._map["en"]:
                return self._map["en"][key]
        except Exception:
            pass
        return key


_t = LocalizedText(LOCALIZATION).t


class AvatarCleanupPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._busy = False

    def on_plugin_load(self):
        try:
            self.description = _t("plugin_description")
        except Exception:
            pass

    def create_settings(self):
        return [
            Header(text=_t("settings_header")),
            Input(
                key="delete_count",
                text=_t("count_label"),
                default=DEFAULT_COUNT,
                subtext=_t("count_subtext"),
                icon="msg_delete",
                on_change=self._on_count_change,
            ),
            Selector(
                key="delete_order",
                text=_t("order_label"),
                default=DEFAULT_ORDER,
                items=[_t("order_newest"), _t("order_oldest")],
                icon="msg_list_solar",
            ),
            Switch(
                key="keep_current",
                text=_t("keep_current"),
                default=DEFAULT_KEEP_CURRENT,
                subtext=_t("keep_current_subtext"),
                icon="msg_openprofile_solar",
            ),
            Input(
                key="delete_cooldown_ms",
                text=_t("cooldown_label"),
                default=DEFAULT_COOLDOWN_MS,
                subtext=_t("cooldown_subtext"),
                icon="msg_contacts_time_solar",
                on_change=self._on_cooldown_change,
            ),
            Divider(),
            Text(
                text=_t("open_panel"),
                icon="msg_delete",
                accent=True,
                on_click=self._open_cleanup_dialog,
            ),
            Text(
                text=_t("run_now"),
                icon="msg_delete",
                red=True,
                on_click=self._run_from_settings,
            ),
            Divider(text=_t("warning")),
        ]

    def _on_count_change(self, value):
        count = self._parse_count(value)
        if count <= 0:
            self.set_setting("delete_count", DEFAULT_COUNT)
        else:
            self.set_setting("delete_count", str(count))

    def _parse_count(self, value):
        try:
            count = int(str(value).strip())
        except Exception:
            return 0
        return max(0, count)

    def _on_cooldown_change(self, value):
        cooldown_ms = self._parse_cooldown_ms(value)
        self.set_setting("delete_cooldown_ms", str(cooldown_ms))

    def _parse_cooldown_ms(self, value):
        try:
            cooldown_ms = int(str(value).strip())
        except Exception:
            return int(DEFAULT_COOLDOWN_MS)
        return max(0, min(cooldown_ms, 60000))

    def _open_cleanup_dialog(self, _=None):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return

        fragment = get_last_fragment()
        if not fragment:
            BulletinHelper.show_error(_t("no_context"))
            return
        context = fragment.getParentActivity()
        if not context:
            BulletinHelper.show_error(_t("no_context"))
            return

        loading = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        loading.set_title(_t("loading"))
        loading.show()

        def on_total(total, error):
            def show_dialog():
                try:
                    loading.dismiss()
                except Exception:
                    pass
                if error:
                    BulletinHelper.show_error(_t("request_error").format(error=error))
                    return
                self._show_cleanup_dialog(context, total)

            run_on_ui_thread(show_dialog)

        run_on_queue(lambda: self._fetch_total_photos(on_total))

    def _run_from_settings(self, _=None):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return

        fragment = get_last_fragment()
        if not fragment:
            BulletinHelper.show_error(_t("no_context"))
            return
        context = fragment.getParentActivity()
        if not context:
            BulletinHelper.show_error(_t("no_context"))
            return

        count = self._parse_count(self.get_setting("delete_count", DEFAULT_COUNT))
        if count <= 0:
            BulletinHelper.show_error(_t("invalid_count"))
            return

        order = self._get_order_setting()
        keep_current = self.get_setting("keep_current", DEFAULT_KEEP_CURRENT)
        cooldown_ms = self._get_cooldown_setting()
        self._confirm_delete(context, count, order, keep_current, cooldown_ms)

    def _show_cleanup_dialog(self, context, total):
        keep_current = self.get_setting("keep_current", DEFAULT_KEEP_CURRENT)
        order = self._get_order_setting()
        cooldown_ms = self._get_cooldown_setting()
        order_text = _t("order_newest") if order == 0 else _t("order_oldest")
        keep_text = _t("yes") if keep_current else _t("no")

        available = max(0, total - (1 if keep_current else 0))
        if available <= 0:
            BulletinHelper.show_info(_t("nothing_to_delete"))
            return

        initial_count = self._parse_count(self.get_setting("delete_count", DEFAULT_COUNT))
        if initial_count <= 0:
            initial_count = 1
        if initial_count > available:
            initial_count = available

        selected_count = [initial_count]
        preview_state = {"request_token": 0, "debounce_token": 0}
        plugin_self = self

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        padding_h = AndroidUtilities.dp(20)
        container.setPadding(padding_h, AndroidUtilities.dp(8), padding_h, AndroidUtilities.dp(12))

        info = TextView(context)
        info.setText(_t("dialog_info").format(total=total, available=available))
        info.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        info.setGravity(Gravity.START)
        try:
            info.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        meta = TextView(context)
        meta.setText(
            _t("dialog_order").format(order=order_text)
            + "\n"
            + _t("dialog_keep").format(value=keep_text)
            + "\n"
            + _t("dialog_cooldown").format(ms=cooldown_ms)
        )
        meta.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        meta.setGravity(Gravity.START)
        try:
            meta.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        count_view = TextView(context)
        count_view.setText(_t("selected_count").format(count=selected_count[0]))
        count_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
        count_view.setGravity(Gravity.START)
        try:
            count_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        except Exception:
            pass

        preview_title = TextView(context)
        preview_title.setText(_t("preview_title"))
        preview_title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        preview_title.setGravity(Gravity.START)
        try:
            preview_title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        preview_scroll = HorizontalScrollView(context)
        preview_scroll.setHorizontalScrollBarEnabled(False)
        preview_scroll.setFillViewport(True)

        preview_row = LinearLayout(context)
        preview_row.setOrientation(LinearLayout.HORIZONTAL)
        preview_scroll.addView(
            preview_row,
            LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT,
            ),
        )

        preview_more = TextView(context)
        preview_more.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        preview_more.setGravity(Gravity.START)
        preview_more.setVisibility(8)
        try:
            preview_more.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        def set_preview_loading():
            preview_title.setText(_t("preview_loading"))
            preview_more.setVisibility(8)
            preview_row.removeAllViews()

        def render_preview(photos, requested_count, request_token, _error_text=None):
            if request_token != preview_state["request_token"]:
                return

            preview_row.removeAllViews()

            if _error_text or not photos:
                preview_title.setText(_t("preview_empty"))
                preview_more.setVisibility(8)
                return

            preview_title.setText(_t("preview_title"))
            for photo in photos:
                thumb = BackupImageView(context)
                thumb.setRoundRadius(AndroidUtilities.dp(22))
                try:
                    thumb.getImageReceiver().setAllowLoadingOnAttachedOnly(False)
                except Exception:
                    pass

                try:
                    photo_size = self._get_preview_photo_size(photo)
                    if photo_size is not None:
                        location = ImageLocation.getForPhoto(photo_size, photo)
                        if location is not None:
                            stripped_bitmap = getattr(photo, "strippedBitmap", None)
                            if stripped_bitmap is not None:
                                thumb.setImage(location, "56_56", stripped_bitmap, 0, 1, photo)
                            else:
                                thumb.setImage(location, "56_56", None, 0, photo)
                except Exception:
                    pass

                thumb_lp = LinearLayout.LayoutParams(AndroidUtilities.dp(44), AndroidUtilities.dp(44))
                thumb_lp.setMargins(0, 0, AndroidUtilities.dp(8), 0)
                preview_row.addView(thumb, thumb_lp)

            hidden_count = max(0, requested_count - len(photos))
            if hidden_count > 0:
                preview_more.setText(_t("preview_more").format(count=hidden_count))
                preview_more.setVisibility(0)
            else:
                preview_more.setVisibility(8)

        def request_preview(count):
            preview_state["request_token"] += 1
            request_token = preview_state["request_token"]
            requested_count = min(max(1, int(count)), available)
            preview_limit = min(requested_count, PREVIEW_LIMIT)
            offset = self._calculate_offset(total, requested_count, order, keep_current)
            set_preview_loading()

            def on_photos(response, req_error):
                error_text = self._error_text(req_error) if req_error else None
                photos = [] if error_text else self._extract_photo_items(response)
                run_on_ui_thread(lambda: render_preview(photos, requested_count, request_token, error_text))

            run_on_queue(lambda: self._fetch_user_photos(offset, preview_limit, on_photos))

        def schedule_preview_update(count):
            preview_state["debounce_token"] += 1
            debounce_token = preview_state["debounce_token"]

            def trigger():
                if debounce_token != preview_state["debounce_token"]:
                    return
                request_preview(count)

            run_on_ui_thread(trigger, delay=120)

        seek = SeekBar(context)
        seek.setMax(available)
        seek.setProgress(selected_count[0])

        seek_listener_class = find_class("android.widget.SeekBar$OnSeekBarChangeListener")
        if seek_listener_class is not None:
            class _SeekListener(dynamic_proxy(seek_listener_class)):
                def onProgressChanged(self, bar, progress, _from_user):
                    if progress < 1:
                        bar.setProgress(1)
                        return
                    selected_count[0] = progress
                    count_view.setText(_t("selected_count").format(count=progress))
                    plugin_self.set_setting("delete_count", str(progress))
                    schedule_preview_update(progress)

                def onStartTrackingTouch(self, _bar):
                    pass

                def onStopTrackingTouch(self, _bar):
                    pass

            seek.setOnSeekBarChangeListener(_SeekListener())

        lp_full = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_block = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_block.setMargins(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(8))
        lp_preview_scroll = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            AndroidUtilities.dp(48),
        )
        lp_preview_scroll.setMargins(0, AndroidUtilities.dp(2), 0, AndroidUtilities.dp(6))

        container.addView(info, lp_full)
        container.addView(meta, lp_block)
        container.addView(count_view, lp_block)
        container.addView(seek, lp_full)
        container.addView(preview_title, lp_block)
        container.addView(preview_scroll, lp_preview_scroll)
        container.addView(preview_more, lp_full)

        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(_t("dialog_title"))
        builder.set_view(container)
        builder.set_positive_button(
            _t("delete"),
            lambda d, _w: (
                d.dismiss(),
                self._confirm_delete(context, selected_count[0], order, keep_current, cooldown_ms),
            ),
        )
        builder.set_negative_button(_t("cancel"), lambda d, _w: d.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        try:
            builder.set_blurred_background(True)
        except Exception:
            pass
        try:
            top_bg = Theme.getColor(Theme.key_dialogTopBackground)
            builder.set_top_image(R.drawable.msg_delete, top_bg)
        except Exception:
            pass
        builder.show()
        schedule_preview_update(selected_count[0])

    def _confirm_delete(self, context, count, order, keep_current, cooldown_ms):
        if count <= 0:
            BulletinHelper.show_error(_t("invalid_count"))
            return

        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(_t("confirm_title"))
        builder.set_message(_t("confirm_message").format(count=count))
        builder.set_positive_button(
            _t("delete"),
            lambda d, _w: (
                d.dismiss(),
                self._run_delete(context, count, order, keep_current, cooldown_ms),
            ),
        )
        builder.set_negative_button(_t("cancel"), lambda d, _w: d.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        try:
            top_bg = Theme.getColor(Theme.key_dialogTopBackground)
            builder.set_top_image(R.drawable.msg_delete, top_bg)
        except Exception:
            pass
        builder.show()

    def _run_delete(self, context, count, order, keep_current, cooldown_ms):
        if self._busy:
            BulletinHelper.show_info(_t("busy"))
            return

        self._busy = True
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        padding_h = AndroidUtilities.dp(20)
        container.setPadding(padding_h, AndroidUtilities.dp(8), padding_h, AndroidUtilities.dp(12))

        progress_text = TextView(context)
        progress_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        progress_text.setGravity(Gravity.START)
        try:
            progress_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        except Exception:
            pass

        progress_bar = LineProgressView(context)
        try:
            progress_bar.setProgressColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            progress_bar.setBackColor(Theme.getColor(Theme.key_dialogLineProgressBackground))
        except Exception:
            pass
        progress_bar.setProgress(0.0, False)

        countdown_text = TextView(context)
        countdown_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        countdown_text.setGravity(Gravity.START)
        try:
            countdown_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
        except Exception:
            pass

        lp_full = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp_full.setMargins(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6))
        lp_bar = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            AndroidUtilities.dp(6),
        )
        lp_bar.setMargins(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))

        container.addView(progress_text, lp_full)
        container.addView(progress_bar, lp_bar)
        container.addView(countdown_text, lp_full)

        progress_dialog = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        progress_dialog.set_title(_t("deleting"))
        progress_dialog.set_view(container)
        progress_dialog.set_cancelable(False)
        progress_dialog.show()

        progress_state = {"token": 0}

        def update_progress(done, total):
            def ui():
                progress_text.setText(_t("progress_text").format(done=done, total=total))
                if total > 0:
                    progress_bar.setProgress(float(done) / float(total), True)
            run_on_ui_thread(ui)

        def start_countdown(seconds):
            progress_state["token"] += 1
            token = progress_state["token"]
            seconds = max(0, int(seconds))

            def tick(remaining):
                if token != progress_state["token"]:
                    return
                if remaining <= 0:
                    countdown_text.setText("")
                    return
                countdown_text.setText(_t("cooldown_wait").format(sec=remaining))
                run_on_ui_thread(lambda: tick(remaining - 1), delay=1000)

            run_on_ui_thread(lambda: tick(seconds))

        def finish(message, success):
            def ui():
                try:
                    progress_state["token"] += 1
                    progress_dialog.dismiss()
                except Exception:
                    pass
                if success:
                    BulletinHelper.show_success(message)
                else:
                    BulletinHelper.show_error(message)
                self._busy = False

            run_on_ui_thread(ui)

        update_progress(0, count)
        start_countdown(0)
        run_on_queue(
            lambda: self._perform_delete(
                count,
                order,
                keep_current,
                cooldown_ms,
                finish,
                update_progress,
                start_countdown,
            )
        )

    def _perform_delete(self, count, order, keep_current, cooldown_ms, finish_cb, progress_cb=None, countdown_cb=None):
        def on_total(total, error):
            if error:
                finish_cb(_t("request_error").format(error=error), False)
                return

            available = max(0, total - (1 if keep_current else 0))
            if available <= 0:
                finish_cb(_t("nothing_to_delete"), False)
                return

            effective_count = min(count, available)
            offset = self._calculate_offset(total, effective_count, order, keep_current)

            def on_photos(response, req_error):
                if req_error:
                    finish_cb(_t("request_error").format(error=self._error_text(req_error)), False)
                    return

                photos = getattr(response, "photos", None)
                if photos is None or photos.size() == 0:
                    finish_cb(_t("nothing_to_delete"), False)
                    return

                input_photos = self._build_input_photos(photos)
                if not input_photos:
                    finish_cb(_t("nothing_to_delete"), False)
                    return

                total_to_delete = len(input_photos)
                if progress_cb:
                    progress_cb(0, total_to_delete)

                self._delete_in_batches(
                    input_photos,
                    cooldown_ms,
                    total_to_delete,
                    progress_cb,
                    countdown_cb,
                    lambda deleted, delete_error: (
                        finish_cb(_t("request_error").format(error=self._error_text(delete_error)), False)
                        if delete_error
                        else finish_cb(_t("deleted_success").format(count=deleted), True)
                    ),
                )

            self._fetch_user_photos(offset, effective_count, on_photos)

        self._fetch_total_photos(on_total)

    def _fetch_total_photos(self, callback):
        current_user = self._get_current_user()
        if not current_user:
            callback(0, _t("no_user"))
            return

        req = TLRPC.TL_photos_getUserPhotos()
        req.user_id = get_messages_controller().getInputUser(current_user)
        req.offset = 0
        req.max_id = 0
        req.limit = 1

        def on_response(response, error):
            if error:
                callback(0, self._error_text(error))
                return

            total = self._extract_total(response)
            callback(total, None)

        send_request(req, RequestCallback(on_response))

    def _fetch_user_photos(self, offset, limit, callback):
        current_user = self._get_current_user()
        if not current_user:
            callback(None, _t("no_user"))
            return

        req = TLRPC.TL_photos_getUserPhotos()
        req.user_id = get_messages_controller().getInputUser(current_user)
        req.offset = max(0, int(offset))
        req.max_id = 0
        req.limit = max(1, int(limit))

        send_request(req, RequestCallback(lambda response, error: callback(response, error)))

    def _extract_total(self, response):
        total = 0
        try:
            total = int(getattr(response, "count", 0))
        except Exception:
            total = 0
        if total <= 0:
            try:
                total = int(response.photos.size())
            except Exception:
                total = 0
        return max(0, total)

    def _extract_photo_items(self, response):
        photos = getattr(response, "photos", None)
        if photos is None:
            return []

        result = []
        try:
            size = int(photos.size())
        except Exception:
            size = 0

        for i in range(size):
            try:
                photo = photos.get(i)
                if photo is not None:
                    result.append(photo)
            except Exception:
                continue
        return result

    def _get_preview_photo_size(self, photo):
        if photo is None:
            return None

        sizes = getattr(photo, "sizes", None)
        if sizes is None:
            return None

        try:
            target_size = int(AndroidUtilities.dp(96))
        except Exception:
            target_size = 96

        try:
            selected = FileLoader.getClosestPhotoSizeWithSize(sizes, target_size, False, None, True)
            if selected is not None:
                return selected
        except Exception:
            pass

        try:
            selected = FileLoader.getClosestPhotoSizeWithSize(sizes, target_size)
            if selected is not None:
                return selected
        except Exception:
            pass

        try:
            size = int(sizes.size())
            if size > 0:
                return sizes.get(size - 1)
        except Exception:
            pass

        return None

    def _build_input_photos(self, photos):
        result = []
        try:
            size = photos.size()
        except Exception:
            size = 0
        for i in range(size):
            try:
                photo = photos.get(i)
                input_photo = TLRPC.TL_inputPhoto()
                input_photo.id = photo.id
                input_photo.access_hash = photo.access_hash
                input_photo.file_reference = photo.file_reference
                result.append(input_photo)
            except Exception:
                continue
        return result

    def _delete_in_batches(self, input_photos, cooldown_ms, total_count, progress_cb, countdown_cb, callback):
        def send_batch(start_index, deleted_count):
            if start_index >= len(input_photos):
                callback(deleted_count, None)
                return

            batch = input_photos[start_index:start_index + 1]
            req = TLRPC.TL_photos_deletePhotos()
            ids = ArrayList()
            for photo in batch:
                ids.add(photo)
            req.id = ids

            def on_response(_response, error):
                if error:
                    callback(deleted_count, error)
                    return
                new_deleted = deleted_count + len(batch)
                if progress_cb:
                    progress_cb(new_deleted, total_count)
                remaining = total_count - new_deleted
                if countdown_cb and cooldown_ms > 0 and remaining > 0:
                    seconds = int((int(cooldown_ms) + 999) / 1000)
                    countdown_cb(seconds)
                run_on_queue(
                    lambda: send_batch(start_index + 1, new_deleted),
                    delay=max(0, int(cooldown_ms)),
                )

            send_request(req, RequestCallback(on_response))

        send_batch(0, 0)

    def _calculate_offset(self, total, count, order, keep_current):
        if order == 0:
            return 1 if keep_current else 0
        return max(0, total - count)

    def _get_current_user(self):
        try:
            return get_user_config().getCurrentUser()
        except Exception:
            return None

    def _get_order_setting(self):
        try:
            return int(self.get_setting("delete_order", DEFAULT_ORDER))
        except Exception:
            return DEFAULT_ORDER

    def _get_cooldown_setting(self):
        return self._parse_cooldown_ms(self.get_setting("delete_cooldown_ms", DEFAULT_COOLDOWN_MS))

    def _error_text(self, error):
        if error is None:
            return ""
        try:
            return str(error.text)
        except Exception:
            return str(error)


plugin = AvatarCleanupPlugin()
