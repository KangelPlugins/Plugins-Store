from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment, send_message, run_on_queue
from hook_utils import find_class
from java import dynamic_proxy
from android_utils import run_on_ui_thread
from org.telegram.messenger import LocaleController
from markdown_utils import parse_markdown
import random
import time
from collections import Counter

# Powered by @AGeekApple
# Memory Match Game Plugin for exteraGram by @ApplePlugins

TextView = find_class("android.widget.TextView")
GridLayout = find_class("android.widget.GridLayout")
LinearLayout = find_class("android.widget.LinearLayout")
FrameLayout = find_class("android.widget.FrameLayout")
AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
Theme = find_class("org.telegram.ui.ActionBar.Theme")
Gravity = find_class("android.view.Gravity")
OnClickListenerInterface = find_class("android.view.View$OnClickListener")

__id__ = "memorymatch"
__name__ = "Memory Match"
__description__ = "–ü–µ—Ä–µ–≤–µ—Ä–Ω–∏—Ç–µ –∫–∞—Ä—Ç—ã, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –≤—Å–µ –ø–∞—Ä—ã!\n\n–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:\n‚Ä¢ –í –º–µ–Ω—é —á–∞—Ç–∞: –≤—ã–±–µ—Ä–∏—Ç–µ –ü–ª–∞–≥–∏–Ω—ã ‚Üí Memory Match\n‚Ä¢ –í –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–º –º–µ–Ω—é: –≤—ã–±–µ—Ä–∏—Ç–µ Memory Match –∏–∑ –ø–æ—è–≤–∏–≤—à–µ–≥–æ—Å—è –º–µ–Ω—é –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–∏\n\nby @ApplePlugins Lab ‚Ä¢ @exteraDevPlugins"
__author__ = "@AGeekApple"
__version__ = "1.0.2"
__min_version__ = "11.12.0"
__icon__ = "ApplePlugins/4"

EMOJI_SET = [
    "üçé","üçä","üçã","üçâ","üçá","üçì","üçí","üçç","ü•ù","üçë","ü••","üçà","ü•≠","üçå","üçê","üçè",
    "‚≠ê","üåô","‚òÄÔ∏è","‚ö°","üî•","üåà","‚ùÑÔ∏è","üíß","üå™Ô∏è","‚òÉÔ∏è","‚òî","üå§Ô∏è","üåßÔ∏è","üå•Ô∏è","üå´Ô∏è","üåª",
    "üçî","üçï","üå≠","üçø","üç©","üç™","üßÅ","üç´","üçü","üçú","üçù","üç£","üç§","üçô","üçõ","ü•™",
    "üê∂","üê±","üê≠","üêπ","üê∞","ü¶ä","üêª","üêº","üê®","üêØ","ü¶Å","üê∑","üê∏","üêô","ü¶ã","üêû",
    "üêî","ü¶Ñ","üê¢","üêç","ü¶ñ","üê¨","üê≥","üêü","ü¶Ö","ü¶â","ü¶Ñ","ü¶ì","ü¶í","üêò","ü¶î","ü¶ù",
    "‚öΩ","üèÄ","üèà","üéæ","üéØ","üé≤","üéÆ","üß©","üöó","üöÄ","‚úàÔ∏è","üö≤","üèùÔ∏è","üèîÔ∏è","üåã","üè∞",
    "üì±","üíª","‚åö","üéß","üì∑","üì∏","üé•","üé¨","üìÄ","üí°","üîã","üîå","üîë","üõ†Ô∏è","üß∞","üß™",
    "üòÄ","üòÉ","üòÑ","üòÅ","üòÜ","üòÖ","üòÇ","üôÇ","üòâ","üòé","üòç","üòò","üòú","ü§™","ü§©","ü§ó",
    "üíñ","üíô","üíö","üíõ","üíú","üñ§","ü§ç","ü§é","üí•","üí´","‚ú®","ü™Ñ","üîÆ","üßø","üïπÔ∏è","üéπ"
]

PLACEHOLDER = "‚ùî"

TRANSLATIONS = {
    "en": {
        "menu_title": "Memory Match",
        "game_title": "Memory Match",
        "btn_close": "Close",
        "btn_reset": "Reset",
        "win_title": "You won!",
        "win_message": "Play again?",
        "btn_yes": "Yes",
        "btn_no": "No",
        "share_button": "Share",
        "share_text": "I solved Memory Match!",
        "share_text_rank": "**Memory Match** completed!\n[üïî](5255971360965930740) Time: {time}\n[üé≤](5235588635885054955) Board: {shape}\n\n_Can you do better?_",
        "toast_copied": "Copied to clipboard"
    },
    "pt": {
        "menu_title": "Jogo da Mem√≥ria",
        "game_title": "Jogo da Mem√≥ria",
        "btn_close": "Fechar",
        "btn_reset": "Resetar",
        "win_title": "Voc√™ venceu!",
        "win_message": "Jogar novamente?",
        "btn_yes": "Sim",
        "btn_no": "N√£o",
        "share_button": "Compartilhar",
        "share_text": "Consegui resolver o Memory Match!",
        "share_text_rank": "**Memory Match** conclu√≠do!\n[üïî](5255971360965930740) Tempo: {time}\n[üé≤](5235588635885054955) Tabuleiro: {shape}\n\n_Consegue fazer melhor?_",
        "toast_copied": "Copiado para a √°rea de transfer√™ncia"
    },
    "es": {
        "menu_title": "Juego de Memoria",
        "game_title": "Juego de Memoria",
        "btn_close": "Cerrar",
        "btn_reset": "Reiniciar",
        "win_title": "¬°Ganaste!",
        "win_message": "¬øJugar de nuevo?",
        "btn_yes": "S√≠",
        "btn_no": "No",
        "share_button": "Compartir",
        "share_text": "¬°Resolv√≠ el Memory Match!",
        "share_text_rank": "**Memory Match** completado!\n[üïî](5255971360965930740) Tiempo: {time}\n[üé≤](5235588635885054955) Tablero: {shape}\n\n_¬øPuedes hacerlo mejor?_",
        "toast_copied": "Copiado al portapapeles"
    },
    "ru": {
        "menu_title": "–ò–≥—Ä–∞ –Ω–∞ –ø–∞–º—è—Ç—å",
        "game_title": "–ò–≥—Ä–∞ –Ω–∞ –ø–∞–º—è—Ç—å",
        "btn_close": "–ó–∞–∫—Ä—ã—Ç—å",
        "btn_reset": "–°–±—Ä–æ—Å",
        "win_title": "–í—ã –ø–æ–±–µ–¥–∏–ª–∏!",
        "win_message": "–°—ã–≥—Ä–∞—Ç—å –µ—â–µ?",
        "btn_yes": "–î–∞",
        "btn_no": "–ù–µ—Ç",
        "share_button": "–ü–æ–¥–µ–ª–∏—Ç—å—Å—è",
        "share_text": "–Ø –ø—Ä–æ—à—ë–ª Memory Match!",
        "share_text_rank": "**Memory Match** –∑–∞–≤–µ—Ä—à—ë–Ω!\n[üïî](5255971360965930740) –í—Ä–µ–º—è: {time}\n[üé≤](5235588635885054955) –ü–æ–ª–µ: {shape}\n\n_–°–º–æ–∂–µ—à—å –ª—É—á—à–µ?_",
        "toast_copied": "–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä"
    }
}

def _get_lang():
    try:
        lc = LocaleController.getInstance()
        info = getattr(lc, "currentLocaleInfo", None)
        code = None
        if info is not None:
            code = getattr(info, "shortName", None) or getattr(info, "language", None)
        if not code:
            cur = getattr(lc, "currentLocale", None)
            if cur and hasattr(cur, "getLanguage"):
                code = cur.getLanguage()
        if code:
            code = str(code).split('-')[0].lower()
            if code in TRANSLATIONS:
                return code
    except Exception:
        pass
    return "en"

def _t(key):
    lang = _get_lang()
    return TRANSLATIONS.get(lang, TRANSLATIONS['en']).get(key, TRANSLATIONS['en'].get(key, key))

def _format_duration(seconds: int) -> str:
    try:
        m = seconds // 60
        s = seconds % 60
        return f"{m:02d}:{s:02d}"
    except Exception:
        return str(seconds)



class CardClickListener(dynamic_proxy(OnClickListenerInterface)):
    def __init__(self, plugin, chat_id, r, c):
        super().__init__()
        self.plugin, self.chat_id, self.r, self.c = plugin, chat_id, r, c
    def onClick(self, view):
        self.plugin.on_card_click(self.chat_id, self.r, self.c)


class MemoryMatchGame:
    def __init__(self, rows=4, cols=6):
        self.rows, self.cols = rows, cols
        self.board = [["" for _ in range(cols)] for _ in range(rows)]
        self.visible = [[False for _ in range(cols)] for _ in range(rows)]
        self.matched = [[False for _ in range(cols)] for _ in range(rows)]
        self.first_pick = None
        self.started_at = None  # tempo come√ßa no primeiro clique
        self.generate_board()

    def generate_board(self):
        total_cards = self.rows * self.cols
        if total_cards % 2 != 0:
            raise ValueError("O tabuleiro deve ter um n√∫mero par de cartas")
        total_pairs = total_cards // 2
        pool = list(dict.fromkeys(EMOJI_SET))
        if total_pairs > len(pool):
            raise ValueError("N√£o h√° emojis suficientes para criar o tabuleiro")
        pair_values = random.sample(pool, total_pairs)
        symbols = pair_values * 2
        random.shuffle(symbols)
        idx = 0
        for r in range(self.rows):
            for c in range(self.cols):
                self.board[r][c] = symbols[idx]
                idx += 1

    def reveal_card(self, r, c):
        if self.matched[r][c] or self.visible[r][c]:
            return False
        if self.started_at is None:
            self.started_at = time.time()  # inicia timer na primeira a√ß√£o
        self.visible[r][c] = True
        return True

    def hide_cards(self, cards):
        for r,c in cards:
            self.visible[r][c] = False

    def match_cards(self, cards):
        for r,c in cards:
            self.matched[r][c] = True

    def all_matched(self):
        return all(all(row) for row in self.matched)

    def is_match(self, a,b):
        return self.board[a[0]][a[1]] == self.board[b[0]][b[1]]


class MemoryMatchPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.active_games = {}
        self.views = {}

    def on_plugin_load(self):
        # Menu do chat
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text=_t("menu_title"),
            icon="msg_media",
            on_click=self.show_game_dialog
        ))
        
        # Context menu das mensagens
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text=_t("menu_title"),
            icon="msg_media",
            on_click=self.show_game_dialog
        ))



    def show_game_dialog(self, context):
        chat_id = context.get("dialog_id")
        fragment = get_last_fragment()
        activity = fragment and fragment.getParentActivity()
        if not activity: 
            return

        game = MemoryMatchGame()
        self.active_games[chat_id] = game

        builder = AlertDialogBuilder(activity)
        builder.set_title(_t("game_title"))

        main = LinearLayout(activity)
        main.setOrientation(LinearLayout.VERTICAL)
        padding = AndroidUtilities.dp(16)
        main.setPadding(padding, padding, padding, padding)
        main.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))

        grid = GridLayout(activity)
        grid.setColumnCount(game.cols)
        grid.setRowCount(game.rows)
        grid.setAlignmentMode(GridLayout.ALIGN_BOUNDS)

        # Calcular tamanho adapt√°vel baseado no n√∫mero de colunas/linhas
        try:
            # Usar AndroidUtilities para obter informa√ß√µes da tela
            display_size = AndroidUtilities.displaySize
            screen_width = display_size.x if display_size else 1080
            screen_height = display_size.y if display_size else 1920
            
            # Usar 75% da largura da tela para o grid
            available_width = int(screen_width * 0.75)
            available_height = int(screen_height * 0.5)
            
            # Calcular tamanho ideal dos cards
            margin = AndroidUtilities.dp(4)
            total_margin_width = (game.cols + 1) * margin * 2
            total_margin_height = (game.rows + 1) * margin * 2
            
            card_width = (available_width - total_margin_width) // game.cols
            card_height = (available_height - total_margin_height) // game.rows
            
            # Usar o menor valor para manter cards quadrados
            size = min(card_width, card_height, AndroidUtilities.dp(64))
            size = max(size, AndroidUtilities.dp(36))  # tamanho m√≠nimo
            
            # Ajustar tamanho da fonte baseado no tamanho do card
            font_size = max(14, min(26, size // AndroidUtilities.dp(2)))
            
        except Exception:
            # Fallback para valores adaptativos baseados no grid
            base_size = AndroidUtilities.dp(52)
            if game.cols > 6 or game.rows > 4:
                base_size = AndroidUtilities.dp(42)
            if game.cols > 8 or game.rows > 6:
                base_size = AndroidUtilities.dp(36)
            
            size = base_size
            margin = AndroidUtilities.dp(3)
            font_size = max(16, min(24, size // AndroidUtilities.dp(2)))

        views = {}

        for r in range(game.rows):
            for c in range(game.cols):
                card = TextView(activity)
                params = GridLayout.LayoutParams(GridLayout.spec(r), GridLayout.spec(c))
                params.width = params.height = size
                params.setMargins(margin, margin, margin, margin)
                card.setLayoutParams(params)
                card.setText(PLACEHOLDER)
                card.setTextSize(font_size)
                card.setGravity(Gravity.CENTER)
                card.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
                card.setOnClickListener(CardClickListener(self, chat_id, r, c))
                grid.addView(card)
                views[(r,c)] = card

        wrapper = FrameLayout(activity)
        wrapper.addView(grid)
        total_width = game.cols * size + game.cols * margin * 2
        total_height = game.rows * size + game.rows * margin * 2
        frame_params = FrameLayout.LayoutParams(total_width, total_height)
        frame_params.gravity = Gravity.CENTER
        grid.setLayoutParams(frame_params)

        self.views[chat_id] = views
        main.addView(wrapper)

        def reset(b, w):
            b.dismiss()
            self.show_game_dialog({"dialog_id": chat_id})

        builder.set_negative_button(_t("btn_close"), lambda b,w: b.dismiss())
        builder.set_neutral_button(_t("btn_reset"), reset)
        builder.set_view(main)
        dialog = builder.show()
        game.dialog = dialog

    def on_card_click(self, chat_id, r, c):
        game = self.active_games.get(chat_id)
        views = self.views.get(chat_id)
        if not game or not views or getattr(game, "locked", False):
            return
        if not game.reveal_card(r, c):
            return
        views[(r,c)].setText(game.board[r][c])

        if game.first_pick is None:
            game.first_pick = (r,c)
            return

        second = (r,c)
        if game.is_match(game.first_pick, second):
            game.match_cards([game.first_pick, second])
            game.first_pick = None
            if game.all_matched():
                self.show_win_dialog(chat_id)
        else:
            a,b = game.first_pick, second
            game.locked = True

            def hide():
                if self.active_games.get(chat_id) is not game:
                    return
                game.hide_cards([a,b])
                views[a].setText(PLACEHOLDER)
                views[b].setText(PLACEHOLDER)
                game.first_pick = None
                game.locked = False

            run_on_ui_thread(hide, 900)

    def show_win_dialog(self, chat_id):
        fragment = get_last_fragment()
        activity = fragment and fragment.getParentActivity()
        if not activity: return

        builder = AlertDialogBuilder(activity)
        builder.set_title(_t("win_title"))
        builder.set_message(_t("win_message"))

        def restart(b, w):
            b.dismiss()
            self.show_game_dialog({"dialog_id": chat_id})

        def share(b, w):
            b.dismiss()  # Fechar o di√°logo primeiro
            game = self.active_games.get(chat_id)
            if not getattr(game, "started_at", None):
                elapsed = 0
            else:
                elapsed = int(time.time() - game.started_at)
            shape = f"{game.rows}x{game.cols}"
            msg = _t("share_text_rank").format(time=_format_duration(elapsed), shape=shape)
            
            try:
                # Usar markdown para formata√ß√£o
                parsed = parse_markdown(msg)
                params = {
                    "peer": chat_id,
                    "message": parsed.text,
                    "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                }
                run_on_queue(lambda: send_message(params))
            except Exception:
                # Fallback para mensagem simples se markdown falhar
                run_on_queue(lambda: send_message({"peer": chat_id, "message": msg}))

        # Reorganizar bot√µes: Share e Reset lado a lado, Close embaixo
        builder.set_positive_button(_t("share_button"), share)
        builder.set_neutral_button(_t("btn_reset"), restart)
        builder.set_negative_button(_t("btn_close"), lambda b,w: b.dismiss())
        builder.show()