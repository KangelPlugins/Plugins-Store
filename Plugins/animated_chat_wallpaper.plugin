"""
╭─────────────────────────────────────────────────────────────╮
│                                                             │
│  ███╗   ███╗ █████╗ ███╗   ██╗██████╗ ██████╗ ███████╗      │
│  ████╗ ████║██╔══██╗████╗  ██║██╔══██╗██╔══██╗██╔════╝      │
│  ██╔████╔██║███████║██╔██╗ ██║██║  ██║██████╔╝█████╗        │
│  ██║╚██╔╝██║██╔══██║██║╚██╗██║██║  ██║██╔══██╗██╔══╝        │
│  ██║ ╚═╝ ██║██║  ██║██║ ╚████║██████╔╝██║  ██║███████╗      │
│  ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚══════╝      │
│                                                             │
│         █████╗ ██╗                                          │
│        ██╔══██╗██║    ╭───────────────────╮                 │
│        ███████║██║    │© 2024-2025        │                 │
│        ██╔══██║██║    │Licensed Product   │                 │
│        ██║  ██║██║    │All Rights Reserved│                 │
│        ╚═╝  ╚═╝╚═╝    ╰───────────────────╯                 │
│                                                             │
│  ╭───────────────────────────────────────────────────────╮  │
│  │ Unauthorized use, reproduction or distribution        │  │
│  │ of this software is strictly prohibited               │  │
│  ╰───────────────────────────────────────────────────────╯  │
│                                                             │
╰─────────────────────────────────────────────────────────────╯
"""
#  /\_/\
# ( o.o )
#  > ^ <
# Кот, который починил утечку памяти. Мяу.

import traceback
from base_plugin import BasePlugin, MethodReplacement, MethodHook
from ui.settings import Header, Input, Divider, Text
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment
from hook_utils import find_class
from android_utils import log, run_on_ui_thread
from java import dynamic_proxy, jclass
from java.lang import Runnable, Integer
from android.view import View
from android.widget import FrameLayout
from android.os import Handler, Looper
import threading
import requests
from android.net import Uri
from android.graphics import Color
from android.graphics.drawable import BitmapDrawable
from org.telegram.messenger import ApplicationLoader, NotificationCenter
import hashlib
from urllib.parse import urlparse
import os
import time

# ВАЖНО ТУТ НАСТРЙКИ МОГУТ НАХУЙ НАЕБНУТЬ ВЕСЬ КЛИЕНТ, редактируем АКУРАТНО! 
VIDEO_URL = "https://github.com/sterepandopalcevsto/supreme-octo-palm-tree/raw/refs/heads/main/uOPpbAEGb8mZFYRQ.mp4"  # RAW MP4 URL
VIDEO_MUTE = True
VIDEO_LOOP = True
VIDEO_ENABLED = True
LOCAL_FILE_NAME = "uOPpbAEGb8mZFYRQ.mp4"
PREFETCH_ON_LOAD = True
TARGET_FPS = 9
PREFERRED_BITRATE = 60000  # ~0.06 Mbps
USE_TEXTURE_VIEW = False  # Prefer SurfaceView for stability on some devices
HOOK_PLAYER_ERROR = True  # Hook error lambda to avoid delegate NPE
HOOK_INTERNAL_CALLBACKS = False  # Do NOT hook per-frame/player callbacks (prevents FPS overhead)
HOOK_STATE_GUARD = False  # Disabled by default to avoid interfering with chat video playback


def _acw_sanitize_filename_from_url(url: str):
    try:
        path = urlparse(url or "").path or ""
        name = path.split("/")[-1] or ""
        if not name:
            name = hashlib.md5((url or "").encode("utf-8")).hexdigest() + ".mp4"
        # allow alnum, dash, underscore, dot
        name = "".join(c for c in name if c.isalnum() or c in ("-", "_", "."))
        if len(name) < 3:
            name = hashlib.md5((url or "").encode("utf-8")).hexdigest() + ".mp4"
        return name
    except Exception:
        return "acw_" + str(abs(hash(url or ""))) + ".mp4"


def _acw_get_local_file_for_url(ctx, url: str):
    try:
        FileCls = jclass("java.io.File")
        cache_dir = ctx.getCacheDir()
        fname = _acw_sanitize_filename_from_url(url)
        return FileCls(cache_dir, fname)
    except Exception:
        return None

__id__ = "animated_chat_wallpaper"
__name__ = "AnimatedChatWallpaper"
__description__ = "Set MP4 URL as animated chat wallpaper"
__author__ = """MandreAI & СвагаНеТута
@swagnonher & @MandreAI_bot"""
__min_version__ = "11.12.0"
__icon__ = "exteraPlugins/0"
__version__ = "1.1"


class AnimatedChatWallpaperPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._chat_resume_ref = None
        self._chat_pause_ref = None
        self._chat_destroy_ref = None
        self._chat_create_view_ref = None
        # Internal VideoPlayer hooks refs (to guard against null delegate callbacks)
        self._vp_tex_hook_ref = None
        self._vp_state_hook_ref = None
        self._vp_size_hook_ref = None
        self._vp_first_frame_hook_ref = None
        self._vp_error_hook_ref = None
        self._vp_error_lambda_hook_ref = None
        # Settings keys and cached values
        self.SETTINGS_URL_KEY = "acw_video_url"
        self.SETTINGS_REPO_KEY = "acw_repo_url"
        self.SETTINGS_FPS_KEY = "acw_target_fps"
        self.SETTINGS_BITRATE_KEY = "acw_preferred_bitrate"
        self._cached_url = VIDEO_URL
        self._cached_fps = TARGET_FPS
        self._cached_bitrate = PREFERRED_BITRATE
        self._vp_state_hook_ref = None
        # Global reusable holder to avoid codec churn across chats
        self._global_holder = None

    def on_plugin_load(self):
        # Load settings persisted values and sync runtime variables
        try:
            self._load_settings()
        except Exception:
            pass
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                log("[ACW] ChatActivity not found")
                return
            # Hook ChatActivity.onResume/onPause/onFragmentDestroy to manage player
            on_resume = ChatActivity.getClass().getDeclaredMethod("onResume")
            on_resume.setAccessible(True)
            self._chat_resume_ref = self.hook_method(on_resume, _ChatResumeHook(self))

            on_pause = ChatActivity.getClass().getDeclaredMethod("onPause")
            on_pause.setAccessible(True)
            self._chat_pause_ref = self.hook_method(on_pause, _ChatPauseHook(self))

            on_destroy = ChatActivity.getClass().getDeclaredMethod("onFragmentDestroy")
            on_destroy.setAccessible(True)
            self._chat_destroy_ref = self.hook_method(on_destroy, _ChatDestroyHook(self))
            # Hook onActivityResult to capture file picker selection
            try:
                IntentCls = find_class("android.content.Intent")
                on_activity_result = ChatActivity.getClass().getDeclaredMethod("onActivityResult", Integer.TYPE, Integer.TYPE, IntentCls)
                on_activity_result.setAccessible(True)
                self._chat_activity_result_ref = self.hook_method(on_activity_result, _ChatActivityResultHook(self))
            except Exception:
                pass
            # Also hook view creation to attach earlier
            try:
                ContextClass = find_class("android.content.Context")
                create_view = ChatActivity.getClass().getDeclaredMethod("createView", ContextClass)
                create_view.setAccessible(True)
                self._chat_create_view_ref = self.hook_method(create_view, _ChatCreateViewHook(self))
            except Exception:
                pass
            log("[ACW] Hooks installed for ChatActivity lifecycle + createView")
        except Exception:
            log(f"[ACW] Failed to hook ChatActivity lifecycle: {traceback.format_exc()}")

        # Also hook LaunchActivity.onActivityResult to ensure picker results are captured reliably
        try:
            LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
            if LaunchActivity:
                IntentCls = find_class("android.content.Intent")
                IntegerType = find_class("java.lang.Integer").TYPE
                on_activity_result = LaunchActivity.getClass().getDeclaredMethod("onActivityResult", IntegerType, IntegerType, IntentCls)
                on_activity_result.setAccessible(True)
                self._root_activity_result_ref = self.hook_method(on_activity_result, _RootActivityResultHook(self))
                log("[ACW] Hooked LaunchActivity.onActivityResult for video picker")
        except Exception:
            pass

        # Hook Theme.getCachedWallpaper to reflect current animated wallpaper on photo tile using a preview frame
        try:
            ThemeClass = find_class("org.telegram.ui.ActionBar.Theme").getClass()
            get_cached_wallpaper_method = ThemeClass.getDeclaredMethod("getCachedWallpaper")
            get_cached_wallpaper_method.setAccessible(True)
            self._wallpaper_hook_ref = self.hook_method(get_cached_wallpaper_method, WallpaperOverrideHook(self))
            log("[ACW] Hooked Theme.getCachedWallpaper for preview tile")
        except Exception:
            pass

        # Guard player state reporting to avoid null delegate NPE seen on first re-entry
        if True and HOOK_STATE_GUARD:
            try:
                VPObj = find_class("org.telegram.ui.Components.VideoPlayer")
                VPClass = VPObj.getClass() if hasattr(VPObj, "getClass") else VPObj
                m = VPClass.getDeclaredMethod("maybeReportPlayerState")
                m.setAccessible(True)
                self._vp_state_hook_ref = self.hook_method(m, _VideoPlayerStateHook())
                # Also guard size/first-frame callbacks which may dereference delegate
                try:
                    m2 = VPClass.getDeclaredMethod("onVideoSizeChanged", jclass("com.google.android.exoplayer2.video.VideoSize"))
                    m2.setAccessible(True)
                    self._vp_size_hook_ref = self.hook_method(m2, _VideoPlayerSizeHook())
                except Exception:
                    pass
                try:
                    m3 = VPClass.getDeclaredMethod("onRenderedFirstFrame")
                    m3.setAccessible(True)
                    self._vp_first_frame_hook_ref = self.hook_method(m3, _VideoPlayerFirstFrameHook())
                except Exception:
                    pass
                log("[ACW] Hooked player guards (state/size/first-frame)")
            except Exception:
                pass

        # Hook internal player callbacks only when explicitly enabled (avoid interfering with Telegram players)
        if HOOK_INTERNAL_CALLBACKS:
            try:
                VPObj = find_class("org.telegram.ui.Components.VideoPlayer")
                VPClass = VPObj.getClass() if hasattr(VPObj, "getClass") else VPObj
                for name, hook in [
                    ("onSurfaceTextureUpdated", _VideoPlayerTexUpdateHook()),
                    ("maybeReportPlayerState", _VideoPlayerStateHook()),
                    ("onRenderedFirstFrame", _VideoPlayerFirstFrameHook()),
                ]:
                    try:
                        if name == "onSurfaceTextureUpdated":
                            m = VPClass.getDeclaredMethod(name, jclass("android.graphics.SurfaceTexture"))
                        else:
                            m = VPClass.getDeclaredMethod(name)
                        m.setAccessible(True)
                        self.hook_method(m, hook)
                    except Exception:
                        pass
                try:
                    m = VPClass.getDeclaredMethod("onVideoSizeChanged", jclass("com.google.android.exoplayer2.video.VideoSize"))
                    m.setAccessible(True)
                    self.hook_method(m, _VideoPlayerSizeHook())
                except Exception:
                    pass
                try:
                    m = VPClass.getDeclaredMethod("onSurfaceDestroyed", jclass("android.graphics.SurfaceTexture"))
                    m.setAccessible(True)
                    self.hook_method(m, _VideoPlayerSurfaceDestroyedHook())
                except Exception:
                    pass
                try:
                    m = VPClass.getDeclaredMethod("onPlayerError", jclass("com.google.android.exoplayer2.PlaybackException"))
                    m.setAccessible(True)
                    self.hook_method(m, _VideoPlayerOnErrorLogHook())
                except Exception:
                    pass
                if HOOK_PLAYER_ERROR:
                    try:
                        m = VPClass.getDeclaredMethod("lambda$onPlayerError$1", jclass("com.google.android.exoplayer2.PlaybackException"))
                        m.setAccessible(True)
                        self.hook_method(m, _VideoPlayerErrorLambdaHook())
                    except Exception:
                        try:
                            m = VPClass.getDeclaredMethod("lambda$onPlayerError$1")
                            m.setAccessible(True)
                            self.hook_method(m, _VideoPlayerErrorLambdaHook())
                        except Exception:
                            pass
                log("[ACW] Hooked internal VideoPlayer callbacks (opt-in)")
            except Exception:
                pass

        # Prefetch video into local storage right after plugin install/load
        if PREFETCH_ON_LOAD:
            try:
                ApplicationLoader = jclass("org.telegram.messenger.ApplicationLoader")
                FileCls = jclass("java.io.File")
                ctx = ApplicationLoader.applicationContext
                cache_dir = ctx.getCacheDir()
                local_file = FileCls(cache_dir, LOCAL_FILE_NAME)
                def _prefetch():
                    try:
                        # Skip if already downloaded
                        if local_file.exists() and local_file.length() > 0:
                            log("[ACW] Prefetch: local file already present")
                            return
                        dest_path = local_file.getAbsolutePath()
                        log(f"[ACW] Prefetch: downloading to {dest_path}")
                        r = requests.get(VIDEO_URL, stream=True, timeout=60)
                        r.raise_for_status()
                        with open(dest_path, "wb") as f:
                            for chunk in r.iter_content(1024 * 256):
                                if chunk:
                                    f.write(chunk)
                        log("[ACW] Prefetch: download complete")
                    except Exception:
                        log(f"[ACW] Prefetch failed: {traceback.format_exc()}")
                threading.Thread(target=_prefetch, daemon=True).start()
            except Exception:
                log(f"[ACW] Prefetch setup failed: {traceback.format_exc()}")

    def create_settings(self):
        try:
            url = self.get_setting(self.SETTINGS_URL_KEY, VIDEO_URL)
            fps = str(self.get_setting(self.SETTINGS_FPS_KEY, TARGET_FPS))
            bitrate = str(self.get_setting(self.SETTINGS_BITRATE_KEY, PREFERRED_BITRATE))
        except Exception:
            url = VIDEO_URL
            fps = str(TARGET_FPS)
            bitrate = str(PREFERRED_BITRATE)
        return [
            Header("Animated Chat Wallpaper"),
            Input(
                "video_url",
                "RAW видео URL",
                default=url,
                icon="msg_video",
                subtext="Укажите прямую RAW-ссылку на MP4/WEBM. Пример: https://github.com/<user>/<repo>/raw/<branch>/file.mp4",
                on_change=self._on_url_change,
            ),
            Divider(),
            Input(
                "repo_url",
                "Repository (GitHub)",
                default=self.get_setting(self.SETTINGS_REPO_KEY, ""),
                icon="msg_info",
                subtext="Например: https://github.com/user/repo/tree/main/path",
                on_change=self._on_repo_url_change,
            ),
            Text(text="Browse repo videos", icon="msg_video", on_click=lambda _: self._open_repo_dialog()),
            Divider(),
            Text(text="Pick local video file", icon="msg_attach", on_click=lambda _: self._open_system_file_picker()),
            Divider(),
            Input(
                "target_fps",
                "Ориентирный FPS",
                default=fps,
                icon="msg_speed",
                subtext="Чем ниже FPS, тем меньше нагрузка и расход батареи. Реальная частота зависит от устройства.",
                on_change=self._on_fps_change,
            ),
            Divider(),
            Input(
                "preferred_bitrate",
                "Ориентирный битрейт (bps)",
                default=bitrate,
                icon="msg_info",
                subtext="Верхний лимит пиковой скорости потока/декодирования. Фактический битрейт зависит от источника и устройства.",
                on_change=self._on_bitrate_change,
            ),
        ]

    def _load_settings(self):
        global VIDEO_URL, TARGET_FPS, PREFERRED_BITRATE
        try:
            if self.get_setting(self.SETTINGS_URL_KEY, None) is None:
                self.set_setting(self.SETTINGS_URL_KEY, VIDEO_URL)
            if self.get_setting(self.SETTINGS_FPS_KEY, None) is None:
                self.set_setting(self.SETTINGS_FPS_KEY, TARGET_FPS)
            if self.get_setting(self.SETTINGS_BITRATE_KEY, None) is None:
                self.set_setting(self.SETTINGS_BITRATE_KEY, PREFERRED_BITRATE)
        except Exception:
            pass
        try:
            self._cached_url = self.get_setting(self.SETTINGS_URL_KEY, VIDEO_URL)
            self._cached_fps = int(self.get_setting(self.SETTINGS_FPS_KEY, TARGET_FPS))
            self._cached_bitrate = int(self.get_setting(self.SETTINGS_BITRATE_KEY, PREFERRED_BITRATE))
            VIDEO_URL = self._cached_url
            TARGET_FPS = self._cached_fps
            PREFERRED_BITRATE = self._cached_bitrate
            log(f"[ACW] Settings loaded: url={VIDEO_URL}, fps={TARGET_FPS}, bitrate={PREFERRED_BITRATE}")
        except Exception:
            pass

    def _get_active_holder(self):
        try:
            return getattr(self, "_global_holder", None)
        except Exception:
            return None

    def _on_url_change(self, value: str):
        global VIDEO_URL
        try:
            url = (value or "").strip()
            self.set_setting(self.SETTINGS_URL_KEY, url)
            VIDEO_URL = url
            self._cached_url = url
            log(f"[ACW] URL updated via settings: {url}")
        except Exception:
            pass
        # Immediately apply updated URL to the active holder/player
        try:
            holder = self._get_active_holder()
            if holder is not None:
                def run():
                    try:
                        if holder.ensure_attached():
                            try:
                                holder.pause()
                                if holder.container is not None:
                                    holder.container.setAlpha(0.0)
                            except Exception:
                                pass
                            if holder.ensure_player(self._cached_url, bool(VIDEO_MUTE), bool(VIDEO_LOOP)):
                                try:
                                    holder.player.setPlayWhenReady(True)
                                    holder.player.seekTo(0)
                                    holder.player.play()
                                    try:
                                        if holder.container is not None:
                                            holder.container.setAlpha(1.0)
                                    except Exception:
                                        pass
                                    log("[ACW] Applied new URL and restarted playback")
                                except Exception:
                                    pass
                    except Exception:
                        pass
                run_on_ui_thread(run)
        except Exception:
            pass

    def _on_repo_url_change(self, value: str):
        try:
            repo = (value or "").strip()
            self.set_setting(self.SETTINGS_REPO_KEY, repo)
        except Exception:
            pass

    def _open_repo_dialog(self):
        try:
            repo = self.get_setting(self.SETTINGS_REPO_KEY, "")
            activity = None
            try:
                frag = get_last_fragment()
                if frag is not None:
                    activity = frag.getParentActivity()
            except Exception:
                activity = None
            if activity is None:
                return
            api_url = self._resolve_repo_api_url(repo)
            items = []
            urls = []
            try:
                if api_url:
                    r = requests.get(api_url, timeout=15)
                    r.raise_for_status()
                    data = r.json()
                    for entry in data:
                        try:
                            name = entry.get("name", "")
                            dl = entry.get("download_url", "")
                            if not dl:
                                html_url = entry.get("html_url", "")
                                if html_url and name:
                                    dl = html_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
                            if name.lower().endswith((".mp4", ".webm")) and dl:
                                items.append(name)
                                urls.append(dl)
                        except Exception:
                            pass
            except Exception:
                items = []
                urls = []
            builder = AlertDialogBuilder(activity)
            builder.set_title("Repo videos")
            if items:
                def on_select(b, which: int):
                    try:
                        sel = urls[which]
                        self._on_url_change(sel)
                    except Exception:
                        pass
                builder.set_items(items, on_select)
            else:
                builder.set_message("No mp4/webm found")
            builder.set_negative_button("Close")
            builder.show()
        except Exception:
            pass

    def _resolve_repo_api_url(self, repo_url: str):
        try:
            u = (repo_url or "").strip()
            if not u:
                return None
            if "api.github.com/repos" in u:
                return u
            p = urlparse(u)
            if p.netloc.endswith("github.com"):
                parts = [x for x in p.path.split("/") if x]
                if len(parts) >= 2:
                    owner, repo = parts[0], parts[1]
                    ref = "main"
                    path = ""
                    if len(parts) >= 4 and parts[2] == "tree":
                        ref = parts[3]
                        if len(parts) > 4:
                            path = "/".join(parts[4:])
                    api = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}?ref={ref}"
                    return api
            return None
        except Exception:
            return None

    def _open_system_file_picker(self):
        try:
            frag = get_last_fragment()
            activity = frag.getParentActivity() if frag is not None else None
            if activity is None:
                return
            Intent = jclass("android.content.Intent")
            # Prefer ACTION_OPEN_DOCUMENT for persistable permissions; fallback to GET_CONTENT/PICK
            intent = Intent(Intent.ACTION_OPEN_DOCUMENT)
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            intent.setType("video/*")
            try:
                intent.addFlags(getattr(Intent, "FLAG_GRANT_READ_URI_PERMISSION", 1))
                intent.addFlags(getattr(Intent, "FLAG_GRANT_PERSISTABLE_URI_PERMISSION", 0x00000040))
            except Exception:
                pass
            try:
                # Prefer fragment to receive result
                if frag is not None:
                    frag.startActivityForResult(intent, 7788)
                else:
                    activity.startActivityForResult(intent, 7788)
            except Exception:
                # Fallback: ACTION_GET_CONTENT
                try:
                    fallback = Intent(Intent.ACTION_GET_CONTENT)
                    fallback.addCategory(Intent.CATEGORY_OPENABLE)
                    fallback.setType("video/*")
                    try:
                        fallback.addFlags(getattr(Intent, "FLAG_GRANT_READ_URI_PERMISSION", 1))
                    except Exception:
                        pass
                    if frag is not None:
                        frag.startActivityForResult(fallback, 7788)
                    else:
                        activity.startActivityForResult(fallback, 7788)
                except Exception:
                    # Last resort: ACTION_PICK
                    try:
                        pick = Intent(Intent.ACTION_PICK)
                        pick.setType("video/*")
                        if frag is not None:
                            frag.startActivityForResult(pick, 7788)
                        else:
                            activity.startActivityForResult(pick, 7788)
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            holder = self._get_active_holder()
            if holder is not None and holder.player is not None:
                def run():
                    try:
                        if holder.ensure_attached():
                            # Pause wallpaper while user interacts with a chat video
                            try:
                                holder.pause()
                                if holder.container is not None:
                                    holder.container.setAlpha(0.0)
                            except Exception:
                                pass
                            if holder.ensure_player(self._cached_url, bool(VIDEO_MUTE), bool(VIDEO_LOOP)):
                                try:
                                    holder.player.setPlayWhenReady(True)
                                    holder.player.seekTo(0)
                                    holder.player.play()
                                    log("[ACW] Applied new URL and restarted playback")
                                except Exception:
                                    pass
                    except Exception:
                        pass
                run_on_ui_thread(run)
        except Exception:
            pass

    def _on_fps_change(self, value: str):
        global TARGET_FPS
        try:
            fps = int(str(value).strip())
            if fps <= 0 or fps > 120:
                raise ValueError()
            self.set_setting(self.SETTINGS_FPS_KEY, fps)
            TARGET_FPS = fps
            self._cached_fps = fps
            log(f"[ACW] Target FPS updated via settings: {fps}")
        except Exception:
            try:
                self.set_setting("target_fps", str(self._cached_fps))
            except Exception:
                pass
        try:
            holder = self._get_active_holder()
            if holder is not None:
                def run():
                    try:
                        # Apply max FPS constraint via TrackSelector when available
                        if holder.player is not None:
                            cls = holder.player.getClass() if hasattr(holder.player, 'getClass') else None
                            if cls is not None:
                                try:
                                    f = cls.getDeclaredField("trackSelector")
                                    f.setAccessible(True)
                                    trackSelector = f.get(holder.player)
                                    if trackSelector is not None:
                                        params = trackSelector.getParameters()
                                        builder = params.buildUpon()
                                        try:
                                            builder.setMaxVideoFrameRate(int(self._cached_fps))
                                        except Exception:
                                            pass
                                        try:
                                            builder.setExceedVideoConstraintsIfNecessary(True)
                                        except Exception:
                                            pass
                                        try:
                                            trackSelector.setParameters(builder.build())
                                            log(f"[ACW] Applied new max FPS: {self._cached_fps}")
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    except Exception:
                        pass
                run_on_ui_thread(run)
        except Exception:
            pass

    def _handle_picked_uri(self, data_uri, intent):
        try:
            # Persist read permission if available
            try:
                frag = get_last_fragment()
                activity = frag.getParentActivity() if frag is not None else None
                if activity is not None:
                    flags = intent.getFlags() if intent is not None else 0
                    IntentCls = jclass("android.content.Intent")
                    read_flag = getattr(IntentCls, "FLAG_GRANT_READ_URI_PERMISSION", 1)
                    persist_flag = getattr(IntentCls, "FLAG_GRANT_PERSISTABLE_URI_PERMISSION", 0x00000040)
                    activity.getContentResolver().takePersistableUriPermission(data_uri, flags & (read_flag | persist_flag))
            except Exception:
                pass
            # Convert content URI to a file path or copy to cache
            ctx = ApplicationLoader.applicationContext
            path = None
            try:
                # Try direct path from content resolver
                cr = ctx.getContentResolver()
                cursor = cr.query(data_uri, ["_data"], None, None, None)
                if cursor is not None:
                    try:
                        if cursor.moveToFirst():
                            path = cursor.getString(0)
                    finally:
                        cursor.close()
            except Exception:
                path = None
            if not path:
                # Copy to cache and use file:// URI
                try:
                    ins = ctx.getContentResolver().openInputStream(data_uri)
                    if ins is not None:
                        cache_dir = ctx.getCacheDir()
                        FileCls = jclass("java.io.File")
                        out_file = FileCls(cache_dir, f"acw_{int(time.time())}.mp4")
                        # Use Python-side buffered copy for robustness
                        with open(out_file.getAbsolutePath(), "wb") as py_out:
                            buf = bytearray(1024 * 64)
                            while True:
                                count = ins.read(buf)
                                if count is None:
                                    break
                                if int(count) <= 0:
                                    break
                                py_out.write(buf[:int(count)])
                        try:
                            ins.close()
                        except Exception:
                            pass
                        path = out_file.getAbsolutePath()
                except Exception:
                    path = None
            # Use file path or content URI string
            if path and len(str(path)) > 0:
                uri = jclass("android.net.Uri").fromFile(jclass("java.io.File")(path))
                self._on_url_change(str(uri.toString()))
            else:
                self._on_url_change(str(data_uri.toString()))
            # Refresh wallpaper preview tile
            try:
                self._force_wallpaper_refresh()
            except Exception:
                pass
        except Exception:
            pass

    def _on_bitrate_change(self, value: str):
        global PREFERRED_BITRATE
        try:
            br = int(str(value).strip())
            if br < 10000:
                br = 10000
            self.set_setting(self.SETTINGS_BITRATE_KEY, br)
            PREFERRED_BITRATE = br
            self._cached_bitrate = br
            log(f"[ACW] Preferred bitrate updated via settings: {br}")
        except Exception:
            try:
                self.set_setting("preferred_bitrate", str(self._cached_bitrate))
            except Exception:
                pass
        try:
            holder = self._get_active_holder()
            if holder is not None and holder.player is not None:
                def run():
                    try:
                        # Apply max bitrate via TrackSelector when available
                        if holder.player is not None:
                            cls = holder.player.getClass() if hasattr(holder.player, 'getClass') else None
                            if cls is not None:
                                try:
                                    f = cls.getDeclaredField("trackSelector")
                                    f.setAccessible(True)
                                    trackSelector = f.get(holder.player)
                                    if trackSelector is not None:
                                        params = trackSelector.getParameters()
                                        builder = params.buildUpon()
                                        try:
                                            builder.setMaxVideoBitrate(int(self._cached_bitrate))
                                        except Exception:
                                            pass
                                        try:
                                            builder.setExceedVideoConstraintsIfNecessary(True)
                                        except Exception:
                                            pass
                                        try:
                                            trackSelector.setParameters(builder.build())
                                            log(f"[ACW] Applied new max bitrate: {self._cached_bitrate}")
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                        # Fallback hint for builds without TrackSelector methods
                        try:
                            holder.player.setPreferredPeakBitrate(int(self._cached_bitrate))
                        except Exception:
                            pass
                    except Exception:
                        pass
                run_on_ui_thread(run)
        except Exception:
            pass

    def on_plugin_unload(self):
        try:
            if self._chat_resume_ref:
                self.unhook_method(self._chat_resume_ref)
                self._chat_resume_ref = None
        except Exception:
            pass
        try:
            if self._chat_pause_ref:
                self.unhook_method(self._chat_pause_ref)
                self._chat_pause_ref = None
        except Exception:
            pass
        try:
            if self._chat_destroy_ref:
                self.unhook_method(self._chat_destroy_ref)
                self._chat_destroy_ref = None
        except Exception:
            pass
        try:
            if self._chat_create_view_ref:
                self.unhook_method(self._chat_create_view_ref)
                self._chat_create_view_ref = None
        except Exception:
            pass
        try:
            if self._vp_tex_hook_ref:
                self.unhook_method(self._vp_tex_hook_ref)
                self._vp_tex_hook_ref = None
        except Exception:
            pass
        try:
            if self._vp_state_hook_ref:
                self.unhook_method(self._vp_state_hook_ref)
                self._vp_state_hook_ref = None
        except Exception:
            pass
        try:
            if self._vp_size_hook_ref:
                self.unhook_method(self._vp_size_hook_ref)
                self._vp_size_hook_ref = None
        except Exception:
            pass
        try:
            if self._vp_first_frame_hook_ref:
                self.unhook_method(self._vp_first_frame_hook_ref)
                self._vp_first_frame_hook_ref = None
        except Exception:
            pass
        try:
            if self._vp_error_hook_ref:
                self.unhook_method(self._vp_error_hook_ref)
                self._vp_error_hook_ref = None
        except Exception:
            pass
        try:
            if self._vp_error_lambda_hook_ref:
                self.unhook_method(self._vp_error_lambda_hook_ref)
                self._vp_error_lambda_hook_ref = None
        except Exception:
            pass
        try:
            if getattr(self, '_vp_surface_destroy_hook_ref', None):
                self.unhook_method(self._vp_surface_destroy_hook_ref)
                self._vp_surface_destroy_hook_ref = None
        except Exception:
            pass
        # Release global holder/player
        try:
            if self._global_holder is not None:
                try:
                    self._global_holder.release()
                except Exception:
                    pass
                self._global_holder = None
        except Exception:
            pass
        try:
            if getattr(self, '_vp_error_log_ref', None):
                self.unhook_method(self._vp_error_log_ref)
                self._vp_error_log_ref = None
        except Exception:
            pass


class _PlayerHolder:
    def __init__(self, chat_activity):
        self.chat_activity = chat_activity
        self.texture_view = None
        self.surface_view = None
        self.container = None
        self.player = None
        self.prepared = False
        self.just_prepared = False
        self._current_uri_str = None
        self._delegate = None
        self._local_file = None
        self._download_started = False
        self._ui = Handler(Looper.getMainLooper())
        self._error_recover_count = 0
        self._last_url = None
        self._idle_prepare_scheduled = False

    def _is_ui_animating(self):
        try:
            chat_activity = self.chat_activity
            chat_list = getattr(chat_activity, 'chatListView', None)
            if chat_list is not None:
                try:
                    animator = chat_list.getItemAnimator()
                    if animator is not None:
                        try:
                            if bool(animator.isRunning()):
                                return True
                        except Exception:
                            pass
                except Exception:
                    pass
            # Also consider PhotoViewer visible as busy UI
            try:
                PhotoViewer = jclass("org.telegram.ui.PhotoViewer")
                inst = PhotoViewer.getInstance()
                if inst is not None and bool(inst.isVisible()):
                    return True
            except Exception:
                pass
        except Exception:
            pass

    def _force_wallpaper_refresh(self):
        # Notify Telegram to refresh wallpaper and update preview tile
        try:
            Theme = find_class("org.telegram.ui.ActionBar.Theme")
            Theme.reloadWallpaper(True)
        except Exception:
            pass
        try:
            NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.didSetNewWallpapper)
        except Exception:
            pass
        return False

    def _prepare_when_idle(self, url: str, mute: bool, loop: bool):
        # Debounce and prepare only when UI animations settle to reduce jank
        try:
            if self._idle_prepare_scheduled:
                return
            self._idle_prepare_scheduled = True
        except Exception:
            pass

        def tick():
            try:
                busy = self._is_ui_animating()
                # While busy, keep wallpaper hidden and let static background draw
                if busy:
                    try:
                        if self.container is not None:
                            self.container.setAlpha(0.0)
                    except Exception:
                        pass
                    try:
                        content_view = getattr(self.chat_activity, 'contentView', None)
                        if content_view is None:
                            try:
                                content_view = self.chat_activity.getFragmentView()
                            except Exception:
                                content_view = None
                        if content_view is not None:
                            content_view.setSkipBackgroundDrawing(False)
                    except Exception:
                        pass
                    # Reschedule check shortly
                    try:
                        self._ui.postDelayed(Runnable(lambda: tick()), 90)
                    except Exception:
                        pass
                    return
                # UI idle: attach and prepare
                try:
                    if not self.ensure_attached():
                        self._ui.postDelayed(Runnable(lambda: tick()), 60)
                        return
                    if self.ensure_player(url, mute, loop):
                        try:
                            if self.player is not None and self.prepared:
                                self.player.setPlayWhenReady(True)
                                try:
                                    if self.just_prepared:
                                        self.player.seekTo(0)
                                except Exception:
                                    pass
                                self.player.play()
                                try:
                                    if self.container is not None:
                                        self.container.setAlpha(1.0)
                                except Exception:
                                    pass
                                log("[ACW] Idle prepare: player.play invoked")
                        except Exception as e:
                            log(f"[ACW] Idle prepare: play failed: {e}")
                except Exception:
                    pass
            finally:
                try:
                    self._idle_prepare_scheduled = False
                except Exception:
                    pass

        try:
            self._ui.postDelayed(Runnable(lambda: tick()), 70)
        except Exception:
            # Fallback: run directly
            tick()

    def pause(self):
        if self.player is not None and self.player.isPlaying():
            try:
                self.player.pause()
                log("[ACW] player.pause invoked")
            except Exception as e:
                log(f"[ACW] Error pausing player: {e}")
        # Detach surfaces and stop callbacks while paused to avoid GPU/compositor load
        try:
            if self.player is not None:
                try:
                    self.player.setSurfaceView(None)
                except Exception:
                    pass
                try:
                    self.player.setTextureView(None)
                except Exception:
                    pass
        except Exception:
            pass
        # Hide views to stop composition work when paused
        try:
            ViewCls = jclass("android.view.View")
            if self.surface_view is not None:
                self.surface_view.setVisibility(getattr(ViewCls, 'INVISIBLE', 4))
            if self.texture_view is not None:
                self.texture_view.setVisibility(getattr(ViewCls, 'INVISIBLE', 4))
        except Exception:
            pass
        try:
            self._ui.removeCallbacksAndMessages(None)
            log("[ACW] UI handler callbacks removed (pause).")
        except Exception:
            pass

    def detach_view(self):
        try:
            # Detach any surfaces from player
            if self.player is not None:
                try:
                    self.player.setSurfaceView(None)
                except Exception:
                    pass
                try:
                    self.player.setTextureView(None)
                except Exception:
                    pass
        except Exception:
            pass
        # Remove container from parent to avoid stacking overlays
        try:
            if self.container is not None:
                parent = self.container.getParent()
                if parent is not None:
                    parent.removeView(self.container)
                    log("[ACW] detach_view: container removed from parent")
        except Exception:
            pass
        # Allow background to draw when view detached
        try:
            content_view = getattr(self.chat_activity, 'contentView', None)
            if content_view is None:
                try:
                    content_view = self.chat_activity.getFragmentView()
                except Exception:
                    content_view = None
            if content_view is not None:
                content_view.setSkipBackgroundDrawing(False)
        except Exception:
            pass

    def release(self):
        log("[ACW] Releasing player holder resources...")
        if self.player is not None:
            # Stop playback and detach surfaces before releasing to free decoder buffers
            try:
                self.player.setPlayWhenReady(False)
            except Exception:
                pass
            try:
                self.player.pause()
            except Exception:
                pass
            try:
                self.player.setDelegate(None)
            except Exception:
                pass
            try:
                self.player.setSurfaceView(None)
            except Exception:
                pass
            try:
                self.player.setTextureView(None)
            except Exception:
                pass
            try:
                # Prefer explicit boolean signature to match client API
                self.player.releasePlayer(True)
            except Exception:
                try:
                    self.player.releasePlayer(False)
                except Exception:
                    try:
                        # Fallback for builds exposing no-arg releasePlayer
                        self.player.releasePlayer()
                    except Exception as e:
                        log(f"[ACW] Error releasing player: {e}")
            try:
                # Clear local delegate reference to aid GC
                self._delegate = None
            except Exception:
                pass
            log("[ACW] VideoPlayer released.")
            self.player = None
        
        if self.container is not None:
            try:
                parent = self.container.getParent()
                if parent is not None:
                    parent.removeView(self.container)
                    log("[ACW] Container view removed from parent.")
            except Exception as e:
                log(f"[ACW] Error removing container view: {e}")
        
        # Reset views to initial state and let background draw
        try:
            content_view = getattr(self.chat_activity, 'contentView', None)
            if content_view is None:
                try:
                    content_view = self.chat_activity.getFragmentView()
                except Exception:
                    content_view = None
            if content_view is not None:
                content_view.setSkipBackgroundDrawing(False)
        except Exception:
            pass

        self.texture_view = None
        self.surface_view = None
        self.container = None
        self.prepared = False
        self.just_prepared = False
        self._current_uri_str = None
        
        try:
            self._ui.removeCallbacksAndMessages(None)
            log("[ACW] UI handler callbacks removed.")
        except Exception:
            pass
        log("[ACW] Player holder released.")

    def _recover_from_error(self):
        try:
            self._error_recover_count = int(self._error_recover_count) + 1
        except Exception:
            self._error_recover_count = 1
        if self._error_recover_count > 3:
            log("[ACW] Recovery attempts exceeded; giving up")
            return
        log(f"[ACW] Attempting recovery #{self._error_recover_count}")
        try:
            # Toggle output view to try different rendering path
            use_texture = self.texture_view is not None
            try:
                if self.player is not None:
                    try:
                        self.player.setSurfaceView(None)
                    except Exception:
                        pass
                    try:
                        self.player.setTextureView(None)
                    except Exception:
                        pass
            except Exception:
                pass
            # Remove existing child views
            try:
                if self.container is not None:
                    self.container.removeAllViews()
            except Exception:
                pass
            # Recreate the alternate view
            FrameLayout = jclass("android.widget.FrameLayout")
            View = jclass("android.view.View")
            try:
                if use_texture:
                    # Switch to SurfaceView
                    self.texture_view = None
                    SurfaceView = jclass("android.view.SurfaceView")
                    self.surface_view = SurfaceView(self.container.getContext())
                    try:
                        self.surface_view.setZOrderOnTop(False)
                        self.surface_view.setZOrderMediaOverlay(False)
                    except Exception:
                        pass
                    self.container.addView(self.surface_view, FrameLayout.LayoutParams(-1, -1))
                    self.surface_view.setVisibility(View.VISIBLE)
                    log("[ACW] Recovery: switched to SurfaceView")
                else:
                    # Switch to TextureView
                    self.surface_view = None
                    TextureView = jclass("android.view.TextureView")
                    self.texture_view = TextureView(self.container.getContext())
                    self.container.addView(self.texture_view, FrameLayout.LayoutParams(-1, -1))
                    self.texture_view.setVisibility(View.VISIBLE)
                    log("[ACW] Recovery: switched to TextureView")
            except Exception as e:
                log(f"[ACW] Recovery: view switch failed: {e}")
            # Recreate player from scratch to drop codec instance
            try:
                if self.player is not None:
                    self.player.setPlayWhenReady(False)
            except Exception:
                pass
            try:
                self.release()
            except Exception:
                pass
            # Ensure attached and re-prepare current URL
            try:
                if not self.ensure_attached():
                    return
                url, mute, loop, enabled = _get_config()
                # Prefer last url if captured
                if self._last_url:
                    url = self._last_url
                if enabled and url:
                    if self.ensure_player(url, mute, loop):
                        try:
                            if self.player is not None and self.prepared:
                                self.player.setPlayWhenReady(True)
                                if self.just_prepared:
                                    try:
                                        self.player.seekTo(0)
                                    except Exception:
                                        pass
                                self.player.play()
                                log("[ACW] Recovery: player.play invoked")
                        except Exception as e:
                            log(f"[ACW] Recovery: play failed: {e}")
            except Exception:
                pass
        except Exception:
            pass

    def ensure_attached(self):
        log("[ACW] ensure_attached: start")
        content_view = getattr(self.chat_activity, 'contentView', None)
        if content_view is None:
            try:
                content_view = self.chat_activity.contentView
            except Exception:
                content_view = None
        if content_view is None:
            try:
                content_view = self.chat_activity.getFragmentView()
            except Exception:
                content_view = None
        if content_view is None:
            log("[ACW] ensure_attached: contentView not found")
            return False

        # Resolve Android classes needed for attaching views
        try:
            FrameLayout = jclass("android.widget.FrameLayout")
        except Exception:
            FrameLayout = None
        try:
            View = jclass("android.view.View")
        except Exception:
            View = None
        if FrameLayout is None:
            log("[ACW] ensure_attached: FrameLayout class unavailable")
            return False

        if self.container is None:
            try:
                self.container = FrameLayout(content_view.getContext())
                self.container.setClickable(False)
                self.container.setFocusable(False)
                try:
                    self.container.setBackgroundColor(Color.TRANSPARENT)
                    try:
                        # Ensure container is visible immediately
                        self.container.setAlpha(1.0)
                    except Exception:
                        pass
                except Exception:
                    pass
                # Remove any previous ACW container by tag to avoid stacking
                try:
                    count = content_view.getChildCount()
                    idx = 0
                    while idx < int(count):
                        try:
                            child = content_view.getChildAt(idx)
                            tag = child.getTag()
                        except Exception:
                            tag = None
                        if tag is not None and str(tag) == "ACW_CONTAINER":
                            content_view.removeView(child)
                            log("[ACW] ensure_attached: removed previous container")
                            count -= 1
                            continue
                        idx += 1
                except Exception:
                    pass
                try:
                    self.container.setTag("ACW_CONTAINER")
                except Exception:
                    pass
                content_view.addView(self.container, 0, FrameLayout.LayoutParams(-1, -1))
                log("[ACW] ensure_attached: container added")
                try:
                    content_view.setSkipBackgroundDrawing(True)
                    log("[ACW] setSkipBackgroundDrawing(true) after attach")
                except Exception:
                    pass
            except Exception as e:
                log(f"[ACW] ensure_attached: failed to add container: {e}")
                return False
        else:
            # Container exists; ensure it's attached to the current content_view
            try:
                parent = self.container.getParent()
            except Exception:
                parent = None
            try:
                if parent is not content_view:
                    try:
                        if parent is not None:
                            parent.removeView(self.container)
                            log("[ACW] ensure_attached: moved container from previous parent")
                    except Exception:
                        pass
                    try:
                        content_view.addView(self.container, 0, FrameLayout.LayoutParams(-1, -1))
                        log("[ACW] ensure_attached: attached existing container to current view")
                    except Exception as e:
                        log(f"[ACW] ensure_attached: failed to attach existing container: {e}")
                        return False
                # Ensure background drawing is skipped on current content
                try:
                    content_view.setSkipBackgroundDrawing(True)
                    log("[ACW] setSkipBackgroundDrawing(true) reattach")
                except Exception:
                    pass
            except Exception:
                pass

        if self.texture_view is None and self.surface_view is None:
            try:
                if USE_TEXTURE_VIEW:
                    TextureView = jclass("android.view.TextureView")
                    self.texture_view = TextureView(self.container.getContext())
                    self.container.addView(self.texture_view, FrameLayout.LayoutParams(-1, -1))
                    try:
                        # Ensure visible immediately; fade can be added later
                        self.texture_view.setAlpha(1.0)
                    except Exception:
                        pass
                    log("[ACW] ensure_attached: texture_view added")
                else:
                    SurfaceView = jclass("android.view.SurfaceView")
                    self.surface_view = SurfaceView(self.container.getContext())
                    try:
                        self.surface_view.setZOrderOnTop(False)
                        self.surface_view.setZOrderMediaOverlay(False)
                    except Exception:
                        pass
                    self.container.addView(self.surface_view, FrameLayout.LayoutParams(-1, -1))
                    # Ensure surface is visible so playback is shown immediately
                    try:
                        View = jclass("android.view.View")
                        self.surface_view.setVisibility(View.VISIBLE)
                    except Exception:
                        pass
                    try:
                        # Transparent background as a safeguard
                        self.surface_view.setBackgroundColor(Color.TRANSPARENT)
                    except Exception:
                        pass
                    # Attempt to cap frame rate at the surface level (Android 11+)
                    try:
                        holder = self.surface_view.getHolder()
                        if holder is not None:
                            surf = holder.getSurface()
                            if surf is not None:
                                try:
                                    # API30+: Hint compositor to present at TARGET_FPS
                                    surf.setFrameRate(float(TARGET_FPS), 1)
                                    log(f"[ACW] Surface.setFrameRate({TARGET_FPS}) applied")
                                except Exception:
                                    pass
                            # Reduce scaler work by matching holder size to content view
                            try:
                                w = content_view.getMeasuredWidth()
                                h = content_view.getMeasuredHeight()
                                if int(w) > 0 and int(h) > 0:
                                    holder.setFixedSize(int(w), int(h))
                            except Exception:
                                pass
                    except Exception:
                        pass
                    # Do not intercept touches; make wallpaper non-interactive
                    try:
                        self.surface_view.setClickable(False)
                        self.surface_view.setFocusable(False)
                        self.surface_view.setFocusableInTouchMode(False)
                    except Exception:
                        pass
                    log("[ACW] ensure_attached: surface_view added")
            except Exception as e:
                log(f"[ACW] ensure_attached: failed to add surface_view: {e}")
                return False
        else:
            # Views exist; ensure they are attached to container and visible
            try:
                if self.texture_view is not None:
                    p = None
                    try:
                        p = self.texture_view.getParent()
                    except Exception:
                        p = None
                    if p is not self.container:
                        try:
                            if p is not None:
                                p.removeView(self.texture_view)
                        except Exception:
                            pass
                        try:
                            self.container.addView(self.texture_view, FrameLayout.LayoutParams(-1, -1))
                            log("[ACW] ensure_attached: (re)attached texture_view to container")
                        except Exception:
                            pass
                    try:
                        if View is not None:
                            self.texture_view.setVisibility(getattr(View, 'VISIBLE', 0))
                            self.texture_view.setAlpha(1.0)
                    except Exception:
                        pass
                if self.surface_view is not None:
                    p = None
                    try:
                        p = self.surface_view.getParent()
                    except Exception:
                        p = None
                    if p is not self.container:
                        try:
                            if p is not None:
                                p.removeView(self.surface_view)
                        except Exception:
                            pass
                        try:
                            self.container.addView(self.surface_view, FrameLayout.LayoutParams(-1, -1))
                            log("[ACW] ensure_attached: (re)attached surface_view to container")
                        except Exception:
                            pass
                    try:
                        if View is not None:
                            self.surface_view.setVisibility(getattr(View, 'VISIBLE', 0))
                    except Exception:
                        pass
            except Exception:
                pass
        return True

    def ensure_player(self, url: str, mute: bool, loop: bool):
        if url is None or len(url.strip()) == 0:
            return False
        try:
            VideoPlayer = jclass("org.telegram.ui.Components.VideoPlayer")
            VideoPlayerDelegate = jclass("org.telegram.ui.Components.VideoPlayer$VideoPlayerDelegate")
        except Exception:
            log("[ACW] VideoPlayer class not found")
            return False
        if self.player is None:
            try:
                self.player = VideoPlayer(False, mute)
                try:
                    self.player.setLooper(jclass("android.os.Looper").getMainLooper())
                except Exception:
                    pass
                # Ensure delegate is set immediately on creation
                try:
                    if self._delegate is None:
                        def _on_state_changed(playWhenReady, playbackState): return None
                        def _on_error(player, e):
                            try:
                                log(f"[ACW] Delegate onError: {e}")
                                # Allow static background to draw while recovering
                                content_view = getattr(self.chat_activity, 'contentView', None)
                                if content_view is None:
                                    try:
                                        content_view = self.chat_activity.getFragmentView()
                                    except Exception:
                                        content_view = None
                                if content_view is not None:
                                    try:
                                        content_view.setSkipBackgroundDrawing(False)
                                    except Exception:
                                        pass
                                # Schedule recovery
                                try:
                                    self._last_url = url
                                except Exception:
                                    pass
                                run_on_ui_thread(lambda: self._recover_from_error())
                            except Exception:
                                pass
                        def _on_video_size_changed(width, height, rotation, ratio): return None
                        def _on_first_frame():
                            try:
                                View = jclass("android.view.View")
                                if self.surface_view is not None:
                                    self.surface_view.setVisibility(View.VISIBLE)
                                if self.container is not None:
                                    try:
                                        self.container.setAlpha(1.0)
                                    except Exception:
                                        pass
                                try:
                                    content_view = getattr(self.chat_activity, 'contentView', None)
                                    if content_view is None:
                                        try:
                                            content_view = self.chat_activity.getFragmentView()
                                        except Exception:
                                            content_view = None
                                    if content_view is not None:
                                        content_view.setSkipBackgroundDrawing(True)
                                        log("[ACW] setSkipBackgroundDrawing(true) after first frame")
                                except Exception:
                                    pass
                            except Exception:
                                pass
                        def _on_tex_updated(surfaceTexture): return None
                        def _on_surface_destroyed(surfaceTexture): return False
                        VideoPlayerDelegate = jclass("org.telegram.ui.Components.VideoPlayer$VideoPlayerDelegate")
                        self._delegate = dynamic_proxy(VideoPlayerDelegate)(
                            onStateChanged=_on_state_changed,
                            onError=_on_error,
                            onVideoSizeChanged=_on_video_size_changed,
                            onRenderedFirstFrame=_on_first_frame,
                            onSurfaceTextureUpdated=_on_tex_updated,
                            onSurfaceDestroyed=_on_surface_destroyed,
                        )
                    self.player.setDelegate(self._delegate)
                except Exception:
                    pass
            except Exception:
                log("[ACW] Failed to create VideoPlayer")
                self.player = None
                return False
        try:
            if self._delegate is None:
                def _on_state_changed(playWhenReady, playbackState):
                    return None
                def _on_error(player, e):
                    try:
                        log(f"[ACW] Delegate onError: {e}")
                        content_view = getattr(self.chat_activity, 'contentView', None)
                        if content_view is None:
                            try:
                                content_view = self.chat_activity.getFragmentView()
                            except Exception:
                                content_view = None
                        if content_view is not None:
                            try:
                                content_view.setSkipBackgroundDrawing(False)
                            except Exception:
                                pass
                        try:
                            self._last_url = url
                        except Exception:
                            pass
                        run_on_ui_thread(lambda: self._recover_from_error())
                    except Exception:
                        pass
                def _on_video_size_changed(width, height, rotation, ratio):
                    return None
                def _on_first_frame():
                    try:
                        View = jclass("android.view.View")
                        if self.surface_view is not None:
                            self.surface_view.setVisibility(View.VISIBLE)
                        if self.container is not None:
                            try:
                                self.container.setAlpha(1.0)
                            except Exception:
                                pass
                        try:
                            content_view = getattr(self.chat_activity, 'contentView', None)
                            if content_view is None:
                                try:
                                    content_view = self.chat_activity.getFragmentView()
                                except Exception:
                                    content_view = None
                            if content_view is not None:
                                content_view.setSkipBackgroundDrawing(True)
                                log("[ACW] setSkipBackgroundDrawing(true) after first frame")
                        except Exception:
                            pass
                    except Exception:
                        pass
                def _on_tex_updated(surfaceTexture):
                    return None
                def _on_surface_destroyed(surfaceTexture):
                    return False
                self._delegate = dynamic_proxy(VideoPlayerDelegate)(
                    onStateChanged=_on_state_changed,
                    onError=_on_error,
                    onVideoSizeChanged=_on_video_size_changed,
                    onRenderedFirstFrame=_on_first_frame,
                    onSurfaceTextureUpdated=_on_tex_updated,
                    onSurfaceDestroyed=_on_surface_destroyed,
                )
            self.player.setDelegate(self._delegate)
            # Apply max FPS/bitrate via TrackSelector when available
            try:
                cls = self.player.getClass() if hasattr(self.player, 'getClass') else None
                if cls is not None:
                    try:
                        f = cls.getDeclaredField("trackSelector")
                        f.setAccessible(True)
                        trackSelector = f.get(self.player)
                        if trackSelector is not None:
                            try:
                                params = trackSelector.getParameters()
                                builder = params.buildUpon()
                                try:
                                    builder.setMaxVideoFrameRate(int(TARGET_FPS))
                                except Exception:
                                    pass
                                try:
                                    builder.setMaxVideoBitrate(int(PREFERRED_BITRATE))
                                except Exception:
                                    pass
                                try:
                                    builder.setExceedVideoConstraintsIfNecessary(True)
                                except Exception:
                                    pass
                                try:
                                    trackSelector.setParameters(builder.build())
                                    log(f"[ACW] TrackSelector max set: fps={TARGET_FPS}, bitrate={PREFERRED_BITRATE}")
                                except Exception:
                                    pass
                            except Exception:
                                pass
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass
        try:
            self.player.setLooping(bool(loop))
        except Exception:
            pass
        # Best-effort tuning: lower peak bitrate, scaling, and playback params
        try:
            # Prefer lower peak bitrate if supported
            self.player.setPreferredPeakBitrate(int(PREFERRED_BITRATE))
        except Exception:
            pass
        try:
            # Keep standard scaling to fit; avoids expensive cropping in many cases
            C = jclass("com.google.android.exoplayer2.C")
            self.player.setVideoScalingMode(getattr(C, "VIDEO_SCALING_MODE_SCALE_TO_FIT", 1))
        except Exception:
            pass
        try:
            # Stable playback params (speed 1.0, pitch 1.0); some devices expose this
            PlaybackParameters = jclass("com.google.android.exoplayer2.PlaybackParameters")
            self.player.setPlaybackParameters(PlaybackParameters(1.0, 1.0))
        except Exception:
            pass
            # Remove explicit frame rate cap to allow device to choose optimal
            try:
                # Some builds expose setPreferredFrameRate; skip using it to avoid 60fps lock
                _ = getattr(self.player, 'setPreferredFrameRate', None)
            except Exception:
                pass
        try:
            self.player.handleAudioFocus(False)
        except Exception:
            pass
        try:
            if self.surface_view is not None:
                self.player.setSurfaceView(self.surface_view)
            elif self.texture_view is not None:
                self.player.setTextureView(self.texture_view)
        except Exception:
            log("[ACW] set video view failed")
        try:
            ApplicationLoader = jclass("org.telegram.messenger.ApplicationLoader")
            ctx = ApplicationLoader.applicationContext
            self._local_file = _acw_get_local_file_for_url(ctx, url)
        except Exception:
            self._local_file = None
        
        source_uri = None
        use_local = False
        try:
            if self._local_file is not None and self._local_file.exists() and self._local_file.length() > 0:
                use_local = True
        except Exception:
            use_local = False

        if use_local:
            try:
                source_uri = jclass("android.net.Uri").fromFile(self._local_file)
                log("[ACW] Using local cached file for playback")
            except Exception:
                source_uri = None
        if source_uri is None:
            try:
                UriCls = jclass("android.net.Uri")
                source_uri = UriCls.parse(url)
            except Exception as e:
                log(f"[ACW] Invalid URL: {url} err={e}")
                return False
        
        # Determine a stable key for the current source to detect duplicates
        try:
            source_key = None
            if use_local and self._local_file is not None:
                source_key = self._local_file.getAbsolutePath()
            else:
                source_key = url.strip()
        except Exception:
            source_key = url.strip()

        # Avoid re-preparing with the same source on every resume
        if self.player is not None and self.prepared and self._current_uri_str == source_key:
            try:
                if self.surface_view is not None:
                    self.player.setSurfaceView(self.surface_view)
                elif self.texture_view is not None:
                    self.player.setTextureView(self.texture_view)
                self.player.setPlayWhenReady(True)
                self.player.play()
                log("[ACW] Reusing prepared player; no re-prepare.")
            except Exception as e:
                log(f"[ACW] Reuse play failed: {e}")
            self.just_prepared = False
            return True
        
        try:
            log(f"[ACW] Preparing player type=other uri={source_uri}")
            # Always ensure delegate is set before assigning output view
            try:
                self.player.setDelegate(self._delegate)
            except Exception:
                pass
            # Defensive: if delegate is still None, create a minimal one to avoid NPE in maybeReportPlayerState
            try:
                if self._delegate is None:
                    VideoPlayerDelegate = jclass("org.telegram.ui.Components.VideoPlayer$VideoPlayerDelegate")
                    self._delegate = dynamic_proxy(VideoPlayerDelegate)(
                        onStateChanged=lambda a,b: None,
                        onError=lambda p, e: log(f"[ACW] Delegate error: {e}"),
                        onVideoSizeChanged=lambda w,h,r,ra: None,
                        onRenderedFirstFrame=lambda : None,
                        onSurfaceTextureUpdated=lambda st: None,
                        onSurfaceDestroyed=lambda st: False,
                    )
                    self.player.setDelegate(self._delegate)
            except Exception:
                pass
            if self.surface_view is not None:
                self.player.setSurfaceView(self.surface_view)
            elif self.texture_view is not None:
                self.player.setTextureView(self.texture_view)
            self.player.preparePlayer(source_uri, "other")
            # Reinforce delegate after prepare in case internal state replaced it
            try:
                self.player.setDelegate(self._delegate)
            except Exception:
                pass
            try:
                self.player.setPlayWhenReady(True)
                self.player.seekTo(0)
            except Exception:
                pass
            self.prepared = True
            self.just_prepared = True
            self._current_uri_str = source_key
            # If Telegram media viewer is visible, keep wallpaper hidden to avoid conflicts
            try:
                PhotoViewer = jclass("org.telegram.ui.PhotoViewer")
                inst = PhotoViewer.getInstance()
                if inst is not None:
                    try:
                        if bool(inst.isVisible()):
                            try:
                                self.pause()
                            except Exception:
                                pass
                            if self.container is not None:
                                try:
                                    self.container.setAlpha(0.0)
                                except Exception:
                                    pass
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception as e:
            log(f"[ACW] prepare failed type=other err={e}")
            # Retry once after force-attaching a minimal delegate to avoid NPE in maybeReportPlayerState
            try:
                if self._delegate is None:
                    VideoPlayerDelegate = jclass("org.telegram.ui.Components.VideoPlayer$VideoPlayerDelegate")
                    self._delegate = dynamic_proxy(VideoPlayerDelegate)(
                        onStateChanged=lambda a,b: None,
                        onError=lambda p, err: log(f"[ACW] Delegate error (retry): {err}"),
                        onVideoSizeChanged=lambda w,h,r,ra: None,
                        onRenderedFirstFrame=lambda : None,
                        onSurfaceTextureUpdated=lambda st: None,
                        onSurfaceDestroyed=lambda st: False,
                    )
                try:
                    self.player.setDelegate(self._delegate)
                except Exception:
                    pass
                # Also try to set the internal field directly as a fallback
                try:
                    cls = self.player.getClass() if hasattr(self.player, 'getClass') else None
                    if cls is not None:
                        f = cls.getDeclaredField("delegate")
                        f.setAccessible(True)
                        f.set(self.player, self._delegate)
                except Exception:
                    pass
                # Retry prepare
                try:
                    if self.surface_view is not None:
                        self.player.setSurfaceView(self.surface_view)
                    elif self.texture_view is not None:
                        self.player.setTextureView(self.texture_view)
                except Exception:
                    pass
                try:
                    self.player.preparePlayer(source_uri, "other")
                    try:
                        self.player.setPlayWhenReady(True)
                        self.player.seekTo(0)
                    except Exception:
                        pass
                    self.prepared = True
                    self.just_prepared = True
                    self._current_uri_str = source_key
                    log("[ACW] prepare retry succeeded")
                except Exception as e2:
                    log(f"[ACW] prepare retry failed: {e2}")
                    self.prepared = False
            except Exception:
                self.prepared = False
        if not self.prepared:
            log("[ACW] Failed to prepare player (source)")
            return False
        
        try:
            if self._local_file is not None:
                need_download = (not self._local_file.exists()) or (self._local_file.length() == 0)
                # If URL changed (source_key differs), reset download flag to fetch new file
                try:
                    last_key = getattr(self, "_current_uri_str", None)
                    if last_key is not None and last_key != source_key:
                        self._download_started = False
                except Exception:
                    pass
                if need_download and not self._download_started:
                    self._download_started = True
                    def _bg_download():
                        try:
                            dest_path = self._local_file.getAbsolutePath()
                            log(f"[ACW] Downloading video to {dest_path}")
                            r = requests.get(url, stream=True, timeout=60)
                            r.raise_for_status()
                            with open(dest_path, "wb") as f:
                                for chunk in r.iter_content(1024 * 128):
                                    if chunk: f.write(chunk)
                            log("[ACW] Download complete; switching to local file")
                            def _switch():
                                try:
                                    local_uri = jclass("android.net.Uri").fromFile(self._local_file)
                                    self.player.preparePlayer(local_uri, "other")
                                    try:
                                        self.player.setPlayWhenReady(True)
                                        self.player.seekTo(0)
                                    except Exception: pass
                                    self.prepared = True
                                    self.player.play()
                                    try:
                                        self._current_uri_str = self._local_file.getAbsolutePath()
                                    except Exception:
                                        pass
                                    log("[ACW] Re-prepared from local and play")
                                except Exception as e2:
                                    log(f"[ACW] Re-prepare failed: {e2}")
                            run_on_ui_thread(_switch)
                        except Exception as e:
                            log(f"[ACW] Download failed: {e}")
                    threading.Thread(target=_bg_download, daemon=True).start()
        except Exception:
            pass
        return True

def _get_or_create_holder(plugin: AnimatedChatWallpaperPlugin, chat_activity):
    try:
        holder = getattr(plugin, "_global_holder", None)
    except Exception:
        holder = None
    if holder is None:
        holder = _PlayerHolder(chat_activity)
        try:
            setattr(plugin, "_global_holder", holder)
        except Exception:
            pass
    # Always bind current chat activity context to the holder before use
    try:
        holder.chat_activity = chat_activity
    except Exception:
        pass
    # Expose holder on activity for lifecycle hooks to find it reliably
    try:
        setattr(chat_activity, "__acw_holder", holder)
    except Exception:
        pass
    return holder


def _get_config():
    return VIDEO_URL or "", bool(VIDEO_MUTE), bool(VIDEO_LOOP), bool(VIDEO_ENABLED)


class _ChatResumeHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        chat_activity = param.thisObject
        url, mute, loop, enabled = _get_config()
        if not enabled or not url:
            log("[ACW] Disabled or empty VIDEO_URL; set VIDEO_URL in plugin code")
            return

        def run():
            try:
                holder = _get_or_create_holder(self.plugin, chat_activity)
                holder._prepare_when_idle(url, mute, loop)
            except Exception:
                log(f"[ACW] onResume runnable failed: {traceback.format_exc()}")
        run_on_ui_thread(run)


class _ChatCreateViewHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        chat_activity = param.thisObject
        url, mute, loop, enabled = _get_config()
        if not enabled or not url:
            return
        def run():
            try:
                holder = _get_or_create_holder(self.plugin, chat_activity)
                holder._prepare_when_idle(url, mute, loop)
            except Exception:
                pass
        run_on_ui_thread(run)


class _ChatPauseHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        chat_activity = param.thisObject
        def run():
            try:
                holder = getattr(chat_activity, "__acw_holder", None)
                if holder:
                    holder.pause()
                    holder.detach_view()
                    # Keep holder/player to avoid codec churn; do NOT release here
                    # While paused, allow chat background to draw to avoid black screen
                    try:
                        content_view = getattr(chat_activity, 'contentView', None)
                        if content_view is None:
                            try:
                                content_view = chat_activity.getFragmentView()
                            except Exception:
                                content_view = None
                        if content_view is not None:
                            content_view.setSkipBackgroundDrawing(False)
                    except Exception:
                        pass
            except Exception:
                pass
        run_on_ui_thread(run)


class _ChatDestroyHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        chat_activity = param.thisObject
        def run():
            try:
                holder = getattr(chat_activity, "__acw_holder", None)
                if holder is not None:
                    holder.detach_view()
                    holder.release()
                    try:
                        setattr(chat_activity, "__acw_holder", None)
                    except Exception:
                        pass
            except Exception:
                pass
        run_on_ui_thread(run)


class _ChatActivityResultHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            args = getattr(param, 'args', [])
            request_code = int(args[0]) if len(args) > 0 else -1
            result_code = int(args[1]) if len(args) > 1 else -1
            intent = args[2] if len(args) > 2 else None
            if request_code == 7788 and intent is not None and result_code == getattr(jclass("android.app.Activity"), "RESULT_OK", -1):
                data_uri = None
                try:
                    data_uri = intent.getData()
                except Exception:
                    data_uri = None
                if data_uri is not None:
                    try:
                        self.plugin._handle_picked_uri(data_uri, intent)
                    except Exception:
                        pass
        except Exception:
            pass

class _RootActivityResultHook:
    def __init__(self, plugin: AnimatedChatWallpaperPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            args = getattr(param, 'args', [])
            request_code = int(args[0]) if len(args) > 0 else -1
            result_code = int(args[1]) if len(args) > 1 else -1
            intent = args[2] if len(args) > 2 else None
            ActivityCls = jclass("android.app.Activity")
            if request_code == 7788 and intent is not None and result_code == getattr(ActivityCls, "RESULT_OK", -1):
                data_uri = None
                try:
                    data_uri = intent.getData()
                except Exception:
                    data_uri = None
                if data_uri is not None:
                    try:
                        self.plugin._handle_picked_uri(data_uri, intent)
                    except Exception:
                        pass
        except Exception:
            pass


class _VideoPlayerTexUpdateHook(MethodReplacement):
    def replace_hooked_method(self, param): return None

class _VideoPlayerStateHook(MethodReplacement):
    def replace_hooked_method(self, param): return None

class _VideoPlayerSizeHook(MethodReplacement):
    def replace_hooked_method(self, param): return None

class _VideoPlayerFirstFrameHook(MethodReplacement):
    def replace_hooked_method(self, param): return None

class _VideoPlayerSurfaceDestroyedHook(MethodReplacement):
    def replace_hooked_method(self, param):
        try:
            this_obj = getattr(param, 'thisObject', None)
            args = getattr(param, 'args', [])
            surface_texture = args[0] if args and len(args) > 0 else None
            delegate = None
            try:
                if this_obj is not None:
                    cls = this_obj.getClass() if hasattr(this_obj, 'getClass') else None
                    if cls is not None:
                        try:
                            f = cls.getDeclaredField("delegate")
                            f.setAccessible(True)
                            delegate = f.get(this_obj)
                        except Exception:
                            try:
                                m = cls.getDeclaredMethod("getDelegate")
                                m.setAccessible(True)
                                delegate = m.invoke(this_obj)
                            except Exception:
                                delegate = None
            except Exception:
                delegate = None
            if delegate is not None:
                try:
                    return delegate.onSurfaceDestroyed(surface_texture)
                except Exception:
                    pass
            return False
        except Exception:
            return False

class _VideoPlayerOnErrorLogHook:
    def after_hooked_method(self, param):
        try:
            args = getattr(param, 'args', [])
            e = args[0] if args and len(args) > 0 else None
            log(f"[ACW] VideoPlayer.onPlayerError: {e}")
        except Exception:
            pass

class _VideoPlayerErrorHook(MethodReplacement):
    def replace_hooked_method(self, param):
        try:
            # Swallow internal error dispatch if delegate is null to prevent NPE
            args = getattr(param, 'args', [])
            e = args[0] if args and len(args) > 0 else None
            log(f"[ACW] VideoPlayer error intercepted: {e}")
        except Exception:
            pass
        return None

class _VideoPlayerErrorLambdaHook(MethodReplacement):
    def replace_hooked_method(self, param):
        try:
            # Synthetic lambda that would post delegate.onError; swallow to avoid NPE
            args = getattr(param, 'args', [])
            e = args[0] if args and len(args) > 0 else None
            log(f"[ACW] VideoPlayer error lambda intercepted: {e}")
        except Exception:
            pass
        return None


class WallpaperOverrideHook(MethodHook):
    def __init__(self, plugin_instance: AnimatedChatWallpaperPlugin):
        self.plugin = plugin_instance
        self.cached_drawable = None
        self.cached_source = None

    def before_hooked_method(self, param):
        try:
            # Use current URL (could be content:// or file://); produce preview bitmap
            source = None
            try:
                source = self.plugin._cached_url if hasattr(self.plugin, '_cached_url') else None
                if not source:
                    source = self.plugin.get_setting(getattr(self.plugin, 'SETTINGS_URL_KEY', 'acw_video_url'), None)
            except Exception:
                source = None
            if not source:
                return
            if self.cached_source != source:
                try:
                    ctx = ApplicationLoader.applicationContext
                    mmr = jclass("android.media.MediaMetadataRetriever")()
                    uri = None
                    try:
                        uri = jclass("android.net.Uri").parse(str(source))
                    except Exception:
                        uri = None
                    try:
                        if uri is not None and str(uri.getScheme() or '').lower() != 'file':
                            mmr.setDataSource(ctx, uri)
                        else:
                            # For file:// or raw path
                            path = None
                            try:
                                if uri is not None and str(uri.getScheme() or '').lower() == 'file':
                                    path = uri.getPath()
                                else:
                                    path = str(source)
                            except Exception:
                                path = str(source)
                            mmr.setDataSource(path)
                        frame = mmr.getFrameAtTime(0)
                    except Exception:
                        frame = None
                    drawable = None
                    if frame is not None:
                        try:
                            drawable = BitmapDrawable(ApplicationLoader.applicationContext.getResources(), frame)
                        except Exception:
                            drawable = None
                    self.cached_drawable = drawable
                    self.cached_source = source
                except Exception:
                    self.cached_drawable = None
                    self.cached_source = None
            if self.cached_drawable:
                param.setResult(self.cached_drawable)
        except Exception:
            pass


