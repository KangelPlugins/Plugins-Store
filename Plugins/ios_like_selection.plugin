__id__ = "ios_like_selection"
__name__ = "IOS-like selection"
__description__ = "Tries to recreate the effect of selecting a message by tapping like on IOS"
__author__ = "@PESSDES_Plugins"
__min_version__ = "12.0.0" 
__icon__ = "VoiceToText7/6"
__version__ = "6.1"

from android.os import Build

BLUR_SUPPORTED = Build.VERSION.SDK_INT >= 31

from typing import Any, Callable, Tuple

from android.animation import AnimatorSet, ObjectAnimator, ValueAnimator

if BLUR_SUPPORTED:
    from android.graphics import RenderEffect, Shader

from android.graphics.drawable import BitmapDrawable
from android.view import Gravity, View, ViewGroup
from android.view.animation import (AccelerateDecelerateInterpolator,
                                    AccelerateInterpolator,
                                    AnticipateInterpolator,
                                    AnticipateOvershootInterpolator,
                                    BounceInterpolator, CycleInterpolator,
                                    DecelerateInterpolator, LinearInterpolator,
                                    OvershootInterpolator)
from android.widget import FrameLayout, LinearLayout, PopupWindow, ScrollView
from android_utils import OnClickListener
from android_utils import log as logcat
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment
from hook_utils import get_private_field, set_private_field
from java import dynamic_proxy
from java import jint as JInt
from java.lang import Boolean, Float, Integer, Runnable
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import ActionBarPopupWindow
from org.telegram.ui.Cells import ChatActionCell, ChatMessageCell
from org.telegram.ui.Components import LayoutHelper, ReactionsContainerLayout
from ui.settings import Divider, Selector, Switch


def log(*msg):
    m = msg if len(msg) > 1 else msg[0]
    if isinstance(m, Exception) and m.__traceback__ is not None:
        m = f"{m.__traceback__.tb_lineno}: {m}"
    logcat(f'[{__id__}] {m}')

def ctx():
    return get_last_fragment().getContext()

jboolean = Boolean.TYPE
jfloat = Float.TYPE
jint = Integer.TYPE

MATCH_PARENT = ViewGroup.LayoutParams.MATCH_PARENT
WRAP_CONTENT = ViewGroup.LayoutParams.WRAP_CONTENT

display_size = AndroidUtilities.displaySize
display_width, display_height = display_size.x, display_size.y

class Plugin(BasePlugin):
    instance: "Plugin | None" = None
    
    def on_plugin_load(self) -> None:
        Plugin.instance = self
        
        self.hook_method(
            ChatActivity.getClass().getDeclaredMethod("createMenu", View, jboolean, jboolean, jfloat, jfloat, jboolean, jboolean), 
            CreateMenuHook())
        
        self.hook_method(
            ActionBarPopupWindow.getClass().getDeclaredMethod("showAtLocation", View, jint, jint, jint),
            ShowPopupHook()
        )
    
    blurs = [
        25,
        50,
        100,
        150,
        250
    ]
    
    animations_speed = [
        0.25,
        0.5,
        0.75,
        1,
        1.5,
        2,
        2.5,
        3
    ]
    
    interpolators = [
        AccelerateDecelerateInterpolator, AccelerateInterpolator, AnticipateInterpolator, AnticipateOvershootInterpolator, BounceInterpolator, CycleInterpolator, DecelerateInterpolator, LinearInterpolator, OvershootInterpolator, 
    ]
    
    def create_settings(self) -> list[Any]:
        try:
            settings = []
            settings.append(Selector('radius', 'Blur Radius', items=[str(x) for x in self.blurs], icon='msg_palette', default=2))
            settings.append(Divider('A larger blur radius may cause lags'))
                
            settings.append(Switch('enable_animations', 'Enable animations', True))
            if self.get_setting("enable_animations", True):
                settings.append(Selector('animations_speed', 'Animations speed', default=3, items=[f'x{x}' for x in self.animations_speed], icon="msg_premium_speed"))
                settings.append(Selector('interpolator', 'Interpolator', 0, [x.getClass().getSimpleName().replace('Interpolator', '') for x in self.interpolators.copy()], icon="msg_noise_on"))
                settings.append(Divider('An Interpolator controls how the animationâ€™s speed changes over time and how smooth it is'))
            settings.append(Switch("scroll_from_bottom", "Scroll from bottom", True, link_alias="bottom_scroll"))
            return settings
        except Exception as e:
            log(e)
    
    @classmethod
    def get_radius(cls):
        try:
            if not cls.instance:
                return cls.blurs[2]
            return cls.blurs[int(cls.instance.get_setting('radius', 2))]
        except Exception as e:
            log(e)
    
    @classmethod
    def get_animation_speed(cls):
        if not cls.instance:
            return cls.animations_speed[3]
        return 0 if not cls.instance.get_setting("enable_animations", True) else cls.animations_speed[int(cls.instance.get_setting("animations_speed", 3))]
    
    @classmethod
    def get_interpolator(cls):
        if not cls.instance:
            return cls.interpolators[0]
        return cls.interpolators[cls.instance.get_setting("interpolator", 0)]
    
    @classmethod
    def scroll_from_bottom(cls):
        if not cls.instance:
            return True
        return cls.instance.get_setting("scroll_from_bottom", True)

current_popup: ActionBarPopupWindow | None = None
current_chat_activity: ChatActivity | None = None
current_message_cell: ChatMessageCell | ChatActionCell | None = None

def apply_blur(view, radius):
    if BLUR_SUPPORTED:
        if radius <= 0:
            view.setRenderEffect(None)
        else:
            view.setRenderEffect(RenderEffect.createBlurEffect(radius, radius, Shader.TileMode.MIRROR))

class ShowPopupHook(MethodHook):   
    def before_hooked_method(self, param):
        if not current_chat_activity:
            return
        
        param.args[2] = JInt(0) # x
        param.args[3] = JInt(0) # y
        
        self._before_hooked_method(param.thisObject, *param.args)
    
    def _before_hooked_method(self, this: ActionBarPopupWindow, *_):    
        try:
            cell = self._copy_message_cell(current_message_cell)
            if not cell:
                return

            this.setWidth(display_width)
            this.setHeight(display_height)
            this.setClippingEnabled(False) 
            
            old_content = this.getContentView()
            children = []
            for i in range(old_content.getChildCount()):
                children.append(old_content.getChildAt(i))

            old_content.removeAllViews()

            new_content = FrameLayout(ctx())
            new_content.setLayoutParams(FrameLayout.LayoutParams(display_width, display_height))
            new_content.setClickable(True) 

            scroll_view = ScrollView(ctx())
            scroll_view.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            scroll_view.setFillViewport(True)
            scroll_view.setClipChildren(False)
            scroll_view.setClipToPadding(False)
            scroll_view.setOverScrollMode(View.OVER_SCROLL_NEVER) 
            scroll_view.setVerticalScrollBarEnabled(False)

            inner_container = LinearLayout(ctx())
            inner_container.setOrientation(LinearLayout.VERTICAL)
            inner_container.setLayoutParams(FrameLayout.LayoutParams(display_width, MATCH_PARENT))
            inner_container.setClickable(False) 
            
            w_spec = View.MeasureSpec.makeMeasureSpec(display_width, View.MeasureSpec.AT_MOST)
            h_spec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)

            is_out = current_message_cell.getMessageObject().isOut()
            lp = LayoutHelper.createLinear(WRAP_CONTENT, WRAP_CONTENT, Gravity.RIGHT if is_out else Gravity.LEFT)
            reactions_height = 0
            reactions_view = None
            if len(children) > 0 and isinstance(children[0], ReactionsContainerLayout):
                reactions_view = children.pop(0)
                reactions_view.setLayoutParams(lp)
                
                reactions_view.measure(w_spec, h_spec)
                reactions_height = reactions_view.getMeasuredHeight()

            cell.setLayoutParams(LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT))
            inner_container.addView(cell)
            
            dismiss = OnClickListener(lambda *_: this.dismiss())
            inner_container.setOnClickListener(dismiss)
            new_content.setOnClickListener(dismiss)
            scroll_view.setOnClickListener(dismiss)
            
            message_height = current_message_cell.getHeight()

            bottom_menu_height = 0
            popup_actions_menu = None
            
            for child in children:
                child.setLayoutParams(lp)
                inner_container.addView(child)
                
                child.measure(w_spec, h_spec)
                bottom_menu_height += child.getMeasuredHeight()
                
                if not popup_actions_menu and isinstance(child, ActionBarPopupWindow.ActionBarPopupWindowLayout):
                    popup_actions_menu = child
                    
            scroll_view.addView(inner_container)
            new_content.addView(scroll_view)

            _, original_msg_y = AndroidUtils.get_location_on_screen(current_message_cell)
            
            top_limit = AndroidUtilities.statusBarHeight + AndroidUtilities.dp(24)
            
            padding_top = original_msg_y - reactions_height
            
            menu_height = reactions_height + bottom_menu_height + message_height
            
            if display_height - padding_top < menu_height:
                padding_top = display_height - menu_height

            if padding_top < top_limit:
                padding_top = top_limit

            bar = False
            if padding_top + menu_height - reactions_height > display_height:
                if Plugin.scroll_from_bottom():
                    scroll_view.post(RunnableFactory(lambda: scroll_view.fullScroll(View.FOCUS_DOWN)))
                if reactions_view is not None:
                    reactions_bar = FrameLayout(ctx())
                    reactions_bar.addView(reactions_view)
                    reactions_view.setLayoutParams(LayoutHelper.createFrame(WRAP_CONTENT, WRAP_CONTENT, Gravity.RIGHT if is_out else Gravity.LEFT))
                    new_content.addView(reactions_bar, lp)
                    reactions_bar.setTranslationY(padding_top)
                    bar = True
            elif reactions_view is not None:
                inner_container.addView(reactions_view, 0)
                
            spacer = View(ctx())
            spacer.setLayoutParams(LinearLayout.LayoutParams(MATCH_PARENT, int(padding_top + (reactions_height if bar else 0))))
            spacer.setOnClickListener(dismiss)
            inner_container.addView(spacer, 0)
            
            message_y = padding_top + reactions_height
            
            this.setContentView(new_content)
            
            original_dismiss_listener = get_private_field(this, "mOnDismissListener")
            def on_dimiss():
                if original_dismiss_listener:
                    original_dismiss_listener()
                self.animate(True)
                
                global current_chat_activity, current_message_cell
                current_chat_activity, current_message_cell = None, None
                
            this.setOnDismissListener(OnPopupDismiss(on_dimiss))
            
            self.animate(False, this, original_msg_y - message_y, popup_actions_menu)
            
            pad = AndroidUtilities.dp(8)    
            popup_actions_menu.setTranslationX(-pad if is_out else pad)
        except Exception as e:
            log(e)
    
    def animate(self, out: bool = False, popup: ActionBarPopupWindow | None = None, message_y: int | None = None, popup_actions: ActionBarPopupWindow.ActionBarPopupWindowLayout | None = None):
        try:
            radius = Plugin.get_radius()
            speed = Plugin.get_animation_speed()
            interploator = Plugin.get_interpolator()
            
            def blur_old_api(enable):
                if enable and popup.getBackground() is None:
                    popup.setBackgroundDrawable(BitmapDrawable(AndroidUtilities.makeBlurBitmap(current_chat_activity.getContentView(), 6, radius)))
                elif not enable and popup.getBackground() is not None:
                    popup.setBackgroundDrawable(None)
                    
            if speed == 0:
                if BLUR_SUPPORTED:
                    apply_blur(current_chat_activity.getContentView(), radius if not out else 0)
                else:
                    blur_old_api(not out)
            else:
                animations = []
                
                if BLUR_SUPPORTED:
                    animator = ValueAnimator.ofFloat(0.0, radius)
                    animator.addUpdateListener(AnimatorUpdateListener(lambda animation, c = current_chat_activity: apply_blur(c.getContentView(), animation.getAnimatedValue())))
                    animations.append(animator)
                else:
                    blur_old_api(not out)
                
                if message_y is not None and popup is not None:
                    animator = ObjectAnimator.ofFloat(popup.getContentView(), "translationY", message_y if not out else -message_y, 0)
                    animations.append(animator)
                
                if popup_actions is not None:
                    popup_actions.setPivotY(0)
                    popup_actions.setPivotX(popup_actions.getMeasuredWidth() / 2)
                    animators = [ObjectAnimator.ofFloat(popup_actions, "scaleX", 0.3, 1),
                        ObjectAnimator.ofFloat(popup_actions, "scaleY", 0.3, 1),
                        ObjectAnimator.ofFloat(popup_actions, "alpha", 0.5, 1)
                    ]
                    animations.extend(animators)
                
                set = AnimatorSet()
                set.playTogether(*animations)
                set.setDuration(0 if speed == 0 else int(250 / speed))
                set.setInterpolator(interploator())
                if not out:
                    set.start()
                else:
                    set.reverse()
        except Exception as e:
            log(e)
    
    @staticmethod
    def _copy_message_cell(cell: ChatMessageCell | ChatActionCell | None):
        if isinstance(cell, ChatMessageCell):
            msg = ChatMessageCell(
                ctx(),
                cell.currentAccount)
            cell.copyParamsTo(msg)
            set_private_field(msg, "isThreadPost", get_private_field(cell, "isThreadPost"))
            
            msg.setMessageObject(
                cell.getMessageObject(), 
                cell.getCurrentMessagesGroup(),
                cell.pinnedBottom,
                cell.pinnedTop,
                cell.firstInChat)
            
            msg.setDelegate(cell.getDelegate())
        elif isinstance(cell, ChatActionCell):
            msg = ChatActionCell(
                ctx()
            )
            
            msg.setMessageObject(cell.getMessageObject(), True)
        else:
            msg = None
        return msg

class CreateMenuHook(MethodHook):
    def before_hooked_method(self, param):
        global current_chat_activity, current_message_cell
        current_chat_activity = param.thisObject
        current_message_cell = param.args[0]

class AnimatorUpdateListener(dynamic_proxy(ValueAnimator.AnimatorUpdateListener)):
    def __init__(self, fn: Callable[[ValueAnimator], None]):
        super().__init__()
        self.fn = fn
        
    def onAnimationUpdate(self, animation):
        self.fn(animation)

class OnPopupDismiss(dynamic_proxy(PopupWindow.OnDismissListener)):
    def __init__(self, fn: Callable[[], None]):
        super().__init__()
        self.fn = fn
    
    def onDismiss(self):
        self.fn()

class RunnableFactory(dynamic_proxy(Runnable)):
    def __init__(self, fn: Callable):
        super().__init__()
        self.fn = fn
    
    def run(self):
        self.fn()

class AndroidUtils:
    @staticmethod
    def get_location_on_screen(view) -> Tuple[int, int]:
        coords = view.getLocationOnScreen()
        return coords[0], coords[1] 
    
    