__id__ = "ios_like_selection"
__name__ = "IOS-like selection"
__description__ = "Tries to recreate the effect of selecting a message by tapping like on IOS"
__author__ = "@PESSDES_Plugins"
__min_version__ = "12.0.0" 
__icon__ = "VoiceToText7/6"
__version__ = "6.7"

from android.os import Build

BLUR_SUPPORTED = Build.VERSION.SDK_INT >= 31

from typing import Any, Callable, Tuple

from android.animation import (Animator, AnimatorSet, ObjectAnimator,
                               ValueAnimator)

if BLUR_SUPPORTED:
    from android.graphics import RenderEffect, Shader

import time

from android.graphics import Color, PorterDuff
from android.graphics.drawable import BitmapDrawable
from android.view import Gravity, MotionEvent, View, ViewGroup
from android.view.animation import (AccelerateDecelerateInterpolator,
                                    AccelerateInterpolator,
                                    AnticipateInterpolator,
                                    AnticipateOvershootInterpolator,
                                    BounceInterpolator, DecelerateInterpolator,
                                    LinearInterpolator, OvershootInterpolator)
from android.widget import FrameLayout, LinearLayout, PopupWindow, ScrollView
from android_utils import OnClickListener
from android_utils import log as logcat
from android_utils import run_on_ui_thread
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment
from hook_utils import get_private_field, set_private_field
from java import dynamic_proxy
from java import jint as JInt
from java.lang import Boolean, Float, Integer, Runnable
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import ActionBarPopupWindow
from org.telegram.ui.Cells import ChatActionCell, ChatMessageCell
from org.telegram.ui.Components import LayoutHelper, ReactionsContainerLayout
from ui.settings import Divider, Header, Selector, Switch


def log(*msg):
    m = msg if len(msg) > 1 else msg[0]
    if isinstance(m, Exception) and m.__traceback__ is not None:
        m = f"{m.__traceback__.tb_lineno}: {m}"
    logcat(f'[{__id__}] {m}')

def ctx():
    return get_last_fragment().getContext()

jboolean = Boolean.TYPE
jfloat = Float.TYPE
jint = Integer.TYPE

MATCH_PARENT = ViewGroup.LayoutParams.MATCH_PARENT
WRAP_CONTENT = ViewGroup.LayoutParams.WRAP_CONTENT

def get_display_metrics():
    try:
        display_metrics = ctx().getResources().getDisplayMetrics()
    except Exception as e:
        display_metrics = None
        log(e)
        
    if not display_metrics:
        display_metrics = AndroidUtilities.displayMetrics
        
    if not display_metrics:
        display_metrics = AndroidUtilities.displaySize
        return display_metrics.x, display_metrics.y 

    return display_metrics.widthPixels, display_metrics.heightPixels

display_width, display_height = get_display_metrics()

class Plugin(BasePlugin):
    instance: "Plugin | None" = None
    
    def on_plugin_load(self) -> None:
        self.dismiss_hook = None
        Plugin.instance = self
        
        self.hook_method(
            ChatActivity.getClass().getDeclaredMethod("createMenu", View, jboolean, jboolean, jfloat, jfloat, jboolean, jboolean), 
            CreateMenuHook())
        
        self.hook_method(
            ActionBarPopupWindow.getClass().getDeclaredMethod("showAtLocation", View, jint, jint, jint),
            ShowPopupHook()
        )
        
        self.hook_method(
            ChatMessageCell.getClass().getDeclaredMethod("onLongPress"),
            PreventTouch()
        )
        
        self.hook_method(
            ChatMessageCell.getClass().getDeclaredMethod("onTouchEvent", MotionEvent),
            PreventTouch()
        )
    
    blurs = [
        25,
        50,
        100,
        150,
        250,
        350
    ]
    
    animations_speed = [
        0.25,
        0.5,
        0.75,
        1,
        1.5,
        2,
        2.5,
        3
    ]
    
    interpolators = [
        AccelerateDecelerateInterpolator, AccelerateInterpolator, AnticipateInterpolator, AnticipateOvershootInterpolator, BounceInterpolator, OvershootInterpolator, DecelerateInterpolator, LinearInterpolator, 
    ]
    
    def create_settings(self) -> list[Any]:
        try:
            settings = []
            settings.append(Header("Blur"))
            settings.append(Selector('radius', 'Blur Radius', items=[str(x) for x in self.blurs], icon='msg_palette', default=2, link_alias="blur_radius"))
            settings.append(Switch("force_simple", "Simple mode", False, subtext="Uses more optimized blur method if enabled. Enable this if you experience lag with regular blur", link_alias="simple_mode"))
            settings.append(Divider('A larger blur radius may cause lags'))
            
            settings.append(Header("Animations"))
            settings.append(Switch('enable_animations', 'Enable animations', True, link_alias="animations"))
            if self.get_setting("enable_animations", True):
                settings.append(Selector('animations_speed', 'Animations speed', default=3, items=[f'x{x}' for x in self.animations_speed], icon="msg_premium_speed", link_alias="animations_speed"))
                settings.append(Selector('interpolator', 'Interpolator', 6, [x.getClass().getSimpleName().replace('Interpolator', '') for x in self.interpolators.copy()], icon="msg_noise_on", link_alias="interpolator"))
                settings.append(Divider('An Interpolator controls how the animation’s speed changes over time and how smooth it is'))
            settings.append(Header("Others"))
            settings.append(Switch("scroll_from_bottom", "Scroll from bottom", True, link_alias="bottom_scroll"))
            settings.append(Switch("sticky_reactions_bar", '"Sticky" reactions bar', True, subtext="Moves the reaction panel over the message like IOS", link_alias="sticky_reactions_bar"))
            return settings
        except Exception as e:
            log(e)
    
    @classmethod
    def get_radius(cls):
        try:
            if not cls.instance:
                return cls.blurs[2]
            return cls.blurs[int(cls.instance.get_setting('radius', 2))]
        except Exception as e:
            log(e)
    
    @classmethod
    def get_animation_speed(cls):
        if not cls.instance:
            return cls.animations_speed[3]
        return 0 if not cls.instance.get_setting("enable_animations", True) else cls.animations_speed[int(cls.instance.get_setting("animations_speed", 3))]
    
    @classmethod
    def get_interpolator(cls):
        if not cls.instance:
            return cls.interpolators[6]
        return cls.interpolators[min(len(cls.interpolators), cls.instance.get_setting("interpolator", 6))]()
    
    @classmethod
    def scroll_from_bottom(cls):
        if not cls.instance:
            return True
        return cls.instance.get_setting("scroll_from_bottom", True)
    
    @classmethod
    def use_alt_blur(cls):
        if not cls.instance:
            return not BLUR_SUPPORTED
        return not BLUR_SUPPORTED or cls.instance.get_setting("force_simple")

    @classmethod
    def sticky_reactions_bar(cls):
        if not cls.instance:
            return True
        return cls.instance.get_setting("sticky_reactions_bar", True)

current_chat_activity: ChatActivity | None = None
current_message_cell: ChatMessageCell | ChatActionCell | None = None
touch_time = 0

def apply_blur(view, radius):
    if BLUR_SUPPORTED:
        if radius <= 0:
            view.setRenderEffect(None)
        else:
            view.setRenderEffect(RenderEffect.createBlurEffect(radius, radius, Shader.TileMode.MIRROR))

class PreventTouch(MethodHook):
    def before_hooked_method(self, param):
        if param.thisObject.getTag() == __id__:
            param.setResult(False)

class ShowPopupHook(MethodHook):  
    def __init__(self) -> None:
        self.out_animation: AnimatorSet | None = None
        
    def before_hooked_method(self, param):
        if not current_chat_activity or time.time() - touch_time > 0.25:
            return
        
        self.original_y = param.args[3]
        self.original_x = param.args[2]
        param.args[2] = JInt(0) # x
        param.args[3] = JInt(0) # y
        
        self._before_hooked_method(param.thisObject, *param.args)
    
    def _pop_globals(self) -> Tuple[ChatActivity | None, ChatMessageCell | ChatActionCell | None]:
        global current_chat_activity, current_message_cell
        ca, mc = current_chat_activity, current_message_cell
        current_chat_activity = None
        current_message_cell = None
        return ca, mc
    
    def _before_hooked_method(self, this: ActionBarPopupWindow, *_):    
        try:
            if self.out_animation is not None and self.out_animation.isRunning():
                self.out_animation.cancel()
                self.out_animation = None
                
            current_chat_activity, current_message_cell = self._pop_globals()
            grouped = isinstance(current_message_cell, ChatMessageCell) and current_message_cell.getCurrentMessagesGroup() is not None
            if grouped:
                cell = None
            else:
                cell = self._copy_message_cell(current_message_cell)
                if not cell:
                    return

            this.setWidth(MATCH_PARENT)
            this.setHeight(MATCH_PARENT)
            this.setClippingEnabled(False) 
            
            old_content = this.getContentView()
            children = []
            for i in range(old_content.getChildCount()):
                children.append(old_content.getChildAt(i))

            old_content.removeAllViews()

            new_content = FrameLayout(ctx())
            new_content.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            new_content.setClickable(True) 
            new_content.setClipChildren(False)

            scroll_view = ScrollView(ctx())
            scroll_view.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            scroll_view.setFillViewport(True)
            scroll_view.setClipChildren(False)
            scroll_view.setClipToPadding(False)
            scroll_view.setOverScrollMode(View.OVER_SCROLL_NEVER) 
            scroll_view.setVerticalScrollBarEnabled(False)

            inner_container = LinearLayout(ctx())
            inner_container.setOrientation(LinearLayout.VERTICAL)
            inner_container.setLayoutParams(FrameLayout.LayoutParams(MATCH_PARENT, MATCH_PARENT))
            
            w_spec = View.MeasureSpec.makeMeasureSpec(display_width, View.MeasureSpec.AT_MOST)
            h_spec = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED)

            if cell:
                is_out = current_message_cell.getMessageObject().isOut()
                lp = LayoutHelper.createLinear(WRAP_CONTENT, WRAP_CONTENT, Gravity.RIGHT if is_out else Gravity.LEFT)
            else:
                is_out = None
                lp = None
                
            reactions_height = 0
            reactions_view: ReactionsContainerLayout | None = None
            if len(children) > 0 and isinstance(children[0], ReactionsContainerLayout):
                reactions_view = children.pop(0)
                if lp:
                    reactions_view.setLayoutParams(lp)
                else:
                    reactions_view.setLayoutParams(LayoutHelper.createLinear(WRAP_CONTENT, WRAP_CONTENT, Gravity.LEFT))
                
                reactions_view.measure(w_spec, h_spec)
                reactions_height = reactions_view.getMeasuredHeight()
            
            if cell:
                cell.setLayoutParams(LinearLayout.LayoutParams(WRAP_CONTENT, WRAP_CONTENT))
                inner_container.addView(cell)
                cell.setLongClickable(False)
                cell.setClickable(False)
                cell.setOnClickListener(OnClickListener(lambda *_: None))
            
            dismiss = OnClickListener(lambda *_: this.dismiss())
            inner_container.setOnClickListener(dismiss)
            new_content.setOnClickListener(dismiss)
            scroll_view.setOnClickListener(dismiss)
            
            message_height = current_message_cell.getHeight() if cell else 0

            bottom_menu_height = 0
            popup_actions_menu = None
            
            for child in children:
                if lp:
                    child.setLayoutParams(lp)
                inner_container.addView(child)
                
                child.measure(w_spec, h_spec)
                bottom_menu_height += child.getMeasuredHeight()
                
                if not popup_actions_menu and isinstance(child, ActionBarPopupWindow.ActionBarPopupWindowLayout):
                    popup_actions_menu = child
                    
            scroll_view.addView(inner_container)
            new_content.addView(scroll_view)

            if cell:
                _, original_msg_y = AndroidUtils.get_location_on_screen(current_message_cell)
            else:
                original_msg_y = self.original_y + reactions_height
                inner_container.setPadding(self.original_x,0,0,0)
            
            top_limit = AndroidUtilities.statusBarHeight + AndroidUtilities.dp(24)
            bottom_limit = AndroidUtilities.navigationBarHeight + AndroidUtilities.dp(12)
            
            padding_top = original_msg_y - reactions_height
            
            menu_height = reactions_height + bottom_menu_height + message_height
            
            if display_height - padding_top < menu_height:
                padding_top = display_height - menu_height

            if padding_top < top_limit:
                padding_top = top_limit
            elif padding_top + menu_height > display_height - bottom_limit:
                padding_top = display_height - bottom_limit - menu_height

            bar = False
            need_scroll = padding_top + menu_height - reactions_height > display_height
            scroll_bottom = False
            if need_scroll:
                if Plugin.scroll_from_bottom():
                    scroll_view.post(RunnableFactory(lambda: scroll_view.fullScroll(View.FOCUS_DOWN)))
                    scroll_bottom = True
                    
                if reactions_view is not None and Plugin.sticky_reactions_bar() and cell and is_out is not None:
                    reactions_bar = FrameLayout(ctx())
                    reactions_bar.addView(reactions_view)
                    reactions_view.setLayoutParams(LayoutHelper.createFrame(WRAP_CONTENT, WRAP_CONTENT, Gravity.RIGHT if is_out else Gravity.LEFT))
                    new_content.addView(reactions_bar, lp)
                    reactions_bar.setTranslationY(padding_top)
                    bar = True
            
            if reactions_view is not None and not bar:
                inner_container.addView(reactions_view, 0)
            
            idk_how_to_name_ts = reactions_height if bar else 0
            if padding_top + menu_height - idk_how_to_name_ts > display_height - bottom_limit:  
                scroll_view.setPadding(0, 0, 0, bottom_limit)
              
            spacer = View(ctx())
            spacer.setLayoutParams(LinearLayout.LayoutParams(MATCH_PARENT, int(padding_top + idk_how_to_name_ts)))
            spacer.setOnClickListener(dismiss)
            inner_container.addView(spacer, 0)
            
            message_y = padding_top + reactions_height
            
            this.setContentView(new_content)
            
            def animate(out):
                if not out and scroll_bottom:
                    scroll_y = max(0, menu_height + idk_how_to_name_ts - display_height)
                else:
                    scroll_y = scroll_view.getScrollY()
                    
                return self.animate(
                    out, 
                    this, 
                    (original_msg_y - message_y + scroll_y) if cell else None, 
                    popup_actions_menu, 
                    current_chat_activity, 
                    current_message_cell if cell else None, 
                    reactions_view, 
                    cell,
                    inner_container)
            
            animate(False)
            
            if is_out != None:
                pad = AndroidUtilities.dp(8)    
                popup_actions_menu.setTranslationX(-pad if is_out else pad)
                  
            def _on_dimiss(param):
                if this == param.thisObject:
                    self._pop_globals()
                    self.out_animation = animation = animate(True)
                    if animation is not None:
                        param.setResult(None)
                        new_content.setClickable(False)
                        scroll_view.setClickable(False)
                        inner_container.setClickable(False)
                        animation.addListener(AnimatorListener(lambda *a: this.dismiss(False)))
                    
            self.dismiss_fn = _on_dimiss
            if Plugin.instance and Plugin.instance.dismiss_hook is None:
                Plugin.instance.dismiss_hook = Plugin.instance.hook_method(
                    ActionBarPopupWindow.getClass().getDeclaredMethod("dismiss", jboolean), 
                    self.OnDismiss(self._on_dismiss))
        except Exception as e:
            log(e)
    
    def _on_dismiss(self, param):
        if self.dismiss_fn and param.args[0]:
            self.dismiss_fn(param)
    
    class OnDismiss(MethodHook):
        def __init__(self, fn) -> None:
            super().__init__()
            self.fn = fn
            
        def before_hooked_method(self, param):
            try:
                self.fn(param)
            except Exception as e:
                log(e)
    
    def animate(self, out: bool = False, popup: ActionBarPopupWindow | None = None, message_translation: int | None = None, popup_actions: ActionBarPopupWindow.ActionBarPopupWindowLayout | None = None, current_chat_activity: ChatActivity | None = None, current_message_cell: ChatActionCell | ChatMessageCell | None = None, reactions_view: View | None = None, new_cell: ChatActionCell | ChatMessageCell | None = None, inner_container = None):
        try:
            radius = Plugin.get_radius()
            speed = Plugin.get_animation_speed()
            duration = int(250 / speed) if speed > 0 else 0
            interploator = Plugin.get_interpolator()
            
            def alt_blur(enable):
                drawable = popup.getBackground()
                if enable and drawable is None and current_chat_activity is not None:
                    drawable = BitmapDrawable(AndroidUtilities.makeBlurBitmap(current_chat_activity.getContentView(), 10, int(radius / 10))).mutate()
                    drawable.setColorFilter(Color.parseColor("#35000000"), PorterDuff.Mode.DARKEN)
                    popup.setBackgroundDrawable(drawable)
                    set_cell_visibility(not out) # Исправление мерциния
                    set_cell_visibility(out, True)
                elif not enable and drawable is not None:
                    run_on_ui_thread(lambda: popup.setBackgroundDrawable(None), duration)
                
                if speed != 0:
                    animations.append(ObjectAnimator.ofInt(drawable, "alpha", 0, 255))
               
            alt = Plugin.use_alt_blur()

            def set_cell_visibility(visible, delay = False):
                if not new_cell or not isinstance(current_message_cell, ChatMessageCell) or not message_translation or message_translation == 0:
                    return
                
                def do():
                    if visible:
                        current_message_cell.updateTranslation()
                    else:
                        def do():
                            current_message_cell.setTranslationX(current_message_cell.getTranslationX() + display_width)
                        
                        if alt: 
                            do()
                        else:        
                            new_cell.post(RunnableFactory(do))
                
                if delay:
                    run_on_ui_thread(do, 50)
                else:
                    do()
               
            if speed == 0:  
                set_cell_visibility(out)         
                if not alt:
                    apply_blur(current_chat_activity.getContentView(), radius if not out else 0)
                else:
                    alt_blur(not out)
            else:
                animations = []         
                
                if not out:
                    set_cell_visibility(False)
                
                if current_chat_activity is not None:
                    if not alt:
                        animator = ValueAnimator.ofFloat(0.0, radius)
                        animator.addUpdateListener(AnimatorUpdateListener(lambda animation, c = current_chat_activity: apply_blur(c.getContentView(), animation.getAnimatedValue())))
                        animations.append(animator)
                    else:
                        alt_blur(not out)
                
                if message_translation is not None and popup is not None and message_translation != 0:
                    c = inner_container or popup.getContentView()
                    animator = ObjectAnimator.ofFloat(c, "translationY", message_translation, 0)
                    animations.append(animator)
                
                def fade_anim(view):
                    animators = [ObjectAnimator.ofFloat(view, "scaleX", 0.3, 1),
                        ObjectAnimator.ofFloat(view, "scaleY", 0.3, 1),
                        ObjectAnimator.ofFloat(view, "alpha", 0 if out else 0.5, 1)
                    ]
                    animations.extend(animators)
                
                if popup_actions is not None:
                    popup_actions.setPivotY(0)
                    popup_actions.setPivotX(popup_actions.getMeasuredWidth() / 2)
                    fade_anim(popup_actions)

                if reactions_view is not None:
                    reactions_view.setPivotY(reactions_view.getMeasuredHeight())
                    reactions_view.setPivotX(reactions_view.getMeasuredWidth() / 2)
                    fade_anim(reactions_view)
                
                if len(animations) > 0:
                    set = AnimatorSet()
                    set.playTogether(*animations)
                    set.setDuration(duration)
                    set.setInterpolator(interploator)
                    if not out:
                        set.start()
                    else:
                        set.reverse()
                    
                    if out:
                        run_on_ui_thread(lambda: set_cell_visibility(True), max(0, duration - 30))
                    
                    return set
            return None
        except Exception as e:
            log(e)
            return None
    
    @staticmethod
    def _copy_message_cell(cell: ChatMessageCell | ChatActionCell | None):
        if isinstance(cell, ChatMessageCell):
            new_cell = ChatMessageCell(
                ctx(),
                cell.currentAccount)
            cell.copyParamsTo(new_cell)
            set_private_field(new_cell, "isThreadPost", get_private_field(cell, "isThreadPost"))
            
            new_cell.setMessageObject(
                cell.getMessageObject(), 
                cell.getCurrentMessagesGroup(),
                cell.pinnedBottom,
                cell.pinnedTop,
                cell.firstInChat)
            
            new_cell.setDelegate(cell.getDelegate())
            new_cell.setTag(__id__)
        elif isinstance(cell, ChatActionCell):
            new_cell = ChatActionCell(
                ctx()
            )
            
            new_cell.setMessageObject(cell.getMessageObject(), True)
        else:
            new_cell = None
        return new_cell

class CreateMenuHook(MethodHook):
    def before_hooked_method(self, param):
        global current_chat_activity, current_message_cell, touch_time
        current_chat_activity = param.thisObject
        current_message_cell = param.args[0]
        touch_time = time.time()

class AnimatorUpdateListener(dynamic_proxy(ValueAnimator.AnimatorUpdateListener)):
    def __init__(self, fn: Callable[[ValueAnimator], None]):
        super().__init__()
        self.fn = fn
        
    def onAnimationUpdate(self, animation):
        self.fn(animation)

class OnPopupDismiss(dynamic_proxy(PopupWindow.OnDismissListener)):
    def __init__(self, fn: Callable[[], None]):
        super().__init__()
        self.fn = fn
    
    def onDismiss(self):
        self.fn()

class RunnableFactory(dynamic_proxy(Runnable)):
    def __init__(self, fn: Callable):
        super().__init__()
        self.fn = fn
    
    def run(self):
        self.fn()

class AnimatorListener(dynamic_proxy(Animator.AnimatorListener)):
    def __init__(self, on_end: Callable):
        super().__init__()
        self.on_end = on_end
        
    def onAnimationEnd(self, *a):
        self.on_end(*a)

class OnTouchListener(dynamic_proxy(View.OnTouchListener)):
    def __init__(self, on_touch: Callable):
        super().__init__()
        self.on_touch = on_touch
    
    def onTouch(self, view, event):
        result = self.on_touch(view, event)
        if not isinstance(result, bool):
            return False
        return result

class AndroidUtils:
    @staticmethod
    def get_location_on_screen(view) -> Tuple[int, int]:
        coords = view.getLocationOnScreen()
        return coords[0], coords[1] 
    
    