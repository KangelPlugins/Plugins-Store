from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.settings import Switch, Header, Divider, Text, Selector
from ui.bulletin import BulletinHelper
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment, log
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from java.util import Locale
import json
import time
import traceback
import hashlib
import os
import threading
import urllib.request
import uuid

__id__ = "shortcuts"
__name__ = "Shortcuts"
__description__ = "Cоздает ярлыки на настройки, включение/отклочение плагинов, и сами настройки плагина\n\nесть сбор статистики mkStats"
__icon__ = "feature_plugins/3"
__version__ = "1.1"
__min_version__ = "12.1.1"
__author__ = "@feature_plugins"

# === mkStats: embed client start ===
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))
MKSTATS_POW_SOLVE_SECONDS = int(os.getenv("MKSTATS_POW_SOLVE_SECONDS", "6"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def generate_device_fingerprint(device_id: str) -> str:
    payload = f"{device_id}:mkstats:device:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

def _pow_valid(challenge: str, nonce: str, difficulty: int) -> bool:
    if not challenge or not nonce or difficulty <= 0:
        return False
    prefix = "0" * max(1, int(difficulty))
    digest = hashlib.sha256(f"{challenge}:{nonce}".encode("utf-8")).hexdigest()
    return digest.startswith(prefix)

def _solve_pow(challenge: str, difficulty: int, max_seconds: int = MKSTATS_POW_SOLVE_SECONDS) -> str | None:
    difficulty = max(1, int(difficulty or 0))
    deadline = time.time() + max(1, int(max_seconds or 0))
    nonce = 0
    prefix = "0" * difficulty
    while time.time() < deadline:
        candidate = format(nonce, "x")
        digest = hashlib.sha256(f"{challenge}:{candidate}".encode("utf-8")).hexdigest()
        if digest.startswith(prefix):
            return candidate
        nonce += 1
    return None

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, plugin_version: str, user_hash: str, device_fingerprint: str, client_version: str | None = None, client_name: str | None = None) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.plugin_version = plugin_version
        self.client_version = client_version
        self.client_name = client_name
        self.user_hash = user_hash
        self.device_fingerprint = device_fingerprint

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
        }
        response = _post_json(f"{self.api_base}/handshake", payload)
        token = (response or {}).get("install_token", "")
        if token:
            return response
        pow_required = bool((response or {}).get("pow_required"))
        pow_challenge = (response or {}).get("pow_challenge")
        if pow_required and pow_challenge:
            difficulty = int((response or {}).get("pow_difficulty") or 0)
            nonce = _solve_pow(pow_challenge, difficulty)
            if nonce and _pow_valid(pow_challenge, nonce, difficulty):
                payload["pow_challenge"] = pow_challenge
                payload["pow_nonce"] = nonce
                response = _post_json(f"{self.api_base}/handshake", payload)
        return response

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)
# === mkStats: embed client end ===

STRINGS = {
    "en": {
        "shortcuts": "Shortcuts",
        "plugins": "Plugins",
        "no_plugins": "No other plugins",
        "settings": "Settings",
        "add_shortcut": "Add shortcut",
        "remove_shortcut": "Remove shortcut",
        "restart": "Restart engine",
        "actions": "Actions",
        "location": "Location",
        "drawer": "Drawer",
        "chat_menu": "Chat menu",
        "both_places": "Drawer + Chat",
        "type": "Type",
        "toggle_plugin": "Toggle plugin",
        "open_settings": "Open settings",
        "next": "Next...",
        "create": "Create",
        "shortcut_created": "Shortcut created",
        "shortcut_removed": "Shortcut removed",
        "engine_restarted": "Engine restarted",
        "manage_plugins": "Installed plugins",
        "has_settings": "Settings available",
        "no_settings": "No settings",
        "plugin_list": "Plugin List",
        "settings_btn": "Settings",
        "error": "Error",
        "plugin_not_found": "Plugin not found",
        "quick_access": "Quick access to settings",
        "quick_access_sub": "Add Shortcuts to the main menu",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Anonymous usage statistics",
        "auto_remove_missing": "Auto-remove missing plugin shortcuts",
        "auto_remove_missing_sub": "Automatically delete shortcuts if target plugin is missing",
        "missing_shortcuts_removed": "Removed missing shortcuts",
        "operate_setting": "Change setting",
        "select_setting": "Select a setting to control",
        "choose_value": "Choose a new value"
    },
    "ru": {
        "shortcuts": "Ярлыки",
        "plugins": "Плагины",
        "no_plugins": "Нет других плагинов",
        "settings": "Настройки",
        "add_shortcut": "Добавить ярлык",
        "remove_shortcut": "Удалить ярлык",
        "restart": "Перезагрузить движок",
        "actions": "Действия",
        "location": "Расположение",
        "drawer": "Боковое меню",
        "chat_menu": "Меню чата",
        "both_places": "Боковое меню + Меню чата",
        "type": "Тип",
        "toggle_plugin": "Вкл/Откл плагин",
        "open_settings": "Открыть настройки",
        "next": "Далее...",
        "create": "Создать",
        "shortcut_created": "Ярлык создан",
        "shortcut_removed": "Ярлык удален",
        "engine_restarted": "Движок перезагружен",
        "manage_plugins": "Установленные плагины",
        "has_settings": "Есть настройки",
        "no_settings": "Нет настроек",
        "plugin_list": "Список плагинов",
        "settings_btn": "Настройки",
        "error": "Ошибка",
        "quick_access": "Быстрый доступ к настройкам",
        "quick_access_sub": "Добавить 'Ярлыки' в главное меню",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Анонимная статистика использования",
        "operate_setting": "Управление настройкой",
        "select_setting": "Выберите настройку для управления",
        "choose_value": "Выберите новое значение",
        "plugin_not_found": "Плагин не найден",
        "auto_remove_missing": "Автоудаление ярлыков отсутствующих плагинов",
        "auto_remove_missing_sub": "Автоматически удалять ярлыки, если плагин не найден",
        "missing_shortcuts_removed": "Удалено ярлыков отсутствующих плагинов"
    }
}

def _s(key):
    lang = "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    return STRINGS.get(lang, STRINGS["en"]).get(key, key)

def _ctrl():
    return PluginsController.getInstance()

def _plugin_ids():
    try:
        ids = []
        for key in _ctrl().plugins.keySet().toArray():
            pid = str(key)
            if pid != __id__:
                ids.append(pid)
        ids.sort()
        return ids
    except Exception as e:
        log(f"[{__id__}] _plugin_ids: {e}")
        return []

def _plugin_name(pid):
    try:
        p = _ctrl().plugins.get(pid)
        if p and p.getName():
            return str(p.getName())
    except:
        pass
    return pid

def _plugin_exists(pid):
    try:
        return _ctrl().plugins.get(pid) is not None
    except:
        return False

def _has_settings(pid):
    try:
        ctrl = _ctrl()
        if ctrl.hasPluginSettings(pid):
            return True
        lst = ctrl.getPluginSettingsList(pid)
        if lst is not None:
            return True
        if ctrl.hasPluginSettingsPreferences(pid):
            return True
    except:
        pass
    return False

def _get_settings_list(pid, ensure_loaded=False, wait_seconds=0.6):
    ctrl = _ctrl()
    try:
        lst = ctrl.getPluginSettingsList(pid)
        if lst is not None:
            return lst
    except:
        pass
    if not ensure_loaded:
        return None
    try:
        ctrl.loadPluginSettings(pid)
    except:
        return None
    deadline = time.time() + max(0.0, float(wait_seconds))
    while time.time() < deadline:
        try:
            lst = ctrl.getPluginSettingsList(pid)
            if lst is not None:
                return lst
        except:
            pass
        time.sleep(0.05)
    try:
        return ctrl.getPluginSettingsList(pid)
    except:
        return None

def _has_settings_reliably(pid):
    if _has_settings(pid):
        return True
    lst = _get_settings_list(pid, ensure_loaded=True, wait_seconds=0.45)
    return lst is not None

def _to_py_list(seq):
    if seq is None:
        return []
    try:
        return list(seq)
    except:
        pass
    try:
        arr = seq.toArray()
        try:
            return list(arr)
        except:
            return [x for x in arr]
    except:
        pass
    try:
        n = int(seq.size())
        return [seq.get(i) for i in range(n)]
    except:
        pass
    return []

def _open_link_key(prefix, key, alias=None):
    tail = alias or key
    if not tail:
        return None
    return f"{prefix}:{tail}" if prefix else tail

class ShortcutsPlugin(BasePlugin):

    # === mkStats: integration start ===
    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_get_client_version(self) -> str:
        try:
            from org.telegram.messenger import BuildVars
            version = getattr(BuildVars, "BUILD_VERSION_STRING", None) or getattr(BuildVars, "BUILD_VERSION", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import BuildConfig as TgBuildConfig
            version = getattr(TgBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            version = getattr(AyuBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            version = getattr(ExBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pm = ctx.getPackageManager()
                pkg = ctx.getPackageName()
                info = pm.getPackageInfo(pkg, 0)
                version = getattr(info, "versionName", None) or getattr(info, "versionCode", None)
                if version:
                    return str(version)
        except Exception:
            pass
        return "unknown"

    def _mkstats_get_client_name(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pkg = ctx.getPackageName()
                if pkg == "com.radolyn.ayugram":
                    return "AyuGram"
                if pkg == "com.exteragram.messenger":
                    return "exteraGram"
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            _ = AyuBuildConfig.VERSION_NAME
            return "AyuGram"
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            _ = ExBuildConfig.VERSION_NAME
            return "exteraGram"
        except Exception:
            pass
        return "unknown"

    def _mkstats_log(self, message: str) -> None:
        if hasattr(self, "log"):
            try:
                self.log(message)
            except Exception:
                pass

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self._mkstats_log(f"mkStats: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    self._mkstats_log("mkStats: handshake start")
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                        self._mkstats_log("mkStats: handshake ok, token stored")
                    else:
                        self._mkstats_log("mkStats: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_log("mkStats: sending ping")
                    self._mkstats_client.send_ping(self._mkstats_token)
                    self._mkstats_log("mkStats: ping sent")
            except Exception as exc:
                self._mkstats_log(f"mkStats: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            device_fingerprint = generate_device_fingerprint(device_id)
            client_name = self._mkstats_get_client_name()
            client_version = self._mkstats_get_client_version()
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash, device_fingerprint, client_version, client_name)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self._mkstats_log(f"mkStats: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass
    # === mkStats: integration end ===

    def __init__(self):
        super().__init__()
        self._menu_items = []
        self._qa_mid = None

    def on_plugin_load(self):
        # === Feature Toggles ===
        enable_analytics = self.get_setting("enable_analytics", True)

        # === mkStats: integration start ===
        if enable_analytics:
            self._mkstats_start()
        # === mkStats: integration end ===

        try:
            if bool(self.get_setting("auto_remove_missing", False)):
                self._cleanup_missing_shortcuts(restore_menus=False, notify=False)
            self._restore_shortcuts()
            self._update_quick_access()
        except Exception as e:
            log(f"[{__id__}] on_plugin_load: {e}")

    def on_plugin_unload(self):

        # === mkStats: integration start ===
        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self._mkstats_log("mkStats: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass
        # === mkStats: integration end ===

        self._clear_menu_items()
        if self._qa_mid:
            try:
                self.remove_menu_item(self._qa_mid)
            except:
                pass

    # ========== settings UI ==========
    def create_settings(self):
        settings = []
        try:
            settings = self._build_settings()
        except Exception as e:
            log(f"[{__id__}] create_settings: {e}\n{traceback.format_exc()}")
            settings = [Header(text=_s("shortcuts")), Divider(text=str(e))]
        return settings

    def _build_settings(self):
        settings = []

        # --- Ярлыки ---
        settings.append(Header(text=_s("shortcuts")))

        shortcuts = self._load_shortcuts()
        for i, sc in enumerate(shortcuts):
            label = self._sc_label(sc)
            loc_label = self._loc_label(sc.get("location", "drawer"))
            settings.append(Text(
                text=f"{label} [{loc_label}]",
                on_click=lambda v, _sc=sc: self._exec_shortcut(_sc)
            ))
            settings.append(Text(
                text=_s("remove_shortcut"),
                red=True,
                on_click=lambda v, _i=i: self._remove_shortcut(_i)
            ))

        settings.append(Text(
            text=_s("add_shortcut"),
            accent=True,
            create_sub_fragment=self._wizard_step1
        ))

        # --- Действия ---
        settings.append(Header(text=_s("actions")))
        
        # Тумблер быстрого доступа
        settings.append(Switch(
            key="quick_access",
            text=_s("quick_access"),
            subtext=_s("quick_access_sub"),
            default=False,
            on_change=lambda v: self._update_quick_access(v)
        ))
        settings.append(Switch(
            key="auto_remove_missing",
            text=_s("auto_remove_missing"),
            subtext=_s("auto_remove_missing_sub"),
            default=False,
            on_change=lambda v: self._on_auto_remove_missing_toggle(v)
        ))

        # Кнопка перехода к списку плагинов
        settings.append(Text(
            text=_s("manage_plugins"),
            create_sub_fragment=self._create_plugins_list,
            icon="msg_download"
        ))

        settings.append(Text(
            text=_s("restart"),
            on_click=lambda v: self._restart(),
            icon="msg_retry"
        ))

        settings.append(Divider())

        settings.append(Switch(
            key="enable_analytics",
            text=_s("enable_analytics"),
            subtext=_s("enable_analytics_sub"),
            icon="stats",
            default=True,
            on_change=lambda v: self._on_enable_analytics_toggle(v)
        ))

        return settings

    def _update_quick_access(self, enabled=None):
        if enabled is None:
            enabled = bool(self.get_setting("quick_access", False))
        
        if enabled:
            if not self._qa_mid:
                self._qa_mid = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text=_s("shortcuts"),
                    icon="media_settings",
                    priority=99,
                    on_click=lambda ctx: self._open_self_settings()
                ))
        else:
            if self._qa_mid:
                try:
                    self.remove_menu_item(self._qa_mid)
                except:
                    pass
                self._qa_mid = None

    def _on_enable_analytics_toggle(self, enabled):
        try:
            if enabled:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None and self._mkstats_thread.is_alive():
                    return
                self._mkstats_start()
                return
            if hasattr(self, "_mkstats_stop"):
                self._mkstats_stop.set()
            if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                self._mkstats_thread.join(timeout=1.0)
        except Exception as e:
            self._mkstats_log(f"mkStats toggle error: {e}")

    def _cleanup_missing_shortcuts(self, restore_menus=True, notify=False):
        sc_list = self._load_shortcuts()
        filtered = [sc for sc in sc_list if _plugin_exists(sc.get("plugin_id", ""))]
        removed = len(sc_list) - len(filtered)
        if removed <= 0:
            return 0
        self._save_shortcuts(filtered)
        if restore_menus:
            self._restore_shortcuts()
        if notify:
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"{_s('missing_shortcuts_removed')}: {removed}"))
        return removed

    def _on_auto_remove_missing_toggle(self, enabled):
        if enabled:
            self._cleanup_missing_shortcuts(restore_menus=True, notify=True)

    def _open_self_settings(self):
        def _do():
            try:
                plugin = _ctrl().plugins.get(__id__)
                if plugin:
                    frag = get_last_fragment()
                    if frag:
                        frag.presentFragment(PluginSettingsActivity(plugin))
            except Exception as e:
                log(f"[{__id__}] _open_self_settings: {e}")
        run_on_ui_thread(_do)

    def _create_plugins_list(self):
        items = []
        items.append(Header(text=_s("plugin_list")))
        
        pids = _plugin_ids()
        if not pids:
            items.append(Divider(text=_s("no_plugins")))
            return items
            
        for pid in pids:
            try:
                plugin = _ctrl().plugins.get(pid)
                if not plugin:
                    continue
                pname = _plugin_name(pid)
                
                sub = None
                has_s = _has_settings_reliably(pid)
                
                # Check error
                try:
                    if plugin.hasError():
                        err = plugin.getError()
                        sub = str(err.getMessage()) if err else _s("error")
                except:
                    pass
                
                if not sub:
                    sub = _s("has_settings") if has_s else _s("no_settings")

                # Используем Text вместо Switch, так как список теперь только информационный
                # Text не поддерживает аргумент subtext, поэтому объединяем всё в один заголовок
                items.append(Text(
                    text=f"{pname} ({sub})"
                ))
            except Exception as e:
                log(f"[{__id__}] plugin list item {pid}: {e}")
                
        return items

    def _collect_settings(self, pid, prefix=None):
        out = []
        try:
            log(f"[{__id__}] _collect_settings: start pid={pid}, prefix={prefix}")
        except:
            pass
        try:
            lst = _get_settings_list(pid, ensure_loaded=False)
        except Exception as e:
            lst = None
            try:
                log(f"[{__id__}] _collect_settings: getPluginSettingsList error {e}")
            except:
                pass
        if not lst:
            try:
                log(f"[{__id__}] _collect_settings: no settings for {pid}, request load")
                lst = _get_settings_list(pid, ensure_loaded=True)
            except Exception as e:
                lst = None
                try:
                    log(f"[{__id__}] _collect_settings: loadPluginSettings error {e}")
                except:
                    pass
        if not lst:
            return out
        def _add(t, key, text, items=None, pf=prefix, alias=None):
            kp = f"{pf}:{key}" if pf else key
            out.append({
                "type": t,
                "key": kp,
                "open_key": _open_link_key(pf, key, alias),
                "text": text,
                "items": items or []
            })
        try:
            for it in _to_py_list(lst):
                try:
                    itype = getattr(it, "type", None)
                    if itype in ("switch", "selector", "input", "edit_text"):
                        key = getattr(it, "key", None)
                        alias = getattr(it, "linkAlias", None)
                        text = getattr(it, "text", getattr(it, "hint", str(key)))
                        if not key:
                            continue
                        if itype == "selector":
                            opts = _to_py_list(getattr(it, "items", None))
                            _add("selector", key, text, opts, alias=alias)
                        elif itype == "switch":
                            _add("switch", key, text, alias=alias)
                        elif itype in ("input", "edit_text"):
                            _add("input", key, text, alias=alias)
                    elif itype == "text":
                        cb = getattr(it, "createSubFragmentCallback", None)
                        alias = getattr(it, "linkAlias", None)
                        tlabel = getattr(it, "text", None)
                        if cb and alias:
                            try:
                                py = cb.call()
                                eng = PluginsController.engines.get("python")
                                if eng:
                                    nested = eng.parsePySettingDefinitions(py.asList())
                                    subprefix = alias if not prefix else f"{prefix}:{alias}"
                                    for sub in _to_py_list(nested):
                                        st = getattr(sub, "type", None)
                                        key = getattr(sub, "key", None)
                                        text = getattr(sub, "text", getattr(sub, "hint", str(key)))
                                        if not key:
                                            continue
                                        sub_alias = getattr(sub, "linkAlias", None)
                                        if st == "selector":
                                            opts = _to_py_list(getattr(sub, "items", None))
                                            out.append({
                                                "type": "selector",
                                                "key": f"{subprefix}:{key}",
                                                "open_key": _open_link_key(subprefix, key, sub_alias),
                                                "text": f"{tlabel} / {text}",
                                                "items": opts
                                            })
                                        elif st == "switch":
                                            out.append({
                                                "type": "switch",
                                                "key": f"{subprefix}:{key}",
                                                "open_key": _open_link_key(subprefix, key, sub_alias),
                                                "text": f"{tlabel} / {text}"
                                            })
                                        elif st in ("input", "edit_text"):
                                            out.append({
                                                "type": "input",
                                                "key": f"{subprefix}:{key}",
                                                "open_key": _open_link_key(subprefix, key, sub_alias),
                                                "text": f"{tlabel} / {text}"
                                            })
                            except Exception as e:
                                try:
                                    log(f"[{__id__}] _collect_settings: sub-fragment parse error {e}")
                                except:
                                    pass
                except Exception as e:
                    try:
                        log(f"[{__id__}] _collect_settings: item parse error {e}")
                    except:
                        pass
        except Exception as e:
            try:
                log(f"[{__id__}] _collect_settings: iterate error {e}")
            except:
                pass
        try:
            log(f"[{__id__}] _collect_settings: total collected {len(out)} for {pid}")
        except:
            pass
        return out

    def _wizard_step3(self, pids):
        try:
            plug_i = _ctrl().getPluginSettingInt(__id__, "__wiz_plugin", 0)
        except:
            plug_i = 0
        if plug_i < 0 or plug_i >= len(pids):
            plug_i = 0
        pid = pids[plug_i]
        settings = [s for s in self._collect_settings(pid) if s.get("type") == "switch"]
        if not settings:
            return [Divider(text=_s("no_plugins"))]
        names = [s.get("text", s.get("key", "")) for s in settings]
        items = []
        items.append(Header(text=_s("select_setting")))
        items.append(Selector(
            key="__wiz_setting",
            text=_s("select_setting"),
            items=names,
            default=0
        ))
        items.append(Text(
            text=_s("create"),
            accent=True,
            on_click=lambda v, _pid=pid, _settings=settings: self._wizard_done_setting(_pid, _settings)
        ))
        return items

    def _wizard_done_setting(self, pid, settings):
        def _do():
            try:
                ctrl = _ctrl()
                loc_i = ctrl.getPluginSettingInt(__id__, "__wiz_loc", 0)
                plug_i = ctrl.getPluginSettingInt(__id__, "__wiz_plugin", 0)
                set_i = ctrl.getPluginSettingInt(__id__, "__wiz_setting", 0)
                loc = "both" if loc_i == 2 else ("drawer" if loc_i == 0 else "chat")
                if set_i < 0 or set_i >= len(settings):
                    set_i = 0
                sel = settings[set_i]
                sc = {
                    "type": "operate_setting",
                    "plugin_id": pid,
                    "location": loc,
                    "setting_key": sel.get("key"),
                    "setting_open_key": sel.get("open_key", sel.get("key")),
                    "setting_type": sel.get("type")
                }
                sc_list = self._load_shortcuts()
                sc_list.append(sc)
                self._save_shortcuts(sc_list)
                self._register_menu(sc)
                label = self._sc_label(sc)
                run_on_ui_thread(lambda: BulletinHelper.show_info(f"{_s('shortcut_created')}: {label}"))
                ctrl.loadPluginSettings(__id__)
            except Exception as e:
                log(f"[{__id__}] wizard_done_setting: {e}\n{traceback.format_exc()}")
                run_on_ui_thread(lambda: BulletinHelper.show_info(str(e)))
        import threading
        threading.Thread(target=_do, daemon=True).start()
    # ========== toggle plugin ==========
    def _toggle(self, pid, pname, enabled):
        def _do():
            try:
                _ctrl().setPluginEnabled(pid, enabled, None)
                msg = f"{pname}: ON" if enabled else f"{pname}: OFF"
                run_on_ui_thread(lambda: BulletinHelper.show_info(msg))
            except Exception as e:
                log(f"[{__id__}] toggle {pid}: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_info(str(e)))
        import threading
        threading.Thread(target=_do, daemon=True).start()

    # ========== open settings ==========
    def _open_settings(self, pid, setting_key=None):
        def _do():
            try:
                if setting_key:
                    _ctrl().openPluginSetting(pid, setting_key)
                else:
                    frag = get_last_fragment()
                    if not frag:
                        return
                    eng = _ctrl().getPluginEngine(pid)
                    if eng:
                        eng.openPluginSettings(pid, frag)
                        return
                    plugin = _ctrl().plugins.get(pid)
                    if plugin:
                        frag.presentFragment(PluginSettingsActivity(plugin))
            except Exception as e:
                log(f"[{__id__}] open_settings {pid}: {e}")
        run_on_ui_thread(_do)

    # ========== restart ==========
    def _restart(self):
        def _do():
            try:
                _ctrl().restart()
                run_on_ui_thread(lambda: BulletinHelper.show_info(_s("engine_restarted")))
            except Exception as e:
                log(f"[{__id__}] restart: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_info(str(e)))
        import threading
        threading.Thread(target=_do, daemon=True).start()

    # ========== shortcuts ==========
    def _load_shortcuts(self):
        try:
            return json.loads(self.get_setting("shortcuts_json", "[]"))
        except:
            return []

    def _save_shortcuts(self, sc_list):
        self.set_setting("shortcuts_json", json.dumps(sc_list, ensure_ascii=False))

    def _restore_shortcuts(self):
        self._clear_menu_items()
        for sc in self._load_shortcuts():
            try:
                self._register_menu(sc)
            except Exception as e:
                log(f"[{__id__}] restore shortcut: {e}")

    def _clear_menu_items(self):
        for mid in self._menu_items:
            try:
                self.remove_menu_item(mid)
            except:
                pass
        self._menu_items = []

    def _register_menu(self, sc):
        label = self._sc_label(sc)
        loc = sc.get("location", "drawer")
        menu_types = [MenuItemType.DRAWER_MENU, MenuItemType.CHAT_ACTION_MENU] if loc == "both" else [
            MenuItemType.DRAWER_MENU if loc == "drawer" else MenuItemType.CHAT_ACTION_MENU
        ]
        for mt in menu_types:
            mid = self.add_menu_item(MenuItemData(
                menu_type=mt,
                text=label,
                icon="media_share",
                priority=10,
                on_click=lambda ctx, _sc=sc: self._exec_shortcut(_sc)
            ))
            if mid:
                self._menu_items.append(mid)

    def _loc_label(self, loc):
        if loc == "chat":
            return _s("chat_menu")
        if loc == "both":
            return _s("both_places")
        return _s("drawer")

    def _sc_label(self, sc):
        pid = sc.get("plugin_id", "?")
        pname = _plugin_name(pid)
        t = sc.get("type", "toggle_plugin")
        if t == "toggle_plugin":
            return f"Toggle: {pname}"
        elif t == "open_settings":
            return f"{_s('settings')}: {pname}"
        elif t == "operate_setting":
            sk = sc.get("setting_key", "")
            base = sk.split(":")[-1] if ":" in sk else sk
            return f"{pname}: {base}"
        return pname

    def _exec_shortcut(self, sc):
        t = sc.get("type", "toggle_plugin")
        pid = sc.get("plugin_id", "")

        if not _plugin_exists(pid):
            if bool(self.get_setting("auto_remove_missing", False)):
                self._cleanup_missing_shortcuts(restore_menus=True, notify=False)
            run_on_ui_thread(lambda: BulletinHelper.show_info(f"{pid}: {_s('plugin_not_found')}"))
            return
        
        if t == "toggle_plugin":
            plugin = _ctrl().plugins.get(pid)
            if plugin:
                self._toggle(pid, _plugin_name(pid), not bool(plugin.isEnabled()))
                
        elif t == "open_settings":
            if not _has_settings_reliably(pid):
                run_on_ui_thread(lambda: BulletinHelper.show_info(f"{_plugin_name(pid)}: {_s('no_settings')}"))
                return
            self._open_settings(pid)
        elif t == "operate_setting":
            sk = sc.get("setting_key", "")
            ok = sc.get("setting_open_key", sk)
            st = sc.get("setting_type", "")
            if st == "switch":
                try:
                    cur = _ctrl().getPluginSettingBoolean(pid, sk, False)
                except:
                    cur = False
                _ctrl().setPluginSetting(pid, sk, not bool(cur))
                run_on_ui_thread(lambda: BulletinHelper.show_info(f"{_plugin_name(pid)}: {('ON' if not cur else 'OFF')}"))
            else:
                self._open_settings(pid, ok)

    def _remove_shortcut(self, idx):
        sc_list = self._load_shortcuts()
        if 0 <= idx < len(sc_list):
            sc_list.pop(idx)
            self._save_shortcuts(sc_list)
            self._restore_shortcuts()
            run_on_ui_thread(lambda: BulletinHelper.show_info(_s("shortcut_removed")))
            _ctrl().loadPluginSettings(__id__)


    # ========== wizard step 1: location + type ==========
    def _wizard_step1(self):
        items = []
        items.append(Header(text=_s("location")))
        items.append(Selector(
            key="__wiz_loc",
            text=_s("location"),
            items=[_s("drawer"), _s("chat_menu"), _s("both_places")],
            default=0
        ))
        items.append(Header(text=_s("type")))
        items.append(Selector(
            key="__wiz_type",
            text=_s("type"),
            items=[
                _s("toggle_plugin"),
                _s("open_settings"),
                _s("operate_setting")
            ],
            default=0
        ))
        items.append(Text(
            text=_s("next"),
            accent=True,
            create_sub_fragment=self._wizard_step2
        ))
        return items

    # ========== wizard step 2: filtered plugin list ==========
    def _wizard_step2(self):
        try:
            type_i = _ctrl().getPluginSettingInt(__id__, "__wiz_type", 0)
        except:
            type_i = 0

        # Фильтруем плагины
        if type_i == 1:  # open_settings
            pids = [pid for pid in _plugin_ids() if _has_settings_reliably(pid)]
            empty_msg = _s("no_plugins")
        elif type_i == 2:  # operate_setting
            pids = []
            for pid in _plugin_ids():
                if not _has_settings_reliably(pid):
                    continue
                try:
                    if any(s.get("type") == "switch" for s in self._collect_settings(pid)):
                        pids.append(pid)
                except Exception as e:
                    log(f"[{__id__}] wizard_step2 switch scan {pid}: {e}")
            empty_msg = _s("no_plugins")
        else:  # toggle_plugin
            pids = _plugin_ids()
            empty_msg = _s("no_plugins")

        if not pids:
            return [Divider(text=empty_msg)]

        pnames = [_plugin_name(p) for p in pids]

        items = []
        items.append(Header(text=_s("plugins")))
        items.append(Selector(
            key="__wiz_plugin",
            text=_s("plugins"),
            items=pnames,
            default=0
        ))
        
        try:
            type_i = _ctrl().getPluginSettingInt(__id__, "__wiz_type", 0)
        except:
            type_i = 0
        if type_i == 2:
            items.append(Text(
                text=_s("select_setting"),
                accent=True,
                create_sub_fragment=lambda: self._wizard_step3(pids)
            ))
        else:
            items.append(Text(
                text=_s("create"),
                accent=True,
                on_click=lambda v: self._wizard_done(pids)
            ))
            
        return items

    def _wizard_done(self, pids):
        def _do():
            try:
                ctrl = _ctrl()
                loc_i = ctrl.getPluginSettingInt(__id__, "__wiz_loc", 0)
                type_i = ctrl.getPluginSettingInt(__id__, "__wiz_type", 0)
                plug_i = ctrl.getPluginSettingInt(__id__, "__wiz_plugin", 0)

                loc = "both" if loc_i == 2 else ("drawer" if loc_i == 0 else "chat")
                types = {0: "toggle_plugin", 1: "open_settings", 2: "operate_setting"}
                stype = types.get(type_i, "toggle_plugin")

                if plug_i < 0 or plug_i >= len(pids):
                    plug_i = 0
                target = pids[plug_i]

                if stype == "operate_setting":
                    run_on_ui_thread(lambda: BulletinHelper.show_info(_s("select_setting")))
                    ctrl.loadPluginSettings(__id__)
                    self._open_self_settings()
                    return
                sc = {"type": stype, "plugin_id": target, "location": loc}

                sc_list = self._load_shortcuts()
                sc_list.append(sc)
                self._save_shortcuts(sc_list)
                self._register_menu(sc)

                label = self._sc_label(sc)
                run_on_ui_thread(lambda: BulletinHelper.show_info(
                    f"{_s('shortcut_created')}: {label}"))
                ctrl.loadPluginSettings(__id__)
            except Exception as e:
                log(f"[{__id__}] wizard_done: {e}\n{traceback.format_exc()}")
                run_on_ui_thread(lambda: BulletinHelper.show_info(str(e)))
        import threading
        threading.Thread(target=_do, daemon=True).start()
