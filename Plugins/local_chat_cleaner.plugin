import client_utils
from android_utils import run_on_ui_thread, log
from client_utils import send_request, get_messages_controller
from java import jint
from ui.settings import Header, Switch, Divider, Input, Text
from java.util import ArrayList
from org.telegram.ui.ActionBar import AlertDialog
from org.telegram.tgnet import TLRPC
from ui.alert import AlertDialogBuilder
from org.telegram.ui.ActionBar import BaseFragment
from org.telegram.messenger import MessageObject, LocaleController, R, ApplicationLoader, UserConfig

__id__ = "local_chat_cleaner"
__name__ = "Local_Chat_Cleaner"
__description__ = "üóëÔ∏è –°–∫—Ä—ã–≤–∞–π—Ç–µ —Å–ø–∞–º –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ª–æ–∫–∞–ª—å–Ω–æ! –ö–ª–∏–∫ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Üí –ü–ª–∞–≥–∏–Ω ‚Üí –°–∫—Ä—ã—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"
__author__ = "@Key_d1204"
__version__ = "0.1.0"
__icon__ = "VariousAnimations9/054"
__min_version__ = "11.12.0"

from ui.bulletin import BulletinHelper
from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy
import json

class HideUserPlugin(BasePlugin):
    BLOCKED_SETTING_KEY = "hide_user_blocked"

    def __init__(self):
        super().__init__()
        self.allCount = 0

    def on_plugin_load(self):
        self.log("HideUser: –∑–∞–≥—Ä—É–∑–∫–∞")
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text="–°–∫—Ä—ã—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ —á–∞—Ç–∞",
            on_click=self.handle_message_hide_click,
            icon="msg_delete"
        ))
        self.add_hook("TL_updateNewMessage")

        if not self.get_setting(self.BLOCKED_SETTING_KEY, None):
            self.set_setting(self.BLOCKED_SETTING_KEY, "{}")

    def handle_message_hide_click(self, context: dict):
        try:
            fragment = client_utils.get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title("–£–¥–∞–ª–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞?")
            builder.set_message("‚ö†Ô∏è –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ù–ê–í–°–ï–ì–î–ê –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–π –∏—Å—Ç–æ—Ä–∏–∏.")

            # **–í–°–ï–ì–î–ê 2 –∫–Ω–æ–ø–∫–∏: "–£–¥–∞–ª–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞" (True) + "–û—Ç–º–µ–Ω–∞"**
            builder.set_neutral_button("–£–¥–∞–ª–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞!",lambda dialog, which: self.local_delete_user_messages(fragment,context.get("dialog_id"),self.get_sender_id(context.get("message")), True))

            builder.set_negative_button("–û—Ç–º–µ–Ω–∞", None)
            builder.show()

        except Exception as e:
            BulletinHelper.show_error(f"error: {e}")

    def get_sender_id(self, message):
        if hasattr(message, "getSenderId"):
            return message.getSenderId()
        elif hasattr(message, "messageOwner"):
            from_id = getattr(message.messageOwner, "from_id", None)
            if from_id:
                if hasattr(from_id, "user_id"):
                    return from_id.user_id
                elif hasattr(from_id, "channel_id"):
                    return -from_id.channel_id
                elif hasattr(from_id, "chat_id"):
                    return -from_id.chat_id
        return None

    def local_delete_user_messages(self, fragment: BaseFragment, dialog_id: int, sender_id: int, from_ayu_too=False):
        def search_and_delete_runnable():
            message_ids = []
            messages_controller = client_utils.get_messages_controller()
            peer = messages_controller.getInputPeer(dialog_id)
            from_peer = messages_controller.getInputPeer(sender_id)

            def on_search_complete():
                if message_ids and len(message_ids) > 0:
                    chunked_lists = [message_ids[i:i + 100] for i in range(0, len(message_ids), 100)]

                    def delete_action():
                        ayugram = False
                        try:
                            from com.radolyn.ayugram import AyuState
                            ayugram = True
                        except Exception:
                            ayugram = False

                        for id_chunk in chunked_lists:
                            java_list = ArrayList()
                            for msg_id in id_chunk:
                                java_list.add(jint(msg_id))
                                if ayugram and from_ayu_too:
                                    AyuState.permitDeleteMessage(dialog_id, jint(msg_id))

                            # forAll=False –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
                            messages_controller.deleteMessages(java_list, None, None, dialog_id, 0, False, 0)
                        BulletinHelper.show_info(f"Successfully locally deleted {len(message_ids)} messages.")

                        # –î–æ–±–∞–≤–ª—è–µ–º –≤ blocked –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –Ω–æ–≤—ã—Ö
                        blocked = self._load_blocked()
                        chat_key = str(dialog_id)
                        blocked.setdefault(chat_key, [])
                        if sender_id not in blocked[chat_key]:
                            blocked[chat_key].append(sender_id)
                            self._save_blocked(blocked)
                            self.log(f"Added user {sender_id} to hidden in chat {chat_key}")

                    run_on_ui_thread(delete_action)
                else:
                    BulletinHelper.show_info("No messages from this user.")

            self._do_search_messages(fragment, on_search_complete, message_ids, peer, 0, from_peer, 0, 0)

        client_utils.run_on_queue(search_and_delete_runnable)

    def _do_search_messages(self, fragment: BaseFragment, on_complete: callable, message_ids: list,
                            peer: TLRPC.InputPeer, reply_message_id: int, from_id: TLRPC.InputPeer,
                            offset_id: int, hash_val: int):

        req = TLRPC.TL_messages_search()
        req.peer = peer
        req.limit = 100
        req.q = ""
        req.offset_id = offset_id
        req.from_id = from_id
        req.flags |= 1
        req.filter = TLRPC.TL_inputMessagesFilterEmpty()
        if reply_message_id != 0:
            req.top_msg_id = reply_message_id
            req.flags |= 2
        req.hash = hash_val

        def on_response(response, error):
            if error:
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Error\n{error.text}"))
                on_complete()
                return

            if not hasattr(response, 'messages') or not response.messages or response.messages.isEmpty():
                on_complete()
                return

            messages_array = response.messages.toArray()
            for message in messages_array:
                message_ids.append(message.id)

            if len(messages_array) < 100:  # ‚Üê –î–æ–±–∞–≤–∏–ª: –µ—Å–ª–∏ –º–µ–Ω—å—à–µ –ª–∏–º–∏—Ç–∞, —Ç–æ –∫–æ–Ω–µ—Ü
                on_complete()
                return

            minId = min(m.id for m in messages_array)
            self._do_search_messages(fragment, on_complete, message_ids, peer, reply_message_id, from_id,
                                     minId, 0)  # hash=0 –æ–∫ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã

        connections_manager = client_utils.get_connections_manager()
        connections_manager.sendRequest(req, client_utils.RequestCallback(on_response), 2)

    def on_update_hook(self, update_name: str, account: int, update: object) -> HookResult:
        if update_name != "TL_updateNewMessage":
            return HookResult(strategy=HookStrategy.DEFAULT)

        message = getattr(update, "message", None)
        if not message:
            return HookResult(strategy=HookStrategy.DEFAULT)

        chat_id = self._get_dialog_id(message)
        sender_id = self._get_sender_id(message)
        if chat_id is None or sender_id is None:
            return HookResult(strategy=HookStrategy.DEFAULT)

        blocked = self._load_blocked()
        chat_key = str(chat_id)
        if chat_key in blocked and sender_id in blocked[chat_key]:
            self.log(f"Blocking new message from {sender_id} in chat {chat_id}")
            return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult(strategy=HookStrategy.DEFAULT)

    def _get_sender_id(self, message):
        if hasattr(message, "getSenderId"):
            return message.getSenderId()
        return self._get_sender_id_from_tl_message(message)

    def _get_sender_id_from_tl_message(self, message):
        from_id = getattr(message, "from_id", None)
        if from_id:
            if hasattr(from_id, "user_id"):
                return from_id.user_id
            elif hasattr(from_id, "channel_id"):
                return -from_id.channel_id
            elif hasattr(from_id, "chat_id"):
                return -from_id.chat_id
        peer_id = getattr(message, "peer_id", None)
        if peer_id:
            if hasattr(peer_id, "channel_id"):
                return -peer_id.channel_id
            elif hasattr(peer_id, "chat_id"):
                return -peer_id.chat_id
            elif hasattr(peer_id, "user_id"):
                return peer_id.user_id
        return None

    def _get_dialog_id(self, message):
        if hasattr(message, "dialogId"):
            return message.dialogId
        peer = getattr(message, "peer_id", None)
        if not peer:
            return None
        if hasattr(peer, "user_id"):
            return peer.user_id
        elif hasattr(peer, "chat_id"):
            return -peer.chat_id
        elif hasattr(peer, "channel_id"):
            return - (1000000000000 + peer.channel_id)
        return None

    def _load_blocked(self):
        raw = self.get_setting(self.BLOCKED_SETTING_KEY, "{}")
        try:
            return json.loads(raw)
        except Exception:
            return {}

    def _save_blocked(self, data: dict):
        try:
            self.set_setting(self.BLOCKED_SETTING_KEY, json.dumps(data))
        except Exception as e:
            self.log(f"_save_blocked error: {e}")

    def create_settings(self):
        def open_manage_screen(view):
            blocked = self._load_blocked()
            items = []

            for chat_key, users in blocked.items():
                items.append(Text(text=f"–ß–∞—Ç {chat_key}: {len(users)} —Å–∫—Ä—ã—Ç–æ"))
                for uid in users:
                    def make_unhide(c=chat_key, u=uid):
                        return lambda v: self._unhide_user(c, u)
                    items.append(Text(
                        text=f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {uid} (–Ω–∞–∂–º–∏—Ç–µ, —á—Ç–æ–±—ã —É–±—Ä–∞—Ç—å)",
                        on_click=make_unhide()
                    ))
                def make_clear(c=chat_key):
                    return lambda v: self._clear_chat_blocked(c)
                items.append(Text(
                    text=f"–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ—Ö —Å–∫—Ä—ã—Ç—ã—Ö –≤ —á–∞—Ç–µ {chat_key}",
                    on_click=make_clear()
                ))

            items.append(Text(text="–≠–∫—Å–ø–æ—Ä—Ç JSON", on_click=lambda v: self._export_blocked()))
            items.append(Text(text="–ò–º–ø–æ—Ä—Ç JSON", on_click=lambda v: self._import_blocked()))
            return items

        return [
            Switch(
                text="–í–∫–ª—é—á–∏—Ç—å –ø–ª–∞–≥–∏–Ω",
                subtext="–í–∫–ª—é—á–∞–µ—Ç –∏–ª–∏ –æ—Ç–∫–ª—é—á–∞–µ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫—É —Å–æ–æ–±—â–µ–Ω–∏–π",
                get_value=lambda: True,
                on_change=lambda v, val: self.log(f"Plugin {'enabled' if val else 'disabled'}")
            ),
            Text(
                text="–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∫—Ä—ã—Ç—ã–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏",
                subtext="–ù–∞–∂–º–∏—Ç–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞/—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è",
                on_click=open_manage_screen
            )
        ]

    def _unhide_user(self, chat_id, user_id):
        blocked = self._load_blocked()
        chat_key = str(chat_id)
        if chat_key in blocked and user_id in blocked[chat_key]:
            blocked[chat_key].remove(user_id)
            if not blocked[chat_key]:
                del blocked[chat_key]
            self._save_blocked(blocked)
            self.log(f"–£–¥–∞–ª–µ–Ω –∏–∑ —Å–∫—Ä—ã—Ç—ã—Ö user {user_id} –≤ —á–∞—Ç–µ {chat_key}")

    def _clear_chat_blocked(self, chat_id):
        blocked = self._load_blocked()
        chat_key = str(chat_id)
        if chat_key in blocked:
            del blocked[chat_key]
            self._save_blocked(blocked)
            self.log(f"–û—á–∏—â–µ–Ω —Å–ø–∏—Å–æ–∫ —Å–∫—Ä—ã—Ç—ã—Ö –≤ —á–∞—Ç–µ {chat_key}")

    def _export_blocked(self):
        try:
            data = self._load_blocked()
            path = "/sdcard/HideUser_blocked_export.json"
            self.write_file(path, json.dumps(data))
            self.log(f"Exported blocked list to {path}")
        except Exception as e:
            self.log(f"export error: {e}")

    def _import_blocked(self):
        try:
            path = "/sdcard/HideUser_blocked_import.json"
            raw = self.read_file(path)
            data = json.loads(raw)
            self._save_blocked(data)
            self.log(f"Imported blocked list from {path}")
        except Exception as e:
            self.log(f"import error: {e}")