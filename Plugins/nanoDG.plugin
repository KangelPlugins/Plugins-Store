import random
import time
import traceback
from base_plugin import BasePlugin, MenuItemData, MenuItemType
from android_utils import run_on_ui_thread, log
from client_utils import get_last_fragment
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from hook_utils import find_class
from java import dynamic_proxy

__id__ = "nanoDG"
__name__ = "nanoDG"
__description__ = "обычная игра дурака. как играть? как хотите - три точки - плагины - дурак"
__author__ = "@nanoPrograms"
__version__ = "1.0.0"
__min_version__ = "11.12.0"
__icon__ = "nanoPrograms/1"

#хуйня полная
TextView = find_class("android.widget.TextView")
Button = find_class("android.widget.Button")
LinearLayout = find_class("android.widget.LinearLayout")
FrameLayout = find_class("android.widget.FrameLayout")
AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
Theme = find_class("org.telegram.ui.ActionBar.Theme")
Gravity = find_class("android.view.Gravity")
OnClickListener = find_class("android.view.View$OnClickListener")

class DurakGame:
    SUITS = ['♠', '♥', '♦', '♣']
    RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    RANK_VALUES = {rank: i for i, rank in enumerate(RANKS)}

    def __init__(self):
        self.deck = []
        self.player_hand = []
        self.ai_hand = []
        self.table_attack = []
        self.table_defense = []
        self.trump_suit = None
        self.trump_card_display = None
        self.discard_pile = []
        self.is_player_attacking = True
        self.game_over = None
        self.first_turn = True
        self.setup_game()

    def setup_game(self):
        self.deck = [(suit, rank) for suit in self.SUITS for rank in self.RANKS]
        random.shuffle(self.deck)
        self.trump_card_display = self.deck[-1]
        self.trump_suit = self.trump_card_display[0]
        
        self.deal_cards()
        
        player_min_trump = self._find_lowest_trump(self.player_hand)
        ai_min_trump = self._find_lowest_trump(self.ai_hand)

        if player_min_trump is None and ai_min_trump is None:
            self.is_player_attacking = random.choice([True, False])
        elif player_min_trump is None:
            self.is_player_attacking = False
        elif ai_min_trump is None:
            self.is_player_attacking = True
        else:
            self.is_player_attacking = self.RANK_VALUES[player_min_trump[1]] < self.RANK_VALUES[ai_min_trump[1]]
        
        self.first_turn = True

    def _find_lowest_trump(self, hand):
        trumps = [card for card in hand if card[0] == self.trump_suit]
        if not trumps:
            return None
        return min(trumps, key=lambda card: self.RANK_VALUES[card[1]])

    def deal_cards(self):
        while len(self.player_hand) < 6 and self.deck:
            self.player_hand.append(self.deck.pop(0))
        while len(self.ai_hand) < 6 and self.deck:
            self.ai_hand.append(self.deck.pop(0))
        
        self.player_hand.sort(key=lambda c: (self.SUITS.index(c[0]), self.RANK_VALUES[c[1]]))
        self.ai_hand.sort(key=lambda c: (self.SUITS.index(c[0]), self.RANK_VALUES[c[1]]))

    def can_beat(self, attack_card, defend_card):
        if attack_card[0] == defend_card[0]:
            return self.RANK_VALUES[defend_card[1]] > self.RANK_VALUES[attack_card[1]]
        elif defend_card[0] == self.trump_suit:
            return attack_card[0] != self.trump_suit
        return False

    def can_add_to_attack(self, card):
        if not self.table_attack:
            return True
        table_ranks = {c[1] for c in self.table_attack} | {c[1] for c in self.table_defense}
        return card[1] in table_ranks

    def end_turn(self, defender_took_cards):
        if defender_took_cards:
            if self.is_player_attacking:
                self.ai_hand.extend(self.table_attack)
                self.ai_hand.extend(self.table_defense)
            else:
                self.player_hand.extend(self.table_attack)
                self.player_hand.extend(self.table_defense)
        else:
            self.discard_pile.extend(self.table_attack)
            self.discard_pile.extend(self.table_defense)
            self.is_player_attacking = not self.is_player_attacking

        self.table_attack = []
        self.table_defense = []
        self.first_turn = False
        
        self.deal_cards()
        self.check_game_over()

    def check_game_over(self):
        if not self.deck:
            player_done = not self.player_hand
            ai_done = not self.ai_hand
            if player_done and ai_done:
                self.game_over = "draw"
            elif player_done:
                self.game_over = "player_wins"
            elif ai_done:
                self.game_over = "ai_wins"

    def ai_attack(self):
        possible_attacks = [card for card in self.ai_hand if self.can_add_to_attack(card)]
        if not possible_attacks:
            return None 

        non_trumps = [card for card in possible_attacks if card[0] != self.trump_suit]
        if non_trumps:
            card_to_play = min(non_trumps, key=lambda c: self.RANK_VALUES[c[1]])
        else:
            card_to_play = min(possible_attacks, key=lambda c: self.RANK_VALUES[c[1]])
        
        self.ai_hand.remove(card_to_play)
        self.table_attack.append(card_to_play)
        return card_to_play

    def ai_defend(self):
        if not self.table_attack or len(self.table_attack) == len(self.table_defense):
            return None 

        card_to_beat = self.table_attack[-1]
        possible_defenses = [card for card in self.ai_hand if self.can_beat(card_to_beat, card)]

        if not possible_defenses:
            return "take"

        card_to_play = min(possible_defenses, key=lambda c: self.RANK_VALUES[c[1]])
        self.ai_hand.remove(card_to_play)
        self.table_defense.append(card_to_play)
        return card_to_play

class DurakPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.active_games = {}
        self.game_views = {}

    def on_plugin_load(self):
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text="дурак",
            icon="msg_game",
            on_click=self.start_new_game
        ))

    def start_new_game(self, context):
        chat_id = context.get("dialog_id")
        game = DurakGame()
        self.active_games[chat_id] = game
        self.create_game_dialog(chat_id, game)

    def create_game_dialog(self, chat_id, game):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        builder = AlertDialogBuilder(activity)
        builder.set_title("дурак")

        main_layout = LinearLayout(activity)
        main_layout.setOrientation(LinearLayout.VERTICAL)
        dp = AndroidUtilities.dp

        
        ai_hand_view = TextView(activity)
        ai_hand_view.setGravity(Gravity.CENTER)
        ai_hand_view.setPadding(dp(10), dp(10), dp(10), dp(10))
        main_layout.addView(ai_hand_view)
        
        
        info_layout = LinearLayout(activity)
        info_layout.setOrientation(LinearLayout.HORIZONTAL)
        info_layout.setGravity(Gravity.CENTER)
        deck_view = TextView(activity)
        trump_view = TextView(activity)
        info_layout.addView(deck_view, LinearLayout.LayoutParams(dp(0), -2, 1.0))
        info_layout.addView(trump_view, LinearLayout.LayoutParams(dp(0), -2, 1.0))
        main_layout.addView(info_layout)
        
       
        table_view = TextView(activity)
        table_view.setGravity(Gravity.CENTER)
        table_view.setMinHeight(dp(80))
        table_view.setPadding(dp(10), dp(20), dp(10), dp(20))
        main_layout.addView(table_view)

        
        player_hand_layout = LinearLayout(activity)
        player_hand_layout.setOrientation(LinearLayout.HORIZONTAL)
        player_hand_layout.setGravity(Gravity.CENTER)
        main_layout.addView(player_hand_layout)

        
        controls_layout = LinearLayout(activity)
        controls_layout.setOrientation(LinearLayout.HORIZONTAL)
        controls_layout.setGravity(Gravity.CENTER)
        take_button = Button(activity)
        take_button.setText("взять")
        pass_button = Button(activity)
        pass_button.setText("пас")
        controls_layout.addView(take_button)
        controls_layout.addView(pass_button)
        main_layout.addView(controls_layout)

        self.game_views[chat_id] = {
            "main": main_layout,
            "ai_hand": ai_hand_view,
            "deck": deck_view,
            "trump": trump_view,
            "table": table_view,
            "player_hand": player_hand_layout,
            "take_button": take_button,
            "pass_button": pass_button
        }

        class ButtonListener(dynamic_proxy(OnClickListener)):
            def __init__(self, plugin, chat_id, action):
                super().__init__()
                self.plugin, self.chat_id, self.action = plugin, chat_id, action
            
            def onClick(self, view):
                view.setEnabled(False) 
                try:
                    self.plugin.on_button_click(self.chat_id, self.action)
                finally:
                    view.setEnabled(True) 

        take_button.setOnClickListener(ButtonListener(self, chat_id, "take"))
        pass_button.setOnClickListener(ButtonListener(self, chat_id, "pass"))
        
        builder.set_view(main_layout)
        builder.set_negative_button("закрыть", lambda d, w: d.dismiss())
        game.dialog = builder.show()
        
        self.redraw_game_view(chat_id)
        
        if not game.is_player_attacking:
            run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)

    def redraw_game_view(self, chat_id):
        game = self.active_games.get(chat_id)
        views = self.game_views.get(chat_id)
        if not game or not views: return
        dp = AndroidUtilities.dp

        views["ai_hand"].setText(f"карты противника: {len(game.ai_hand)}")

        deck_count = len(game.deck)
        views["deck"].setText(f"колода: {deck_count if deck_count > 0 else 'пусто'}")
        trump_str = f"Козырь: {game.trump_card_display[0]}{game.trump_card_display[1]}" if game.trump_card_display else f"козырь: {game.trump_suit}"
        views["trump"].setText(trump_str)
        
        table_str = "стол:\n"
        for i in range(len(game.table_attack)):
            att_card = game.table_attack[i]
            table_str += f"{att_card[0]}{att_card[1]}"
            if i < len(game.table_defense):
                def_card = game.table_defense[i]
                table_str += f" -> {def_card[0]}{def_card[1]}"
            table_str += "\n"
        views["table"].setText(table_str if game.table_attack else "бля стол пустой")
        
        # Player Hand
        player_hand_layout = views["player_hand"]
        player_hand_layout.removeAllViews()
        for i, card in enumerate(game.player_hand):
            card_view = TextView(player_hand_layout.getContext())
            card_view.setText(f"{card[0]}{card[1]}")
            card_view.setPadding(dp(5), dp(10), dp(5), dp(10))
            card_view.setTextSize(18)
            card_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            card_view.setBackgroundDrawable(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector), 2))

            class CardClickListener(dynamic_proxy(OnClickListener)):
                def __init__(self, plugin, chat_id, index):
                    super().__init__()
                    self.plugin, self.chat_id, self.index = plugin, chat_id, index
                
                def onClick(self, view):
                    view.setEnabled(False) 
                    try:
                        self.plugin.on_card_click(self.chat_id, self.index)
                    finally:
                        view.setEnabled(True) 
            
            card_view.setOnClickListener(CardClickListener(self, chat_id, i))
            player_hand_layout.addView(card_view)
           
        can_attack = game.is_player_attacking and len(game.table_attack) < 6 and len(game.ai_hand) > len(game.table_defense)
        can_defend = not game.is_player_attacking and len(game.table_attack) > len(game.table_defense)
        
        views["take_button"].setEnabled(can_defend)
        views["pass_button"].setEnabled(game.is_player_attacking and not game.first_turn and len(game.table_attack) > 0)

    def on_card_click(self, chat_id, card_index):
        game = self.active_games.get(chat_id)
        if not game or game.game_over: return
        
        card = game.player_hand[card_index]
        
        if game.is_player_attacking:
            if game.can_add_to_attack(card) and len(game.table_attack) < 6 and len(game.ai_hand) > len(game.table_defense):
                game.player_hand.pop(card_index)
                game.table_attack.append(card)
                self.redraw_game_view(chat_id)
                run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)
            else:
                BulletinHelper.show_error("эээ так нельзя ходить")
        else:
            if len(game.table_attack) > len(game.table_defense):
                card_to_beat = game.table_attack[-1]
                if game.can_beat(card_to_beat, card):
                    game.player_hand.pop(card_index)
                    game.table_defense.append(card)
                    self.redraw_game_view(chat_id)
                    if not game.ai_hand or len(game.table_attack) >= 6 or len(game.table_defense) >= len(game.ai_hand):
                        BulletinHelper.show_info("еее бито")
                        game.end_turn(False)
                        self.redraw_game_view(chat_id)
                        if game.game_over:
                            log(f"[{__name__}] Game is over! Result: {game.game_over}")
                            if game.game_over == "player_wins":
                                BulletinHelper.show_success("игра окончена: вы вин")
                            elif game.game_over == "ai_wins":
                                BulletinHelper.show_error("игра окончена: вы лох и проебали")
                            else:
                                BulletinHelper.show_info("игра окончена: ну бля ничья.")
                            self.show_game_over_dialog(chat_id, game.game_over)
                    else:
                        run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)
                else:
                    BulletinHelper.show_error("брат, эта карта не бьет")

    def on_button_click(self, chat_id, action):
        game = self.active_games.get(chat_id)
        if not game or game.game_over: return
        
        if action == "take":
            if not game.is_player_attacking and len(game.table_attack) > 0:
                game.end_turn(True)
                BulletinHelper.show_info("вы взяли карты")
                self.redraw_game_view(chat_id)
                if game.game_over:
                    log(f"[{__name__}] Game is over! Result: {game.game_over}")
                    if game.game_over == "player_wins":
                        BulletinHelper.show_success("игра окончена: вы вин")
                    elif game.game_over == "ai_wins":
                        BulletinHelper.show_error("игра окончена: вы лох и проебали")
                    else:
                        BulletinHelper.show_info("игра окончена: ну бля ничья")
                    self.show_game_over_dialog(chat_id, game.game_over)
                else:
                    run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)
                
        elif action == "pass":
            if game.is_player_attacking and len(game.table_attack) > 0 and not game.first_turn:
                game.end_turn(False)
                BulletinHelper.show_info("пас (бито)")
                self.redraw_game_view(chat_id)
                if game.game_over:
                    log(f"[{__name__}] Game is over! Result: {game.game_over}")
                    if game.game_over == "player_wins":
                        BulletinHelper.show_success("игра окончена: вы вин")
                    elif game.game_over == "ai_wins":
                        BulletinHelper.show_error("игра окончена: вы лох и проебали")
                    else:
                        BulletinHelper.show_info("игра окончена: ну бля ничья")
                    self.show_game_over_dialog(chat_id, game.game_over)
                else:
                    run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)
    
    def ai_turn(self, chat_id):
        game = self.active_games.get(chat_id)
        if not game or game.game_over: return
        
        if game.is_player_attacking: 
            result = game.ai_defend()
            if result == "take":
                game.end_turn(True)
                BulletinHelper.show_info("противник взял карты")
            elif result is not None:
                BulletinHelper.show_info(f"противник отбился: {result[0]}{result[1]}")
        else: 
            result = game.ai_attack()
            if result is None:
                game.end_turn(False)
                BulletinHelper.show_info("противник пасует (бито)")
            else:
                BulletinHelper.show_info(f"противник ходит: {result[0]}{result[1]}")

        self.redraw_game_view(chat_id)
        if game.game_over:
            log(f"[{__name__}] Game is over! Result: {game.game_over}")
            if game.game_over == "player_wins":
                BulletinHelper.show_success("игра окончена: вы вин")
            elif game.game_over == "ai_wins":
                BulletinHelper.show_error("игра окончена: вы лох и проебали")
            else:
                BulletinHelper.show_info("игра окончена: ну бля ничья!")
            self.show_game_over_dialog(chat_id, game.game_over)
        elif not game.is_player_attacking and len(game.table_attack) == len(game.table_defense):
            run_on_ui_thread(lambda: self.ai_turn(chat_id), 1000)

    def show_game_over_dialog(self, chat_id, result):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None
        if not activity: return

        if result == "player_wins":
            title = "победа"
            message = "еее ты выиграл!"
        elif result == "ai_wins":
            title = "поражение"
            message = "вы проиграли. лох епани,хаха"
        else:
            title = "ничья"
            message = "игра окончилась вничью."

        builder = AlertDialogBuilder(activity)
        builder.set_title(title)
        builder.set_message(message)

        def on_restart(d, w):
            d.dismiss()
            game = self.active_games.get(chat_id)
            if game and game.dialog:
                try: game.dialog.dismiss()
                except: pass
            self.start_new_game({"dialog_id": chat_id})
        
        builder.set_positive_button("играть снова", on_restart)
        builder.set_negative_button("нет иди нахер", lambda d, w: d.dismiss())
        builder.show()