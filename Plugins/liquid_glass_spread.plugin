__id__ = "liquid_glass_spread"
__name__ = "Liquid Glass Spread"
__description__ = "Extends liquid glass to chat header and top panels."
__author__ = "@mihailkotovski"
__version__ = " - [experiment maybe last]"
__icon__ = "Rom4ikExperiments/5"
__min_version__ = "12.2.10"

from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class, get_private_field, set_private_field
from android_utils import run_on_ui_thread, log
from ui.settings import Header, Switch, Divider, Input
from ui.bulletin import BulletinHelper

from java import dynamic_proxy
from java.lang import Float as JFloat

from android.os import Build
from android.view import View
from android.graphics import Color, PointF, Rect

from org.telegram.messenger import LiteMode, SharedConfig, AndroidUtilities
from org.telegram.ui.ActionBar import Theme
from org.telegram.ui.Components.blur3.drawable.color import (
    BlurredBackgroundColorProvider,
    BlurredBackgroundColorProviderThemed,
)


class _ColorProviderProxy(dynamic_proxy(BlurredBackgroundColorProvider)):
    def __init__(self, base, disable_top_stroke=False, disable_shadow=False, disable_bottom_stroke=False):
        super().__init__()
        self._base = base
        self._disable_top_stroke = disable_top_stroke
        self._disable_shadow = disable_shadow
        self._disable_bottom_stroke = disable_bottom_stroke

    def getShadowColor(self):
        if self._disable_shadow:
            return 0
        return self._base.getShadowColor()

    def getBackgroundColor(self):
        return self._base.getBackgroundColor()

    def getStrokeColorTop(self):
        if self._disable_top_stroke:
            return 0
        return self._base.getStrokeColorTop()

    def getStrokeColorBottom(self):
        if self._disable_bottom_stroke:
            return 0
        return self._base.getStrokeColorBottom()


class LiquidGlassSpreadPlugin(BasePlugin):
    _CONTEXT_STYLE_AUDIO_PLAYER = 0
    _CONTEXT_STYLE_INACTIVE_GROUP_CALL = 4

    def __init__(self):
        super().__init__()
        self._hook_chat_create_view_ref = None
        self._hook_chat_resume_ref = None
        self._hook_chat_padding_ref = None
        self._hook_pinned_create_ref = None
        self._hook_pinned_update_refs = []
        self._hook_actionbar_visible_ref = None
        self._hook_statusbar_visible_ref = None
        self._hook_chat_clip_ref = None
        self._hook_chat_destroy_ref = None
        self._hook_context_update_ref = None
        self._hook_context_padding_ref = None
        self._applied = {}
        self._warned = False
        self._apply_pending = set()
        self._apply_requested = set()

    def on_plugin_load(self):
        self._hook_chat_activity()
        self._hook_fragment_context_view()

    def on_plugin_unload(self):
        refs = [
            self._hook_chat_create_view_ref,
            self._hook_chat_resume_ref,
            self._hook_chat_padding_ref,
            self._hook_pinned_create_ref,
            self._hook_actionbar_visible_ref,
            self._hook_statusbar_visible_ref,
            self._hook_chat_clip_ref,
            self._hook_chat_destroy_ref,
            self._hook_context_update_ref,
            self._hook_context_padding_ref,
        ]
        refs.extend(self._hook_pinned_update_refs)
        for ref in refs:
            if ref:
                try:
                    self.unhook_method(ref)
                except Exception:
                    pass
        self._apply_pending.clear()
        self._apply_requested.clear()
        run_on_ui_thread(self._restore_all)

    def _hook_chat_activity(self):
        ChatActivityClass = find_class("org.telegram.ui.ChatActivity")
        if not ChatActivityClass:
            return
        try:
            ContextClass = find_class("android.content.Context")
            create_view = ChatActivityClass.getClass().getDeclaredMethod("createView", ContextClass)
            create_view.setAccessible(True)
            self._hook_chat_create_view_ref = self.hook_method(create_view, _ChatCreateViewHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] createView hook failed: {e}")
        try:
            on_resume = ChatActivityClass.getClass().getDeclaredMethod("onResume")
            on_resume.setAccessible(True)
            self._hook_chat_resume_ref = self.hook_method(on_resume, _ChatResumeHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] onResume hook failed: {e}")
        try:
            invalidate_padding = ChatActivityClass.getClass().getDeclaredMethod("invalidateChatListViewTopPadding")
            invalidate_padding.setAccessible(True)
            self._hook_chat_padding_ref = self.hook_method(invalidate_padding, _ChatPaddingHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] invalidateChatListViewTopPadding hook failed: {e}")
        try:
            create_pinned = ChatActivityClass.getClass().getDeclaredMethod("createPinnedMessageView")
            create_pinned.setAccessible(True)
            self._hook_pinned_create_ref = self.hook_method(create_pinned, _PinnedViewHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] createPinnedMessageView hook failed: {e}")
        try:
            methods = ChatActivityClass.getClass().getDeclaredMethods()
            for m in methods:
                if m.getName() == "updatePinnedMessageView":
                    m.setAccessible(True)
                    self._hook_pinned_update_refs.append(self.hook_method(m, _PinnedViewHook(self)))
        except Exception as e:
            log(f"[LiquidGlassSpread] updatePinnedMessageView hook failed: {e}")
        try:
            fragment_class = find_class("org.telegram.ui.ChatActivity$ChatActivityFragmentView")
            if fragment_class:
                is_action_bar_visible = fragment_class.getClass().getDeclaredMethod("isActionBarVisible")
                is_action_bar_visible.setAccessible(True)
                self._hook_actionbar_visible_ref = self.hook_method(is_action_bar_visible, _ActionBarVisibleHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] isActionBarVisible hook failed: {e}")
        try:
            container_class = find_class("org.telegram.ui.Components.SizeNotifierFrameLayout")
            if container_class:
                is_status_bar_visible = container_class.getClass().getDeclaredMethod("isStatusBarVisible")
                is_status_bar_visible.setAccessible(True)
                self._hook_statusbar_visible_ref = self.hook_method(is_status_bar_visible, _StatusBarVisibleHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] isStatusBarVisible hook failed: {e}")
        try:
            invalidate_clip = ChatActivityClass.getClass().getDeclaredMethod("invalidateClipRectForBackgroundAndChatList")
            invalidate_clip.setAccessible(True)
            self._hook_chat_clip_ref = self.hook_method(invalidate_clip, _ChatClipHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] invalidateClipRectForBackgroundAndChatList hook failed: {e}")
        try:
            on_destroy = ChatActivityClass.getClass().getDeclaredMethod("onFragmentDestroy")
            on_destroy.setAccessible(True)
            self._hook_chat_destroy_ref = self.hook_method(on_destroy, _ChatDestroyHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] onFragmentDestroy hook failed: {e}")

    def _hook_fragment_context_view(self):
        FragmentContextView = find_class("org.telegram.ui.Components.FragmentContextView")
        if not FragmentContextView:
            return
        try:
            int_cls = find_class("java.lang.Integer").TYPE
            update_style = FragmentContextView.getClass().getDeclaredMethod("updateStyle", int_cls)
            update_style.setAccessible(True)
            self._hook_context_update_ref = self.hook_method(update_style, _ContextStyleHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] FragmentContextView updateStyle hook failed: {e}")
        try:
            float_cls = find_class("java.lang.Float").TYPE
            set_top_padding = FragmentContextView.getClass().getDeclaredMethod("setTopPadding", float_cls)
            set_top_padding.setAccessible(True)
            self._hook_context_padding_ref = self.hook_method(set_top_padding, _ContextTopPaddingHook(self))
        except Exception as e:
            log(f"[LiquidGlassSpread] FragmentContextView setTopPadding hook failed: {e}")

    def _safe_find_class(self, class_name):
        try:
            return find_class(class_name)
        except Exception as e:
            log(f"[LiquidGlassSpread] find_class failed for {class_name}: {e}")
            return None

    def _is_fragment_active(self, fragment):
        try:
            if self._get_attr(fragment, "isFinished"):
                return False
        except Exception:
            pass
        try:
            if self._get_attr(fragment, "finishing"):
                return False
        except Exception:
            pass
        return True

    def _get_context_style(self, context_view):
        try:
            value = self._get_attr(context_view, "currentStyle")
            return int(value) if value is not None else None
        except Exception:
            return None

    def _should_apply_context_panel(self, context_view):
        style = self._get_context_style(context_view)
        if style is None:
            return False
        return style in (self._CONTEXT_STYLE_AUDIO_PLAYER, self._CONTEXT_STYLE_INACTIVE_GROUP_CALL)

    def _is_context_panel_visible(self, chat_activity):
        if not self.get_setting("apply_top_panels", True):
            return False
        if chat_activity is None:
            return False
        try:
            context_view = get_private_field(chat_activity, "fragmentContextView")
        except Exception:
            context_view = None
        if not context_view:
            return False
        try:
            if context_view.getVisibility() != View.VISIBLE:
                return False
        except Exception:
            pass
        return self._should_apply_context_panel(context_view)

    def _resolve_context_panel_view(self, context_view):
        if context_view is None:
            return None
        panel = self._get_attr(context_view, "frameLayout")
        return panel if panel is not None else context_view

    def _restore_panel_entry(self, store, key):
        entry = store.get(key)
        if not entry:
            return
        view = entry.get("view")
        applied = entry.get("applied")
        restored_background = False
        try:
            if view and applied is not None and view.getBackground() is applied:
                view.setBackground(entry.get("background"))
                restored_background = True
        except Exception:
            pass
        try:
            if view and entry.get("drawBlur") is not None:
                self._set_attr(view, "drawBlur", entry.get("drawBlur"))
            if view and restored_background and entry.get("backgroundColor") is not None:
                self._set_attr(view, "backgroundColor", entry.get("backgroundColor"))
            if view:
                view.invalidate()
        except Exception:
            pass
        store.pop(key, None)

    def _apply_context_panel(self, store, key, context_view, factory, theme_delegate, alpha, radius, thickness, intensity, offset_x, offset_y):
        target = self._resolve_context_panel_view(context_view)
        if target is None or not self._should_apply_context_panel(context_view):
            self._restore_panel_entry(store, key)
            return
        provider = self._build_color_provider(
            theme_delegate,
            Theme.key_chat_topPanelBackground,
            alpha,
            True,
            True
        )
        bg = self._create_drawable(factory, target, provider, offset_x, offset_y, store)
        if bg:
            self._configure_drawable(
                bg,
                radius,
                thickness,
                intensity
            )
            self._log_drawable(key, bg)
            self._apply_panel_background(store, key, target, bg)

    def _needs_context_apply(self, store, context_view, key):
        entry = store.get(key)
        if context_view is None:
            return entry is not None
        target = self._resolve_context_panel_view(context_view)
        if target is None:
            return entry is not None
        if not self._should_apply_context_panel(context_view):
            return entry is not None
        if not entry or entry.get("view") is not target:
            return True
        try:
            applied = entry.get("applied")
            if applied is not None and target.getBackground() is not applied:
                return True
        except Exception:
            return True
        return False

    def apply_to_chat(self, chat_activity, delay_ms=120):
        if not self.get_setting("enabled", True):
            return
        if chat_activity is None:
            return
        if not self._is_fragment_active(chat_activity):
            return
        key = id(chat_activity)
        if key in self._apply_pending:
            self._apply_requested.add(key)
            return
        if not self._needs_apply(chat_activity):
            return
        self._apply_pending.add(key)
        run_on_ui_thread(lambda: self._apply_chat_impl(chat_activity), delay_ms)

    def _apply_pinned_gap(self, chat_activity):
        if not self.get_setting("apply_pinned", True):
            return
        pinned = get_private_field(chat_activity, "pinnedMessageView")
        if not pinned:
            return
        gap = self._get_pinned_gap()
        if gap <= 0:
            return
        try:
            pinned.setTranslationY(pinned.getTranslationY() + gap)
        except Exception:
            pass

    def _get_context_gap(self):
        return AndroidUtilities.dp(2)

    def _apply_context_gap(self, chat_activity):
        if not self.get_setting("apply_top_panels", True):
            return
        gap = self._get_context_gap()
        if gap <= 0:
            return
        store = self._applied.setdefault(id(chat_activity), {})
        gap_state = store.setdefault("context_gap", {})
        for field in ("fragmentContextView", "fragmentLocationContextView"):
            view = get_private_field(chat_activity, field)
            if not view:
                continue
            try:
                if view.getVisibility() != View.VISIBLE:
                    continue
            except Exception:
                pass
            view_id = id(view)
            prev = 0
            try:
                prev = gap_state.get(view_id, {}).get("gap", 0)
            except Exception:
                prev = 0
            try:
                view.setTranslationY(view.getTranslationY() - prev + gap)
                gap_state[view_id] = {"view": view, "gap": gap}
            except Exception:
                pass

    def _apply_chat_impl(self, chat_activity):
        try:
            if not self._is_supported():
                return
            if not self._is_fragment_active(chat_activity):
                return
            store = self._applied.setdefault(id(chat_activity), {})

            factory = get_private_field(chat_activity, "glassBackgroundDrawableFactory")
            frosted_factory = get_private_field(chat_activity, "glassBackgroundDrawableFactoryFrosted")
            theme_delegate = get_private_field(chat_activity, "themeDelegate")

            self._log_flag_state(chat_activity, factory)

            factory = get_private_field(chat_activity, "glassBackgroundDrawableFactory")
            frosted_factory = get_private_field(chat_activity, "glassBackgroundDrawableFactoryFrosted")

            if not factory:
                return

            self._enable_factory_glass(factory)
            if frosted_factory:
                self._enable_factory_glass(frosted_factory)

            action_bar = getattr(chat_activity, "actionBar", None)
            if not action_bar and hasattr(chat_activity, "getActionBar"):
                action_bar = chat_activity.getActionBar()

            strong_glass = self.get_setting("strong_glass", False)
            offset_x, offset_y = self._get_glass_offsets()
            action_alpha = 0.65 if strong_glass else 0.82
            panel_alpha = 0.62 if strong_glass else 0.80
            action_thickness = AndroidUtilities.dp(24 if strong_glass else 14)
            panel_thickness = AndroidUtilities.dp(22 if strong_glass else 12)
            action_intensity = 0.85 if strong_glass else 0.42
            panel_intensity = 0.8 if strong_glass else 0.38
            panel_radius = AndroidUtilities.dp(12)
            context_radius = 0

            if action_bar and self.get_setting("apply_action_bar", True):
                provider = self._build_color_provider(
                    theme_delegate,
                    Theme.key_actionBarDefault,
                    action_alpha,
                    disable_shadow=True,
                    disable_bottom_stroke=True
                )
                bg = self._create_drawable(factory, action_bar, provider, offset_x, offset_y, store)
                if bg:
                    self._configure_drawable(
                        bg,
                        0,
                        action_thickness,
                        action_intensity
                    )
                    self._set_bottom_rounding(bg, panel_radius)
                    self._log_drawable("action_bar", bg)
                    self._disable_actionbar_blur(store, action_bar)
                    self._disable_actionbar_shadows(store, action_bar)
                    self._apply_background(store, "action_bar", action_bar, bg)
                self._unclip_chat_background(chat_activity)

            if self.get_setting("apply_top_panels", True):
                for key, field in [("top_panel", "topChatPanelView"), ("top_panel2", "topChatPanelView2")]:
                    panel = get_private_field(chat_activity, field)
                    if panel:
                        provider = self._build_color_provider(
                            theme_delegate,
                            Theme.key_chat_topPanelBackground,
                            panel_alpha,
                            True,
                            True
                        )
                        bg = self._create_drawable(factory, panel, provider, offset_x, offset_y, store)
                        self._configure_drawable(
                            bg,
                            panel_radius,
                            panel_thickness,
                            panel_intensity
                        )
                        self._log_drawable(key, bg)
                        self._apply_panel_background(store, key, panel, bg)
            if self.get_setting("apply_pinned", True):
                pinned = self._resolve_pinned_view(chat_activity)
                if pinned:
                    provider = self._build_color_provider(
                        theme_delegate,
                        Theme.key_chat_topPanelBackground,
                        panel_alpha,
                        True,
                        True
                    )
                    bg = self._create_drawable(factory, pinned, provider, offset_x, offset_y, store)
                    self._configure_drawable(
                        bg,
                        panel_radius,
                        panel_thickness,
                        panel_intensity
                    )
                    self._log_drawable("pinned_panel", bg)
                    self._apply_panel_background(store, "pinned_panel", pinned, bg)
                    self._apply_pinned_insets(store, pinned)
            if self.get_setting("apply_top_panels", True):
                context_view = get_private_field(chat_activity, "fragmentContextView")
                self._apply_context_panel(
                    store,
                    "context_panel",
                    context_view,
                    factory,
                    theme_delegate,
                    panel_alpha,
                    context_radius,
                    panel_thickness,
                    panel_intensity,
                    offset_x,
                    offset_y
                )
        except Exception as e:
            log(f"[LiquidGlassSpread] apply_to_chat failed: {e}")
        finally:
            try:
                key = id(chat_activity)
                self._apply_pending.discard(key)
                if key in self._apply_requested:
                    self._apply_requested.discard(key)
                    if self._needs_apply(chat_activity):
                        self.apply_to_chat(chat_activity, 80)
            except Exception:
                pass

    def _needs_apply(self, chat_activity):
        store = self._applied.get(id(chat_activity))
        if not store:
            return True
        if self.get_setting("apply_action_bar", True):
            action_bar = getattr(chat_activity, "actionBar", None)
            if not action_bar and hasattr(chat_activity, "getActionBar"):
                action_bar = chat_activity.getActionBar()
            if action_bar:
                entry = store.get("action_bar")
                if not entry or entry.get("view") is not action_bar:
                    return True
                try:
                    applied = entry.get("applied")
                    if applied is not None and action_bar.getBackground() is not applied:
                        return True
                except Exception:
                    return True
        if self.get_setting("apply_top_panels", True):
            for key, field in [("top_panel", "topChatPanelView"), ("top_panel2", "topChatPanelView2")]:
                panel = get_private_field(chat_activity, field)
                if not panel:
                    continue
                entry = store.get(key)
                if not entry or entry.get("view") is not panel:
                    return True
                try:
                    applied = entry.get("applied")
                    if applied is not None and panel.getBackground() is not applied:
                        return True
                except Exception:
                    return True
        if self.get_setting("apply_pinned", True):
            pinned = get_private_field(chat_activity, "pinnedMessageView")
            if pinned:
                entry = store.get("pinned_panel")
                if not entry or entry.get("view") is not pinned:
                    return True
                try:
                    applied = entry.get("applied")
                    if applied is not None and pinned.getBackground() is not applied:
                        return True
                except Exception:
                    return True
        if self.get_setting("apply_top_panels", True):
            context_view = get_private_field(chat_activity, "fragmentContextView")
            if self._needs_context_apply(store, context_view, "context_panel"):
                return True
        return False

    def _resolve_pinned_view(self, chat_activity):
        pinned = get_private_field(chat_activity, "pinnedMessageView")
        if pinned:
            return pinned
        try:
            fields = chat_activity.getClass().getDeclaredFields()
            for field in fields:
                name = field.getName()
                if not name or "pinned" not in name.lower():
                    continue
                field.setAccessible(True)
                value = field.get(chat_activity)
                if not value:
                    continue
                try:
                    class_name = value.getClass().getName()
                except Exception:
                    class_name = ""
                if class_name.endswith("BlurredFrameLayout") or class_name.endswith("FrameLayout"):
                    return value
        except Exception:
            pass
        return None

    def _build_color_provider(self, resources_provider, color_key, alpha, disable_top_stroke=False, disable_shadow=False, disable_bottom_stroke=False):
        try:
            if alpha is None:
                provider = BlurredBackgroundColorProviderThemed(resources_provider, color_key)
            else:
                provider = BlurredBackgroundColorProviderThemed(resources_provider, color_key, float(alpha))
            if disable_top_stroke or disable_shadow or disable_bottom_stroke:
                try:
                    return _ColorProviderProxy(provider, disable_top_stroke, disable_shadow, disable_bottom_stroke)
                except Exception:
                    return provider
            return provider
        except Exception as e:
            log(f"[LiquidGlassSpread] color provider failed: {e}")
            return None

    def _create_drawable(self, factory, view, provider, offset_x, offset_y, store):
        if factory is None or view is None:
            return None
        watcher = None
        parent = None
        try:
            watcher = get_private_field(factory, "viewPositionWatcher")
            parent = get_private_field(factory, "parent")
            if watcher:
                watcher.unsubscribe(view)
        except Exception:
            watcher = None
            parent = None
        try:
            drawable = factory.create(view, provider) if provider else factory.create(view)
        except Exception as e:
            log(f"[LiquidGlassSpread] factory create failed: {e}")
            return None
        if watcher and parent:
            if offset_x != 0 or offset_y != 0:
                try:
                    watcher.unsubscribe(view)
                except Exception:
                    pass
                listener = self._build_offset_listener(drawable, view, offset_x, offset_y)
                if listener:
                    try:
                        watcher.subscribe(view, parent, listener)
                        tracked = store.setdefault("offset_views", [])
                        if tracked:
                            tracked[:] = [(f, v) for (f, v) in tracked if v is not view]
                        tracked.append((factory, view))
                    except Exception:
                        pass
            self._apply_source_offset(drawable, view, parent, offset_x, offset_y)
        return drawable

    def _build_offset_listener(self, drawable, view, offset_x, offset_y):
        listener_class = self._safe_find_class("org.telegram.ui.Components.chat.ViewPositionWatcher$OnChangedListener")
        if not listener_class:
            return None

        class _OffsetListener(dynamic_proxy(listener_class)):
            def __init__(self):
                super().__init__()

            def onPositionChanged(self, v, rect):
                try:
                    drawable.setSourceOffset(rect.left + offset_x, rect.top + offset_y)
                except Exception:
                    pass
                try:
                    view.invalidate()
                except Exception:
                    pass

        try:
            return _OffsetListener()
        except Exception:
            return None

    def _apply_source_offset(self, drawable, view, parent, offset_x, offset_y):
        if drawable is None:
            return
        try:
            watcher_class = self._safe_find_class("org.telegram.ui.Components.chat.ViewPositionWatcher")
            if watcher_class:
                point = PointF()
                if watcher_class.computeCoordinatesInParent(view, parent, point):
                    drawable.setSourceOffset(point.x + offset_x, point.y + offset_y)
                    view.invalidate()
                    return
        except Exception:
            pass
        try:
            view_coords = view.getLocationOnScreen()
            parent_coords = parent.getLocationOnScreen()
            if view_coords and parent_coords:
                drawable.setSourceOffset(
                    (view_coords[0] - parent_coords[0]) + offset_x,
                    (view_coords[1] - parent_coords[1]) + offset_y
                )
                view.invalidate()
                return
        except Exception:
            pass
        try:
            drawable.setSourceOffset(view.getX() + offset_x, view.getY() + offset_y)
            view.invalidate()
        except Exception:
            pass

    def _enable_factory_glass(self, factory):
        try:
            if Build.VERSION.SDK_INT >= 33:
                factory.setLiquidGlassEffectAllowed(True)
        except Exception as e:
            log(f"[LiquidGlassSpread] factory setLiquidGlassEffectAllowed failed: {e}")

    def _enable_drawable_glass(self, drawable):
        if drawable is None:
            return
        if Build.VERSION.SDK_INT < 33:
            return
        try:
            if hasattr(drawable, "setLiquidGlassEffectAllowed"):
                drawable.setLiquidGlassEffectAllowed()
        except Exception:
            pass

    def _ensure_glass_source(self, chat_activity, store):
        try:
            glass_source = get_private_field(chat_activity, "glassBackgroundSourceRenderNode")
            if glass_source:
                return
            if Build.VERSION.SDK_INT < 31:
                return
            source_class = self._safe_find_class("org.telegram.ui.Components.blur3.source.BlurredBackgroundSourceRenderNode")
            if not source_class:
                return
            wallpaper_source = get_private_field(chat_activity, "navbarContentSourceWallpaper")
            if not wallpaper_source:
                return
            new_source = source_class(wallpaper_source)

            frosted_source = get_private_field(chat_activity, "glassBackgroundSourceFrostedRenderNode")
            listener = self._get_attr(frosted_source, "onDrawablesRelativePositionChangeListener") if frosted_source else None
            if listener:
                try:
                    new_source.setOnDrawablesRelativePositionChangeListener(listener)
                except Exception:
                    pass

            old_factory = get_private_field(chat_activity, "glassBackgroundDrawableFactory")
            factory_class = self._safe_find_class("org.telegram.ui.Components.blur3.BlurredBackgroundDrawableViewFactory")
            if not factory_class:
                return
            new_factory = factory_class(new_source)
            if old_factory:
                linked = self._get_attr(old_factory, "linkedViews")
                if linked:
                    try:
                        new_factory.setLinkedViewsRef(linked)
                    except Exception:
                        pass
                watcher = self._get_attr(old_factory, "viewPositionWatcher")
                parent = self._get_attr(old_factory, "parent")
                if watcher and parent:
                    try:
                        new_factory.setSourceRootView(watcher, parent)
                    except Exception:
                        pass

            self._enable_factory_glass(new_factory)

            if "glass_override" not in store:
                store["glass_override"] = {
                    "chat": chat_activity,
                    "source": glass_source,
                    "factory": old_factory,
                }
            set_private_field(chat_activity, "glassBackgroundSourceRenderNode", new_source)
            set_private_field(chat_activity, "glassBackgroundDrawableFactory", new_factory)
            try:
                set_private_field(chat_activity, "glassSourcesInvalidated", True)
            except Exception:
                pass
        except Exception as e:
            log(f"[LiquidGlassSpread] ensure glass source failed: {e}")

    def _ensure_noise_suppressor_glass(self, chat_activity, store):
        try:
            suppressor = get_private_field(chat_activity, "scrollableViewNoiseSuppressor")
            if not suppressor:
                return
            is_glass = self._get_attr(suppressor, "isLiquidGlassEnabled")
            if is_glass:
                return
            cls = self._safe_find_class("org.telegram.ui.Components.blur3.DownscaleScrollableNoiseSuppressor")
            if not cls:
                return
            new_suppressor = cls()
            if "noise_override" not in store:
                store["noise_override"] = {"chat": chat_activity, "suppressor": suppressor}
            set_private_field(chat_activity, "scrollableViewNoiseSuppressor", new_suppressor)
            try:
                set_private_field(chat_activity, "glassSourcesInvalidated", True)
            except Exception:
                pass
        except Exception as e:
            log(f"[LiquidGlassSpread] ensure noise suppressor failed: {e}")

    def _configure_drawable(self, drawable, radius, thickness, intensity):
        if drawable is None:
            return
        try:
            if radius is not None:
                drawable.setRadius(radius)
        except Exception:
            pass
        try:
            if thickness is not None:
                drawable.setThickness(thickness)
        except Exception:
            pass
        try:
            if intensity is not None:
                drawable.setIntensity(float(intensity))
        except Exception:
            pass
        self._enable_drawable_glass(drawable)

    def _set_bottom_rounding(self, drawable, radius):
        if drawable is None:
            return
        try:
            drawable.setRadius(0, 0, radius, radius, False)
            return
        except Exception:
            pass
        try:
            drawable.setRadius(0, 0, radius, radius)
        except Exception:
            pass

    def _log_drawable(self, label, drawable):
        if not self.get_setting("debug_logs", False):
            return
        try:
            class_name = drawable.getClass().getName() if drawable else "None"
            log(f"[LiquidGlassSpread] {label} drawable={class_name}")
        except Exception:
            pass

    def _log_flag_state(self, chat_activity, factory):
        if not self.get_setting("debug_logs", False):
            return
        try:
            enabled = LiteMode.isEnabled(LiteMode.FLAG_LIQUID_GLASS)
            has_glass_source = get_private_field(chat_activity, "glassBackgroundSourceRenderNode") is not None
            suppressor = get_private_field(chat_activity, "scrollableViewNoiseSuppressor")
            suppressor_glass = self._get_attr(suppressor, "isLiquidGlassEnabled")
            suppressor_state = "yes" if suppressor_glass else "no"
            src = "yes" if has_glass_source else "no"
            log(f"[LiquidGlassSpread] lite_mode_glass={enabled} glass_source={src} noise_glass={suppressor_state} factory={factory}")
        except Exception:
            pass

    def _apply_background(self, store, key, view, drawable):
        if view is None or drawable is None:
            return
        entry = store.get(key)
        if not entry or entry.get("view") is not view:
            store[key] = {"view": view, "background": view.getBackground()}
        store[key]["applied"] = drawable
        try:
            view.setBackground(drawable)
            view.invalidate()
        except Exception as e:
            log(f"[LiquidGlassSpread] set background failed: {e}")

    def _apply_panel_background(self, store, key, panel, drawable):
        if panel is None or drawable is None:
            return
        entry = store.get(key)
        if not entry or entry.get("view") is not panel:
            store[key] = {
                "view": panel,
                "background": panel.getBackground(),
                "drawBlur": self._get_attr(panel, "drawBlur"),
                "backgroundColor": self._get_attr(panel, "backgroundColor"),
            }
        store[key]["applied"] = drawable
        try:
            panel.setBackground(drawable)
            self._set_attr(panel, "drawBlur", False)
            self._set_attr(panel, "backgroundColor", Color.TRANSPARENT)
            panel.invalidate()
        except Exception as e:
            log(f"[LiquidGlassSpread] panel background failed: {e}")

    def _apply_pinned_insets(self, store, pinned):
        try:
            params = pinned.getLayoutParams()
            if not params:
                return
            entry = store.get("pinned_insets")
            if not entry or entry.get("view") is not pinned:
                store["pinned_insets"] = {
                    "view": pinned,
                    "left": params.leftMargin,
                    "top": params.topMargin,
                    "right": params.rightMargin,
                    "bottom": params.bottomMargin,
                }
            inset = AndroidUtilities.dp(8)
            if params.leftMargin != inset or params.rightMargin != inset:
                params.leftMargin = inset
                params.rightMargin = inset
                pinned.setLayoutParams(params)
                pinned.requestLayout()
        except Exception:
            pass

    def _disable_actionbar_blur(self, store, action_bar):
        try:
            blurred = self._get_attr(action_bar, "blurredBackground")
            content_view = self._get_attr(action_bar, "contentView")
            action_bar_color = self._to_int(self._get_attr(action_bar, "actionBarColor"))
            entry = store.get("action_bar_blurred")
            if not entry or entry.get("view") is not action_bar:
                store["action_bar_blurred"] = {
                    "view": action_bar,
                    "blurredBackground": blurred,
                    "contentView": content_view,
                    "actionBarColor": action_bar_color,
                }
            if blurred:
                self._set_attr(action_bar, "blurredBackground", False)
            if action_bar_color is not None and action_bar_color != 0:
                self._set_attr(action_bar, "actionBarColor", 0)
            if content_view:
                blur_list = self._get_attr(content_view, "blurBehindViews")
                if blur_list:
                    try:
                        blur_list.remove(action_bar)
                    except Exception:
                        pass
            try:
                action_bar.invalidate()
            except Exception:
                pass
        except Exception:
            pass

    def _disable_actionbar_shadows(self, store, action_bar):
        try:
            prev = None
            try:
                prev = action_bar.getCastShadows()
            except Exception:
                prev = self._get_attr(action_bar, "castShadows")
            entry = store.get("action_bar_cast_shadows")
            if not entry or entry.get("view") is not action_bar:
                store["action_bar_cast_shadows"] = {
                    "view": action_bar,
                    "castShadows": prev,
                }
            try:
                action_bar.setCastShadows(False)
            except Exception:
                self._set_attr(action_bar, "castShadows", False)
        except Exception:
            pass

    def _unclip_chat_background(self, chat_activity):
        try:
            content_view = get_private_field(chat_activity, "contentView")
            if not content_view:
                content_view = getattr(chat_activity, "contentView", None)
            if not content_view:
                return
            bg_view = getattr(content_view, "backgroundView", None)
            if bg_view is None:
                bg_view = get_private_field(content_view, "backgroundView")
            if bg_view is None:
                return
            store = self._applied.setdefault(id(chat_activity), {})
            entry = store.get("background_clip")
            if not entry or entry.get("view") is not bg_view:
                prev = None
                try:
                    current = bg_view.getClipBounds()
                    if current is not None:
                        prev = Rect(current.left, current.top, current.right, current.bottom)
                except Exception:
                    prev = None
                store["background_clip"] = {"view": bg_view, "clip": prev}
            bg_view.setClipBounds(None)
            bg_view.invalidate()
        except Exception:
            pass

        try:
            blur = get_private_field(action_bar, "blurBehindDrawable")
            if blur:
                entry = store.get("action_bar_blur")
                if not entry or entry.get("drawable") is not blur:
                    store["action_bar_blur"] = {
                        "drawable": blur,
                        "show": self._get_attr(blur, "show"),
                        "blurAlpha": self._get_attr(blur, "blurAlpha"),
                    }
                self._set_attr(blur, "show", False)
                self._set_attr(blur, "blurAlpha", 0.0)
        except Exception:
            pass

        try:
            bg_view = get_private_field(action_bar, "backgroundView")
            if bg_view:
                entry = store.get("action_bar_bg_view")
                if not entry or entry.get("view") is not bg_view:
                    store["action_bar_bg_view"] = {
                        "view": bg_view,
                        "visibility": bg_view.getVisibility(),
                    }
                bg_view.setVisibility(View.GONE)
        except Exception:
            pass

    def _get_attr(self, obj, name):
        try:
            return getattr(obj, name)
        except Exception:
            try:
                return get_private_field(obj, name)
            except Exception:
                return None

    def _set_attr(self, obj, name, value):
        try:
            setattr(obj, name, value)
            return
        except Exception:
            pass
        try:
            set_private_field(obj, name, value)
        except Exception:
            pass

    def _to_int(self, value):
        try:
            return int(value)
        except Exception:
            return None

    def _get_glass_offsets(self):
        x = self._parse_float(self.get_setting("glass_offset_x_dp", "0"))
        y = self._parse_float(self.get_setting("glass_offset_y_dp", "0"))
        return AndroidUtilities.dp(x), AndroidUtilities.dp(y)

    def _get_pinned_gap(self):
        return AndroidUtilities.dp(6)

    def _parse_float(self, value):
        try:
            return float(str(value).replace(",", ".").strip())
        except Exception:
            return 0.0

    def _is_supported(self):
        if Build.VERSION.SDK_INT < 33:
            self._warn_once("Liquid glass requires Android 13+.")
            return False
        if not SharedConfig.chatBlurEnabled():
            self._warn_once("Chat blur is disabled in Lite Mode; enable it to use liquid glass.")
            return False
        return True

    def _warn_once(self, text):
        if self._warned:
            return
        self._warned = True
        try:
            BulletinHelper.show_info(text)
        except Exception:
            pass

    def _cleanup_chat(self, chat_activity):
        if chat_activity is None:
            return
        key = id(chat_activity)
        data = self._applied.pop(key, None)
        self._apply_pending.discard(key)
        self._apply_requested.discard(key)
        if not data:
            return
        self._restore_action_bar(data)
        self._restore_background_clip(data)
        self._restore_panel(data, "top_panel")
        self._restore_panel(data, "top_panel2")
        self._restore_panel(data, "pinned_panel")
        self._restore_panel(data, "context_panel")
        self._restore_pinned_insets(data)
        self._restore_offset_tracking(data)
        self._restore_noise_override(data)
        self._restore_glass_override(data)

    def _restore_all(self):
        for data in list(self._applied.values()):
            self._restore_action_bar(data)
            self._restore_background_clip(data)
            self._restore_panel(data, "top_panel")
            self._restore_panel(data, "top_panel2")
            self._restore_panel(data, "pinned_panel")
            self._restore_panel(data, "context_panel")
            self._restore_pinned_insets(data)
            self._restore_offset_tracking(data)
            self._restore_noise_override(data)
            self._restore_glass_override(data)
        self._applied.clear()

    def _restore_noise_override(self, data):
        entry = data.get("noise_override")
        if not entry:
            return
        try:
            chat = entry.get("chat")
            if chat:
                set_private_field(chat, "scrollableViewNoiseSuppressor", entry.get("suppressor"))
                set_private_field(chat, "glassSourcesInvalidated", True)
        except Exception:
            pass

    def _restore_glass_override(self, data):
        entry = data.get("glass_override")
        if not entry:
            return
        try:
            chat = entry.get("chat")
            if chat:
                set_private_field(chat, "glassBackgroundSourceRenderNode", entry.get("source"))
                set_private_field(chat, "glassBackgroundDrawableFactory", entry.get("factory"))
                set_private_field(chat, "glassSourcesInvalidated", True)
        except Exception:
            pass

    def _restore_background_clip(self, data):
        entry = data.get("background_clip")
        if not entry:
            return
        try:
            view = entry.get("view")
            if view:
                view.setClipBounds(entry.get("clip"))
        except Exception:
            pass

    def _restore_offset_tracking(self, data):
        tracked = data.get("offset_views")
        if not tracked:
            return
        for factory, view in tracked:
            try:
                watcher = get_private_field(factory, "viewPositionWatcher")
                if watcher:
                    watcher.unsubscribe(view)
            except Exception:
                pass

    def _restore_action_bar(self, data):
        try:
            entry = data.get("action_bar")
            if entry:
                view = entry.get("view")
                if view:
                    view.setBackground(entry.get("background"))
        except Exception:
            pass

        try:
            entry = data.get("action_bar_blurred")
            if entry:
                action_bar = entry.get("view")
                content_view = entry.get("contentView")
                if content_view:
                    blur_list = self._get_attr(content_view, "blurBehindViews")
                    if blur_list and entry.get("blurredBackground"):
                        try:
                            if not blur_list.contains(action_bar):
                                blur_list.add(action_bar)
                        except Exception:
                            try:
                                blur_list.add(action_bar)
                            except Exception:
                                pass
                self._set_attr(action_bar, "blurredBackground", entry.get("blurredBackground"))
                if entry.get("actionBarColor") is not None:
                    try:
                        action_bar.setBackgroundColor(int(entry.get("actionBarColor")))
                    except Exception:
                        self._set_attr(action_bar, "actionBarColor", int(entry.get("actionBarColor")))
        except Exception:
            pass

        try:
            entry = data.get("action_bar_blur")
            if entry:
                blur = entry.get("drawable")
                if blur:
                    self._set_attr(blur, "show", entry.get("show"))
                    self._set_attr(blur, "blurAlpha", entry.get("blurAlpha"))
        except Exception:
            pass

        try:
            entry = data.get("action_bar_bg_view")
            if entry:
                view = entry.get("view")
                if view and entry.get("visibility") is not None:
                    view.setVisibility(entry.get("visibility"))
        except Exception:
            pass

        try:
            entry = data.get("action_bar_cast_shadows")
            if entry:
                view = entry.get("view")
                prev = entry.get("castShadows")
                if view and prev is not None:
                    try:
                        view.setCastShadows(bool(prev))
                    except Exception:
                        self._set_attr(view, "castShadows", bool(prev))
        except Exception:
            pass

    def _restore_panel(self, data, key):
        entry = data.get(key)
        if not entry:
            return
        try:
            view = entry.get("view")
            if view:
                view.setBackground(entry.get("background"))
                if entry.get("drawBlur") is not None:
                    self._set_attr(view, "drawBlur", entry.get("drawBlur"))
                if entry.get("backgroundColor") is not None:
                    self._set_attr(view, "backgroundColor", entry.get("backgroundColor"))
                view.invalidate()
        except Exception:
            pass

    def _restore_pinned_insets(self, data):
        entry = data.get("pinned_insets")
        if not entry:
            return
        try:
            view = entry.get("view")
            if not view:
                return
            params = view.getLayoutParams()
            if not params:
                return
            params.leftMargin = entry.get("left", params.leftMargin)
            params.topMargin = entry.get("top", params.topMargin)
            params.rightMargin = entry.get("right", params.rightMargin)
            params.bottomMargin = entry.get("bottom", params.bottomMargin)
            view.setLayoutParams(params)
            view.requestLayout()
        except Exception:
            pass

    def create_settings(self):
        def on_change(_):
            run_on_ui_thread(self._restore_all)

        return [
            Header(text="Liquid Glass Spread"),
            Switch(
                key="enabled",
                text="Enable plugin",
                default=True,
                on_change=on_change
            ),
            Header(text="Chat Areas"),
            Switch(
                key="apply_action_bar",
                text="Chat header (ActionBar)",
                default=True,
                on_change=on_change
            ),
            Switch(
                key="apply_top_panels",
                text="Top panels (pinned, spam, etc.)",
                default=True,
                on_change=on_change
            ),
            Switch(
                key="apply_pinned",
                text="Pinned message bar",
                default=True,
                on_change=on_change
            ),
            Header(text="Alignment"),
            Input(
                key="glass_offset_x_dp",
                text="Glass offset X (dp)",
                subtext="Adjusts the blur sampling position. Default 0.",
                default="0",
                on_change=on_change
            ),
            Input(
                key="glass_offset_y_dp",
                text="Glass offset Y (dp)",
                subtext="Positive values move the effect down. Default 0.",
                default="0",
                on_change=on_change
            ),
            Divider(),
            Switch(
                key="strong_glass",
                text="Strong glass refraction",
                subtext="Lowers overlay alpha and boosts refraction.",
                default=False,
                on_change=on_change
            ),
            Divider(),
            Switch(
                key="debug_logs",
                text="Debug logs",
                default=False,
                on_change=on_change
            ),
        ]


class _ChatCreateViewHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            self.plugin.apply_to_chat(chat_activity, 160)
        except Exception as e:
            log(f"[LiquidGlassSpread] createView hook error: {e}")


class _ChatResumeHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            self.plugin.apply_to_chat(chat_activity, 80)
        except Exception as e:
            log(f"[LiquidGlassSpread] onResume hook error: {e}")


class _ChatPaddingHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            self.plugin._apply_pinned_gap(chat_activity)
            if not self.plugin._hook_context_padding_ref:
                self.plugin._apply_context_gap(chat_activity)
        except Exception as e:
            log(f"[LiquidGlassSpread] padding hook error: {e}")


class _ContextStyleHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            fragment = self.plugin._get_attr(view, "fragment")
            if fragment and fragment.getClass().getName() == "org.telegram.ui.ChatActivity":
                self.plugin.apply_to_chat(fragment, 30)
                if not self.plugin._hook_context_padding_ref:
                    self.plugin._apply_context_gap(fragment)
        except Exception as e:
            log(f"[LiquidGlassSpread] context style hook error: {e}")


class _ContextTopPaddingHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            if not self.plugin.get_setting("apply_top_panels", True):
                return
            view = param.thisObject
            fragment = self.plugin._get_attr(view, "fragment")
            if not fragment or fragment.getClass().getName() != "org.telegram.ui.ChatActivity":
                return
            apply_gap = self.plugin._should_apply_context_panel(view)
            if not apply_gap:
                other = self.plugin._get_attr(view, "additionalContextView")
                if other:
                    apply_gap = self.plugin._should_apply_context_panel(other)
            if not apply_gap:
                return
            gap = self.plugin._get_context_gap()
            if gap <= 0:
                return
            if not param.args or len(param.args) < 1:
                return
            try:
                value = float(param.args[0])
            except Exception:
                return
            param.args[0] = JFloat(value + gap)
        except Exception as e:
            log(f"[LiquidGlassSpread] context topPadding hook error: {e}")


class _ChatDestroyHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            self.plugin._cleanup_chat(chat_activity)
        except Exception as e:
            log(f"[LiquidGlassSpread] destroy hook error: {e}")


class _PinnedViewHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            self.plugin.apply_to_chat(chat_activity, 60)
        except Exception as e:
            log(f"[LiquidGlassSpread] pinned hook error: {e}")


class _ChatClipHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            if not self.plugin.get_setting("apply_action_bar", True):
                return
            self.plugin._unclip_chat_background(param.thisObject)
        except Exception:
            pass


class _ActionBarVisibleHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            if not self.plugin.get_setting("apply_action_bar", True):
                return
            param.setResult(False)
        except Exception:
            pass


class _StatusBarVisibleHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            if not self.plugin.get_setting("apply_action_bar", True):
                return
            obj = param.thisObject
            if obj is None:
                return
            name = obj.getClass().getName()
            if name == "org.telegram.ui.ChatActivity$ChatActivityFragmentView":
                param.setResult(False)
        except Exception:
            pass
