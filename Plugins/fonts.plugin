__id__ = "font_magic_selector"
__name__ = "Quick Fonts"
__description__ = """
–ü–æ–∑–≤–æ–ª—è–µ—Ç –º–µ–Ω—è—Ç—å —à—Ä–∏—Ñ—Ç –≤ —Å—Ç—Ä–æ–∫–µ –≤–≤–æd–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç–µ –≤–æ–∑–ª–µ –∫–Ω–æ–ø–∫–∏ "–û—Ç–ø—Ä–∞–≤–∏—Ç—å"

!–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —à—Ä–∏—Ñ—Ç—ã –º–æ–≥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –∫–∞–∫ [] –≤ –æ–±—ã—á–Ω–æ–º –∫–ª–∏–µ–Ω—Ç–µ —Ç–µ–ª–µ–≥—Ä–∞–º!
"""
__author__ = "@pl_meow"
__version__ = "1.0.0"
__icon__ = "r7xy27x2y7yfqf_by_fStikBot/0"
__min_version__ = "11.12.1"

import traceback
from typing import Any, Dict, List

# Base Imports
from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook, MenuItemData, MenuItemType
from android_utils import log, run_on_ui_thread
from client_utils import get_last_fragment
from ui.bulletin import BulletinHelper
from ui.settings import Header, Text

# Reflection & Java Imports
from hook_utils import find_class, get_private_field
from java import dynamic_proxy, jclass, jarray, jint
from java.lang import Integer, Runnable, CharSequence, String as JString, Class as JClass
from java.util import ArrayList

# Telegram Classes
from org.telegram.messenger import R, AndroidUtilities, LocaleController
from org.telegram.ui import ChatActivity, MessageSendPreview
from org.telegram.ui.Components import ItemOptions
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import BottomSheet, Theme
from android.view import View, Gravity, ViewGroup

from android.widget import FrameLayout, LinearLayout, TextView, ScrollView
from android.text import TextWatcher, Editable
from android.widget import EditText
from android.graphics import Color, Typeface
from android.graphics.drawable import GradientDrawable
from android.content.res import ColorStateList
from android.graphics.drawable import RippleDrawable
from android.view.animation import DecelerateInterpolator

# --- Constants ---
MENU_ITEM_ID = 18492
# --- Configuration (Customize layout here) ---
SELECTOR_OFFSET_Y = -44  # Vertical offset for the font bar in dp.
SELECTOR_HEIGHT = 45     # Height of the font bar in dp.

# --- Fonts Data ---
# Mapping standard characters to styled unicode characters
LOWER_ALPHA = "abcdefghijklmnopqrstuvwxyz"
UPPER_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
DIGITS = "0123456789"
RUS_LOWER = "–∞–±–≤–≥–¥–µ—ë–∂–∑–∏–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è"
RUS_UPPER = "–ê–ë–í–ì–î–ï–Å–ñ–ó–ò–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø"

FONTS_DATA = [
    ("Normal", None, None),
    ("Alien", "…ë·ë≤c·ëØe·∫úg·®ài«∞∆ôlm‚¥∫o‚ç¥ÍùórÍûÖÍûáu◊ò…Øx—áz", "A·ë≤CDE·∫îGHIJ∆òLMNOPQ–ØSTUVWXYZ"),
    ("Gothic", "êå∞êå±êå≤êå≥êå¥êçÜêåµêå∑êåπêåæêå∫êåªêåºêåΩêåæêçÄêåµêçÇêçÉêçÑêåøêçÖêçÖêçáêçàêå∂", "êå∞êå±êå≤êå≥êå¥êçÜêåµêå∑êåπêåæêå∫êåªêåºêåΩêåæêçÄêåµêçÇêçÉêçÑêåøêçÖêçÖêçáêçàêå∂"),
    ("Fancy", "…ëbcdÍ§ïfghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Bubbles White", "‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©", "‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè"),
    ("Small Caps", "·¥Ä ô·¥Ñ·¥Ö·¥á“ì…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ Äs·¥õ·¥ú·¥†·¥°x è·¥¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Italic Sans", "ùò¢ùò£ùò§ùò•ùò¶ùòßùò®ùò©ùò™ùò´ùò¨ùò≠ùòÆùòØùò∞ùò±ùò≤ùò≥ùò¥ùòµùò∂ùò∑ùò∏ùòπùò∫ùòª", "ùòàùòâùòäùòãùòåùòçùòéùòèùòêùòëùòíùòìùòîùòïùòñùòóùòòùòôùòöùòõùòúùòùùòûùòüùò†ùò°"),
    ("Bold Script", "ùì™ùì´ùì¨ùì≠ùìÆùìØùì∞ùì±ùì≤ùì≥ùì¥ùìµùì∂ùì∑ùì∏ùìπùì∫ùìªùìºùìΩùìæùìøùîÄùîÅùîÇùîÉ", "ùìêùìëùìíùììùìîùìïùìñùìóùìòùìôùìöùìõùìúùìùùìûùìüùì†ùì°ùì¢ùì£ùì§ùì•ùì¶ùìßùì®ùì©"),
    ("Sans", "ùñ∫ùñªùñºùñΩùñæùñøùóÄùóÅùóÇùóÉùóÑùóÖùóÜùóáùóàùóâùóäùóãùóåùóçùóéùóèùóêùóëùóíùóì", "ùñ†ùñ°ùñ¢ùñ£ùñ§ùñ•ùñ¶ùñßùñ®ùñ©ùñ™ùñ´ùñ¨ùñ≠ùñÆùñØùñ∞ùñ±ùñ≤ùñ≥ùñ¥ùñµùñ∂ùñ∑ùñ∏ùñπ"),
    ("Italic", "ùëéùëèùëêùëëùëíùëìùëî‚Ñéùëñùëóùëòùëôùëöùëõùëúùëùùëûùëüùë†ùë°ùë¢ùë£ùë§ùë•ùë¶ùëß", "ùê¥ùêµùê∂ùê∑ùê∏ùêπùê∫ùêªùêºùêΩùêæùêøùëÄùëÅùëÇùëÉùëÑùëÖùëÜùëáùëàùëâùëäùëãùëåùëç"),
    ("Double Struck", "ùïíùïìùïîùïïùïñùïóùïòùïôùïöùïõùïúùïùùïûùïüùï†ùï°ùï¢ùï£ùï§ùï•ùï¶ùïßùï®ùï©ùï™ùï´", "ùî∏ùîπ‚ÑÇùîªùîºùîΩùîæ‚ÑçùïÄùïÅùïÇùïÉùïÑ‚ÑïùïÜ‚Ñô‚Ñö‚Ñùùïäùïãùïåùïçùïéùïèùïê‚Ñ§"),
    ("Monospace", "ùöäùöãùöåùöçùöéùöèùöêùöëùöíùöìùöîùöïùöñùöóùöòùöôùööùöõùöúùöùùöûùöüùö†ùö°ùö¢ùö£", "ùô∞ùô±ùô≤ùô≥ùô¥ùôµùô∂ùô∑ùô∏ùôπùô∫ùôªùôºùôΩùôæùôøùöÄùöÅùöÇùöÉùöÑùöÖùöÜùöáùöàùöâ"),
    ("Bubbles Black", "üÖêüÖëüÖíüÖìüÖîüÖïüÖñüÖóüÖòüÖôüÖöüÖõüÖúüÖùüÖûüÖüüÖ†üÖ°üÖ¢üÖ£üÖ§üÖ•üÖ¶üÖßüÖ®üÖ©", "üÖêüÖëüÖíüÖìüÖîüÖïüÖñüÖóüÖòüÖôüÖöüÖõüÖúüÖùüÖûüÖüüÖ†üÖ°üÖ¢üÖ£üÖ§üÖ•üÖ¶üÖßüÖ®üÖ©"),
    ("Superscript", "·µÉ·µá·∂ú·µà·µâ·∂†·µç ∞·∂¶ ≤·µèÀ°·µê‚Åø·µí·µñ·ë´ ≥À¢·µó·µò·µõ ∑À£ ∏·∂ª", "·¥¨·¥Æ·∂ú·¥∞·¥±·∂†·¥≥·¥¥·¥µ·¥∂·¥∑·¥∏·¥π·¥∫·¥º·¥æQ·¥øÀ¢·µÄ·µÅ‚±Ω·µÇÀ£ ∏·∂ª"),
    ("Greek Mix", "·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥òQ ÄÍú±·¥õ·¥ú·¥†·¥°x è·¥¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Coptic", "‚≤Å‚≤Écd‚≤âf‚Ñähi‚ìôk‚Ñìm‚≤õo‚≤£q Äs‚≤ßu‚≤©‚≤±x‚≤©z", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Phonetic", "…ëb…îd…õf…°hijklmn…îpqrstuvwxjz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Cherokee", "·éØ·ë≤·è£·é†e·é∏·è©·èÇi·è†klmno·éµq·é°s·èõu·èâ·èáx·éΩz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Squares", "üÑ∞üÑ±üÑ≤üÑ≥üÑ¥üÑµüÑ∂üÑ∑üÑ∏üÑπüÑ∫üÑªüÑºüÑΩüÑæüÑøüÖÄüÖÅüÖÇüÖÉüÖÑüÖÖüÖÜüÖáüÖàüÖâ", "üÑ∞üÑ±üÑ≤üÑ≥üÑ¥üÑµüÑ∂üÑ∑üÑ∏üÑπüÑ∫üÑªüÑºüÑΩüÑæüÑøüÖÄüÖÅüÖÇüÖÉüÖÑüÖÖüÖÜüÖáüÖàüÖâ"),
    ("Script", "ùí∂ùí∑ùí∏ùíπ‚ÑØùíª‚ÑäùíΩùíæùíøùìÄùìÅùìÇùìÉ‚Ñ¥ùìÖùìÜùìáùìàùìâùìäùìãùìåùìçùìéùìè", "ùíú‚Ñ¨ùíûùíü‚Ñ∞‚Ñ±ùí¢‚Ñã‚Ñêùí•ùí¶‚Ñí‚Ñ≥ùí©ùí™ùí´ùí¨‚ÑõùíÆùíØùí∞ùí±ùí≤ùí≥ùí¥ùíµ"),
    ("Bold Italic", "ùôñùôóùôòùôôùôöùôõùôúùôùùôûùôüùô†ùô°ùô¢ùô£ùô§ùô•ùô¶ùôßùô®ùô©ùô™ùô´ùô¨ùô≠ùôÆùôØ", "ùòºùòΩùòæùòøùôÄùôÅùôÇùôÉùôÑùôÖùôÜùôáùôàùôâùôäùôãùôåùôçùôéùôèùôêùôëùôíùôìùôîùôï"),
    ("Fraktur", "ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑", "ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®"),
    ("Bubbles Small", "‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©", "‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©"),
    ("Bold", "ùóÆùóØùó∞ùó±ùó≤ùó≥ùó¥ùóµùó∂ùó∑ùó∏ùóπùó∫ùóªùóºùóΩùóæùóøùòÄùòÅùòÇùòÉùòÑùòÖùòÜùòá", "ùóîùóïùóñùóóùóòùóôùóöùóõùóúùóùùóûùóüùó†ùó°ùó¢ùó£ùó§ùó•ùó¶ùóßùó®ùó©ùó™ùó´ùó¨ùó≠"),
    # --- New Cyrillic Fonts ---
    ("êåøœÅ·ßê·•¥·¥õ·ßê·•î", "–ê·•≤ –ëŒ¥ –í ô êå≤·¥¶ –î–¥ –ï·•± √ã√´ –ñ–∂ –ó·§ã –ò·•ô –ô·•î êå∫Œ∫ êå°·ßò êåë‚≤ô êãè–Ω êåè·ßê êåø·•∞ –†œÅ ëÄù·•¥ –¢·¥õ –£—É –§…∏ êåó—Ö –¶—Ü –©—â –®…Ø ‘ø—á –¨—å –´—ã –™—ä –≠œ∂ –Æ—é –Ø—è", None),
    ("êãèÍ§ïÍ§ÄÍ§í‡™ñ‡™™‡™û‡™ñÍ§á", "êåÄÍ§å ‡¶öÍ§í êå±Í§ê –ìÍ§Ö ëÄ•·Éõ Œ£Í§ï √ã√´ êåüêåü ·äï‡§â êåµÍ§£ êåµÍ§á êå∫”Ñ êå°êåª êåëêåº êãè‡™û êåèÍ§Ä êåøÍ§ô ·ïà—Ä ëÄóÍ§ç êåï·â∞ êçÖŒ≥ êåòœï êåóëÄã ‘±Í§ü êå∏‡µ∞ êå∏œâ ‘ø‡™™ ·à´ëÄ® ·àç‡™ñ –™—ä êåÑ·§ã êåùêåè‡™≥ êåìÍ§é", None),
    ("Õ∂”°…ûŒºŒªŒºœ≤œÑ∆Ö…©œç", "ŒëŒ± “îŒ¥ Œí…û ”∂”∑ ëÄê…† ŒæŒµ √ã√´ —™—´ ”†”° Õ∂Œº ”¢œç ”É”Ñ ŒõŒª œ∫œª Œóœ∞ ŒüœÉ Œ∑Œ∑ œ∑œÅ ëÄùœ≤ Õ≤œÑ ·àÉŒ≥ Œ¶œï ”ºœá –è“µ Œ®œà Œ®œâ œ§…• ·èè∆Ö ‚Ñî∆Ö…© –™—ä œøœ∂ —§‡™¨ êçâo", None)
]

class RunnableImpl(dynamic_proxy(Runnable)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def run(self):
        try: self.func()
        except Exception as e: log(f"Error in Runnable: {e}")

class ClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def onClick(self, view):
        try: self.func(view)
        except Exception as e: log(f"Click Error: {e}")

class LayoutListener(dynamic_proxy(View.OnLayoutChangeListener)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def onLayoutChange(self, v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom):
        self.callback()
class FontMagicPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hooks = []
        self.active_font = None # (lower_map, upper_map) or None
        self.is_formatting = False # Recursion guard

    def on_plugin_load(self):
        try:
            self._hook_chat_activity()
            self.log("UI Hooks installed successfully!")
        except Exception as e:
            self.log(f"Error loading plugin: {e}")
            self.log(traceback.format_exc())
        except Exception as e:
            self.log(f"Error loading plugin: {e}")
            self.log(traceback.format_exc())

    def on_plugin_unload(self):
        self.hooks.clear()

    def create_settings(self):
        return [
            Header("Font Magic"),
            Text("–ü–ª–∞–≥–∏–Ω –∞–∫—Ç–∏–≤–µ–Ω. –ó–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —á–∞—Ç–µ, —á—Ç–æ–±—ã –≤—ã–±—Ä–∞—Ç—å —à—Ä–∏—Ñ—Ç!", icon="msg_info")
        ]

    def _hook_chat_activity(self):
        try:
            # Use JClass.forName to get the actual Java class object for reflection
            chat_activity_cls = JClass.forName("org.telegram.ui.ChatActivity")
            if chat_activity_cls:
                resume_method = chat_activity_cls.getDeclaredMethod("onResume")
                resume_method.setAccessible(True)
                self.hook_method(resume_method, self.ChatActivityResumeHook(self))
                self.log("Hooked ChatActivity.onResume")
        except Exception as e:
            self.log(f"Failed to hook ChatActivity: {e}")
    def _setup_ui(self, activity):
        try:
            enter_view = get_private_field(activity, "chatActivityEnterView")
            if not enter_view: return
            
            parent_view = enter_view.getParent()
            if not parent_view: return

            # Prevent duplicate injection
            if enter_view.findViewWithTag("font_magic_btn"): return

            edit_text = self._find_edit_text(enter_view)
            if not edit_text: return

            context = activity.getParentActivity() or activity

            # --- 1. The 'A' Button (Inside EnterView) ---
            btn = TextView(context)
            btn.setTag("font_magic_btn")
            btn.setText("A")
            btn.setTextSize(24)
            btn.setTypeface(Typeface.DEFAULT, Typeface.BOLD)
            btn.setTextColor(Theme.getColor(Theme.key_chat_messagePanelIcons))
            btn.setShadowLayer(4.0, 0.0, 0.0, 0x40000000) 
            btn.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
            btn.setVisibility(View.GONE)

            btn_params = FrameLayout.LayoutParams(-2, -2)
            btn_params.gravity = Gravity.RIGHT | Gravity.BOTTOM
            btn_params.rightMargin = AndroidUtilities.dp(62)
            btn_params.bottomMargin = AndroidUtilities.dp(10)
            enter_view.addView(btn, btn_params)

            # --- 2. The Font Bar (Attached to Parent to fix touch events) ---
            font_bar = self._create_font_bar(context, enter_view, edit_text)
            font_bar.setTag("font_magic_bar")
            font_bar.setVisibility(View.GONE)
            
            bar_params = FrameLayout.LayoutParams(-1, AndroidUtilities.dp(SELECTOR_HEIGHT))
            bar_params.gravity = Gravity.BOTTOM | Gravity.LEFT
            
            # Add to parent (SizeNotifierFrameLayout) to ensure it receives touches
            # when positioned above the input field
            parent_view.addView(font_bar, bar_params)

            # --- 3. Positioning Logic ---
            def update_bar_position():
                try:
                    if font_bar.getVisibility() == View.VISIBLE:
                        # Move bar to exactly top of enter_view
                        # The user wants SELECTOR_OFFSET_Y = -44. 
                        # If we assume -44 means "44dp above standard position", we treat it as an offset.
                        # Base position (Gravity.BOTTOM) is 0.
                        # We shift up by enter_view height.
                        
                        # Calculate effective Y translation
                        # If SELECTOR_OFFSET_Y is -44, we want it 44dp *above* the input? 
                        # Or does -44 just mean "Above"?
                        # Let's align it to the TOP of enter_view, then apply offset.
                        
                        h = enter_view.getHeight()
                        # If h is 0 (not laid out), wait.
                        if h == 0: return

                        # Shift up by height of input bar + extra offset
                        # We add 44 to SELECTOR_OFFSET_Y to normalize it if the user intended -44 to be the *total* shift from a "zero" point.
                        # But simplest is: Base = -h. Plus User Offset.
                        offset = AndroidUtilities.dp(SELECTOR_OFFSET_Y)
                        
                        # Correction: User likely wants it *just* above. 
                        # If SELECTOR_OFFSET_Y is -44, and we just use that, it might be inside the view.
                        # Let's assume standard behavior: Sit on top edge.
                        # Y = -height.
                        # + Offset.
                        # To make -44 meaningful as "just above", we probably need to ignore it and use -height,
                        # OR assume the user tweaked it for the previous broken layout.
                        # Let's stick to reliable positioning: Just above EnterView.
                        
                        # USE MARGINS instead of TranslationY to fix touch issues
                        p = font_bar.getLayoutParams()
                        # Base margin is height of enter_view + user offset adjustment
                        # We want it to sit on top of enter_view. 
                        # EnterView is at bottom. FontBar is at bottom.
                        # FontBar bottom margin = EnterView height.
                        
                        new_margin = h + AndroidUtilities.dp(SELECTOR_OFFSET_Y + 44) # Normalize -44 to 0
                        # Wait, user set -44. If we want it "Just above", margin should be `h`.
                        # If user wants to tweak, we add offset.
                        # Let's interpret SELECTOR_OFFSET_Y = -44 as "Standard Position (0)" for this logic correction,
                        # or just apply the raw value relative to the top of input?
                        
                        # Let's trust the margin logic: 
                        # Margin = Height of Input View.
                        # This places it exactly on top edge.
                        # If user wants it higher, they increase margin.
                        
                        p.bottomMargin = h
                        font_bar.setLayoutParams(p)
                except: pass

            # Keep position synced when input grows (multiline)
            enter_view.addOnLayoutChangeListener(LayoutListener(update_bar_position))
            
            # Initial Update
            enter_view.post(RunnableImpl(update_bar_position))

            # --- 4. Logic ---
            def toggle_bar(v):
                if font_bar.getVisibility() == View.VISIBLE:
                    font_bar.setVisibility(View.GONE)
                else:
                    font_bar.setVisibility(View.VISIBLE)
                    update_bar_position()
            btn.setOnClickListener(ClickListener(toggle_bar))

            class TextListener(dynamic_proxy(TextWatcher)):
                def __init__(self, plugin, button, bar, edit_text):
                    super().__init__()
                    self.plugin = plugin
                    self.btn = button
                    self.bar = bar
                    self.edit_text = edit_text
                
                def beforeTextChanged(self, s, start, count, after): pass
                
                def onTextChanged(self, s, start, before, count):
                    # Live Formatting: Replace typed characters
                    if self.plugin.active_font and not self.plugin.is_formatting and count > 0:
                        try:
                            self.plugin.is_formatting = True
                            # Get the newly added text segment
                            # Note: 's' is the CharSequence AFTER the change.
                            # 'start' is where the new text started.
                            # 'count' is how many characters were added.
                            
                            # We only want to process the *new* part to avoid re-processing the whole text constantly
                            # causing lag on long messages.
                            new_text_sub = s.subSequence(start, start + count).toString()
                            
                            lower, upper = self.plugin.active_font
                            converted = self.plugin.convert_string(new_text_sub, lower, upper)
                            
                            if converted != new_text_sub:
                                s.replace(start, start + count, converted)
                        except Exception as e:
                            log(f"Live Format Error: {e}")
                        finally:
                            self.plugin.is_formatting = False
                
                def afterTextChanged(self, s):
                    try:
                        has_text = s and s.length() > 0
                        self.btn.setVisibility(View.VISIBLE if has_text else View.GONE)
                        if not has_text:
                            self.bar.setVisibility(View.GONE)
                            self.plugin.active_font = None
                    except Exception as e:
                        log(f"TextWatcher Error: {e}")

            edit_text.addTextChangedListener(TextListener(self, btn, font_bar, edit_text))
            self.log("Font Magic UI initialized")

        except Exception as e:
            log(f"Error setting up UI: {e}")

    def _create_font_bar(self, context, enter_view, edit_text):
        # Main Container (Horizontal Layout with Close button at end)
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.HORIZONTAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_chat_messagePanelBackground))
        container.setElevation(AndroidUtilities.dp(4))
        container.setClickable(True)
        container.setFocusable(True)
        container.setPadding(0, 0, 0, 0)

        # Scroll View for Fonts
        scroll = ScrollView(context) # Actually HorizontalScrollView needs to be imported or used via reflection if not available, but usually we use HorizontalScrollView
        # Since HorizontalScrollView is not in standard imports list above, let's use reflection or FrameLayout trick, 
        # but simpler: `android.widget.HorizontalScrollView` exists in standard Android.
        # I'll use find_class just in case it wasn't imported, but standard android.widget usually has it.
        # Let's check imports. Line 33 has ScrollView. I will trust android.widget.HorizontalScrollView exists.
        
        HorizontalScrollViewCls = find_class("android.widget.HorizontalScrollView")
        scroll = HorizontalScrollViewCls(context)
        scroll.setHorizontalScrollBarEnabled(False)
        
        # Fonts Container
        fonts_layout = LinearLayout(context)
        fonts_layout.setOrientation(LinearLayout.HORIZONTAL)
        fonts_layout.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0)

        for name, lower_map, upper_map in FONTS_DATA:
            chip = TextView(context)
            
            # Text Preview
            preview = self.convert_string(name, lower_map, upper_map)
            chip.setText(preview)
            chip.setTextSize(14)
            chip.setTextColor(Theme.getColor(Theme.key_chat_messagePanelText))
            chip.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(6), AndroidUtilities.dp(12), AndroidUtilities.dp(6))
            
            # Chip Background (Ripple for animation + Gradient)
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(16))
            bg.setColor(Theme.getColor(Theme.key_chat_inBubble))
            
            # Create Ripple
            pressed_color = Theme.getColor(Theme.key_featuredStickers_addButton)
            csl = ColorStateList([jarray(jint)([])], jarray(jint)([pressed_color]))
            ripple = RippleDrawable(csl, bg, None)
            chip.setBackground(ripple)
            
            # Margin between chips
            params = LinearLayout.LayoutParams(-2, -2)
            params.rightMargin = AndroidUtilities.dp(8)
            chip.setLayoutParams(params)

            # Click Action
            def on_font_click(v, l=lower_map, u=upper_map, n=name):
                try:
                    self.active_font = (l, u)
                    v.animate().scaleX(1.1).scaleY(1.1).setDuration(100).withEndAction(
                        RunnableImpl(lambda: v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start())
                    ).start()

                    
                    # Apply to ALL existing text
                    if edit_text and edit_text.getText():
                        self.is_formatting = True
                        try:
                            editable = edit_text.getText()
                            raw_text = editable.toString()
                            if raw_text:
                                converted = self.convert_string(raw_text, l, u)
                                if converted != raw_text:
                                    editable.replace(0, editable.length(), converted)
                        finally:
                            self.is_formatting = False
                            
                except Exception as e:
                    log(f"Selection Error: {e}")
                    self.is_formatting = False
            
            chip.setOnClickListener(ClickListener(on_font_click))
            fonts_layout.addView(chip)

        scroll.addView(fonts_layout)
        
        # Add Scroll to Container with weight 1
        scroll_params = LinearLayout.LayoutParams(0, -2)
        scroll_params.weight = 1
        container.addView(scroll, scroll_params)

        # Close Button (X)
        close_btn = TextView(context)
        close_btn.setText("‚úï")
        close_btn.setTextSize(16)
        close_btn.setTextColor(Theme.getColor(Theme.key_chat_messagePanelIcons))
        close_btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(6), AndroidUtilities.dp(12), AndroidUtilities.dp(6))
        close_btn.setOnClickListener(ClickListener(lambda v: (self.reset_font(), container.setVisibility(View.GONE))))
        
        container.addView(close_btn)

        return container

    class ChatActivityResumeHook(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin
        
        def after_hooked_method(self, param):
            activity = param.thisObject
            run_on_ui_thread(lambda: self.plugin._setup_ui(activity))


    def reset_font(self):
        self.active_font = None

    def _find_edit_text(self, view):
        if not view: return None
        
        # 1. Try direct accessor (best for Telegram components)
        try:
            if hasattr(view, "getEditField"):
                f = view.getEditField()
                if f: return f
        except: pass

        # 2. Check class name
        try:
            cls_name = str(view.getClass().getName())
            if "EditText" in cls_name:
                return view
            
            # 3. Traverse children (Duck typing for ViewGroup)
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    child = view.getChildAt(i)
                    res = self._find_edit_text(child)
                    if res: return res
        except: pass
        
        return None

    def _find_enter_view(self, fragment):
        try:
            v = get_private_field(fragment, "chatActivityEnterView")
            if v: return v
        except: pass
        try:
            return self._find_view_by_class_name(fragment.getFragmentView(), "ChatActivityEnterView")
        except: return None

    def _find_view_by_class_name(self, view, class_name_part):
        if not view: return None
        try:
            if class_name_part in str(view.getClass().getName()):
                return view
            
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    res = self._find_view_by_class_name(view.getChildAt(i), class_name_part)
                    if res: return res
        except: pass
        return None
    def convert_string(self, text, lower_map, upper_map):
        if not lower_map and not upper_map:
            return text

        # Lazy parsing of Cyrillic font strings
        rus_dict = None
        if isinstance(lower_map, str) and upper_map is None and " " in lower_map:
            # Treat as Cyrillic mapping string
            rus_dict = self._parse_rus_map(lower_map)

        # Standard Transliteration Map
        rus_translit = {
            '–∞':'a','–±':'b','–≤':'v','–≥':'g','–¥':'d','–µ':'e','—ë':'e','–∂':'zh','–∑':'z','–∏':'i',
            '–π':'y','–∫':'k','–ª':'l','–º':'m','–Ω':'n','–æ':'o','–ø':'p','—Ä':'r','—Å':'s','—Ç':'t',
            '—É':'u','—Ñ':'f','—Ö':'h','—Ü':'c','—á':'ch','—à':'sh','—â':'sh','—ä':'','—ã':'y','—å':'',
            '—ç':'e','—é':'yu','—è':'ya',
            '–ê':'A','–ë':'B','–í':'V','–ì':'G','–î':'D','–ï':'E','–Å':'E','–ñ':'ZH','–ó':'Z','–ò':'I',
            '–ô':'Y','–ö':'K','–õ':'L','–ú':'M','–ù':'N','–û':'O','–ü':'P','–†':'R','–°':'S','–¢':'T',
            '–£':'U','–§':'F','–•':'H','–¶':'C','–ß':'CH','–®':'SH','–©':'SH','–™':'','–´':'Y','–¨':'',
            '–≠':'E','–Æ':'YU','–Ø':'YA'
        }

        result = []
        for char in text:
            # 1. Check direct Cyrillic Map first (if active)
            if rus_dict and char in rus_dict:
                result.append(rus_dict[char])
                continue
            
            # 2. Transliterate for Latin fonts
            # Only transliterate if we have Latin maps and NO custom dict found for this char
            if not rus_dict:
                char_to_process = rus_translit.get(char, char)
            else:
                char_to_process = char

            # 3. Apply Latin Maps
            c = char_to_process
            processed = False
            
            if 'a' <= c <= 'z' and lower_map and not rus_dict:
                index = ord(c) - ord('a')
                if index < len(lower_map):
                    result.append(lower_map[index])
                    processed = True
            
            elif 'A' <= c <= 'Z' and upper_map and not rus_dict:
                index = ord(c) - ord('A')
                if index < len(upper_map):
                    result.append(upper_map[index])
                    processed = True

            if not processed:
                result.append(c)
        
        return "".join(result)

    def _parse_rus_map(self, map_str):
        # Parses "–ê·•≤ –ëŒ¥ ..." into dict
        # Assumes standard alphabet order for missing chars or explicit mapping?
        # The user provided string seems to contain explicit pairs or mapped chars.
        # Strategy: Split by space. For each chunk, map to RUS_UPPER[i] and RUS_LOWER[i].
        
        mapping = {}
        parts = [p for p in map_str.split(" ") if p]
        
        # Map to standard alphabet
        # Note: The user provided strings vary in length. 
        # We will iterate through available parts and map them to standard RUS chars.
        for i, part in enumerate(parts):
            if i >= len(RUS_UPPER): break
            
            std_u = RUS_UPPER[i]
            std_l = RUS_LOWER[i]
            
            # Part is like "–ê·•≤" (Upper+Lower) or just chars.
            # We blindly split the part in half if length is even, or just take chars.
            # Let's assume char 0 is Upper replacement, char 1 is Lower replacement.
            if len(part) >= 2:
                # First char is replacement for Upper, remaining for Lower?
                # Actually some parts are 3 chars? "êå∫Œ∫" (2). "êå°·ßò" (2).
                # Let's handle 2 chars.
                mapping[std_u] = part[0]
                mapping[std_l] = part[1:]
            else:
                # Fallback
                mapping[std_u] = part
                mapping[std_l] = part
        
        return mapping
