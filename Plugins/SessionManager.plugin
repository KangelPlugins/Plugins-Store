
__id__ = "android_session_injector"
__name__ = "Session Manager"
__author__ = "@sexplugins - @gemeguardian"
__version__ = "1.0"
__description__ = """Полное управление сессиями: добавление, просмотр, переключение, удаление"""

__min_version__ = "10.14.4"
__icon__ = "DMJDuckX2/62"

import os
import zipfile
import shutil
import time
import traceback
import struct
import hashlib
import random
import base64
import xml.etree.ElementTree as ET
import json
from io import BytesIO

from ui.settings import Header, Text, Divider
from base_plugin import BasePlugin, MethodHook, hook_filters, HookFilter
from android_utils import run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment
from java import jclass, dynamic_proxy
from java.lang import System
from android.app import Activity
from android.content import Intent, Context
from android.view import Gravity, View
from android.widget import FrameLayout, TextView, LinearLayout
from android.util import TypedValue
from android.graphics.drawable import GradientDrawable
from android.text import TextUtils

from org.telegram.messenger import UserConfig, ApplicationLoader, AccountInstance, AndroidUtilities, MediaDataController, ImageLocation, MessagesController
from org.telegram.tgnet import ConnectionsManager
from org.telegram.ui.ActionBar import Theme, AlertDialog
from org.telegram.ui.Components import LayoutHelper, BackupImageView, UItem, AvatarDrawable
from com.exteragram.messenger.plugins.models import HeaderSetting

FILE_PICKER_ID = 7788

# ==================== JAVA NATIVE CRYPTO ====================
from javax.crypto import Cipher
from javax.crypto.spec import SecretKeySpec

class AES256:
    def __init__(self, key):
        self.key = key
        
    def encrypt_ige(self, data, iv):
        return self._ige(data, iv, encrypt=True)
        
    def decrypt_ige(self, data, iv):
        return self._ige(data, iv, encrypt=False)
        
    def _ige(self, data, iv, encrypt):
        if len(data) % 16 != 0:
            raise ValueError("Длина данных должна быть кратна 16")
            
        cipher = Cipher.getInstance("AES/ECB/NoPadding")
        keyVal = SecretKeySpec(self.key, "AES")
        cipher.init(Cipher.ENCRYPT_MODE if encrypt else Cipher.DECRYPT_MODE, keyVal)
        
        # Инициализация IV на основе режима (Standard AES-IGE / Pyrogram Logic)
        if encrypt:
            iv1 = bytearray(iv[:16])      # First Half
            iv2 = bytearray(iv[16:32])    # Second Half
        else:
            iv1 = bytearray(iv[16:32])    # Second Half
            iv2 = bytearray(iv[:16])      # First Half
        
        out = bytearray()
        
        chunks = [data[i:i+16] for i in range(0, len(data), 16)]
        
        for chunk in chunks:
            chunk = bytearray(chunk)
            
            if encrypt:
                # Шифрование: C_i = AES(M_i ^ IV1) ^ IV2
                # Buffer = M_i ^ IV1
                x = bytes(c ^ i for c, i in zip(chunk, iv1))
                
                # AES Encrypt
                y = cipher.doFinal(x)
                y = bytearray(y)
                
                # Output (C_i) = Y ^ IV2
                out_block = bytes(a ^ b for a, b in zip(y, iv2))
                out.extend(out_block)
                
                # Обновление IV
                iv1 = bytearray(out_block) # Следующий IV1 = C_i
                iv2 = chunk                # Следующий IV2 = M_i
                
            else: # Decrypt
                # Дешифрование: M_i = AES_DEC(C_i ^ IV1) ^ IV2
                # Buffer = C_i ^ IV1
                x = bytes(c ^ i for c, i in zip(chunk, iv1))
                
                # AES Decrypt
                y = cipher.doFinal(x)
                y = bytearray(y)
                
                # Output (M_i) = Y ^ IV2
                out_block = bytes(a ^ b for a, b in zip(y, iv2))
                out.extend(out_block)
                
                # Обновление IV
                iv1 = bytearray(out_block) # Следующий IV1 = M_i
                iv2 = chunk                # Следующий IV2 = C_i
                
        return bytes(out)

# ==================== NATIVE BYTE BUFFER ====================
class NativeByteBuffer:
    def __init__(self,data=None):
        self.s=BytesIO(data)if data else BytesIO()
    def __len__(self):
        return len(self.s.getvalue())
    def get_value(self):
        return self.s.getvalue()
    def remaining(self):
        return len(self.s.getvalue()) - self.s.tell()
    def read_bytes(self,l):
        return self.s.read(l)
    def read_int(self,signed=True):
        return int.from_bytes(self.read_bytes(4),'little',signed=signed)
    def read_long(self,signed=True):
        return int.from_bytes(self.read_bytes(8),'little',signed=signed)
    def read_byte_array(self):
        sl=1
        l=int.from_bytes(self.read_bytes(1),'little',signed=False)
        if l>=254:
            l=int.from_bytes(self.read_bytes(3),'little',signed=False)
            sl=4
        add=(l+sl)%4
        if add!=0:add=4-add
        r=self.read_bytes(l)
        self.read_bytes(add)
        return r
    def read_string(self):
        return self.read_byte_array().decode('utf-8','replace')
    def write_bytes(self,d):
        self.s.write(d)
    def write_int(self,n,signed=True):
        self.write_bytes(n.to_bytes(4,'little',signed=signed))
    def write_long(self,n,signed=True):
        self.write_bytes(n.to_bytes(8,'little',signed=signed))
    def read_bool(self):
        v = self.read_int(signed=False)
        return v == 0x997275b5
    def write_bool(self,v):
        self.write_int(0x997275b5 if v else 0xbc799737,signed=False)
    def write_string(self,v):
        d=v.encode('utf-8')
        l=len(d)
        if l<254:
            self.write_bytes(l.to_bytes(1,'little',signed=False))
        else:
            self.write_bytes((254).to_bytes(1,'little',signed=False))
            self.write_bytes(l.to_bytes(3,'little',signed=False))
        self.write_bytes(d)
        sl=1 if l<254 else 4
        pad=(4-((l+sl)%4))%4
        if pad:self.write_bytes(b'\x00'*pad)

# ==================== TGNET SERIALIZER (v2 - ATP Style) ====================
DATACENTERS = {
    1: "149.154.175.50",
    2: "149.154.167.51",
    3: "149.154.175.100",
    4: "149.154.167.91",
    5: "91.108.56.130"
}

class TgnetSerializer:
    def __init__(self, auth_key, dc_id):
        self.auth_key = auth_key
        self.dc_id = dc_id
        self.version = 5
        self.test_backend = False

    def to_buffer(self):
        buf = NativeByteBuffer()
        # Front Headers
        buf.write_int(self.version)
        buf.write_bool(self.test_backend)
        if self.version >= 3:
            buf.write_bool(False) # client_blocked
        if self.version >= 4:
            buf.write_string("en-us") # lang
        buf.write_bool(True) # has_session
        buf.write_int(self.dc_id)
        buf.write_int(0) # time_diff
        buf.write_int(int(time.time())) # last_dc_update
        buf.write_long(random.randint(1, 2**63 - 1)) # push_session_id
        if self.version >= 2:
            buf.write_bool(True) # registered_for_push
        if self.version >= 5:
            buf.write_int(int(time.time())) # last_server_time
        
        buf.write_int(0) # sessions_to_destroy

        # Datacenters
        buf.write_int(1) # Num DCs
        dc_ver = 11
        buf.write_int(dc_ver) # DC version
        buf.write_int(self.dc_id)
        buf.write_int(13) # last_init_version
        if dc_ver > 10:
            buf.write_int(0) # last_init_media_version
            
        # IPs (4 groups: v4, v6, v4dl, v6dl)
        ip = DATACENTERS.get(self.dc_id, DATACENTERS[2])
        for group in range(4):
            if group == 0: # IPv4
                buf.write_int(1)
                buf.write_string(ip)
                buf.write_int(443)
                buf.write_int(0) # flags
                buf.write_string("") # secret
            else:
                buf.write_int(0)

        buf.write_bool(False) # is_cdn

        # Auth
        buf.write_int(len(self.auth_key), signed=False)
        buf.write_bytes(self.auth_key)
        
        # auth_key_perm_id
        kid = int.from_bytes(hashlib.sha1(self.auth_key).digest()[12:20], "little", signed=True)
        buf.write_long(kid)

        # Temp keys (v8+)
        buf.write_int(0); buf.write_long(0) # temp
        # Media temp (v12+)
        # buf.write_int(0); buf.write_long(0) # media temp (skipped as we are v11)

        buf.write_int(1) # authorized

        # Salts
        buf.write_int(0)
        
        return buf

    def save(self, path):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        data = self.to_buffer().get_value()
        final = NativeByteBuffer()
        final.write_int(len(data))
        final.write_bytes(data)
        with open(path, "wb") as f:
            f.write(final.get_value())

class TgnetDeserializer:
    @staticmethod
    def parse_tgnet(path):
        if not os.path.exists(path): return None
        try:
            with open(path, "rb") as f:
                full_data = f.read()
            
            if len(full_data) < 4: return None
            buf = NativeByteBuffer(full_data)
            total_len = buf.read_int()
            
            # Headers
            ver = buf.read_int()
            buf.read_bool() # test
            if ver >= 3: buf.read_bool()
            if ver >= 4: buf.read_string()
            if buf.read_bool():
                dc_id = buf.read_int()
                buf.read_int() # time_diff
                buf.read_int() # update_time
                buf.read_long() # push_id
                if ver >= 2: buf.read_bool()
                if ver >= 5: buf.read_int()
                
                cnt = buf.read_int()
                for _ in range(cnt): buf.read_long()
                
            # DCs
            num_dcs = buf.read_int()
            for _ in range(num_dcs):
                dc_ver = buf.read_int()
                this_dc_id = buf.read_int()
                buf.read_int() # last_init
                if dc_ver > 10: buf.read_int()
                
                # IPs
                ip_groups = 4 if dc_ver >= 5 else 1
                for _ in range(ip_groups):
                    ips_cnt = buf.read_int()
                    for _ in range(ips_cnt):
                        buf.read_string() # addr
                        buf.read_int() # port
                        if dc_ver >= 7: buf.read_int()
                        if dc_ver >= 11: buf.read_string()
                
                if dc_ver >= 6: buf.read_bool() # cdn
                
                # Auth Key
                alen = buf.read_int(signed=False)
                auth_key = buf.read_bytes(alen) if alen > 0 else None
                
                if dc_ver >= 4: buf.read_long() # id
                else: 
                    if buf.read_int() > 0: buf.read_long()
                    
                if dc_ver >= 8:
                    tlen = buf.read_int(signed=False)
                    if tlen > 0: buf.read_bytes(tlen)
                    buf.read_long()
                
                if dc_ver >= 12:
                    mlen = buf.read_int(signed=False)
                    if mlen > 0: buf.read_bytes(mlen)
                    buf.read_long()
                    
                authorized = buf.read_int()
                
                # Salts
                for _ in range(2 if dc_ver >= 13 else 1):
                    slen = buf.read_int()
                    for _ in range(slen):
                        buf.read_int(); buf.read_int(); buf.read_long()
                
                if auth_key and authorized:
                    return {"auth_key": auth_key, "dc_id": this_dc_id}
        except:
            pass
        return None

def create_userconfig_xml(path,uid,dc,user_data=None):
    os.makedirs(os.path.dirname(path),exist_ok=True)
    
    # Значения по умолчанию
    fname = "Loading..."
    lname = ""
    uname = ""
    phone = ""
    
    if user_data:
        fname = user_data.get('first_name', "Loading...")
        lname = user_data.get('last_name', "")
        uname = user_data.get('username', "") or ""
        phone = user_data.get('phone', "") or ""

    # Создание объекта User с использованием конструктора 0x20b1422 (Найдено в TLRPC.java)
    # Этот конструктор требует ДВА флага (целых числа).
    
    # Флаги:
    # self(10) | contact(11) | mutual_contact(12) = 0x400 | 0x800 | 0x1000 = 0x1c00
    # плюс поля: first_name(1) | last_name(2) | username(3) | phone(4) | photo(5) | status(6)
    # = 0x1c00 | 0x02 | 0x04 | 0x08 | 0x10 | 0x20 | 0x40 = 0x1c7e
    
    flags = 0x1c7e
    flags2 = 0 # Расширенные флаги не требуются для базовой информации
    
    buf = NativeByteBuffer()
    buf.write_int(0x20b1422) # user#20b1422
    buf.write_int(flags)     # flags
    buf.write_int(flags2)    # flags2 (КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Этого не хватало!)
    buf.write_long(uid)      # id
    
    # access_hash (flag 0) - Не установлено
    
    buf.write_string(fname)   # flag 2 (first_name)
    buf.write_string(lname)   # flag 4 (last_name)
    buf.write_string(uname)   # flag 8 (username)
    buf.write_string(phone)   # flag 16 (phone)
    
    buf.write_int(0x4f11bae1) # photo: UserProfilePhotoEmpty (flag 32)
    buf.write_int(0x09d05049) # status: UserStatusEmpty (flag 64)
    
    user_bytes = buf.get_value()
    user_b64 = base64.b64encode(user_bytes).decode('ascii')
    
    # Minimal XML
    xml=f'''<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <string name="user">{user_b64}</string>
    <int name="dc_id" value="{dc}" />
    <long name="clientUserId" value="{uid}" />
    <int name="currentAccount" value="0" />
</map>'''
    with open(path,'w',encoding='utf-8')as f:f.write(xml)

# ==================== MAIN PLUGIN ====================



class SessionManagerUIHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0] # ArrayList<UItem>
            if not items:
                return
            
            # Check if this is our plugin settings
            try:
                plugin_field = activity.getClass().getDeclaredField("plugin")
                plugin_field.setAccessible(True)
                plugin_obj = plugin_field.get(activity)
                if not plugin_obj or str(plugin_obj.getId()) != "android_session_injector":
                    return
            except:
                return

            context = activity.getContext()
            
            # 1. Вставляем Хедер (сверху)
            header = self.plugin._create_settings_header(context)
            if header:
                header_item = UItem.asCustom(header)
                header_item.settingItem = HeaderSetting("session_manager_header")
                try: header_item.setTransparent(True)
                except: pass
                items.add(0, header_item)
                items.add(1, UItem.asShadow())

            # 2. Вставляем Карточки Аккаунтов
            # Ищем заголовок управления аккаунтами, чтобы вставить после него
            insert_pos = -1
            for i in range(items.size()):
                item = items.get(i)
                if item and item.text and "Управление Аккаунтами" in str(item.text):
                    insert_pos = i + 1
                    break
            
            if insert_pos != -1:
                accounts = self.plugin._get_all_accounts()
                # Группируем карточки по 2 в ряд
                for row_idx in range(0, len(accounts), 2):
                    row_accounts = accounts[row_idx:row_idx + 2]
                    row_container = self.plugin._create_cards_row(row_accounts, context)
                    if row_container:
                        row_item = UItem.asCustom(row_container)
                        try:
                            row_item.setTransparent(True)
                        except:
                            try: row_item.transparent = True
                            except: pass
                        items.add(insert_pos + (row_idx // 2), row_item)
            
        except Exception as e:
            self.plugin._log(f"[UI_HOOK] Error: {e}")

class AndroidSessionInjector(BasePlugin):
    def __init__(self):
        super().__init__()
        self._activity_hook=None
        self.last_slot=None
        self.last_status="Ожидание..."

    def _log(self, msg):
        self.log(msg)

    def on_plugin_load(self):
        self._log(f"Session Manager v{__version__} loaded - Full account management ready!")
        try:
            # Fix: Use java.lang.Class.forName to get the Class object that has getDeclaredMethod
            Class = jclass("java.lang.Class")
            PSA_Class = Class.forName("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            
            method = PSA_Class.getDeclaredMethod("fillItems", jclass("java.util.ArrayList"), jclass("org.telegram.ui.Components.UniversalAdapter"))
            method.setAccessible(True)
            self.hook_method(method, SessionManagerUIHook(self))
            self._log("[INIT] UI hook registered")
        except Exception as e:
            self.log(f"[INIT] Failed to hook settings header: {e}")

    def _create_settings_header(self, context):
        try:
            container = FrameLayout(context)
            container.setPadding(0, AndroidUtilities.dp(0), 0, AndroidUtilities.dp(4))
            
            # Decoration background
            inner = LinearLayout(context)
            inner.setOrientation(LinearLayout.VERTICAL)
            inner.setGravity(Gravity.CENTER)
            inner.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(5), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
            
            bg = Theme.createRoundRectDrawable(AndroidUtilities.dp(16), Theme.getColor(Theme.key_windowBackgroundGray))
            inner.setBackground(bg)

            # Sticker
            imageView = BackupImageView(context)
            imageView.setRoundRadius(AndroidUtilities.dp(35))
            
            pack_name = "DMJDuckX2"
            sticker_id = "62"
            
            def load_sticker():
                try:
                    ss = MediaDataController.getInstance(0).getStickerSetByName(pack_name) or MediaDataController.getInstance(0).getStickerSetByEmojiOrName(pack_name)
                    if ss and ss.documents:
                        idx = int(sticker_id) if sticker_id.isdigit() and int(sticker_id) < ss.documents.size() else 0
                        img_doc = ss.documents.get(idx)
                        imageView.setImage(ImageLocation.getForDocument(img_doc), "100_100", None, None, 0, 1)
                        return True
                    return False
                except: return False

            if not load_sticker():
                 MediaDataController.getInstance(0).loadStickersByEmojiOrName(pack_name, False, False)
                 run_on_ui_thread(load_sticker, 1500)
            
            inner.addView(imageView, LayoutHelper.createLinear(70, 70, 0, 0, 0, 10))
            
            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
            title.setText("Session Manager")
            try: title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except: pass
            inner.addView(title, LayoutHelper.createLinear(-2, -2, 0, 0, 0, 4))
            
            sub = TextView(context)
            sub.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            sub.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            sub.setText(f"v{__version__} • By {__author__}")
            inner.addView(sub, LayoutHelper.createLinear(-2, -2))

            container.addView(inner, LayoutHelper.createFrame(-1, -2, Gravity.TOP, 16, 0, 16, 0))
            
            return container
        except Exception as e:
            self._log(f"Error creating header: {e}")
            return None
    
    def create_local_key(self, salt, passcode=b''):
        """
        Генерирует локальный ключ для TData.
        Соответствует Storage::ComputeKey из TDesktop.
        """
        iterations = 1 if not passcode else 100000
        
        # SHA512(salt + passcode + salt)
        h = hashlib.sha512()
        h.update(salt)
        h.update(passcode)
        h.update(salt)
        key_input = h.digest()
        
        return hashlib.pbkdf2_hmac("sha512", key_input, salt, iterations, 256)

    def decrypt_local(self, enc, authkey):
        """
        Расшифровывает локальное хранилище TDesktop.
        Портировано из opentele's Storage.DecryptLocal.
        Формат: [16 байт encryptedKey (msgKey)][зашифрованные данные (с выравниванием по 16 байт)]
        """
        encryptedSize = len(enc)
        if (encryptedSize <= 16) or (encryptedSize & 0x0F):
            raise ValueError(f"Bad encrypted part size: {encryptedSize}")
        
        fullLen = encryptedSize - 16
        encryptedKey = enc[:16]  # This is the msgKey
        encryptedData = enc[16:]
        
        self._log(f"[DEBUG decrypt_local] encryptedSize={encryptedSize}, fullLen={fullLen}")
        self._log(f"[DEBUG decrypt_local] encryptedKey={encryptedKey.hex()}")
        self._log(f"[DEBUG decrypt_local] authkey_len={len(authkey)}, authkey[:32]={authkey[:32].hex()}")
        
        # Деривация ключа используя старый MTProto (send=False -> x=8)
        # Соответствует authKey.prepareAES_oldmtp(encryptedKey, False)
        x = 8
        key = authkey
        
        sha1_a = hashlib.sha1(encryptedKey[:16] + key[x : x + 32]).digest()
        sha1_b = hashlib.sha1(
            key[x + 32 : x + 32 + 16]
            + encryptedKey[:16]
            + key[x + 48 : x + 48 + 16]
        ).digest()
        sha1_c = hashlib.sha1(key[x + 64 : x + 64 + 32] + encryptedKey[:16]).digest()
        sha1_d = hashlib.sha1(encryptedKey[:16] + key[x + 96 : x + 96 + 32]).digest()

        aesKey = sha1_a[:8] + sha1_b[8 : 8 + 12] + sha1_c[4 : 4 + 12]
        aesIv = sha1_a[8 : 8 + 12] + sha1_b[:8] + sha1_c[16 : 16 + 4] + sha1_d[:8]
        
        self._log(f"[DEBUG decrypt_local] aesKey={aesKey.hex()}, aesIv={aesIv.hex()}")
        
        # Расшифровка используя AES-256-IGE
        # Примечание: ige256_decrypt глобальный -> Заменен классом AES256
        aes = AES256(aesKey)
        decrypted = aes.decrypt_ige(encryptedData, aesIv)
        
        self._log(f"[DEBUG decrypt_local] decrypted_len={len(decrypted)}, decrypted[:32]={decrypted[:32].hex()}")
        
        # Verify checksum
        checkHash = hashlib.sha1(decrypted).digest()[:16]
        self._log(f"[DEBUG decrypt_local] checkHash={checkHash.hex()}, expected={encryptedKey.hex()}")
        
        if checkHash != encryptedKey:
            raise ValueError("Bad decrypt key")
        
        # Extract actual data length (first 4 bytes, little-endian)
        dataLen = int.from_bytes(decrypted[:4], 'little')
        if (dataLen + 4 > len(decrypted)) or (dataLen <= fullLen - 16) or (dataLen < 0):
             # Note: dataLen is payload length, so +4 covers the length prefix itself
            raise ValueError(f"Bad decrypted part size: {encryptedSize}, fullLen: {fullLen}, decrypted size: {len(decrypted)}")
        
        # Return only the valid data (with the 4-byte length prefix)
        return decrypted[:4+dataLen]
    

    class QtBuffer:
        """Помощник для чтения потоков Qt (Big Endian)"""
        def __init__(self, data):
            self.stream = BytesIO(data)
        def read_int(self, signed=True):
            return int.from_bytes(self.stream.read(4), 'big', signed=signed)
        def read_uint(self):
            return int.from_bytes(self.stream.read(4), 'big', signed=False)
        def read_long(self, signed=True):
            return int.from_bytes(self.stream.read(8), 'big', signed=signed)
        def read_bytes(self, length):
            return self.stream.read(length)
    

    def parse_tdata(self, tdata_dir):
        """Full TData parser - scans all account files"""
        try:
            # Step 1: Read key_datas file
            kf = os.path.join(tdata_dir, 'key_datas')
            if not os.path.exists(kf):
                kf = os.path.join(tdata_dir, 'tdata', 'key_datas')
            if not os.path.exists(kf):
                raise FileNotFoundError("key_datas not found")
            
            with open(kf, 'rb') as f:
                magic = f.read(4)
                ver = int.from_bytes(f.read(4), 'little')
                data = f.read()
                if len(data) < 16:
                    raise ValueError(f"key_datas too small: {len(data)} bytes")
                chkdata = data[:-16]
                md5_chk = data[-16:]
                comp_md5 = hashlib.md5(chkdata + len(chkdata).to_bytes(4, 'little') + ver.to_bytes(4, 'little') + magic).digest()
                if comp_md5 != md5_chk:
                    raise ValueError("key_datas checksum fail")
            
            # TDesktop QDataStream parsing (Big Endian)
            def read_qba(curr_offset, info_bytes):
                if curr_offset + 4 > len(info_bytes):
                    raise ValueError("Unexpected EOF")
                l = int.from_bytes(info_bytes[curr_offset:curr_offset+4], 'big')
                curr_offset += 4
                if l == 0xffffffff:
                    return b'', curr_offset
                if curr_offset + l > len(info_bytes):
                    raise ValueError("Unexpected EOF")
                return info_bytes[curr_offset:curr_offset+l], curr_offset + l
            
            offset = 0
            salt, offset = read_qba(offset, chkdata)
            key_enc, offset = read_qba(offset, chkdata)
            info_enc, offset = read_qba(offset, chkdata)
            
            # Step 2: Derive localKey from key_datas
            passcode_key = self.create_local_key(salt)
            key_inner_data = self.decrypt_local(key_enc, passcode_key)
            local_key = key_inner_data[4:4+256]
            
            # Step 3: Iterate all candidate data files
            valid_accounts = []
            
            candidate_files = []
            for fname in os.listdir(tdata_dir):
                if fname.endswith('s') and fname != 'key_datas' and fname != 'maps':
                    candidate_files.append(os.path.join(tdata_dir, fname))
            
            self._log(f"[SCAN] Found {len(candidate_files)} potential data files")
            
            for data_file in candidate_files:
                try:
                    self._log(f"[TRY] Parsing {os.path.basename(data_file)}...")
                    with open(data_file, 'rb') as f:
                        magic2 = f.read(4)
                        ver2 = int.from_bytes(f.read(4), 'little')
                        data2 = f.read()
                        if len(data2) < 16:
                            continue
                        chkdata2 = data2[:-16]
                        md5_chk2 = data2[-16:]
                        comp_md5_2 = hashlib.md5(chkdata2 + len(chkdata2).to_bytes(4, 'little') + ver2.to_bytes(4, 'little') + magic2).digest()
                        if comp_md5_2 != md5_chk2:
                            self._log(f"[SKIP] Checksum fail for {os.path.basename(data_file)}")
                            continue
                    
                    # Parse data file
                    offset2 = 0
                    mtp_enc, offset2 = read_qba(offset2, chkdata2)
                    
                    # Decrypt MTP data with localKey
                    try:
                        mtp_dec = self.decrypt_local(mtp_enc, local_key)
                    except Exception as dec_err:
                        self._log(f"[SKIP] Decrypt fail for {os.path.basename(data_file)}: {dec_err}")
                        continue
                    
                    # Parse MTP authorization
                    mb = self.QtBuffer(mtp_dec[4:])
                    block_id = mb.read_int()
                    if block_id != 75:
                        self._log(f"[SKIP] BlockID {block_id} != 75 in {os.path.basename(data_file)}")
                        continue
                    
                    serialized_len = mb.read_uint()
                    serialized_data = mb.read_bytes(serialized_len)
                    
                    sb = self.QtBuffer(serialized_data)
                    user_id = sb.read_int()
                    main_dc_id = sb.read_int()
                    
                    kWideIdsTag = (~0) & 0xFFFFFFFFFFFFFFFF
                    combined = ((user_id & 0xFFFFFFFF) << 32) | (main_dc_id & 0xFFFFFFFF)
                    if combined == kWideIdsTag:
                        user_id = sb.read_long(signed=False)
                        main_dc_id = sb.read_int()
                    
                    key_count = sb.read_int()
                    auth_key = None
                    for i in range(key_count):
                        dc_id = sb.read_int()
                        key_256 = sb.read_bytes(256)
                        if dc_id == main_dc_id:
                            auth_key = key_256
                    
                    if auth_key:
                        self._log(f"[FOUND] User: {user_id} DC: {main_dc_id} in {os.path.basename(data_file)}")
                        valid_accounts.append((auth_key, main_dc_id, user_id))
                    
                except Exception as e:
                    self._log(f"[ERR] Error parsing {os.path.basename(data_file)}: {e}")
            
            if not valid_accounts:
                raise ValueError("No valid accounts found in TData")
                
            return valid_accounts
            
        except Exception as e:
            self._log(f"[TDATA ERROR] {e}")
            raise

    # ==================== ACCOUNT MANAGEMENT ====================
    
    def _show_invalid_session_alert(self):
        """Показывает диалог о невалидной сессии"""
        def show_dialog():
            context = get_last_fragment().getParentActivity()
            builder = AlertDialogBuilder(context)
            builder.set_title("Сессия невалидна")
            builder.set_message("Этот аккаунт не прошел проверку.\n\nСкорее всего, сессия была завершена (кикнута) пользователем или сервером.")
            builder.set_positive_button("Понятно")
            builder.show()
        run_on_ui_thread(show_dialog)

    def _switch_to_account(self, slot):
        """Переключается на указанный аккаунт"""
        try:
            self._log(f"[SWITCH] Switching to slot {slot}")
            
            # Пытаемся переключиться через LaunchActivity если она есть
            try:
                ActivityCls = jclass("org.telegram.ui.LaunchActivity")
                if hasattr(ActivityCls, "instance") and ActivityCls.instance:
                    run_on_ui_thread(lambda: ActivityCls.instance.switchToAccount(slot, True))
                    self._log("[SWITCH] Switched via LaunchActivity.instance")
                    return
            except:
                pass

            # Фоллбэк на стандартный метод
            AccountInstance.getInstance(slot).switchToAccount(slot, True)
            run_on_ui_thread(lambda: BulletinHelper.show_success(f"Переключено на аккаунт {slot}!"))
            
        except Exception as e:
            self._log(f"[SWITCH] Error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка переключения: {e}"))



    def _show_restart_dialog(self):
        def show():
            context = get_last_fragment().getParentActivity()
            builder = AlertDialogBuilder(context)
            builder.set_title("Действие выполнено")
            builder.set_message("Для применения изменений необходимо перезапустить клиент.\n\nСделать это сейчас?")
            
            def on_restart(builder, _):
                builder.dismiss()
                self._restart_app()
                
            def on_later(builder, _):
                builder.dismiss()
                
            builder.set_positive_button("Перезапустить", on_restart)
            builder.set_negative_button("Позже", on_later)
            builder.show()
            
        run_on_ui_thread(show)

    def _restart_app(self):
        """Полный перезапуск приложения (Fix v2)"""
        try:
            self._log("[RESTART] Scheduling full restart (v2)...")
            ctx = ApplicationLoader.applicationContext
            pm = ctx.getPackageManager()
            
            # 1. Получаем корректный Intent запуска через PackageManager
            intent = pm.getLaunchIntentForPackage(ctx.getPackageName())
            if not intent:
                self._log("[RESTART] ❌ Failed to get launch intent!")
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка перезапуска: Launch Intent not found"))
                return
                
            intent.addFlags(0x10000000 | 0x00008000) # FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK
            
            # 2. Создаем PendingIntent
            PendingIntent = jclass("android.app.PendingIntent")
            # FLAG_CANCEL_CURRENT = 268435456, FLAG_IMMUTABLE = 67108864
            pending_intent = PendingIntent.getActivity(
                ctx, 
                123456, 
                intent, 
                268435456 | 67108864 
            )
            
            # 3. Планируем запуск через 100 мс
            AlarmManager = jclass("android.app.AlarmManager")
            alarm_manager = ctx.getSystemService("alarm")
            System = jclass("java.lang.System")
            
            # setExact (if available) or set
            try:
                # setExact = 0 (RTC_WAKEUP) or 1 (RTC)
                alarm_manager.setExact(1, System.currentTimeMillis() + 100, pending_intent)
            except:
                alarm_manager.set(1, System.currentTimeMillis() + 100, pending_intent)
            
            # 4. Убиваем процесс
            self._log("[RESTART] Killing process...")
            run_on_ui_thread(lambda: BulletinHelper.show_success("Перезагрузка..."))
            
            def kill():
                time.sleep(0.2)
                Process = jclass("android.os.Process")
                Process.killProcess(Process.myPid())
                System.exit(0)
            
            import threading
            threading.Thread(target=kill).start()
            
        except Exception as e:
            self._log(f"[RESTART ERROR] {e}")
            self._log(traceback.format_exc())


    def _get_all_accounts(self):
        """Сканирует все слоты и возвращает список активных аккаунтов"""
        accounts = []
        
        try:
            for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    uc = UserConfig.getInstance(i)
                    user = uc.getCurrentUser()
                    is_activated = uc.isClientActivated()
                    user_id = uc.getClientUserId()
                    
                    # Проверяем активность
                    if user or is_activated or user_id != 0:
                        # Извлекаем данные
                        first_name = user.first_name if user and hasattr(user, 'first_name') else "Unknown"
                        last_name = user.last_name if user and hasattr(user, 'last_name') else ""
                        username = user.username if user and hasattr(user, 'username') else ""
                        phone = user.phone if user and hasattr(user, 'phone') else ""
                        
                        # Получаем DC
                        try:
                            cm = ConnectionsManager.getInstance(i)
                            dc_id = cm.getCurrentDatacenterId()
                        except Exception as e:
                            dc_id = 0
                        
                        account_data = {
                            'slot': i,
                            'is_active': (UserConfig.selectedAccount == i),
                            'user_id': user_id,
                            'dc_id': dc_id,
                            'first_name': first_name,
                            'last_name': last_name,
                            'username': username or "",
                            'phone': phone or ""
                        }
                        
                        accounts.append(account_data)
                        
                except Exception as e:
                    self._log(f"[GET_ACCOUNTS] Error reading slot {i}: {e}")
                    
        except Exception as e:
            self._log(f"[GET_ACCOUNTS] Critical error: {e}")
            self._log(traceback.format_exc())
            
        return accounts
    
    def _validate_session(self, auth_key, dc_id):
        """Проверяет валидность сессии через прямое MTProto соединение"""
        try:
            self._log(f"[VALIDATE] Starting MTProto validation for DC{dc_id}")
            
            if dc_id not in DATACENTERS:
                self._log(f"[VALIDATE] ❌ Invalid DC ID: {dc_id}")
                return False
            
            host = DATACENTERS[dc_id]
            port = 443
            self._log(f"[VALIDATE] Connecting to {host}:{port}...")
            
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            try:
                sock.connect((host, port))
                self._log("[VALIDATE] ✅ TCP connection established")
                
                # Send Intermediate Protocol Header
                sock.sendall(b'\xee\xee\xee\xee')
                
                self.val_req_msg_id = 0
                self.val_success = False
                self.val_failed = False
                
                def send_rpc_request(salt=0):
                    # Генерируем msg_id
                    import time
                    msg_id = int(time.time() * (2**32))
                    msg_id &= -4 
                    
                    self.val_req_msg_id = msg_id
                    
                    # Тело updates.getState (Requires Auth)
                    # Used to detect revoked sessions (checks if User matches Key)
                    req_buf = NativeByteBuffer()
                    req_buf.write_int(0xedd4882a, signed=False)
                    req_data = req_buf.get_value()
                    
                    # Создаем сообщение
                    session_id = random.randint(1, 2**63 - 1)
                    
                    msg_buf = NativeByteBuffer()
                    msg_buf.write_long(salt, signed=True)  # salt
                    msg_buf.write_long(session_id, signed=True)
                    msg_buf.write_long(msg_id, signed=True)
                    msg_buf.write_int(1, signed=True)
                    msg_buf.write_int(len(req_data), signed=True)
                    msg_buf.write_bytes(req_data)
                    
                    plain_data = msg_buf.get_value()
                    
                    # Padding
                    current_len = len(plain_data)
                    min_padding = 12 + int(os.urandom(1)[0] % 16)
                    padding_needed = (16 - ((current_len + min_padding) % 16)) % 16
                    total_padding = min_padding + padding_needed
                    plain_data += os.urandom(total_padding)
                    
                    # msg_key
                    msg_key_data = auth_key[88:88+32] + plain_data
                    msg_key_full = hashlib.sha256(msg_key_data).digest()
                    msg_key = msg_key_full[8:24]
                    
                    # AES key
                    sha256_a = hashlib.sha256(msg_key + auth_key[0:36]).digest()
                    sha256_b = hashlib.sha256(auth_key[40:76] + msg_key).digest()
                    aes_key = sha256_a[0:8] + sha256_b[8:24] + sha256_a[24:32]
                    aes_iv = sha256_b[0:8] + sha256_a[8:24] + sha256_b[24:32]
                    
                    # Encrypt
                    aes = AES256(aes_key)
                    encrypted = aes.encrypt_ige(plain_data, aes_iv)
                    
                    # Final packet
                    auth_key_id = hashlib.sha1(auth_key).digest()[-8:]
                    packet = auth_key_id + msg_key + encrypted
                    packet_len = len(packet)
                    full_packet = struct.pack('<I', packet_len) + packet
                    
                    sock.sendall(full_packet)
                    return True

                # Start request
                if not send_rpc_request(0):
                    return False
                    
                import time
                start_time = time.time()
                while time.time() - start_time < 15:
                    if self.val_success:
                        self._log("[VALIDATE] ✅ Success flag set")
                        return True
                    if self.val_failed: 
                        self._log("[VALIDATE] ❌ Failed flag set")
                        return False
                    
                    try:
                        response_len_data = sock.recv(4)
                    except socket.timeout:
                        break
                        
                    if len(response_len_data) < 4:
                        self._log("[VALIDATE] Connection closed")
                        break
                        
                    response_len = struct.unpack('<I', response_len_data)[0]
                    response_data = b''
                    while len(response_data) < response_len:
                        chunk = sock.recv(response_len - len(response_data))
                        if not chunk: break
                        response_data += chunk
                        
                    if len(response_data) != response_len: break
                    
                    if len(response_data) == 4:
                        code = struct.unpack('<i', response_data[0:4])[0]
                        self._log(f"[VALIDATE] Transport Error: {code}")
                        return False

                    # Decrypt
                    auth_key_id = hashlib.sha1(auth_key).digest()[-8:]
                    res_auth_key_id = response_data[:8]
                    res_msg_key = response_data[8:24]
                    res_encrypted = response_data[24:]
                    
                    if res_auth_key_id != auth_key_id:
                        self._log("[VALIDATE] Key ID mismatch (ignoring)")
                        continue

                    sha256_ra = hashlib.sha256(res_msg_key + auth_key[8:44]).digest()
                    sha256_rb = hashlib.sha256(auth_key[48:84] + res_msg_key).digest()
                    res_aes_key = sha256_ra[0:8] + sha256_rb[8:24] + sha256_ra[24:32]
                    res_aes_iv = sha256_rb[0:8] + sha256_ra[8:24] + sha256_rb[24:32]
                    
                    try:
                        aes_dec = AES256(res_aes_key)
                        res_plain = aes_dec.decrypt_ige(res_encrypted, res_aes_iv)
                    except:
                        continue

                    res_buf = NativeByteBuffer(res_plain)
                    res_buf.read_bytes(28) # salt(8)+session(8)+msg_id(8)+seq(4)
                    res_msg_len = res_buf.read_int(signed=True)
                    
                    main_constructor = res_buf.read_int(signed=False)
                    self._log(f"[VALIDATE] Packet Constructor: {hex(main_constructor)}")
                    
                    # Handle Bad Salt
                    if main_constructor == 0xedab447b:
                        self._log("[VALIDATE] Bad salt received, retrying...")
                        res_buf.read_long() # bad msg id
                        res_buf.read_int() # bad seq
                        res_buf.read_int() # err code
                        new_salt = res_buf.read_long(signed=True)
                        send_rpc_request(new_salt)
                        continue
                        
                    # Queue for processing messages (constructor, buffer)
                    queue = [(main_constructor, res_buf)]
                    
                    while queue:
                        const, buf = queue.pop(0)
                        
                        if const == 0xf35c6d01: # rpc_result
                            req_id = buf.read_long()
                            inner = buf.read_int(signed=False)
                            self._log(f"[VALIDATE] RPC Result for {req_id} (Inner: {hex(inner)})")
                            
                            if inner == 0x2144ca19: # rpc_error inside result
                                err_code = buf.read_int()
                                err_msg = buf.read_string()
                                self._log(f"[VALIDATE] ❌ RPC Error (Result): {err_code} {err_msg}")
                                if err_code == 401 or "AUTH_KEY" in err_msg:
                                    self.val_failed = True
                            else:
                                if req_id == self.val_req_msg_id:
                                    self._log("[VALIDATE] ✅ Valid RPC Result matched!")
                                    self.val_success = True
                        
                        elif const == 0x2144ca19: # rpc_error direct
                            err_code = buf.read_int()
                            err_msg = buf.read_string()
                            self._log(f"[VALIDATE] ❌ RPC Error (Direct): {err_code} {err_msg}")
                            if err_code == 401 or "AUTH_KEY" in err_msg: self.val_failed = True
                            
                        elif const == 0x3072cfa1: # gzip_packed
                            packed = buf.read_byte_array()
                            import zlib
                            unpacked = zlib.decompress(packed)
                            ub = NativeByteBuffer(unpacked)
                            uc = ub.read_int(signed=False)
                            queue.append((uc, ub))
                            
                        elif const == 0x73f1f8dc: # msg_container
                            count = buf.read_int()
                            self._log(f"[VALIDATE] Container with {count} messages")
                            for _ in range(count):
                                buf.read_long() # msg_id
                                buf.read_int() # seq
                                b_len = buf.read_int()
                                body = buf.read_bytes(b_len)
                                bb = NativeByteBuffer(body)
                                bc = bb.read_int(signed=False)
                                queue.append((bc, bb))
                                
                        elif const == 0x9ec20908:
                            self._log("[VALIDATE] Recd: new_session_created (Ignored)")
                        elif const == 0x62d6b459:
                            self._log("[VALIDATE] Recd: msgs_ack (Ignored)")
                        else:
                            self._log(f"[VALIDATE] Unknown: {hex(const)} (Ignored)")
                            
                if self.val_success: return True
                if self.val_failed: return False
                
                self._log("[VALIDATE] ⚠️ Timeout waiting for RPC result")
                return False

            finally:
                sock.close()
                
        except socket.timeout:
            self._log("[VALIDATE] ❌ Connection timeout")
            return False
        except Exception as e:
            self._log(f"[VALIDATE] ❌ Validation error: {e}")
            self._log(traceback.format_exc())
            return False

    def _delete_account(self, slot):
        """Удаляет аккаунт из указанного слота"""
        try:
            self._log(f"[DELETE] Deleting account in slot {slot}")
            
            # FIX: Если удаляем текущий активный аккаунт, сначала переключаемся на другой
            current_account = UserConfig.selectedAccount
            if slot == current_account:
                self._log(f"[DELETE] Deleting current active account (slot {slot}), switching to another...")
                
                # Ищем другой активный аккаунт для переключения
                switched = False
                for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                    if i != slot:  # Не переключаемся на удаляемый слот
                        uc = UserConfig.getInstance(i)
                        if uc.isClientActivated():
                            self._log(f"[DELETE] Found alternative account in slot {i}, switching...")
                            try:
                                # Переключаемся на этот аккаунт
                                UserConfig.selectedAccount = i
                                # Сохраняем изменения
                                uc.saveConfig(True)
                                switched = True
                                self._log(f"[DELETE] Successfully switched to slot {i}")
                                break
                            except Exception as e:
                                self._log(f"[DELETE] Failed to switch to slot {i}: {e}")
                
                if not switched:
                    self._log("[DELETE] ⚠️ No alternative account found, will show login screen after restart")
            
            ctx = ApplicationLoader.applicationContext
            base_dir = str(ctx.getFilesDir())
            
            # Определяем директорию аккаунта
            if slot == 0:
                acc_dir = base_dir
            else:
                acc_dir = os.path.join(base_dir, f"account{slot}")
            
            # Удаляем файлы
            files_to_delete = ["tgnet.dat", "user.xml", "config.xml"]
            for fname in files_to_delete:
                fpath = os.path.join(acc_dir, fname)
                if os.path.exists(fpath):
                    os.remove(fpath)
                    self._log(f"[DELETE] Removed {fname}")
            
            # Удаляем userconfig из shared_prefs
            prefs_dir = os.path.join(str(ctx.getFilesDir().getParent()), "shared_prefs")
            if slot == 0:
                prefs_name = "userconfing.xml"
            else:
                prefs_name = f"userconfing{slot}.xml"
            
            prefs_path = os.path.join(prefs_dir, prefs_name)
            if os.path.exists(prefs_path):
                os.remove(prefs_path)
                self._log(f"[DELETE] Removed {prefs_name}")
            
            # Очищаем через UserConfig
            try:
                uc = UserConfig.getInstance(slot)
                uc.clearConfig()
                self._log(f"[DELETE] Cleared UserConfig for slot {slot}")
            except Exception as e:
                self._log(f"[DELETE] Error clearing UserConfig: {e}")
            
            # Удаляем папку если это не slot 0
            if slot != 0 and os.path.exists(acc_dir):
                try:
                    shutil.rmtree(acc_dir, ignore_errors=True)
                    self._log(f"[DELETE] Removed directory account{slot}")
                except Exception as e:
                    self._log(f"[DELETE] Error removing directory: {e}")
            
            self._show_restart_dialog()

            run_on_ui_thread(lambda: BulletinHelper.show_success(f"Аккаунт удалён!"))
            return True
            
        except Exception as e:
            self._log(f"[DELETE] Error: {e}")
            self._log(traceback.format_exc())
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка удаления: {e}"))
            return False
    
    
    def _show_account_info(self, account):
        """Показывает ОЧЕНЬ красивую детальную информацию об аккаунте"""
        try:
            def show_dialog():
                try:
                    context = get_last_fragment().getParentActivity()
                    
                    # Основной контейнер с белым фоном
                    root = LinearLayout(context)
                    root.setOrientation(LinearLayout.VERTICAL)
                    root.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
                    
                    # 1. Заголовок внутри View
                    header_bar = LinearLayout(context)
                    header_bar.setOrientation(LinearLayout.VERTICAL)
                    header_bar.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(20), AndroidUtilities.dp(24), AndroidUtilities.dp(16))
                    header_bar.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundGray))
                    
                    title_text = TextView(context)
                    title_text.setText("Account Information")
                    title_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                    title_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                    try: title_text.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                    except: pass
                    header_bar.addView(title_text)
                    root.addView(header_bar)
                    
                    # 2. Секция Аватара
                    avatar_container = FrameLayout(context)
                    avatar_container.setPadding(0, AndroidUtilities.dp(24), 0, AndroidUtilities.dp(20))
                    
                    # Круглая подложка
                    circle_bg = View(context)
                    shape = GradientDrawable()
                    shape.setShape(GradientDrawable.OVAL)
                    shape.setColor(Theme.getColor(Theme.key_featuredStickers_addButton) & 0x15FFFFFF)
                    circle_bg.setBackground(shape)
                    avatar_container.addView(circle_bg, LayoutHelper.createFrame(110, 110, Gravity.CENTER))
                    
                    avatar_view = BackupImageView(context)
                    avatar_view.setRoundRadius(AndroidUtilities.dp(42))
                    
                    slot = account['slot']
                    user_id = account.get('user_id', 0)
                    
                    avatar_drawable = AvatarDrawable()
                    if user_id > 0:
                        user = MessagesController.getInstance(slot).getUser(user_id)
                        if user:
                            avatar_drawable.setInfo(slot, user)
                            avatar_view.setForUserOrChat(user, avatar_drawable)
                        else:
                            avatar_drawable.setInfo(user_id, account.get('first_name', '?'), account.get('last_name', ''))
                            avatar_view.setImageDrawable(avatar_drawable)
                    else:
                        avatar_drawable.setInfo(0, None)
                        avatar_view.setImageDrawable(avatar_drawable)
                    
                    avatar_container.addView(avatar_view, LayoutHelper.createFrame(84, 84, Gravity.CENTER))
                    root.addView(avatar_container)
                    
                    # 3. Имя
                    name_title = TextView(context)
                    full_name = f"{account.get('first_name', '')} {account.get('last_name', '')}".strip()
                    name_title.setText(full_name or "Unknown Account")
                    name_title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                    name_title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                    name_title.setGravity(Gravity.CENTER)
                    try: name_title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                    except: pass
                    root.addView(name_title, LayoutHelper.createLinear(-1, -2, 16, 0, 16, 4))
                    
                    status_text = TextView(context)
                    status_text.setText(f"Slot {slot} • ID {user_id}")
                    status_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                    status_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
                    status_text.setGravity(Gravity.CENTER)
                    root.addView(status_text, LayoutHelper.createLinear(-1, -2, 16, 0, 16, 24))
                    
                    # 4. Данные
                    data_container = LinearLayout(context)
                    data_container.setOrientation(LinearLayout.VERTICAL)
                    data_container.setPadding(AndroidUtilities.dp(20), 0, AndroidUtilities.dp(20), AndroidUtilities.dp(16))
                    
                    def add_detail(label, value, icon):
                        if not value: return
                        
                        item = LinearLayout(context)
                        item.setOrientation(LinearLayout.HORIZONTAL)
                        item.setGravity(Gravity.CENTER_VERTICAL)
                        item.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(10))
                        
                        icon_text = TextView(context)
                        icon_text.setText(icon)
                        icon_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
                        item.addView(icon_text, LayoutHelper.createLinear(28, -2))
                        
                        text_box = LinearLayout(context)
                        text_box.setOrientation(LinearLayout.VERTICAL)
                        text_box.setPadding(AndroidUtilities.dp(12), 0, 0, 0)
                        
                        lbl = TextView(context)
                        lbl.setText(label.upper())
                        lbl.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                        lbl.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11)
                        try: lbl.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
                        except: pass
                        text_box.addView(lbl)
                        
                        val = TextView(context)
                        val.setText(str(value))
                        val.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                        val.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
                        text_box.addView(val)
                        
                        item.addView(text_box, LayoutHelper.createLinear(-1, -2))
                        data_container.addView(item)
                        
                        # Divider
                        div = View(context)
                        div.setBackgroundColor(Theme.getColor(Theme.key_divider))
                        data_container.addView(div, LayoutHelper.createLinear(-1, 0.5, 40, 0, 0, 0))

                    add_detail("Phone Number", account.get('phone'), "📞")
                    add_detail("Username", f"@{account.get('username')}" if account.get('username') else None, "👤")
                    add_detail("Data Center", f"DC {account.get('dc_id')}", "📡")
                    add_detail("Status", "Active Session" if account.get('is_active') else "Inactive", "💎")
                    
                    root.addView(data_container)
                    
                    # Показываем диалог БЕЗ title/message, только view
                    native_builder = AlertDialog.Builder(context)
                    native_builder.setView(root)
                    native_builder.setPositiveButton("Close", None)
                    
                    dialog = native_builder.create()
                    dialog.show()
                except Exception as e:
                    self._log(f"[INFO_DIALOG] Error in show_dialog: {e}")
                    BulletinHelper.show_error(f"Dialog error: {e}")
            
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            self._log(f"[INFO] Error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {e}"))
    
    def _confirm_delete(self, account):
        """Показывает диалог подтверждения удаления"""
        try:
            def show_dialog():
                context = get_last_fragment().getParentActivity()
                
                def on_confirm(builder, button_id):
                    builder.dismiss()
                    import threading
                    threading.Thread(target=self._delete_account, args=(account['slot'],)).start()
                
                builder = AlertDialogBuilder(context)
                builder.set_title("Удалить аккаунт?")
                builder.set_message(f"Вы уверены, что хотите удалить аккаунт:\n\n{account['first_name']} {account['last_name']}\n@{account['username']}\n\nЭто действие нельзя отменить!")
                builder.set_positive_button("Удалить", on_confirm)
                builder.set_negative_button("Отмена")
                builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
                builder.show()
            
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            self._log(f"[CONFIRM] Error: {e}")
    
    def _show_account_menu(self, account):
        """Показывает меню действий для аккаунта"""
        try:
            def show_menu():
                context = get_last_fragment().getParentActivity()
                
                options = [
                    "🔄 Переключиться",
                    "🗑️ Удалить аккаунт"
                ]
                
                def handle_option(builder, index):
                    builder.dismiss()
                    
                    if index == 0:  # Switch
                        self._switch_to_account(account['slot'])
                    elif index == 1:  # Delete
                        self._confirm_delete(account)
                
                builder = AlertDialogBuilder(context)
                builder.set_title(f"Аккаунт: {account['first_name']}")
                builder.set_items(options, handle_option)
                builder.set_negative_button("Отмена")
                builder.show()
            
            run_on_ui_thread(show_menu)
            
        except Exception as e:
            self._log(f"[MENU] Error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {e}"))


    def create_settings(self):
        try:
            settings = [
                Header(text="Добавление сессий"),
                Text(text="Выбрать ZIP архив", icon="msg_folders", on_click=self._launch_file_picker),
                Text(text="Перезапустить клиент", icon="msg_retry", on_click=self._restart),
                Divider()
            ]
            
            # Получаем список аккаунтов для статуса
            accounts = self._get_all_accounts()
            active_cnt = sum(1 for a in accounts if a.get('is_active'))
            self.last_status = f"Активных: {active_cnt} • Всего: {len(accounts)}"
            
            if accounts:
                settings.append(Header(text="Управление Аккаунтами"))
                settings.append(Divider())
            else:
                settings.append(Header(text="Аккаунты"))
                settings.append(Text(text="Нет активных аккаунтов", icon="msg_block"))
                settings.append(Divider())
            
            return settings
            
        except Exception as e:
            self._log(f"[CREATE_SETTINGS] Error: {e}")
            self._log(traceback.format_exc())
            
            # Возвращаем минимальные настройки при ошибке
            return [
                Header(text="Ошибка"),
                Text(text=f"Ошибка загрузки настроек: {str(e)}", icon="msg_block"),
                Divider(),
                Header(text="Добавление"),
                Text(text="Выбрать ZIP", icon="msg_folders", on_click=self._launch_file_picker)
            ]

    def _restart(self, v):
        try:
            self._restart_app()
        except:
            pass

    def _launch_file_picker(self,v):
        try:
            fragment=get_last_fragment()
            activity=fragment.getParentActivity()
            if self._activity_hook:self.unhook_method(self._activity_hook)
            Integer=jclass("java.lang.Integer").TYPE
            IntentCls=jclass("android.content.Intent")
            method=activity.getClass().getDeclaredMethod("onActivityResult",Integer,Integer,IntentCls)
            self._activity_hook=self.hook_method(method,self.ActivityResultHook(self))
            intent=Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("application/zip")
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            activity.startActivityForResult(Intent.createChooser(intent,"Выбери ZIP"),FILE_PICKER_ID)
        except Exception as e:BulletinHelper.show_error(f"Err: {e}")

    class ActivityResultHook(MethodHook):
        def __init__(self,p):
            self.plugin=p
        def before_hooked_method(self,param):
            req=param.args[0]
            res=param.args[1]
            data=param.args[2]
            if req==FILE_PICKER_ID:
                param.setResult(None)
                if res==Activity.RESULT_OK and data:
                    uri=data.getData()
                    if uri:
                        BulletinHelper.show_info("Обработка...")
                        import threading
                        threading.Thread(target=self.plugin._process_zip,args=(uri,)).start()
                if self.plugin._activity_hook:
                    self.plugin.unhook_method(self.plugin._activity_hook)
                    self.plugin._activity_hook=None

    def _process_zip(self,uri):
        temp_zip=None
        temp_dir=None
        try:
            self.last_status="Чтение ZIP..."
            self._log("=== START ===")
            ctx=ApplicationLoader.applicationContext
            stream=ctx.getContentResolver().openInputStream(uri)
            temp_zip=os.path.join(str(ctx.getCacheDir()),f"s_{int(time.time())}.zip")
            with open(temp_zip,"wb")as f:
                buf=bytearray(8192)
                while True:
                    br=stream.read(buf)
                    if br==-1:break
                    f.write(buf[:br])
            stream.close()
            self._log(f"ZIP: {os.path.getsize(temp_zip)} bytes")
            
            self.last_status="Распаковка..."
            temp_dir=os.path.join(str(ctx.getCacheDir()),f"ex_{int(time.time())}")
            os.makedirs(temp_dir,exist_ok=True)
            with zipfile.ZipFile(temp_zip,'r')as zf:zf.extractall(temp_dir)
            
            # Detect type
            tgnet_file=None
            userconf_file=None
            key_datas_file=None
            
            for root,dirs,files in os.walk(temp_dir):
                self._log(f"[DEBUG] Found in {root}: {files}")
                for f in files:
                    if f.lower() == "tgnet.dat":
                        tgnet_file = os.path.join(root, f)
                    if f.lower() in ["userconfig.xml", "userconfing.xml"]:
                        userconf_file = os.path.join(root, f)
                    if f.lower() == "key_datas":
                        key_datas_file = os.path.join(root, f)
            
            # PATH 1: Premade session
            if tgnet_file:
                self._log(f"[MODE] tgnet.dat detected at {tgnet_file}")
                
                # Пытаемся вытянуть реальный ID из tgnet.dat
                real_id = 0
                real_dc = 2
                try:
                    session_info = TgnetDeserializer.parse_tgnet(tgnet_file)
                    if session_info:
                        real_dc = session_info.get("dc_id", 2)
                        # Мы не можем вытянуть User ID напрямую из tgnet.dat (он там не хранится в явном виде)
                        # Но мы можем попробовать найти его в других местах или оставить 0
                        self._log(f"[INJECT] Parsed tgnet: DC{real_dc}")
                except:
                    pass

                # Если userconfig нет, создадим минимальный
                if not userconf_file:
                    self._log("[INJECT] userconfig.xml missing, creating stub...")
                    userconf_file = os.path.join(temp_dir, "userconfig.xml")
                    # Если ID 0, пробуем хотя бы DC подставить правильный
                    create_userconfig_xml(userconf_file, real_id, real_dc)
                
                self._inject_premade(tgnet_file, userconf_file, ctx)
                return
            
            # PATH 2: TData folder
            if key_datas_file:
                self._log("[MODE] TData detected")
                self._inject_tdata(os.path.dirname(key_datas_file),ctx)
                return
                
            # PATH 3: NiceGram Backup
            # Check for account folders
            nicegram_accounts = []
            for root, dirs, files in os.walk(temp_dir):
                for d in dirs:
                    if d.startswith("account"):
                        acc_path = os.path.join(root, d)
                        if os.path.exists(os.path.join(acc_path, "tgnet.dat")) and \
                           os.path.exists(os.path.join(acc_path, "session.json")):
                            nicegram_accounts.append(acc_path)
            
            if nicegram_accounts:
                self._log(f"[MODE] NiceGram detected ({len(nicegram_accounts)} accounts)")
                self._inject_nicegram(nicegram_accounts, ctx)
                return
            
            # Neither
            self.last_status="❌ Неопознанный архив"
            self._log("[ERROR] No tgnet.dat or key_datas or NiceGram accounts found")
            run_on_ui_thread(lambda:BulletinHelper.show_error("Файлы не найдены (ни tgnet.dat, ни key_datas)"))
        
        except Exception as e:
            self.last_status=f"❌ {str(e)[:50]}"
            self._log(f"[EXCEPTION] {e}")
            self._log(traceback.format_exc())
            run_on_ui_thread(lambda:BulletinHelper.show_error(f"Ошибка: {e}"))
        finally:
            if temp_zip and os.path.exists(temp_zip):os.remove(temp_zip)
            if temp_dir and os.path.exists(temp_dir):shutil.rmtree(temp_dir,ignore_errors=True)

    def _inject_premade(self,tgnet_path,userconf_path,ctx):
        self._log("[INJECT] Using premade session")
        free_slot=self._find_free_slot()
        if free_slot==-1:
            run_on_ui_thread(lambda:BulletinHelper.show_error("Нет слотов!"))
            return
        self.last_slot=free_slot
        self.last_status=f"Копирование (Слот {free_slot})..."
        
        base=str(ctx.getFilesDir())
        acc_dir=os.path.join(base,f"account{free_slot}")if free_slot>0 else base
        if os.path.exists(acc_dir):
            for fn in["tgnet.dat","user.xml","config.xml"]:
                p=os.path.join(acc_dir,fn)
                if os.path.exists(p):os.remove(p)
        os.makedirs(acc_dir,exist_ok=True)
        
        dest_tgnet=os.path.join(acc_dir,"tgnet.dat")
        shutil.copy(tgnet_path,dest_tgnet)
        self._log(f"[COPY] tgnet.dat -> {dest_tgnet}")
        
        prefs_dir=os.path.join(str(ctx.getFilesDir().getParent()),"shared_prefs")
        os.makedirs(prefs_dir,exist_ok=True)
        prefs_name=f"userconfig{free_slot}.xml"if free_slot>0 else"userconfig.xml"
        dest_xml=os.path.join(prefs_dir,prefs_name)
        shutil.copy(userconf_path,dest_xml)
        self._log(f"[COPY] userconfig -> {dest_xml}")
        
        self.last_status=f"✅ Готово (Слот {free_slot})"
        self._log("[SUCCESS] Premade session injected")
        self._show_restart_dialog()
        run_on_ui_thread(lambda:BulletinHelper.show_success(f"Слот {free_slot}!\n\nТребуется перезапуск"))

    def _inject_tdata(self, tdata_dir, ctx):
        self._log("[INJECT] Scanning TData...")
        try:
            accounts = self.parse_tdata(tdata_dir)
            self._log(f"[TDATA] Found {len(accounts)} valid accounts")
        except Exception as e:
            err_msg = str(e)
            self._log(f"[ERROR] TData scan failed: {err_msg}")
            self._log(traceback.format_exc())
            run_on_ui_thread(lambda msg=err_msg: BulletinHelper.show_error(f"Ошибка TData: {msg}"))
            return
        
        injected_count = 0
        for auth_key, dc_id, user_id in accounts:
            # Validate session (Blocking)
            self._log(f"[INJECT] Validating session for User {user_id} DC{dc_id}...")
            is_valid = self._validate_session(auth_key, dc_id)
            
            if not is_valid:
                 self._log(f"[SKIP] Session invalid or connection failed")
                 self._show_invalid_session_alert()
                 continue


            free_slot = self._find_free_slot()
            if free_slot == -1:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Нет свободных слотов!"))
                break
            
            self._log(f"[INJECT] Injecting ID {user_id} (DC{dc_id}) -> Slot {free_slot}")
            
            base = str(ctx.getFilesDir())
            acc_dir = os.path.join(base, f"account{free_slot}") if free_slot > 0 else base
            if os.path.exists(acc_dir):
                for fn in ["tgnet.dat", "user.xml", "config.xml"]:
                    p = os.path.join(acc_dir, fn)
                    if os.path.exists(p): os.remove(p)
            os.makedirs(acc_dir, exist_ok=True)
            
            # Generate tgnet.dat
            ser = TgnetSerializer(auth_key, dc_id)
            tgnet_path = os.path.join(acc_dir, "tgnet.dat")
            ser.save(tgnet_path)
            self._log(f"[GEN] tgnet.dat -> {tgnet_path}")
            
            # Generate userconfig
            if user_id > 0:
                prefs_dir = os.path.join(str(ctx.getFilesDir().getParent()), "shared_prefs")
                os.makedirs(prefs_dir, exist_ok=True)
                prefs_name = f"userconfig{free_slot}.xml" if free_slot > 0 else "userconfig.xml"
                xml_path = os.path.join(prefs_dir, prefs_name)
                create_userconfig_xml(xml_path, user_id, dc_id)
                self._log(f"[GEN] userconfig -> {xml_path}")
            


            injected_count += 1
            
        if injected_count > 0:
            self.last_status = f"✅ Готово ({injected_count} акк.)"
            self._log(f"[SUCCESS] {injected_count} accounts injected")
            self._show_restart_dialog()
        else:
            self.last_status = "⚠️ Ничего не добавлено"
            run_on_ui_thread(lambda: BulletinHelper.show_error("Аккаунты найдены, но не добавлены"))

    def _inject_nicegram(self, account_paths, ctx):
        self._log("[INJECT] Starting NiceGram injection...")
        injected_count = 0
        
        for acc_path in account_paths:
            try:
                self._log(f"[NICEGRAM] Processing {os.path.basename(acc_path)}")
                
                # Парсинг JSON
                json_path = os.path.join(acc_path, "session.json")
                with open(json_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    try:
                        data = json.loads(content, strict=False)
                    except json.JSONDecodeError:
                        # Fallback для очень сломанного JSON (переносы строк в строке)
                        content_fixed = content.replace('\n', '').replace('\r', '')
                        data = json.loads(content_fixed, strict=False)
                    
                user_b64 = data.get("user")
                uid = data.get("id")
                
                if not user_b64 or not uid:
                    self._log(f"[SKIP] Missing user data in {json_path}")
                    continue
                    
                # Поиск слота
                free_slot = self._find_free_slot()
                if free_slot == -1:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Нет свободных слотов!"))
                    break
                    
                self._log(f"[INJECT] Injecting ID {uid} -> Slot {free_slot}")
                
                base = str(ctx.getFilesDir())
                acc_dir = os.path.join(base, f"account{free_slot}") if free_slot > 0 else base
                if os.path.exists(acc_dir):
                    try:
                       shutil.rmtree(acc_dir)
                    except:
                       pass
                os.makedirs(acc_dir, exist_ok=True)
                
                # Копирование tgnet.dat
                src_tgnet = os.path.join(acc_path, "tgnet.dat")
                dest_tgnet = os.path.join(acc_dir, "tgnet.dat")
                shutil.copy(src_tgnet, dest_tgnet)
                self._log(f"[COPY] tgnet.dat -> {dest_tgnet}")
                
                # Создание userconfig.xml
                prefs_dir = os.path.join(str(ctx.getFilesDir().getParent()), "shared_prefs")
                os.makedirs(prefs_dir, exist_ok=True)
                prefs_name = f"userconfig{free_slot}.xml" if free_slot > 0 else "userconfig.xml"
                xml_path = os.path.join(prefs_dir, prefs_name)
                
                # Создание XML вручную с существующим base64 blob
                # DC по умолчанию 2, как и планировалось
                xml_content = f'''<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
    <string name="user">{user_b64}</string>
    <int name="dc_id" value="2" />
    <long name="clientUserId" value="{uid}" />
    <int name="currentAccount" value="0" />
</map>'''
                with open(xml_path, 'w', encoding='utf-8') as f:
                    f.write(xml_content)
                    
                self._log(f"[GEN] userconfig -> {xml_path}")
                injected_count += 1
                
            except Exception as e:
                self._log(f"[ERROR] Failed to inject {acc_path}: {e}")
                self._log(traceback.format_exc())
                
        if injected_count > 0:
            self.last_status = f"✅ Готово ({injected_count} NiceGram)"
            self._log(f"[SUCCESS] {injected_count} NiceGram accounts injected")
            self._show_restart_dialog()
        else:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка NiceGram импорта"))

    def _find_free_slot(self):
        for i in range(UserConfig.MAX_ACCOUNT_COUNT):
            uc=UserConfig.getInstance(i)
            if not uc.isClientActivated():
                self._log(f"[SLOT] Free slot found: {i}")
                return i
        self._log("[SLOT] No free slots")
        return -1

    def _create_cards_row(self, accounts, context):
        """Создает горизонтальный ряд из 2 карточек (FIX: адаптивная высота)"""
        try:
            row = LinearLayout(context)
            row.setOrientation(LinearLayout.HORIZONTAL)
            row.setPadding(
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(4),
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(4)
            )
            
            for idx, account in enumerate(accounts):
                card = self._create_account_card(account, context)
                if card:
                    # FIX: WRAP_CONTENT (-2) для автоматического подстраивания под контент
                    margin_right = AndroidUtilities.dp(4) if idx < len(accounts) - 1 else 0
                    row.addView(
                        card,
                        LayoutHelper.createLinear(-1, -2, 1.0, 0, 0, margin_right, 0)
                    )
            
            return row if row.getChildCount() > 0 else None
            
        except Exception as e:
            self._log(f"[ROW] Error creating row: {e}")
            return None

    def _create_account_card(self, account, context):
        """Создает минималистичную вертикальную MD3 карточку (FIX: аватарки + красивый фон)"""
        try:
            # FIX: Вертикальный контейнер
            card = LinearLayout(context)
            card.setOrientation(LinearLayout.VERTICAL)
            card.setGravity(Gravity.CENTER)
            card.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12))
            
            # FIX: Красивый фон (убираем голубой у активного)
            # Для активного делаем светло-серый или акцентный, но ОЧЕНЬ прозрачный/мягкий
            if account.get('is_active'):
                bg_color = Theme.getColor(Theme.key_windowBackgroundGray) # Нейтральный серый для выделения
            else:
                bg_color = Theme.getColor(Theme.key_windowBackgroundWhite)
            
            card_bg = Theme.createRoundRectDrawable(AndroidUtilities.dp(12), bg_color)
            card.setBackground(card_bg)
            
            card.setClickable(True)
            card.setFocusable(True)
            
            # Аватар
            avatar_size = AndroidUtilities.dp(46)
            avatar_view = BackupImageView(context)
            avatar_view.setRoundRadius(AndroidUtilities.dp(23))
            
            # FIX: Прямое использование BackupImageView (гарантирует отображение авы)
            slot = account['slot']
            user_id = account.get('user_id', 0)
            
            if user_id > 0:
                controller = MessagesController.getInstance(slot)
                user = controller.getUser(user_id)
                if user:
                    avatar_drawable = AvatarDrawable()
                    avatar_drawable.setInfo(slot, user)
                    avatar_view.setForUserOrChat(user, avatar_drawable)
                else:
                    # Если юзера нет в памяти, рисуем плейсхолдер
                    avatar_drawable = AvatarDrawable()
                    avatar_drawable.setInfo(slot, None)
                    avatar_drawable.setInfo(user_id, account.get('first_name', '?'), account.get('last_name', ''))
                    avatar_view.setImageDrawable(avatar_drawable)
            else:
                # Плейсхолдер
                avatar_drawable = AvatarDrawable()
                avatar_drawable.setInfo(0, None)
                avatar_view.setImageDrawable(avatar_drawable)

            card.addView(avatar_view, LayoutHelper.createLinear(46, 46, Gravity.CENTER, 0, 0, 0, 8))
            
            # Имя
            name_text = TextView(context)
            # FIX: Убираем None если фамилии нет
            fname = account.get('first_name') or ""
            lname = account.get('last_name') or ""
            full_name = f"{fname} {lname}".strip()
            
            if not full_name:
                full_name = f"Слот {account['slot']}"
            
            name_text.setText(full_name)
            name_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            name_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            name_text.setSingleLine(True)
            name_text.setEllipsize(TextUtils.TruncateAt.END)
            name_text.setGravity(Gravity.CENTER)
            
            try: name_text.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except: pass
            
            card.addView(name_text, LayoutHelper.createLinear(-1, -2, Gravity.CENTER, 4, 0, 4, 2))
            
            # Слот
            slot_text = TextView(context)
            if account.get('is_active'):
                slot_text.setText(f"✅ Активен")
                slot_text.setTextColor(Theme.getColor(Theme.key_chats_actionBackground))
            else:
                slot_text.setText(f"Слот {account['slot']}")
                slot_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            
            slot_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11)
            slot_text.setGravity(Gravity.CENTER)
            
            card.addView(slot_text, LayoutHelper.createLinear(-1, -2, Gravity.CENTER))
            
            # Обработка клика
            try:
                OnClickListener = jclass("android.view.View$OnClickListener")
                class OnAccountClick(dynamic_proxy(OnClickListener)):
                    def __init__(self, callback, data):
                        super().__init__()
                        self.callback = callback
                        self.data = data
                    def onClick(self, v):
                        self.callback(self.data)
                
                card.setOnClickListener(OnAccountClick(self._show_account_menu, account.copy()))
            except Exception as click_err:
                self._log(f"[CARD] Fallback to lambda click: {click_err}")
                account_data_copy = account.copy()
                card.setOnClickListener(lambda v: self._show_account_menu(account_data_copy))
            
            return card
            
        except Exception as e:
            self._log(f"[CARD] Error creating card: {e}")
            self._log(traceback.format_exc())
            return None
