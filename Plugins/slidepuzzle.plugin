from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment, send_message, run_on_queue
from hook_utils import find_class
from java import dynamic_proxy
from android_utils import run_on_ui_thread
from org.telegram.messenger import LocaleController
from markdown_utils import parse_markdown
import random
import time

# Powered by @AGeekApple
# Slide Puzzle Game Plugin for exteraGram by @ApplePlugins

TextView = find_class("android.widget.TextView")
GridLayout = find_class("android.widget.GridLayout")
LinearLayout = find_class("android.widget.LinearLayout")
FrameLayout = find_class("android.widget.FrameLayout")
AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
Theme = find_class("org.telegram.ui.ActionBar.Theme")
Gravity = find_class("android.view.Gravity")
OnClickListenerInterface = find_class("android.view.View$OnClickListener")

__id__ = "slidepuzzle"
__name__ = "Slide Puzzle"
__description__ = "ÐšÐ»Ð°ÑÑÐ¸Ñ‡ÐµÑÐºÐ°Ñ Ð³Ð¾Ð»Ð¾Ð²Ð¾Ð»Ð¾Ð¼ÐºÐ° Â«ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸Â»! Ð Ð°ÑÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ñ‡Ð¸ÑÐ»Ð° Ð¾Ñ‚ 1 Ð´Ð¾ 15 Ð² Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ.\n\nÐ˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ:\nâ€¢ Ð’ Ð¼ÐµÐ½ÑŽ Ñ‡Ð°Ñ‚Ð°: Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐŸÐ»Ð°Ð³Ð¸Ð½Ñ‹ â†’ ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸\nâ€¢ Ð’ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð½Ð¾Ð¼ Ð¼ÐµÐ½ÑŽ: Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸\n\nby @ApplePlugins Lab â€¢ @exteraDevPlugins"
__author__ = "@AGeekApple"
__version__ = "1.0.0"
__min_version__ = "11.12.0"
__icon__ = "ApplePlugins/17"

TRANSLATIONS = {
    "en": {
        "menu_title": "Slide Puzzle",
        "game_title": "Slide Puzzle",
        "btn_close": "Close",
        "btn_reset": "Shuffle",
        "win_title": "Congratulations!",
        "win_message": "You solved the puzzle! Play again?",
        "btn_yes": "Yes",
        "btn_no": "No",
        "share_button": "Share",
        "share_text": "I solved the Slide Puzzle!",
        "share_text_rank": "**Slide Puzzle** solved!\n[ðŸ§©](5235588635885054955) Moves: {moves}\n[ðŸ•”](5255971360965930740) Time: {time}\n\n_Can you solve it faster?_",
        "moves_text": "Moves: {moves}",
        "time_text": "Time: {time}",
        "toast_copied": "Copied to clipboard"
    },
    "pt": {
        "menu_title": "Quebra-CabeÃ§a",
        "game_title": "Quebra-CabeÃ§a",
        "btn_close": "Fechar",
        "btn_reset": "Embaralhar",
        "win_title": "ParabÃ©ns!",
        "win_message": "VocÃª resolveu o quebra-cabeÃ§a! Jogar novamente?",
        "btn_yes": "Sim",
        "btn_no": "NÃ£o",
        "share_button": "Compartilhar",
        "share_text": "Resolvi o Quebra-CabeÃ§a!",
        "share_text_rank": "**Quebra-CabeÃ§a** resolvido!\n[ðŸ§©](5235588635885054955) Movimentos: {moves}\n[ðŸ•”](5255971360965930740) Tempo: {time}\n\n_Consegue resolver mais rÃ¡pido?_",
        "moves_text": "Movimentos: {moves}",
        "time_text": "Tempo: {time}",
        "toast_copied": "Copiado para a Ã¡rea de transferÃªncia"
    },
    "es": {
        "menu_title": "Rompecabezas",
        "game_title": "Rompecabezas",
        "btn_close": "Cerrar",
        "btn_reset": "Mezclar",
        "win_title": "Â¡Felicitaciones!",
        "win_message": "Â¡Resolviste el rompecabezas! Â¿Jugar de nuevo?",
        "btn_yes": "SÃ­",
        "btn_no": "No",
        "share_button": "Compartir",
        "share_text": "Â¡ResolvÃ­ el Rompecabezas!",
        "share_text_rank": "**Rompecabezas** resuelto!\n[ðŸ§©](5235588635885054955) Movimientos: {moves}\n[ðŸ•”](5255971360965930740) Tiempo: {time}\n\n_Â¿Puedes resolverlo mÃ¡s rÃ¡pido?_",
        "moves_text": "Movimientos: {moves}",
        "time_text": "Tiempo: {time}",
        "toast_copied": "Copiado al portapapeles"
    },
    "ru": {
        "menu_title": "ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸",
        "game_title": "ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸",
        "btn_close": "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",
        "btn_reset": "ÐŸÐµÑ€ÐµÐ¼ÐµÑˆÐ°Ñ‚ÑŒ",
        "win_title": "ÐŸÐ¾Ð·Ð´Ñ€Ð°Ð²Ð»ÑÐµÐ¼!",
        "win_message": "Ð’Ñ‹ Ñ€ÐµÑˆÐ¸Ð»Ð¸ Ð³Ð¾Ð»Ð¾Ð²Ð¾Ð»Ð¾Ð¼ÐºÑƒ! Ð¡Ñ‹Ð³Ñ€Ð°Ñ‚ÑŒ ÐµÑ‰Ðµ?",
        "btn_yes": "Ð”Ð°",
        "btn_no": "ÐÐµÑ‚",
        "share_button": "ÐŸÐ¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ",
        "share_text": "Ð¯ Ñ€ÐµÑˆÐ¸Ð» ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸!",
        "share_text_rank": "**ÐŸÑÑ‚Ð½Ð°ÑˆÐºÐ¸** Ñ€ÐµÑˆÐµÐ½Ñ‹!\n[ðŸ§©](5235588635885054955) Ð¥Ð¾Ð´Ð¾Ð²: {moves}\n[ðŸ•”](5255971360965930740) Ð’Ñ€ÐµÐ¼Ñ: {time}\n\n_Ð¡Ð¼Ð¾Ð¶ÐµÑˆÑŒ Ñ€ÐµÑˆÐ¸Ñ‚ÑŒ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ?_",
        "moves_text": "Ð¥Ð¾Ð´Ð¾Ð²: {moves}",
        "time_text": "Ð’Ñ€ÐµÐ¼Ñ: {time}",
        "toast_copied": "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€"
    }
}

def _get_lang():
    try:
        lc = LocaleController.getInstance()
        info = getattr(lc, "currentLocaleInfo", None)
        code = None
        if info is not None:
            code = getattr(info, "shortName", None) or getattr(info, "language", None)
        if not code:
            cur = getattr(lc, "currentLocale", None)
            if cur and hasattr(cur, "getLanguage"):
                code = cur.getLanguage()
        if code:
            code = str(code).split('-')[0].lower()
            if code in TRANSLATIONS:
                return code
    except Exception:
        pass
    return "en"

def _t(key):
    lang = _get_lang()
    return TRANSLATIONS.get(lang, TRANSLATIONS['en']).get(key, TRANSLATIONS['en'].get(key, key))

def _format_duration(seconds: int) -> str:
    try:
        m = seconds // 60
        s = seconds % 60
        return f"{m:02d}:{s:02d}"
    except Exception:
        return str(seconds)

class TileClickListener(dynamic_proxy(OnClickListenerInterface)):
    def __init__(self, plugin, chat_id, row, col):
        super().__init__()
        self.plugin, self.chat_id, self.row, self.col = plugin, chat_id, row, col
    def onClick(self, view):
        self.plugin.on_tile_click(self.chat_id, self.row, self.col)

class SlidePuzzleGame:
    def __init__(self):
        self.size = 4  # 4x4 grid
        self.board = [[0 for _ in range(self.size)] for _ in range(self.size)]
        self.empty_row = 3
        self.empty_col = 3
        self.moves = 0
        self.started_at = None
        self.is_solved = False
        self.init_board()
        
    def init_board(self):
        # Initialize with numbers 1-15, empty space at bottom right
        num = 1
        for r in range(self.size):
            for c in range(self.size):
                if r == self.size - 1 and c == self.size - 1:
                    self.board[r][c] = 0  # Empty space
                else:
                    self.board[r][c] = num
                    num += 1
    
    def shuffle(self):
        # Shuffle by making random valid moves
        self.moves = 0
        self.started_at = None
        self.is_solved = False
        
        # Make 1000 random moves to shuffle
        for _ in range(1000):
            # Get possible moves
            possible_moves = []
            directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # up, down, left, right
            
            for dr, dc in directions:
                new_r = self.empty_row + dr
                new_c = self.empty_col + dc
                if 0 <= new_r < self.size and 0 <= new_c < self.size:
                    possible_moves.append((new_r, new_c))
            
            if possible_moves:
                move_r, move_c = random.choice(possible_moves)
                self.board[self.empty_row][self.empty_col] = self.board[move_r][move_c]
                self.board[move_r][move_c] = 0
                self.empty_row = move_r
                self.empty_col = move_c
    
    def can_move(self, row, col):
        # Check if tile can move to empty space
        if self.board[row][col] == 0:
            return False
        
        # Check if adjacent to empty space
        return (abs(row - self.empty_row) == 1 and col == self.empty_col) or \
               (abs(col - self.empty_col) == 1 and row == self.empty_row)
    
    def move_tile(self, row, col):
        if not self.can_move(row, col):
            return False
        
        if self.started_at is None:
            self.started_at = time.time()
        
        # Swap tile with empty space
        self.board[self.empty_row][self.empty_col] = self.board[row][col]
        self.board[row][col] = 0
        self.empty_row = row
        self.empty_col = col
        self.moves += 1
        
        # Check if solved
        self.is_solved = self.check_solved()
        return True
    
    def check_solved(self):
        num = 1
        for r in range(self.size):
            for c in range(self.size):
                if r == self.size - 1 and c == self.size - 1:
                    # Last position should be empty
                    if self.board[r][c] != 0:
                        return False
                else:
                    if self.board[r][c] != num:
                        return False
                    num += 1
        return True

class SlidePuzzlePlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.active_games = {}
        self.views = {}
        self.status_views = {}

    def on_plugin_load(self):
        # Chat menu
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.CHAT_ACTION_MENU,
            text=_t("menu_title"),
            icon="msg_plugins_solar",
            on_click=self.show_game_dialog
        ))
        
        # Context menu
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text=_t("menu_title"),
            icon="msg_plugins_solar",
            on_click=self.show_game_dialog
        ))

    def show_game_dialog(self, context):
        chat_id = context.get("dialog_id")
        fragment = get_last_fragment()
        activity = fragment and fragment.getParentActivity()
        if not activity: 
            return

        game = SlidePuzzleGame()
        game.shuffle()
        self.active_games[chat_id] = game

        builder = AlertDialogBuilder(activity)
        builder.set_title(_t("game_title"))

        main = LinearLayout(activity)
        main.setOrientation(LinearLayout.VERTICAL)
        padding = AndroidUtilities.dp(16)
        main.setPadding(padding, padding, padding, padding)
        main.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))

        # Status display
        status_layout = LinearLayout(activity)
        status_layout.setOrientation(LinearLayout.HORIZONTAL)
        status_layout.setGravity(Gravity.CENTER)
        
        moves_text = TextView(activity)
        moves_text.setText(_t("moves_text").format(moves=game.moves))
        moves_text.setTextSize(16)
        moves_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        moves_text.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(16), AndroidUtilities.dp(8))
        
        time_text = TextView(activity)
        time_text.setText(_t("time_text").format(time="00:00"))
        time_text.setTextSize(16)
        time_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        time_text.setPadding(AndroidUtilities.dp(16), 0, AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        
        status_layout.addView(moves_text)
        status_layout.addView(time_text)

        # Game grid
        grid = GridLayout(activity)
        grid.setColumnCount(game.size)
        grid.setRowCount(game.size)
        grid.setAlignmentMode(GridLayout.ALIGN_BOUNDS)

        # Calculate adaptive size
        try:
            display_size = AndroidUtilities.displaySize
            screen_width = display_size.x if display_size else 1080
            
            available_width = int(screen_width * 0.8)
            margin = AndroidUtilities.dp(2)
            total_margin_width = (game.size + 1) * margin * 2
            
            tile_size = (available_width - total_margin_width) // game.size
            tile_size = max(tile_size, AndroidUtilities.dp(60))
            tile_size = min(tile_size, AndroidUtilities.dp(90))
            
            font_size = max(16, min(24, tile_size // AndroidUtilities.dp(4)))
            
        except Exception:
            tile_size = AndroidUtilities.dp(75)
            margin = AndroidUtilities.dp(2)
            font_size = 20

        tiles = {}
        
        for r in range(game.size):
            for c in range(game.size):
                tile = TextView(activity)
                params = GridLayout.LayoutParams(GridLayout.spec(r), GridLayout.spec(c))
                params.width = params.height = tile_size
                params.setMargins(margin, margin, margin, margin)
                tile.setLayoutParams(params)
                
                tile.setTextSize(font_size)
                tile.setGravity(Gravity.CENTER)
                tile.setOnClickListener(TileClickListener(self, chat_id, r, c))
                
                grid.addView(tile)
                tiles[(r, c)] = tile

        # Center the grid
        wrapper = FrameLayout(activity)
        wrapper.addView(grid)
        grid_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT,
            FrameLayout.LayoutParams.WRAP_CONTENT
        )
        grid_params.gravity = Gravity.CENTER
        grid.setLayoutParams(grid_params)

        self.views[chat_id] = tiles
        self.status_views[chat_id] = {
            "moves": moves_text,
            "time": time_text
        }

        # Add shuffle button to the layout instead of dialog buttons
        shuffle_button = TextView(activity)
        shuffle_button.setText(_t("btn_reset"))
        shuffle_button.setTextSize(16)
        shuffle_button.setTextColor(Theme.getColor(Theme.key_featuredStickers_addButton))
        shuffle_button.setGravity(Gravity.CENTER)
        shuffle_button.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
        shuffle_button.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        class ShuffleClickListener(dynamic_proxy(OnClickListenerInterface)):
            def __init__(self, plugin, chat_id):
                super().__init__()
                self.plugin, self.chat_id = plugin, chat_id
            def onClick(self, view):
                game = self.plugin.active_games.get(self.chat_id)
                if game:
                    game.shuffle()
                    self.plugin.update_display(self.chat_id)
        
        shuffle_button.setOnClickListener(ShuffleClickListener(self, chat_id))

        main.addView(status_layout)
        main.addView(wrapper)
        main.addView(shuffle_button)

        builder.set_negative_button(_t("btn_close"), lambda b,w: b.dismiss())
        builder.set_view(main)
        dialog = builder.show()
        game.dialog = dialog
        
        self.update_display(chat_id)
        self.start_timer(chat_id)

    def update_display(self, chat_id):
        game = self.active_games.get(chat_id)
        tiles = self.views.get(chat_id)
        status_views = self.status_views.get(chat_id)
        
        if not game or not tiles or not status_views:
            return
        
        # Update tiles
        for r in range(game.size):
            for c in range(game.size):
                tile = tiles[(r, c)]
                value = game.board[r][c]
                
                if value == 0:
                    # Empty space
                    tile.setText("")
                    tile.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
                else:
                    tile.setText(str(value))
                    if game.can_move(r, c):
                        tile.setBackgroundColor(Theme.getColor(Theme.key_featuredStickers_addButton))
                    else:
                        tile.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
                
                tile.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        
        # Update status
        status_views["moves"].setText(_t("moves_text").format(moves=game.moves))

    def start_timer(self, chat_id):
        def update_timer():
            game = self.active_games.get(chat_id)
            status_views = self.status_views.get(chat_id)
            
            if not game or not status_views or game.is_solved:
                return
            
            if game.started_at:
                elapsed = int(time.time() - game.started_at)
                status_views["time"].setText(_t("time_text").format(time=_format_duration(elapsed)))
            
            # Schedule next update
            run_on_ui_thread(update_timer, 1000)
        
        run_on_ui_thread(update_timer, 1000)

    def on_tile_click(self, chat_id, row, col):
        game = self.active_games.get(chat_id)
        if not game or game.is_solved:
            return
        
        if game.move_tile(row, col):
            self.update_display(chat_id)
            
            if game.is_solved:
                run_on_ui_thread(lambda: self.show_win_dialog(chat_id), 500)

    def show_win_dialog(self, chat_id):
        game = self.active_games.get(chat_id)
        if not game:
            return
            
        fragment = get_last_fragment()
        activity = fragment and fragment.getParentActivity()
        if not activity: 
            return

        builder = AlertDialogBuilder(activity)
        builder.set_title(_t("win_title"))
        builder.set_message(_t("win_message"))

        def restart(b, w):
            b.dismiss()
            self.show_game_dialog({"dialog_id": chat_id})

        def share(b, w):
            b.dismiss()
            elapsed = int(time.time() - game.started_at) if game.started_at else 0
            msg = _t("share_text_rank").format(
                moves=game.moves,
                time=_format_duration(elapsed)
            )
            
            try:
                parsed = parse_markdown(msg)
                params = {
                    "peer": chat_id,
                    "message": parsed.text,
                    "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                }
                run_on_queue(lambda: send_message(params))
            except Exception:
                run_on_queue(lambda: send_message({"peer": chat_id, "message": msg}))

        builder.set_positive_button(_t("share_button"), share)
        builder.set_neutral_button(_t("btn_reset"), restart)
        builder.set_negative_button(_t("btn_close"), lambda b,w: b.dismiss())
        builder.show()