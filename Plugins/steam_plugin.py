'''‚†Ä‚†Ä‚†Ä
–£–∂ –µ—Å–ª–∏ —Ç—ã –∏ —é–Ω—ã–π –ø–∞—Å—Ç–µ—Ä–æ–∫ , —Ç–æ —Ö–æ—Ç—è –±—ã –∏—Å—Ç–æ—á–Ω–∏–∫ —É–∫–∞–∑—ã–≤–∞–π –æ—Ç–∫—É–¥–∞ –ø–∞—Å—Ç–∏–ª :) 
–í –Ω–∞—à–µ–º —Å–ª—É—á–∞–µ: @KangelPlugins & @MGEPlugins
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚£†‚£¥‚£Ø‚£´‚°á‚£Ä‚†ñ‚°∂‚†ä‚†Å‚†Ä‚†Ä‚†à‚†í‚¢§‚°Ä‚†Ä‚£¥‚¢¶‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†ä‚¢ê‚†É‚°á‚°é‚£ø‚°ó‚†Ä‚†à‚†Ä‚†í‚¢ò‚†Ä‚¢±‚†ê‚°á‚†ê‚†â‚¢≤‚£ø‚£á‚£©‚¢ñ‚†¢‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ü‚†Ä‚°ç‚¢∏‚¢Ä‚¢∞‚£ø‚¢á‚†î‚†Ä‚°Ñ‚†Ä‚†à‚†Ñ‚†î‚¢â‚£ê‚†≤‚°Ä‚¢Ä‚£ø‚£∑‚†Ä‚†ò‚¢ì‚†à‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚£á‚°á‚°ò‚£æ‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚°ã‚¢∑‚†ì‚°è‚¢º‚£ø‚†Ä‚°Ä‚¢á‚†Ä‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ü‚†Ä‚£ø‚¢†‚¢°‚†ù‚†Ä‚†Ä‚¢Ä‚£æ‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†õ‚†ã‚£â‚°ô‚†õ‚¢ª‚†Ä‚¢§‚£û‚†Ä‚°∏‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚°Ä‚£á‚¢Ü‚£æ‚°è‚†Ä‚¢†‚£º‚£Ä‚£µ‚£Ñ‚¢Ä‚†Ä‚°Ñ‚¢†‚†Ä‚¢†‚£è‚¢∏‚†ö‚°û‚¢π‚°∏‚¢Å‚†¥‚†Å‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£ø‚£µ‚£ø‚°ç‚¢≥‚¢∂‚¢Ø‚°ü‚¢â‚°õ‚†£‚†Ä‚†Å‚†â‚†â‚¢â‚£â‚°ø‚†æ‚¢ª‚°£‚†æ‚°á‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚¢ø‚¢ã‚°Ä‚†ö‚£ä‚†û‚°•‚†∏‚¢Ä‚†à‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚†õ‚†ã‚°á‚£†‚£∏‚£Ä‚¢Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ö‚†Å‚°á‚†Ä‚†à‚¢Ü‚¢Ä‚†§‚°ã‚†â‚°á‚¢π‚¢ü‚†Å‚†Ä‚¢†‚£†‚°Ä‚†Ä‚†Ä‚£†‚†û‚°á‚¢Ä‚£ß‚†õ‚¢Ø‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚†Ä‚†ò‚¢Ñ‚£†‚°•‚¢è‚†Ä‚¢±‚†Ä‚†ô‚£ú‚£Ü‚£π‚£Ñ‚°à‚†õ‚£Å‚†¥‚†ö‚†Å‚¢∏‚†Å‚°û‚†∞‚†Ä‚†Ä‚†ô‚¢ø‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚°†‚†ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°á‚†Ä‚¢∏‚†Ä‚¢∏‚†Ä‚¢Ä‚£®‚¢Ø‚†ø‚†õ‚†â‚†â‚¢ß‚£Ä‚°Ä‚£Ä‚£û‚°º‚¢ë‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚£Ω‚¢≤‚°Ñ‚†Ä‚†Ä
‚†Ä‚¢Ä‚†ú‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚††‚£í‚†ù‚†ã‚†Ä‚£†‚£æ‚†§‚†ú‚†ö‚†â‚†Ä‚†π‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚£ß‚†â‚†ô‚¢¶‚¢§‚°Ä‚¢Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£æ‚£ó‚°Ñ
‚†Ä‚°ú‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚°æ‚†Å‚¢Ä‚†≤‚†â‚†â‚¢á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ß‚†Ä‚†≤‚†Ä‚¢†‚†É‚†Ä‚†Ä‚¢Ä‚°à‚†®‚¢ª‚¢Ü‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚°ø‚¢∏
‚†ú‚†Ä‚†Ä‚†Ä‚†ê‚†æ‚°©‚†ô‚†£‚°Ä‚†ê‚†Ä‚†Ç‚†Ä‚†Ä‚†±‚£Ñ‚†Ä‚††‚†Ä‚†Ä‚†ò‚°Ñ‚†Ä‚¢Ä‚¢∏‚†Ä‚†Ä‚†∞‚°ª‚£å‚†ñ‚†Å‚†Ä‚†ë‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢Ä‚°§‚†É‚°û
‚¢Ü‚°†‚††‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢Ç‚°Ä‚†Ä‚†Ä‚†Ä‚£Ñ‚†à‚†≥‚£Ñ‚†â‚†Ç‚°Ä‚¢±‚†Ä‚†Ä‚°∏‚¢Ä‚£æ‚£ó‚°û‚†Å‚†Ä‚†Ä‚†ê‚†Å‚†à‚†≥‚£Ä‚°¥‚†ã‚¢Ä‚°û‚†Ä
‚£†‚†û‚£ì‚†∂‚†í‚†Ç‚†¨‚£ç‚£Ç‚£†‚¢§‚†§‚†Å‚†Ñ‚¢ê‚°è‚†Ä‚¢†‚†í‚†ì‚†¢‚°Ä‚†¢‚¢Å‚¢Ä‚°Ø‚¢à‚†Ω‚†ç‚†Å‚¢Ñ‚†Ä‚†∏‚†Å‚†Ä‚††‚†Ä‚†â‚°≥‚£¥‚†Ø‚£Ä‚†Ä
'''
from ui.settings import Header, Input, Switch, Selector, Divider, Text
from base_plugin import BasePlugin, HookResult, HookStrategy
import json
import requests
from java.util import Locale
from markdown_utils import parse_markdown
import time
import threading
from org.telegram.ui.ActionBar import AlertDialog
from client_utils import send_message, get_last_fragment, get_send_messages_helper, get_messages_controller, get_user_config, send_request
from android_utils import log
from java.io import File
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet.tl import TL_account
from org.telegram.tgnet import TLRPC
from ui.bulletin import BulletinHelper
import os
import uuid
from typing import Optional
import io
from PIL import Image, ImageDraw, ImageFont, ImageFilter
from ui.alert import AlertDialogBuilder


__id__ = "steam"
__name__ = "Steam"
__version__ = "1.5.6"
__description__ = "üéÆ Shows the current game on Steam\n\nüìã Commands:\n‚Ä¢ [.nowsteam/.snp] ‚Äî current game\n‚Ä¢ [.slibrary] ‚Äî games library\n‚Ä¢ [.sflibrary] ‚Äî full library\n\nüé® Design by @reNightly, @qmrrchh"
__author__ = "@KangelPlugins & @MGEPlugins"
__min_version__ = "11.12.0"
__icon__ = "Kangelcons_by_fStikBot/0"
__load__ = True

FONTS = {
    "NotoSansJP": "https://github.com/itsNightly/font_link/raw/refs/heads/main/NotoSansJP-Regular.ttf",
    "Zpix": "https://github.com/Ar4ikTrirtyFour/windose20/raw/refs/heads/main/fonts/zpix.ttf",
    "Impact": "https://github.com/localizator/ukrainian-fonts-pack/raw/refs/heads/master/TimesNRCyrMT-Bold%20-%20Times%20New%20Roman%20Cyr%20-%20Bold.ttf"
}

class Locales:
    default = {
        "settings_main_header": "‚öôÔ∏è Basic Settings",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "Enter your Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "Get it at: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ Profile Auto-Update",
        "settings_enable_auto": "Enable auto-update",
        "settings_enable_auto_subtext": "Automatically updates profile with game info",
        "settings_check_interval": "Check interval (seconds)",
        "settings_check_interval_subtext": "How often to check game status",
        "settings_update_location": "Update location",
        "settings_update_location_items": ["About", "Location (Premium)"],
        "settings_text_template": "Text template",
        "settings_text_template_subtext": "Use {game} for game name",
        "settings_default_text": "Default text",
        "settings_default_text_subtext": "Shown when no game is running",
        "settings_sort_by_playtime": "Sort by playtime",
        "settings_sort_by_playtime_subtext": "If disabled, sorts by last played date",
        "settings_usage_divider": "Usage: .nowsteam",
        "card_settings_header": "üñºÔ∏è Card settings",
        "card_text_format": "Card text format",
        "card_text_format_subtext": "Use {nick} and {game}",
        "card_font_family": "Card font",
        "settings_show_card_authors": "Show authors credit on card",
        "settings_show_card_authors_subtext": "Adds 'Plugin by @KangelPlugins & @MGEPlugins' footer",
        "settings_icon_style": "Icon style",
        "settings_icon_style_items": ["Standard", "Needy Streamer Overload"],
        "custom_font_link": "Custom font link",
        "custom_font_link_subtext": "Direct link to .ttf file",
        "custom_font_help_title": "How to use custom fonts",
        "library_settings_header": "üìö Library settings",
        "error_steam_id_not_set": "First set up your Steam ID in plugin settings!",
        "error_api_key_not_set": "First set up your API key in plugin settings!",
        "error_steam_id_not_found": "Steam ID not found or profile is hidden",
        "error_invalid_api_key": "Invalid API key. Get a new key at https://steamcommunity.com/dev/apikey",
        "error_network": "Network error! Check your internet connection",
        "error_api": "Error: Invalid response from Steam API",
        "error_unknown": "Error: {e}",
        "error_invalid_steam_id": "‚ùå Error: Invalid Steam ID",
        "error_api_key_missing": "‚ùå Error: API key is missing",
        "error_api_code": "‚ùå API Error: {code}",
        "error_invalid_response": "‚ùå Error: Invalid response from Steam API",
        "error_private_profile": "‚ùå Error: Unable to get games list. Check your profile privacy settings.",
        "error_network_generic": "‚ùå Network error: {e}",
        "error_json_parse": "‚ùå JSON parse error: {e}",
        "error_unknown_generic": "‚ùå Unknown error: {e}",
        "failed_to_load_library": "‚ùå An error occurred while loading the library. Please check logs.",
        "searching": "Searching...",
        "loading_library": "üîç Loading game list...",
        "library_empty": "üìö Your game library is empty",
        "library_header": "Library of Steam games",
        "full_library_header": "Full Steam library",
        "total_games_and_time": "Total games: {count} | Total time: {hours}h",
        "sorting_label": "Sorting:",
        "sort_by_hours_text": "By playtime (descending)",
        "sort_by_last_played_text": "By last played date",
        "btn_sort_by_hours": "üïí By playtime",
        "btn_sort_by_last_played": "üìÖ By last played date",
        "last_played_suffix": " (last played: {date})",
        "duration_compact_hm": "{hours}h {minutes}m",
        "duration_compact_m": "{minutes}m",
        "and_more_games": "...and {count} more games",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "This feature may work inconsistently due to Telegram's profile change limits. Your profile information may not update immediately. Use at your own risk.",
        "not_playing": "Not playing anything...",
        "playing_format": "**Currently playing:** {game}",
        "developers": "**Developers:** {developers}",
        "publishers": "**Publishers:** {publishers}",
        "metacritic": "**Metacritic Score:** {score}/100",
        "genres": "**Genres:** {genres}",
        "playtime": "**Playtime:** {hours} hrs. {minutes} min.",
        "playtime_minutes": "**Playtime:** {minutes} min.",
        "game_link": "[Game Link]({url})",
        "font_faq_title": "üé® How to use custom fonts",
        "font_faq_text": (
            "üìù How to add a custom font?\n\n"
            "1Ô∏è‚É£ Select 'Custom font' in the font selector\n\n"
            "2Ô∏è‚É£ In the 'Custom font link' field, paste a direct link to the .ttf file\n\n"
            "üîó Example links:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° AND THERE MUST BE .ttf AT THE END\n\n"
            "3Ô∏è‚É£ Create a card with .nowsteam command\n\n"
            "‚ö° The plugin will automatically download the font and use it!\n\n"
            "üö® IMPORTANT! ON FIRST USE/FONT CHANGE, IT WILL TAKE LONGER TO CREATE THAN USUAL\n\n"
            "üíª The author recommends uploading fonts to Github\n\n"
            "üåê Sites where you can find fonts (with direct links):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ Got it",
    }
    en = default
    ru = {
        "settings_main_header": "‚öôÔ∏è –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏",
        "settings_steam_id": "Steam ID",
        "settings_steam_id_subtext": "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Steam ID",
        "settings_api_key": "Steam API Key",
        "settings_api_key_subtext": "–ü–æ–ª—É—á–∏—Ç—å: https://steamcommunity.com/dev/apikey",
        "settings_auto_update_header": "üéÆ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è",
        "settings_enable_auto": "–í–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
        "settings_enable_auto_subtext": "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –ø—Ä–æ—Ñ–∏–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∏–≥—Ä–µ",
        "settings_check_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Å–µ–∫—É–Ω–¥—ã)",
        "settings_check_interval_subtext": "–ö–∞–∫ —á–∞—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å —Å—Ç–∞—Ç—É—Å –∏–≥—Ä—ã",
        "settings_update_location": "–ú–µ—Å—Ç–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è",
        "settings_update_location_items": ["–û —Å–µ–±–µ", "–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è (–ü—Ä–µ–º–∏—É–º)"],
        "settings_text_template": "–®–∞–±–ª–æ–Ω —Ç–µ–∫—Å—Ç–∞",
        "settings_text_template_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {game} –¥–ª—è –Ω–∞–∑–≤–∞–Ω–∏—è –∏–≥—Ä—ã",
        "settings_default_text": "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é",
        "settings_default_text_subtext": "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –∫–æ–≥–¥–∞ –∏–≥—Ä–∞ –Ω–µ –∑–∞–ø—É—â–µ–Ω–∞",
        "settings_sort_by_playtime": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã",
        "settings_sort_by_playtime_subtext": "–ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ, —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "settings_usage_divider": "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: .nowsteam",
        "card_settings_header": "üñºÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format": "–§–æ—Ä–º–∞—Ç —Ç–µ–∫—Å—Ç–∞ –∫–∞—Ä—Ç–æ—á–∫–∏",
        "card_text_format_subtext": "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ {nick} –∏ {game}",
        "card_font_family": "–®—Ä–∏—Ñ—Ç –∫–∞—Ä—Ç–æ—á–∫–∏",
        "settings_show_card_authors": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–¥–ø–∏—Å—å –∞–≤—Ç–æ—Ä–æ–≤ –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ",
        "settings_show_card_authors_subtext": "–î–æ–±–∞–≤–ª—è–µ—Ç —Ñ—É—Ç–µ—Ä 'Plugin by @KangelPlugins & @MGEPlugins'",
        "settings_icon_style": "–°—Ç–∏–ª—å –∏–∫–æ–Ω–æ–∫",
        "settings_icon_style_items": ["–û–±—ã—á–Ω—ã–µ", "Needy Streamer Overload"],
        "custom_font_link": "–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç",
        "custom_font_link_subtext": "–°—Å—ã–ª–∫–∞ –Ω–∞ .ttf —Ñ–∞–π–ª",
        "custom_font_help_title": "–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "library_settings_header": "üìö –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏",
        "error_steam_id_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ Steam ID –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_api_key_not_set": "–°–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ API –∫–ª—é—á –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –ø–ª–∞–≥–∏–Ω–∞!",
        "error_steam_id_not_found": "Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –ø—Ä–æ—Ñ–∏–ª—å —Å–∫—Ä—ã—Ç",
        "error_invalid_api_key": "–ù–µ–≤–µ—Ä–Ω—ã–π API –∫–ª—é—á. –ü–æ–ª—É—á–∏—Ç–µ –Ω–æ–≤—ã–π –∫–ª—é—á –Ω–∞ https://steamcommunity.com/dev/apikey",
        "error_network": "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É",
        "error_api": "–û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API",
        "error_unknown": "–û—à–∏–±–∫–∞: {e}",
        "error_invalid_steam_id": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π Steam ID",
        "error_api_key_missing": "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–∫–∞–∑–∞–Ω API –∫–ª—é—á",
        "error_api_code": "‚ùå –û—à–∏–±–∫–∞ API: {code}",
        "error_invalid_response": "‚ùå –û—à–∏–±–∫–∞: –ù–µ–≤–µ—Ä–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Steam API",
        "error_private_profile": "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª—è.",
        "error_network_generic": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: {e}",
        "error_json_parse": "‚ùå –û—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞ JSON: {e}",
        "error_unknown_generic": "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}",
        "failed_to_load_library": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
        "searching": "–ò—â–µ–º –∏–≥—Ä—É...",
        "loading_library": "üîç –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∏–≥—Ä...",
        "library_empty": "üìö –í–∞—à–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞",
        "library_header": "–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä Steam",
        "full_library_header": "–ü–æ–ª–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Steam",
        "total_games_and_time": "–í—Å–µ–≥–æ –∏–≥—Ä: {count} | –û–±—â–µ–µ –≤—Ä–µ–º—è: {hours}—á",
        "sorting_label": "–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:",
        "sort_by_hours_text": "–ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã (–ø–æ —É–±—ã–≤–∞–Ω–∏—é)",
        "sort_by_last_played_text": "–ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "btn_sort_by_hours": "üïí –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã",
        "btn_sort_by_last_played": "üìÖ –ü–æ –¥–∞—Ç–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∑–∞–ø—É—Å–∫–∞",
        "last_played_suffix": " (–ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞–∑: {date})",
        "duration_compact_hm": "{hours}—á {minutes}–º",
        "duration_compact_m": "{minutes}–º",
        "and_more_games": "...–∏ –µ—â–µ {count} –∏–≥—Ä",
        "stream_alert_title": "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è",
        "stream_alert_message": "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫.",
        "not_playing": "–°–µ–π—á–∞—Å –Ω–µ –∏–≥—Ä–∞—é –Ω–∏ –≤–æ —á—Ç–æ...",
        "playing_format": "**–°–µ–π—á–∞—Å –∏–≥—Ä–∞—é –≤:** {game}",
        "developers": "**–†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∏:** {developers}",
        "publishers": "**–ò–∑–¥–∞—Ç–µ–ª–∏:** {publishers}",
        "metacritic": "**–û—Ü–µ–Ω–∫–∞ Metacritic:** {score}/100",
        "genres": "**–ñ–∞–Ω—Ä—ã:** {genres}",
        "playtime": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {hours} —á. {minutes} –º–∏–Ω.",
        "playtime_minutes": "**–í—Ä–µ–º—è –≤ –∏–≥—Ä–µ:** {minutes} –º–∏–Ω.",
        "game_link": "[–°—Å—ã–ª–∫–∞ –Ω–∞ –∏–≥—Ä—É]({url})",
        "font_faq_title": "üé® –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã",
        "font_faq_text": (
            "üìù –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç?\n\n"
            "1Ô∏è‚É£ –í—ã–±–µ—Ä–∏—Ç–µ '–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤ —Å–µ–ª–µ–∫—Ç–æ—Ä–µ —à—Ä–∏—Ñ—Ç–æ–≤\n\n"
            "2Ô∏è‚É£ –í –ø–æ–ª–µ '–°—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç' –≤—Å—Ç–∞–≤—å—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf —Ñ–∞–π–ª\n\n"
            "üîó –ü—Ä–∏–º–µ—Ä—ã —Å—Å—ã–ª–æ–∫:\n"
            "‚Ä¢ https://example.com/font.ttf\n"
            "‚Ä¢ https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "üí° –ò –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û –¢–ê–ú –î–û–õ–ñ–ï–ù –ë–´–¢–¨ –í –ö–û–ù–¶–ï .ttf\n\n"
            "3Ô∏è‚É£ –°–æ–∑–¥–∞–π—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É –∫–æ–º–∞–Ω–¥–æ–π .nowsteam\n\n"
            "‚ö° –ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫–∞—á–∞–µ—Ç —à—Ä–∏—Ñ—Ç –∏ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ!\n\n"
            "üö® –í–ê–ñ–ù–û! –ü–†–ò –ü–ï–†–í–û–ú –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ò/–°–ú–ï–ù–ï –®–†–ò–§–¢–ê –ë–£–î–ï–¢ –î–û–õ–¨–®–ï –°–û–ó–î–ê–í–ê–¢–¨–°–Ø –ß–ï–ú –û–ë–´–ß–ù–û\n\n"
            "üíª –ê–≤—Ç–æ—Ä —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã –Ω–∞ Github\n\n"
            "üåê –°–∞–π—Ç—ã –≥–¥–µ –º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ —à—Ä–∏—Ñ—Ç—ã (—Å –ø—Ä—è–º—ã–º–∏ —Å—Å—ã–ª–∫–∞–º–∏):\n"
            "‚Ä¢ https://fontsaddict.com\n\n"
            "‚Ä¢ https://en.bestfonts.pro\n\n"
        ),
        "alert_close_button": "‚úÖ –ü–æ–Ω—è–ª",
    }

def localise(key: str, **kwargs) -> str:
    lang = Locale.getDefault().getLanguage()
    locale_dict = getattr(Locales, lang, Locales.default)
    text = locale_dict.get(key, key)
    return text.format(**kwargs) if kwargs else text

TEMP_DIR_NAME = "temp_steam_images"
DEFAULT_STREAM_STRING = localise("playing_format")
DEFAULT_STREAM_TEXT = localise("not_playing")
DEFAULT_CHECK_INTERVAL = 30

NO_STEAM_FALLBACK_URL = "https://raw.githubusercontent.com/ArThirtyFour/Fonts_For_Exteragram/refs/heads/main/no_steam.jpg"
progress_dialog = None
class AlertManager:
    def __init__(self):
        self.alert_builder_instance: Optional[AlertDialogBuilder] = None

    def show_info_alert(self, title: str, message: str, positive_button: str):
        last_fragment = get_last_fragment()
        if not last_fragment or not last_fragment.getParentActivity(): return
        context = last_fragment.getParentActivity()
        builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.alert_builder_instance = builder
        builder.set_title(title)
        builder.set_message(message)
        builder.set_positive_button(positive_button, lambda d, w: self.dismiss_dialog())
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def dismiss_dialog(self):
        if self.alert_builder_instance and self.alert_builder_instance.get_dialog() and self.alert_builder_instance.get_dialog().isShowing():
            self.alert_builder_instance.dismiss()
            self.alert_builder_instance = None


class SteamPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir = None
        self._streamer_thread = None
        self._stop_streamer = False
        self.alert_manager = AlertManager()
        threading.Thread(target=self._streamer, daemon=True).start()

    def _get_icon(self, key: str) -> str:
        style = self.get_setting("icon_style", 1)
        nso = {
            "star": "[üåü](5398096269786764342)",
            "game": "[üéÆ](5265139050263626266)",
            "dev": "[üì±](5363920828465431862)",
            "pub": "[‚ù§Ô∏è](5366551886776253280)",
            "meta": "[üíò](5364175348227395877)",
            "genre": "[üìù](5267392860122006833)",
            "time": "[‚è∞](5267166897597599285)",
            "link": "[üéÆ](5265139050263626266)",
        }
        std = {
            "star": "[üåü](5242483467144416949)",
            "game": "[üéÆ](5467583879948803288)",
            "dev": "[üë®‚Äçüíª](5190498849440931467)",
            "pub": "[üè¢](5264733042710181045)",
            "meta": "[‚≠ê](5438496463044752972)",
            "genre": "[üè∑](5278305362703835500)",
            "time": "[‚è±](5382194935057372936)",
            "link": "[üì±](5373144051690258848)",
        }
        icons = nso if style == 1 else std
        return icons.get(key, "")

    def _with_icon(self, text: str, icon: str) -> str:
        try:
            if "|" in text:
                return f"{icon} | {text.split('|', 1)[1].strip()}"
            return f"{icon} | {text}"
        except Exception:
            return text

    def _streamer(self):
        log("[Steam] Streamer started")
        while not self._stop_streamer:
            try:
                if self.get_setting("update_bio", False):
                    log("[Steam] Update bio is enabled")
                    userFull = get_messages_controller().getUserFull(get_user_config().getClientUserId())
                    if not userFull:
                        log("[Steam] Failed to get userFull")
                        time.sleep(5)
                        continue

                    stream_place = self.get_setting("stream_place", 1 if get_user_config().isPremium() else 0)
                    max_len = 140 if get_user_config().isPremium() else 70

                    steam_id = self.get_setting("steam_id", "")
                    api_key = self.get_setting("api_key", "")

                    if not steam_id:
                        log("[Steam] Steam ID is not set")
                        time.sleep(5)
                        continue

                    log(f"[Steam] Fetching game for user {steam_id}")
                    result, _, _, _, _ = self.get_game(steam_id, api_key)
                    log(f"[Steam] Got result from get_game: {result}")

                    if result != self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        log(f"[Steam] Found game: {result}")
                        new_about_text = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                        log(f"[Steam] Original format: {new_about_text}")
                        if isinstance(result, dict):
                            log(f"[Steam] Result is a dict, using name: {result['name']}")
                            new_about_text = new_about_text.replace("{game}", str(result['name']))
                        else:
                            log(f"[Steam] Result is a string: {result}")
                            new_about_text = new_about_text.replace("{game}", str(result))
                        log(f"[Steam] Final about text: {new_about_text}")

                        if stream_place == 0:
                            if userFull.about != new_about_text[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = new_about_text[:max_len]
                                    send_request(req, ())
                                    log("[Steam] Successfully updated bio")
                                except Exception as e:
                                    log(f"[Steam] Error updating bio: {e}")
                                    time.sleep(5)
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = new_about_text[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[Steam] Successfully updated business location")
                            except Exception as e:
                                log(f"[Steam] Error updating business location: {e}")
                                time.sleep(5)
                    else:
                        log("[Steam] No game found")
                        default_bio = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
                        if stream_place == 0:
                            if userFull.about != default_bio[:max_len]:
                                try:
                                    req = TL_account.updateProfile()
                                    req.flags = 4
                                    req.about = default_bio[:max_len]
                                    send_request(req, ())
                                    log("[Steam] Set default bio")
                                except Exception as e:
                                    log(f"[Steam] Error setting default bio: {e}")
                                    time.sleep(5)
                        else:
                            if not get_user_config().isPremium():
                                log("[Steam] User is not premium, can't update business location")
                                time.sleep(5)
                                continue
                            try:
                                req = TL_account.updateBusinessLocation()
                                req.address = default_bio[:96]
                                req.flags = 1
                                send_request(req, ())
                                log("[Steam] Set default bio in business location")
                            except Exception as e:
                                log(f"[Steam] Error setting default bio in business location: {e}")
                                time.sleep(5)

                    check_interval = self.get_setting("check_interval", DEFAULT_CHECK_INTERVAL)
                    time.sleep(check_interval)
            except Exception as e:
                log(f"[Steam] Streamer error: {e}")
                time.sleep(10)

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if self._temp_dir:
            threading.Thread(target=self._download_fonts, daemon=True).start()
            log("Steam plugin loaded successfully")
        else:
            log("Failed to initialize temp directory for Steam")

    def _download_fonts(self):
        try:
            for font_name, font_url in FONTS.items():
                font_path = File(self._temp_dir, f"{font_name}-Regular.ttf").getAbsolutePath()
                if not os.path.exists(font_path):
                    response = requests.get(font_url)
                    with open(font_path, 'wb') as f:
                        f.write(response.content)
                    log(f"Downloaded font: {font_name}")
        except Exception as e:
            log(f"Error downloading fonts: {e}")

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            if not base_dir:
                return None
            temp_dir = File(base_dir, TEMP_DIR_NAME)
            if not temp_dir.exists() and not temp_dir.mkdirs():
                return None
            return temp_dir
        except Exception as e:
            log(f"Error getting temp directory: {e}")
            return None

    def download_game_image(self, image_url):
        if not image_url:
            return None
        temp_dir = self._get_temp_dir()
        if not temp_dir or not temp_dir.isDirectory():
            return None

        filename = f"game_{uuid.uuid4()}.jpg"
        temp_photo_path = File(temp_dir, filename).getAbsolutePath()

        try:
            head = requests.head(image_url, timeout=5)
            content_length = int(head.headers.get('content-length', 0))
            if content_length > 10 * 1024 * 1024:
                return None

            resp = requests.get(image_url, stream=True, timeout=10)
            resp.raise_for_status()

            with open(temp_photo_path, 'wb') as f:
                for chunk in resp.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return temp_photo_path
        except Exception as e:
            try:
                if os.path.exists(temp_photo_path):
                    os.remove(temp_photo_path)
            except Exception:
                pass
            return None

    def delete_temp_file_async(self, file_path, delay_seconds=5):
        def _delete():
            try:
                time.sleep(delay_seconds)
                if os.path.exists(file_path):
                    os.remove(file_path)
            except Exception as e:
                pass
        threading.Thread(target=_delete, daemon=True).start()

    def _handle_show_faq_alert_click(self, view):
        title = localise("font_faq_title")
        text = localise("font_faq_text")
        close_button = localise("alert_close_button")
        self.alert_manager.show_info_alert(title, text, close_button)

    def create_settings(self):
        lang = Locale.getDefault().getLanguage()
        update_bio = self.get_setting("update_bio", False)
        font_items = ["Noto Sans JP", "Zpix", "Impact", "–ö–∞—Å—Ç–æ–º–Ω—ã–π —à—Ä–∏—Ñ—Ç" if lang.startswith('ru') else "Custom font"]

        settings = [
            Header(text=localise("settings_main_header")),
            Input(
                key="steam_id",
                text=localise("settings_steam_id"),
                subtext=localise("settings_steam_id_subtext"),
                default="",
                icon="filled_username"
            ),
            Input(
                key="api_key",
                text=localise("settings_api_key"),
                subtext=localise("settings_api_key_subtext"),
                default="",
                icon="msg_secret"
            ),
            Selector(
                key="icon_style",
                text=localise("settings_icon_style"),
                default=1,
                items=localise("settings_icon_style_items"),
                icon="msg_emoji_smiles"
            ),
            Divider(),
            Header(text=localise("card_settings_header")),
            Input(
                key="card_text_format",
                text=localise("card_text_format"),
                subtext=localise("card_text_format_subtext"),
                default=("{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}" if lang.startswith('ru') else "{nick} plays {game}"),
                icon="msg_view_file"
            ),
            Selector(
                key="card_font_family",
                text=localise("card_font_family"),
                default=0,
                items=font_items,
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_path",
                text=localise("custom_font_link"),
                subtext=localise("custom_font_link_subtext"),
                default="",
                icon="msg_link"
            ),
            Text(
                text=localise("custom_font_help_title"),
                icon="msg_info",
                on_click=self._handle_show_faq_alert_click
            ),
            Switch(
                key="show_card_authors",
                text=localise("settings_show_card_authors"),
                default=True,
                subtext=localise("settings_show_card_authors_subtext"),
                icon="msg_info"
            ),
            Divider(),
            Header(text=localise("settings_auto_update_header")),
            Switch(
                key="update_bio",
                text=localise("settings_enable_auto"),
                default=False,
                subtext=localise("settings_enable_auto_subtext"),
                on_change=lambda new_value: self._show_stream_alert(new_value),
                icon="ic_ab_search"
            ),
            Input(
                key="check_interval",
                text=localise("settings_check_interval"),
                subtext=localise("settings_check_interval_subtext"),
                default=str(DEFAULT_CHECK_INTERVAL),
                icon="input_schedule"
            ) if update_bio else None,
            Selector(
                key="stream_place",
                text=localise("settings_update_location"),
                default=1 if get_user_config().isPremium() else 0,
                items=localise("settings_update_location_items"),
                icon="menu_premium_location" if get_user_config().isPremium() else "msg_openprofile"
            ) if update_bio and get_user_config().isPremium() else None,
            Input(
                key="track_display_format",
                text=localise("settings_text_template"),
                default=DEFAULT_STREAM_STRING,
                subtext=localise("settings_text_template_subtext"),
                icon="input_forward"
            ) if update_bio else None,
            Input(
                key="default_stream_text",
                text=localise("settings_default_text"),
                default=DEFAULT_STREAM_TEXT,
                subtext=localise("settings_default_text_subtext"),
                icon="input_reply"
            ) if update_bio else None,
            Divider(),
            Header(text=localise("library_settings_header")),
            Switch(
                key="sort_by_playtime",
                text=localise("settings_sort_by_playtime"),
                default=True,
                subtext=localise("settings_sort_by_playtime_subtext"),
                icon="filled_info"
            ),
        ]
        return [s for s in settings if s is not None]

    def _show_stream_alert(self, value):
        if value:
            title = localise("stream_alert_title")
            message = localise("stream_alert_message")
            fragment = get_last_fragment()
            ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
            dialog = AlertDialog(ctx, 3)
            dialog.setTitle(title)
            dialog.setMessage(message)
            dialog.setButton("OK", None)
            dialog.show()

    def get_game(self, id_steam, api_key):
        if not api_key:
            BulletinHelper.show_error(localise("error_api_key_not_set"))
            return localise("error_api_key_missing"), None, None, None, None

        if not id_steam or not id_steam.strip():
            BulletinHelper.show_error(localise("error_steam_id_not_set"))
            return localise("error_invalid_steam_id"), None, None, None, None

        if not id_steam.isdigit():
            BulletinHelper.show_error(localise("error_invalid_steam_id"))
            return localise("error_invalid_steam_id"), None, None, None, None

        link = 'http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002'
        params = {
            'key': api_key,
            'steamids': id_steam,
            'format': 'json'
        }
        max_retries = 3
        retry_delay = 2

        for attempt in range(max_retries):
            try:
                log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –∫ Steam API (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries})...")
                r = requests.get(link, params=params, timeout=20)

                if r.status_code == 403:
                    BulletinHelper.show_error(localise("error_invalid_api_key"))
                    return localise("error_invalid_api_key"), None, None, None, None

                r.raise_for_status()
                da = json.loads(r.text)
                log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç Steam API: {da}")

                if not da['response']['players']:
                    log("[SteamPlugin] Steam ID –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return localise("error_steam_id_not_found"), None, None, None, None

                player = da['response']['players'][0]
                nickname = player.get('personaname', 'Unknown')
                log(f"[SteamPlugin] –î–∞–Ω–Ω—ã–µ –∏–≥—Ä–æ–∫–∞: {player}")

                if 'gameextrainfo' not in player:
                    log("[SteamPlugin] –ò–≥—Ä–æ–∫ –Ω–µ –≤ –∏–≥—Ä–µ")
                    return self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT), None, None, None, nickname

                game_name = player['gameextrainfo']
                game_id = player.get('gameid')
                log(f"[SteamPlugin] –ù–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã: {game_name}, ID –∏–≥—Ä—ã: {game_id}")

                if not game_id:
                    log("[SteamPlugin] ID –∏–≥—Ä—ã –Ω–µ –Ω–∞–π–¥–µ–Ω")
                    return game_name, None, None, None, nickname

                game_store_url = f"https://store.steampowered.com/app/{game_id}/"

                stats_link = f'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
                stats_params = {
                    'key': api_key,
                    'steamid': id_steam,
                    'include_appinfo': 1,
                    'include_played_free_games': 1,
                    'format': 'json'
                }
                try:
                    log("[SteamPlugin] –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä—ã...")
                    stats_r = requests.get(stats_link, params=stats_params, timeout=10)
                    stats_r.raise_for_status()
                    stats_data = json.loads(stats_r.text)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats_data}")

                    playtime = 0
                    if 'response' in stats_data and 'games' in stats_data['response']:
                        for game in stats_data['response']['games']:
                            if str(game.get('appid')) == str(game_id):
                                playtime = game.get('playtime_forever', 0)
                                log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –≤—Ä–µ–º—è –∏–≥—Ä—ã: {playtime} –º–∏–Ω—É—Ç")
                                break
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã: {e}")
                    playtime = 0

                game_link = 'http://store.steampowered.com/api/appdetails'
                game_params = {
                    'appids': game_id,
                    'l': 'russian',
                    'format': 'json'
                }
                try:
                    log("[SteamPlugin] –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã...")
                    game_r = requests.get(game_link, params=game_params, timeout=10)
                    game_r.raise_for_status()
                    game_data = json.loads(game_r.text)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω—ã –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã: {game_data}")

                    if str(game_id) in game_data and game_data[str(game_id)]['success']:
                        game_info = game_data[str(game_id)]['data']
                        log(f"[SteamPlugin] –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∏–≥—Ä–µ: {game_info}")

                        image_url = None
                        if 'header_image' in game_info:
                            image_url = game_info['header_image']
                        elif 'background' in game_info:
                            image_url = game_info['background']
                        elif 'screenshots' in game_info and game_info['screenshots']:
                            image_url = game_info['screenshots'][0]['path_full']

                        metacritic_score = 'N/A'
                        if 'metacritic' in game_info and isinstance(game_info['metacritic'], dict):
                            metacritic_score = game_info['metacritic'].get('score', 'N/A')

                        game_details = {
                            'name': game_name,
                            'developers': game_info.get('developers', []),
                            'publishers': game_info.get('publishers', []),
                            'metacritic': metacritic_score,
                            'genres': [g['description'] for g in game_info.get('genres', [])],
                            'categories': [c['description'] for c in game_info.get('categories', [])],
                            'release_date': game_info.get('release_date', {}).get('date', 'N/A'),
                            'short_description': game_info.get('short_description', ''),
                            'playtime': playtime,
                            'store_url': game_store_url
                        }

                        log(f"[SteamPlugin] –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω—ã –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã: {game_details}")
                        return game_details, image_url, playtime, game_store_url, nickname

                    log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∏–≥—Ä—ã")
                    return game_name, None, playtime, game_store_url, nickname

                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–≥—Ä–µ: {e}")
                    return game_name, None, playtime, game_store_url, nickname

            except requests.exceptions.RequestException as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_retries}): {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return localise("error_network"), None, None, None, None
            except json.JSONDecodeError as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ JSON: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return localise("error_api"), None, None, None, None
            except Exception as e:
                log(f"[SteamPlugin] –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
                if attempt < max_retries - 1:
                    time.sleep(retry_delay)
                    continue
                return localise("error_unknown", e=str(e)), None, None, None, None

    def _dismiss_dialog(self):
        global progress_dialog
        try:
            if progress_dialog is not None and progress_dialog.isShowing():
                progress_dialog.dismiss()
        except Exception:
            pass
        finally:
            progress_dialog = None

    def get_steam_library(self, steam_id, api_key):
        log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –¥–ª—è Steam ID: {steam_id}")

        if not steam_id or not steam_id.strip() or not steam_id.isdigit():
            error_msg = localise("error_invalid_steam_id")
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

        if not api_key or not api_key.strip():
            error_msg = localise("error_api_key_missing")
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

        url = 'http://api.steampowered.com/IPlayerService/GetOwnedGames/v0001/'
        params = {
            'key': api_key,
            'steamid': steam_id,
            'include_appinfo': 1,
            'include_played_free_games': 1,
            'format': 'json'
        }

        try:
            log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ Steam API: {url}")
            response = requests.get(url, params=params, timeout=20)
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç. –°—Ç–∞—Ç—É—Å: {response.status_code}")

            if response.status_code != 200:
                error_msg = f"{localise('error_api_code', code=response.status_code)} - {response.text}"
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            data = response.json()
            log(f"[SteamPlugin] –û—Ç–≤–µ—Ç API: {json.dumps(data, ensure_ascii=False)[:500]}...")

            if 'response' not in data:
                error_msg = localise("error_invalid_response")
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            if 'games' not in data['response']:
                error_msg = localise("error_private_profile")
                log(f"[SteamPlugin] {error_msg}")
                return None, error_msg

            games = data['response'].get('games', [])
            log(f"[SteamPlugin] –ù–∞–π–¥–µ–Ω–æ –∏–≥—Ä: {len(games)}")

            if not games:
                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                return [], localise("library_empty")

            sorted_games = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
            log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ –∏ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {len(sorted_games)} –∏–≥—Ä")
            return sorted_games, None

        except requests.exceptions.RequestException as e:
            error_msg = localise("error_network_generic", e=str(e))
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except json.JSONDecodeError as e:
            error_msg = localise("error_json_parse", e=str(e))
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg
        except Exception as e:
            import traceback
            error_msg = localise("error_unknown_generic", e=str(e)) + f"\n{traceback.format_exc()}"
            log(f"[SteamPlugin] {error_msg}")
            return None, error_msg

    def on_callback_query_hook(self, account, params):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ inline-–∫–Ω–æ–ø–∫–∏"""
        try:
            if not hasattr(params, 'data'):
                return HookResult()

            data = params.data
            log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω callback: {data}")

            if data.startswith('sort_'):
                sort_type, steam_id = data.split('_', 1)[1].split('_', 1)

                api_key = self.get_setting("api_key", "").strip()

                try:
                    get_messages_controller().callCallbackQuery(params.query_id, "")
                except:
                    pass

                self.send_sorted_library(params.peer, steam_id, api_key, sort_type)

                try:
                    get_messages_controller().editMessageReplyMarkup(params.peer, params.msg_id, None)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–æ–∫: {str(e)}")

                return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ on_callback_query_hook: {str(e)}")
            import traceback
            log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")

        return HookResult()

    def send_sorted_library(self, peer, steam_id, api_key, sort_type='hours', full_list=False):

        def _send():
            try:
                log(f"[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ —Å —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–æ–π: {sort_type}, full_list={full_list}")
                games, error = self.get_steam_library(steam_id, api_key)

                if error:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                    send_message({"peer": peer, "message": error})
                    return

                if not games:
                    log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                    send_message({"peer": peer, "message": localise("library_empty")})
                    return

                if sort_type == 'hours':
                    games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)
                    sort_text = localise("sort_by_hours_text")
                else:
                    games_sorted = sorted(games,
                        key=lambda x: x.get('rtime_last_played', x.get('last_played', 0)),
                        reverse=True)
                    sort_text = localise("sort_by_last_played_text")

                games_list = []
                total_games = len(games_sorted)
                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60

                max_games = 30
                games_to_show = games_sorted[:max_games]

                for i, game in enumerate(games_to_show, 1):
                    try:
                        name = game.get('name', 'Unknown game')
                        playtime = game.get('playtime_forever', 0)
                        hours = playtime // 60
                        minutes = playtime % 60

                        last_played = ""
                        if sort_type == 'last_played' and 'rtime_last_played' in game:
                            from datetime import datetime
                            last_played_ts = game['rtime_last_played']
                            if last_played_ts > 0:
                                last_played_date = datetime.fromtimestamp(last_played_ts).strftime('%d.%m.%Y')
                                last_played = localise("last_played_suffix", date=last_played_date)

                        if hours > 0:
                            playtime_str = localise("duration_compact_hm", hours=hours, minutes=minutes) + last_played
                        else:
                            playtime_str = localise("duration_compact_m", minutes=minutes) + last_played

                        games_list.append(f"{i}. {name} - {playtime_str}")
                    except Exception as game_err:
                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")

                if total_games > max_games:
                    games_list.append("\n" + localise("and_more_games", count=total_games - max_games))

                if full_list:
                    message = f"üéÆ *{localise('full_library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"

                    games_by_letter = {}
                    for game in games_sorted:
                        name = game.get('name', 'Unknown game')
                        first_letter = name[0].upper() if name and name[0].isalpha() else '#'
                        if first_letter not in games_by_letter:
                            games_by_letter[first_letter] = []
                        games_by_letter[first_letter].append(name)

                    sorted_letters = sorted(games_by_letter.keys())

                    for letter in sorted_letters:
                        games_str = ', '.join(games_by_letter[letter])
                        message += f"\n*{letter}*: {games_str}\n"

                    message += f"\nüìä *{localise('sorting_label')}* {sort_text}"
                else:
                    sort_buttons = [
                        [{"text": localise("btn_sort_by_hours"), "callback_data": f"sort_hours_{steam_id}"}],
                        [{"text": localise("btn_sort_by_last_played"), "callback_data": f"sort_last_played_{steam_id}"}]
                    ]

                    message = f"üéÆ *{localise('library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"
                    message += "\n".join(games_list)
                    message += f"\n\nüìä *{localise('sorting_label')}* {sort_text}"

                log(f"[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º {'–ø–æ–ª–Ω—ã–π' if full_list else '–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π'} —Å–ø–∏—Å–æ–∫ –∏–≥—Ä")
                parsed = parse_markdown(message)

                entities = [entity.to_tlrpc_object() for entity in parsed.entities]
                try:
                    blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                    blockquote_entity.collapsed = True
                    blockquote_entity.offset = 0
                    try:
                        blockquote_entity.length = len(parsed.text.encode('utf-16le')) // 2
                    except Exception:
                        blockquote_entity.length = len(parsed.text)
                    entities.append(blockquote_entity)
                except Exception as e:
                    log(f"[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Å–≤—ë—Ä–Ω—É—Ç—É—é —Ü–∏—Ç–∞—Ç—É: {e}")

                message_data = {
                    "peer": peer,
                    "message": parsed.text,
                    "entities": entities
                }

                if not full_list and 'sort_buttons' in locals():
                    message_data["reply_markup"] = {"inline_keyboard": sort_buttons}

                send_message(message_data)

            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {str(e)}")
                import traceback
                log(f"[SteamPlugin] –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")
                try:
                    send_message({
                        "peer": peer,
                        "message": localise("failed_to_load_library")
                    })
                except:
                    pass

        threading.Thread(target=_send, daemon=True).start()

    def on_send_message_hook(self, account, params):
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        message = params.message.strip()

        if message in (".slibrary", ".sflibrary"):
            is_full_library = message == ".sflibrary"
            command_name = ".sflibrary" if is_full_library else ".slibrary"

            try:
                log(f"[SteamPlugin] –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã {command_name}")
                steam_id = self.get_setting("steam_id", "").strip()
                api_key = self.get_setting("api_key", "").strip()

                if not steam_id:
                    params.message = localise("error_steam_id_not_set")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                if not api_key:
                    params.message = localise("error_api_key_not_set")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    log("[SteamPlugin] –ü–æ–∫–∞–∑–∞–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ")
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫–∞–∑–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {str(e)}")

                def send_library_message(peer):
                    try:
                        log("[SteamPlugin] –ó–∞–≥—Ä—É–∑–∫–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏...")
                        games, error = self.get_steam_library(steam_id, api_key)

                        if error:
                            log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏: {error}")
                            message = error
                        else:
                            if not games:
                                log("[SteamPlugin] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∏–≥—Ä –ø—É—Å—Ç–∞")
                                message = localise("library_empty")
                            else:
                                log(f"[SteamPlugin] –£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–æ {len(games)} –∏–≥—Ä")
                                games_sorted = sorted(games, key=lambda x: x.get('playtime_forever', 0), reverse=True)

                                games_list = []
                                total_games = len(games_sorted)
                                total_playtime = sum(game.get('playtime_forever', 0) for game in games_sorted) // 60

                                max_games = 30
                                games_to_show = games_sorted[:max_games]

                                for i, game in enumerate(games_to_show, 1):
                                    try:
                                        name = game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∏–≥—Ä–∞')
                                        playtime = game.get('playtime_forever', 0)
                                        hours = playtime // 60
                                        minutes = playtime % 60
                                        if hours > 0:
                                            playtime_str = f"{hours}—á {minutes}–º"
                                        else:
                                            playtime_str = f"{minutes}–º"
                                        games_list.append(f"{i}. {name} - {playtime_str}")
                                    except Exception as game_err:
                                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–≥—Ä—ã {i}: {str(game_err)}")

                                if total_games > max_games:
                                    games_list.append("\n" + localise("and_more_games", count=total_games - max_games))

                                sort_buttons = [
                                    [{"text": localise("btn_sort_by_hours"), "callback_data": f"sort_hours_{steam_id}"}],
                                    [{"text": localise("btn_sort_by_last_played"), "callback_data": f"sort_last_played_{steam_id}"}]
                                ]

                                message = f"üéÆ *{localise('library_header')}*\n" + localise('total_games_and_time', count=total_games, hours=total_playtime) + "\n\n"
                                message += "\n".join(games_list)
                                message += f"\n\nüìä *{localise('sorting_label')}* {localise('sort_by_hours_text')}"
                                log("[SteamPlugin] –°–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–æ")

                        log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π –∏ –∫–Ω–æ–ø–∫–∞–º–∏")
                        parsed = parse_markdown(message)
                        entities = [entity.to_tlrpc_object() for entity in parsed.entities]
                        try:
                            blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                            blockquote_entity.collapsed = True
                            blockquote_entity.offset = 0
                            try:
                                blockquote_entity.length = len(parsed.text.encode('utf-16le')) // 2
                            except Exception:
                                blockquote_entity.length = len(parsed.text)
                            entities.append(blockquote_entity)
                        except Exception as e:
                            log(f"[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–±–∞–≤–∏—Ç—å —Å–≤—ë—Ä–Ω—É—Ç—É—é —Ü–∏—Ç–∞—Ç—É: {e}")

                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": entities,
                            "reply_markup": {
                                "inline_keyboard": sort_buttons
                            }
                        })

                    except Exception as e:
                        import traceback
                        error_msg = f"{localise('error_unknown_generic', e=str(e))}\n\n{traceback.format_exc()}"
                        log(f"[SteamPlugin] {error_msg}")
                        try:
                            send_message({
                                "peer": peer,
                                "message": localise("failed_to_load_library")
                            })
                        except:
                            pass

                try:
                    BulletinHelper.show_info(localise("loading_library"))
                    sort_type = 'hours' if self.get_setting("sort_by_playtime", True) else 'last_played'
                    self.send_sorted_library(params.peer, steam_id, api_key, sort_type, is_full_library)
                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –ø–æ—Ç–æ–∫–∞: {str(e)}")
                    params.message = localise("failed_to_load_library")
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)

                return HookResult(strategy=HookStrategy.CANCEL)

            except Exception as e:
                import traceback
                error_msg = f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}\n\n{traceback.format_exc()}"
                log(f"[SteamPlugin] {error_msg}")
                params.message = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏."
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        if not (message.lower().startswith(".nowsteam") or message.lower().startswith(".snp")):
            return HookResult()

        try:
            steam_id = self.get_setting("steam_id", "")
            api_key = self.get_setting("api_key", "")

            log(f"[SteamPlugin] –ö–æ–º–∞–Ω–¥–∞ .nowsteam –ø–æ–ª—É—á–µ–Ω–∞. Steam ID: {steam_id}, API Key: {'*' * 8 + api_key[-4:] if api_key else '–ù–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'}")

            if not steam_id:
                BulletinHelper.show_error(localise("error_steam_id_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            if not api_key:
                BulletinHelper.show_error(localise("error_api_key_not_set"))
                return HookResult(strategy=HookStrategy.CANCEL)

            def search_and_reply(peer):
                try:
                    log("[SteamPlugin] –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –∏–≥—Ä–µ...")
                    result, image_url, playtime, game_url, nickname = self.get_game(steam_id, api_key)
                    log(f"[SteamPlugin] –ü–æ–ª—É—á–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result}, nickname: {nickname}")
                    
                    if isinstance(result, str) and result.startswith('‚ùå –û—à–∏–±–∫–∞'):
                        BulletinHelper.show_error(result)
                        return

                    if result == self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT):
                        log("[SteamPlugin] –ò–≥—Ä–æ–∫ –Ω–µ –≤ –∏–≥—Ä–µ")
                        text_np = self._with_icon(str(result), self._get_icon("star"))
                        parsed = parse_markdown(text_np)
                        send_message({
                            "peer": peer,
                            "message": parsed.text,
                            "entities": [entity.to_tlrpc_object() for entity in parsed.entities]
                        })
                        return
                    
                   
                    playtime_text = ""
                    if isinstance(result, dict) and 'playtime' in result:
                        hours = result['playtime'] // 60
                        minutes = result['playtime'] % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)
                    elif playtime is not None:
                        hours = playtime // 60
                        minutes = playtime % 60
                        if hours > 0:
                            playtime_text = localise("playtime", hours=hours, minutes=minutes)
                        else:
                            playtime_text = localise("playtime_minutes", minutes=minutes)
                    
                    caption_message = ""
                    if isinstance(result, dict):
                        caption_lines = []
                        caption_lines.append(self._with_icon(localise("playing_format", game=result['name']), self._get_icon('game')))
                        if result.get('developers'):
                            caption_lines.append(self._with_icon(localise("developers", developers=', '.join(result['developers'])), self._get_icon('dev')))
                        if result.get('publishers') and result['publishers'] != result.get('developers', []):
                            caption_lines.append(self._with_icon(localise("publishers", publishers=', '.join(result['publishers'])), self._get_icon('pub')))
                        caption_lines.append(self._with_icon(localise("metacritic", score=result.get('metacritic', 'N/A')), self._get_icon('meta')))
                        if result.get('genres'):
                            caption_lines.append(self._with_icon(localise("genres", genres=', '.join(result['genres'][:3])), self._get_icon('genre')))
                        if isinstance(result, dict) and 'playtime' in result:
                            hours = result['playtime'] // 60
                            minutes = result['playtime'] % 60
                            if hours > 0:
                                pt = localise("playtime", hours=hours, minutes=minutes)
                            else:
                                pt = localise("playtime_minutes", minutes=minutes)
                            caption_lines.append(self._with_icon(pt, self._get_icon('time')))
                        if result.get('store_url'):
                            caption_lines.append("\n" + self._with_icon(localise("game_link", url=result['store_url']), self._get_icon('link')))
                        caption_message = "\n".join(caption_lines)
                    else:
                        line_playing = self._with_icon(localise("playing_format", game=result), self._get_icon('game'))
                        if playtime is not None:
                            hours = playtime // 60
                            minutes = playtime % 60
                            if hours > 0:
                                pt = localise("playtime", hours=hours, minutes=minutes)
                            else:
                                pt = localise("playtime_minutes", minutes=minutes)
                            line_time = self._with_icon(pt, self._get_icon('time'))
                            caption_message = f"{line_playing}\n{line_time}"
                        else:
                            caption_message = line_playing
                        if game_url:
                            caption_message += "\n\n" + self._with_icon(localise("game_link", url=game_url), self._get_icon('link'))

                    try:
                        temp_photo_path = self._make_card(result, nickname, image_url)
                        helper = get_send_messages_helper()
                        if temp_photo_path:
                            generated_photo = helper.generatePhotoSizes(temp_photo_path, None)
                            if generated_photo is not None:
                                log("[SteamPlugin] –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–∞—Ä—Ç–æ—á–∫–æ–π –∏ –ø–æ–¥–ø–∏—Å—å—é")
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": temp_photo_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(temp_photo_path)
                                return
                            else:
                                log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ (card)")
                                self.delete_temp_file_async(temp_photo_path)
                        log("[SteamPlugin] –ü–µ—Ä–µ—Ö–æ–¥–∏–º –Ω–∞ fallback-—Ñ–æ—Ç–æ –±–µ–∑ –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                        fallback_path = self.download_game_image(NO_STEAM_FALLBACK_URL)
                        if fallback_path:
                            generated_photo = helper.generatePhotoSizes(fallback_path, None)
                            if generated_photo is not None:
                                parsed_caption = parse_markdown(caption_message.strip())
                                send_message({
                                    "peer": peer,
                                    "photo": generated_photo,
                                    "path": fallback_path,
                                    "caption": parsed_caption.text,
                                    "entities": [entity.to_tlrpc_object() for entity in parsed_caption.entities],
                                    "message": None
                                })
                                self.delete_temp_file_async(fallback_path)
                                return
                            else:
                                log("[SteamPlugin] –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ñ–æ—Ç–æ (fallback)")
                                self.delete_temp_file_async(fallback_path)
                        BulletinHelper.show_error(localise("error_unknown_generic", e="card generation failed"))
                    except Exception as e:
                        log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∫–∞—Ä—Ç–æ—á–∫–∏: {e}")
                        BulletinHelper.show_error(localise("error_unknown", e=str(e)))

                except Exception as e:
                    log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –≤ –ø–æ—Ç–æ–∫–µ –ø–æ–∏—Å–∫–∞: {e}")
                    BulletinHelper.show_error(localise("error_unknown", e=str(e)))

            try:
                BulletinHelper.show_info(localise("searching"))
            except Exception as e:
                log(f"[SteamPlugin] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–∏–∞–ª–æ–≥–∞: {e}")

            threading.Thread(target=lambda: search_and_reply(params.peer), daemon=True).start()
            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            params.message = localise("error_unknown", e=str(e))
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

    def _make_card(self, game_info, nickname, image_url):
        log(f"[SteamPlugin] Starting _make_card with game_info: {game_info}, nickname: {nickname}")
        width, height = 1280, 720
        background_color = "#000000"
        text_color = "#FFFFFF"

        log(f"[SteamPlugin] Creating card with dimensions: {width}x{height}")

        if not image_url or not image_url.strip():
            log(f"[SteamPlugin] No image_url provided ‚Äî cancel card generation to trigger raw fallback")
            return None

        original_image = None
        try:
            log(f"[SteamPlugin] Downloading original image from: {image_url}")
            response = requests.get(image_url, timeout=10)
            response.raise_for_status()
            original_image = Image.open(io.BytesIO(response.content)).convert("RGBA")
        except Exception as e:
            log(f"[SteamPlugin] Error downloading cover image: {e}")
            return None

        full_background = Image.new('RGB', (width, height), background_color)
        if original_image:
            try:
                blurred_background = original_image.resize((width, height))
                blurred_background = blurred_background.filter(ImageFilter.GaussianBlur(30))
                overlay = Image.new("RGBA", (width, height), (0, 0, 0, 150))
                full_background = Image.alpha_composite(blurred_background, overlay).convert("RGB")
                log(f"[SteamPlugin] Full blurred background created")
            except Exception as e:
                log(f"[SteamPlugin] Error processing background cover: {e}")

        card = full_background
        draw = ImageDraw.Draw(card)

        if original_image:
            try:
                log(f"[SteamPlugin] Original image size: {original_image.size}, mode: {original_image.mode}")
                

                target_width = 1023 
                target_height = int(target_width / 2.14)
                
                thumbnail = original_image.copy()
                if thumbnail.mode != 'RGBA':
                    thumbnail = thumbnail.convert('RGBA')

                thumbnail = thumbnail.resize((target_width, target_height), Image.Resampling.LANCZOS)
                log(f"[SteamPlugin] Resized to {target_width}x{target_height}, mode: {thumbnail.mode}")
                
                paste_x = (width - target_width) // 2
                paste_y = 50
                
                if thumbnail.mode == 'RGBA':
                    card.paste(thumbnail, (paste_x, paste_y), thumbnail)
                else:
                    card.paste(thumbnail, (paste_x, paste_y))
                    
                log(f"[SteamPlugin] Image pasted at position ({paste_x}, {paste_y})")
                

                text_start_y = paste_y + target_height + 20
            except Exception as e:
                log(f"[SteamPlugin] Error processing album cover thumbnail: {e}")

                return None

        game_name = game_info.get('name', 'Unknown Game') if isinstance(game_info, dict) else game_info

        font_index = self.get_setting("card_font_family", 0)
        main_font, footer_font = None, None

        if font_index == 3:
            custom_font_url = self.get_setting("custom_font_path", "").strip()
            if custom_font_url and custom_font_url.startswith(('http://', 'https://')):
                try:
                    custom_font_file = File(self._temp_dir, "custom_font.ttf").getAbsolutePath()
                    if not os.path.exists(custom_font_file):
                        response = requests.get(custom_font_url)
                        with open(custom_font_file, 'wb') as f:
                            f.write(response.content)
                    main_font = ImageFont.truetype(custom_font_file, 45)
                    footer_font = ImageFont.truetype(custom_font_file, 25)
                    try:
                        setattr(main_font, "_path", custom_font_file)
                    except Exception:
                        pass
                except Exception as e:
                    log(f"[SteamPlugin] Failed to load custom font: {e}, falling back.")
                    font_index = 0

        if not main_font:
            font_key = list(FONTS.keys())[font_index]
            font_file_name = f"{font_key}-Regular.ttf"
            try:
                font_path = File(self._temp_dir, font_file_name).getAbsolutePath()
                main_font = ImageFont.truetype(font_path, 45)
                footer_font = ImageFont.truetype(font_path, 25)
                try:
                    setattr(main_font, "_path", font_path)
                except Exception:
                    pass
            except Exception as e:
                log(f"Error loading font, using default: {e}")
                main_font = ImageFont.load_default()
                footer_font = ImageFont.load_default()

        card_text_format = self.get_setting("card_text_format", "{nick} –∏–≥—Ä–∞–µ—Ç –≤ {game}")
        main_text = card_text_format.replace("{nick}", nickname).replace("{game}", game_name)
        footer_text = "Plugin by @KangelPlugins & @MGEPlugins" if self.get_setting("show_card_authors", True) else None
        
        def wrap_lines(text, font, max_width):
            words = text.split()
            lines = []
            current = ""
            for w in words:
                test = (current + (" " if current else "") + w).strip()
                wlen = draw.textlength(test, font=font)
                if wlen <= max_width:
                    current = test
                else:
                    if current:
                        lines.append(current)
                        current = w
                    else:

                        lines.append(w)
                        current = ""
            if current:
                lines.append(current)
            return lines

        def fit_and_draw_centered(start_y, text, base_font, fill, max_width, max_lines=3, min_size=20):
            size = base_font.size if hasattr(base_font, 'size') else 45
            font_path = getattr(base_font, '_path', None)

            def with_size(sz):
                try:
                    if font_path:
                        return ImageFont.truetype(font_path, sz)
                except Exception:
                    pass
                return base_font

            while size >= min_size:
                font_try = with_size(size)
                lines = wrap_lines(text, font_try, max_width)
                if len(lines) <= max_lines:
                    y = start_y
                    line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
                    spacing = 6 
                    total_h = len(lines) * line_height + (len(lines)-1) * spacing
                    y = start_y
                    for line in lines:
                        bbox = draw.textbbox((0, 0), line, font=font_try)
                        tw = bbox[2] - bbox[0]
                        draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                        y += line_height + spacing
                    return True
                size -= 2

            font_try = with_size(min_size)
            lines = wrap_lines(text, font_try, max_width)
            y = start_y
            line_height = font_try.getbbox("Ay")[3] - font_try.getbbox("Ay")[1]
            spacing = 6
            for i, line in enumerate(lines[:max_lines]):
                bbox = draw.textbbox((0, 0), line, font=font_try)
                tw = bbox[2] - bbox[0]
                draw.text(((width - tw) / 2, y), line, font=font_try, fill=fill)
                y += line_height + spacing #–ü–ê–°–•–ê–õ–ö–ê–ê–ê
            return True


        available_width = width - 120
        try:
            _ = text_start_y
        except NameError:
            text_start_y = int(height * 0.6)

        fit_and_draw_centered(text_start_y, main_text, main_font, text_color, available_width)
        if footer_text:
            footer_bbox = draw.textbbox((0, 0), footer_text, font=footer_font)
            footer_w = footer_bbox[2] - footer_bbox[0]
            draw.text(((width - footer_w) / 2, height - 40), footer_text, font=footer_font, fill=text_color)

        filename = f"now_steam.png"
        temp_photo_path = File(self._temp_dir, filename).getAbsolutePath()
        log(f"[SteamPlugin] Saving card to: {temp_photo_path}")
        card.save(temp_photo_path)
        log(f"[SteamPlugin] Card saved successfully")
        return temp_photo_path


    def on_plugin_unload(self):
        log("Steam plugin unloaded")
        self.alert_manager.dismiss_dialog() # –∫—Ç–æ –ø—Ä–æ—á–∏—Ç–∞–ª —Ç–æ—Ç –ª–æ—Ö –ª–º–∞–æ
