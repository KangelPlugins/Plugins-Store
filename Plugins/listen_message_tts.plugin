__id__ = "listen_message_tts"
__name__ = "Прослушать сообщение"
__version__ = "1.0"
__author__ = "MandreAI CLI"
__description__ = "Добавляет пункт в контекстное меню сообщения: Прослушать. Использует системный TextToSpeech (Google, если установлен), без внешних API."
__min_version__ = "11.9.0"
__icon__ = "exteraPlugins/0"

from base_plugin import BasePlugin, MenuItemData, MenuItemType
from android_utils import run_on_ui_thread, log
from hook_utils import find_class
from java import dynamic_proxy

TextUtils = find_class("android.text.TextUtils")
TextToSpeech = find_class("android.speech.tts.TextToSpeech")
Locale = find_class("java.util.Locale")
ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")

GOOGLE_TTS_PKG = "com.google.android.tts"

class _TTSState:
    tts = None
    init_ok = False
    engine = None

class ListenMessageTTSPlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            self._menu_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text="Прослушать",
                icon="msg_voice",
                on_click=self._on_listen_click,
                condition="message != null && ((message.messageText != null && message.messageText.length() > 0) || message.caption != null)",
                priority=1000
            ))
            self._init_tts_deferred = False
            log("[TTS] plugin loaded")
            # Initialize TTS immediately after install/load using application context
            try:
                ctx = getattr(ApplicationLoader, 'applicationContext', None)
                if ctx is not None:
                    self._ensure_tts(ctx)
                    log("[TTS] requested init on load")
                else:
                    log("[TTS] Application context not available on load")
            except Exception as e:
                log(f"[TTS] init on load error: {e}")
        except Exception as e:
            log(f"[TTS] load error: {e}")

    def on_plugin_unload(self):
        try:
            if getattr(self, "_menu_id", None):
                try:
                    self.remove_menu_item(self._menu_id)
                except Exception:
                    pass
            self._shutdown_tts()
            log("[TTS] plugin unloaded")
        except Exception as e:
            log(f"[TTS] unload error: {e}")

    def _ensure_tts(self, ctx):
        try:
            if _TTSState.tts is not None and _TTSState.init_ok:
                return True
            if getattr(self, "_init_tts_deferred", False):
                return False
            self._init_tts_deferred = True
            def init_on_ui():
                try:
                    OnInitListener = find_class("android.speech.tts.TextToSpeech$OnInitListener")
                    class _OnInit(dynamic_proxy(OnInitListener)):
                        def __init__(self, cb):
                            super().__init__()
                            self.cb = cb
                        def onInit(self, status):
                            try:
                                self.cb(status)
                            except Exception as e:
                                log(f"[TTS] OnInit error: {e}")

                    def _on_init_cb(status):
                        try:
                            _TTSState.init_ok = (status == TextToSpeech.SUCCESS)
                            if _TTSState.init_ok:
                                try:
                                    _TTSState.tts.setLanguage(Locale.getDefault())
                                except Exception:
                                    pass
                            else:
                                log(f"[TTS] init failed: status={status}")
                        except Exception as e:
                            log(f"[TTS] onInit cb error: {e}")

                    listener = _OnInit(_on_init_cb)
                    try:
                        _TTSState.tts = TextToSpeech(ctx, listener, GOOGLE_TTS_PKG)
                        _TTSState.engine = GOOGLE_TTS_PKG
                    except Exception:
                        _TTSState.tts = TextToSpeech(ctx, listener)
                        _TTSState.engine = None
                except Exception as e:
                    log(f"[TTS] init error: {e}")
                finally:
                    self._init_tts_deferred = False
            run_on_ui_thread(init_on_ui)
            return False
        except Exception as e:
            log(f"[TTS] ensure error: {e}")
            return False

    def _shutdown_tts(self):
        try:
            if _TTSState.tts is not None:
                try:
                    _TTSState.tts.stop()
                except Exception:
                    pass
                try:
                    _TTSState.tts.shutdown()
                except Exception:
                    pass
                _TTSState.tts = None
                _TTSState.init_ok = False
        except Exception as e:
            log(f"[TTS] shutdown error: {e}")

    def _speak_text(self, ctx, text):
        try:
            if text is None:
                return
            try:
                if TextUtils.isEmpty(text):
                    return
            except Exception:
                if not text:
                    return
            if not (_TTSState.tts is not None and _TTSState.init_ok):
                ok = self._ensure_tts(ctx)
                if not ok:
                    log("[TTS] Инициализация синтезатора... Нажмите ещё раз через секунду")
                    return
            def speak_on_ui():
                try:
                    try:
                        _TTSState.tts.speak(text, TextToSpeech.QUEUE_FLUSH, None, "extera_tts_msg")
                    except Exception:
                        _TTSState.tts.speak(text, TextToSpeech.QUEUE_FLUSH, None)
                except Exception as e:
                    log(f"[TTS] speak error: {e}")
            run_on_ui_thread(speak_on_ui)
        except Exception as e:
            log(f"[TTS] _speak_text error: {e}")

    def _extract_message_text(self, message_obj):
        try:
            if message_obj is None:
                return None
            # Prefer real caption for media messages
            try:
                cap = getattr(message_obj, 'caption', None)
                if cap is not None:
                    cs = str(cap)
                    if cs and len(cs.strip()) > 0:
                        return cs
            except Exception:
                pass
            # If media present and caption empty, avoid reading file name
            try:
                owner = getattr(message_obj, 'messageOwner', None)
                media = getattr(owner, 'media', None) if owner is not None else None
            except Exception:
                owner = None
                media = None
            if media is not None:
                # Try legacy/fallback caption in owner.message
                try:
                    mt = getattr(owner, 'message', None)
                    if mt and len(str(mt).strip()) > 0:
                        return str(mt)
                except Exception:
                    pass
                # No caption: return None to avoid speaking file name
                return None
            # Non-media: use messageText or owner.message
            try:
                txt = getattr(message_obj, 'messageText', None)
                if txt and len(str(txt).strip()) > 0:
                    return str(txt)
            except Exception:
                pass
            try:
                mt = getattr(owner, 'message', None) if owner is not None else None
                if mt and len(str(mt).strip()) > 0:
                    return str(mt)
            except Exception:
                pass
            return None
        except Exception:
            return None

    def _on_listen_click(self, context: dict):
        try:
            ctx = context.get('context') or (context.get('fragment') and context.get('fragment').getParentActivity())
            msg = context.get('message')
            text = self._extract_message_text(msg)
            if ctx is None:
                log("[TTS] Нет Android Context для инициализации TTS")
                return
            if not text:
                log("[TTS] Нет текста для озвучивания")
                return
            self._speak_text(ctx, text)
        except Exception as e:
            log(f"[TTS] click error: {e}")
