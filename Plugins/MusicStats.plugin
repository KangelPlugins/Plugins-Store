
__id__ = "music_stats_v2"
__name__ = "Music Stats"
__description__ = "Detailed music statistics: time tracking, top tracks and artists. Customizable daily goal.\n\n–ü–æ–¥—Ä–æ–±–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è –º—É–∑—ã–∫–∏: –≤—Ä–µ–º—è, —Ç–æ–ø —Ç—Ä–µ–∫–æ–≤ –∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π. \n–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º–∞—è –µ–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ü–µ–ª—å."
__author__ = "@Vexmio"
__version__ = "2.2"
__icon__ = "icqkolobki/1"
__min_version__ = "12.0.1"

import threading
import json
import os
import datetime
import shutil

from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

try:
    from ui.settings import Header, Switch, Divider, Text, Input
    UI_IMPORTED = True
except:
    UI_IMPORTED = False

from org.telegram.messenger import MediaController, ApplicationLoader, AndroidUtilities, LocaleController

class MusicStatsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.stats_file = None
        self.stats = {
            "daily_time": {}, 
            "track_counts": {}, 
            "track_durations": {},
            "artist_counts": {},
            "daily_tracks": {},
            "hourly_stats": {}
        }
        
        self.now_playing = None
        self.session_sec = 0
        self.is_counted = False
        
        self.stop_flag = threading.Event()
        self.worker = None
        self.menu_ids = {}
        
        self.LANGS = {
            "ru": {
                "active": "‚úÖ",
                "stopped": "‚ùå –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                "mon_cat": "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞",
                "mon_btn": "–ê–∫—Ç–∏–≤–Ω—ã–π –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥",
                "mon_desc": "–°—á–∏—Ç–∞—Ç—å –≤—Ä–µ–º—è –≤ —Ñ–æ–Ω–µ",
                "drawer_btn": "–ò–∫–æ–Ω–∫–∞ –≤ –º–µ–Ω—é",
                "drawer_desc": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ –±–æ–∫–æ–≤–æ–π —à—Ç–æ—Ä–∫–µ",
                "smart_btn": "–£–º–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç",
                "smart_desc": "–ó–∞—Å—á–∏—Ç—ã–≤–∞—Ç—å —Ç—Ä–µ–∫ –ø–æ—Å–ª–µ 90% –≤—Ä–µ–º–µ–Ω–∏",
                "notify_btn": "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è",
                "notify_desc": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ—Å—Ç –ø—Ä–∏ –∑–∞—á–µ—Ç–µ —Ç—Ä–µ–∫–∞",
                "params": "–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –§–∏–ª—å—Ç—Ä—ã",
                "goal": "–¶–µ–ª—å –Ω–∞ –¥–µ–Ω—å (–º–∏–Ω)",
                "goal_desc": "–î–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞",
                "block": "–ò—Å–∫–ª—é—á–∏—Ç—å –∞—Ä—Ç–∏—Å—Ç–æ–≤",
                "block_desc": "–ò–º–µ–Ω–∞ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é",
                "cmd": "–ö–æ–º–∞–Ω–¥–∞ –≤—ã–∑–æ–≤–∞",
                "cmd_desc": "–î–ª—è —á–∞—Ç–∞",
                "view": "–ü—Ä–æ—Å–º–æ—Ç—Ä —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏",
                "b_short": "–ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞ (–°–µ–≥–æ–¥–Ω—è)",
                "b_full": "–î–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç (–ì—Ä–∞—Ñ–∏–∫–∏)",
                "b_top": "–õ–∏–¥–µ—Ä—ã –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è",
                "manage": "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏",
                "b_save": "–ë—ç–∫–∞–ø –≤ –ó–∞–≥—Ä—É–∑–∫–∏",
                "b_wipe": "–°–±—Ä–æ—Å–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É",
                "toast_wiped": "–î–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã",
                "toast_saved": "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ –ó–∞–≥—Ä—É–∑–∫–∏",
                "toast_scrobbled": "‚úÖ –ó–∞—Å—á–∏—Ç–∞–Ω–æ: ",
                "h_short": "üéß –°–≤–æ–¥–∫–∞ –∑–∞ —Å–µ–≥–æ–¥–Ω—è",
                "h_full": "üìä –î–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç",
                "h_top": "üëë –õ–∏–¥–µ—Ä—ã –∑–∞ –≤—Å—ë –≤—Ä–µ–º—è",
                "t_time": "–í—Ä–µ–º—è",
                "t_total": "–í—Å–µ–≥–æ",
                "t_tracks": "–¢–æ–ø —Ç—Ä–µ–∫–æ–≤",
                "t_artists": "–¢–æ–ø –ò—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–π",
                "t_act": "–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (7 –¥–Ω–µ–π)",
                "t_daytime": "–í—Ä–µ–º—è —Å—É—Ç–æ–∫",
                "nodata": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö",
                "copy": "–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å",
                "copied": "–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ",
                "ok": "–û–ö",
                "err": "–û—à–∏–±–∫–∞",
                "target": "–¶–µ–ª—å",
                "u_h": "—á", "u_m": "–º", "u_s": "—Å", "u_x": "—Ä–∞–∑",
                "vibes": ["üåÖ –£—Ç—Ä–æ", "‚òÄÔ∏è –î–µ–Ω—å", "üåÜ –í–µ—á–µ—Ä", "ü¶â –ù–æ—á—å"]
            },
            "en": {
                "active": "‚úÖ",
                "stopped": "‚ùå Stopped",
                "mon_cat": "Monitoring Settings",
                "mon_btn": "Active Monitoring",
                "mon_desc": "Track time in background",
                "drawer_btn": "Drawer Icon",
                "drawer_desc": "Show in side menu",
                "smart_btn": "Smart Count",
                "smart_desc": "Count play after 90% duration",
                "notify_btn": "Notifications",
                "notify_desc": "Show toast when track is counted",
                "params": "Parameters & Filters",
                "goal": "Daily Goal (min)",
                "goal_desc": "For progress bar",
                "block": "Exclude Artists",
                "block_desc": "Comma separated names",
                "cmd": "Launch Command",
                "cmd_desc": "Chat command",
                "view": "View Statistics",
                "b_short": "Daily Summary",
                "b_full": "Detailed Report",
                "b_top": "All-Time Leaders",
                "manage": "Data Management",
                "b_save": "Backup to Downloads",
                "b_wipe": "Reset Statistics",
                "toast_wiped": "Data cleared",
                "toast_saved": "Saved to Downloads",
                "toast_scrobbled": "‚úÖ Counted: ",
                "h_short": "üéß Daily Summary",
                "h_full": "üìä Detailed Report",
                "h_top": "üëë All-Time Leaders",
                "t_time": "Time",
                "t_total": "Total",
                "t_tracks": "Top Tracks",
                "t_artists": "Top Artists",
                "t_act": "Activity (7 days)",
                "t_daytime": "Time of Day",
                "nodata": "No data",
                "copy": "Copy",
                "copied": "Copied",
                "ok": "OK",
                "err": "Error",
                "target": "Goal",
                "u_h": "h", "u_m": "m", "u_s": "s", "u_x": "plays",
                "vibes": ["üåÖ Morning", "‚òÄÔ∏è Day", "üåÜ Evening", "ü¶â Night"]
            }
        }

    def t(self, key):
        try:
            sys_lang = LocaleController.getInstance().getCurrentLocale().getLanguage().lower()
            lang = "ru" if sys_lang.startswith("ru") else "en"
        except:
            lang = "en"
        return self.LANGS[lang].get(key, key)

    def on_plugin_load(self):
        root = ApplicationLoader.getFilesDirFixed().getAbsolutePath()
        self.db_path = os.path.join(root, "plugins", f"{__id__}.json")
        self.data = self.load_db()
        
        self.add_on_send_message_hook()
        self.refresh_ui()
        self.start_worker()

    def on_plugin_unload(self):
        self.stop_worker()
        self.clear_ui()

    def refresh_ui(self):
        self.clear_ui()
        try:
            chat_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="üìä Music Stats",
                icon="msg_stats",
                priority=100,
                on_click=self.open_summary
            ))
            self.menu_ids['chat'] = chat_id

            if self.get_setting("show_drawer", True):
                draw_id = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text="Music Stats",
                    icon="msg_channel_14",
                    on_click=self.open_settings
                ))
                self.menu_ids['drawer'] = draw_id
        except: pass

    def clear_ui(self):
        for mid in self.menu_ids.values():
            try: self.remove_menu_item(mid)
            except: pass
        self.menu_ids.clear()

    def open_settings(self, view=None):
        try:
            plugin = PluginsController.getInstance().plugins.get(__id__)
            frag = get_last_fragment()
            if plugin and frag:
                run_on_ui_thread(lambda: frag.presentFragment(PluginSettingsActivity(plugin)))
            else:
                self.open_summary()
        except:
            self.open_summary()

    def on_send_message_hook(self, account, params):
        if not params.message: return HookResult()
        
        trigger = self.get_setting("cmd_trigger", ".mstats").strip()
        if params.message.strip() == trigger:
            self.open_summary()
            return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

    def create_settings(self):
        if not UI_IMPORTED: return []

        s = []
        
        s.append(Header(self.t("view")))
        s.append(Text(text=self.t("b_short"), icon="msg_stats", on_click=self.open_summary))
        s.append(Text(text=self.t("b_full"), icon="menu_intro_remix", on_click=self.open_detailed))
        s.append(Text(text=self.t("b_top"), icon="msg_allowspeak", on_click=self.open_leaders))
        s.append(Divider())

        state = self.t("active") if (self.worker and self.worker.is_alive()) else self.t("stopped")
        s.append(Header(f"{self.t('mon_cat')} ({state})"))
        
        s.append(Switch(
            key="is_monitoring", 
            text=self.t("mon_btn"), 
            default=True,
            subtext=self.t("mon_desc"),
            icon="msg_emoji_flags"
        ))

        s.append(Switch(
            key="show_drawer", 
            text=self.t("drawer_btn"), 
            default=True,
            subtext=self.t("drawer_desc"),
            icon="msg_list"
        ))

        s.append(Switch(
            key="smart_mode", 
            text=self.t("smart_btn"), 
            default=False,
            subtext=self.t("smart_desc"),
            icon="msg_customize"
        ))
        
        s.append(Switch(
            key="notify_on_scrobble", 
            text=self.t("notify_btn"), 
            default=True,
            subtext=self.t("notify_desc"),
            icon="msg_message"
        ))

        s.append(Divider())

        s.append(Header(self.t("params")))
        s.append(Input(key="goal_min", text=self.t("goal"), default="120", subtext=self.t("goal_desc"), icon="msg_timer"))
        s.append(Input(key="cmd_trigger", text=self.t("cmd"), default=".mstats", subtext=self.t("cmd_desc"), icon="msg_cmd"))
        s.append(Input(key="blacklist", text=self.t("block"), default="", subtext=self.t("block_desc"), icon="media_button_erase"))
        s.append(Divider())

        s.append(Header(self.t("manage")))
        s.append(Text(text=self.t("b_save"), icon="msg_download_solar", on_click=self.do_backup))
        s.append(Text(text=self.t("b_wipe"), icon="msg_delete_solar", red=True, on_click=self.do_wipe))

        return s

    def open_summary(self, v=None): self.show_dialog("summary")
    def open_detailed(self, v=None): self.show_dialog("detailed")
    def open_leaders(self, v=None): self.show_dialog("leaders")

    def do_wipe(self, v=None):
        self.data = {"daily_time": {}, "track_counts": {}, "track_durations": {}, "artist_counts": {}, "daily_tracks": {}, "hourly_stats": {}}
        self.save_db()
        BulletinHelper.show_success(self.t("toast_wiped"), None)

    def do_backup(self, v=None):
        try:
            self.save_db()
            dest = os.path.join(os.environ["EXTERNAL_STORAGE"], "Download", f"{__id__}_backup.json")
            shutil.copy2(self.db_path, dest)
            BulletinHelper.show_success(self.t("toast_saved"), None)
        except Exception as e:
            BulletinHelper.show_error(f"{self.t('err')}: {e}", None)

    def start_worker(self):
        self.stop_flag.clear()
        self.worker = threading.Thread(target=self.work_loop, daemon=True)
        self.worker.start()

    def stop_worker(self):
        self.stop_flag.set()
        if self.worker: self.worker.join(1)

    def work_loop(self):
        while not self.stop_flag.is_set():
            try:
                if self.get_setting("is_monitoring", True):
                    self.check_playback()
            except: pass
            if self.stop_flag.wait(5): break

    def check_playback(self):
        try:
            mc = MediaController.getInstance()
            obj = mc.getPlayingMessageObject()
            
            if not obj or mc.isMessagePaused() or not obj.isMusic(): return

            meta = (obj.getMusicTitle(), obj.getMusicAuthor() or "Unknown Artist")
            dur = 0
            try: dur = obj.getDuration()
            except: pass
            
            self.process_track(meta, dur)
        except: pass

    def is_blocked(self, artist):
        blocked = self.get_setting("blacklist", "")
        if not blocked: return False
        
        norm_art = artist.strip().lower()
        for item in blocked.split(","):
            if item.strip().lower() == norm_art: return True
        return False

    def process_track(self, meta, total_dur):
        title, artist = meta
        if self.is_blocked(artist): return

        full_name = f"{artist} - {title}"
        today = datetime.date.today().isoformat()
        current_hour = str(datetime.datetime.now().hour) 

        for k in ["daily_time", "track_counts", "track_durations", "artist_counts", "daily_tracks", "hourly_stats"]:
            if k not in self.data: self.data[k] = {}

        if full_name != self.now_playing:
            self.now_playing = full_name
            self.session_sec = 0
            self.is_counted = False

        self.data["daily_time"][today] = self.data["daily_time"].get(today, 0) + 5
        self.data["track_durations"][full_name] = self.data["track_durations"].get(full_name, 0) + 5
        
        dt = self.data["daily_tracks"].setdefault(today, {})
        dt[full_name] = dt.get(full_name, 0) + 5
        
        self.data["hourly_stats"][current_hour] = self.data["hourly_stats"].get(current_hour, 0) + 5
        
        self.session_sec += 5

        if not self.is_counted:
            count_it = False
            if self.get_setting("smart_mode", False):
                if total_dur > 0 and self.session_sec >= (total_dur * 0.9): count_it = True
                elif total_dur == 0 and self.session_sec >= 30: count_it = True
            elif self.session_sec >= 5:
                count_it = True

            if count_it:
                self.data["track_counts"][full_name] = self.data["track_counts"].get(full_name, 0) + 1
                
                art_key = artist.strip().lower()
                real_art_name = artist
                for existing in self.data["artist_counts"]:
                    if existing.lower() == art_key:
                        real_art_name = existing
                        break
                
                self.data["artist_counts"][real_art_name] = self.data["artist_counts"].get(real_art_name, 0) + 1
                self.is_counted = True
                self.save_db()
                
                if self.get_setting("notify_on_scrobble", True):
                    run_on_ui_thread(lambda: BulletinHelper.show_success(f"{self.t('toast_scrobbled')}{title}", None))

        if self.data["daily_time"][today] % 60 == 0:
            self.save_db()

    def save_db(self):
        if not self.db_path: return
        try:
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            with open(self.db_path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, ensure_ascii=False)
        except: pass

    def load_db(self):
        if self.db_path and os.path.exists(self.db_path):
            try:
                with open(self.db_path, "r", encoding="utf-8") as f:
                    return json.load(f)
            except: pass
        return {"daily_time": {}, "track_counts": {}, "track_durations": {}, "artist_counts": {}, "daily_tracks": {}, "hourly_stats": {}}

    def get_bar(self, val):
        try: goal = int(self.get_setting("goal_min", "120")) * 60
        except: goal = 7200
        if goal < 1: goal = 1
        
        pct = min(1.0, val / goal)
        blk = int(pct * 10)
        vis = "‚ñà" * blk + "‚ñë" * (10 - blk)
        
        m_lbl = self.t("u_m")
        return f"[{vis}] {int(pct * 100)}% ({self.t('target')}: {int(goal/60)}{m_lbl})"

    def fmt_time(self, sec):
        m, s = divmod(sec, 60)
        h, m = divmod(m, 60)
        
        h_l = self.t("u_h")
        m_l = self.t("u_m")
        s_l = self.t("u_s")
        
        if h > 0: return f"{h}{h_l} {m}{m_l}"
        return f"{m}{m_l} {s}{s_l}"

    def build_graph(self):
        today = datetime.date.today()
        if self.t("ok") == "OK": 
             d_names = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        else:
             d_names = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
             
        out = ""
        max_v = 1
        points = []

        for i in range(6, -1, -1):
            d = today - datetime.timedelta(days=i)
            val = self.data["daily_time"].get(d.isoformat(), 0)
            if val > max_v: max_v = val
            points.append((d_names[d.weekday()], val))

        for name, val in points:
            pct = val / max_v
            blk = int(pct * 8)
            vis = "‚ñà" * blk
            if blk == 0 and val > 0: vis = "‚ñè"
            
            t_str = f"{int(val/60)}{self.t('u_m')}"
            if val > 3600: t_str = f"{round(val/3600, 1)}{self.t('u_h')}"
            if val == 0: t_str = "-"
            
            out += f"`{name}: {vis:<8} {t_str}`\n"
        return out

    def build_hourly_graph(self):
        periods = [0, 0, 0, 0] 
        vibes = self.LANGS["ru"]["vibes"] if self.t("ok") != "OK" else self.LANGS["en"]["vibes"]
        
        if "hourly_stats" in self.data:
            for h_str, sec in self.data["hourly_stats"].items():
                h = int(h_str)
                if 6 <= h < 12: periods[0] += sec
                elif 12 <= h < 18: periods[1] += sec
                elif 18 <= h <= 23: periods[2] += sec
                else: periods[3] += sec
                
        out = f"üï∞ **{self.t('t_daytime')}:**\n"
        total = sum(periods) or 1
        
        for i, val in enumerate(periods):
            pct = int((val / total) * 100)
            if val > 0:
                out += f"{vibes[i]}: {pct}% ({self.fmt_time(val)})\n"
        
        return out

    def show_dialog(self, mode):
        try:
            today = datetime.date.today().isoformat()
            
            if mode == "summary":
                sec = self.data["daily_time"].get(today, 0)
                day_tracks = self.data.get("daily_tracks", {}).get(today, {})
                top = sorted(day_tracks.items(), key=lambda x: x[1], reverse=True)[:5]
                
                txt = f"**{self.t('h_short')}**\n\n{self.get_bar(sec)}\n{self.t('t_time')}: {self.fmt_time(sec)}\n\n"
                txt += f"üèÜ **{self.t('t_tracks')}:**\n"
                if not top: txt += f"({self.t('nodata')})"
                else:
                    for i, (n, t) in enumerate(top):
                        txt += f"{i+1}. {n}\n   ‚îî {self.fmt_time(t)}\n"
                
                self.alert(self.t("b_short"), txt)

            elif mode == "leaders":
                top = sorted(self.data.get("track_durations", {}).items(), key=lambda x: x[1], reverse=True)[:10]
                
                txt = f"**{self.t('h_top')}**\n\n"
                if not top: txt += f"({self.t('nodata')})"
                else:
                    for i, (n, t) in enumerate(top):
                        cnt = self.data["track_counts"].get(n, 0)
                        txt += f"{i+1}. {n}\n   ‚îî {self.fmt_time(t)} ‚Ä¢ {cnt} {self.t('u_x')}\n"
                
                self.alert(self.t("b_top"), txt)

            elif mode == "detailed":
                cur = datetime.date.today()
                w_sec = sum(self.data["daily_time"].get((cur - datetime.timedelta(days=i)).isoformat(), 0) for i in range(7))
                m_sec = sum(self.data["daily_time"].get((cur - datetime.timedelta(days=i)).isoformat(), 0) for i in range(30))
                y_sec = sum(self.data["daily_time"].get((cur - datetime.timedelta(days=i)).isoformat(), 0) for i in range(365))
                
                top_art = sorted(self.data.get("artist_counts", {}).items(), key=lambda x: x[1], reverse=True)[:5]

                txt = f"üìÖ **{self.t('t_act')}:**\n{self.build_graph()}\n"
                txt += f"{self.build_hourly_graph()}\n"
                
                txt += f"üìà **{self.t('t_total')}:**\n"
                txt += f"‚Ä¢ {self.t('week')}: {self.fmt_time(w_sec)}\n"
                txt += f"‚Ä¢ {self.t('month')}: {self.fmt_time(m_sec)}\n"
                txt += f"‚Ä¢ {self.t('year')}: {self.fmt_time(y_sec)}\n\n"
                txt += f"üé§ **{self.t('t_artists')}:**\n"
                
                if not top_art: txt += f"({self.t('nodata')})"
                else:
                    for i, (a, c) in enumerate(top_art):
                        txt += f"{i+1}. {a}: {c}\n"

                self.alert(self.t("b_full"), txt)
        except: pass

    def alert(self, title, text):
        frag = get_last_fragment()
        if frag:
            act = frag.getParentActivity()
            if act:
                run_on_ui_thread(lambda: self._build_alert(act, title, text))

    def _build_alert(self, act, title, text):
        b = AlertDialogBuilder(act)
        b.set_title(title)
        b.set_message(text)
        b.set_positive_button(self.t("ok"), None)
        b.set_neutral_button(self.t("copy"), lambda d, w: self.copy_txt(text))
        b.show()

    def copy_txt(self, text):
        try:
            cln = text.replace("**", "").replace("`", "")
            AndroidUtilities.addToClipboard(cln)
            BulletinHelper.show_success(self.t("copied"), None)
        except: pass