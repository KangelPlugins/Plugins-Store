from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from ui.settings import Input, Header, Selector, Text, Switch, Divider
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment
import hashlib
import json
import os
import threading
import time
import urllib.request
import uuid

__id__ = "fix_endpoint_gooey"
__name__ = "Notch Fix"
__description__ = "изменяет конечную точку аватарки в профиле\n\nесть сбор статистики mkStats"
__icon__ = "feature_plugins/0"
__version__ = "3.1"
__min_version__ = "12.1.1"
__author__ = "@feature_plugins"

# === mkStats: embed client start ===
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))
MKSTATS_POW_SOLVE_SECONDS = int(os.getenv("MKSTATS_POW_SOLVE_SECONDS", "6"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def generate_device_fingerprint(device_id: str) -> str:
    payload = f"{device_id}:mkstats:device:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

def _pow_valid(challenge: str, nonce: str, difficulty: int) -> bool:
    if not challenge or not nonce or difficulty <= 0:
        return False
    prefix = "0" * max(1, int(difficulty))
    digest = hashlib.sha256(f"{challenge}:{nonce}".encode("utf-8")).hexdigest()
    return digest.startswith(prefix)

def _solve_pow(challenge: str, difficulty: int, max_seconds: int = MKSTATS_POW_SOLVE_SECONDS) -> str | None:
    difficulty = max(1, int(difficulty or 0))
    deadline = time.time() + max(1, int(max_seconds or 0))
    nonce = 0
    prefix = "0" * difficulty
    while time.time() < deadline:
        candidate = format(nonce, "x")
        digest = hashlib.sha256(f"{challenge}:{candidate}".encode("utf-8")).hexdigest()
        if digest.startswith(prefix):
            return candidate
        nonce += 1
    return None

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, plugin_version: str, user_hash: str, device_fingerprint: str, client_version: str | None = None, client_name: str | None = None) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.plugin_version = plugin_version
        self.client_version = client_version
        self.client_name = client_name
        self.user_hash = user_hash
        self.device_fingerprint = device_fingerprint

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
        }
        response = _post_json(f"{self.api_base}/handshake", payload)
        token = (response or {}).get("install_token", "")
        if token:
            return response
        pow_required = bool((response or {}).get("pow_required"))
        pow_challenge = (response or {}).get("pow_challenge")
        if pow_required and pow_challenge:
            difficulty = int((response or {}).get("pow_difficulty") or 0)
            nonce = _solve_pow(pow_challenge, difficulty)
            if nonce and _pow_valid(pow_challenge, nonce, difficulty):
                payload["pow_challenge"] = pow_challenge
                payload["pow_nonce"] = nonce
                response = _post_json(f"{self.api_base}/handshake", payload)
        return response

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)
# === mkStats: embed client end ===

CONF_MODE = "notch_mode"
CONF_OFFSET_Y = "notch_offset_y"
CONF_OFFSET_X = "notch_offset_x"
CONF_RECT_X = "notch_rect_x"
CONF_RECT_Y = "notch_rect_y"
CONF_RECT_W = "notch_rect_w"
CONF_RECT_H = "notch_rect_h"

MODE_HIDE = "0"
MODE_MANUAL = "1"

STRINGS = {
    "ru": {
        "label_mode": "Режим",
        "mode_hide": "Выреза нету",
        "mode_manual": "Ручной",
        "label_x": "Смещение X [DP]",
        "label_y": "Смещение Y [DP]",
        "label_w": "Ширина [DP]",
        "label_h": "Высота [DP]",
        "force_hint": "Если ширина/высота 0 - используется системное значение\nY: + вниз, - вверх | X: + вправо, - влево",
        "faq_btn": "FAQ / Справка",
        "faq_title": "Справка",
        "faq_content": "Режим 'Выреза нету': Скрывает вырез.\n\nРежим 'Ручной': Позволяет задать смещение от левого/верхнего угла и размеры.\n\nЕсли не меняется - перезапуск.",
        "btn_ok": "Понятно",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Анонимная статистика использования",
    },
    "en": {
        "label_mode": "Mode",
        "mode_hide": "No notch",
        "mode_manual": "Manual",
        "label_x": "X Offset [DP]",
        "label_y": "Y Offset [DP]",
        "label_w": "Width [DP]",
        "label_h": "Height [DP]",
        "force_hint": "If width/height are 0 - system default is used",
        "faq_btn": "FAQ / Help",
        "faq_title": "Help",
        "faq_content": "Mode 'No notch': Hides the notch.\n\nMode 'Manual': Custom offset and dimensions.\n\nIf it doesn't change, restart.",
        "btn_ok": "Got it",
        "enable_analytics": "mkStats",
        "enable_analytics_sub": "Anonymous usage statistics",
    }
}

def get_language():
    """Определяет язык системы используя Java Locale API"""
    try:
        Locale = find_class("java.util.Locale")
        return "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    except:
        return "en"

def get_string(key):
    lang = get_language()
    return STRINGS.get(lang, STRINGS["en"]).get(key, STRINGS["en"].get(key, ""))

class Plugin(BasePlugin):

    # === mkStats: integration start ===
    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_get_client_version(self) -> str:
        try:
            from org.telegram.messenger import BuildVars
            version = getattr(BuildVars, "BUILD_VERSION_STRING", None) or getattr(BuildVars, "BUILD_VERSION", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import BuildConfig as TgBuildConfig
            version = getattr(TgBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            version = getattr(AyuBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            version = getattr(ExBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pm = ctx.getPackageManager()
                pkg = ctx.getPackageName()
                info = pm.getPackageInfo(pkg, 0)
                version = getattr(info, "versionName", None) or getattr(info, "versionCode", None)
                if version:
                    return str(version)
        except Exception:
            pass
        return "unknown"

    def _mkstats_get_client_name(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pkg = ctx.getPackageName()
                if pkg == "com.radolyn.ayugram":
                    return "AyuGram"
                if pkg == "com.exteragram.messenger":
                    return "exteraGram"
                if pkg == "org.telegram.messenger":
                    return "Telegram"
                if pkg:
                    return str(pkg)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            _ = AyuBuildConfig.VERSION_NAME
            return "AyuGram"
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            _ = ExBuildConfig.VERSION_NAME
            return "exteraGram"
        except Exception:
            pass
        return "unknown"

    def _mkstats_log(self, message: str) -> None:
        if hasattr(self, "log"):
            try:
                self.log(message)
            except Exception:
                pass

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self._mkstats_log(f"mkStats: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    self._mkstats_log("mkStats: handshake start")
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                        self._mkstats_log("mkStats: handshake ok, token stored")
                    else:
                        self._mkstats_log("mkStats: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_log("mkStats: sending ping")
                    self._mkstats_client.send_ping(self._mkstats_token)
                    self._mkstats_log("mkStats: ping sent")
            except Exception as exc:
                self._mkstats_log(f"mkStats: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            device_fingerprint = generate_device_fingerprint(device_id)
            client_name = self._mkstats_get_client_name()
            client_version = self._mkstats_get_client_version()
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash, device_fingerprint, client_version, client_name)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self._mkstats_log(f"mkStats: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass
    # === mkStats: integration end ===

    def on_plugin_load(self):
        # === Feature Toggles ===
        enable_analytics = self.get_setting("enable_analytics", True)

        # === mkStats: integration start ===
        if enable_analytics:
            self._mkstats_start()
        # === mkStats: integration end ===

        try:
            target = find_class("org.telegram.messenger.NotchInfoUtils")
            m = target.getClass().getDeclaredMethod("getInfo", find_class("android.content.Context"))
            m.setAccessible(True)
            self.hook_method(m, NotchHook(self))
        except Exception as e:
            self.log(f"Hook Error: {e}")

    def create_settings(self):
        current_mode = int(self.get_setting(CONF_MODE, MODE_MANUAL))
        
        # Manual Mode Settings
        current_x = self.get_setting(CONF_RECT_X, "0")
        current_y = self.get_setting(CONF_RECT_Y, "0")
        current_w = self.get_setting(CONF_RECT_W, "0")
        current_h = self.get_setting(CONF_RECT_H, "0")

        # Proactive Initialization if 0
        if (current_w == "0" or current_w == "") and (current_h == "0" or current_h == ""):
            try:
                AU = find_class("org.telegram.messenger.AndroidUtilities")
                AL = find_class("org.telegram.messenger.ApplicationLoader")
                NIU = find_class("org.telegram.messenger.NotchInfoUtils")
                
                info = NIU.getInfo(AL.applicationContext)
                if info and info.bounds:
                    density = float(AU.density)
                    val_x = int(info.bounds.left / density)
                    val_y = int(info.bounds.top / density)
                    val_w = int((info.bounds.right - info.bounds.left) / density)
                    val_h = int((info.bounds.bottom - info.bounds.top) / density)
                    
                    self.set_setting(CONF_RECT_X, str(val_x))
                    self.set_setting(CONF_RECT_Y, str(val_y))
                    self.set_setting(CONF_RECT_W, str(val_w))
                    self.set_setting(CONF_RECT_H, str(val_h))
                    
                    current_x, current_y, current_w, current_h = str(val_x), str(val_y), str(val_w), str(val_h)
            except:
                pass
        
        items = [get_string("mode_hide"), get_string("mode_manual")]
        
        settings = [
            Selector(key=CONF_MODE, text=get_string("label_mode"), default=current_mode, items=items),
            Divider()
        ]
        
        if current_mode == 1:
            settings.extend([
                Input(CONF_RECT_X, get_string("label_x"), default=current_x),
                Input(CONF_RECT_Y, get_string("label_y"), default=current_y),
                Input(CONF_RECT_W, get_string("label_w"), default=current_w),
                Input(CONF_RECT_H, get_string("label_h"), default=current_h),
                Header(get_string("force_hint"))
            ])
        
        # FAQ Button
        settings.extend([
            Divider(),
            Text(
                text=get_string("faq_btn"),
                on_click=self.show_faq
            )
        ])
        
        settings.extend([
            Divider(),
            Switch(
                key="enable_analytics",
                text=get_string("enable_analytics"),
                subtext=get_string("enable_analytics_sub"),
                icon="stats",
                default=True
            )
        ])
        
        return settings

    def show_faq(self, view):
        frag = get_last_fragment()
        if not frag:
            return
        act = frag.getParentActivity()
        if not act:
            return
            
        b = AlertDialogBuilder(act)
        b.set_title(get_string("faq_title"))
        b.set_message(get_string("faq_content"))
        b.set_positive_button(get_string("btn_ok"), lambda b, w: b.dismiss())
        b.show()

    def on_plugin_unload(self):
        # === mkStats: integration start ===
        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self._mkstats_log("mkStats: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass
        # === mkStats: integration end ===

class NotchHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        # Кэшируем класс при инициализации, чтобы не искать его каждый раз
        self._au_class = None
        self.detected = False

    def _get_au_class(self):
        """Кэшируем AndroidUtilities класс"""
        if self._au_class is None:
            self._au_class = find_class("org.telegram.messenger.AndroidUtilities")
        return self._au_class

    def after_hooked_method(self, param):
        try:
            original = param.getResult()
            mode = int(self.plugin.get_setting(CONF_MODE, MODE_MANUAL))
            
            # Режим 0 - "выреза нету" - возвращаем null
            if mode == 0:
                if original is not None:
                    param.setResult(None)
                return
            
            # Режим 1 - Ручной
            if mode == 1:
                # Читаем настройки
                x_str = self.plugin.get_setting(CONF_RECT_X, "0")
                y_str = self.plugin.get_setting(CONF_RECT_Y, "0")
                w_str = self.plugin.get_setting(CONF_RECT_W, "0")
                h_str = self.plugin.get_setting(CONF_RECT_H, "0")
                
                AU = self._get_au_class()
                
                try:
                    x_dp = float(x_str or 0)
                    y_dp = float(y_str or 0)
                    w_dp = float(w_str or 0)
                    h_dp = float(h_str or 0)
                except:
                    return

                # Если настройки 0 - выходим
                if w_dp <= 0 and h_dp <= 0:
                    return

                # Если оригинала нет - создаем
                if original is None:
                    NotchInfo = find_class("org.telegram.messenger.NotchInfoUtils$NotchInfo")
                    RectF = find_class("android.graphics.RectF")
                    original = NotchInfo.newInstance()
                    original.bounds = RectF.newInstance()
                    param.setResult(original)

                # Вычисляем px
                l_px = float(AU.dp(x_dp))
                t_px = float(AU.dp(y_dp))
                r_px = l_px + float(AU.dp(w_dp))
                b_px = t_px + float(AU.dp(h_dp))

                # Применяем границы
                b = original.bounds
                b.left = l_px
                b.top = t_px
                b.right = r_px
                b.bottom = b_px
                
                # Настройки типа выреза
                original.gravity = 17 # CENTER
                original.isLikelyCircle = True

        except Exception:
            pass
