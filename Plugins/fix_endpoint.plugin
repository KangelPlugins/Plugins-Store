from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from ui.settings import Input, Header, Selector, Text
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment

# обнову делал до этого с телефона

import hashlib
import json
import os
import threading
import time
import urllib.request
import uuid

# === mkStats: embed client start ===
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))
MKSTATS_POW_SOLVE_SECONDS = int(os.getenv("MKSTATS_POW_SOLVE_SECONDS", "6"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def generate_device_fingerprint(device_id: str) -> str:
    payload = f"{device_id}:mkstats:device:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

def _pow_valid(challenge: str, nonce: str, difficulty: int) -> bool:
    if not challenge or not nonce or difficulty <= 0:
        return False
    prefix = "0" * max(1, int(difficulty))
    digest = hashlib.sha256(f"{challenge}:{nonce}".encode("utf-8")).hexdigest()
    return digest.startswith(prefix)

def _solve_pow(challenge: str, difficulty: int, max_seconds: int = MKSTATS_POW_SOLVE_SECONDS) -> str | None:
    difficulty = max(1, int(difficulty or 0))
    deadline = time.time() + max(1, int(max_seconds or 0))
    nonce = 0
    prefix = "0" * difficulty
    while time.time() < deadline:
        candidate = format(nonce, "x")
        digest = hashlib.sha256(f"{challenge}:{candidate}".encode("utf-8")).hexdigest()
        if digest.startswith(prefix):
            return candidate
        nonce += 1
    return None

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, plugin_version: str, user_hash: str, device_fingerprint: str, client_version: str | None = None, client_name: str | None = None) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.plugin_version = plugin_version
        self.client_version = client_version
        self.client_name = client_name
        self.user_hash = user_hash
        self.device_fingerprint = device_fingerprint

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
        }
        response = _post_json(f"{self.api_base}/handshake", payload)
        token = (response or {}).get("install_token", "")
        if token:
            return response
        pow_required = bool((response or {}).get("pow_required"))
        pow_challenge = (response or {}).get("pow_challenge")
        if pow_required and pow_challenge:
            difficulty = int((response or {}).get("pow_difficulty") or 0)
            nonce = _solve_pow(pow_challenge, difficulty)
            if nonce and _pow_valid(pow_challenge, nonce, difficulty):
                payload["pow_challenge"] = pow_challenge
                payload["pow_nonce"] = nonce
                response = _post_json(f"{self.api_base}/handshake", payload)
        return response

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)
# === mkStats: embed client end ===

# бубубу бебебе

__id__ = "fix_endpoint_gooey"
__name__ = "Notch Fix"
__description__ = "изменяет конечную точку аватарки в профиле"
__icon__ = "feature_plugins/0"
__version__ = "3.0 (mkStats integration)"
__min_version__ = "12.1.1"
__author__ = "@feature_plugins"

CONF_MODE = "notch_mode"
CONF_OFFSET_Y = "notch_offset_y"
CONF_RECT_L = "notch_rect_l"
CONF_RECT_T = "notch_rect_t"
CONF_RECT_R = "notch_rect_r"
CONF_RECT_B = "notch_rect_b"

MODE_HIDE = "0"
MODE_OFFSET = "1"
MODE_FORCE = "2"

STRINGS = {
    "ru": {
        "label_mode": "Режим",
        "mode_hide": "Выреза нету",
        "mode_offset": "Смещение",
        "mode_force": "Ручной",
        "label_offset": "Сдвиг (DP)",
        "hint_offset": "Положит. = вниз, Отрицат. = вверх",
        "label_l": "Слева [DP]",
        "label_t": "Сверху [DP]",
        "label_r": "Справа [DP]",
        "label_b": "Снизу [DP]",
        "force_hint": "Если все 0 - используется системное значение",
        "faq_btn": "FAQ / Справка",
        "faq_title": "Справка",
        "faq_content": "Режим 'Выреза нету': Скрывает вырез.\n\nРежим 'Смещение': Поднимает/Опускает.\n\nРежим 'Ручной': Позволяет задать точные координаты RectF.\n\nЕсли не меняется - перезапуск.",
        "btn_ok": "Понятно",
    },
    "en": {
        "label_mode": "Mode",
        "mode_hide": "No notch",
        "mode_offset": "Offset",
        "mode_force": "Manual",
        "label_offset": "Vertical Offset (DP)",
        "hint_offset": "Positive = down, Negative = up",
        "label_l": "Left [DP]",
        "label_t": "Top [DP]",
        "label_r": "Right [DP]",
        "label_b": "Bottom [DP]",
        "force_hint": "If all are 0 - system default is used",
        "faq_btn": "FAQ / Help",
        "faq_title": "Help",
        "faq_content": "Mode 'No notch': Hides the notch.\n\nMode 'Offset': Raises/Lowers.\n\nMode 'Manual': Custom RectF coordinates.\n\nIf it doesn't change, restart.",
        "btn_ok": "Got it",
    }
}

def get_language():
    """Определяет язык системы используя Java Locale API"""
    try:
        Locale = find_class("java.util.Locale")
        return "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    except:
        return "en"

def get_string(key):
    lang = get_language()
    return STRINGS.get(lang, STRINGS["en"]).get(key, STRINGS["en"].get(key, ""))

class Plugin(BasePlugin):

    # === mkStats: integration start ===
    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_get_client_version(self) -> str:
        try:
            from org.telegram.messenger import BuildVars
            version = getattr(BuildVars, "BUILD_VERSION_STRING", None) or getattr(BuildVars, "BUILD_VERSION", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import BuildConfig as TgBuildConfig
            version = getattr(TgBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            version = getattr(AyuBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            version = getattr(ExBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pm = ctx.getPackageManager()
                pkg = ctx.getPackageName()
                info = pm.getPackageInfo(pkg, 0)
                version = getattr(info, "versionName", None) or getattr(info, "versionCode", None)
                if version:
                    return str(version)
        except Exception:
            pass
        return "unknown"

    def _mkstats_get_client_name(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pkg = ctx.getPackageName()
                if pkg == "com.radolyn.ayugram":
                    return "AyuGram"
                if pkg == "com.exteragram.messenger":
                    return "exteraGram"
                if pkg == "org.telegram.messenger":
                    return "Telegram"
                if pkg:
                    return str(pkg)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            _ = AyuBuildConfig.VERSION_NAME
            return "AyuGram"
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            _ = ExBuildConfig.VERSION_NAME
            return "exteraGram"
        except Exception:
            pass
        return "unknown"

    def _mkstats_log(self, message: str) -> None:
        if hasattr(self, "log"):
            try:
                self.log(message)
            except Exception:
                pass

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self._mkstats_log(f"mkStats: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    self._mkstats_log("mkStats: handshake start")
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                        self._mkstats_log("mkStats: handshake ok, token stored")
                    else:
                        self._mkstats_log("mkStats: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_log("mkStats: sending ping")
                    self._mkstats_client.send_ping(self._mkstats_token)
                    self._mkstats_log("mkStats: ping sent")
            except Exception as exc:
                self._mkstats_log(f"mkStats: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            device_fingerprint = generate_device_fingerprint(device_id)
            client_name = self._mkstats_get_client_name()
            client_version = self._mkstats_get_client_version()
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash, device_fingerprint, client_version, client_name)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self._mkstats_log(f"mkStats: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass
    # === mkStats: integration end ===

    def on_plugin_load(self):

        # === mkStats: integration start ===
        self._mkstats_start()
        # === mkStats: integration end ===

        try:
            target = find_class("org.telegram.messenger.NotchInfoUtils")
            m = target.getClass().getDeclaredMethod("getInfo", find_class("android.content.Context"))
            m.setAccessible(True)
            self.hook_method(m, NotchHook(self))
        except Exception as e:
            self.log(f"Hook Error: {e}")

    def create_settings(self):
        current_mode = int(self.get_setting(CONF_MODE, MODE_OFFSET))
        current_offset = self.get_setting(CONF_OFFSET_Y, "0")
        
        # RectF Settings
        current_l = self.get_setting(CONF_RECT_L, "0")
        current_t = self.get_setting(CONF_RECT_T, "0")
        current_r = self.get_setting(CONF_RECT_R, "0")
        current_b = self.get_setting(CONF_RECT_B, "0")
        
        items = [get_string("mode_hide"), get_string("mode_offset"), get_string("mode_force")]
        
        settings = [
            Selector(key=CONF_MODE, text=get_string("label_mode"), default=current_mode, items=items)
        ]
        
        if current_mode == 1:
            settings.extend([
                Input(
                    CONF_OFFSET_Y, 
                    get_string("label_offset"),
                    default=current_offset
                ),
                Header(get_string("hint_offset"))
            ])
        elif current_mode == 2:
            settings.extend([
                Input(CONF_RECT_L, get_string("label_l"), default=current_l),
                Input(CONF_RECT_T, get_string("label_t"), default=current_t),
                Input(CONF_RECT_R, get_string("label_r"), default=current_r),
                Input(CONF_RECT_B, get_string("label_b"), default=current_b),
                Header(get_string("force_hint"))
            ])
        
        # FAQ Button
        settings.append(
            Text(
                text=get_string("faq_btn"),
                on_click=self.show_faq
            )
        )
        
        return settings

    def show_faq(self, view):
        frag = get_last_fragment()
        if not frag:
            return
        act = frag.getParentActivity()
        if not act:
            return
            
        b = AlertDialogBuilder(act)
        b.set_title(get_string("faq_title"))
        b.set_message(get_string("faq_content"))
        b.set_positive_button(get_string("btn_ok"), lambda b, w: b.dismiss())
        b.show()

    def on_plugin_unload(self):
        # === mkStats: integration start ===
        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self._mkstats_log("mkStats: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass
        # === mkStats: integration end ===

class NotchHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        # Кэшируем класс при инициализации, чтобы не искать его каждый раз
        self._au_class = None
        self.detected = False

    def _get_au_class(self):
        """Кэшируем AndroidUtilities класс"""
        if self._au_class is None:
            self._au_class = find_class("org.telegram.messenger.AndroidUtilities")
        return self._au_class

    def after_hooked_method(self, param):
        try:
            original = param.getResult()
            mode = int(self.plugin.get_setting(CONF_MODE, MODE_OFFSET))
            
            # Режим 0 - "выреза нету" - возвращаем null
            if mode == 0:
                if original is not None:
                    param.setResult(None)
                return
            
            # Режим 1 - смещения
            if mode == 1:
                if original is None:
                    return
                    
                offset_dp = int(self.plugin.get_setting(CONF_OFFSET_Y, "0"))
                if offset_dp == 0:
                    return
                
                # Используем кэшированный класс
                AU = self._get_au_class()
                offset_px = float(AU.dp(float(offset_dp)))
                
                original.bounds.top += offset_px
                original.bounds.bottom += offset_px
                return

            # Режим 2 - Ручной
            if mode == 2:
                # Читаем настройки
                l_str = self.plugin.get_setting(CONF_RECT_L, "0")
                t_str = self.plugin.get_setting(CONF_RECT_T, "0")
                r_str = self.plugin.get_setting(CONF_RECT_R, "0")
                b_str = self.plugin.get_setting(CONF_RECT_B, "0")
                
                AU = self._get_au_class()

                # Авто-определение (если все настройки по нулям)
                if r_str == "0" and not self.detected and original is not None:
                    density = float(AU.density)
                    real_l = int(original.bounds.left / density)
                    real_t = int(original.bounds.top / density)
                    real_r = int(original.bounds.right / density)
                    real_b = int(original.bounds.bottom / density)
                    
                    self.plugin.set_setting(CONF_RECT_L, str(real_l))
                    self.plugin.set_setting(CONF_RECT_T, str(real_t))
                    self.plugin.set_setting(CONF_RECT_R, str(real_r))
                    self.plugin.set_setting(CONF_RECT_B, str(real_b))
                    
                    l_str = str(real_l)
                    t_str = str(real_t)
                    r_str = str(real_r)
                    b_str = str(real_b)
                    self.detected = True
                
                l_dp = int(l_str)
                t_dp = int(t_str)
                r_dp = int(r_str)
                b_dp = int(b_str)

                # Если настройки 0 (после детекта) - используем системное (если есть) или выходим
                if r_dp <= 0 and l_dp <= 0:
                    return

                # Если оригинала нет - создаем
                if original is None:
                    NotchInfo = find_class("org.telegram.messenger.NotchInfoUtils$NotchInfo")
                    RectF = find_class("android.graphics.RectF")
                    original = NotchInfo.newInstance()
                    original.bounds = RectF.newInstance()
                    param.setResult(original)

                # Вычисляем px
                l_px = float(AU.dp(float(l_dp)))
                t_px = float(AU.dp(float(t_dp)))
                r_px = float(AU.dp(float(r_dp)))
                b_px = float(AU.dp(float(b_dp)))

                # Применяем границы
                b = original.bounds
                b.left = l_px
                b.top = t_px
                b.right = r_px
                b.bottom = b_px
                
                # Настройки типа выреза
                original.gravity = 17 # CENTER
                original.isLikelyCircle = True

        except Exception:
            pass
