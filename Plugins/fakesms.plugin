from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_send_messages_helper, get_messages_controller
from org.telegram.tgnet import TLRPC
from java.util import Locale, ArrayList, HashMap
from org.telegram.messenger import MessageObject, MessagesController, NotificationCenter, MessagesStorage, UserConfig
from ui.settings import Header, Input, Switch, Divider, Text
import time
import random
import traceback

__id__ = "fakesms"
__name__ = "Fake SMS"
__version__ = "2.1"
__author__ = "@im_gyd @im_gydik .fakeo by @h_0_b_l"
__description__ = "Расширенный плагин для создания фейковых сообщений.\n" \
                 "Команды:\n" \
                 ".fakeo [id] [сообщение] - отправить от имени другого пользователя (в чате)\n" \
                 ".fakesms [сообщение] - отправить от своего имени\n" \
                 ".fakesms1 [сообщение] - отправить от собеседника\n" \
                 ".fakeclear - очистить фейковые сообщения"
__min_version__ = "11.9.0"
__icon__ = "https://raw.githubusercontent.com/SabmorT/FakeSMS/main/icon.png"

class LocalizationManager:
    language = "en"
    
    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager._get_supported_languages() else "en"
    
    @staticmethod
    def get_string(string):
        return LocalizationManager.strings[LocalizationManager.language].get(string, string)
    
    @staticmethod
    def _get_supported_languages():
        return LocalizationManager.strings.keys()
    
    strings = {
        "ru": {
            "INVALID_FORMAT": "⚠️ Используйте формат:\n.fakeo \"айди\" \"сообщение\"\n.fakesms \"сообщение\"\n.fakesms1 \"сообщение\"",
            "ERROR_CLEARING": "Ошибка при очистке сообщений: {}",
            "ERROR_GENERAL": "Ошибка плагина: {}",
            "SETTINGS_PREFIX_TITLE": "Префиксы команд",
            "SETTINGS_PREFIX_DESC": "Настройка префиксов для команд плагина",
            "SETTINGS_PREFIX_FAKEO": "Префикс для .fakeo",
            "SETTINGS_PREFIX_FAKESMS": "Префикс для .fakesms",
            "SETTINGS_PREFIX_FAKESMS1": "Префикс для .fakesms1",
            "SETTINGS_PREFIX_CLEAR": "Префикс для .fakeclear"
        },
        "en": {
            "INVALID_FORMAT": "⚠️ Use format:\n.fakeo \"id\" \"message\"\n.fakesms \"message\"\n.fakesms1 \"message\"",
            "ERROR_CLEARING": "Error clearing messages: {}",
            "ERROR_GENERAL": "Plugin error: {}",
            "SETTINGS_PREFIX_TITLE": "Command Prefixes",
            "SETTINGS_PREFIX_DESC": "Configure command prefixes for the plugin",
            "SETTINGS_PREFIX_FAKEO": "Prefix for .fakeo",
            "SETTINGS_PREFIX_FAKESMS": "Prefix for .fakesms",
            "SETTINGS_PREFIX_FAKESMS1": "Prefix for .fakesms1",
            "SETTINGS_PREFIX_CLEAR": "Prefix for .fakeclear"
        }
    }

class FakeSMSPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.fake_message_ids = {}
        # Default prefixes
        self.prefixes = {
            "fakeo": ".fakeo",
            "fakesms": ".fakesms",
            "fakesms1": ".fakesms1",
            "clear": ".fakeclear"
        }

    def on_plugin_load(self):
        LocalizationManager.init()
        self.add_on_send_message_hook()
        # Load saved prefixes
        for key in self.prefixes:
            saved_prefix = self.get_setting(f"prefix_{key}")
            if saved_prefix:
                self.prefixes[key] = saved_prefix

    def create_settings(self):
        return [
            Header(text=LocalizationManager.get_string("SETTINGS_PREFIX_TITLE")),
            Divider(),
            Input(
                key="prefix_fakeo",
                text=LocalizationManager.get_string("SETTINGS_PREFIX_FAKEO"),
                default=self.prefixes["fakeo"],
                on_change=lambda value: self._on_prefix_change("fakeo", value)
            ),
            Input(
                key="prefix_fakesms",
                text=LocalizationManager.get_string("SETTINGS_PREFIX_FAKESMS"),
                default=self.prefixes["fakesms"],
                on_change=lambda value: self._on_prefix_change("fakesms", value)
            ),
            Input(
                key="prefix_fakesms1",
                text=LocalizationManager.get_string("SETTINGS_PREFIX_FAKESMS1"),
                default=self.prefixes["fakesms1"],
                on_change=lambda value: self._on_prefix_change("fakesms1", value)
            ),
            Input(
                key="prefix_clear",
                text=LocalizationManager.get_string("SETTINGS_PREFIX_CLEAR"),
                default=self.prefixes["clear"],
                on_change=lambda value: self._on_prefix_change("clear", value)
            )
        ]

    def _on_prefix_change(self, key, value):
        if value:
            self.prefixes[key] = value
            self.set_setting(f"prefix_{key}", value)

    def clear_fake_messages(self, account, params):
        try:
            messages_controller = get_messages_controller()
            chat_messages_ids = self.fake_message_ids.get(params.peer, [])
            dialog_messages = messages_controller.dialogMessage.get(params.peer)
            
            if dialog_messages:
                to_remove = []
                
                # Collect messages by id
                for i in range(dialog_messages.size() - 1, -1, -1):
                    msg = dialog_messages.get(i)
                    if msg.getId() in chat_messages_ids:
                        to_remove.append(msg)
                        dialog_messages.remove(i)
                
                # Remove from dialogMessagesByIds
                for msg_id in chat_messages_ids:
                    messages_controller.dialogMessagesByIds.remove(msg_id)
                
                # Update interface
                if to_remove:
                    history_array = ArrayList()
                    for msg in to_remove:
                        history_array.add(msg)
                    messages_controller.updateInterfaceWithMessages(params.peer, history_array, 1)
                
                # Clear from storage
                MessagesStorage.getInstance(account).deleteMessages(chat_messages_ids, False, params.peer)
                self.fake_message_ids[params.peer] = []
                NotificationCenter.getInstance(account).postNotificationName(NotificationCenter.dialogsNeedReload)
            
            return True
        except Exception as e:
            self.log(f"Error in clear_fake_messages: {str(e)}\n{traceback.format_exc()}")
            return False

    def create_fake_message(self, account, params, content, is_from_other, target_user_id=None):
        current_time = int(time.time())
        fake_message = TLRPC.TL_message()
        fake_message.date = current_time
        fake_message.message = content
        fake_message.id = UserConfig.getInstance(account).getNewMessageId()
        UserConfig.getInstance(account).saveConfig(False)
        
        if params.peer not in self.fake_message_ids:
            self.fake_message_ids[params.peer] = []
        self.fake_message_ids[params.peer].append(fake_message.id)
        
        fake_message.dialog_id = params.peer
        fake_message.out = not is_from_other
        fake_message.unread = True
        
        # Handle media if present
        if hasattr(params, 'photo') and params.photo and isinstance(params.photo, TLRPC.Photo):
            media = TLRPC.TL_messageMediaPhoto()
            media.photo = params.photo
            if hasattr(params, 'hasMediaSpoilers') and params.hasMediaSpoilers:
                media.has_spoiler = True
            fake_message.media = media
        elif hasattr(params, 'document') and params.document and isinstance(params.document, TLRPC.Document):
            media = TLRPC.TL_messageMediaDocument()
            media.document = params.document
            if hasattr(params, 'hasMediaSpoilers') and params.hasMediaSpoilers:
                media.has_spoiler = True
            fake_message.media = media
            
        current_flags = 256 | (2 if not is_from_other else 0)
        if fake_message.media is not None:
            current_flags |= 512
        fake_message.flags = current_flags
        
        # Set from_id and peer_id
        if is_from_other:
            from_peer = TLRPC.TL_peerUser()
            from_peer.user_id = target_user_id if target_user_id else params.peer
            fake_message.from_id = from_peer
            
            to_peer = TLRPC.TL_peerUser()
            to_peer.user_id = params.peer if target_user_id else account
            fake_message.peer_id = to_peer
        else:
            from_peer = TLRPC.TL_peerUser()
            from_peer.user_id = account
            fake_message.from_id = from_peer
            
            if params.peer < 0:
                peer_obj = TLRPC.TL_peerChat()
                peer_obj.chat_id = -params.peer
            else:
                peer_obj = TLRPC.TL_peerUser()
                peer_obj.user_id = params.peer
            fake_message.peer_id = peer_obj
            
        return fake_message

    def on_send_message_hook(self, account, params) -> HookResult:
        message_text = ""
        is_originally_text_message = isinstance(params.message, str)

        if is_originally_text_message:
            message_text = params.message.strip()
        elif hasattr(params, 'caption') and isinstance(params.caption, str):
            message_text = params.caption.strip()
        else:
            return HookResult()

        if not message_text:
            return HookResult()
            
        message = message_text

        if message.startswith(self.prefixes["clear"]):
            if self.clear_fake_messages(account, params):
                return HookResult(strategy=HookStrategy.CANCEL)
            else:
                get_send_messages_helper().sendMessage(
                    LocalizationManager.get_string("ERROR_CLEARING").format(str(e)),
                    params.peer, None, None, True, None, None, None, True, 0
                )
                return HookResult(strategy=HookStrategy.CANCEL)

        try:
            is_legacy_command = message.startswith((self.prefixes["fakesms"], self.prefixes["fakesms1"]))
            is_new_command = message.startswith(self.prefixes["fakeo"])
            
            if not (is_legacy_command or is_new_command):
                return HookResult()

            is_from_other = message.startswith((self.prefixes["fakesms1"], self.prefixes["fakeo"]))
            command = None
            content = None
            target_user_id = None

            if is_legacy_command:
                command = self.prefixes["fakesms1"] if is_from_other else self.prefixes["fakesms"]
                content = message[len(command):].strip()
            else:
                command = self.prefixes["fakeo"]
                content = message[len(command):].strip()
                args = content.split(" ", 1)
                if len(args) < 2 or not args[0].isdigit():
                    get_send_messages_helper().sendMessage(
                        LocalizationManager.get_string("INVALID_FORMAT"),
                        params.peer, None, None, True, None, None, None, True, 0
                    )
                    return HookResult(strategy=HookStrategy.CANCEL)
                target_user_id = int(args[0])
                content = args[1]

            if not content.strip():
                get_send_messages_helper().sendMessage(
                    LocalizationManager.get_string("INVALID_FORMAT"),
                    params.peer, None, None, True, None, None, None, True, 0
                )
                return HookResult(strategy=HookStrategy.CANCEL)

            fake_message = self.create_fake_message(account, params, content, is_from_other, target_user_id)
            message_object = MessageObject(account, fake_message, False, True)
            
            mc = get_messages_controller()
            arr = ArrayList()
            arr.add(message_object)
            
            current_dialog_messages = mc.dialogMessage.get(params.peer)
            if current_dialog_messages is None:
                current_dialog_messages = ArrayList()
                mc.dialogMessage.put(params.peer, current_dialog_messages)
            current_dialog_messages.add(0, message_object)
            
            mc.dialogMessagesByIds.put(fake_message.id, message_object)
            
            hist_arr = ArrayList()
            hist_arr.add(message_object)
            
            store_arr = ArrayList()
            store_arr.add(fake_message)
            
            MessagesStorage.getInstance(account).putMessages(store_arr, True, True, False, 1, 0, 0)
            mc.updateInterfaceWithMessages(params.peer, hist_arr, 0)
            
            self.log(f"FakeSMS: Message created with ID {fake_message.id} (media: {fake_message.media is not None})")
            return HookResult(strategy=HookStrategy.CANCEL)
            
        except Exception as e:
            error_message = f"{type(e).__name__} - {str(e)}"
            self.log(f"Error in FakeSMS: {error_message}\n{traceback.format_exc()}")
            get_send_messages_helper().sendMessage(
                LocalizationManager.get_string("ERROR_GENERAL").format(error_message[:100]),
                params.peer, None, None, True, None, None, None, True, 0
            )
            return HookResult(strategy=HookStrategy.CANCEL) 
