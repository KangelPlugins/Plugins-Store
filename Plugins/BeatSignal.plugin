import os
import time
import math
import threading
from dataclasses import dataclass
from typing import Any, List, Optional, Tuple

from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment, run_on_queue
from android_utils import run_on_ui_thread
from hook_utils import get_private_field, set_private_field, log as _log, find_class

from java import dynamic_proxy
from java.lang import Class, Runnable
from java.io import File, FileOutputStream, ByteArrayOutputStream

from android.app import Activity
from android.os import Handler, Looper, Build
from android.view import View, ViewGroup, Gravity
from android.widget import FrameLayout, LinearLayout, TextView, ImageView, EditText
from android.graphics import Color
from android.graphics.drawable import GradientDrawable
from android.content import ContextWrapper, Intent, Context
from android.net import Uri
from android.media import MediaPlayer, MediaExtractor, MediaCodec

from org.telegram.messenger import ApplicationLoader, AndroidUtilities

try:
    from ui.settings import Header, Text as SettingsText, Divider
except Exception:
    Header = None
    SettingsText = None
    Divider = None


__id__ = "beatsignal"
__name__ = "BeatSignal"
__description__ = "–°–¥–µ–ª–∞–µ—Ç –∏–∑ –≤–∞—à–µ–≥–æ –Ω–µ –°–≤–µ—Ç—è—à–∫–µ —Å–∞–º—ã–π –Ω–∞—Å—Ç–æ—è—â–∏–π –°–≤–µ—Ç—è—â–∫–µ"
__icon__ = "RoflPlugins/13"
__version__ = "2.0.0"
__author__ = "@RoflPlugins"
__min_version__ = "12.0.1"

ENTRY_BTN_TAG = "BEATSIGNAL_ENTRY_BTN"
PANEL_TAG = "BEATSIGNAL_FULLSCREEN_PANEL"
STATE_KEY_VISIBLE = "_beatsignal_visible"

C_BG = Color.parseColor("#050816")
C_PANEL = Color.parseColor("#0B1020")
C_FIELD = Color.parseColor("#0F172A")
C_DIM = Color.parseColor("#94A3B8")
C_TEXT = Color.parseColor("#E5E7EB")
C_ACC = Color.parseColor("#3B82F6")
C_BTN = Color.parseColor("#111827")
C_BTN2 = Color.parseColor("#1F2937")

ANALYZE_MAX_SECONDS = 600

WAVE_FRAME_MS_DEFAULT = 18
WAVE_GATE_DEFAULT = 2.06
WAVE_SENS_DEFAULT = 1.00
WAVE_CAP_DEFAULT = 1.00
WAVE_LATENCY_DEFAULT = -10

WAVE_TICK_MS = 16
VIB_PULSE_MS = 18
VIB_MIN_AMP = 1
VIB_GAMMA = 1.15

PWM_CYCLE_MS = 60
PWM_MIN_DUTY = 0.02


def logcat(m: Any):
    _log(f"[{__id__}] {m}")


def _dp(v: float) -> int:
    try:
        return int(AndroidUtilities.dp(float(v)))
    except Exception:
        return int(v)


def make_round_bg(color: int, radius_dp: int) -> GradientDrawable:
    d = GradientDrawable()
    d.setColor(color)
    d.setCornerRadius(float(_dp(radius_dp)))
    return d


def unwrap_activity(ctx) -> Optional[Any]:
    try:
        c = ctx
        for _ in range(16):
            if c is None:
                break
            try:
                n = c.getClass().getName()
                if "Activity" in n:
                    return c
            except Exception:
                pass
            try:
                if isinstance(c, ContextWrapper):
                    c = c.getBaseContext()
                    continue
            except Exception:
                pass
            break
    except Exception:
        pass
    return None


def get_activity_content_root(activity) -> Optional[Any]:
    try:
        win = activity.getWindow()
        decor = win.getDecorView()
        content = decor.findViewById(16908290)
        if content and isinstance(content, ViewGroup):
            return content
        if isinstance(decor, ViewGroup):
            return decor
    except Exception as e:
        logcat(f"get_activity_content_root error: {e}")
    return None


def ensure_fullscreen_panel(activity) -> Optional[FrameLayout]:
    root = get_activity_content_root(activity)
    if not root:
        return None

    try:
        for i in range(root.getChildCount()):
            ch = root.getChildAt(i)
            if ch and str(ch.getTag()) == PANEL_TAG:
                return ch
    except Exception:
        pass

    panel = FrameLayout(activity)
    panel.setTag(PANEL_TAG)
    panel.setVisibility(View.GONE)
    panel.setClickable(True)
    panel.setFocusable(True)
    panel.setBackgroundColor(C_BG)
    lp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)
    panel.setLayoutParams(lp)

    class EatAll(dynamic_proxy(View.OnTouchListener)):
        def onTouch(self, v, event):
            try:
                v.requestDisallowInterceptTouchEvent(True)
            except Exception:
                pass
            return True

    panel.setOnTouchListener(EatAll())
    root.addView(panel)
    panel.bringToFront()
    panel.invalidate()
    return panel


def set_panel_visible(activity, visible: bool):
    root = get_activity_content_root(activity)
    if not root:
        return
    panel = None
    for i in range(root.getChildCount()):
        ch = root.getChildAt(i)
        if ch and str(ch.getTag()) == PANEL_TAG:
            panel = ch
            break
    if panel:
        panel.setVisibility(View.VISIBLE if visible else View.GONE)
        panel.bringToFront()
        panel.invalidate()


def _get_res_id_drawable(name: str) -> Optional[int]:
    try:
        r_drawable = Class.forName("org.telegram.messenger.R$drawable")
        field = r_drawable.getField(name)
        return int(field.getInt(None))
    except Exception:
        return None


def _get_drawable(res_id: int):
    try:
        ctx = ApplicationLoader.applicationContext
        res = ctx.getResources()
        try:
            return res.getDrawable(res_id, None)
        except Exception:
            return res.getDrawable(res_id)
    except Exception:
        return None


def get_music_drawable():
    for n in ["msg_music", "msg_audio", "msg_voice", "msg_mic", "ic_music", "ic_mic"]:
        rid = _get_res_id_drawable(n)
        if rid:
            d = _get_drawable(rid)
            if d:
                return d
    return None


def _clamp(x: float, a: float, b: float) -> float:
    return a if x < a else b if x > b else x


def _clamp01(x: float) -> float:
    return _clamp(x, 0.0, 1.0)


def _percentile(xs: List[float], p: float) -> float:
    if not xs:
        return 0.0
    ys = sorted(xs)
    p = _clamp01(p)
    idx = int(round((len(ys) - 1) * p))
    return float(ys[idx])


def _soft_clip(x: float) -> float:
    return math.tanh(max(0.0, x))


class _Haptics:
    def __init__(self, ctx, view):
        self.ctx = ctx
        self.view = view
        self.Build_VERSION = find_class("android.os.Build$VERSION")
        self.VibrationEffect = find_class("android.os.VibrationEffect")
        self.Context = find_class("android.content.Context")
        self.HFC = find_class("android.view.HapticFeedbackConstants")
        self.vib = None

        try:
            if self.Context and hasattr(self.Context, "VIBRATOR_SERVICE"):
                self.vib = ctx.getSystemService(self.Context.VIBRATOR_SERVICE)
        except Exception as e:
            logcat(f"vib VIBRATOR_SERVICE err: {e}")

        if not self.vib:
            try:
                self.vib = ctx.getSystemService("vibrator")
            except Exception as e:
                logcat(f"vib 'vibrator' err: {e}")

    def _kind(self, name: str, default_val: int) -> int:
        try:
            if self.HFC and hasattr(self.HFC, name):
                return int(getattr(self.HFC, name))
        except Exception:
            pass
        return int(default_val)

    def haptic(self, kind_name="KEYBOARD_TAP", fallback_int=3) -> bool:
        try:
            k = self._kind(kind_name, fallback_int)
            self.view.performHapticFeedback(int(k), 3)
            return True
        except Exception:
            try:
                AU = find_class("org.telegram.messenger.AndroidUtilities")
                if AU:
                    AU.vibrate(self.view)
                    return True
            except Exception:
                pass
        return False

    def oneshot(self, ms: int, amp: int) -> bool:
        if not self.vib:
            return False
        try:
            sdk = 0
            try:
                sdk = int(getattr(self.Build_VERSION, "SDK_INT", 0))
            except Exception:
                sdk = 0

            if sdk >= 26 and self.VibrationEffect:
                try:
                    self.vib.vibrate(self.VibrationEffect.createOneShot(int(ms), int(_clamp(amp, 1, 255))))
                    return True
                except Exception:
                    try:
                        self.vib.vibrate(self.VibrationEffect.createOneShot(int(ms), -1))
                        return True
                    except Exception:
                        pass

            self.vib.vibrate(int(ms))
            return True
        except Exception as e:
            logcat(f"vibrate oneshot err: {e}")
            return False


@dataclass
class WaveEnvelope:
    frame_ms: int
    duration_ms: int
    amp01: List[float]


def _extract_rms_envelope(path: str, frame_ms: int, max_seconds: int) -> Tuple[List[float], int, int]:
    extractor = MediaExtractor()
    extractor.setDataSource(path)

    track_index = -1
    fmt = None
    mime = None
    dur_us = 0

    for i in range(extractor.getTrackCount()):
        f = extractor.getTrackFormat(i)
        m = f.getString("mime")
        if m and m.startswith("audio/"):
            track_index = i
            fmt = f
            mime = m
            try:
                dur_us = int(f.getLong("durationUs"))
            except Exception:
                dur_us = 0
            break

    if track_index < 0 or fmt is None or mime is None:
        raise Exception("audio track not found")

    extractor.selectTrack(track_index)
    codec = MediaCodec.createDecoderByType(mime)
    codec.configure(fmt, None, None, 0)
    codec.start()

    sample_rate = 44100
    channels = 1
    try:
        sample_rate = int(fmt.getInteger("sample-rate"))
    except Exception:
        pass
    try:
        channels = int(fmt.getInteger("channel-count"))
    except Exception:
        pass

    win_samples = int(max(256, min(4096, round(sample_rate * (frame_ms / 1000.0)))))
    frame_ms_real = int(round(1000.0 * win_samples / float(sample_rate)))
    frame_ms_real = max(10, frame_ms_real)

    max_us = max_seconds * 1_000_000

    rms_list: List[float] = []
    pcm_acc = bytearray()
    info = MediaCodec.BufferInfo()
    eos = False

    while True:
        if not eos:
            in_idx = codec.dequeueInputBuffer(10_000)
            if in_idx >= 0:
                in_buf = codec.getInputBuffer(in_idx)
                in_buf.clear()
                sz = extractor.readSampleData(in_buf, 0)
                if sz < 0 or (dur_us and extractor.getSampleTime() > max_us):
                    codec.queueInputBuffer(in_idx, 0, 0, 0, MediaCodec.BUFFER_FLAG_END_OF_STREAM)
                    eos = True
                else:
                    t = extractor.getSampleTime()
                    codec.queueInputBuffer(in_idx, 0, sz, t, 0)
                    extractor.advance()

        out_idx = codec.dequeueOutputBuffer(info, 10_000)
        if out_idx >= 0:
            out_buf = codec.getOutputBuffer(out_idx)
            if out_buf is not None and info.size > 0:
                data = bytearray(info.size)
                out_buf.get(data, 0, info.size)
                pcm_acc.extend(data)

                frame_bytes = win_samples * channels * 2
                while len(pcm_acc) >= frame_bytes:
                    chunk = pcm_acc[:frame_bytes]
                    del pcm_acc[:frame_bytes]

                    ssum = 0.0
                    count = 0
                    for j in range(0, len(chunk), 2):
                        v = chunk[j] | (chunk[j + 1] << 8)
                        if v >= 32768:
                            v -= 65536
                        ssum += float(v * v)
                        count += 1

                    if count > 0:
                        rms = math.sqrt(ssum / float(count)) / 32768.0
                        rms_list.append(rms)

            codec.releaseOutputBuffer(out_idx, False)
            if (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0:
                break
        elif out_idx == MediaCodec.INFO_TRY_AGAIN_LATER:
            if eos:
                break

    try:
        codec.stop()
        codec.release()
    except Exception:
        pass
    try:
        extractor.release()
    except Exception:
        pass

    duration_ms = int(dur_us / 1000) if dur_us else (len(rms_list) * frame_ms_real)
    duration_ms = int(min(duration_ms, max_seconds * 1000))
    return rms_list, frame_ms_real, duration_ms


def build_wave_envelope(path: str, frame_ms: int, max_seconds: int, sens: float, gate: float, cap: float) -> WaveEnvelope:
    rms, frame_ms_real, duration_ms = _extract_rms_envelope(path, frame_ms=frame_ms, max_seconds=max_seconds)
    if not rms:
        return WaveEnvelope(frame_ms=frame_ms_real, duration_ms=duration_ms, amp01=[])

    sens = _clamp(float(sens), 0.2, 3.0)
    gate = _clamp(float(gate), 0.0, 0.6)
    cap = _clamp(float(cap), 0.10, 1.0)

    comp: List[float] = []
    for v in rms:
        v = math.sqrt(max(0.0, v))
        v = math.log1p(v * 12.0)
        comp.append(v)

    p10 = _percentile(comp, 0.10)
    p98 = _percentile(comp, 0.98)
    denom = max(1e-6, (p98 - p10))

    out: List[float] = []
    env = 0.0

    attack = 0.035
    release = 0.120
    dt = frame_ms_real / 1000.0
    a_att = 1.0 - math.exp(-dt / max(1e-3, attack))
    a_rel = 1.0 - math.exp(-dt / max(1e-3, release))

    for v in comp:
        x = (v - p10) / denom
        x = _clamp01(x)
        x = _soft_clip(x * sens)
        if x < gate:
            x = 0.0
        x = min(cap, x)

        if x > env:
            env = env + a_att * (x - env)
        else:
            env = env + a_rel * (x - env)

        out.append(_clamp01(env))

    return WaveEnvelope(frame_ms=frame_ms_real, duration_ms=duration_ms, amp01=out)


class _Torch:
    def __init__(self):
        self.cam_mgr = None
        self.torch_id = None
        self.torch_on = False

        self.support_strength = False
        self.max_strength = 0
        self._m_turn_on_strength = None

        self._pwm_phase = 0
        self._pwm_last_ms = 0
        self._pwm_duty = 0.0

        try:
            ctx = ApplicationLoader.applicationContext
            self.cam_mgr = ctx.getSystemService(Context.CAMERA_SERVICE)
        except Exception:
            self.cam_mgr = None

        if not self.cam_mgr:
            return

        try:
            CameraCharacteristics = find_class("android.hardware.camera2.CameraCharacteristics")
            key = CameraCharacteristics.FLASH_INFO_AVAILABLE
            for cid in self.cam_mgr.getCameraIdList():
                try:
                    cc = self.cam_mgr.getCameraCharacteristics(cid)
                    ok = cc.get(key)
                    if bool(ok):
                        self.torch_id = cid
                        break
                except Exception:
                    pass
        except Exception:
            pass

        try:
            if int(getattr(Build.VERSION, "SDK_INT", 0)) >= 33:
                m = self.cam_mgr.getClass().getMethod(
                    "turnOnTorchWithStrengthLevel",
                    Class.forName("java.lang.String"),
                    int
                )
                self._m_turn_on_strength = m
                try:
                    CameraCharacteristics = find_class("android.hardware.camera2.CameraCharacteristics")
                    key2 = getattr(CameraCharacteristics, "FLASH_INFO_STRENGTH_MAXIMUM_LEVEL", None)
                    if key2 and self.torch_id:
                        cc = self.cam_mgr.getCameraCharacteristics(self.torch_id)
                        mx = cc.get(key2)
                        if mx is not None:
                            self.max_strength = int(mx)
                            if self.max_strength > 1:
                                self.support_strength = True
                except Exception:
                    self.max_strength = 5
                    self.support_strength = True
        except Exception:
            self.support_strength = False
            self._m_turn_on_strength = None

    def is_available(self) -> bool:
        return bool(self.cam_mgr and self.torch_id)

    def off(self):
        if not self.is_available():
            return
        try:
            if self.torch_on:
                self.cam_mgr.setTorchMode(self.torch_id, False)
            self.torch_on = False
        except Exception:
            self.torch_on = False

    def on(self):
        if not self.is_available():
            return
        try:
            self.cam_mgr.setTorchMode(self.torch_id, True)
            self.torch_on = True
        except Exception:
            self.torch_on = False

    def set_strength01(self, a01: float):
        if not self.is_available():
            return
        a01 = _clamp01(float(a01))
        self._pwm_duty = a01

        if a01 <= 0.0:
            self.off()
            return

        if self.support_strength and self._m_turn_on_strength:
            mx = max(1, int(self.max_strength or 5))
            level = int(max(1, min(mx, round(1 + (mx - 1) * a01))))
            try:
                self._m_turn_on_strength.invoke(self.cam_mgr, self.torch_id, int(level))
                self.torch_on = True
                return
            except Exception:
                self.support_strength = False

        if not self.torch_on:
            self.on()

    def tick_pwm(self, now_ms: int):
        if not self.is_available() or self.support_strength:
            return

        duty = float(self._pwm_duty)
        duty = _clamp01(duty)

        if duty <= 0.0:
            self.off()
            return

        if duty < PWM_MIN_DUTY:
            duty = PWM_MIN_DUTY

        if self._pwm_last_ms == 0:
            self._pwm_last_ms = now_ms

        dt = now_ms - self._pwm_last_ms
        if dt < 0:
            dt = 0
        self._pwm_last_ms = now_ms

        self._pwm_phase = (self._pwm_phase + dt) % PWM_CYCLE_MS
        on_ms = int(round(PWM_CYCLE_MS * duty))
        want_on = self._pwm_phase < on_ms

        try:
            if want_on and not self.torch_on:
                self.cam_mgr.setTorchMode(self.torch_id, True)
                self.torch_on = True
            elif (not want_on) and self.torch_on:
                self.cam_mgr.setTorchMode(self.torch_id, False)
                self.torch_on = False
        except Exception:
            self.torch_on = False


class BeatSignalRuntime:
    def __init__(self, ctx, panel: FrameLayout, plugin: "Plugin", activity):
        self.ctx = ctx
        self.panel = panel
        self.plugin = plugin
        self.activity = activity
        self.handler = Handler(Looper.getMainLooper())

        self.music_path: str = ""
        self.media: Optional[MediaPlayer] = None

        self.running = False
        self.wave_env: Optional[WaveEnvelope] = None

        self.enable_vib = True
        self.enable_flash = True

        self.wave_frame_ms = int(WAVE_FRAME_MS_DEFAULT)
        self.wave_gate = float(WAVE_GATE_DEFAULT)
        self.wave_sens = float(WAVE_SENS_DEFAULT)
        self.wave_cap = float(WAVE_CAP_DEFAULT)
        self.wave_latency_ms = int(WAVE_LATENCY_DEFAULT)

        self.hapt: Optional[_Haptics] = None
        self.torch = _Torch()

        self.txt_status: Optional[TextView] = None
        self.txt_track: Optional[TextView] = None
        self.txt_stats: Optional[TextView] = None

        self.btn_close: Optional[TextView] = None
        self.btn_pick: Optional[TextView] = None
        self.btn_analyze: Optional[TextView] = None
        self.btn_start: Optional[TextView] = None
        self.btn_stop: Optional[TextView] = None

        self.tog_vib: Optional[TextView] = None
        self.tog_flash: Optional[TextView] = None

        self.inp_frame: Optional[EditText] = None
        self.inp_gate: Optional[EditText] = None
        self.inp_sens: Optional[EditText] = None
        self.inp_cap: Optional[EditText] = None
        self.inp_lat: Optional[EditText] = None

        self._old_ui_flags = None
        self._on_close = None

    def build_ui(self):
        self.panel.removeAllViews()
        self.panel.setBackgroundColor(C_BG)

        self.hapt = _Haptics(self.panel.getContext(), self.panel)

        try:
            sb = int(getattr(AndroidUtilities, "statusBarHeight", 0) or 0)
        except Exception:
            sb = 0
        top_safe = sb + _dp(8)

        top = LinearLayout(self.ctx)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        top.setPadding(_dp(14), top_safe, _dp(14), _dp(10))
        top.setBackground(make_round_bg(C_PANEL, 0))
        tlp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        tlp.gravity = Gravity.TOP
        top.setLayoutParams(tlp)

        title = TextView(self.ctx)
        title.setText("üîä BeatSignal ‚Äî RoflPlugins")
        title.setTextSize(17)
        title.setTextColor(Color.WHITE)
        t_lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT)
        t_lp.weight = 1.0
        title.setLayoutParams(t_lp)

        self.btn_close = TextView(self.ctx)
        self.btn_close.setText("‚úï")
        self.btn_close.setTextSize(16)
        self.btn_close.setTextColor(Color.WHITE)
        self.btn_close.setPadding(_dp(12), _dp(8), _dp(12), _dp(8))
        self.btn_close.setBackground(make_round_bg(C_BTN2, 14))

        top.addView(title)
        top.addView(self.btn_close)

        self.txt_status = TextView(self.ctx)
        self.txt_status.setText("Pick ‚Üí Analyze ‚Üí Start")
        self.txt_status.setTextSize(12)
        self.txt_status.setTextColor(C_DIM)
        slp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        slp.topMargin = top_safe + _dp(52)
        slp.leftMargin = _dp(14)
        slp.rightMargin = _dp(14)
        self.txt_status.setLayoutParams(slp)

        card = LinearLayout(self.ctx)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(_dp(14), _dp(14), _dp(14), _dp(14))
        card.setBackground(make_round_bg(C_FIELD, 18))
        clp = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        clp.topMargin = top_safe + _dp(86)
        clp.leftMargin = _dp(12)
        clp.rightMargin = _dp(12)
        card.setLayoutParams(clp)

        self.txt_track = TextView(self.ctx)
        self.txt_track.setText("Track: (none)")
        self.txt_track.setTextSize(14)
        self.txt_track.setTextColor(C_TEXT)

        self.txt_stats = TextView(self.ctx)
        self.txt_stats.setText("‚Äî")
        self.txt_stats.setTextSize(13)
        self.txt_stats.setTextColor(C_DIM)
        self.txt_stats.setPadding(0, _dp(6), 0, 0)

        card.addView(self.txt_track)
        card.addView(self.txt_stats)

        def pill(text: str, accent: bool) -> TextView:
            b = TextView(self.ctx)
            b.setText(text)
            b.setTextSize(14)
            b.setGravity(Gravity.CENTER)
            b.setPadding(_dp(12), _dp(10), _dp(12), _dp(10))
            if accent:
                b.setBackground(make_round_bg(C_ACC, 14))
                b.setTextColor(Color.WHITE)
            else:
                b.setBackground(make_round_bg(C_BTN, 14))
                b.setTextColor(C_TEXT)
            lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp.weight = 1.0
            lp.leftMargin = _dp(6)
            lp.rightMargin = _dp(6)
            b.setLayoutParams(lp)
            return b

        btns = LinearLayout(self.ctx)
        btns.setOrientation(LinearLayout.HORIZONTAL)
        btns.setGravity(Gravity.CENTER)
        btns.setPadding(0, _dp(12), 0, 0)

        self.btn_pick = pill("Pick", False)
        self.btn_analyze = pill("Analyze", True)
        self.btn_start = pill("Start", True)
        self.btn_stop = pill("Stop", False)

        btns.addView(self.btn_pick)
        btns.addView(self.btn_analyze)
        btns.addView(self.btn_start)
        btns.addView(self.btn_stop)
        card.addView(btns)

        def toggle_btn(label: str, on: bool) -> TextView:
            b = TextView(self.ctx)
            b.setText(label + ("ON" if on else "OFF"))
            b.setTextSize(13)
            b.setGravity(Gravity.CENTER)
            b.setPadding(_dp(12), _dp(8), _dp(12), _dp(8))
            b.setBackground(make_round_bg(C_ACC if on else C_BTN, 14))
            b.setTextColor(Color.WHITE if on else C_TEXT)
            lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp.weight = 1.0
            lp.leftMargin = _dp(6)
            lp.rightMargin = _dp(6)
            b.setLayoutParams(lp)
            return b

        togg = LinearLayout(self.ctx)
        togg.setOrientation(LinearLayout.HORIZONTAL)
        togg.setGravity(Gravity.CENTER)
        togg.setPadding(0, _dp(12), 0, 0)

        self.tog_vib = toggle_btn("Vibration: ", True)
        self.tog_flash = toggle_btn("Flash: ", True)

        togg.addView(self.tog_vib)
        togg.addView(self.tog_flash)
        card.addView(togg)

        def label(t: str) -> TextView:
            tv = TextView(self.ctx)
            tv.setText(t)
            tv.setTextSize(12)
            tv.setTextColor(C_DIM)
            tv.setPadding(0, _dp(10), 0, _dp(4))
            return tv

        def input_box(hint: str, value: str) -> EditText:
            e = EditText(self.ctx)
            e.setHint(hint)
            e.setText(value)
            e.setTextColor(Color.WHITE)
            e.setHintTextColor(C_DIM)
            e.setBackground(make_round_bg(C_BTN, 14))
            e.setPadding(_dp(12), _dp(10), _dp(12), _dp(10))
            return e

        card.addView(label("Wave settings"))
        row1 = LinearLayout(self.ctx)
        row1.setOrientation(LinearLayout.HORIZONTAL)
        row2 = LinearLayout(self.ctx)
        row2.setOrientation(LinearLayout.HORIZONTAL)
        row3 = LinearLayout(self.ctx)
        row3.setOrientation(LinearLayout.HORIZONTAL)

        lp2 = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp2.weight = 1.0
        lp2.leftMargin = _dp(6)
        lp2.rightMargin = _dp(6)

        self.inp_frame = input_box("frame ms (18..28)", str(self.wave_frame_ms))
        self.inp_gate = input_box("gate (0..0.3)", f"{self.wave_gate:.2f}")
        self.inp_sens = input_box("sens (0.2..3.0)", f"{self.wave_sens:.2f}")
        self.inp_cap = input_box("cap (0.3..1.0)", f"{self.wave_cap:.2f}")
        self.inp_lat = input_box("latency ms", str(self.wave_latency_ms))

        self.inp_frame.setLayoutParams(lp2)
        self.inp_gate.setLayoutParams(lp2)
        self.inp_sens.setLayoutParams(lp2)
        self.inp_cap.setLayoutParams(lp2)
        self.inp_lat.setLayoutParams(lp2)

        row1.addView(self.inp_frame)
        row1.addView(self.inp_gate)
        row2.addView(self.inp_sens)
        row2.addView(self.inp_cap)
        row3.addView(self.inp_lat)

        card.addView(row1)
        card.addView(row2)
        card.addView(row3)

        hint = TextView(self.ctx)
        hint.setText(
            "‚Ä¢ –Ø —É–∂–µ –≤—ã—Å—Ç–∞–≤–∏–ª —Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –Ω–æ –µ—Å–ª–∏ —Ç–µ–±—è —ç—Ç–æ –≤–æ–∑–±—É–∂–¥–∞–µ—Ç - –º–æ–∂–µ—à—å –ø–æ—Ç—Ä–æ–≥–∞—Ç—å.\n"
        )
        hint.setTextSize(11)
        hint.setTextColor(C_DIM)
        hint.setPadding(0, _dp(10), 0, 0)
        card.addView(hint)

        self.panel.addView(top)
        self.panel.addView(self.txt_status)
        self.panel.addView(card)

        self._wire_buttons()
        self._update_labels()
        self._apply_immersive(True)

        try:
            self.hapt.haptic("KEYBOARD_TAP", 3)
        except Exception:
            pass

    def _apply_immersive(self, enable: bool):
        try:
            decor = self.activity.getWindow().getDecorView()
            if enable:
                try:
                    self._old_ui_flags = int(decor.getSystemUiVisibility())
                except Exception:
                    self._old_ui_flags = None
                flags = 0
                for name in [
                    "SYSTEM_UI_FLAG_LAYOUT_STABLE",
                    "SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION",
                    "SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN",
                    "SYSTEM_UI_FLAG_HIDE_NAVIGATION",
                    "SYSTEM_UI_FLAG_FULLSCREEN",
                    "SYSTEM_UI_FLAG_IMMERSIVE_STICKY",
                ]:
                    try:
                        ViewClass = Class.forName("android.view.View")
                        flags |= int(ViewClass.getField(name).getInt(None))
                    except Exception:
                        pass
                decor.setSystemUiVisibility(flags)
            else:
                if self._old_ui_flags is not None:
                    decor.setSystemUiVisibility(int(self._old_ui_flags))
        except Exception:
            pass

    def _wire_buttons(self):
        rt = self

        class CloseClick(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt.stop()
                rt._apply_immersive(False)
                try:
                    rt.torch.off()
                except Exception:
                    pass
                if rt._on_close:
                    rt._on_close()

        class PickClick(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt.plugin.launch_music_picker()

        class AnalyzeClick(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt._read_inputs()
                rt._analyze()

        class StartClick(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt._read_inputs()
                rt.start()

        class StopClick(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt.stop()

        class TogV(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt.enable_vib = not rt.enable_vib
                rt._update_toggle_styles()

        class TogF(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                rt.enable_flash = not rt.enable_flash
                rt._update_toggle_styles()

        self.btn_close.setOnClickListener(CloseClick())
        self.btn_pick.setOnClickListener(PickClick())
        self.btn_analyze.setOnClickListener(AnalyzeClick())
        self.btn_start.setOnClickListener(StartClick())
        self.btn_stop.setOnClickListener(StopClick())
        self.tog_vib.setOnClickListener(TogV())
        self.tog_flash.setOnClickListener(TogF())
        self._update_toggle_styles()

    def _update_toggle_styles(self):
        def setbtn(b: TextView, on: bool, label: str):
            b.setText(label + ("ON" if on else "OFF"))
            b.setBackground(make_round_bg(C_ACC if on else C_BTN, 14))
            b.setTextColor(Color.WHITE if on else C_TEXT)

        if self.tog_vib:
            setbtn(self.tog_vib, self.enable_vib, "Vibration: ")
        if self.tog_flash:
            setbtn(self.tog_flash, self.enable_flash, "Flash: ")

    def _read_inputs(self):
        def geti(e: EditText, default: int, lo: int, hi: int) -> int:
            try:
                v = int(float(str(e.getText().toString()).strip()))
                return max(lo, min(hi, v))
            except Exception:
                return default

        def getf(e: EditText, default: float, lo: float, hi: float) -> float:
            try:
                v = float(str(e.getText().toString()).strip())
                return max(lo, min(hi, v))
            except Exception:
                return default

        if self.inp_frame:
            self.wave_frame_ms = geti(self.inp_frame, self.wave_frame_ms, 12, 40)
        if self.inp_gate:
            self.wave_gate = getf(self.inp_gate, self.wave_gate, 0.0, 0.6)
        if self.inp_sens:
            self.wave_sens = getf(self.inp_sens, self.wave_sens, 0.2, 3.0)
        if self.inp_cap:
            self.wave_cap = getf(self.inp_cap, self.wave_cap, 0.10, 1.0)
        if self.inp_lat:
            self.wave_latency_ms = geti(self.inp_lat, self.wave_latency_ms, -250, 250)

    def _update_labels(self):
        if self.txt_track:
            self.txt_track.setText("Track: " + (os.path.basename(self.music_path) if self.music_path else "(none)"))

        if self.txt_stats:
            if self.wave_env and self.wave_env.amp01:
                torch_mode = "strength" if self.torch.support_strength else ("PWM" if self.torch.is_available() else "none")
                self.txt_stats.setText(f"Wave frames: {len(self.wave_env.amp01)} | frame={self.wave_env.frame_ms}ms | torch={torch_mode}")
            else:
                self.txt_stats.setText("‚Äî")

    def _status(self, s: str):
        if self.txt_status:
            self.txt_status.setText(s)

    def set_music_path(self, path: str):
        self.music_path = path or ""
        self.wave_env = None
        self._update_labels()
        self._status("–§–∞–π–ª –≤—ã–±—Ä–∞–Ω. –ù–∞–∂–º–∏ Analyze.")

    def _analyze(self):
        path = (self.music_path or "").strip()
        if not path or not os.path.exists(path):
            self._status("–°–Ω–∞—á–∞–ª–∞ Pick –∞—É–¥–∏–æ.")
            return

        self._status("–ê–Ω–∞–ª–∏–∑ Wave‚Ä¶")

        def worker():
            try:
                env = build_wave_envelope(
                    path,
                    frame_ms=int(self.wave_frame_ms),
                    max_seconds=int(ANALYZE_MAX_SECONDS),
                    sens=float(self.wave_sens),
                    gate=float(self.wave_gate),
                    cap=float(self.wave_cap),
                )

                def apply():
                    self.wave_env = env
                    self._update_labels()
                    if env.amp01:
                        self._status("–ì–æ—Ç–æ–≤–æ. Start.")
                        try:
                            if self.hapt:
                                self.hapt.haptic("KEYBOARD_TAP", 3)
                        except Exception:
                            pass
                    else:
                        self._status("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ—Å—Ç—Ä–æ–∏—Ç—å envelope.")
                run_on_ui_thread(apply)

            except Exception as ex:
                run_on_ui_thread(lambda m=str(ex): self._status(f"Analyze error: {m}"))

        threading.Thread(target=worker, daemon=True).start()

    def _play(self):
        self._stop_media()
        if not self.music_path or not os.path.exists(self.music_path):
            return
        mp = MediaPlayer()
        mp.setLooping(False)
        mp.setDataSource(self.music_path)
        mp.prepare()
        mp.start()
        self.media = mp

    def _stop_media(self):
        try:
            if self.media:
                try:
                    self.media.stop()
                except Exception:
                    pass
                try:
                    self.media.release()
                except Exception:
                    pass
        finally:
            self.media = None

    def _song_pos(self) -> int:
        try:
            if self.media:
                return int(self.media.getCurrentPosition())
        except Exception:
            pass
        return 0

    def start(self):
        if self.running:
            return
        if not self.music_path or not os.path.exists(self.music_path):
            self._status("Pick –∞—É–¥–∏–æ —Å–Ω–∞—á–∞–ª–∞.")
            return
        if not self.wave_env or not self.wave_env.amp01:
            self._status("–°–Ω–∞—á–∞–ª–∞ Analyze‚Ä¶")
            self._analyze()
            return

        self.running = True
        self._play()
        self._status("Running‚Ä¶")
        self._tick_wave()

    def stop(self):
        self.running = False
        self._stop_media()
        try:
            self.torch.off()
        except Exception:
            pass
        self._status("Stopped")

    def _tick_wave(self):
        if not self.running:
            return

        pos = self._song_pos()
        try:
            if self.media and (not self.media.isPlaying()):
                self.stop()
                return
        except Exception:
            pass

        env = self.wave_env
        if env and env.amp01:
            trigger_pos = int(pos - self.wave_latency_ms)
            idx = int(trigger_pos // max(1, env.frame_ms))
            if idx < 0:
                idx = 0
            if idx >= len(env.amp01):
                idx = len(env.amp01) - 1

            a01 = float(env.amp01[idx])
            a01 = _clamp01(a01)

            if self.enable_vib and self.hapt:
                if a01 <= 0.0:
                    amp = VIB_MIN_AMP
                else:
                    amp = int(_clamp(255.0 * (a01 ** VIB_GAMMA), VIB_MIN_AMP, 255.0))
                self.hapt.oneshot(int(VIB_PULSE_MS), int(amp))

            if self.enable_flash and self.torch.is_available():
                self.torch.set_strength01(a01)
                self.torch.tick_pwm(int(time.time() * 1000))
            else:
                try:
                    self.torch.off()
                except Exception:
                    pass

        rt = self

        class Again(dynamic_proxy(Runnable)):
            def run(self):
                rt._tick_wave()

        self.handler.postDelayed(Again(), int(WAVE_TICK_MS))


def ensure_entry_button(emoji_view, plugin):
    try:
        search = get_private_field(emoji_view, "emojiSearchField")
        if not search or not isinstance(search, ViewGroup):
            return
        if search.findViewWithTag(ENTRY_BTN_TAG):
            return

        btn = ImageView(emoji_view.getContext())
        btn.setTag(ENTRY_BTN_TAG)
        btn.setPadding(_dp(6), _dp(6), _dp(6), _dp(6))
        btn.setBackground(make_round_bg(Color.parseColor("#2A2A2A"), 12))

        d = get_music_drawable()
        if d:
            btn.setImageDrawable(d)

        lp = LinearLayout.LayoutParams(_dp(34), _dp(34))
        lp.gravity = Gravity.END
        lp.leftMargin = _dp(6)
        btn.setLayoutParams(lp)

        act = unwrap_activity(emoji_view.getContext())
        if not act:
            logcat("Cannot resolve Activity from EmojiView context")
            return

        try:
            set_private_field(emoji_view, STATE_KEY_VISIBLE, False)
        except Exception:
            pass

        class Click(dynamic_proxy(View.OnClickListener)):
            def onClick(self, v):
                try:
                    cur = False
                    try:
                        cur = bool(get_private_field(emoji_view, STATE_KEY_VISIBLE))
                    except Exception:
                        cur = False
                    new_val = not cur
                    try:
                        set_private_field(emoji_view, STATE_KEY_VISIBLE, new_val)
                    except Exception:
                        pass

                    panel = ensure_fullscreen_panel(act)
                    if panel and new_val:
                        plugin.ensure_ui(panel, emoji_view, act)

                    set_panel_visible(act, new_val)
                    logcat(f"Fullscreen panel -> {new_val}")
                except Exception as e:
                    logcat(f"toggle error: {e}")

        btn.setOnClickListener(Click())
        search.addView(btn)
        logcat("Entry button placed in emojiSearchField")
    except Exception as e:
        logcat(f"ensure_entry_button error: {e}")


class EmojiViewCtorHook(MethodHook):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def after_hooked_method(self, param):
        emoji_view = param.thisObject
        run_on_ui_thread(lambda: ensure_entry_button(emoji_view, self.plugin))


class Plugin(BasePlugin):
    FILE_PICKER_AUDIO_CODE = 903

    class ActivityResultHook(MethodHook):
        def __init__(self, plugin: "Plugin"):
            super().__init__()
            self.plugin = plugin

        def before_hooked_method(self, param):
            request_code, result_code, data = param.args
            if request_code != self.plugin.FILE_PICKER_AUDIO_CODE:
                return

            param.setResult(None)

            try:
                if result_code == Activity.RESULT_OK and data and data.getData():
                    uri = data.getData()
                    run_on_queue(lambda u=uri: self.plugin._handle_picked_audio_uri(u))
            except Exception as e:
                logcat(f"onActivityResult error: {e}")

            if self.plugin.activity_hook:
                try:
                    self.plugin.unhook_method(self.plugin.activity_hook)
                except Exception:
                    pass
                self.plugin.activity_hook = None

    def __init__(self):
        super().__init__()
        self.hooks: List[Any] = []
        self.activity_hook = None
        self._plugin_dir_path: str = ""
        self.runtime: Optional[BeatSignalRuntime] = None

    def on_plugin_load(self):
        base_dir = ApplicationLoader.getFilesDirFixed()
        if base_dir:
            plugin_id = getattr(self, "id", None) or __id__
            folder = File(base_dir, plugin_id)
            if not folder.exists():
                folder.mkdirs()
            self._plugin_dir_path = folder.getAbsolutePath()

        emoji_view = Class.forName("org.telegram.ui.Components.EmojiView")
        try:
            ctor = emoji_view.getDeclaredConstructors()[0]
            ctor.setAccessible(True)
            self.hooks.append(self.hook_method(ctor, EmojiViewCtorHook(self)))
            logcat("Hooked EmojiView ctor (first)")
        except Exception as e:
            logcat(f"ctor hook error: {e}")

        logcat("Plugin loaded")

    def on_plugin_unload(self):
        for h in self.hooks:
            try:
                self.unhook_method(h)
            except Exception:
                pass
        self.hooks.clear()

        if self.activity_hook:
            try:
                self.unhook_method(self.activity_hook)
            except Exception:
                pass
        self.activity_hook = None

        if self.runtime:
            try:
                self.runtime.stop()
            except Exception:
                pass
        self.runtime = None
        logcat("Unloaded")

    def create_settings(self):
        if Header and SettingsText and Divider:
            def _open(_=None):
                self.open_from_settings()

            return [
                Header(text="BeatSignal"),
                SettingsText(
                    text="–û—Ç–∫—Ä—ã—Ç—å BeatSignal",
                    icon="msg_music",
                    accent=True,
                    on_click=_open
                ),
                Divider(text="–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–µ –º–µ–Ω—é BeatSignal."),
            ]

        def _open_fallback(_=None):
            self.open_from_settings()

        return [
            {"type": "Header", "text": "BeatSignal"},
            {"type": "Text", "text": "–û—Ç–∫—Ä—ã—Ç—å BeatSignal", "icon": "msg_music", "accent": True, "on_click": _open_fallback},
        ]

    def open_from_settings(self):
        fragment = get_last_fragment()
        if not fragment:
            logcat("open_from_settings: no fragment")
            return
        activity = fragment.getParentActivity()
        if not activity:
            logcat("open_from_settings: no activity")
            return

        def _ui():
            try:
                panel = ensure_fullscreen_panel(activity)
                if not panel:
                    logcat("open_from_settings: panel not created")
                    return

                panel.removeAllViews()
                self.runtime = BeatSignalRuntime(panel.getContext(), panel, self, activity)
                self.runtime.build_ui()

                def do_close():
                    set_panel_visible(activity, False)

                self.runtime._on_close = do_close
                set_panel_visible(activity, True)
                logcat("BeatSignal opened from settings")
            except Exception as e:
                logcat(f"open_from_settings error: {e}")

        run_on_ui_thread(_ui)

    def ensure_ui(self, panel: FrameLayout, emoji_view, activity):
        panel.removeAllViews()
        self.runtime = BeatSignalRuntime(panel.getContext(), panel, self, activity)
        self.runtime.build_ui()

        def do_close():
            try:
                set_private_field(emoji_view, STATE_KEY_VISIBLE, False)
            except Exception:
                pass
            set_panel_visible(activity, False)

        self.runtime._on_close = do_close

    def _install_activity_hook(self, activity):
        if self.activity_hook:
            try:
                self.unhook_method(self.activity_hook)
            except Exception:
                pass
            self.activity_hook = None

        IntegerClassObj = Class.forName("java.lang.Integer")
        int_type = IntegerClassObj.getField("TYPE").get(None)
        IntentClassObj = Class.forName("android.content.Intent")

        ActivityClass = Class.forName(activity.getClass().getName())
        method = ActivityClass.getDeclaredMethod("onActivityResult", int_type, int_type, IntentClassObj)
        method.setAccessible(True)
        self.activity_hook = self.hook_method(method, Plugin.ActivityResultHook(self))

    def launch_music_picker(self):
        fragment = get_last_fragment()
        if not fragment:
            return
        activity = fragment.getParentActivity()
        if not activity:
            return

        self._install_activity_hook(activity)

        intent = Intent(Intent.ACTION_GET_CONTENT)
        intent.setType("audio/*")
        activity.startActivityForResult(
            Intent.createChooser(intent, "–í—ã–±–µ—Ä–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª"),
            self.FILE_PICKER_AUDIO_CODE
        )

    def _handle_picked_audio_uri(self, uri: Uri):
        if not self._plugin_dir_path:
            logcat("No plugin dir")
            return

        resolver = ApplicationLoader.applicationContext.getContentResolver()
        inp = resolver.openInputStream(uri)
        if not inp:
            logcat("openInputStream returned null")
            return

        byte_stream = ByteArrayOutputStream()
        buffer = bytearray(4096)

        out_path = None
        try:
            while True:
                n = inp.read(buffer)
                if n == -1:
                    break
                byte_stream.write(buffer, 0, n)

            data = byte_stream.toByteArray()

            out_name = f"picked_{int(time.time())}.mp3"
            out_path = os.path.join(self._plugin_dir_path, out_name)

            out = FileOutputStream(out_path)
            out.write(data)
            out.close()

        finally:
            try:
                inp.close()
            except Exception:
                pass
            try:
                byte_stream.close()
            except Exception:
                pass

        def apply(path=out_path):
            if self.runtime and path:
                self.runtime.set_music_path(path)
            logcat(f"Picked audio saved -> {path}")

        run_on_ui_thread(apply)
