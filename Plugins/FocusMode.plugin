import time
import threading # 
from base_plugin import BasePlugin, MethodHook, hook_filters, HookFilter, MenuItemData, MenuItemType
from hook_utils import find_class, get_private_field
from ui.settings import Switch, Input, Text, Header, Divider, Selector
from android_utils import run_on_ui_thread, OnClickListener, log
from org.telegram.messenger import MessageObject, AndroidUtilities
from org.telegram.messenger import R as R_tg
from org.telegram.ui.Components import BulletinFactory, Bulletin, LayoutHelper
from org.telegram.ui import LaunchActivity
from android.view import Gravity
from android.widget import LinearLayout, TextView, FrameLayout, ImageView, ProgressBar
from android.graphics import Color, Typeface
from android.graphics.drawable import GradientDrawable
from android.util import TypedValue
from android.app import ActivityManager
from android.content import Context
from org.telegram.ui.ActionBar import Theme, AlertDialog
from java.lang import Runtime, Thread
from org.telegram.tgnet import TLRPC
from java.lang import Boolean
from java.util import ArrayList
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity

__id__ = "focus_mode"
__name__ = "Focus Mode"
__description__ = (
    "Helps you stay focused in chats by reducing visual noise, highlighting relevant messages, and offering flexible filters and moderation tools.\n\n"
    "Помогает сосредоточиться в чатах, снижая визуальный шум, выделяя важные сообщения и предоставляя гибкие инструменты фильтрации и модерации."
)
__author__ = "@AGeekApple"
__version__ = "1.0.1-exp"
__min_version__ = "11.12.0"
__icon__        = "ApplePlugins/22"


# Dicionário padrão
strings = {
    "extended_settings_hello": {
        "pt": "Olá, {}",
        "en": "Hello, {}",
        "es": "Hola, {}",
        "ru": "Привет, {}",
        "cn": "你好, {}",
        "ar": "مرحبا, {}",
        "fa": "سلام, {}",
        "uk": "Привіт, {}",
        "hi": "नमस्ते, {}"
    },
    "extended_settings_subtitle": {
        "pt": "Controle seu foco e atenção",
        "en": "Control your focus and attention",
        "es": "Controla tu enfoque y atención",
        "ru": "Контролируйте своё внимание",
        "cn": "掌控您的专注和注意力",
        "ar": "تحكم في تركيزك وانتباهك",
        "fa": "کنترل تمرکز و توجه",
        "uk": "Контролюйте свою увагу",
        "hi": "अपना ध्यान और एकाग्रता नियंत्रित करें"
    },
    "enable_focus": {
        "pt": "Modo Foco",
        "en": "Focus Mode",
        "es": "Modo Enfoque",
        "ru": "Режим фокуса",
        "cn": "专注模式",
        "ar": "وضع التركيز",
        "fa": "حالت تمرکز",
        "uk": "Режим фокусу",
        "hi": "फोकस मोड"
    },
    "focus_keep_count": {
        "pt": "Mensagens em Foco",
        "en": "Focused Messages",
        "es": "Mensajes en Foco",
        "ru": "Сообщения в фокусе",
        "cn": "聚焦消息",
        "ar": "رسائل مركزة",
        "fa": "پیام‌های متمرکز",
        "uk": "Повідомлення у фокусі",
        "hi": "फोकस संदेश"
    },
    "focus_keep_count_sub": {
        "pt": "Quantidade de mensagens recentes mantidas em destaque",
        "en": "Number of recent messages kept in focus",
        "es": "Cantidad de mensajes recientes mantenidos en foco",
        "ru": "Количество последних сообщений в фокусе",
        "cn": "保持焦点的最近消息数量",
        "ar": "عدد الرسائل الحديثة التي يتم التركيز عليها",
        "fa": "تعداد پیام‌های اخیر که در کانون توجه نگه داشته می‌شوند",
        "uk": "Кількість останніх повідомлень у фокусі",
        "hi": "फोकस में रखे गए हाल के संदेशों की संख्या"
    },
    "focus_alpha": {
        "pt": "Intensidade",
        "en": "Intensity",
        "es": "Intensidad",
        "ru": "Интенсивность",
        "cn": "强度",
        "ar": "الشدة",
        "fa": "شدت",
        "uk": "Інтенсивність",
        "hi": "तीव्रता"
    },
    "focus_ignore_own": {
        "pt": "Me Ignorar",
        "en": "Ignore Me",
        "es": "Ignorarme",
        "ru": "Игнорировать Меня",
        "cn": "忽略我",
        "ar": "تجاهلني",
        "fa": "نادیده‌ام بگیر",
        "uk": "Ігнорувати Мене",
        "hi": "मुझे अनदेखा करें"
    },
    "focus_gradient": {
        "pt": "Transição do foco",
        "en": "Focus transition",
        "es": "Transición del enfoque",
        "ru": "Переход фокуса",
        "cn": "专注过渡",
        "ar": "انتقال التركيز",
        "fa": "گذار تمرکز",
        "uk": "Перехід фокусу",
        "hi": "फोकस ट्रांज़िशन"
    },
    "focus_blur": {
        "pt": "Desfoque",
        "en": "Blur",
        "es": "Desenfoque",
        "ru": "Размытие",
        "cn": "模糊",
        "ar": "طمس",
        "fa": "تاری",
        "uk": "Розмиття",
        "hi": "धुंधला"
    },
    "focus_blur_sub": {
        "pt": "Aplica um efeito de desfoque nas mensagens antigas",
        "en": "Applies a blur effect to old messages",
        "es": "Aplica un efecto de desenfoque a mensajes antiguos",
        "ru": "Применяет эффект размытия к старым сообщениям",
        "cn": "对旧消息应用模糊效果",
        "ar": "يطبق تأثير طمس على الرسائل القديمة",
        "fa": "اعمال افکت تاری روی پیام‌های قدیمی",
        "uk": "Застосовує ефект розмиття до старих повідомлень",
        "hi": "पुराने संदेशों पर धुंधला प्रभाव लागू करता है"
    },
    "optimize_auto": {
        "pt": "Otimização Automática",
        "en": "Auto Optimization",
        "es": "Optimización Automática",
        "ru": "Автооптимизация",
        "cn": "自动优化",
        "ar": "تحسين تلقائي",
        "fa": "بهینه‌سازی خودکار",
        "uk": "Автооптимізація",
        "hi": "स्वतः अनुकूलन"
    },
    "optimize_auto_sub": {
        "pt": "Ajustes automáticos experimentais de desempenho",
        "en": "Experimental automatic performance tuning",
        "es": "Ajustes automáticos experimentales de rendimiento",
        "ru": "Экспериментальная автоматическая оптимизация производительности",
        "cn": "实验性的自动性能优化",
        "ar": "تحسين أداء تلقائي تجريبي",
        "fa": "بهینه‌سازی خودکار آزمایشی عملکرد",
        "uk": "Експериментальне автоматичне налаштування продуктивності",
        "hi": "प्रयोगात्मक स्वचालित प्रदर्शन अनुकूलन"
    },
    "optimization_complete": {
        "pt": "Otimização Concluída!",
        "en": "Optimization Completed!",
        "es": "¡Optimización Completada!",
        "ru": "Оптимизация завершена!",
        "cn": "优化完成！",
        "ar": "اكتمل التحسين!",
        "fa": "بهینه‌سازی کامل شد!",
        "uk": "Оптимізацію завершено!",
        "hi": "अनुकूलन पूरा हुआ!"
    },
    "settings_applied": {
        "pt": "Configurações aplicadas com sucesso.",
        "en": "Settings applied successfully.",
        "es": "Configuraciones aplicadas con éxito.",
        "ru": "Настройки успешно применены.",
        "cn": "设置已成功应用。",
        "ar": "تم تطبيق الإعدادات بنجاح.",
        "fa": "تنظیمات با موفقیت اعمال شد.",
        "uk": "Налаштування успішно застосовано.",
        "hi": "सेटिंग्स सफलतापूर्वक लागू की गईं।"
    },
    "manual_restart_required": {
        "pt": "Reabra as configurações para ver as alterações",
        "en": "Reopen settings to see changes",
        "es": "Reabra la configuración para ver cambios",
        "ru": "Переоткройте настройки, чтобы увидеть изменения",
        "cn": "重新打开设置以查看更改",
        "ar": "أعد فتح الإعدادات لرؤية التغييرات",
        "fa": "برای دیدن تغییرات تنظیمات را دوباره باز کنید",
        "uk": "Перевідкрийте налаштування, щоб побачити зміни",
        "hi": "परिवर्तन देखने के लिए सेटिंग्स फिर से खोलें"
    },
    "optimized_toast": {
        "pt": "Configurações otimizadas com sucesso!",
        "en": "Settings optimized successfully!",
        "es": "¡Configuraciones optimizadas con éxito!",
        "ru": "Настройки успешно оптимизированы!",
        "cn": "设置已成功优化！",
        "ar": "تم تحسين الإعدادات بنجاح!",
        "fa": "تنظیمات با موفقیت بهینه‌سازی شد!",
        "uk": "Налаштування успішно оптимізовано!",
        "hi": "सेटिंग्स सफलतापूर्वक अनुकूलित की गईं!"
    },
    "focus_do_not_show": {
        "pt": "Não Mostrar",
        "en": "Do Not Show",
        "es": "No mostrar",
        "ru": "Не показывать",
        "cn": "不显示",
        "ar": "لا تظهر",
        "fa": "نشان نده",
        "uk": "Не показувати",
        "hi": "मत दिखाओ"
    },
    "focus_per_chat_title": {
        "pt": "Controle por Chat",
        "en": "Per-Chat Control",
        "es": "Control por Chat",
        "ru": "Управление по чатам",
        "cn": "按聊天控制",
        "ar": "التحكم لكل محادثة",
        "fa": "کنترل برای هر چت",
        "uk": "Управління по чатах",
        "hi": "प्रति चैट नियंत्रण"
    },
    "focus_per_chat_desc": {
        "pt": "Adiciona opção no menu do chat para ativar/desativar individualmente",
        "en": "Adds option in chat menu to toggle individually",
        "es": "Agrega opción en menú de chat para alternar individualmente",
        "ru": "Добавляет опцию в меню чата для переключения индивидуально",
        "cn": "在聊天菜单中添加单独切换的选项",
        "ar": "يضيف خيارًا في قائمة الدردشة للتبديل بشكل فردي",
        "fa": "گزینه‌ای را به منوی چت اضافه می‌کند تا به صورت جداگانه تغییر کند",
        "uk": "Додає опцію в меню чату для перемикання індивідуально",
        "hi": "व्यक्तिगत रूप से टॉगल करने के लिए चैट मेनू में विकल्प जोड़ता है"
    },
    "focus_chat_menu_item": {
        "pt": "Focus Mode",
        "en": "Focus Mode",
        "es": "Modo Enfoque",
        "ru": "Режим фокусировки",
        "cn": "专注模式",
        "ar": "وضع التركيز",
        "fa": "حالت تمرکز",
        "uk": "Режим фокусу",
        "hi": "फोकस मोड"
    },
    "focus_chat_enabled": {
        "pt": "Focus Mode: Ativado",
        "en": "Focus Mode: Enabled",
        "es": "Modo Enfoque: Activado",
        "ru": "Режим фокусировки: Включен",
        "cn": "专注模式：已启用",
        "ar": "وضع التركيز: مفعل",
        "fa": "حالت تمرکز: فعال شد",
        "uk": "Режим фокусу: Увімкнено",
        "hi": "फोकस मोड: सक्षम"
    },
    "focus_chat_disabled": {
        "pt": "Focus Mode: Desativado",
        "en": "Focus Mode: Disabled",
        "es": "Modo Enfoque: Desactivado",
        "ru": "Режим фокусировки: Отключен",
        "cn": "专注模式：已禁用",
        "ar": "وضع التركيز: معطل",
        "fa": "حالت تمرکز: غیرفعال شد",
        "uk": "Режим фокусу: Вимкнено",
        "hi": "फोकस मोड: अक्षम"
    },
    "dns_none": {
        "pt": "Desativado",
        "en": "Disabled",
        "es": "Desactivado",
        "ru": "Отключено",
        "cn": "已禁用",
        "ar": "معطل",
        "fa": "غیرفعال",
        "uk": "Вимкнено",
        "hi": "अक्षम"
    },
    "dns_gifs": {
        "pt": "Gifs",
        "en": "Gifs",
        "es": "Gifs",
        "ru": "Gifs",
        "cn": "Gifs",
        "ar": "Gifs",
        "fa": "Gifs",
        "uk": "Gifs",
        "hi": "Gifs"
    },
    "dns_stickers": {
        "pt": "Adesivos",
        "en": "Stickers",
        "es": "Stickers",
        "ru": "Стикеры",
        "cn": "贴纸",
        "ar": "ملصقات",
        "fa": "استیکرها",
        "uk": "Стікери",
        "hi": "स्टिकर"
    },
    "dns_emojis": {
        "pt": "Emojis",
        "en": "Emojis",
        "es": "Emojis",
        "ru": "Эмодзи",
        "cn": "表情符号",
        "ar": "الرموز التعبيرية",
        "fa": "ایموجی‌ها",
        "uk": "Емодзі",
        "hi": "इमोजी"
    },
    "dns_both": {
        "pt": "Todos",
        "en": "All",
        "es": "Todos",
        "ru": "Все",
        "cn": "全部",
        "ar": "الكل",
        "fa": "همه",
        "uk": "Всі",
        "hi": "सब"
    },
    "focus_theme_title": {
        "pt": "Estilo do Foco",
        "en": "Focus Style",
        "es": "Estilo de Enfoque",
        "ru": "Стиль фокуса",
        "cn": "焦点样式",
        "ar": "نمط التركيز",
        "fa": "سبک تمرکز",
        "uk": "Стиль фокусу",
        "hi": "फोकस शैली"
    },
    "focus_theme_transparent": {
        "pt": "Transparente",
        "en": "Transparent",
        "es": "Transparente",
        "ru": "Прозрачный",
        "cn": "透明",
        "ar": "شفاف",
        "fa": "شفاف",
        "uk": "Прозорий",
        "hi": "पारदर्शी"
    },
    "focus_theme_hidden": {
        "pt": "Oculto",
        "en": "Hidden",
        "es": "Oculto",
        "ru": "Скрытый",
        "cn": "隐藏",
        "ar": "مخفي",
        "fa": "پنهان",
        "uk": "Прихований",
        "hi": "छिपा हुआ"
    },
    "focus_moderation": {
        "pt": "Modo Moderação",
        "en": "Moderation Mode",
        "es": "Modo Moderación",
        "ru": "Режим модерации",
        "cn": "审核模式",
        "ar": "وضع الاعتدال",
        "fa": "حالت اعتدال",
        "uk": "Режим модерації",
        "hi": "संयम मोड"
    },
    "focus_moderation_sub": {
        "pt": "Mantém mensagens moderadas visíveis",
        "en": "Keeps moderated messages visible",
        "es": "Mantiene visibles los mensajes moderados",
        "ru": "Оставляет сообщения модерации видимыми",
        "cn": "保持被管理的消息可见",
        "ar": "يبقي رسائل الإشراف مرئية",
        "fa": "پیام‌های نظارت‌شده را قابل مشاهده نگه می‌دارد",
        "uk": "Залишає модераційні повідомлення видимими",
        "hi": "मॉडरेट किए गए संदेशों को दृश्यमान रखता है"
    },
    "focus_moderation_keywords": {
        "pt": "Palavras-chave (Separe por vírgula)",
        "en": "Keywords (Comma separated)",
        "es": "Palabras clave (Separadas por coma)",
        "ru": "Ключевые слова (через запятую)",
        "cn": "关键词 (逗号分隔)",
        "ar": "الكلمات الرئيسية (مفصولة بفواصل)",
        "fa": "کلمات کلیدی (با ویرگول جدا شود)",
        "uk": "Ключові слова (через кому)",
        "hi": "कीवर्ड (अल्पविराम से अलग)"
    },
    "focus_moderation_regex": {
        "pt": "Regex (Avançado)",
        "en": "Regex (Advanced)",
        "es": "Regex (Avanzado)",
        "ru": "Regex (Расширенный)",
        "cn": "正则 (高级)",
        "ar": "تعبير عادي (متقدم)",
        "fa": "عبارات باقاعده (پیشرفته)",
        "uk": "Regex (Розширений)",
        "hi": "Regex (उन्नत)"
    },
    "focus_moderation_regex_sub": {
        "pt": "Padrões regex separados por ;; (ex: ^Start;;end$)",
        "en": "Regex patterns separated by ;; (e.g. ^Start;;end$)",
        "es": "Patrones regex separados por ;; (ej: ^Start;;end$)",
        "ru": "Regex шаблоны, разделенные ;; (например: ^Start;;end$)",
        "cn": "用 ;; 分隔的正则模式 (例如: ^Start;;end$)",
        "ar": "أنماط التعبير العادي مفصولة بـ ;; (مثال: ^Start;;end$)",
        "fa": "الگوهای عبارات باقاعده جدا شده با ;; (مثال: ^Start;;end$)",
        "uk": "Regex шаблони, розділені ;; (наприклад: ^Start;;end$)",
        "hi": ";; द्वारा अलग किए गए Regex पैटर्न (उदाहरण: ^Start;;end$)"
    },
    "enable_focus_sub": {
        "pt": "Ativa o efeito de foco nas mensagens recentes",
        "en": "Enables focus effect on recent messages",
        "es": "Activa el efecto de enfoque en mensajes recientes",
        "ru": "Включает эффект фокуса на последних сообщениях",
        "cn": "启用最近消息的焦点效果",
        "ar": "تمكين تأثير التركيز على الرسائل الحديثة",
        "fa": "فعال‌سازی جلوه تمرکز روی پیام‌های اخیر",
        "uk": "Вмикає ефект фокусу на останніх повідомленнях",
        "hi": "हाल के संदेशों पर फोकस प्रभाव सक्षम करता है"
    },
    "focus_ignore_own_sub": {
        "pt": "Mantém suas próprias mensagens sempre visíveis",
        "en": "Keeps your own messages always visible",
        "es": "Mantiene tus propios mensajes siempre visibles",
        "ru": "Держит ваши сообщения всегда видимыми",
        "cn": "保持您自己的消息始终可见",
        "ar": "يبقي رسائلك الخاصة مرئية دائماً",
        "fa": "پیام‌های خودتان را همیشه قابل مشاهده نگه می‌دارد",
        "uk": "Тримає ваші повідомлення завжди видимими",
        "hi": "आपके अपने संदेशों को हमेशा दृश्यमान रखता है"
    },
    "focus_ignore_dns_title": {
        "pt": "Filtros visuais (DNS)",
        "en": "Visual filters (DNS)",
        "es": "Filtros visuales (DNS)",
        "ru": "Визуальные фильтры (DNS)",
        "cn": "视觉过滤器 (DNS)",
        "ar": "المرشحات البصرية (DNS)",
        "fa": "فیلترهای بصری (DNS)",
        "uk": "Візуальні фільтри (DNS)",
        "hi": "दृश्य फिल्टर (DNS)"
    },
    "focus_hide_paid_stars": {
        "pt": "Ocultar Mensagens Pagas",
        "en": "Hide Paid Messages",
        "es": "Ocultar Mensajes Pagados",
        "ru": "Скрыть платные сообщения",
        "cn": "隐藏付费消息",
        "ar": "إخفاء الرسائل المدفوعة",
        "fa": "پنهان کردن پیام‌های پولی",
        "uk": "Приховати платні повідомлення",
        "hi": "भुगतान किए गए संदेश छिपाएं"
    },
    "focus_hide_paid_stars_sub": {
        "pt": "Oculta mensagens de mídia paga (Telegram Stars)",
        "en": "Hides paid media messages (Telegram Stars)",
        "es": "Oculta mensajes de medios pagados (Telegram Stars)",
        "ru": "Скрывает сообщения с платным медиа (Telegram Stars)",
        "cn": "隐藏付费媒体消息 (Telegram Stars)",
        "ar": "يخفي رسائل الوسائط المدفوعة (نجوم تيليجرام)",
        "fa": "پیام‌های رسانه‌ای پولی را پنهان می‌کند (ستاره‌های تلگرام)",
        "uk": "Приховує повідомлення з платним медіа (Telegram Stars)",
        "hi": "भुगतान किए गए मीडिया संदेशों को छिपाता है (Telegram Stars)"
    },
    "focus_paid_stars_unlocked": {
        "pt": "Recurso experimental desbloqueado!",
        "en": "Experimental feature unlocked!",
        "es": "¡Función experimental desbloqueada!",
        "ru": "Экспериментальная функция разблокирована!",
        "cn": "实验性功能已解锁！",
        "ar": "تم فتح ميزة تجريبية!",
        "fa": "ویژگی آزمایشی باز شد!",
        "uk": "Експериментальну функцію розблоковано!",
        "hi": "प्रयोगात्मक सुविधा अनलॉक की गई!"
    },
    "header_experimental": {
        "pt": "Experimental",
        "en": "Experimental",
        "es": "Experimental",
        "ru": "Экспериментальные",
        "cn": "实验性",
        "ar": "تجريبي",
        "fa": "آزمایشی",
        "uk": "Експериментальні",
        "hi": "प्रयोगात्मक"
    },
    "focus_ignore_dns_opt_apply": {
        "pt": "Ocultar (Padrão)",
        "en": "Hide (Default)",
        "es": "Ocultar (Predeterminado)",
        "ru": "Скрыть (По умолчанию)",
        "cn": "隐藏 (默认)",
        "ar": "إخفاء (افتراضي)",
        "fa": "پنهان کردن (پیش‌فرض)",
        "uk": "Приховати (За замовчуванням)",
        "hi": "छिपाएं (डिफ़ॉल्ट)"
    },
    "focus_ignore_dns_opt_show": {
        "pt": "Manter visível",
        "en": "Keep visible",
        "es": "Mantener visible",
        "ru": "Оставить видимым",
        "cn": "保持可见",
        "ar": "ابق مرئيا",
        "fa": "قابل مشاهده نگه دارید",
        "uk": "Залишити видимим",
        "hi": "दृश्यमान रखें"
    },
    "support_title": {
        "pt": "Suporte",
        "en": "Support",
        "es": "Soporte",
        "ru": "Поддержка",
        "cn": "支持",
        "ar": "الدعم",
        "fa": "پشتیبانی",
        "uk": "Підтримка",
        "hi": "सहायता"
    },
    "support_description": {
        "pt": "Oi. Sou o Apple, desenvolvedor de plugins e projetos independentes. Se você curtiu, pode apoiar enviando um presente pelo Telegram. É só tocar no meu nome de usuário ou me chamar se quiser ajudar de outra forma. Seu apoio mantém os projetos ativos e novas ideias ganhando vida. Obrigado.",
        "en": "Hey. I’m Apple, a developer of plugins and independent projects. If you like what I do, you can support me by sending a gift on Telegram. Just tap my username or reach out if you’d like to help in another way. Your support keeps the projects alive and new ideas coming. Thank you.",
        "es": "Hola. Soy Apple, desarrollador de plugins y proyectos independientes. Si te gusta lo que hago, puedes apoyarme enviando un regalo por Telegram. Solo toca mi nombre de usuario o escríbeme si quieres ayudar de otra forma. Tu apoyo mantiene los proyectos activos y nuevas ideas en marcha. Gracias.",
        "ru": "Привет. Я Apple, разработчик плагинов и независимых проектов. Если тебе нравится моя работа, можешь поддержать меня, отправив подарок в Telegram. Просто нажми на мой ник или напиши мне, если хочешь помочь другим способом. Твоя поддержка помогает проектам жить и развивать новые идеи. Спасибо.",
        "cn": "嗨。我是 Apple，插件和独立项目的开发者。如果你喜欢我的作品，可以通过 Telegram 发送礼物来支持我。点击我的用户名，或者如果你想用其他方式支持，也可以直接联系我。你的支持让项目持续发展，也让新想法不断出现。谢谢。",
        "ar": "مرحباً. أنا Apple، مطور إضافات ومشاريع مستقلة. إذا أعجبك ما أقدمه، يمكنك دعمي بإرسال هدية عبر Telegram. فقط اضغط على اسم المستخدم الخاص بي أو تواصل معي إذا رغبت بالدعم بطريقة أخرى. دعمك يساعد على استمرار المشاريع وولادة أفكار جديدة. شكراً لك.",
        "fa": "سلام. من Apple هستم، توسعه‌دهنده پلاگین‌ها و پروژه‌های مستقل. اگر کارت را دوست داری، می‌توانی با ارسال هدیه در تلگرام از من حمایت کنی. کافی است روی نام کاربری من بزنید یا اگر دوست دارید به شکل دیگری کمک کنید، با من تماس بگیرید. حمایت شما باعث ادامه پروژه‌ها و شکل‌گیری ایده‌های جدید می‌شود. ممنونم.",
        "uk": "Привіт. Я Apple, розробник плагінів і незалежних проєктів. Якщо тобі подобається моя робота, ти можеш підтримати мене, надіславши подарунок у Telegram. Просто натисни на мій нік або напиши мені, якщо хочеш допомогти іншим способом. Твоя підтримка допомагає проєктам жити та розвивати нові ідеї. Дякую.",
        "hi": "नमस्ते। मैं Apple हूँ, प्लगइन्स और स्वतंत्र प्रोजेक्ट्स का डेवलपर। अगर आपको मेरा काम पसंद आया, तो आप Telegram पर गिफ्ट भेजकर सपोर्ट कर सकते हैं। बस मेरे यूज़रनेम पर टैप करें या अगर किसी और तरीके से मदद करना चाहें तो मुझसे संपर्क करें। आपका सपोर्ट प्रोजेक्ट्स को ज़िंदा रखता है और नई आइडियाज़ को आगे बढ़ाता है। धन्यवाद।"
    },
    "support_button": {
        "pt": "Falar com Desenvolvedor",
        "en": "Talk to Developer",
        "es": "Hablar con el desarrollador",
        "ru": "Связаться с разработчиком",
        "cn": "联系开发者",
        "ar": "تحدث إلى المطور",
        "fa": "صحبت با توسعه‌دهنده",
        "uk": "Зв'язатися з розробником",
        "hi": "डेवलपर से बात करें"
    },
    "plugin_lang_label": {
        "pt": "Idioma do Plugin",
        "en": "Plugin Language",
        "es": "Idioma del Plugin",
        "ru": "Язык плагина",
        "cn": "插件语言",
        "ar": "لغة البرنامج المساعد",
        "fa": "زبان افزونه",
        "uk": "Мова плагіна",
        "hi": "प्लगइन भाषा"
    },
    "lang_english": {
        "en": "English",
        "pt": "Inglês",
        "es": "Inglés",
        "ru": "Английский",
        "cn": "英语",
        "ar": "إنجليزي",
        "fa": "انگلیسی",
        "uk": "Англійська",
        "hi": "अंग्रेज़ी"
    },
    "lang_portuguese": {
        "en": "Portuguese",
        "pt": "Português",
        "es": "Portugués",
        "ru": "Португальский",
        "cn": "葡萄牙语",
        "ar": "برتغالي",
        "fa": "پرتغالی",
        "uk": "Португальська",
        "hi": "पुर्तगाली"
    },
    "lang_spanish": {
        "en": "Spanish",
        "pt": "Espanhol",
        "es": "Español",
        "ru": "Испанский",
        "cn": "西班牙语",
        "ar": "إسباني",
        "fa": "اسپانیایی",
        "uk": "Іспанська",
        "hi": "स्पेनिश"
    },
    "lang_russian": {
        "en": "Russian",
        "pt": "Russo",
        "es": "Ruso",
        "ru": "Русский",
        "cn": "俄语",
        "ar": "روسي",
        "fa": "روسی",
        "uk": "Російська",
        "hi": "रूसी"
    },
    "lang_chinese_simplified": {
        "en": "Chinese (Simplified)",
        "pt": "Chinês (Simplificado)",
        "es": "Chino (Simplificado)",
        "ru": "Китайский (упрощенный)",
        "cn": "简体中文",
        "ar": "صيني (مبسط)",
        "fa": "چینی (ساده شده)",
        "uk": "Китайська (спрощена)",
        "hi": "चीनी (सरलीकृत)"
    },
    "lang_arabic": {
        "en": "Arabic",
        "pt": "Árabe",
        "es": "Árabe",
        "ru": "Арабский",
        "cn": "阿拉伯语",
        "ar": "العربية",
        "fa": "عربی",
        "uk": "Арабська",
        "hi": "अरबी"
    },
    "lang_persian": {
        "en": "Persian",
        "pt": "Persa",
        "es": "Persa",
        "ru": "Персидский",
        "cn": "波斯语",
        "ar": "فارسي",
        "fa": "فارسی",
        "uk": "Перська",
        "hi": "फारसी"
    },
    "lang_ukrainian": {
        "en": "Ukrainian",
        "pt": "Ucraniano",
        "es": "Ucraniano",
        "ru": "Украинский",
        "cn": "乌克兰语",
        "ar": "أوكراني",
        "fa": "اوکراینی",
        "uk": "Українська",
        "hi": "यूक्रेनी"
    },
    "lang_hindi": {
        "en": "Hindi",
        "pt": "Hindi",
        "es": "Hindi",
        "ru": "Хинди",
        "cn": "印地语",
        "ar": "هندي",
        "fa": "هندی",
        "uk": "Гінді",
        "hi": "हिन्दी"
    },
    
    # Opções de Intensidade (Alpha)
    "alpha_10": {
        "pt": "10% (Fantasma)",
        "en": "10% (Ghost)",
        "es": "10% (Fantasma)",
        "ru": "10% (Призрак)",
        "cn": "10% (幽灵)",
        "ar": "10% (شبح)",
        "fa": "10% (روح)",
        "uk": "10% (Привид)",
        "hi": "10% (भूत)"
    },
    "alpha_20": {
        "pt": "20% (Muito Baixo)",
        "en": "20% (Very Low)",
        "es": "20% (Muy bajo)",
        "ru": "20% (Очень низкий)",
        "cn": "20% (极低)",
        "ar": "20% (منخفض جدا)",
        "fa": "20% (خیلی کم)",
        "uk": "20% (Дуже низький)",
        "hi": "20% (बहुत कम)"
    },
    "alpha_30": {
        "pt": "30% (Baixo)",
        "en": "30% (Low)",
        "es": "30% (Bajo)",
        "ru": "30% (Низкий)",
        "cn": "30% (低)",
        "ar": "30% (منخفض)",
        "fa": "30% (کم)",
        "uk": "30% (Низький)",
        "hi": "30% (कम)"
    },
    "alpha_50": {
        "pt": "50% (Médio)",
        "en": "50% (Medium)",
        "es": "50% (Medio)",
        "ru": "50% (Средний)",
        "cn": "50% (中)",
        "ar": "50% (متوسط)",
        "fa": "50% (متوسط)",
        "uk": "50% (Середній)",
        "hi": "50% (मध्यम)"
    },
    "alpha_70": {
        "pt": "70% (Alto)",
        "en": "70% (High)",
        "es": "70% (Alto)",
        "ru": "70% (Высокий)",
        "cn": "70% (高)",
        "ar": "70% (عالي)",
        "fa": "70% (بالا)",
        "uk": "70% (Високий)",
        "hi": "70% (उच्च)"
    },
    "alpha_100": {
        "pt": "100% (Desativado)",
        "en": "100% (Off)",
        "es": "100% (Desactivado)",
        "ru": "100% (Выкл)",
        "cn": "100% (关)",
        "ar": "100% (إيقاف)",
        "fa": "100% (خاموش)",
        "uk": "100% (Вимк)",
        "hi": "100% (बंद)"
    },

    # Opções de Suavidade (Gradient)
    "grad_0": {
        "pt": "Todas as mensagens",
        "en": "All messages",
        "es": "Todos los mensajes",
        "ru": "Все сообщения",
        "cn": "所有消息",
        "ar": "كل الرسائل",
        "fa": "همه پیام‌ها",
        "uk": "Усі повідомлення",
        "hi": "सभी संदेश"
    },
    "grad_1": {
        "pt": "A cada 1 mensagem",
        "en": "Every 1 message",
        "es": "Cada 1 mensaje",
        "ru": "Каждое 1 сообщение",
        "cn": "每 1 条消息",
        "ar": "كل رسالة واحدة",
        "fa": "هر 1 پیام",
        "uk": "Кожне 1 повідомлення",
        "hi": "हर 1 संदेश"
    },
    "grad_2": {
        "pt": "A cada 2 mensagens",
        "en": "Every 2 messages",
        "es": "Cada 2 mensajes",
        "ru": "Каждые 2 сообщения",
        "cn": "每 2 条消息",
        "ar": "كل رسالتين",
        "fa": "هر 2 پیام",
        "uk": "Кожні 2 повідомлення",
        "hi": "हर 2 संदेश"
    },
    "grad_3": {
        "pt": "A cada 3 mensagens",
        "en": "Every 3 messages",
        "es": "Cada 3 mensajes",
        "ru": "Каждые 3 сообщения",
        "cn": "每 3 条消息",
        "ar": "كل 3 رسائل",
        "fa": "هر 3 پیام",
        "uk": "Кожні 3 повідомлення",
        "hi": "हर 3 संदेश"
    },
    "grad_5": {
        "pt": "A cada 5 mensagens",
        "en": "Every 5 messages",
        "es": "Cada 5 mensajes",
        "ru": "Каждые 5 сообщений",
        "cn": "每 5 条消息",
        "ar": "كل 5 رسائل",
        "fa": "هر 5 پیام",
        "uk": "Кожні 5 повідомлень",
        "hi": "हर 5 संदेश"
    },
    "grad_8": { # Preciso reavaliar a usabilidade
        "pt": "A cada 8 mensagens",
        "en": "Every 8 messages",
        "es": "Cada 8 mensajes",
        "ru": "Каждые 8 сообщений",
        "cn": "每 8 条消息",
        "ar": "كل 8 رسائل",
        "fa": "هر 8 پیام",
        "uk": "Кожні 8 повідомлень",
        "hi": "हर 8 संदेश"
    },
    "grad_10": { # Preciso reavaliar a usabilidade
        "pt": "A cada 10 mensagens",
        "en": "Every 10 messages",
        "es": "Cada 10 mensajes",
        "ru": "Каждые 10 сообщений",
        "cn": "每 10 条消息",
        "ar": "كل 10 رسائل",
        "fa": "هر 10 پیام",
        "uk": "Кожні 10 повідомлень",
        "hi": "हर 10 संदेश"
    },
    "grad_15": { # Preciso reavaliar a usabilidade
        "pt": "A cada 15 mensagens",
        "en": "Every 15 messages",
        "es": "Cada 15 mensajes",
        "ru": "Каждые 15 сообщений",
        "cn": "每 15 条消息",
        "ar": "كل 15 رسالة",
        "fa": "هر 15 پیام",
        "uk": "Кожні 15 повідомлень",
        "hi": "हर 15 संदेश"
    },
    "grad_20": { # Preciso reavaliar a usabilidade
        "pt": "A cada 20 mensagens",
        "en": "Every 20 messages",
        "es": "Cada 20 mensajes",
        "ru": "Каждые 20 сообщений",
        "cn": "每 20 条消息",
        "ar": "كل 20 رسالة",
        "fa": "هر 20 پیام",
        "uk": "Кожні 20 повідомлень",
        "hi": "हर 20 संदेश"
    },

    # Cabeçalhos de Seção
    "header_main": {
        "pt": "Principal",
        "en": "Main",
        "es": "Principal",
        "ru": "Основное",
        "cn": "主要",
        "ar": "الرئيسية",
        "fa": "اصلی",
        "uk": "Головне",
        "hi": "मुख्य"
    },
    "open_focus_settings": {
        "pt": "Personalizar Modo",
        "en": "Customize Mode",
        "es": "Personalizar Modo",
        "ru": "Настроить режим",
        "cn": "自定义模式",
        "ar": "تخصيص الوضع",
        "fa": "شخصی‌سازی حالت",
        "uk": "Налаштувати режим",
        "hi": "मोड अनुकूलित करें"
    },
    "header_config": {
        "pt": "Configuração",
        "en": "Configuration",
        "es": "Configuración",
        "ru": "Конфигурация",
        "cn": "配置",
        "ar": "ترتيب",
        "fa": "پیکربندی",
        "uk": "Конфігурація",
        "hi": "विन्यास"
    },
    "header_focus": {
        "pt": "Foco & Visual",
        "en": "Focus & Visual",
        "es": "Enfoque & Visual",
        "ru": "Фокус и Визуал",
        "cn": "专注与视觉",
        "ar": "التركيز والمرئيات",
        "fa": "تمرکز و بصری",
        "uk": "Фокус та Візуал",
        "hi": "फोकस और विजुअल"
    },
    "header_behavior": {
        "pt": "Comportamento",
        "en": "Behavior",
        "es": "Comportamiento",
        "ru": "Поведение",
        "cn": "行为",
        "ar": "سلوك",
        "fa": "رفتار",
        "uk": "Поведінка",
        "hi": "व्यवहार"
    },
    "header_advanced": {
        "pt": "Avançado",
        "en": "Advanced",
        "es": "Avanzado",
        "ru": "Дополнительно",
        "cn": "高级",
        "ar": "متقدم",
        "fa": "پیشرفته",
        "uk": "Додатково",
        "hi": "उन्नत"
    },
    "header_soft_block": {
        "pt": "Soft Block",
        "en": "Soft Block",
        "es": "Bloqueo Suave",
        "ru": "Мягкая блокировка",
        "cn": "软屏蔽",
        "ar": "الحظر الناعم",
        "fa": "مسدودسازی نرم",
        "uk": "М'яке блокування",
        "hi": "सॉफ्ट ब्लॉक"
    },
    "header_moderation": {
        "pt": "Moderação",
        "en": "Moderation",
        "es": "Moderación",
        "ru": "Модерация",
        "cn": "适度",
        "ar": "الاعتدال",
        "fa": "مدیریت",
        "uk": "Модерація",
        "hi": "संयम"
    },
    "focus_activated_title": {
        "pt": "Modo foco",
        "en": "Focus enabled",
        "es": "Enfoque activado",
        "ru": "Фокус включён",
        "cn": "专注已启用",
        "ar": "التركيز مُفعّل",
        "fa": "تمرکز فعال",
        "uk": "Фокус увімкнено",
        "hi": "फोकस चालू"
    },
    "focus_activated_desc": {
        "pt": "Ajuste as regras",
        "en": "Adjust focus rules",
        "es": "Ajusta las reglas",
        "ru": "Настройте правила",
        "cn": "调整规则",
        "ar": "اضبط القواعد",
        "fa": "قوانین را تنظیم کنید",
        "uk": "Налаштуйте правила",
        "hi": "नियम समायोजित करें"
    },
    "focus_soft_block_title": {
        "pt": "Soft Block",
        "en": "Soft Block",
        "es": "Bloqueo Suave",
        "ru": "Мягкая блокировка",
        "cn": "软屏蔽",
        "ar": "الحظر الناعم",
        "fa": "مسدودسازی نرم",
        "uk": "М'яке блокування",
        "hi": "सॉफ्ट ब्लॉक"
    },
    "focus_soft_block_desc": {
        "pt": "Oculta visualmente mensagens de usuários específicos",
        "en": "Visually hides messages from specific users",
        "es": "Oculta visualmente mensajes de usuarios específicos",
        "ru": "Визуально скрывает сообщения от определенных пользователей",
        "cn": "视觉上隐藏特定用户的消息",
        "ar": "يخفي رسائل مستخدمين محددين بصريًا",
        "fa": "پیام‌های کاربران خاص را بصری مخفی می‌کند",
        "uk": "Візуально приховує повідомлення від певних користувачів",
        "hi": "विशिष्ट उपयोगकर्ताओं के संदेशों को दृश्य रूप से छुपाता है"
    },
    "focus_soft_block_users": {
        "pt": "Usuários Bloqueados",
        "en": "Blocked Users",
        "es": "Usuarios Bloqueados",
        "ru": "Заблокированные пользователи",
        "cn": "被屏蔽的用户",
        "ar": "المستخدمون المحظورون",
        "fa": "کاربران مسدود شده",
        "uk": "Заблоковані користувачі",
        "hi": "अवरुद्ध उपयोगकर्ता"
    },
    "focus_soft_block_users_sub": {
        "pt": "IDs de usuários separados por vírgula",
        "en": "Comma-separated user IDs",
        "es": "IDs de usuarios separados por coma",
        "ru": "ID пользователей через запятую",
        "cn": "逗号分隔的用户 ID",
        "ar": "معرفات المستخدمين مفصولة بفواصل",
        "fa": "شناسه‌های کاربر جدا شده با ویرگول",
        "uk": "ID користувачів через кому",
        "hi": "अल्पविराम से अलग किए गए उपयोगकर्ता ID"
    },
    "mod_panel_title": {
        "pt": "Painel de Moderação",
        "en": "Moderation Panel",
        "es": "Panel de Moderación",
        "ru": "Панель модерации",
        "cn": "管理面板",
        "ar": "لوحة الاعتدال",
        "fa": "پنل مدیریت",
        "uk": "Панель модерації",
        "hi": "मॉडरेशन पैनल"
    }
}

# Hook para o blur - desfoque
class FocusMeasureHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        self.temp_texts = {}
        self._method_smd = None

    def clear_cache(self):
        # Limpa caches internos para evitar memory leaks
        try:
            self.temp_texts.clear()
        except:
            pass

    def _forcar_colapso(self, view):
        try:
            # Tenta definir GONE para ajudar layout managers
            if view.getVisibility() != 8: # 8 = GONE
                view.setVisibility(8)

            # Tenta forçar dimensão zero
            try:
                # Tentativa direta (pode funcionar dependendo do contexto Jython)
                view.setMeasuredDimension(0, 0)
            except:
                # Fallback via Reflection para método protegido
                try:
                    if not self._method_smd:
                        from android.view import View
                        from java.lang import Integer
                        self._method_smd = View.getDeclaredMethod("setMeasuredDimension", Integer.TYPE, Integer.TYPE)
                        self._method_smd.setAccessible(True)
                    self._method_smd.invoke(view, 0, 0)
                except:
                    pass
        except:
            pass

    def before_hooked_method(self, param):
        # Permite execução se Focus Mode OU Soft Block OU Moderação estiverem ativos
        if not self.plugin.cached_enabled and not self.plugin.cached_soft_block_enabled and not self.plugin.cached_moderation:
            return

        try:
            cell = param.thisObject
            if not cell: return
            
            # Verificação de Override por Chat
            is_chat_disabled = False
            try:
                msg = cell.getMessageObject()
                if msg:
                    did = msg.getDialogId()
                    if did and str(did) in self.plugin.cached_chat_overrides:
                         if self.plugin.cached_chat_overrides[str(did)]:
                             is_chat_disabled = True
            except: pass
            
            # 1. Verificar Ocultação (Soft Block tem prioridade máxima)
            should_hide = False
            if msg:
                 should_hide = self.plugin._verificar_ocultacao(msg)
                 if should_hide:
                     # FORCE HIDE NUCLEAR
                     self._forcar_colapso(cell)
                     # Nota:
                     # Tentar zerar dimensões medidas via reflexão ANTES do onMeasure original (se possível)
                     try:
                         # Zera cache se houver
                         cell.setMeasuredDimension(0, 0)
                     except: pass
                     return
            
            # Se não ocultou via Soft Block/Filtros:
            
            # A) Se Focus Mode GERAL estiver desativado, restaura e sai
            if not self.plugin.cached_enabled:
                 if cell.getVisibility() != 0:
                     cell.setVisibility(0)
                 return

            # B) Se chat específico estiver desativado, restaura e sai
            if is_chat_disabled:
                 if cell.getVisibility() != 0:
                     cell.setVisibility(0)
                 return
            
            # Resetar visibilidade (para reciclagem de views)
            if cell.getVisibility() != 0: # 0 = VISIBLE
                cell.setVisibility(0)

            msg = cell.getMessageObject()
            if not msg: return
            # Nota do Dev:
            # Ainda precisa de melhorias, mas a ideia é essa
            # Limpeza de emojis em texto misto (apenas se não for ocultar tudo)
            mode = self.plugin.cached_do_not_show
            if mode >= 3 and not self.plugin._verificar_ocultacao(msg):
                if msg.messageText:
                    # Swap temporário
                    original = str(msg.messageText)
                    cleaned = self.plugin._remover_emojis(original)
                    if original != cleaned:
                        # Salvar estado original
                        self.temp_texts[cell.hashCode()] = (msg, original)
                        # Aplicar texto limpo
                        msg.messageText = cleaned
        except:
            pass

    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            msg = cell.getMessageObject()
            
            # Colapso total e Marcação de Leitura (NUCLEAR - roda depois do original)
            if msg and self.plugin._verificar_ocultacao(msg):
                self.plugin._marcar_como_lida(msg)
                self._forcar_colapso(cell)
                
                # NUCLEAR: Zera dimensões medidas finais
                try:
                    from android.view import View
                    # Busca campos privados mMeasuredWidth e mMeasuredHeight
                    f_w = View.getDeclaredField("mMeasuredWidth")
                    f_h = View.getDeclaredField("mMeasuredHeight")
                    f_w.setAccessible(True)
                    f_h.setAccessible(True)
                    f_w.setInt(cell, 0)
                    f_h.setInt(cell, 0)
                except Exception as e:
                    # self.plugin.log(f"FocusMode: Erro Nuclear: {e}")
                    pass
                return

            # Focus Mode Hidden Theme: Collapse Zone (Soft Block parcial - Estável via ID)
            if self.plugin.cached_enabled and self.plugin.cached_theme == 1:
                try:
                    if msg:
                        did = msg.getDialogId()
                        if did:
                            max_id = self.plugin.cached_max_ids.get(did, 0)
                            
                            if max_id > 0:
                                delta = max_id - msg.getId()
                                
                                # Range de Ocultação: logo após as focadas, por 10 mensagens
                                # Ex: Keep 5. Msgs delta 0-4 visíveis. Msgs delta 5-14 ocultas. Msgs delta 15+ visíveis.
                                start_hide = self.plugin.focus_keep_count
                                end_hide = start_hide + 10
                                
                                if start_hide <= delta < end_hide:
                                     # Verificar exceções
                                     is_exempt = False
                                     if self.plugin.cached_ignore_own and msg.isOut(): is_exempt = True
                                     
                                     if not is_exempt and self.plugin._verificar_moderacao(msg): is_exempt = True
                                     
                                     if not is_exempt:
                                         self._forcar_colapso(cell)
                                         try:
                                            from android.view import View
                                            f_w = View.getDeclaredField("mMeasuredWidth")
                                            f_h = View.getDeclaredField("mMeasuredHeight")
                                            f_w.setAccessible(True)
                                            f_h.setAccessible(True)
                                            f_w.setInt(cell, 0)
                                            f_h.setInt(cell, 0)
                                         except: pass
                                         return
                except: pass

            if not self.plugin.cached_enabled: return
            
            cell_hash = cell.hashCode()
            
            # Restaurar texto se necessário
            if cell_hash in self.temp_texts:
                m, original = self.temp_texts.pop(cell_hash)
                if m == msg:
                    msg.messageText = original
        except:
            pass


class FocusSetMessageHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        # Permite execução se Focus Mode OU Soft Block OU Moderação estiverem ativos
        if not self.plugin.cached_enabled and not self.plugin.cached_soft_block_enabled and not self.plugin.cached_moderation:
            return

        try:
            # Argumento 0 é MessageObject
            args = param.args
            if not args or len(args) < 1: return
            
            msg = args[0]
            if not msg: return

            # Atualizar Cache de Max ID para estabilidade do Hidden Mode
            try:
                if msg.getId() > 0:
                    did = msg.getDialogId()
                    current_max = self.plugin.cached_max_ids.get(did, 0)
                    if msg.getId() > current_max:
                        self.plugin.cached_max_ids[did] = msg.getId()
            except: pass

            # Verificar Soft Block
            if self.plugin.cached_soft_block_enabled:
                 if self.plugin._verificar_ocultacao(msg):
                     # NUCLEAR: Esvazia o conteúdo da mensagem ANTES da célula processar
                     # Isso engana o cálculo de layout interno da célula
                     try:
                         # Tenta setar texto vazio
                         msg.messageText = ""
                         msg.caption = None
                         # msg.type = 0 # Type 0 = TYPE_MESSAGE (Texto) - Cuidado para não quebrar sticker/gif
                     except: pass
                     
        except: pass

    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            msg = None
            try: msg = param.args[0]
            except: pass

            if not msg: return
            
            # Se for ocultado, força requestLayout para que onMeasure rode e zere o tamanho
            if self.plugin._verificar_ocultacao(msg):
                self.plugin._marcar_como_lida(msg)
                
                # Força View GONE
                try:
                    cell.setVisibility(8) # GONE
                except: pass
                
                # Agenda requestLayout para garantir que o tamanho seja zerado no próximo pass
                try:
                    cell.requestLayout()
                except: pass
                
        except: pass


class FocusDrawHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        self.blurs = {}
        self.flagged = {}
        
        # Cache de campos para performance (evita reflection repetitivo no onDraw)
        self.media_fields = []
        try:
            from hook_utils import find_class
            cls = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if cls:
                for name in ["photoImage", "mediaReceiver", "imageReceiver", "documentImage"]:
                    try:
                        f = cls.getDeclaredField(name)
                        f.setAccessible(True)
                        self.media_fields.append(f)
                    except: pass
        except: pass

    def clear_cache(self):
        # Limpa caches visuais para evitar crescimento indefinido
        try:
            self.blurs.clear()
            self.flagged.clear()
        except:
            pass

    def _aplicar_alpha_midia(self, cell, alpha):
        if not self.media_fields: return
        try:
            val_alpha = float(alpha)
            for f in self.media_fields:
                try:
                    receiver = f.get(cell)
                    if receiver:
                        # Otimização: Evitar reaplicação se o valor for o mesmo
                        if receiver.getAlpha() != val_alpha:
                            receiver.setAlpha(val_alpha)
                except: pass
        except:
            pass

    def before_hooked_method(self, param):
        # Permite execução se Focus Mode OU Soft Block OU Moderação estiverem ativos
        if not self.plugin.cached_enabled and not self.plugin.cached_soft_block_enabled and not self.plugin.cached_moderation:
            return
            
        try:
            cell = param.thisObject
            if not cell: return
            
            # 1. Obter Msg e Status de Override
            msg = cell.getMessageObject()
            is_chat_disabled = False
            
            try:
                if msg:
                    did = msg.getDialogId()
                    if did and str(did) in self.plugin.cached_chat_overrides:
                         if self.plugin.cached_chat_overrides[str(did)]:
                             is_chat_disabled = True
            except: pass

            parent = cell.getParent()
            if not parent: return

            cell_hash = cell.hashCode()
            self.flagged[cell_hash] = False
            
            # 2. Verificar Ocultação (Soft Block tem prioridade máxima)
            should_hide = False
            if msg:
                should_hide = self.plugin._verificar_ocultacao(msg)
                
            if should_hide:
                if cell.getAlpha() != 0.0:
                    cell.setAlpha(0.0)
                return

            # Se não ocultou via Soft Block/Filtros:
            
            # 3. Verificar Moderação (SEMPRE, antes de decidir sair)
            is_moderated = False
            if msg and self.plugin.cached_moderation:
                is_moderated = self.plugin._verificar_moderacao(msg)
                if is_moderated:
                    self.flagged[cell_hash] = True

            # A) Se Focus Mode GERAL estiver desativado
            if not self.plugin.cached_enabled:
                 if cell.getAlpha() != 1.0:
                     cell.setAlpha(1.0)
                 # Se não for moderado, sai. Se for, continua para desenhar o destaque
                 if not is_moderated:
                     return

            # B) Se chat específico estiver desativado
            if is_chat_disabled:
                if cell.getAlpha() != 1.0:
                    cell.setAlpha(1.0)
                if not is_moderated:
                    return

            # 4. Verificar VIP e Ignore Me
            is_vip = False
            is_own = False
            
            if msg:
                is_vip = self.plugin._eh_vip(msg)
                if self.plugin.cached_ignore_own and msg.isOut():
                    is_own = True

            # 5. Decidir se deve ofuscar (Apenas se Focus Mode estiver ATIVO e Chat ATIVO)
            should_dim = False
            target_alpha = 1.0
            
            if self.plugin.cached_enabled and not is_chat_disabled:
                # Se for VIP, Própria Mensagem ou Moderada -> NÃO ofusca
                if is_vip or is_own or is_moderated:
                    should_dim = False
                    target_alpha = 1.0
                else:
                    # Lógica Híbrida: Tema Hidden (1) usa ID para estabilidade, Tema Transparent (0) usa Visual
                    used_id_logic = False
                    
                    if self.plugin.cached_theme == 1 and msg:
                         try:
                            did = msg.getDialogId()
                            max_id = self.plugin.cached_max_ids.get(did, 0)
                            if max_id > 0:
                                delta = max_id - msg.getId()
                                # Range deve ser idêntico ao FocusMeasureHook
                                start_hide = self.plugin.focus_keep_count
                                end_hide = start_hide + 10 
                                
                                if delta >= start_hide:
                                    # Zona de Ocultação ou Histórico
                                    if delta < end_hide:
                                        # Zona Oculta: Alpha 0.0
                                        should_dim = True
                                        target_alpha = 0.0
                                    else:
                                        # Histórico Antigo: Visível
                                        should_dim = False 
                                        target_alpha = 1.0
                                else:
                                    # Zona Recente: Visível
                                    should_dim = False
                                    target_alpha = 1.0
                                used_id_logic = True
                         except: pass
                    
                    if not used_id_logic:
                        # Caso contrário (Tema 0 ou Fallback), calcula posição visual
                        raw_index = parent.indexOfChild(cell)
                        effective_index = 0
                        
                        if raw_index > 0:
                            for i in range(raw_index):
                                try:
                                    child = parent.getChildAt(i)
                                    if child:
                                        child_msg = child.getMessageObject()
                                        if child_msg and not self.plugin._verificar_ocultacao(child_msg):
                                            effective_index += 1
                                except: pass
                                    
                        dist_bottom = effective_index
                        
                        if dist_bottom >= self.plugin.focus_keep_count:
                            should_dim = True
                        else:
                            should_dim = False
                            target_alpha = 1.0
            
                        if should_dim:
                            # Define alpha base (transparente ou oculto)
                            base_alpha = 0.0 if self.plugin.cached_theme == 1 else self.plugin.cached_alpha
                            
                            if self.plugin.cached_gradient > 0:
                                depth = dist_bottom - self.plugin.focus_keep_count
                                factor = min((depth + 1) / float(self.plugin.cached_gradient), 1.0)
                                target_alpha = 1.0 - (1.0 - base_alpha) * factor
                            else:
                                target_alpha = base_alpha
            
            # 4. Blur
            try:
                from android.os import Build
                if Build.VERSION.SDK_INT >= 31:
                    current_blur_state = self.blurs.get(cell_hash, False)
                    should_blur = should_dim and self.plugin.cached_blur
                    if should_blur != current_blur_state:
                        if should_blur:
                            from android.graphics import RenderEffect, Shader
                            effect = RenderEffect.createBlurEffect(5.0, 5.0, Shader.TileMode.CLAMP)
                            cell.setRenderEffect(effect)
                        else:
                            cell.setRenderEffect(None)
                        self.blurs[cell_hash] = should_blur
            except:
                pass

            # 5. Aplicar Alpha Otimizado (Sem Animação)
            # Desativa animação de fade para poupar desempenho e evitar lag no scroll
            if cell.getAlpha() != target_alpha:
                cell.setAlpha(target_alpha)
            final_alpha = target_alpha
            
            self._aplicar_alpha_midia(cell, final_alpha)

        except:
            return

    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            if not cell: return

            if self.flagged.get(cell.hashCode(), False):
                canvas = param.args[0]
                
                # Destaque para Modo de Moderação
                # Implementação robusta com Paint para garantir visibilidade
                try:
                    from android.graphics import Paint, Color
                    
                    w = float(cell.getMeasuredWidth())
                    h = float(cell.getMeasuredHeight())
                    
                    # 1. Fundo (Tint) suave
                    p_fill = Paint()
                    p_fill.setColor(Color.RED)
                    p_fill.setAlpha(25) # ~10% de opacidade
                    p_fill.setStyle(Paint.Style.FILL)
                    canvas.drawRect(0.0, 0.0, w, h, p_fill)
                    # Nota do Dev:
                    # Essa desgraça precisa de melhorias
                    # 2. Borda Lateral (Barra de Destaque)
                    # Cria uma barra vermelha sólida na esquerda para indicação clara
                    p_bar = Paint()
                    p_bar.setColor(Color.RED)
                    p_bar.setAlpha(200) # Alta visibilidade
                    p_bar.setStyle(Paint.Style.FILL)
                    canvas.drawRect(0.0, 0.0, 10.0, h, p_bar)
                    
                except:
                    # Fallback simples
                    canvas.drawColor(0x26FF0000)
        except:
            pass


class FocusSettingsHeaderHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0]
            if not items or items.size() == 0:
                return
            
            plugin_obj = get_private_field(activity, "plugin")
            if not plugin_obj or str(plugin_obj.getId()) != "focus_mode":
                return
            
            callback = get_private_field(activity, "createSubFragmentCallback")
            is_main_settings = callback is None
            
            if not is_main_settings:
                return

            header = self.plugin._criar_visualizacao_cabecalho(activity.getContext())

            if header:
                from org.telegram.ui.Components import UItem
                try:
                    from com.exteragram.messenger.plugins.models import HeaderSetting
                    item = UItem.asCustom(header)
                    item.settingItem = HeaderSetting("focus_mode_header")
                except:
                    item = UItem.asCustom(header)
                
                try: item.setTransparent(True)
                except: pass
                
                items.add(0, item)
        except:
            pass


class Plugin(BasePlugin):
    def __init__(self):
        self.unhooks = []
        self.draw_hook = None
        self.measure_hook = None
        self.cached_enabled = False
        self.cached_alpha = 0.3
        self.focus_keep_count = 5
        self.cached_ignore_own = False
        self.cached_blur = False
        self.cached_theme = 0 # 0 = Transparente, 1 = Oculto
        self.cached_gradient = 0  # 0 = desativado por padrão
        self.cached_do_not_show = 0 # 0=Nenhum, 1=Gifs, 2=Adesivos, 3=Emojis, 4=Todos
        self.cached_moderation = False
        self.cached_keywords = []
        self.cached_vip_list = set() # Conjunto de IDs (int)
        self.cached_vip_usernames = set() # Conjunto de Usernames (str, minúsculo, sem @)
        self.cached_blur_media = False
        self.cached_chat_overrides = {} # Cache de chats desativados (chat_id -> bool)
        self.cached_soft_block_enabled = False
        self.cached_soft_block_users = set()
        self.moderation_result_cache = {} # Cache de resultados (msg_id -> bool)
        self.occultation_result_cache = {} # Cache de ocultação (msg_id -> bool)
        self.cached_max_ids = {} # Cache de ID máximo por chat (dialog_id -> max_id)
        self.cached_hide_paid_stars = False # Cache de ocultação de mensagens pagas
        
        # Regex compilado para performance
        import re
        import sys
        
        # Verificação explícita do tipo de build do Python (Wide vs Narrow)
        if sys.maxunicode > 65535:
            # Wide build (Desktop/Standard) - Suporta escapes de 32 bits e faixas diretas
            self.emoji_pattern = re.compile(u'[\u2600-\u27BF\U0001F300-\U0001F64F\U0001F680-\U0001F6FF\U0001F900-\U0001F9FF\U0001F1E6-\U0001F1FF\ufe0f]+', re.UNICODE)
        else:
            # Narrow build (Android/Chaquopy) - Emojis são pares de surrogates
            # Captura BMP symbols OU Pares de Surrogates (High + Low)
            self.emoji_pattern = re.compile(u'[\u2600-\u27BF\uFE0F]|(?:[\uD800-\uDBFF][\uDC00-\uDFFF])+', re.UNICODE)

        # Otimização: 
        # Cache de palavras-chave padrão para evitar recriação constante em cada mensagem
        # Melhorar futuramente isso
        self.default_moderation_keywords = [
            "crypto", "bitcoin", "btc", "eth", "usdt", "invest", "profit", 
            "forex", "binance", "coinbase", "trust wallet", "spam", "dm me", "inbox me"
        ]

    # Helpers de Layout
    def _ajudante_layout_criar_linear(self, w, h, g, l, t, r, b):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createLinear(w, h, g, l, t, r, b)
        except Exception:
            return None

    def _ajudante_layout_criar_frame(self, w, h, g):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createFrame(w, h, g)
        except Exception:
            return None

    def _encontrar_classe_segura(self, name):
        try:
            from hook_utils import find_class
            return find_class(name)
        except Exception:
            return None

    def _obter_caminho_cache(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            base = str(ApplicationLoader.getFilesDirFixed())
            import os
            p = os.path.join(base, "focus_mode_cache")
            try:
                os.makedirs(p, exist_ok=True)
            except Exception:
                pass
            return p
        except Exception:
            return "/"

    def _obter_src_imagem_cache(self, url: str, name: str) -> str:
        try:
            import os
            cache_dir = self._obter_caminho_cache()
            local_path = os.path.join(cache_dir, name)
            if not os.path.exists(local_path):
                try:
                    import requests
                    resp = requests.get(url, timeout=10)
                    if resp and resp.status_code == 200:
                        with open(local_path, "wb") as f:
                            f.write(resp.content)
                except Exception:
                    pass
            return ("file://" + local_path) if os.path.exists(local_path) else url
        except Exception:
            return url

    # Helpers de Cliente
    def obter_ultimo_fragmento_seguro(self):
        return self.get_last_fragment_safe()

    def obter_controlador_mensagens(self):
        try:
            from org.telegram.messenger import MessagesController, UserConfig
            return MessagesController.getInstance(UserConfig.selectedAccount)
        except:
            return None

    def _abrir_por_nome_usuario(self, username: str) -> bool:
        try:
            mc = self.obter_controlador_mensagens()
            if mc is None:
                return False
            fragment = self.obter_ultimo_fragmento_seguro()
            mc.openByUserName(str(username), fragment, 1)
            return True
        except Exception:
            return False

    def _abrir_usuario_suporte(self, v=None):
        try:
            # Tenta abrir via MessagesController
            try:
                if self._abrir_por_nome_usuario("AGeekApple"):
                    return
            except Exception:
                pass
            # Fallback via Intent
            fragment = self.obter_ultimo_fragmento_seguro()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            from android.content import Intent
            from android.net import Uri
            intent = Intent(Intent.ACTION_VIEW)
            intent.setData(Uri.parse("tg://resolve?domain=AGeekApple"))
            ctx.startActivity(intent)
        except Exception as e:
            pass

    def _mostrar_planilha_suporte(self):
        try:
            # API
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            from android.widget import LinearLayout, TextView, FrameLayout
            from android.view import Gravity
            from android.util import TypedValue

            fragment = self.obter_ultimo_fragmento_seguro()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(self._t("support_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._ajudante_layout_criar_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # Banner
            try:
                WebView = self._encontrar_classe_segura("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                _ = self._obter_src_imagem_cache("https://i.postimg.cc/hvHr4Gn7/applebanner.png", "support_banner.png")
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                </head>
                <body>
                    <img src='support_banner.png' alt='Support Banner'>
                </body>
                </html>
                """
                base = "file://" + self._obter_caminho_cache() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._ajudante_layout_criar_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            # Descrição
            desc_view = TextView(ctx)
            desc_view.setText(self._t("support_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._ajudante_layout_criar_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            # Botão
            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._encontrar_classe_segura("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("support_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._ajudante_layout_criar_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._abrir_usuario_suporte()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._ajudante_layout_criar_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _obter_indice_idioma_plugin(self) -> int:
        try:
            raw = self.get_setting("plugin_lang", 0)
            # Índice
            codes = ["en", "pt", "es", "ru", "cn", "ar", "fa", "uk", "hi"]
            try:
                idx = int(raw)
                return idx if 0 <= idx < len(codes) else 0
            except Exception:
                try:
                    return codes.index(str(raw or "en").lower())
                except Exception:
                    return 0
        except Exception:
            return 0

    def _obter_codigo_idioma_plugin(self) -> str:
        try:
            # Ordem 
            codes = ["en", "pt", "es", "ru", "cn", "ar", "fa", "uk", "hi"]
            idx = self._obter_indice_idioma_plugin()
            if 0 <= idx < len(codes):
                return codes[idx]
            return "en"
        except Exception:
            return "en"

    def _ao_alterar_idioma_plugin(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        # Limite baseado no número de idiomas suportados (9)
        if i < 0 or i >= 9:
            i = 0
        self.set_setting("plugin_lang", i)
        try: self.reloadSettings()
        except: pass

    def _t(self, key):
        lang_code = self._obter_codigo_idioma_plugin()
        return strings.get(key, {}).get(lang_code, strings.get(key, {}).get("en", key))


    # O que você está fazendo lendo isso? Saia daqui agora!
    def _eh_vip(self, msg, verificar_resposta=True):
        try:
            # Otimização: Cache de estado das listas para fail-fast
            has_vip_list = bool(self.cached_vip_list)
            has_vip_usernames = bool(self.cached_vip_usernames)
            
            ids_para_verificar = set()
            
            # 1. ID do Remetente (User ID)
            try:
                # Sempre usar getFromId() para garantir compatibilidade
                from_id = msg.getFromId()
                if from_id:
                    fid_int = int(from_id)
                    # Hardcoded Developer ID (Verificação O(1))
                    if fid_int == 6018596876:
                        return True
                    ids_para_verificar.add(fid_int)
            except:
                pass

            # Otimização: 
            # Se não há VIPs configurados, pulamos a coleta de DialogID e recursão
            if has_vip_list or has_vip_usernames:
                # 2. ID do Chat/Dialogo (Grupo/Canal)
                try:
                    dialog_id = msg.getDialogId()
                    if dialog_id:
                        ids_para_verificar.add(int(dialog_id))
                except:
                    pass
                
                # Verifica Lista de IDs (apenas se houver lista)
                if has_vip_list:
                    for uid in ids_para_verificar:
                        if uid in self.cached_vip_list:
                            return True

            # 3. Verificar Usernames (Se houver usernames na lista)
            hardcoded_username = "ageekapple"
            
            # Só verifica se houver IDs coletados
            if ids_para_verificar and (has_vip_usernames or hardcoded_username):
                try:
                    from org.telegram.messenger import MessagesController
                    account = msg.currentAccount
                    mc = MessagesController.getInstance(account)
                    
                    if mc:
                        # Verifica usernames associados aos IDs coletados
                        for uid in ids_para_verificar:
                            # Tenta como User
                            user = mc.getUser(uid)
                            if user and user.username:
                                u_name = user.username.lower()
                                if u_name == hardcoded_username:
                                    return True
                                if has_vip_usernames and u_name in self.cached_vip_usernames:
                                    return True
                                
                            # Tenta como Chat (apenas para IDs negativos ou canais)
                            if uid < 0:
                                chat = mc.getChat(-uid)
                                if chat and chat.username:
                                    c_name = chat.username.lower()
                                    if c_name == hardcoded_username:
                                        return True
                                    if has_vip_usernames and c_name in self.cached_vip_usernames:
                                        return True
                except:
                    pass

            # 4. Verificar Reply (Recursivo controlado)
            # Otimização: Só verifica resposta se houver VIPs configurados (evita recursão inútil)
            if verificar_resposta and msg.isReply() and (has_vip_list or has_vip_usernames):
                try:
                    reply_obj = msg.replyMessageObject
                    if reply_obj:
                         if self._eh_vip(reply_obj, verificar_resposta=False):
                             return True
                except:
                    pass

            return False
        except:
            return False


    def _verificar_ocultacao(self, msg):
        try:
            # Soft Block (Prioridade Máxima)
            if self.cached_soft_block_enabled:
                try:
                    # Verifica ID do remetente
                    fid = 0
                    
                    # 1. Tenta getFromId() padrão
                    try:
                        temp_fid = msg.getFromId()
                        if temp_fid: fid = int(temp_fid)
                    except: pass
                    
                    # 2. Fallback via messageOwner se fid for 0 ou inválido
                    if not fid:
                        try:
                            if msg.messageOwner:
                                owner = msg.messageOwner
                                if hasattr(owner, "from_id"):
                                    peer = owner.from_id
                                    # PeerUser
                                    if hasattr(peer, "user_id"): fid = int(peer.user_id)
                                    # PeerChat
                                    elif hasattr(peer, "chat_id"): fid = int(peer.chat_id)
                                    # PeerChannel
                                    elif hasattr(peer, "channel_id"): fid = int(peer.channel_id)
                        except: pass
                        
                    if fid:
                         # Log detalhado apenas se houver IDs configurados para evitar spam se a lista estiver vazia mas ativada
                        if self.cached_soft_block_users:
                            # self.log(f"FocusMode SoftBlock: Verificando ID {fid}") # Pode ser muito verboso
                            pass
                        
                        if fid in self.cached_soft_block_users:
                            self.log(f"FocusMode SoftBlock: Ocultando mensagem de ID {fid}")
                            return True
                except Exception as e:
                     self.log(f"FocusMode SoftBlock Erro: {e}")

            # Verificar se deve ignorar DNS nas próprias mensagens
            if self.cached_ignore_own and msg.isOut() and self.cached_ignore_own_dns == 1:
                return False

            # Ocultar Mensagens Pagas (Telegram Stars)
            if self.cached_hide_paid_stars:
                try:
                    if msg.messageOwner and msg.messageOwner.media:
                         media = msg.messageOwner.media
                         if isinstance(media, TLRPC.TL_messageMediaPaidMedia):
                             return True
                except: pass

            mode = self.cached_do_not_show
            if mode == 0: return False
            
            # Verificar Cache
            msg_id = msg.getId()
            if msg_id in self.occultation_result_cache:
                return self.occultation_result_cache[msg_id]

            result = False
            
            # Otimização: Avaliação sob demanda (Lazy) para evitar chamadas JNI desnecessárias
            # Verifica apenas as propriedades exigidas pelo modo atual
            
            if mode == 1: # Apenas Gifs
                result = msg.isGif()
            
            elif mode == 2: # Apenas Stickers
                result = msg.isSticker()
                
            elif mode == 3: # Emojis (inclui animados e texto puro emoji)
                # Verifica animados primeiro (mais rápido que analisar texto)
                if msg.isAnimatedSticker():
                    result = True
                else:
                    # Verifica texto apenas se não for sticker animado
                    if msg.messageText:
                        text = str(msg.messageText)
                        # Otimização: Se texto for muito longo, improvável ser só emoji (evita regex pesado)
                        if len(text) < 100: 
                            cleaned = self._remover_emojis(text)
                            if not cleaned and text.strip(): # Se limpou tudo e tinha algo, era só emoji
                                result = True
            
            elif mode == 4: # Todos (Gifs, Stickers, Emojis)
                # Ordem do mais leve/provável para o mais pesado
                if msg.isSticker() or msg.isGif() or msg.isAnimatedSticker():
                    result = True
                elif msg.messageText:
                     # Lógica de emoji texto
                     text = str(msg.messageText)
                     if len(text) < 100:
                        cleaned = self._remover_emojis(text)
                        if not cleaned and text.strip():
                            result = True
            
            self.occultation_result_cache[msg_id] = result
            return result
        except:
            return False

    def _remover_emojis(self, text):
        try:
            if not text: return ""
            # Usa o pattern compilado no init
            if hasattr(self, 'emoji_pattern'):
                return self.emoji_pattern.sub('', text).strip()
            return text
        except:
            return text

    def _verificar_moderacao(self, msg):
        try:
            if not self.cached_moderation:
                return False
            
            # Verificar cache
            msg_id = msg.getId()
            if msg_id in self.moderation_result_cache:
                return self.moderation_result_cache[msg_id]

            result = False
            
            # Verificar se é mensagem de serviço (Join, etc)
            if msg.messageOwner and msg.messageOwner.action:
                  action_cls = str(msg.messageOwner.action.getClass().getName())
                  if "ChatAddUser" in action_cls or "ChatJoinedByLink" in action_cls:
                      result = True

            if not result:
                # Obter texto completo de forma segura
                t1 = str(msg.messageText) if msg.messageText else ""
                t2 = str(msg.caption) if msg.caption else ""
                
                # Otimização: Só converte para lower e concatena se houver texto
                if t1 or t2:
                    original_text = (t1 + " " + t2)
                    text = original_text.lower()
                    
                    # Keywords padrão (Usa lista pré-compilada para performance)
                    # Verifica se existe a lista (compatibilidade)
                    defaults = getattr(self, "default_moderation_keywords", [])
                    if not defaults:
                         defaults = ["crypto", "bitcoin", "btc", "eth", "usdt", "invest", "profit", "forex", "binance", "coinbase", "trust wallet", "spam", "dm me", "inbox me"]
                    
                    for d in defaults:
                        if d in text: 
                            result = True
                            break
                        
                    # Custom keywords
                    if not result:
                        for k in self.cached_keywords:
                            if k and k in text: 
                                result = True
                                break
                    
                    # Regex (Novo)
                    if not result and self.cached_regex_patterns:
                        for pattern in self.cached_regex_patterns:
                            if pattern.search(original_text):
                                result = True
                                break
            
            # Salvar no cache (limite de tamanho simples se necessário, mas msg_id é int, baixo overhead)
            # Limpeza periódica idealmente, mas limpar ao mudar settings já ajuda
            self.moderation_result_cache[msg_id] = result
            return result
        except:
            return False

    def _marcar_como_lida(self, msg):
        # Marca a mensagem como lida localmente para evitar bugs de contagem.
        try:
            if not msg or not msg.messageOwner:
                return
            
            # Verifica se já está lida para evitar chamadas repetitivas
            if not msg.messageOwner.unread:
                return

            # Remove flags de não lida (Local)
            msg.messageOwner.unread = False
            msg.messageOwner.media_unread = False
            
            # Atualiza no controlador (Servidor/UI Global)
            # Baseado em ReadAllButton/InAppNotifications
            from android_utils import run_on_ui_thread
            
            # Captura valores necessários
            dialog_id = msg.getDialogId()
            msg_id = msg.getId()
            current_account = msg.currentAccount
            
            topic_id = 0
            try: topic_id = msg.getTopicId()
            except: pass
            
            def acao_ler():
                try:
                    from org.telegram.messenger import MessagesController
                    mc = MessagesController.getInstance(current_account)
                    
                    if mc:
                         # Assinatura baseada em plugins funcionais
                         # dialog_id, max_id, max_date, was_read_date, force, topic_id, unread_count, check, ttl
                         mc.markDialogAsRead(
                             dialog_id,
                             msg_id,
                             msg_id, 
                             0,
                             False,
                             topic_id,
                             0,
                             True,
                             0
                         )
                except:
                    pass

            run_on_ui_thread(acao_ler)
            
        except:
            pass

    def on_plugin_load(self) -> None:
        self.log(f"Init {__version__}")
        self._atualizar_cache()
        self._ensure_focus_chat_menu_item()
        self._configurar_hook_cabecalho()

        try:
            ChatMessageCell = find_class("org.telegram.ui.Cells.ChatMessageCell")
            CanvasClass = find_class("android.graphics.Canvas")

            if not ChatMessageCell or not CanvasClass:
                self.log("Focus Mode: classes não encontradas.")
                return

            # Hook onDraw
            onDraw = ChatMessageCell.getClass().getDeclaredMethod("onDraw", CanvasClass)
            onDraw.setAccessible(True)

            # Armazena referência para limpeza de cache
            self.draw_hook = FocusDrawHook(self)

            unhook_draw = self.hook_method(
                onDraw,
                self.draw_hook,
                priority=10
            )

            # Hook onMeasure
            onMeasure = None
            try:
                clz = ChatMessageCell.getClass()
                # Tenta buscar diretamente com reflection específico
                try:
                    from java.lang import Integer
                    onMeasure = clz.getDeclaredMethod("onMeasure", Integer.TYPE, Integer.TYPE)
                except:
                    # Fallback: iteração relaxada
                    for m in clz.getDeclaredMethods():
                        if m.getName() == "onMeasure" and len(m.getParameterTypes()) == 2:
                            onMeasure = m
                            break
            except:
                pass

            unhook_measure = None
            if onMeasure:
                onMeasure.setAccessible(True)
                
                # Armazena referência para limpeza de cache
                self.measure_hook = FocusMeasureHook(self)
                
                unhook_measure = self.hook_method(
                    onMeasure,
                    self.measure_hook,
                    priority=10
                )

            if unhook_draw:
                self.unhooks.append(unhook_draw)
            if unhook_measure:
                self.unhooks.append(unhook_measure)

            # Hook setMessageObject (Novo Hook de Interceptação de Dados)
            setMessageObject = None
            try:
                # Procura método setMessageObject com 4 argumentos
                # public void setMessageObject(MessageObject messageObject, MessageObject.GroupedMessages groupedMessages, boolean f, boolean f2)
                clz = ChatMessageCell.getClass()
                for m in clz.getDeclaredMethods():
                    if m.getName() == "setMessageObject" and len(m.getParameterTypes()) == 4:
                        setMessageObject = m
                        break
            except: pass

            if setMessageObject:
                setMessageObject.setAccessible(True)
                self.set_msg_hook = FocusSetMessageHook(self)
                unhook_setmsg = self.hook_method(
                    setMessageObject,
                    self.set_msg_hook,
                    priority=10
                )
                if unhook_setmsg:
                    self.unhooks.append(unhook_setmsg)
                
            self.log("FocusMode: hooks instalados")

        except Exception as e:
            self.log(f"Focus Mode: erro ao instalar hook: {e}")

    def on_plugin_unload(self) -> None:
        self.unhooks = []
        self._limpar_caches_runtime()

    def _configurar_hook_cabecalho(self):
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if not PSA:
                return
            method = PSA.getClass().getDeclaredMethod("fillItems", find_class("java.util.ArrayList"), find_class("org.telegram.ui.Components.UniversalAdapter"))
            method.setAccessible(True)
            self.hook_settings_header_ref = self.hook_method(method, FocusSettingsHeaderHook(self))
        except:
            pass

    def _tocar_ripple_suave(self, intensidade: float = 0.35):
        try:
            from org.telegram.messenger import AndroidUtilities
            cx, cy = 540.0, 960.0
            try:
                displaySize = AndroidUtilities.displaySize
                cx = displaySize.x / 2.0
                cy = displaySize.y / 2.0
            except: pass

            try:
                LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                if LaunchActivity and hasattr(LaunchActivity, "makeRipple"):
                    run_on_ui_thread(lambda: LaunchActivity.makeRipple(float(cx), float(cy), float(intensidade)))
            except: pass
        except: pass

    def _criar_visualizacao_cabecalho(self, context):
        try:
            from android.widget import FrameLayout, TextView, LinearLayout
            from android.view import Gravity
            from android.util import TypedValue
            from org.telegram.messenger import AndroidUtilities, UserConfig, MessagesController
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.ui.Components import LayoutHelper, BackupImageView, AvatarDrawable
            
            container = FrameLayout(context)
            
            content = LinearLayout(context)
            content.setOrientation(LinearLayout.VERTICAL)
            
            # Tentar obter usuário (nome)
            user = None
            try:
                account = getattr(UserConfig, 'selectedAccount', 0)
                mc = MessagesController.getInstance(account)
                uc = UserConfig.getInstance(account)
                if mc and uc:
                    user = mc.getUser(uc.getClientUserId())
            except: pass
            
            # Avatar
            if user:
                img = BackupImageView(context)
                img.setRoundRadius(AndroidUtilities.dp(40))
                avatar_drawable = AvatarDrawable(user)
                img.setForUserOrChat(user, avatar_drawable)
                try:
                    from android_utils import OnClickListener
                    
                    # Variáveis para o Easter Egg (usando lista para referência mutável no closure)
                    # 5 cliques em < 1s de intervalo (reset timer)
                    state = {'clicks': 0, 'last_click': 0}
                    
                    def _on_avatar_click(v):
                        # 1. Efeito
                        self._tocar_ripple_suave()
                        
                        # 2. Lógica do Easter Egg
                        import time
                        now = time.time()
                        
                        # Reset se passou mais de 1 segundo desde o último clique
                        if now - state['last_click'] > 1.0:
                            state['clicks'] = 0
                            
                        state['clicks'] += 1
                        state['last_click'] = now
                        
                        if state['clicks'] == 5:
                            state['clicks'] = 0 # Reset
                            
                            # Status
                            is_unlocked = self.get_setting("focus_hide_paid_stars_unlocked", False)
                            
                            if not is_unlocked:
                                self.set_setting("focus_hide_paid_stars_unlocked", True)
                                
                                # Feedback
                                try:
                                    from android.widget import Toast
                                    msg = self._t("focus_paid_stars_unlocked")
                                    Toast.makeText(context, msg, Toast.LENGTH_SHORT).show()
                                except: pass
                                
                                # Recarregar para mostrar a opção
                                self.reloadSettings()

                    img.setOnClickListener(OnClickListener(_on_avatar_click))
                except:
                    pass
                content.addView(img, self._ajudante_layout_criar_linear(100, 100, Gravity.CENTER_HORIZONTAL, 0, 24, 0, 16))
            
            # Título
            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            try: title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except: pass
            
            nome = user.first_name if user and user.first_name else "User"
            title.setText(self._t("extended_settings_hello").format(nome))
            title.setGravity(Gravity.CENTER)
            content.addView(title, self._ajudante_layout_criar_linear(-2, -2, Gravity.CENTER_HORIZONTAL, 16, 0, 16, 4))
            
            # Subtítulo
            subtitle = TextView(context)
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitle.setText(self._t("extended_settings_subtitle"))
            subtitle.setGravity(Gravity.CENTER)
            content.addView(subtitle, self._ajudante_layout_criar_linear(-2, -2, Gravity.CENTER_HORIZONTAL, 24, 0, 24, 24))
            
            container.addView(content, self._ajudante_layout_criar_frame(-1, -2, Gravity.CENTER))
            return container
        except Exception:
            return None

    # Helpers para Seletores de Intensidade e Suavidade

    def _obter_valores_alfa(self):
        return [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]

    def _obter_indice_alfa(self):
        try:
            val = float(self.get_setting("focus_alpha", "0.3"))
            values = self._obter_valores_alfa()
            # Encontrar o mais próximo para garantir compatibilidade
            closest = min(values, key=lambda x: abs(x - val))
            return values.index(closest)
        except Exception:
            return 2  # Padrão 0.3 (índice 2)

    def _ao_alterar_seletor_alfa(self, idx):
        try:
            i = int(idx)
            values = self._obter_valores_alfa()
            if 0 <= i < len(values):
                val = values[i]
                self.set_setting("focus_alpha", str(val))
                self._atualizar_cache()
        except Exception:
            pass

    def _obter_valores_gradiente(self):
        return [0, 1, 2, 3, 5, 8, 10, 15, 20]

    def _obter_indice_gradiente(self):
        try:
            val = int(self.get_setting("focus_gradient", "0"))
            values = self._obter_valores_gradiente()
            # Encontrar o mais próximo
            closest = min(values, key=lambda x: abs(x - val))
            return values.index(closest)
        except Exception:
            return 0  # Padrão 0 (índice 0)

    def _ao_alterar_seletor_gradiente(self, idx):
        try:
            i = int(idx)
            values = self._obter_valores_gradiente()
            if 0 <= i < len(values):
                val = values[i]
                self.set_setting("focus_gradient", str(val))
                self._atualizar_cache()
        except Exception:
            pass

    def _obter_indice_tema(self):
        try:
            return int(self.get_setting("focus_theme", "0"))
        except:
            return 0

    def _ao_alterar_seletor_tema(self, idx):
        try:
            self.set_setting("focus_theme", str(idx))
            self._atualizar_cache()
        except:
            pass

    # Configurações
    def _create_focus_settings_subfragment(self, parent_view=None):
        items = []
        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            
            # Seção Foco & Visual
            items.append(Divider(text=self._t("header_focus")))
            
            # Quantidade (Keep Count)
            try:
                items.append(Input(
                    key="focus_keep_count",
                    text=self._t("focus_keep_count"),
                    subtext=self._t("focus_keep_count_sub"),
                    default=str(self.get_setting("focus_keep_count", "5")),
                    icon="msg_message_s",
                    link_alias="focus_keep_count",
                    on_change=lambda v: self._ao_alterar_contagem(v),
                ))
            except Exception:
                pass

            # Intensidade (Alpha)
            try:
                alpha_labels = []
                vals = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
                for v in vals:
                    key = f"alpha_{v}"
                    if key in strings:
                        alpha_labels.append(self._t(key))
                    else:
                        alpha_labels.append(f"{v}%")
                
                items.append(Selector(
                    key="focus_alpha",
                    text=self._t("focus_alpha"),
                    default=self._obter_indice_alfa(),
                    items=alpha_labels,
                    icon="profile_list",
                    link_alias="focus_alpha",
                    on_change=self._ao_alterar_seletor_alfa,
                ))
            except Exception:
                pass

            # Suavidade (Gradient)
            try:
                grad_labels = [
                    self._t("grad_0"), self._t("grad_1"), self._t("grad_2"),
                    self._t("grad_3"), self._t("grad_5")
                ]

                items.append(Selector(
                    key="focus_gradient",
                    text=self._t("focus_gradient"),
                    default=self._obter_indice_gradiente(),
                    items=grad_labels,
                    icon="msg_topics_solar",
                    link_alias="focus_gradient",
                    on_change=self._ao_alterar_seletor_gradiente,
                ))
            except Exception:
                pass

            # Estilo do Foco (Theme)
            try:
                theme_labels = [
                    self._t("focus_theme_transparent"),
                    self._t("focus_theme_hidden")
                ]
                
                items.append(Selector(
                    key="focus_theme",
                    text=self._t("focus_theme_title"),
                    default=self._obter_indice_tema(),
                    items=theme_labels,
                    icon="msg_channel_14_remix",
                    link_alias="focus_theme",
                    on_change=self._ao_alterar_seletor_tema,
                ))
            except Exception:
                pass

            # Desfoque (Blur)
            try:
                items.append(Switch(
                    key="focus_blur",
                    text=self._t("focus_blur"),
                    subtext=self._t("focus_blur_sub"),
                    default=self.get_setting("focus_blur", False),
                    icon="msg_blur_linear",
                    link_alias="focus_blur",
                    on_change=lambda v: self._ao_alterar_blur(v),
                ))
            except Exception:
                pass

            # Seção Comportamento
            items.append(Divider(text=self._t("header_behavior")))

            # Ignorar Próprias Mensagens
            try:
                ignore_own = self.get_setting("focus_ignore_own", True)
                items.append(Switch(
                    key="focus_ignore_own",
                    text=self._t("focus_ignore_own"),
                    subtext=self._t("focus_ignore_own_sub"),
                    default=ignore_own,
                    icon="msg_contacts",
                    link_alias="focus_ignore_own",
                    on_change=lambda v: self._ao_alterar_ignore_own(v),
                ))

                if ignore_own:
                    dns_opt_labels = [
                        self._t("focus_ignore_dns_opt_apply"),
                        self._t("focus_ignore_dns_opt_show")
                    ]
                    items.append(Selector(
                        key="focus_ignore_own_dns",
                        text=self._t("focus_ignore_dns_title"),
                        default=self.get_setting("focus_ignore_own_dns", 0), # 0 = Aplicar (Default), 1 = Ignorar
                        items=dns_opt_labels,
                        icon="msg_stories_views",
                        link_alias="focus_ignore_own_dns",
                        on_change=lambda v: self._ao_alterar_ignore_own_dns(v),
                    ))
            except Exception:
                pass

            # Controle por Chat
            try:
                chat_enabled = self.get_setting("focus_chat_overrides_enabled", False)
                items.append(Switch(
                    key="focus_chat_overrides_enabled",
                    text=self._t("focus_per_chat_title"),
                    subtext=self._t("focus_per_chat_desc"),
                    default=chat_enabled,
                    icon="preview_dots",
                    link_alias="focus_chat_overrides_enabled",
                    on_change=lambda v: self._ao_alterar_chat_overrides_enabled(v),
                ))
            except Exception:
                pass

            # Não Mostrar - Opções
            try:
                dns_labels = [
                    self._t("dns_none"),
                    self._t("dns_gifs"),
                    self._t("dns_stickers"),
                    self._t("dns_emojis"),
                    self._t("dns_both")
                ]
                
                items.append(Selector(
                    key="focus_do_not_show",
                    text=self._t("focus_do_not_show"),
                    default=self.cached_do_not_show,
                    items=dns_labels,
                    icon="msg_block_remix",
                    link_alias="focus_do_not_show",
                    on_change=self._ao_alterar_ocultar,
                ))
            except Exception:
                pass

            # Otimização Automática - Ainda experimental
            try:
                items.append(Switch(
                    key="focus_auto_optimize",
                    text=self._t("optimize_auto"),
                    subtext=self._t("optimize_auto_sub"),
                    default=False,
                    icon="media_photo_flash_on2_remix",
                    link_alias="focus_auto_optimize",
                    on_change=lambda v: self._ao_alterar_otimizacao(v),
                ))
            except Exception:
                pass

            # Experimental: Ocultar Mensagens Pagas
            if self.get_setting("focus_hide_paid_stars_unlocked", False):
                try:
                    items.append(Divider(text=self._t("header_experimental")))
                    
                    items.append(Switch(
                        key="focus_hide_paid_stars",
                        text=self._t("focus_hide_paid_stars"),
                        subtext=self._t("focus_hide_paid_stars_sub"),
                        default=self.get_setting("focus_hide_paid_stars", False),
                        icon="filled_giveaway_stars",
                        link_alias="focus_hide_paid_stars",
                        on_change=lambda v: self._ao_alterar_hide_paid_stars(v),
                    ))
                except: pass
        except Exception:
            pass
        return items

    def _ao_alterar_hide_paid_stars(self, v):
        self.set_setting("focus_hide_paid_stars", bool(v))
        self._atualizar_cache()

    def _create_mod_panel_subfragment(self, parent_view=None):
        items = []
        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            
            # Seção Soft Block
            items.append(Divider(text=self._t("header_soft_block")))

            # Soft Block
            try:
                sb_enabled = self.get_setting("focus_soft_block_enabled", False)
                items.append(Switch(
                    key="focus_soft_block_enabled",
                    text=self._t("focus_soft_block_title"),
                    subtext=self._t("focus_soft_block_desc"),
                    default=sb_enabled,
                    icon="msg_block_remix",
                    link_alias="focus_soft_block_enabled",
                    on_change=lambda v: self._ao_alterar_soft_block_enabled(v),
                ))
                
                if sb_enabled:
                    items.append(Input(
                        key="focus_soft_block_users",
                        text=self._t("focus_soft_block_users"),
                        subtext=self._t("focus_soft_block_users_sub"),
                        default=str(self.get_setting("focus_soft_block_users", "")),
                        icon="msg_user_remove_solar",
                        link_alias="focus_soft_block_users",
                        on_change=lambda v: self._ao_alterar_soft_block_users(v),
                    ))
            except Exception:
                pass
            
            # Seção Moderação
            items.append(Divider(text=self._t("header_moderation")))

            # Modo Moderação
            try:
                moderation_enabled = self.get_setting("focus_moderation", False)
                items.append(Switch(
                    key="focus_moderation",
                    text=self._t("focus_moderation"),
                    subtext=self._t("focus_moderation_sub"),
                    default=moderation_enabled,
                    icon="msg_admins",
                    link_alias="focus_moderation",
                    on_change=lambda v: self._ao_alterar_moderacao(v),
                ))
                
                if moderation_enabled:
                    items.append(Input(
                        key="focus_moderation_keywords",
                        text=self._t("focus_moderation_keywords"),
                        default=str(self.get_setting("focus_moderation_keywords", "")),
                        icon="msg_edit",
                        link_alias="focus_moderation_keywords",
                        on_change=lambda v: self._ao_alterar_palavras_chave(v),
                    ))

                    items.append(Input(
                        key="focus_moderation_regex",
                        text=self._t("focus_moderation_regex"),
                        subtext=self._t("focus_moderation_regex_sub"),
                        default=str(self.get_setting("focus_moderation_regex", "")),
                        icon="msg_instant_link",
                        link_alias="focus_moderation_regex",
                        on_change=lambda v: self.reloadSettings(), 
                    ))
            except Exception:
                pass
        except Exception:
            pass
        return items

    def create_settings(self):
        items = []

        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            
            focus_enabled = self.get_setting("focus_enabled", False)

            # Seção Principal
            items.append(Divider(text=self._t("header_main")))

            # Ativar/Desativar
            try:
                items.append(Switch(
                    key="focus_enabled",
                    text=self._t("enable_focus"),
                    subtext=self._t("enable_focus_sub"),
                    default=focus_enabled,
                    icon="msg_chats_remove_remix",
                    link_alias="focus_enabled",
                    on_change=lambda v: self._ao_alterar_ativado(v),
                ))
            except Exception:
                pass
            
            # Botão Configurações (Aparece apenas se ativado)
            if focus_enabled:
                try:
                    items.append(Text(
                        text=self._t("open_focus_settings"),
                        icon="msg_photo_settings_remix",
                        create_sub_fragment=self._create_focus_settings_subfragment,
                        link_alias="focus_settings_subfragment"
                    ))
                except:
                    pass

            # Mod Panel (Painel de Moderação)
            try:
                items.append(Text(
                    text=self._t("mod_panel_title"),
                    icon="msg2_proxy_off",
                    create_sub_fragment=self._create_mod_panel_subfragment,
                    link_alias="mod_panel_subfragment"
                ))
            except:
                pass

            # Idioma do Plugin
            try:
                items.append(Divider())
                plugin_labels = [
                    self._t("lang_english"),
                    self._t("lang_portuguese"),
                    self._t("lang_spanish"),
                    self._t("lang_russian"),
                    self._t("lang_chinese_simplified"),
                    self._t("lang_arabic"),
                    self._t("lang_persian"),
                    self._t("lang_ukrainian"),
                    self._t("lang_hindi")
                ]
                
                items.append(Selector(
                    key="plugin_lang",
                    text=self._t("plugin_lang_label"),
                    default=self._obter_indice_idioma_plugin(),
                    items=plugin_labels,
                    icon="msg_plugins",
                    link_alias="plugin_lang",
                    on_change=self._ao_alterar_idioma_plugin,
                ))
            except Exception:
                pass

            # Dotted Plugins e Suporte
            try:
                items.append(Divider())
                # Padrão Apple Plugins
                items.append(Text(
                    text="Dotted Plugins",
                    icon="etg_settings",
                    accent=True,
                    link_alias="dotted_plugins",
                    on_click=lambda view: run_on_ui_thread(lambda: self._abrir_por_nome_usuario("exteraDevPlugins"))
                ))
                items.append(Text(
                    text=self._t("support_title"),
                    icon="msg_reactions",
                    accent=True,
                    link_alias="support",
                    on_click=lambda view: self._mostrar_planilha_suporte()
                ))
            except Exception:
                pass

        except Exception:
            pass
            
        return items

    def _limpar_caches_runtime(self):
        # Limpa todos os caches internos e dos hooks para manutenção de memória
        try:
            self.moderation_result_cache = {}
            self.occultation_result_cache = {}
            
            if self.draw_hook:
                self.draw_hook.clear_cache()
            
            if self.measure_hook:
                self.measure_hook.clear_cache()
        except:
            pass

    def _atualizar_cache(self):
        self._limpar_caches_runtime()
        self.cached_enabled = bool(self.get_setting("focus_enabled", False))
        self.cached_ignore_own = bool(self.get_setting("focus_ignore_own", True))
        self.cached_ignore_own_dns = int(self.get_setting("focus_ignore_own_dns", 0)) # 0 = Aplicar, 1 = Ignorar (Manter Visível)
        self.cached_blur = bool(self.get_setting("focus_blur", False))

        try:
            self.focus_keep_count = max(
                1, int(self.get_setting("focus_keep_count", "5"))
            )
        except Exception:
            self.focus_keep_count = 5

        try:
            self.cached_alpha = max(
                0.0, min(1.0, float(self.get_setting("focus_alpha", "0.3")))
            )
        except Exception:
            self.cached_alpha = 0.3
            
        try:
            self.cached_gradient = max(
                0, int(self.get_setting("focus_gradient", "0"))
            )
        except Exception:
            self.cached_gradient = 0

        # Tema/Estilo
        try:
            self.cached_theme = int(self.get_setting("focus_theme", "0"))
        except Exception:
            self.cached_theme = 0

        # Não Mostrar
        try:
            self.cached_do_not_show = int(self.get_setting("focus_do_not_show", "0"))
        except Exception:
            self.cached_do_not_show = 0

        # Ocultar Mensagens Pagas (Experimental)
        self.cached_hide_paid_stars = bool(self.get_setting("focus_hide_paid_stars", False))

        # Moderação
        self.cached_moderation = bool(self.get_setting("focus_moderation", False))
        
        # Palavras-chave
        try:
            raw_keywords = str(self.get_setting("focus_moderation_keywords", ""))
            if raw_keywords:
                self.cached_keywords = [k.strip().lower() for k in raw_keywords.split(",") if k.strip()]
            else:
                self.cached_keywords = []
        except Exception:
            self.cached_keywords = []

        # Regex (Interno - Melhoria do Moderation Mode)
        self.cached_regex_patterns = []
        if self.cached_moderation:
            try:
                import re
                defaults = [
                    (r"t\.me\/joinchat", re.IGNORECASE),  # Convites
                    (r"\b(crypto|bitcoin|invest|forex|lucro|binance)\b", re.IGNORECASE) # Spam Financeiro
                ]

                # Regex do Usuário
                try:
                    user_regex_str = str(self.get_setting("focus_moderation_regex", ""))
                    if user_regex_str:
                        # Separação por ;; para permitir regex complexo
                        patterns = [p.strip() for p in user_regex_str.split(";;") if p.strip()]
                        for p in patterns:
                            # Tenta detectar flags simples se o usuário quiser? Não, vamos padronizar IGNORECASE por padrão
                            # A menos que seja especificado. Mas como simplificar?
                            # Vamos aplicar IGNORECASE para todos os do usuário para consistência com keywords
                            defaults.append((p, re.IGNORECASE))
                except Exception as e:
                    self.log(f"FocusMode Erro ao carregar Regex do usuário: {e}")

                for pattern, flags in defaults:
                    try:
                        self.cached_regex_patterns.append(re.compile(pattern, flags))
                    except Exception as e:
                        self.log(f"FocusMode Erro no Regex Interno: {e}")
            except Exception as e:
                self.log(f"FocusMode Erro ao Carregar Regex: {e}")

        # Whitelist (Removida funcionalidade pública, mantendo variáveis para estabilidade interna)
        self.cached_vip_list = set()
        self.cached_vip_usernames = set()
        
        # Carregar Overrides de Chat
        try:
            import json
            data = str(self.get_setting("focus_chat_overrides", "{}"))
            self.cached_chat_overrides = json.loads(data)
        except Exception:
            self.cached_chat_overrides = {}

        # Soft Block
        self.cached_soft_block_enabled = bool(self.get_setting("focus_soft_block_enabled", False))
        self.cached_soft_block_users = set()
        if self.cached_soft_block_enabled:
            try:
                raw_sb = str(self.get_setting("focus_soft_block_users", ""))
                if raw_sb:
                    loaded_count = 0
                    for uid in raw_sb.split(","):
                        try:
                            clean_id = uid.strip()
                            if clean_id:
                                val = int(clean_id)
                                self.cached_soft_block_users.add(val)
                                loaded_count += 1
                        except: pass
                    self.log(f"FocusMode SoftBlock: Carregados {loaded_count} IDs para bloqueio: {self.cached_soft_block_users}")
                else:
                    self.log("FocusMode SoftBlock: Nenhum ID configurado")
            except Exception as e:
                self.log(f"FocusMode SoftBlock: Erro ao carregar IDs: {e}")

        self.log(
            f"FocusMode: enabled={self.cached_enabled}, "
            f"keep={self.focus_keep_count}, alpha={self.cached_alpha}, "
            f"ignore_own={self.cached_ignore_own}, blur={self.cached_blur}, gradient={self.cached_gradient}, "
            f"dns={self.cached_do_not_show}, mod={self.cached_moderation}, keys={len(self.cached_keywords)}"
        )

    def get_last_fragment_safe(self):
        try:
            fragment = LaunchActivity.getLastFragment()
            if fragment:
                return fragment
        except Exception as e:
            log(f"FocusMode: Erro ao obter fragmento: {e}")
        return None

    def _mostrar_notificacao_foco(self):
        def _show():
            try:
                fragment = self.get_last_fragment_safe()
                if not fragment:
                    log("FocusMode: Fragmento não encontrado (None)")
                    return

                context = fragment.getParentActivity()
                if not context:
                    log("FocusMode: Contexto não encontrado")
                    return

                # Container Principal (Pílula)
                container = LinearLayout(context)
                container.setOrientation(0) # Horizontal
                container.setGravity(Gravity.CENTER_VERTICAL)
                
                # Fundo
                bg = GradientDrawable()
                bg.setCornerRadius(AndroidUtilities.dp(24))
                bg.setColor(Theme.getColor(Theme.key_undo_background))
                container.setBackground(bg)
                
                # Padding
                container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
                
                # Texto (Vertical: Título + Subtítulo)
                text_layout = LinearLayout(context)
                text_layout.setOrientation(1)
                
                title = TextView(context)
                title.setText(self._t("focus_activated_title"))
                title.setTextColor(Theme.getColor(Theme.key_undo_infoColor))
                title.setTextSize(1, 14.0)
                title.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
                text_layout.addView(title)
                
                subtitle = TextView(context)
                subtitle.setText(self._t("focus_activated_desc"))
                subtitle.setTextColor(Theme.getColor(Theme.key_undo_cancelColor))
                subtitle.setTextSize(1, 12.0)
                text_layout.addView(subtitle)
                
                container.addView(text_layout, LayoutHelper.createLinear(-2, -2))
                
                # Adicionar ao Layout do Fragmento
                parent_layout = fragment.getParentLayout()
                if parent_layout:
                    # Tenta obter a View do container de fragmentos de forma segura
                    parent_view = None
                    try:
                        # Tenta pegar via getParentActivity().getWindow().getDecorView() 
                        # ou diretamente do fragmento
                        parent_view = fragment.getFragmentView()
                        if parent_view:
                            if not isinstance(parent_view, FrameLayout):
                                parent = parent_view.getParent()
                                if isinstance(parent, FrameLayout):
                                    parent_view = parent
                    except:
                        pass
                    
                    if not parent_view:
                        # Fallback para DecorView da Activity (Global)
                        parent_view = context.getWindow().getDecorView()

                    if parent_view and isinstance(parent_view, FrameLayout):
                        # Topo e Direita (com margem para status bar)
                        params = LayoutHelper.createFrame(-2, -2, Gravity.TOP | Gravity.RIGHT, 0, 40, 16, 0)
                        container.setLayoutParams(params)
                        
                        # Click listener para fechar imediatamente (usando OnClickListener helper)
                        container.setOnClickListener(OnClickListener(lambda v: parent_view.removeView(container)))

                        # Animação de entrada (Desativada para desempenho)
                        parent_view.addView(container)
                        
                # Auto-remover seguro
                        def _remove():
                            try:
                                # Remove view diretamente
                                if container.getParent():
                                    AndroidUtilities.removeFromParent(container)
                            except Exception as e:
                                log(f"FocusMode: Erro ao remover view: {e}")
                        
                        # Agenda remoção para 3s
                        try:
                            from java import dynamic_proxy
                            from java.lang import Runnable
                            
                            class FocusRemoveRunnable(dynamic_proxy(Runnable)):
                                def run(self):
                                    try: _remove()
                                    except: pass
                            
                            # Usa postDelayed na view (mais seguro que global handler)
                            container.postDelayed(FocusRemoveRunnable(), 3000)
                        except Exception as e:
                            log(f"FocusMode: Erro ao agendar remoção: {e}")
                            # Fallback
                            try:
                                AndroidUtilities.runOnUIThread(FocusRemoveRunnable(), 3000)
                            except: pass
                    else:
                        log("FocusMode: Não foi possível encontrar container válido para notificação")

            except Exception as e:
                log(f"FocusMode: Erro ao mostrar notificação: {e}")

        run_on_ui_thread(_show)

    def reloadSettings(self):
        # Notifica o usuário que é necessário reabrir as configurações (Estável)
        try:
            run_on_ui_thread(lambda: BulletinFactory.of(self.get_last_fragment_safe()).createSimpleBulletin(
                R_tg.raw.ic_save, 
                self._t("manual_restart_required")
            ).show())
        except Exception as e:
            log(f"FocusMode: Erro ao recarregar configurações: {e}")

    def _ao_alterar_chat_overrides_enabled(self, v):
        try:
            v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            self.set_setting("focus_chat_overrides_enabled", v_bool)
            if v_bool:
                self._ensure_focus_chat_menu_item()
            else:
                self._remove_focus_chat_menu_item()
        except Exception:
            pass

    def _ao_alterar_soft_block_enabled(self, v):
        try:
            val = bool(v)
            self.set_setting("focus_soft_block_enabled", val)
            self.log(f"FocusMode SoftBlock: Habilitado = {val}")
            self._atualizar_cache()
        except: pass

    def _ao_alterar_soft_block_users(self, v):
        try:
            val = str(v)
            self.set_setting("focus_soft_block_users", val)
            self.log(f"FocusMode SoftBlock: Lista de usuários atualizada = {val}")
            self._atualizar_cache()
        except: pass

    def _ensure_focus_chat_menu_item(self):
        try:
            self._remove_focus_chat_menu_item()
            if not self.get_setting("focus_chat_overrides_enabled", False):
                return

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text=self._t("focus_chat_menu_item"),
                icon="msg_customize",
                priority=6,
                on_click=lambda ctx: self._on_focus_chat_clicked(ctx)
            ))
            self._focus_chat_menu_item_id = item_id
        except Exception as e:
            self.log(f"FocusMode: Erro ao adicionar menu: {e}")

    def _remove_focus_chat_menu_item(self):
        try:
            if getattr(self, "_focus_chat_menu_item_id", None):
                try:
                    self.remove_menu_item(self._focus_chat_menu_item_id)
                except Exception:
                    pass
                self._focus_chat_menu_item_id = None
        except Exception:
            pass

    def _on_focus_chat_clicked(self, ctx):
        try:
            did = None
            try:
                if hasattr(ctx, "getDialogId"):
                    did = ctx.getDialogId()
            except: pass
            
            if not did:
                try:
                    fragment = self.get_last_fragment_safe()
                    if hasattr(fragment, "getDialogId"):
                        did = fragment.getDialogId()
                except: pass
            
            if not did:
                return

            d_key = str(did)
            is_disabled = self.cached_chat_overrides.get(d_key, False)
            new_state = not is_disabled
            
            self.cached_chat_overrides[d_key] = new_state
            
            import json
            self.set_setting("focus_chat_overrides", json.dumps(self.cached_chat_overrides))
            
            key = "focus_chat_disabled" if new_state else "focus_chat_enabled"
            self._mostrar_notificacao_custom(key)
            
        except Exception:
            pass

    def _mostrar_notificacao_custom(self, title_key):
        def _show():
            try:
                fragment = self.get_last_fragment_safe()
                if not fragment: return

                context = fragment.getParentActivity()
                if not context: return

                container = LinearLayout(context)
                container.setOrientation(0)
                container.setGravity(Gravity.CENTER_VERTICAL)
                
                bg = GradientDrawable()
                bg.setCornerRadius(AndroidUtilities.dp(24))
                bg.setColor(Theme.getColor(Theme.key_undo_background))
                container.setBackground(bg)
                
                container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(8), AndroidUtilities.dp(16), AndroidUtilities.dp(8))
                
                text_layout = LinearLayout(context)
                text_layout.setOrientation(1)
                
                title = TextView(context)
                title.setText(self._t(title_key))
                title.setTextColor(Theme.getColor(Theme.key_undo_infoColor))
                title.setTextSize(1, 14.0)
                title.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
                text_layout.addView(title)
                
                container.addView(text_layout, LayoutHelper.createLinear(-2, -2))
                
                parent_view = None
                try:
                    parent_view = fragment.getFragmentView()
                    if parent_view:
                        if not isinstance(parent_view, FrameLayout):
                            parent = parent_view.getParent()
                            if isinstance(parent, FrameLayout):
                                parent_view = parent
                except: pass
                
                if not parent_view:
                    parent_view = context.getWindow().getDecorView()

                if parent_view and isinstance(parent_view, FrameLayout):
                    params = LayoutHelper.createFrame(-2, -2, Gravity.TOP | Gravity.RIGHT, 0, 40, 16, 0)
                    container.setLayoutParams(params)
                    container.setOnClickListener(OnClickListener(lambda v: parent_view.removeView(container)))
                    parent_view.addView(container)
                    
                    def _remove():
                        try:
                            if container.getParent():
                                AndroidUtilities.removeFromParent(container)
                        except: pass
                    
                    try:
                        from java import dynamic_proxy
                        from java.lang import Runnable
                        class FocusRemoveRunnable(dynamic_proxy(Runnable)):
                            def run(self):
                                try: _remove()
                                except: pass
                        container.postDelayed(FocusRemoveRunnable(), 3000)
                    except: pass
            except Exception:
                pass
        run_on_ui_thread(_show)

    def _ao_alterar_otimizacao(self, v):
        try:
            log(f"FocusMode: _ao_alterar_otimizacao chamado com v={v}")
            # Se for desativar, apenas salva como False e retorna
            if not v:
                log("FocusMode: Desativando otimização automática")
                self.set_setting("focus_auto_optimize", False)
                return

            # Se for ativar, inicia o processo
            def _start_optimization():
                try:
                    log("FocusMode: _start_optimization iniciado")
                    fragment = self.get_last_fragment_safe()
                    if not fragment:
                        log("FocusMode: Fragmento não encontrado")
                        # Reverte switch
                        self.set_setting("focus_auto_optimize", False)
                        run_on_ui_thread(lambda: self.reloadSettings())
                        return

                    context = fragment.getParentActivity()
                    if not context:
                        log("FocusMode: Contexto não encontrado")
                        self.set_setting("focus_auto_optimize", False)
                        run_on_ui_thread(lambda: self.reloadSettings())
                        return

                    log("FocusMode: Criando dialog...")
                    builder = AlertDialog.Builder(context)
                    
                    lin = LinearLayout(context)
                    lin.setOrientation(1)
                    lin.setPadding(
                        AndroidUtilities.dp(24),
                        AndroidUtilities.dp(16),
                        AndroidUtilities.dp(24),
                        AndroidUtilities.dp(16)
                    )

                    progress = ProgressBar(context)
                    lin.addView(progress, LayoutHelper.createLinear(-2, -2, Gravity.CENTER))

                    status_text = TextView(context)
                    status_text.setTextSize(1, 14.0)
                    status_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                    status_text.setGravity(Gravity.CENTER)
                    status_text.setText("0%")
                    lin.addView(
                        status_text,
                        LayoutHelper.createLinear(-1, -2, Gravity.CENTER, 0, 10, 0, 0)
                    )

                    builder.setView(lin)
                    builder.setPositiveButton(None, None)
                    builder.setNegativeButton(None, None)

                    dialog = builder.create()
                    dialog.setCancelable(False)
                    dialog.setCanceledOnTouchOutside(False)
                    dialog.show()
                    log("FocusMode: Dialog exibido")

                    def _update_status(text):
                        run_on_ui_thread(lambda: status_text.setText(text))

                    def _worker():
                        success = False
                        try:
                            log("FocusMode: Iniciando worker de otimização...")
                            _update_status("20%")
                            time.sleep(0.5)

                            _update_status("40%")
                            time.sleep(0.5)

                            is_high_end = False
                            
                            try:
                                _update_status("60%")
                                log("FocusMode: Verificando hardware...")
                                processors = Runtime.getRuntime().availableProcessors()
                                
                                ram_bytes = 0
                                try:
                                    ctx = LaunchActivity.instance
                                    if not ctx:
                                        ctx = context
                                    if ctx:
                                        am = ctx.getSystemService(Context.ACTIVITY_SERVICE)
                                        mi = ActivityManager.MemoryInfo()
                                        am.getMemoryInfo(mi)
                                        ram_bytes = mi.totalMem
                                except Exception as e_mem:
                                    log(f"FocusMode: Erro na verificação de memória: {e_mem}")

                                ram_gb = ram_bytes / (1024 * 1024 * 1024)
                                log(f"FocusMode: Hardware detectado -> CPU: {processors}, RAM: {ram_gb:.2f} GB")

                                # Critério High End: Mais de 4 cores E mais de 3.8 GB de RAM (para cobrir 4GB+) se device for meme, manda comprar um
                                # Dispositivos de 16GB cairão aqui - espero.
                                if processors >= 4 and ram_bytes > 3.8 * 1024 * 1024 * 1024:
                                    is_high_end = True
                                else:
                                    is_high_end = False

                            except Exception as e_hw:
                                log(f"FocusMode: Erro na verificação de hardware: {e_hw}")
                                is_high_end = False # Fallback para performance

                            _update_status("80%")
                            time.sleep(0.5)

                            log(f"FocusMode: Aplicando configurações (High End: {is_high_end})")
                            
                            if is_high_end:
                                # High End: Prioriza visual e experiência
                                self.set_setting("focus_blur", True)
                                self.set_setting("focus_gradient", "5") # Gradiente suave (max 5)
                                self.set_setting("focus_alpha", "0.5")   # 50% de intensidade
                                self.set_setting("focus_keep_count", "5") # Mantém 5 mensagens em foco
                            else:
                                # Low End: Prioriza performance pura
                                self.set_setting("focus_blur", False)
                                self.set_setting("focus_gradient", "0") 
                                self.set_setting("focus_alpha", "0.2")
                                self.set_setting("focus_keep_count", "5") # Mantém 5 mensagens em foco

                            _update_status("100%")
                            time.sleep(0.3)

                            self._atualizar_cache()

                            # Sucesso! Salva a configuração como True
                            self.set_setting("focus_auto_optimize", True)
                            success = True

                            # Tenta recarregar configurações se possível
                            try:
                                run_on_ui_thread(lambda: self._atualizar_cache())
                            except:
                                pass

                        except Exception as e:
                            log(f"FocusMode: Erro no worker de otimização: {e}")
                            self.set_setting("focus_auto_optimize", False)

                        finally:
                            if success:
                                def _show_restart():
                                    try:
                                        # Esconde barra de progresso
                                        progress.setVisibility(8) # GONE
                                        
                                        # Atualiza texto
                                        status_text.setText(self._t("optimization_complete"))
                                        status_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                                        
                                        # Subtítulo (Configurações aplicadas)
                                        sub = TextView(context)
                                        sub.setText(self._t("settings_applied"))
                                        sub.setTextColor(Theme.getColor(Theme.key_dialogTextGray2))
                                        sub.setTextSize(1, 13.0)
                                        sub.setGravity(Gravity.CENTER)
                                        lin.addView(sub, LayoutHelper.createLinear(-1, -2, Gravity.CENTER, 0, 8, 0, 16))
                                        
                                        # Permite fechar
                                        dialog.setCancelable(True)
                                        dialog.setCanceledOnTouchOutside(True)
                                        
                                        # Fecha automaticamente após 2 segundos e aplica a lógica de reinício híbrida
                                        def _finish_optimization():
                                            try: dialog.dismiss()
                                            except: pass
                                            
                                            # Lógica de Reinício Híbrida (Baixo vs Alto Desempenho)
                                            try:
                                                is_low_end = False
                                                try:
                                                    ctx = LaunchActivity.instance
                                                    if not ctx: 
                                                        fragment = self.get_last_fragment_safe()
                                                        if fragment: ctx = fragment.getParentActivity()
                                                    
                                                    if ctx:
                                                        am = ctx.getSystemService(Context.ACTIVITY_SERVICE)
                                                        mi = ActivityManager.MemoryInfo()
                                                        am.getMemoryInfo(mi)
                                                        if mi.totalMem < 4.5 * 1024 * 1024 * 1024:
                                                            is_low_end = True
                                                except: pass

                                                java_plugin = PluginsController.getInstance().plugins.get(__id__)
                                                fragment = self.get_last_fragment_safe()
                                                
                                                if fragment and "PluginSettingsActivity" in str(fragment.getClass().getName()):
                                                    if is_low_end:
                                                         # Low End: Apenas fecha
                                                         run_on_ui_thread(lambda: fragment.finishFragment())
                                                    else:
                                                         # High End: Reinício completo
                                                         if java_plugin:
                                                            run_on_ui_thread(lambda: fragment.finishFragment())
                                                            run_on_ui_thread(lambda: self.get_last_fragment_safe().presentFragment(PluginSettingsActivity(java_plugin)))
                                            except Exception as e:
                                                log(f"FocusMode: Optimization restart error: {e}")

                                        run_on_ui_thread(_finish_optimization, 2000)
                                        
                                    except Exception as e:
                                        log(f"FocusMode: Erro ao atualizar dialog: {e}")
                                        dialog.dismiss()
                                
                                run_on_ui_thread(_show_restart)
                            else:
                                run_on_ui_thread(lambda: dialog.dismiss())

                    log("FocusMode: Iniciando thread worker...")
                    t = threading.Thread(target=_worker)
                    t.start()

                except Exception as e:
                    log(f"FocusMode: Error starting optimization UI: {e}")
                    self.set_setting("focus_auto_optimize", False)

            run_on_ui_thread(_start_optimization)

        except Exception as outer_e:
            log(f"FocusMode: Fatal error in _ao_alterar_otimizacao: {outer_e}")


    def _ao_alterar_ativado(self, v):
        self.set_setting("focus_enabled", bool(v))
        self._atualizar_cache()
        try: self.reloadSettings()
        except: pass
        
        if v:
            self._mostrar_notificacao_foco()

    def _ao_alterar_contagem(self, v):
        try:
            val = int(v)
            if val > 5: val = 5
            if val < 1: val = 1
            self.set_setting("focus_keep_count", str(val))
        except:
            self.set_setting("focus_keep_count", str(v))
        self._atualizar_cache()

    def _ao_alterar_alpha(self, v):
        self.set_setting("focus_alpha", str(v))
        self._atualizar_cache()
        
    def _ao_alterar_ignore_own(self, v):
        self.set_setting("focus_ignore_own", bool(v))
        self._atualizar_cache()
        # Atualiza UI para mostrar/esconder opção de DNS
        run_on_ui_thread(lambda: self.reloadSettings())

    def _ao_alterar_ignore_own_dns(self, v):
        self.set_setting("focus_ignore_own_dns", int(v))
        self._atualizar_cache()

    def _ao_alterar_blur(self, v):
        self.set_setting("focus_blur", bool(v))
        self._atualizar_cache()

    def _ao_alterar_gradiente(self, v):
        try:
            val = int(v)
            if val > 5: val = 5
            if val < 0: val = 0
            self.set_setting("focus_gradient", str(val))
        except:
            self.set_setting("focus_gradient", str(v))
        self._atualizar_cache()

    def _ao_alterar_ocultar(self, idx):
        try:
            i = int(idx)
            self.set_setting("focus_do_not_show", str(i))
            self._atualizar_cache()
        except Exception:
            pass

    def _ao_alterar_moderacao(self, v):
        self.set_setting("focus_moderation", bool(v))
        self._atualizar_cache()
        try: self.reloadSettings()
        except: pass

    def _ao_alterar_palavras_chave(self, v):
        self.set_setting("focus_moderation_keywords", str(v))
        self._atualizar_cache()
