__id__ = "gadcrypto_pg"
__name__ = "GadCrypto"
__author__ = "@Vladislav_01a"
__version__ = "1.3.3"
__description__ = """Thanks https://t.me/wavacat

A versatile multi-encoder/decoder for various text transformations. Features encryption/decryption via dialogs and a command (.gdec) for quick decryption attempts. Supported methods: Binary, Base64, Base32, Base16, ASCII, URL, BaseXi, Hex, Zlib, Base85, Base91, Unicode Escape, Hexy, Octal, SHA1, SHA2, SHA3, MD5, Numy, SL, XOR (with key), XNOR (with key)."""

__icon__ = "CMXLang_by_fStikBot/0"
__min_version__ = "11.12.0"

import re
import base64
import urllib.parse
import zlib
import os
import codecs
import hashlib
from typing import Any, Callable, Dict, List, Optional, Tuple

from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from client_utils import get_last_fragment, run_on_queue, send_message
from android_utils import run_on_ui_thread, log
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from markdown_utils import parse_markdown

# --- Localization System ---
class Locales:
    strings = {
        'en': {
            "plugin_name": "gadcrypto",
            "plugin_description": "A versatile multi-encoder/decoder for various text transformations. Features encryption/decryption via dialogs and a command (.gdec) for quick decryption attempts. Supported methods: Binary, Base64, Base32, Base16, ASCII, URL, BaseXi, Hex, Zlib, Base85, Base91, Unicode Escape, Hexy, Octal, SHA1, SHA2, SHA3, MD5, Numy, SL, XOR (with key), XNOR (with key).",
            "menu_encrypt": "Encrypt",
            "select_encryption_method_title": "Select Encryption Method",
            "select_decryption_method_title": "Select Decryption Method",
            "possible_decryption_prefix": "Possible: ",
            "enter_text_to_action": "Enter text to {action_type}...",
            "text_cannot_be_empty": "Text cannot be empty.",
            "enter_key_hint": "Enter key...",
            "key_cannot_be_empty": "Key cannot be empty.",
            "button_ok": "OK",
            "button_cancel": "Cancel",
            "button_send": "Send",
            "encoded_prefix": "",
            "decrypted_prefix": "**Decrypted ({method_name}):**",
            "error_chat_context": "Could not determine chat context.",
            "error_no_methods": "No {type} methods found.",
            "error_no_text_to_decrypt": "No text to decrypt. Reply to a message or provide text with command.",
            "error_action_failed": "Failed to {action_type} text. Invalid input or key.",
            "error_decryption_failed_specific": "Failed to decrypt via {method_name}. Invalid input format or key.",
            "error_during_action": "Error during {action_type} ({method_name}): {error}",
            "success_action": "Successfully {action_type}ed.",
            "settings_language": "Language",
            "settings_language_auto": "Automatic",
            "settings_language_english": "English",
            "settings_language_russian": "Русский",
            "settings_title": "gadcrypto Settings"
        },
        'ru': {
            "plugin_name": "gadcrypto",
            "plugin_description": "Универсальный мульти-кодировщик/декодировщик для различных текстовых преобразований. Поддерживает шифрование/дешифрование через диалоги и команду (.gdec) для быстрой дешифровки. Поддерживаемые методы: Бинарный, Base64, Base32, Base16, ASCII, URL, BaseXi, Hex, Zlib, Base85, Base91, Unicode Escape, Hexy, Octal, SHA1, SHA2, SHA3, MD5, Numy, SL, XOR (с ключом), XNOR (с ключом).",
            "menu_encrypt": "Зашифровать",
            "select_encryption_method_title": "Выберите метод шифрования",
            "select_decryption_method_title": "Выберите метод дешифровки",
            "possible_decryption_prefix": "Возможно: ",
            "enter_text_to_action": "Введите текст для {action_type}...",
            "text_cannot_be_empty": "Текст не может быть пустым.",
            "enter_key_hint": "Введите ключ...",
            "key_cannot_be_empty": "Ключ не может быть пустым.",
            "button_ok": "ОК",
            "button_cancel": "Отмена",
            "button_send": "Отправить",
            "encoded_prefix": "",
            "decrypted_prefix": "**Расшифровано ({method_name}):**",
            "error_chat_context": "Не удалось определить контекст чата.",
            "error_no_methods": "Методы {type} не найдены.",
            "error_action_failed": "Не удалось {action_type} текст. Неверный ввод или ключ.",
            "error_no_text_to_decrypt": "Нет текста для дешифровки. Ответьте на сообщение или введите текст командой.",
            "error_decryption_failed_specific": "Не удалось расшифровать через {method_name}. Неверный формат ввода или ключ.",
            "error_during_action": "Ошибка во время {action_type} ({method_name}): {error}",
            "success_action": "Успешно {action_type}ено.",
            "settings_language": "Язык",
            "settings_language_auto": "Автоматически",
            "settings_language_english": "English",
            "settings_language_russian": "Русский",
            "settings_title": "Настройки gadcrypto"
        }
    }

def get_localized_string(key: str, pg_plugin_instance: Optional[Any] = None, **kwargs) -> str:
    pg_selected_language_code = "en"
    
    if pg_plugin_instance:
        language_setting = pg_plugin_instance.get_setting("language_override", 0)
        if language_setting == 1:
            pg_selected_language_code = "en"
        elif language_setting == 2:
            pg_selected_language_code = "ru"
        else:
            try:
                from org.telegram.messenger import LocaleController
                pg_current_locale_lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
                if pg_current_locale_lang.startswith('ru'):
                    pg_selected_language_code = "ru"
            except ImportError:
                pg_selected_language_code = "en"
            except Exception:
                pg_selected_language_code = "en"

    pg_locale_dict = Locales.strings.get(pg_selected_language_code, Locales.strings['en'])
    value = pg_locale_dict.get(key, Locales.strings['en'].get(key, key))
    
    if isinstance(value, str) and kwargs:
        return value.format(**kwargs)
    return value

def text_to_base_n(s: str, base: int) -> str:
    encoded_bytes = s.encode("utf-8")
    if base == 2:
        formatter = lambda b: format(b, '08b')
    elif base == 8:
        formatter = lambda b: format(b, '03o')
    else:
        raise ValueError("Unsupported base for this helper function")
    return " ".join(formatter(b) for b in encoded_bytes)

def base_n_to_text(s: str, base: int) -> str:
    try:
        parts = s.strip().split()
        byte_array = bytearray(int(p, base) for p in parts)
        return byte_array.decode("utf-8", errors="strict")
    except Exception:
        return ""

def text_to_binary(s: str) -> str: return text_to_base_n(s, 2)
def binary_to_text(binary: str) -> str: return base_n_to_text(binary, 2)

def text_to_octal(s: str) -> str: return text_to_base_n(s, 8)
def octal_to_text(s: str) -> str: return base_n_to_text(s, 8)

def text_to_base64(s: str) -> str: return base64.b64encode(s.encode("utf-8")).decode("utf-8")
def base64_to_text(s: str) -> str:
    try: return base64.b64decode(s).decode("utf-8")
    except Exception: return ""

def text_to_base32(s: str) -> str: return base64.b32encode(s.encode("utf-8")).decode("utf-8")
def base32_to_text(s: str) -> str:
    try: return base64.b32decode(s).decode("utf-8")
    except Exception: return ""

def text_to_base16(s: str) -> str: return base64.b16encode(s.encode("utf-8")).decode("utf-8")
def base16_to_text(s: str) -> str:
    try: return base64.b16decode(s).decode("utf-8")
    except Exception: return ""

def text_to_ascii(s: str) -> str: return " ".join(str(ord(ch)) for ch in s)
def ascii_to_text(s: str) -> str:
    try: return "".join(chr(int(code)) for code in s.strip().split())
    except Exception: return ""

def text_to_url(s: str) -> str: return urllib.parse.quote(s)
def url_to_text(s: str) -> str:
    try: return urllib.parse.unquote(s)
    except Exception: return ""

def text_to_hex(s: str) -> str: return s.encode("utf-8").hex()
def hex_to_text(s: str) -> str:
    try:
        if len(s) % 2 != 0: return ""
        return bytes.fromhex(s).decode("utf-8")
    except Exception: return ""

def text_to_zlib(s: str) -> str: return zlib.compress(s.encode("utf-8")).hex()
def zlib_to_text(s: str) -> str:
    try: return zlib.decompress(bytes.fromhex(s)).decode("utf-8")
    except Exception: return ""

def text_to_base85(s: str) -> str: return base64.b85encode(s.encode("utf-8")).decode("utf-8")
def base85_to_text(s: str) -> str:
    try: return base64.b85decode(s).decode("utf-8")
    except Exception: return ""

B91_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+,./:;<=>?@[]^_`{|}~"'
B91_VAL = {ch: i for i, ch in enumerate(B91_ALPHABET)}

def base91_encode(data: bytes) -> str:
    b = 0; n = 0; out = []
    for byte in data:
        b |= byte << n; n += 8
        if n > 13:
            v = b & 8191
            if v > 88: b >>= 13; n -= 13
            else: v = b & 16383; b >>= 14; n -= 14
            out.append(B91_ALPHABET[v % 91]); out.append(B91_ALPHABET[v // 91])
    if n:
        out.append(B91_ALPHABET[b % 91])
        if n > 7 or b > 90: out.append(B91_ALPHABET[b // 91])
    return "".join(out)

def base91_decode(s: str) -> bytes:
    v = -1; b = 0; n = 0; out = []
    for ch in s:
        if ch not in B91_VAL: continue
        c = B91_VAL[ch]
        if v == -1: v = c
        else:
            v += c * 91
            b |= v << n
            n += 13 if (v & 8191) > 88 else 14
            while n >= 8: out.append(b & 255); b >>= 8; n -= 8
            v = -1
    if v != -1: out.append((b | v << n) & 255)
    return bytes(out)

def text_to_base91(s: str) -> str: return base91_encode(s.encode("utf-8"))
def base91_to_text(s: str) -> str:
    try: return base91_decode(s).decode("utf-8")
    except Exception: return ""

def text_to_unicode_escape(s: str) -> str:
    out = []
    for ch in s:
        cp = ord(ch)
        if cp <= 0xFFFF:
            out.append(f'\\u{cp:04x}')
        else:
            out.append(f'\\U{cp:08x}')
    return ''.join(out)

def unicode_escape_to_text(s: str) -> str:
    try:
        return codecs.decode(s, 'unicode_escape')
    except Exception:
        try:
            fixed = s.replace(r'\\u', r'\u').replace(r'\\U', r'\U')
            return codecs.decode(fixed, 'unicode_escape')
        except Exception:
            return ""

ALPHABET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_.~!*'();:@&=+$,/?#[]"
BASE = len(ALPHABET)
CHAR_TO_VAL = {c: i for i, c in enumerate(ALPHABET)}

def crc8(data: bytes) -> int: return zlib.crc32(data) & 0xFF

def int_to_base(n: int) -> str:
    if n == 0: return ALPHABET[0]
    digits = []
    while n > 0: n, r = divmod(n, BASE); digits.append(ALPHABET[r])
    return "".join(reversed(digits))

def base_to_int(s: str) -> int:
    n = 0
    for ch in s: n = n * BASE + CHAR_TO_VAL[ch]
    return n

def encode_baseXi(text: str) -> str:
    data = text.encode("utf-8"); ln = len(data)
    n = int.from_bytes(data, "big") if ln > 0 else 0
    core = int_to_base(n); length_str = int_to_base(ln)
    checksum = ALPHABET[crc8(data) % BASE]; shift_char = ALPHABET[os.urandom(1)[0] % BASE]
    return f"Ξ{core}|{length_str}{checksum}{shift_char}"

def decode_baseXi(code: str) -> str:
    if not code.startswith("Ξ"): raise ValueError("Invalid BaseXi format")
    try:
        core, rest = code[1:].split("|", 1)
        core_int = base_to_int(core) if core else 0
        length_str = rest[:-2]
        checksum_char = rest[-2]
    except Exception: raise ValueError("Invalid BaseXi format")
    ln = base_to_int(length_str)
    b = core_int.to_bytes(ln, "big")
    if ALPHABET[crc8(b) % BASE] != checksum_char: raise ValueError("Checksum error")
    return b.decode("utf-8", errors="replace")

def text_to_basexi(s: str) -> str: return encode_baseXi(s)
def basexi_to_text(s: str) -> str:
    try: return decode_baseXi(s)
    except Exception: return ""

HEXY_ALPHABET = "@#$€¥=√&!?%✓[]{}"
HEXY_SHIFT_ALPH = "|•>/"

def text_to_hexy(s: str) -> str:
    shift = HEXY_SHIFT_ALPH[len(s) % 4]
    shifting_power = HEXY_SHIFT_ALPH.find(shift) + 1
    shifted = HEXY_ALPHABET[-shifting_power:] + HEXY_ALPHABET[:-shifting_power]
    base = len(shifted); core_parts = []
    for i, char in enumerate(s):
        num_to_encode = ord(char) + shifting_power + i
        encoded_part = ""
        if num_to_encode == 0: encoded_part = shifted[0]
        else:
            temp_num = num_to_encode
            while temp_num > 0:
                remainder = temp_num % base
                encoded_part = shifted[remainder] + encoded_part
                temp_num //= base
            # Add padding for single-digit numbers if needed to maintain structure
            if not encoded_part:
                encoded_part = shifted[0]
        core_parts.append(encoded_part)
    core = " ".join(core_parts)
    return f"hexy {shift} {core}"

def hexy_to_text(s: str) -> str:
    try:
        if not s.startswith("hexy "): return ""
        parts = s.split(" ", 2);
        if len(parts) < 3: return ""
        _header, shift, core = parts
        shifting_power = HEXY_SHIFT_ALPH.find(shift);
        if shifting_power == -1: return ""
        shifting_power += 1
        shifted = HEXY_ALPHABET[-shifting_power:] + HEXY_ALPHABET[:-shifting_power]
        base = len(shifted); core_parts = core.split(" "); decoded_chars = []
        for i, encoded_part in enumerate(core_parts):
            if not encoded_part: continue
            decoded_num = 0
            for digit_char in encoded_part:
                digit_value = shifted.find(digit_char);
                if digit_value == -1: return ""
                decoded_num = decoded_num * base + digit_value
            original_ord = decoded_num - shifting_power - i
            decoded_chars.append(chr(original_ord))
        return "".join(decoded_chars)
    except Exception: return ""

def text_to_sha1(s: str) -> str:
    try: h = hashlib.sha1(); h.update(s.encode("utf-8")); return h.hexdigest()
    except Exception: return ""

def text_to_sha2(s: str) -> str:
    try: h = hashlib.sha256(); h.update(s.encode("utf-8")); return h.hexdigest()
    except Exception: return ""

def text_to_sha3(s: str) -> str:
    try: h = hashlib.sha3_256(); h.update(s.encode("utf-8")); return h.hexdigest()
    except Exception: return ""

def text_to_md5(s: str) -> str:
    try: h = hashlib.md5(); h.update(s.encode("utf-8")); return h.hexdigest()
    except Exception: return ""

_MAX_NUMY_INPUT_DIGITS = 200000
_MAX_BYTES_ENCODE = 2 * 1024 * 1024

def text_to_numy(s: str) -> str:
    try:
        b = s.encode("utf-8");
        if len(b) > _MAX_BYTES_ENCODE: return ""
        n = int.from_bytes(b, "big") if len(b) > 0 else 0
        if n == 0: return "0"
        parts = []
        while n > 0: n, r = divmod(n, 10); parts.append(str(r))
        return "".join(reversed(parts))
    except Exception: return ""

def numy_to_text(s: str) -> str:
    try:
        if s is None or not s.strip(): return ""
        s = s.strip();
        if not re.fullmatch(r"[0-9]+", s): return ""
        if len(s) > _MAX_NUMY_INPUT_DIGITS: return ""
        n = 0
        for ch in s: n = n * 10 + (ord(ch) - 48)
        if n == 0: return ""
        length = (n.bit_length() + 7) // 8;
        if length == 0: return ""
        b = n.to_bytes(length, "big")
        return b.decode("utf-8", errors="strict")
    except Exception: return ""

alphabet_sl = ",.|!`:;-_()\"'/\\@#$%&*+=<>"

def text_to_sl(s: str) -> str:
    try:
        b = s.encode("utf-8");
        n = int.from_bytes(b, "big") if len(b) > 0 else 0
        if n == 0: return ""
        coded = ""; base = len(alphabet_sl)
        while n > 0: n, ind = divmod(n, base); coded = alphabet_sl[ind] + coded
        return coded
    except Exception: return ""

def sl_to_text(s: str) -> str:
    try:
        if s is None or not s.strip(): return ""
        s = s.strip()
        for ch in s:
            if ch not in alphabet_sl: return ""
        res = 0; base = len(alphabet_sl)
        for ch in s: res = res * base + alphabet_sl.index(ch)
        length = (res.bit_length() + 7) // 8;
        if length == 0: return ""
        b = res.to_bytes(length, "big")
        return b.decode("utf-8", errors="strict")
    except Exception: return ""

def xor_encrypt(message: str, key: str) -> str:
    if not key: return ""
    b_msg = message.encode("utf-8")
    b_key = key.encode("utf-8")
    result = bytes([b_msg[i] ^ b_key[i % len(b_key)] for i in range(len(b_msg))])
    return base64.b64encode(result).decode("utf-8")

def xor_decrypt(encoded: str, key: str) -> str:
    if not key: return ""
    try: data = base64.b64decode(encoded)
    except Exception: return ""
    b_key = key.encode("utf-8")
    result = bytes([data[i] ^ b_key[i % len(b_key)] for i in range(len(data))])
    try: return result.decode("utf-8")
    except Exception: return result.decode("utf-8", errors="replace")

def xnor_encrypt(message: str, key: str) -> str:
    if not key: return ""
    b_msg = message.encode("utf-8")
    b_key = key.encode("utf-8")
    result = bytes([(~(b_msg[i] ^ b_key[i % len(b_key)])) & 0xFF for i in range(len(b_msg))])
    return base64.b64encode(result).decode("utf-8")

def xnor_decrypt(encoded: str, key: str) -> str:
    if not key: return ""
    try: data = base64.b64decode(encoded)
    except Exception: return ""
    b_key = key.encode("utf-8")
    result = bytes([(~(data[i] ^ b_key[i % len(b_key)])) & 0xFF for i in range(len(data))])
    try: return result.decode("utf-8")
    except Exception: return result.decode("utf-8", errors="replace")

METHOD_DETAILS: Dict[str, Tuple[Callable, str, str, bool]] = {
    "bn": (text_to_binary, "Binary", "encode", False),
    "bs64": (text_to_base64, "Base64", "encode", False),
    "bs32": (text_to_base32, "Base32", "encode", False),
    "bs16": (text_to_base16, "Base16", "encode", False),
    "asc": (text_to_ascii, "ASCII", "encode", False),
    "url": (text_to_url, "URL", "encode", False),
    "bsx": (text_to_basexi, "BaseXi", "encode", False),
    "hex": (text_to_hex, "Hex", "encode", False),
    "zl": (text_to_zlib, "Zlib", "encode", False),
    "bs85": (text_to_base85, "Base85", "encode", False),
    "bs91": (text_to_base91, "Base91", "encode", False),
    "uni": (text_to_unicode_escape, "Unicode Escape", "encode", False),
    "hexy": (text_to_hexy, "Hexy", "encode", False),
    "oct": (text_to_octal, "Octal", "encode", False),
    "sha1": (text_to_sha1, "SHA1 (Hash)", "encode", False),
    "sha2": (text_to_sha2, "SHA256 (Hash)", "encode", False),
    "sha3": (text_to_sha3, "SHA3-256 (Hash)", "encode", False),
    "md5": (text_to_md5, "MD5 (Hash)", "encode", False),
    "numy": (text_to_numy, "Numy", "encode", False),
    "sl": (text_to_sl, "SL", "encode", False),
    "xor": (xor_encrypt, "XOR (Keyed)", "encode", True),
    "xnor": (xnor_encrypt, "XNOR (Keyed)", "encode", True),

    "bnen": (binary_to_text, "Binary", "decode", False),
    "bs64en": (base64_to_text, "Base64", "decode", False),
    "bs32en": (base32_to_text, "Base32", "decode", False),
    "bs16en": (base16_to_text, "Base16", "decode", False),
    "ascen": (ascii_to_text, "ASCII", "decode", False),
    "urlen": (url_to_text, "URL", "decode", False),
    "bsxen": (basexi_to_text, "BaseXi", "decode", False),
    "hexen": (hex_to_text, "Hex", "decode", False),
    "zlen": (zlib_to_text, "Zlib", "decode", False),
    "bs85en": (base85_to_text, "Base85", "decode", False),
    "bs91en": (base91_to_text, "Base91", "decode", False),
    "unien": (unicode_escape_to_text, "Unicode Escape", "decode", False),
    "hexyen": (hexy_to_text, "Hexy", "decode", False),
    "octen": (octal_to_text, "Octal", "decode", False),
    "numyen": (numy_to_text, "Numy", "decode", False),
    "slen": (sl_to_text, "SL", "decode", False),
    "xoren": (xor_decrypt, "XOR (Keyed)", "decode", True),
    "xnoren": (xnor_decrypt, "XNOR (Keyed)", "decode", True),
}

DECODERS_AUTO_TRY: List[str] = [
    "bnen", "bs64en", "bs32en", "bs16en", "ascen", "urlen", "bsxen", "hexen",
    "zlen", "bs85en", "bs91en", "unien", "hexyen", "octen", "numyen", "slen"
]

def is_plausible_text(s: str) -> bool:
    if not s or not s.strip():
        return False
    if len(s) < 3:
        return False

    if not re.search(r'[a-zA-Z0-9А-Яа-я]', s):
        return False

    non_printable_control_chars = sum(1 for c in s if ord(c) < 32 and c not in '\n\r\t')
    if non_printable_control_chars / len(s) > 0.1:
        return False

    return True

class GadCryptoPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._menu_items = []

    def on_plugin_load(self):
        self.__class__.__name__ = get_localized_string("plugin_name", self)
        self.__class__.__description__ = get_localized_string("plugin_description", self)
        
        self.add_on_send_message_hook()
        # Кнопка "Зашифровать" убрана из меню чата по запросу пользователя.
        # self.add_menu_item(MenuItemData(
        #     menu_type=MenuItemType.CHAT_ACTION_MENU,
        #     text=get_localized_string("menu_encrypt", self),
        #     icon="msg_lock_file",
        #     on_click=self._show_encryption_dialog
        # ))
        # Сгенерировано в PluginGRT - @PluginIDEbot
        log(f"[{__name__}] Plugin loaded. Current language: {self.get_setting('language_override', 0)}")

    def create_settings(self):
        from ui.settings import Header, Selector
        pg_lang_options = [
            get_localized_string("settings_language_auto", self),
            get_localized_string("settings_language_english", self),
            get_localized_string("settings_language_russian", self)
        ]

        return [
            Header(text=get_localized_string("settings_title", self)),
            Selector(
                key="language_override",
                text=get_localized_string("settings_language", self),
                items=pg_lang_options,
                default=0,
                icon="msg_language_solar",
                on_change=lambda value: self._on_language_changed(value)
            )
        ]

    def _on_language_changed(self, value: int):
        self.__class__.__name__ = get_localized_string("plugin_name", self)
        self.__class__.__description__ = get_localized_string("plugin_description", self)
        
        self.on_plugin_unload()
        self.on_plugin_load()

        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "rebuildAllFragments"):
                fragment.rebuildAllFragments(True)
        except Exception as e:
            log(f"[{__name__}] Error rebuilding settings fragment: {e}")

    def on_plugin_unload(self):
        for item_data in list(self._menu_items):
            try:
                self.remove_menu_item(item_data.item_id)
            except Exception as e:
                log(f"[{__name__}] Error removing menu item {item_data.item_id}: {e}")
        self._menu_items.clear()

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        message_text_pg = getattr(params, "message", None)
        if not isinstance(message_text_pg, str):
            return HookResult()

        pg_trigger_enc_cmd = ".genc"
        if message_text_pg.strip().lower().startswith(pg_trigger_enc_cmd):
            initial_text = message_text_pg[len(pg_trigger_enc_cmd):].strip()
            run_on_ui_thread(lambda: self._show_encryption_dialog(
                context={"peer": params.peer, "initial_text": initial_text}
            ))
            return HookResult(strategy=HookStrategy.CANCEL)
            
        pg_trigger_dec_cmd = ".gdec"
        if message_text_pg.strip().lower().startswith(pg_trigger_dec_cmd):
            initial_text = message_text_pg[len(pg_trigger_dec_cmd):].strip()
            context_for_decryption = {"peer": params.peer, "initial_text": initial_text}
            if hasattr(params, 'replyToMsg') and params.replyToMsg:
                context_for_decryption["message"] = params.replyToMsg
            run_on_ui_thread(lambda: self._handle_decryption_request(
                context=context_for_decryption
            ))
            return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult()

    def _show_encryption_dialog(self, context: Dict[str, Any]):
        pg_peer = context.get("peer")
        pg_initial_text = context.get("initial_text", "")

        if not pg_peer:
            fragment = get_last_fragment()
            if hasattr(fragment, 'getDialogId') and fragment.getDialogId():
                pg_peer = fragment.getDialogId()
            else:
                BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
                return

        pg_encrypt_methods_names = [details[1] for key, details in METHOD_DETAILS.items() if details[2] == "encode"]
        pg_encrypt_methods_keys = [key for key, details in METHOD_DETAILS.items() if details[2] == "encode"]

        if not pg_encrypt_methods_names:
            BulletinHelper.show_error(get_localized_string("error_no_methods", self, type="encryption"), get_last_fragment())
            return

        def _on_method_selected(dialog: AlertDialogBuilder, which: int):
            pg_selected_method_key = pg_encrypt_methods_keys[which]
            pg_method_func, pg_method_display_name, pg_type, pg_needs_key = METHOD_DETAILS[pg_selected_method_key]

            pg_message_to_process = pg_initial_text
            if not pg_message_to_process:
                self._request_text_input(
                    pg_peer,
                    pg_method_func,
                    pg_method_display_name,
                    pg_needs_key,
                    pg_selected_method_key,
                    "encode"
                )
            else:
                if pg_needs_key:
                    self._request_key_input(
                        pg_peer,
                        pg_message_to_process,
                        pg_method_func,
                        pg_method_display_name,
                        pg_selected_method_key,
                        "encode"
                    )
                else:
                    self._perform_action_and_send(
                        pg_peer,
                        pg_message_to_process,
                        pg_method_func,
                        pg_method_display_name,
                        None,
                        "encode"
                    )
            dialog.dismiss()

        pg_fragment = get_last_fragment()
        if not pg_fragment or not pg_fragment.getParentActivity():
            BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
            return

        pg_builder = AlertDialogBuilder(pg_fragment.getParentActivity())
        pg_builder.set_title(get_localized_string("select_encryption_method_title", self))
        pg_builder.set_items(pg_encrypt_methods_names, _on_method_selected)
        pg_builder.set_negative_button(get_localized_string("button_cancel", self), lambda d, w: d.dismiss())
        pg_builder.show()

    def _handle_decryption_request(self, context: Dict[str, Any]):
        pg_peer = context.get("peer")
        pg_message_obj = context.get("message")
        pg_initial_text = context.get("initial_text", "")

        pg_text_to_decrypt = ""
        pg_reply_to_msg_id = None

        if pg_initial_text:
            pg_text_to_decrypt = pg_initial_text
            if pg_message_obj and hasattr(pg_message_obj, 'messageOwner') and hasattr(pg_message_obj.messageOwner, 'message'):
                pg_reply_to_msg_id = pg_message_obj.getId()
        elif pg_message_obj and hasattr(pg_message_obj, 'messageOwner') and hasattr(pg_message_obj.messageOwner, 'message'):
            pg_text_to_decrypt = pg_message_obj.messageOwner.message.strip()
            pg_reply_to_msg_id = pg_message_obj.getId()
        
        if not pg_peer:
            fragment = get_last_fragment()
            if hasattr(fragment, 'getDialogId') and fragment.getDialogId():
                pg_peer = fragment.getDialogId()
            else:
                BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
                return

        if not pg_text_to_decrypt:
            BulletinHelper.show_error(get_localized_string("error_no_text_to_decrypt", self), get_last_fragment())
            return

        pg_suggested_method_display_name = None

        for pg_decoder_key in DECODERS_AUTO_TRY:
            pg_method_func, pg_method_display_name, _, pg_needs_key = METHOD_DETAILS[pg_decoder_key]
            if not pg_needs_key:
                try:
                    pg_decrypted_text = pg_method_func(pg_text_to_decrypt)
                    if pg_decrypted_text and pg_decrypted_text != pg_text_to_decrypt and is_plausible_text(pg_decrypted_text):
                        pg_suggested_method_display_name = pg_method_display_name
                        break
                except Exception:
                    pass
        
        run_on_ui_thread(lambda: self._show_decryption_dialog(pg_peer, pg_text_to_decrypt, pg_reply_to_msg_id, pg_suggested_method_display_name))

    def _show_decryption_dialog(self, pg_peer: int, pg_text_to_decrypt: str, pg_reply_to_msg_id: Optional[int], pg_suggested_method_display_name: Optional[str] = None):
        pg_decrypt_methods_names = [details[1] for key, details in METHOD_DETAILS.items() if details[2] == "decode"]
        pg_decrypt_methods_keys = [key for key, details in METHOD_DETAILS.items() if details[2] == "decode"]

        if not pg_decrypt_methods_names:
            BulletinHelper.show_error(get_localized_string("error_no_methods", self, type="decryption"), get_last_fragment())
            return

        def _on_method_selected(dialog: AlertDialogBuilder, which: int):
            pg_selected_method_key = pg_decrypt_methods_keys[which]
            pg_method_func, pg_method_display_name, pg_type, pg_needs_key = METHOD_DETAILS[pg_selected_method_key]
            
            if pg_needs_key:
                self._request_key_input(
                    pg_peer,
                    pg_text_to_decrypt,
                    pg_method_func,
                    pg_method_display_name,
                    pg_selected_method_key,
                    "decode",
                    pg_reply_to_msg_id
                )
            else:
                self._perform_action_and_send(
                    pg_peer,
                    pg_text_to_decrypt,
                    pg_method_func,
                    pg_method_display_name,
                    None,
                    "decode",
                    pg_reply_to_msg_id
                )
            dialog.dismiss()

        pg_fragment = get_last_fragment()
        if not pg_fragment or not pg_fragment.getParentActivity():
            BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
            return

        pg_builder = AlertDialogBuilder(pg_fragment.getParentActivity())
        pg_dialog_title = get_localized_string("select_decryption_method_title", self)
        if pg_suggested_method_display_name:
            pg_dialog_title = f"{pg_dialog_title} ({get_localized_string('possible_decryption_prefix', self)}{pg_suggested_method_display_name})"
        pg_builder.set_title(pg_dialog_title)
        pg_builder.set_items(pg_decrypt_methods_names, _on_method_selected)
        pg_builder.set_negative_button(get_localized_string("button_cancel", self), lambda d, w: d.dismiss())
        pg_builder.show()

    def _request_text_input(self, pg_peer: int, pg_method_func: Callable, pg_method_display_name: str, pg_needs_key: bool, pg_method_key: str, pg_action_type: str):
        pg_fragment = get_last_fragment()
        if not pg_fragment or not pg_fragment.getParentActivity():
            BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
            return

        from org.telegram.ui.Components import EditTextBoldCursor
        from android.text import InputType
        from android.util import TypedValue
        from org.telegram.ui.ActionBar import Theme
        from org.telegram.messenger import AndroidUtilities

        pg_input_edit_text = EditTextBoldCursor(pg_fragment.getParentActivity())
        pg_input_edit_text.setHint(get_localized_string("enter_text_to_action", self, action_type=pg_action_type))
        pg_input_edit_text.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE)
        pg_input_edit_text.setMaxLines(5)
        pg_input_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        pg_input_edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        pg_input_edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
        pg_input_edit_text.setBackground(None)
        pg_input_edit_text.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
        pg_input_edit_text.setCursorWidth(1.5)
        pg_input_edit_text.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))

        def _on_text_entered(dialog: AlertDialogBuilder, which: int):
            pg_entered_text = pg_input_edit_text.getText().toString().strip()
            if not pg_entered_text:
                BulletinHelper.show_error(get_localized_string("text_cannot_be_empty", self), get_last_fragment())
                dialog.dismiss()
                return

            if pg_needs_key:
                self._request_key_input(
                    pg_peer,
                    pg_entered_text,
                    pg_method_func,
                    pg_method_display_name,
                    pg_method_key,
                    pg_action_type
                )
            else:
                self._perform_action_and_send(
                    pg_peer,
                    pg_entered_text,
                    pg_method_func,
                    pg_method_display_name,
                    None,
                    "encode"
                )
            dialog.dismiss()

        pg_builder = AlertDialogBuilder(pg_fragment.getParentActivity())
        pg_builder.set_title(get_localized_string("enter_text_to_action", self, action_type=pg_action_type))
        pg_builder.set_view(pg_input_edit_text)
        pg_builder.set_positive_button(get_localized_string("button_ok", self), _on_text_entered)
        pg_builder.set_negative_button(get_localized_string("button_cancel", self), lambda d, w: d.dismiss())
        pg_dialog = pg_builder.show()

        run_on_ui_thread(lambda: (pg_input_edit_text.requestFocus(), AndroidUtilities.showKeyboard(pg_input_edit_text)), delay=100)

    def _request_key_input(self, pg_peer: int, pg_message_to_process: str, pg_method_func: Callable, pg_method_display_name: str, pg_method_key: str, pg_action_type: str, pg_reply_to_msg_id: Optional[int] = None):
        pg_fragment = get_last_fragment()
        if not pg_fragment or not pg_fragment.getParentActivity():
            BulletinHelper.show_error(get_localized_string("error_chat_context", self), get_last_fragment())
            return

        from org.telegram.ui.Components import EditTextBoldCursor
        from android.text import InputType
        from android.util import TypedValue
        from org.telegram.ui.ActionBar import Theme
        from org.telegram.messenger import AndroidUtilities

        pg_key_input_edit_text = EditTextBoldCursor(pg_fragment.getParentActivity())
        pg_key_input_edit_text.setHint(get_localized_string("enter_key_hint", self))
        pg_key_input_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
        pg_key_input_edit_text.setMaxLines(1)
        pg_key_input_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        pg_key_input_edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
        pg_key_input_edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
        pg_key_input_edit_text.setBackground(None)
        pg_key_input_edit_text.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
        pg_key_input_edit_text.setCursorWidth(1.5)
        pg_key_input_edit_text.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))

        def _on_key_entered(dialog: AlertDialogBuilder, which: int):
            pg_entered_key = pg_key_input_edit_text.getText().toString().strip()
            if not pg_entered_key:
                BulletinHelper.show_error(get_localized_string("key_cannot_be_empty", self), get_last_fragment())
                dialog.dismiss()
                return

            self._perform_action_and_send(
                pg_peer,
                pg_message_to_process,
                pg_method_func,
                pg_method_display_name,
                pg_entered_key,
                pg_action_type,
                pg_reply_to_msg_id
            )
            dialog.dismiss()

        pg_builder = AlertDialogBuilder(pg_fragment.getParentActivity())
        pg_builder.set_title(get_localized_string("enter_key_hint", self))
        pg_builder.set_view(pg_key_input_edit_text)
        pg_builder.set_positive_button(get_localized_string("button_ok", self), _on_key_entered)
        pg_builder.set_negative_button(get_localized_string("button_cancel", self), lambda d, w: d.dismiss())
        pg_dialog = pg_builder.show()

        run_on_ui_thread(lambda: (pg_key_input_edit_text.requestFocus(), AndroidUtilities.showKeyboard(pg_key_input_edit_text)), delay=100)

    def _perform_action_and_send(self, pg_peer: int, pg_input_data: str, pg_method_func: Callable, pg_method_display_name: str, pg_key: Optional[str], pg_action_type: str, pg_reply_to_msg_id: Optional[int] = None):
        def _task():
            try:
                pg_output = ""
                if pg_key is None:
                    pg_output = pg_method_func(pg_input_data)
                else:
                    pg_output = pg_method_func(pg_input_data, pg_key)

                if not pg_output:
                    pg_error_msg = get_localized_string("error_action_failed", self, action_type=pg_action_type)
                    if pg_action_type == "decode":
                         pg_error_msg = get_localized_string("error_decryption_failed_specific", self, method_name=pg_method_display_name)
                    run_on_ui_thread(lambda: BulletinHelper.show_error(pg_error_msg, get_last_fragment()))
                    return

                pg_final_message_text = ""
                pg_entities = []

                if pg_action_type == "encode":
                    pg_final_message_text = pg_output

                else:
                    pg_markdown_prefix = get_localized_string("decrypted_prefix", self, method_name=pg_method_display_name)
                    pg_parsed_md_prefix = parse_markdown(pg_markdown_prefix)
                    pg_final_message_text = f"{pg_parsed_md_prefix.text}\n{pg_output}"
                    pg_entities = [e.to_tlrpc_object() for e in pg_parsed_md_prefix.entities]

                run_on_ui_thread(lambda peer=pg_peer, msg=pg_final_message_text, entities=pg_entities, reply_id=pg_reply_to_msg_id:
                    send_message({
                        "peer": peer,
                        "message": msg,
                        "entities": entities,
                        "replyToMsg": reply_id
                    })
                )
                run_on_ui_thread(lambda: BulletinHelper.show_success(get_localized_string("success_action", self, action_type=pg_action_type), get_last_fragment()))

            except Exception as e:
                run_on_ui_thread(lambda: BulletinHelper.show_error(
                    get_localized_string("error_during_action", self, action_type=pg_action_type, method_name=pg_method_display_name, error=str(e)),
                    get_last_fragment()
                ))

        run_on_queue(_task)