"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 Кража кода без указания авторства является публичным неуважением к работе автора.
  Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
   Берёте — но делайте это с уважением :)
"""

__id__ = "text_animation"
__name__ = "Text Animation"
__description__ = "Animation of text appearance with blur effect (for now)"
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "1.0.0"
__icon__ = "DateRegBot_by_MoiStikiBot/14"
__min_version__ = "11.12.1"

import time
from base_plugin import BasePlugin, MethodHook
from android_utils import run_on_ui_thread
from ui.settings import Header, Switch, Input, Divider

from java import jclass
from java.lang import Class as JClass


class AnimationState:
    
    def __init__(self):
        self.prev_text = ""
        self.prev_len = 0
        self.prev_last_line_start = 0
        self.char_start_times = {}
        self.has_animating_chars = False
        self.animation_running = False


class TextBlurHook(MethodHook):
    
    def __init__(self, plugin):
        self.plugin = plugin
        self._states = {}
        self._classes_loaded = False
        
        self._Paint = None
        self._Bitmap = None
        self._Canvas = None
        self._Utilities = None
        self._ForegroundColorSpan = None
        
        self._active_spans = {}
    
    def _load_classes(self):
        if self._classes_loaded:
            return True
        
        try:
            self._Paint = jclass("android.graphics.Paint")
            self._Bitmap = jclass("android.graphics.Bitmap")
            self._Canvas = jclass("android.graphics.Canvas")
            self._ForegroundColorSpan = jclass("android.text.style.ForegroundColorSpan")
            
            try:
                self._Utilities = jclass("org.telegram.messenger.Utilities")
            except:
                self._Utilities = None
            
            self._classes_loaded = True
            return True
        except Exception as e:
            self.plugin.log(f"Failed to load classes: {e}")
            return False
    
    def _get_state(self, view) -> AnimationState:
        vid = id(view)
        if vid not in self._states:
            self._states[vid] = AnimationState()
        return self._states[vid]
    
    def _get_last_line_start(self, view, txt: str) -> int:
        try:
            layout = view.getLayout()
            if layout is None:
                return 0
            
            line_count = layout.getLineCount()
            if line_count <= 1:
                return 0
            
            last_line = line_count - 1
            line_start = layout.getLineStart(last_line)
            return line_start
        except:
            return 0
    
    def _update_hidden_span(self, view, state: AnimationState, last_line_start: int):
        if self._ForegroundColorSpan is None:
            return
        
        try:
            vid = id(view)
            text = view.getText()
            if text is None:
                return
            
            animating_indices = [idx for idx in state.char_start_times.keys() if idx >= last_line_start]
            
            if not animating_indices:
                if vid in self._active_spans:
                    span = self._active_spans.pop(vid)
                    try:
                        text.removeSpan(span)
                    except:
                        pass
                return
            
            start = min(animating_indices)
            end = max(animating_indices) + 1
            
            if vid in self._active_spans:
                old_span = self._active_spans.pop(vid)
                try:
                    text.removeSpan(old_span)
                except:
                    pass
            
            new_span = self._ForegroundColorSpan(0x00000000)
            text.setSpan(new_span, start, end, 33)
            self._active_spans[vid] = new_span
            
        except Exception as e:
            self.plugin.log(f"Span error: {e}")
    
    def _remove_span(self, view):
        vid = id(view)
        if vid not in self._active_spans:
            return
        
        span = self._active_spans.pop(vid, None)
        if span is None:
            return
        
        try:
            text = view.getText()
            if text is not None:
                text.removeSpan(span)
        except:
            pass
    
    def _start_animation_loop(self, view, state: AnimationState):
        if state.animation_running:
            return
        
        state.animation_running = True
        duration = int(self.plugin.get_setting("duration", 300))
        
        def update_frame():
            if not state.char_start_times:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
                return
            
            current_time = time.time()
            completed = []
            
            for idx, start_time in state.char_start_times.items():
                elapsed = (current_time - start_time) * 1000
                if elapsed >= duration:
                    completed.append(idx)
            
            for idx in completed:
                del state.char_start_times[idx]
            
            txt = ""
            try:
                text = view.getText()
                if text:
                    txt = str(text)
            except:
                pass
            
            last_line_start = self._get_last_line_start(view, txt)
            
            if completed:
                self._update_hidden_span(view, state, last_line_start)
            
            self._invalidate(view)
            
            if state.char_start_times:
                run_on_ui_thread(update_frame, delay=16)
            else:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
        
        run_on_ui_thread(update_frame)
    
    def _invalidate(self, view):
        try:
            run_on_ui_thread(lambda: view.invalidate())
        except:
            pass
    
    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            
            view = param.thisObject
            if view is None:
                return
            
            if not self._load_classes():
                return
            
            state = self._get_state(view)
            
            try:
                text = view.getText()
                if text is None:
                    return
                
                current_text = str(text)
                current_len = len(current_text)
                
                last_line_start = self._get_last_line_start(view, current_text)
                
                if last_line_start != state.prev_last_line_start:
                    state.char_start_times.clear()
                    state.has_animating_chars = False
                    self._remove_span(view)
                    state.prev_last_line_start = last_line_start
                    state.prev_text = current_text
                    state.prev_len = current_len
                    return
                
                if current_len > state.prev_len:
                    prefix_matches = current_text[:state.prev_len] == state.prev_text
                    
                    if prefix_matches:
                        current_time = time.time()
                        
                        for i in range(state.prev_len, current_len):
                            state.char_start_times[i] = current_time
                        
                        if state.char_start_times:
                            state.has_animating_chars = True
                            self._update_hidden_span(view, state, last_line_start)
                            self._start_animation_loop(view, state)
                
                elif current_len < state.prev_len:
                    to_remove = [idx for idx in state.char_start_times if idx >= current_len]
                    for idx in to_remove:
                        del state.char_start_times[idx]
                    
                    if not state.char_start_times:
                        state.has_animating_chars = False
                        self._remove_span(view)
                    else:
                        self._update_hidden_span(view, state, last_line_start)
                
                state.prev_text = current_text
                state.prev_len = current_len
                state.prev_last_line_start = last_line_start
                
            except Exception as e:
                self.plugin.log(f"Text tracking error: {e}")
        
        except Exception as e:
            self.plugin.log(f"Before hook error: {e}")
    
    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            
            view = param.thisObject
            canvas = param.args[0] if param.args else None
            
            if view is None or canvas is None:
                return
            
            state = self._states.get(id(view))
            if state is None or not state.has_animating_chars:
                return
            
            self._draw_animated_chars(view, canvas, state)
        
        except Exception as e:
            self.plugin.log(f"After hook error: {e}")
    
    def _draw_animated_chars(self, view, canvas, state: AnimationState):
        if not self._classes_loaded:
            return
        
        try:
            paint = view.getPaint()
            text = view.getText()
            
            if paint is None or text is None:
                return
            
            txt = str(text)
            if not state.char_start_times:
                return
            
            blur_radius = int(self.plugin.get_setting("blur_radius", 10))
            duration = int(self.plugin.get_setting("duration", 300))
            current_time = time.time()
            
            layout = None
            last_line_start = 0
            try:
                layout = view.getLayout()
                if layout:
                    last_line = layout.getLineCount() - 1
                    last_line_start = layout.getLineStart(last_line)
            except:
                pass
            
            pad_left = view.getPaddingLeft()
            
            scroll_x = 0
            try:
                scroll_x = view.getScrollX()
            except:
                pass
            
            orig_alpha = paint.getAlpha()
            
            for char_idx, start_time in list(state.char_start_times.items()):
                if char_idx >= len(txt):
                    continue
                
                if char_idx < last_line_start:
                    continue
                
                char = txt[char_idx]
                
                elapsed = (current_time - start_time) * 1000
                progress = min(1.0, elapsed / duration)
                progress = self._ease_out_quint(progress)
                
                x, y = self._get_char_pos(view, layout, paint, txt, char_idx, last_line_start, pad_left, scroll_x)
                
                self._draw_char_with_blur(canvas, char, x, y, paint, progress, blur_radius, orig_alpha)
            
            paint.setAlpha(orig_alpha)
        
        except Exception as e:
            self.plugin.log(f"Draw error: {e}")
    
    def _ease_out_quint(self, t: float) -> float:
        return 1 - pow(1 - t, 5)
    
    def _get_char_pos(self, view, layout, paint, txt, char_idx, last_line_start, pad_left, scroll_x):
        try:
            pad_top = view.getPaddingTop()
            
            if layout is not None:
                last_line = layout.getLineCount() - 1
                baseline = layout.getLineBaseline(last_line)
                x_pos = layout.getPrimaryHorizontal(char_idx)
                
                x = pad_left + x_pos - scroll_x
                y = pad_top + baseline
            else:
                idx_in_line = char_idx - last_line_start
                line_text = txt[last_line_start:]
                prefix_width = paint.measureText(line_text[:idx_in_line])
                
                x = pad_left + prefix_width - scroll_x
                y = view.getBaseline()
            
            return x, y
        except Exception as e:
            self.plugin.log(f"Pos error: {e}")
            return 0, 0
    
    def _draw_char_with_blur(self, canvas, char: str, x: float, y: float, paint, progress: float, blur_radius: int, orig_alpha: int):
        blur_alpha, normal_alpha = self._calc_blur_alpha(progress)
        
        if blur_alpha > 5 and self._Utilities is not None:
            self._draw_blurred_char(canvas, char, x, y, paint, blur_alpha, blur_radius, orig_alpha)
        
        if normal_alpha > 0:
            self._draw_normal_char(canvas, char, x, y, paint, normal_alpha, orig_alpha)
    
    def _calc_blur_alpha(self, progress: float) -> tuple:
        if progress >= 1.0:
            return (0, 255)
        elif progress <= 0.0:
            return (255, 0)
        
        blur_alpha = int((1.0 - progress) * 255)
        
        normal_start = 0.2
        if progress < normal_start:
            normal_alpha = 0
        else:
            normal_alpha = int(((progress - normal_start) / (1.0 - normal_start)) * 255)
        
        return (blur_alpha, normal_alpha)
    
    def _draw_blurred_char(self, canvas, char: str, x: float, y: float, paint, alpha: int, blur_radius: int, orig_alpha: int):
        try:
            char_width = max(8, int(paint.measureText(char)) + blur_radius * 4)
            char_height = max(8, int(paint.getTextSize() * 1.5) + blur_radius * 4)
            
            scale = 2.0
            bmp_w = max(4, int(char_width / scale))
            bmp_h = max(4, int(char_height / scale))
            
            Config = jclass("android.graphics.Bitmap$Config")
            bitmap = self._Bitmap.createBitmap(bmp_w, bmp_h, Config.ARGB_8888)
            temp_canvas = self._Canvas(bitmap)
            
            temp_canvas.scale(1.0 / scale, 1.0 / scale)
            temp_canvas.translate(blur_radius * 2, char_height - blur_radius * 2)
            
            paint.setAlpha(255)
            temp_canvas.drawText(char, 0, 0, paint)
            paint.setAlpha(orig_alpha)
            
            effective_blur = max(1, int(blur_radius / scale))
            self._Utilities.stackBlurBitmap(bitmap, effective_blur)
            
            draw_paint = self._Paint(1)
            draw_paint.setAlpha(alpha)
            
            canvas.save()
            canvas.translate(x - blur_radius * 2, y - char_height + blur_radius * 2)
            canvas.scale(scale, scale)
            canvas.drawBitmap(bitmap, 0, 0, draw_paint)
            canvas.restore()
            
            bitmap.recycle()
        
        except Exception as e:
            pass
    
    def _draw_normal_char(self, canvas, char: str, x: float, y: float, paint, alpha: int, orig_alpha: int):
        try:
            combined_alpha = int((alpha / 255.0) * orig_alpha)
            combined_alpha = max(1, min(255, combined_alpha))
            
            draw_paint = self._Paint(paint.getFlags())
            draw_paint.setTextSize(paint.getTextSize())
            draw_paint.setTypeface(paint.getTypeface())
            draw_paint.setAntiAlias(True)
            
            color = int(paint.getColor())
            r = (color >> 16) & 0xFF
            g = (color >> 8) & 0xFF
            b = color & 0xFF
            
            draw_paint.setARGB(combined_alpha, r, g, b)
            
            canvas.drawText(char, x, y, draw_paint)
        except:
            pass


class TextBlurAnimationPlugin(BasePlugin):
    
    def __init__(self):
        super().__init__()
        self._hook = None
    
    def on_plugin_load(self):
        self.log("Loading... (by mihailkotovski)")
        
        try:
            target_class = None
            
            for class_name in [
                "org.telegram.ui.Components.EditTextCaption",
                "org.telegram.ui.Components.EditTextBoldCursor",
                "org.telegram.ui.Components.EditTextEffects"
            ]:
                try:
                    java_class = JClass.forName(class_name)
                    if java_class:
                        self.log(f"Found class: {class_name}")
                        target_class = getattr(java_class, "class_", java_class)
                        break
                except:
                    continue
            
            if target_class is None:
                self.log("No suitable EditText class found!")
                return
            
            try:
                canvas_class = JClass.forName("android.graphics.Canvas")
                canvas_type = getattr(canvas_class, "class_", canvas_class)
            except:
                self.log("Failed to load Canvas class!")
                return
            
            try:
                method = None
                try:
                    method = target_class.getDeclaredMethod("onDraw", canvas_type)
                except:
                    method = target_class.getMethod("onDraw", canvas_type)
                
                if method:
                    method.setAccessible(True)
                    self._hook = self.hook_method(method, TextBlurHook(self))
                    self.log("Successfully hooked onDraw!")
            
            except Exception as e:
                self.log(f"Failed to hook method: {e}")
            
            self.log("Loaded! (thx for using)")
        
        except Exception as e:
            self.log(f"Load error: {e}")
    
    def on_plugin_unload(self):
        try:
            if self._hook:
                self.unhook_method(self._hook)
                self._hook = None
            self.log("Unloaded! (thx for using)")
        except:
            pass
    
    def create_settings(self):
        from org.telegram.messenger import LocaleController
        
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except:
            lang = "en"
        
        is_ru = str(lang).startswith("ru")
        
        return [
            Header(text="Настройки" if is_ru else "Settings"),
            
            Switch(
                key="enabled",
                text="Включить" if is_ru else "Enable",
                default=True,
                subtext="Анимация размытия при вводе" if is_ru else "Blur animation on typing",
                icon="msg_animations"
            ),
            
            Divider(),
            Header(text="Параметры анимации" if is_ru else "Animation Parameters"),
            
            Input(
                key="duration",
                text="Длительность (мс)" if is_ru else "Duration (ms)",
                default="300",
                subtext="200-500 мс рекомендуется" if is_ru else "200-500 ms recommended",
                icon="msg_timer"
            ),
            
            Input(
                key="blur_radius",
                text="Радиус размытия" if is_ru else "Blur Radius",
                default="10",
                subtext="5-15 (рекомендуется)" if is_ru else "5-15 (recommended)",
                icon="msg_photo_blur2"
            )
        ]