"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 Кража кода без указания авторства является публичным неуважением к работе автора.
  Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
   Берёте — но делайте это с уважением :)
   
 Оригинальная идея и реализация + исправление эмодзи от @mihailkotovski & @mishabotov
 Плавный курсор и плавное появление букв сверху от @shikaatux + исправление OOM (out of memory)
"""

__id__ = "text_animation"
__name__ = "Text Animation"
__description__ = "Animation of text appearance with blur effect + Slide + Smooth Cursor animations"
__author__ = "@mihailkotovski & @mishabotov & @shikaatux"
__version__ = "2.5.0 [emoji fix]"
__icon__ = "DateRegBot_by_MoiStikiBot/15"
__min_version__ = "11.12.1"

import time
import math
from weakref import WeakKeyDictionary
from base_plugin import BasePlugin, MethodHook
from android_utils import run_on_ui_thread
from ui.settings import Header, Switch, Input, Divider, Text

from java import jclass
from java.lang import Class as JClass


class AnimationState:
    __slots__ = (
        'prev_text', 'prev_len', 'prev_last_line_start',
        'char_start_times', 'has_animating_chars', 'animation_running',
        'cursor_x', 'cursor_y', 'cursor_animating',
        'system_cursor_hidden', 'is_focused', 'heartbeat_running',
        'cursor_paint', 'cursor_rect', 'drawing_depth',
        'prev_java_len'
    )
    
    def __init__(self):
        self.prev_text = ""
        self.prev_len = 0
        self.prev_last_line_start = 0
        self.char_start_times = {}
        self.has_animating_chars = False
        self.animation_running = False
        self.cursor_x = -1.0
        self.cursor_y = -1.0
        self.cursor_animating = False
        self.system_cursor_hidden = False
        self.is_focused = False
        self.heartbeat_running = False
        self.drawing_depth = 0
        self.cursor_paint = None
        self.cursor_rect = None
        self.prev_java_len = 0


class BaseTextHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin


class TouchHook(BaseTextHook):
    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            if view:
                view.invalidate()
                if hasattr(self.plugin, "_start_heartbeat"):
                    self.plugin._start_heartbeat(view)
        except:
            pass


class FocusHook(BaseTextHook):
    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            focused = param.args[0]
            if view and hasattr(self.plugin, "get_state"):
                state = self.plugin.get_state(view)
                state.is_focused = focused
                if focused:
                    view.invalidate()
                    self.plugin._start_heartbeat(view)
        except:
            pass


class TextBlurHook(BaseTextHook):
    
    def __init__(self, plugin):
        super().__init__(plugin)
        self._classes_loaded = False
        self._Paint = None
        self._Bitmap = None
        self._Canvas = None
        self._Utilities = None
        self._ForegroundColorSpan = None
        self._RectF = None
        self._active_spans = WeakKeyDictionary()
    
    def _load_classes(self):
        if self._classes_loaded:
            return True
        try:
            self._Paint = jclass("android.graphics.Paint")
            self._Bitmap = jclass("android.graphics.Bitmap")
            self._Canvas = jclass("android.graphics.Canvas")
            self._ForegroundColorSpan = jclass("android.text.style.ForegroundColorSpan")
            self._RectF = jclass("android.graphics.RectF")
            self._ReplacementSpan = jclass("android.text.style.ReplacementSpan")

            try:
                self._Utilities = jclass("org.telegram.messenger.Utilities")
            except:
                self._Utilities = None
            self._classes_loaded = True
            return True
        except:
            return False
    
    def _setup_cursor(self, view, state):
        if state.system_cursor_hidden:
            return
        try:
            view.setCursorVisible(True)
            if self.plugin.field_cursorWidth:
                self.plugin.field_cursorWidth.setFloat(view, 0.0)
                state.system_cursor_hidden = True
        except:
            pass
    
    def _get_java_char_len(self, char):
        return 2 if ord(char) > 0xFFFF else 1
        
    def _get_str_java_len(self, s):
        return sum(2 if ord(c) > 0xFFFF else 1 for c in s)
        
    def _get_last_line_start(self, view, txt):
        try:
            layout = view.getLayout()
            if layout and layout.getLineCount() > 1:
                return layout.getLineStart(layout.getLineCount() - 1)
            return 0
        except:
            return 0
    
    def _update_hidden_span(self, view, state, last_line_start):
        if self._ForegroundColorSpan is None:
            return
        try:
            text = view.getText()
            if text is None:
                return
            anim_indices = [i for i in state.char_start_times.keys() if i >= last_line_start]
            if not anim_indices:
                self._remove_span(view)
                return
            
            start = min(anim_indices)
            max_idx = max(anim_indices)
            entry = state.char_start_times[max_idx]
            end = max_idx + entry[2]
            
            if view in self._active_spans:
                try:
                    text.removeSpan(self._active_spans.pop(view))
                except:
                    pass
            new_span = self._ForegroundColorSpan(0x00000000)
            text.setSpan(new_span, start, end, 33)
            self._active_spans[view] = new_span
        except:
            pass
    
    def _remove_span(self, view):
        if view in self._active_spans:
            try:
                view.getText().removeSpan(self._active_spans.pop(view))
            except:
                pass
    
    def _start_text_animation_loop(self, view, state):
        if state.animation_running:
            return
        state.animation_running = True
        duration = int(self.plugin.get_setting("duration", 300))
        
        def update():
            if not state.char_start_times:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
                return
            
            curr = time.time()
            done = []
            for i, val in state.char_start_times.items():
                t = val[0]
                if (curr - t) * 1000 >= duration:
                    done.append(i)
            for i in done:
                del state.char_start_times[i]
            
            try:
                txt = str(view.getText())
                if done:
                    self._update_hidden_span(view, state, self._get_last_line_start(view, txt))
            except:
                pass
            
            run_on_ui_thread(lambda: view.invalidate())
            
            if state.char_start_times:
                run_on_ui_thread(update, delay=16)
            else:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
        
        run_on_ui_thread(update)
    
    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            view = param.thisObject
            if not view or not self._load_classes():
                return
            
            state = self.plugin.get_state(view)
            state.drawing_depth += 1
            
            if self.plugin.get_setting("cursor_enabled", True):
                self._setup_cursor(view, state)
            
            text = view.getText()
            if text is None:
                return
            
            cur_txt = str(text)
            cur_len = len(cur_txt)
            cur_java_len = self._get_str_java_len(cur_txt)
            last_start = self._get_last_line_start(view, cur_txt)
            
            if last_start != state.prev_last_line_start:
                state.char_start_times.clear()
                state.has_animating_chars = False
                self._remove_span(view)
                state.prev_last_line_start = last_start
                state.prev_text = cur_txt
                state.prev_len = cur_len
                state.prev_java_len = cur_java_len
                return
            
            if cur_len > state.prev_len:
                if cur_txt[:state.prev_len] == state.prev_text:
                    now = time.time()
                    
                    curr_java_idx = state.prev_java_len
                    
                    for i in range(state.prev_len, cur_len):
                        char = cur_txt[i]
                        char_len = self._get_java_char_len(char)
                        
                        skip = False
                        try:
                            spans = text.getSpans(curr_java_idx, curr_java_idx + char_len, self._ReplacementSpan)
                            if spans and len(spans) > 0:
                                skip = True
                        except:
                            pass
                        
                        if not skip:
                            state.char_start_times[curr_java_idx] = (now, char, char_len)
                            
                        curr_java_idx += char_len

                    if state.char_start_times:
                        state.has_animating_chars = True
                        self._update_hidden_span(view, state, last_start)
                        self._start_text_animation_loop(view, state)
            elif cur_len < state.prev_len:
                rem = [i for i in state.char_start_times if i >= cur_java_len]
                for i in rem:
                    del state.char_start_times[i]
                if not state.char_start_times:
                    state.has_animating_chars = False
                    self._remove_span(view)
                else:
                    self._update_hidden_span(view, state, last_start)
            
            state.prev_text = cur_txt
            state.prev_len = cur_len
            state.prev_java_len = cur_java_len
            state.prev_last_line_start = last_start
        except:
            pass
    
    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            view = param.thisObject
            canvas = param.args[0] if param.args else None
            state = self.plugin.get_state(view)
            state.drawing_depth -= 1
            
            if state.drawing_depth > 0:
                return
            if not view or not canvas:
                return
            
            if state.has_animating_chars:
                self._draw_animated_chars(view, canvas, state)
            
            if self.plugin.get_setting("cursor_enabled", True):
                self._draw_cursor(view, canvas, state)
        except:
            pass

    
    def _draw_cursor(self, view, canvas, state):
        try:
            canvas.save()
            
            final_color = 0xFF2CA5E0
            try:
                if self.plugin.field_resourcesProvider:
                    prov = self.plugin.field_resourcesProvider.get(view)
                    if prov and self.plugin.key_chat_messagePanelCursor:
                        final_color = prov.getColor(self.plugin.key_chat_messagePanelCursor)
                    elif self.plugin.Theme and self.plugin.key_chat_messagePanelCursor:
                        final_color = self.plugin.Theme.getColor(self.plugin.key_chat_messagePanelCursor)
            except:
                pass
            
            layout = view.getLayout()
            sel = view.getSelectionStart()
            if sel < 0:
                sel = 0
            
            paint = view.getPaint()
            text_size = paint.getTextSize()
            target_x = 0.0
            line_mid_y = float(view.getHeight()) / 2.0 if view.getHeight() > 0 else text_size
            
            if layout:
                try:
                    target_line = layout.getLineForOffset(sel)
                    target_x = layout.getPrimaryHorizontal(sel)
                    line_T = layout.getLineTop(target_line)
                    line_B = layout.getLineBottom(target_line)
                    line_mid_y = line_T + (line_B - line_T) / 2.0
                except:
                    pass
            
            if state.cursor_x < 0:
                state.cursor_x = target_x
            if state.cursor_y < 0:
                state.cursor_y = line_mid_y
            
            base_speed = max(0.05, float(self.plugin.get_setting("cursor_speed", 25)) / 100.0)
            max_step = 60.0
            is_moving = False
            
            diff_x = target_x - state.cursor_x
            if abs(diff_x) > 0.1:
                step_x = diff_x * base_speed
                if step_x > max_step:
                    step_x = max_step
                elif step_x < -max_step:
                    step_x = -max_step
                state.cursor_x += step_x
                is_moving = True
            else:
                state.cursor_x = target_x
            
            diff_y = line_mid_y - state.cursor_y
            if abs(diff_y) > 0.1:
                step_y = diff_y * (base_speed * 1.2)
                limit_y = max_step * 1.5
                if step_y > limit_y:
                    step_y = limit_y
                elif step_y < -limit_y:
                    step_y = -limit_y
                state.cursor_y += step_y
                is_moving = True
            else:
                state.cursor_y = line_mid_y
            
            blink_alpha = 255
            if not is_moving:
                t = time.time()
                val = (math.sin(t * 6.0) + 1) / 2.0
                blink_alpha = int((0.2 + 0.8 * val) * 255)
            
            color_alpha = (final_color >> 24) & 0xFF
            final_alpha = min(blink_alpha, color_alpha)
            if final_alpha == 0 and blink_alpha > 0:
                final_alpha = blink_alpha
            
            pad_L = view.getPaddingLeft()
            pad_T = view.getPaddingTop()
            scroll_X = view.getScrollX()
            scroll_Y = view.getScrollY()
            
            cursor_height = text_size * 1.25
            width = int(self.plugin.get_setting("cursor_width", 5))
            
            draw_y_T = pad_T + state.cursor_y - (cursor_height / 2)
            draw_y_B = pad_T + state.cursor_y + (cursor_height / 2)
            draw_x = pad_L + state.cursor_x
            
            if state.cursor_paint is None:
                state.cursor_paint = self._Paint(1)
            
            r = (final_color >> 16) & 0xFF
            g = (final_color >> 8) & 0xFF
            b = final_color & 0xFF
            state.cursor_paint.setARGB(final_alpha, r, g, b)
            
            if state.cursor_rect is None:
                state.cursor_rect = self._RectF()
            
            state.cursor_rect.set(float(draw_x), float(draw_y_T), float(draw_x + width), float(draw_y_B))
            canvas.drawRoundRect(state.cursor_rect, float(width / 2), float(width / 2), state.cursor_paint)
            
            canvas.restore()
        except:
            pass
    
    def _draw_animated_chars(self, view, canvas, state):
        if not self._classes_loaded:
            return
        try:
            paint = view.getPaint()
            text = view.getText()
            if not paint or not text:
                return
            
            txt = str(text)
            if not state.char_start_times:
                return
            
            blur_enabled = self.plugin.get_setting("blur_enabled", True)
            slide_enabled = self.plugin.get_setting("slide_enabled", True)
            
            blur_rad = int(self.plugin.get_setting("blur_radius", 10))
            duration = int(self.plugin.get_setting("duration", 300))
            
            try:
                slide_dist = int(self.plugin.get_setting("slide_dist", 20))
            except:
                slide_dist = 20
            
            now = time.time()
            layout = view.getLayout()
            last_line_start = layout.getLineStart(layout.getLineCount() - 1) if layout else 0
            pad_L = view.getPaddingLeft()
            scr_X = view.getScrollX()
            orig_A = paint.getAlpha()
            
            
            for i, val in list(state.char_start_times.items()):
                start_t, char, char_len = val
                
                if i < last_line_start:
                    continue
                
                prog = min(1.0, (now - start_t) * 1000 / duration)
                prog = self._ease_out_quint(prog)
                
                x, y = self._get_char_pos(view, layout, paint, char, i, last_line_start, pad_L, scr_X)
                
                y_off = 0
                if slide_enabled:
                    y_off = int(-slide_dist * (1.0 - prog))
                
                if blur_enabled:
                    self._draw_char_with_blur(canvas, char, x, y + y_off, paint, prog, blur_rad, orig_A)
                else:
                    alpha = int(prog * orig_A)
                    if alpha > 0:
                        paint.setAlpha(alpha)
                        canvas.drawText(char, x, y + y_off, paint)
            
            paint.setAlpha(orig_A)
        except:
            pass
    
    def _ease_out_quint(self, t):
        return 1 - pow(1 - t, 5)
    
    def _get_char_pos(self, view, layout, paint, char, idx, last_start, pad_L, scr_X):
        try:
            if layout:
                base = layout.getLineBaseline(layout.getLineCount() - 1)
                x = pad_L + layout.getPrimaryHorizontal(idx) - scr_X
                y = view.getPaddingTop() + base
            else:
                return 0, 0
            return x, y
        except:
            return 0, 0
    
    def _draw_char_with_blur(self, canvas, char, x, y, paint, prog, blur_rad, orig_a):
        blur_a = int((1.0 - prog) * 255)
        normal_a = 0
        if prog > 0.2:
            normal_a = int(((prog - 0.2) / 0.8) * 255)
        
        if blur_a > 5 and self._Utilities:
            try:
                sc = 2.0
                bw = max(4, int(paint.measureText(char) / sc + blur_rad * 2))
                bh = max(4, int(paint.getTextSize() / sc * 1.5 + blur_rad * 2))
                
                Config = jclass("android.graphics.Bitmap$Config")
                bmp = self._Bitmap.createBitmap(bw, bh, Config.ARGB_8888)
                tmp = self._Canvas(bmp)
                tmp.scale(1.0 / sc, 1.0 / sc)
                tmp.translate(blur_rad * 2, paint.getTextSize() * 1.5 - blur_rad * 2)
                
                paint.setAlpha(255)
                tmp.drawText(char, 0, 0, paint)
                
                self._Utilities.stackBlurBitmap(bmp, max(1, int(blur_rad / sc)))
                
                d_paint = self._Paint(1)
                d_paint.setAlpha(blur_a)
                
                canvas.save()
                canvas.translate(x - blur_rad * 2, y - paint.getTextSize() * 1.5 + blur_rad * 2)
                canvas.scale(sc, sc)
                canvas.drawBitmap(bmp, 0, 0, d_paint)
                canvas.restore()
                
                bmp.recycle()
            except:
                pass
        
        if normal_a > 0:
            paint.setAlpha(int(normal_a / 255.0 * orig_a))
            canvas.drawText(char, x, y, paint)



class TextBlurAnimationPlugin(BasePlugin):
    
    def __init__(self):
        super().__init__()
        self._hooks = []
        self._states = WeakKeyDictionary()
        self.field_resourcesProvider = None
        self.field_cursorWidth = None
        self.key_chat_messagePanelCursor = None
        self.Theme = None
    
    def get_state(self, view) -> AnimationState:
        if view not in self._states:
            self._states[view] = AnimationState()
        return self._states[view]
    
    def _start_heartbeat(self, view):
        state = self.get_state(view)
        if state.heartbeat_running:
            return
        state.heartbeat_running = True
        
        def loop():
            if not state.is_focused:
                state.heartbeat_running = False
                return
            try:
                if not view.isShown():
                    state.heartbeat_running = False
                    return
                view.invalidate()
                run_on_ui_thread(loop, delay=10)
            except:
                state.heartbeat_running = False
        
        run_on_ui_thread(loop)
    
    def on_plugin_load(self):
        self.log("Loading v2.0.0...")
        self._hooks = []
        
        try:
            self.Theme = jclass("org.telegram.ui.ActionBar.Theme")
            self.key_chat_messagePanelCursor = getattr(self.Theme, "key_chat_messagePanelCursor")
        except:
            pass
        
        target_classes = [
            "org.telegram.ui.Components.EditTextCaption",
            "org.telegram.ui.Components.EditTextBoldCursor",
            "org.telegram.ui.Components.EditTextEffects"
        ]
        
        t_cls = None
        found_name = None
        for n in target_classes:
            try:
                c = JClass.forName(n)
                if c:
                    t_cls = getattr(c, "class_", c)
                    found_name = n
                    break
            except:
                continue
        
        if not t_cls:
            self.log("No suitable EditText class found!")
            return
        
        curr = t_cls
        while curr and not self.field_resourcesProvider:
            try:
                f = curr.getDeclaredField("resourcesProvider")
                f.setAccessible(True)
                self.field_resourcesProvider = f
            except:
                pass
            curr = curr.getSuperclass()
        
        try:
            curr = t_cls
            while curr and not self.field_cursorWidth:
                try:
                    f = curr.getDeclaredField("cursorWidth")
                    f.setAccessible(True)
                    self.field_cursorWidth = f
                except:
                    pass
                curr = curr.getSuperclass()
        except:
            pass
        
        try:
            cnv = JClass.forName("android.graphics.Canvas")
            m_draw = None
            try:
                m_draw = t_cls.getDeclaredMethod("onDraw", getattr(cnv, "class_", cnv))
            except:
                m_draw = t_cls.getMethod("onDraw", getattr(cnv, "class_", cnv))
            
            if m_draw:
                m_draw.setAccessible(True)
                self._hooks.append(self.hook_method(m_draw, TextBlurHook(self)))
                self.log(f"Hooked: {found_name}")
        except Exception as e:
            self.log(f"Error hooking onDraw: {e}")
        
        for m_name, hk_cls in [("onFocusChanged", FocusHook), ("onTouchEvent", TouchHook)]:
            try:
                m = None
                curr = t_cls
                while curr and not m:
                    try:
                        for dm in curr.getDeclaredMethods():
                            if dm.getName() == m_name:
                                m = dm
                                break
                    except:
                        pass
                    curr = curr.getSuperclass()
                if m:
                    m.setAccessible(True)
                    self._hooks.append(self.hook_method(m, hk_cls(self)))
            except:
                pass
        
        self.log("Loaded! (thx for using)")
    
    def on_plugin_unload(self):
        for h in self._hooks:
            self.unhook_method(h)
        self._hooks.clear()
        self._states.clear()
        self.field_resourcesProvider = None
        self.field_cursorWidth = None
        self.log("Unloaded!")
    
    def _show_test_dialog(self, view):
        from client_utils import get_last_fragment
        from ui.alert import AlertDialogBuilder
        
        try:
            fragment = get_last_fragment()
            if not fragment:
                self.log("No fragment available")
                return
            
            activity = fragment.getParentActivity()
            if not activity:
                self.log("No activity available")
                return
            
            FrameLayout = jclass("android.widget.FrameLayout")
            LayoutParams = jclass("android.widget.FrameLayout$LayoutParams")
            TypedValue = jclass("android.util.TypedValue")
            Gravity = jclass("android.view.Gravity")
            Theme = jclass("org.telegram.ui.ActionBar.Theme")
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            
            EditTextCaption = jclass("org.telegram.ui.Components.EditTextCaption")
            
            container = FrameLayout(activity)
            
            edit_text = EditTextCaption(activity, None)
            edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            edit_text.setBackgroundDrawable(None)
            edit_text.setPadding(
                AndroidUtilities.dp(24),
                AndroidUtilities.dp(16),
                AndroidUtilities.dp(24),
                AndroidUtilities.dp(16)
            )
            edit_text.setGravity(Gravity.TOP | Gravity.LEFT)
            edit_text.setInputType(1 | 0x00020000 | 0x00001000)
            edit_text.setMaxLines(6)
            edit_text.setSingleLine(False)
            
            from org.telegram.messenger import LocaleController
            try:
                lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            except:
                lang = "en"
            is_ru = str(lang).startswith("ru")
            
            hint_text = "Начните печатать для теста анимации..." if is_ru else "Start typing to test animation..."
            edit_text.setHint(hint_text)
            
            params = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT)
            container.addView(edit_text, params)
            
            title = "Тест анимации" if is_ru else "Animation Test"
            close_text = "Закрыть" if is_ru else "Close"
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(title)
            builder.set_view(container, AndroidUtilities.dp(150))
            builder.set_positive_button(close_text, lambda b, w: b.dismiss())
            builder.show()
            
            def setup_focus():
                edit_text.requestFocus()
                state = self.get_state(edit_text)
                state.is_focused = True
                self._start_heartbeat(edit_text)
            
            run_on_ui_thread(setup_focus, delay=100)
            
        except Exception as e:
            self.log(f"Error showing test dialog: {e}")
    
    def create_settings(self):
        from org.telegram.messenger import LocaleController
        
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except:
            lang = "en"
        
        is_ru = str(lang).startswith("ru")
        
        slide_enabled = self.get_setting("slide_enabled", True)
        
        settings = [
            Header(text="Основные" if is_ru else "General"),
            
            Switch(
                key="enabled",
                text="Включить плагин" if is_ru else "Enable Plugin",
                default=True,
                subtext="Главный переключатель" if is_ru else "Master switch",
                icon=""
            ),
            
            Text(
                text="Тестировать анимацию" if is_ru else "Test Animation",
                icon="msg_photo_curve_solar",
                accent=True,
                on_click=self._show_test_dialog
            ),
            
            Divider(),
            Header(text="Анимация текста" if is_ru else "Text Animation"),
            
            Switch(
                key="blur_enabled",
                text="Эффект размытия" if is_ru else "Blur Effect",
                default=True,
                subtext="Размытие при появлении букв" if is_ru else "Blur on character appearance",
                icon="msg_photo_blur_solar"
            ),
            
            Switch(
                key="slide_enabled",
                text="Появление сверху" if is_ru else "Slide from Top",
                default=True,
                subtext="Буквы появляются сверху" if is_ru else "Characters slide from above",
                icon="msg_contacts_name_solar"
            ),
            
            Input(
                key="duration",
                text="Длительность (мс)" if is_ru else "Duration (ms)",
                default="300",
                subtext="200-500 мс рекомендуется" if is_ru else "200-500 ms recommended",
                icon="msg_contacts_time_solar"
            ),
            
            Input(
                key="blur_radius",
                text="Радиус размытия" if is_ru else "Blur Radius",
                default="10",
                subtext="5-15 рекомендуется" if is_ru else "5-15 recommended",
                icon="msg_instant_link_solar"
            ),
        ]
        
        if slide_enabled:
            settings.append(
                Input(
                    key="slide_dist",
                    text="Дистанция слайда" if is_ru else "Slide Distance",
                    default="20",
                    subtext="Пиксели смещения сверху" if is_ru else "Pixels offset from top",
                    icon="msg_map_type_solar"
                )
            )
        
        settings.extend([
            Divider(),
            Header(text="Плавный курсор" if is_ru else "Smooth Cursor"),
            
            Switch(
                key="cursor_enabled",
                text="Плавный курсор" if is_ru else "Smooth Cursor",
                default=True,
                subtext="Плавное движение курсора" if is_ru else "Fluid cursor movement",
                icon="msg_edit"
            ),
            
            Input(
                key="cursor_speed",
                text="Скорость (10-100)" if is_ru else "Speed (10-100)",
                default="25",
                subtext="Скорость анимации курсора" if is_ru else "Cursor animation speed",
                icon="msg_speed"
            ),
            
            Input(
                key="cursor_width",
                text="Ширина курсора" if is_ru else "Cursor Width",
                default="5",
                subtext="Толщина курсора в пикселях" if is_ru else "Cursor thickness in pixels",
                icon="msg_edit"
            )
        ])
        
        return settings