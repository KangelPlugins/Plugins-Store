"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

 Кража кода без указания авторства является публичным неуважением к работе автора.
  Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
   Берёте — но делайте это с уважением :)
   
 Оригинальная идея и реализация от @mihailkotovski & @mishabotov + scale эффект
 Плавный курсор и плавное появление букв сверху от @shikaatux + исправление OOM (out of memory)
"""

__id__ = "text_animation"
__name__ = "Text Animation"
__description__ = "Animation of text appearance with blur effect + Slide + Scale + Smooth Cursor animations"
__author__ = "@mihailkotovski & @mishabotov & @shikaatux"
__version__ = "3.0.0 [bug fixes + scale]"
__icon__ = "DateRegBot_by_MoiStikiBot/15"
__min_version__ = "11.12.1"

import time
import math
from weakref import WeakKeyDictionary
from base_plugin import BasePlugin, MethodHook
from android_utils import run_on_ui_thread
from ui.settings import Header, Switch, Input, Divider

from java import jclass
from java.lang import Class as JClass

class AnimationState:

    __slots__ = (
        'prev_text', 'prev_len', 'prev_last_line_start',
        'char_start_times', 'has_animating_chars', 'animation_running',
        'cursor_x', 'cursor_y', 'cursor_animating',
        'system_cursor_hidden', 'is_focused', 'heartbeat_running',
        'cursor_paint', 'cursor_rect', 'drawing_depth'
    )

    def __init__(self):
        self.prev_text = ""
        self.prev_len = 0
        self.prev_last_line_start = 0
        self.char_start_times = {}
        self.has_animating_chars = False
        self.animation_running = False
        self.cursor_x = -1.0
        self.cursor_y = -1.0
        self.cursor_animating = False
        self.system_cursor_hidden = False
        self.is_focused = False
        self.heartbeat_running = False
        self.drawing_depth = 0
        self.cursor_paint = None
        self.cursor_rect = None

class BaseTextHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

class TouchHook(BaseTextHook):
    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            if view:
                view.invalidate()
                if hasattr(self.plugin, "_start_heartbeat"):
                    self.plugin._start_heartbeat(view)
        except:
            pass

class FocusHook(BaseTextHook):
    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            focused = param.args[0]
            if view and hasattr(self.plugin, "get_state"):
                state = self.plugin.get_state(view)
                state.is_focused = focused
                if focused:
                    view.invalidate()
                    self.plugin._start_heartbeat(view)
        except:
            pass

class TextBlurHook(BaseTextHook):
    def __init__(self, plugin):
        super().__init__(plugin)
        self._classes_loaded = False
        self._Paint = None
        self._Bitmap = None
        self._Canvas = None
        self._Utilities = None
        self._ForegroundColorSpan = None
        self._RectF = None
        self._active_spans = WeakKeyDictionary()

    def _load_classes(self):
        if self._classes_loaded:
            return True
        try:
            self._Paint = jclass("android.graphics.Paint")
            self._Bitmap = jclass("android.graphics.Bitmap")
            self._Canvas = jclass("android.graphics.Canvas")
            self._ForegroundColorSpan = jclass("android.text.style.ForegroundColorSpan")
            self._RectF = jclass("android.graphics.RectF")
            try:
                self._Utilities = jclass("org.telegram.messenger.Utilities")
            except:
                self._Utilities = None
            
            self._classes_loaded = True
            return True
        except:
            return False

    def _setup_cursor(self, view, state):
        if state.system_cursor_hidden:
            return
        try:
            view.setCursorVisible(True)
            if self.plugin.field_cursorWidth:
                self.plugin.field_cursorWidth.setFloat(view, 0.0)
            state.system_cursor_hidden = True
        except:
            pass

    def _get_last_line_start(self, view, txt):
        try:
            layout = view.getLayout()
            if layout and layout.getLineCount() > 1:
                return layout.getLineStart(layout.getLineCount() - 1)
            return 0
        except:
            return 0

    def _update_hidden_span(self, view, state, last_line_start):
        if self._ForegroundColorSpan is None:
            return
        try:
            text = view.getText()
            if text is None:
                return
            
            anim_indices = [i for i in state.char_start_times.keys() if i >= last_line_start]
            if not anim_indices:
                self._remove_span(view)
                return
            
            start = min(anim_indices)
            end = max(anim_indices) + 1
            
            if view in self._active_spans:
                try:
                    text.removeSpan(self._active_spans.pop(view))
                except:
                    pass
            
            new_span = self._ForegroundColorSpan(0x00000000)
            text.setSpan(new_span, start, end, 33)
            self._active_spans[view] = new_span
        except:
            pass

    def _remove_span(self, view):
        if view in self._active_spans:
            try:
                view.getText().removeSpan(self._active_spans.pop(view))
            except:
                pass

    def _start_text_animation_loop(self, view, state):
        if state.animation_running:
            return
        state.animation_running = True
        
        duration = int(self.plugin.get_setting("duration", 300))
        
        def update():
            if not state.char_start_times:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
                return

            curr = time.time()
            done = []
            for i, t in state.char_start_times.items():
                if (curr - t) * 1000 >= duration:
                    done.append(i)
            
            for i in done:
                del state.char_start_times[i]
            
            try:
                txt = str(view.getText())
                if done:
                    self._update_hidden_span(view, state, self._get_last_line_start(view, txt))
            except:
                pass
            
            run_on_ui_thread(lambda: view.invalidate())
            
            if state.char_start_times:
                run_on_ui_thread(update, delay=16)
            else:
                state.animation_running = False
                state.has_animating_chars = False
                self._remove_span(view)
                run_on_ui_thread(update)

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            
            view = param.thisObject
            if not view or not self._load_classes():
                return
                
            state = self.plugin.get_state(view)
            state.drawing_depth += 1
            
            if self.plugin.get_setting("cursor_enabled", True):
                self._setup_cursor(view, state)

            text = view.getText()
            if text is None:
                return
            
            cur_txt = str(text)
            cur_len = len(cur_txt)
            last_start = self._get_last_line_start(view, cur_txt)
            
            if last_start != state.prev_last_line_start:
                state.char_start_times.clear()
                state.has_animating_chars = False
                self._remove_span(view)
                state.prev_last_line_start = last_start
                state.prev_text = cur_txt
                state.prev_len = cur_len
                return

            if cur_len > state.prev_len:
                if cur_txt[:state.prev_len] == state.prev_text:
                    now = time.time()
                    for i in range(state.prev_len, cur_len):
                        state.char_start_times[i] = now
                    
                    if state.char_start_times:
                        state.has_animating_chars = True
                        self._update_hidden_span(view, state, last_start)
                        self._start_text_animation_loop(view, state)
            elif cur_len < state.prev_len:
                rem = [i for i in state.char_start_times if i >= cur_len]
                for i in rem:
                    del state.char_start_times[i]
                    
                if not state.char_start_times:
                    state.has_animating_chars = False
                    self._remove_span(view)
                else:
                    self._update_hidden_span(view, state, last_start)

            state.prev_text = cur_txt
            state.prev_len = cur_len
            state.prev_last_line_start = last_start

        except:
            pass

    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("enabled", True):
                return
            
            view = param.thisObject
            canvas = param.args[0] if param.args else None
            state = self.plugin.get_state(view)
            
            state.drawing_depth -= 1
            if state.drawing_depth > 0:
                return
                
            if not view or not canvas:
                return

            if state.has_animating_chars:
                self._draw_animated_chars(view, canvas, state)
                
            if self.plugin.get_setting("cursor_enabled", True):
                self._draw_cursor(view, canvas, state)
        except:
            pass

    def _draw_cursor(self, view, canvas, state):
        if not view.isFocused():
            return

        try:
            canvas.save()
            
            final_color = 0xFF2CA5E0
            try:
                if self.plugin.field_resourcesProvider:
                    prov = self.plugin.field_resourcesProvider.get(view)
                    if prov and self.plugin.key_chat_messagePanelCursor:
                        final_color = prov.getColor(self.plugin.key_chat_messagePanelCursor)
                elif self.plugin.Theme and self.plugin.key_chat_messagePanelCursor:
                    final_color = self.plugin.Theme.getColor(self.plugin.key_chat_messagePanelCursor)
            except:
                pass

            layout = view.getLayout()
            sel = view.getSelectionStart()
            if sel < 0:
                sel = 0
            
            layout_len = 0
            if layout:
                layout_len = layout.getLineEnd(layout.getLineCount() - 1)
            
            safe_sel = sel
            if safe_sel > layout_len:
                safe_sel = layout_len

            paint = view.getPaint()
            text_size = paint.getTextSize()
            
            target_x = 0.0
            line_mid_y = float(view.getHeight()) / 2.0 if view.getHeight() > 0 else text_size

            if layout:
                try:
                    target_line = layout.getLineForOffset(safe_sel)
                    target_x = layout.getPrimaryHorizontal(safe_sel)
                    
                    line_T = layout.getLineTop(target_line)
                    line_B = layout.getLineBottom(target_line)
                    line_mid_y = line_T + (line_B - line_T) / 2.0
                except:
                    pass

            if state.cursor_x < 0:
                state.cursor_x = target_x
                state.cursor_y = line_mid_y

            base_speed = max(0.05, float(self.plugin.get_setting("cursor_speed", 25)) / 100.0)
            max_step = 60.0

            is_moving = False
            
            diff_x = target_x - state.cursor_x
            if abs(diff_x) > 0.1:
                step_x = diff_x * base_speed
                if step_x > max_step: step_x = max_step
                elif step_x < -max_step: step_x = -max_step
                state.cursor_x += step_x
                is_moving = True
            else:
                state.cursor_x = target_x

            diff_y = line_mid_y - state.cursor_y
            if abs(diff_y) > 0.1:
                step_y = diff_y * (base_speed * 1.2)
                limit_y = max_step * 1.5
                if step_y > limit_y: step_y = limit_y
                elif step_y < -limit_y: step_y = -limit_y
                state.cursor_y += step_y
                is_moving = True
            else:
                state.cursor_y = line_mid_y

            blink_alpha = 255
            if not is_moving:
                t = time.time()
                val = (math.sin(t * 6.0) + 1) / 2.0
                blink_alpha = int((0.2 + 0.8 * val) * 255)

            color_alpha = (final_color >> 24) & 0xFF
            final_alpha = min(blink_alpha, color_alpha)
            if final_alpha == 0 and blink_alpha > 0:
                final_alpha = blink_alpha

            pad_L = view.getPaddingLeft()
            pad_T = view.getPaddingTop()
            
            
            cursor_height = text_size * 1.25
            width = int(self.plugin.get_setting("cursor_width", 5))
            
            draw_y_T = pad_T + state.cursor_y - (cursor_height / 2)
            draw_y_B = pad_T + state.cursor_y + (cursor_height / 2)
            draw_x = pad_L + state.cursor_x
            
            if state.cursor_paint is None:
                state.cursor_paint = self._Paint(1)
            
            r = (final_color >> 16) & 0xFF
            g = (final_color >> 8) & 0xFF
            b = final_color & 0xFF
            state.cursor_paint.setARGB(final_alpha, r, g, b)

            if state.cursor_rect is None:
                state.cursor_rect = self._RectF()
            
            state.cursor_rect.set(float(draw_x), float(draw_y_T), float(draw_x + width), float(draw_y_B))
            
            canvas.drawRoundRect(state.cursor_rect, float(width / 2), float(width / 2), state.cursor_paint)
            
            canvas.restore()
        except:
            pass

    def _draw_animated_chars(self, view, canvas, state):
        if not self._classes_loaded:
            return
        try:
            paint = view.getPaint()
            text = view.getText()
            if not paint or not text:
                return
            
            txt = str(text)
            if not state.char_start_times:
                return
                
            blur_enabled = self.plugin.get_setting("blur_enabled", True)
            slide_enabled = self.plugin.get_setting("slide_enabled", True)
            scale_enabled = self.plugin.get_setting("scale_enabled", False)
            blur_rad = int(self.plugin.get_setting("blur_radius", 10))
            duration = int(self.plugin.get_setting("duration", 300))
            try:
                slide_dist = int(self.plugin.get_setting("slide_dist", 20))
            except:
                slide_dist = 20
            try:
                scale_start = float(self.plugin.get_setting("scale_start", "0.3"))
            except:
                scale_start = 0.3

            now = time.time()
            layout = view.getLayout()
            last_line_start = layout.getLineStart(layout.getLineCount() - 1) if layout else 0
            
            pad_L = view.getPaddingLeft()
            
            orig_A = paint.getAlpha()
            
            for i, start_t in list(state.char_start_times.items()):
                if i >= len(txt) or i < last_line_start:
                    continue
                
                prog = min(1.0, (now - start_t) * 1000 / duration)
                prog = self._ease_out_quint(prog)
                
                x, y = self._get_char_pos(view, layout, paint, txt, i, last_line_start, pad_L)
                
                y_off = 0
                if slide_enabled:
                    y_off = int(-slide_dist * (1.0 - prog))
                
                if scale_enabled:
                    self._draw_char_with_scale(canvas, txt[i], x, y + y_off, paint, prog, scale_start, blur_enabled, blur_rad, orig_A)
                elif blur_enabled:
                    self._draw_char_with_blur(canvas, txt[i], x, y + y_off, paint, prog, blur_rad, orig_A)
                else:
                    alpha = int(prog * orig_A)
                    if alpha > 0:
                        paint.setAlpha(alpha)
                        canvas.drawText(txt[i], x, y + y_off, paint)
                        paint.setAlpha(orig_A)
        except:
            pass
    
    def _draw_char_with_scale(self, canvas, char, x, y, paint, prog, scale_start, blur_enabled, blur_rad, orig_a):
        scale = scale_start + (1.0 - scale_start) * prog
        alpha = int(prog * orig_a)
        
        if alpha <= 0:
            return
        
        try:
            char_width = paint.measureText(char)
            
            canvas.save()
            
            pivot_x = x + char_width / 2
            pivot_y = y - paint.getTextSize() / 2
            
            canvas.translate(pivot_x, pivot_y)
            canvas.scale(scale, scale)
            canvas.translate(-pivot_x, -pivot_y)
            
            if blur_enabled and prog < 0.8:
                self._draw_char_with_blur(canvas, char, x, y, paint, prog, blur_rad, orig_a)
            else:
                paint.setAlpha(alpha)
                canvas.drawText(char, x, y, paint)
                paint.setAlpha(orig_a)
            
            canvas.restore()
        except:
            paint.setAlpha(alpha)
            canvas.drawText(char, x, y, paint)
            paint.setAlpha(orig_a)

    def _ease_out_quint(self, t):
        return 1 - pow(1 - t, 5)

    def _get_char_pos(self, view, layout, paint, txt, idx, last_start, pad_L):
        try:
            if layout:
                base = layout.getLineBaseline(layout.getLineCount() - 1)
                x = pad_L + layout.getPrimaryHorizontal(idx) 
                y = view.getPaddingTop() + base
            else:
                pre_w = paint.measureText(txt[last_start:idx])
                x = pad_L + pre_w
                y = view.getBaseline()
            return x, y
        except:
            return 0, 0

    def _draw_char_with_blur(self, canvas, char, x, y, paint, prog, blur_rad, orig_a):
        blur_a = int((1.0 - prog) * 255)
        normal_a = 0
        if prog > 0.2:
            normal_a = int(((prog - 0.2) / 0.8) * 255)

        if blur_a > 5 and self._Utilities:
            try:
                sc = 2.0
                bw = max(4, int(paint.measureText(char) / sc + blur_rad * 2))
                bh = max(4, int(paint.getTextSize() / sc * 1.5 + blur_rad * 2))
                
                Config = jclass("android.graphics.Bitmap$Config")
                bmp = self._Bitmap.createBitmap(bw, bh, Config.ARGB_8888)
                tmp = self._Canvas(bmp)
                tmp.scale(1.0 / sc, 1.0 / sc)
                tmp.translate(blur_rad * 2, paint.getTextSize() * 1.5 - blur_rad * 2)
                
                paint.setAlpha(255)
                tmp.drawText(char, 0, 0, paint)
                
                self._Utilities.stackBlurBitmap(bmp, max(1, int(blur_rad / sc)))
                
                d_paint = self._Paint(1)
                d_paint.setAlpha(blur_a)
                
                canvas.save()
                canvas.translate(x - blur_rad * 2, y - paint.getTextSize() * 1.5 + blur_rad * 2)
                canvas.scale(sc, sc)
                canvas.drawBitmap(bmp, 0, 0, d_paint)
                canvas.restore()
                bmp.recycle()
            except:
                pass
        
        if normal_a > 0:
            paint.setAlpha(int(normal_a / 255.0 * orig_a))
            canvas.drawText(char, x, y, paint)

class TextBlurAnimationPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._hooks = []
        self._states = WeakKeyDictionary()
        self.field_resourcesProvider = None
        self.field_cursorWidth = None
        self.key_chat_messagePanelCursor = None
        self.Theme = None

    def get_state(self, view) -> AnimationState:
        if view not in self._states:
            self._states[view] = AnimationState()
        return self._states[view]
    
    def _start_heartbeat(self, view):
        state = self.get_state(view)
        if state.heartbeat_running:
            return
        state.heartbeat_running = True
        
        def loop():
            if not state.is_focused:
                state.heartbeat_running = False
                return
            try:
                if not view.isShown():
                    state.heartbeat_running = False
                    return
                view.invalidate()
                run_on_ui_thread(loop, delay=10)
            except:
                state.heartbeat_running = False
        
        run_on_ui_thread(loop)

    def on_plugin_load(self):
        self.log("Loading v2.0.3...")
        self._hooks = []
        
        try:
            self.Theme = jclass("org.telegram.ui.ActionBar.Theme")
            self.key_chat_messagePanelCursor = getattr(self.Theme, "key_chat_messagePanelCursor")
        except:
            pass
            
        target_classes = [
            "org.telegram.ui.Components.EditTextCaption",
            "org.telegram.ui.Components.EditTextBoldCursor",
            "org.telegram.ui.Components.EditTextEffects"
        ]
        
        t_cls = None
        found_name = None
        
        for n in target_classes:
            try:
                c = JClass.forName(n)
                if c:
                    t_cls = getattr(c, "class_", c)
                    found_name = n
                    break
            except:
                continue
                
        if not t_cls:
            self.log("No suitable EditText class found!")
            return

        curr = t_cls
        while curr and not self.field_resourcesProvider:
            try:
                f = curr.getDeclaredField("resourcesProvider")
                f.setAccessible(True)
                self.field_resourcesProvider = f
            except:
                pass
            curr = curr.getSuperclass()
            
        curr = t_cls
        while curr and not self.field_cursorWidth:
            try:
                f = curr.getDeclaredField("cursorWidth")
                f.setAccessible(True)
                self.field_cursorWidth = f
            except:
                pass
            curr = curr.getSuperclass()

        try:
            cnv = JClass.forName("android.graphics.Canvas")
            m_draw = None
            try:
                m_draw = t_cls.getDeclaredMethod("onDraw", getattr(cnv, "class_", cnv))
            except:
                m_draw = t_cls.getMethod("onDraw", getattr(cnv, "class_", cnv))
                
            if m_draw:
                m_draw.setAccessible(True)
                self._hooks.append(self.hook_method(m_draw, TextBlurHook(self)))
                self.log(f"Hooked: {found_name}")
        except Exception as e:
            self.log(f"Error hooking onDraw: {e}")
            
        for m_name, hk_cls in [("onFocusChanged", FocusHook), ("onTouchEvent", TouchHook)]:
            try:
                m = None
                curr = t_cls
                while curr and not m:
                    try:
                        for dm in curr.getDeclaredMethods():
                            if dm.getName() == m_name:
                                m = dm
                                break
                    except:
                        pass
                    curr = curr.getSuperclass()
                
                if m:
                    m.setAccessible(True)
                    self._hooks.append(self.hook_method(m, hk_cls(self)))
            except:
                pass
                
        self.log("Loaded! (thx for using)")

    def on_plugin_unload(self):
        for h in self._hooks:
            self.unhook_method(h)
        self._hooks.clear()
        self._states.clear()
        self.field_resourcesProvider = None
        self.field_cursorWidth = None
        self.log("Unloaded!")

    def create_settings(self):
        from org.telegram.messenger import LocaleController
        try:
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except:
            lang = "en"
            
        is_ru = str(lang).startswith("ru")
        slide_enabled = self.get_setting("slide_enabled", True)
        
        settings = [
            Header(text="Основные" if is_ru else "General"),
            Switch(
                key="enabled",
                text="Включить плагин" if is_ru else "Enable Plugin",
                default=True,
                subtext="Главный переключатель" if is_ru else "Master switch",
                icon=""
            ),
            Divider(),
            Header(text="Анимация текста" if is_ru else "Text Animation"),
            Switch(
                key="blur_enabled",
                text="Эффект размытия" if is_ru else "Blur Effect",
                default=True,
                subtext="Размытие при появлении букв" if is_ru else "Blur on character appearance",
                icon="msg_photo_blur_solar"
            ),
            Switch(
                key="slide_enabled",
                text="Появление сверху" if is_ru else "Slide from Top",
                default=True,
                subtext="Буквы появляются сверху" if is_ru else "Characters slide from above",
                icon="msg_contacts_name_solar"
            ),
            Switch(
                key="scale_enabled",
                text="Масштабирование" if is_ru else "Scale Animation",
                default=False,
                subtext="Буквы увеличиваются при появлении" if is_ru else "Characters scale up on appearance",
                icon="msg_zoomin"
            ),
            Input(
                key="duration",
                text="Длительность (мс)" if is_ru else "Duration (ms)",
                default="300",
                subtext="200-500 мс рекомендуется" if is_ru else "200-500 ms recommended",
                icon="msg_contacts_time_solar"
            ),
            Input(
                key="blur_radius",
                text="Радиус размытия" if is_ru else "Blur Radius",
                default="10",
                subtext="5-15 рекомендуется" if is_ru else "5-15 recommended",
                icon="msg_instant_link_solar"
            ),
        ]
        
        if slide_enabled:
            settings.append(
                Input(
                    key="slide_dist",
                    text="Дистанция слайда" if is_ru else "Slide Distance",
                    default="20",
                    subtext="Пиксели смещения сверху" if is_ru else "Pixels offset from top",
                    icon="msg_map_type_solar"
                )
            )
        
        scale_enabled = self.get_setting("scale_enabled", False)
        if scale_enabled:
            settings.append(
                Input(
                    key="scale_start",
                    text="Начальный масштаб" if is_ru else "Start Scale",
                    default="0.3",
                    subtext="0.0-0.9 (0.3 рекомендуется)" if is_ru else "0.0-0.9 (0.3 recommended)",
                    icon="msg_zoomin"
                )
            )
            
        settings.extend([
            Divider(),
            Header(text="Плавный курсор" if is_ru else "Smooth Cursor"),
            Switch(
                key="cursor_enabled",
                text="Плавный курсор" if is_ru else "Smooth Cursor",
                default=True,
                subtext="Плавное движение курсора" if is_ru else "Fluid cursor movement",
                icon="msg_edit"
            ),
            Input(
                key="cursor_speed",
                text="Скорость (10-100)" if is_ru else "Speed (10-100)",
                default="25",
                subtext="Скорость анимации курсора" if is_ru else "Cursor animation speed",
                icon="msg_speed"
            ),
            Input(
                key="cursor_width",
                text="Ширина курсора" if is_ru else "Cursor Width",
                default="5",
                subtext="Толщина курсора в пикселях" if is_ru else "Cursor thickness in pixels",
                icon="msg_edit"
            )
        ])
        
        return settings