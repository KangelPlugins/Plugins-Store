"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿

by @mihailkotovski
Перед копированием/изменением кода уведомите @mihailkotovski
"""

import os
import time
import json
import re
import threading
import base64
import random
from typing import List, Dict, Any, Optional
from collections import deque
from java.util import ArrayList, Locale
from java.io import File, FileOutputStream, FileInputStream
from android.content import Intent, Context
from android.net import Uri
from android.widget import LinearLayout, CheckBox, TextView, ScrollView, FrameLayout, EditText
from android.text import InputType, TextWatcher
from androidx.core.content import FileProvider
from android.view import Gravity, ViewGroup, View
from android.graphics import Color, Typeface, Canvas, Paint, RectF
from android.graphics.drawable import GradientDrawable, RippleDrawable, ColorDrawable
from android.content.res import ColorStateList
from android.util import TypedValue
from org.telegram.messenger import (
    ApplicationLoader, UserConfig, MessagesController, 
    MessagesStorage, FileLoader, LocaleController, AndroidUtilities, R,
    ImageLocation
)
from org.telegram.tgnet import TLRPC, NativeByteBuffer
from org.telegram.SQLite import SQLiteCursor
from org.telegram.ui.ActionBar import Theme, BottomSheet
from org.telegram.ui.Cells import (
    TextCheckCell, TextSettingsCell, HeaderCell
)
from org.telegram.ui.Components import EditTextBoldCursor, Bulletin, BulletinFactory, CircularProgressDrawable
from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import (
    get_messages_storage, get_messages_controller, 
    get_user_config, get_last_fragment, run_on_queue,
    send_request, get_connections_manager
)
from android_utils import log, run_on_ui_thread, OnClickListener, OnLongClickListener, R
from hook_utils import get_private_field
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

__id__ = "chatexport"
__name__ = "Chat Export"
__description__ = "Export chats to HTML/JSON/TXT with Telegram Desktop style and media."
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "1.7.0 [pre-release]"
__icon__ = "nibbler_vk_Nyasticks_by_MoiStikiBot/35"
__min_version__ = "11.12.1"

DEFAULT_CHUNK_SIZE = 5000
API_BATCH_SIZE = 200

TRANSLATIONS = {
    "ru": {
        "export_chat": "Экспорт чата",
        "exporting": "Экспорт чата...",
        "cancel": "Отмена",
        "export_complete": "Экспорт завершён!",
        "export_failed": "Ошибка экспорта",
        "export_in_progress": "Экспорт уже выполняется",
        "run_in_background": "В фоне",
        "background_export": "Экспорт продолжается в фоне",
        "cannot_determine_chat": "Не удалось определить ID чата",
        "loading_messages": "Загрузка сообщений из {chat}...",
        "generating_export": "Создание экспорта для {chat}...",
        "preparing_share": "Подготовка к отправке...",
        "export_settings": "Настройки экспорта",
        "export_format": "Формат экспорта",
        "media_handling": "Обработка медиа",
        "message_filters": "Фильтры сообщений",
        "max_messages": "Макс. сообщений",
        "empty_all": "Пусто = все",
        "advanced": "Дополнительно",
        "max_size_mb": "Макс. размер (МБ)",
        "include_timestamps": "Временные метки",
        "include_avatars": "Аватары",
        "group_messages": "Группировать сообщения",
        "by_sender_time": "По отправителю и времени",
        "menu_help": "Используйте кнопку 'Экспорт чата' в меню чата",
        "chunk_mode": "Режим оптимизации",
        "chunk_mode_desc": "Для больших чатов (45k+ сообщений)",
        "chunk_size": "Размер порции",
        "processing_chunk": "Обработка {current}/{total} порций...",
        "progress_overlay_settings": "Настройки фонового процесса",
        "enable_overlay_stroke": "Обводка оверлея",
        "enable_overlay_stroke_desc": "Показывать обводку вокруг фонового процесса",
        "enable_stroke_animation": "Анимация обводки",
        "enable_stroke_animation_desc": "Переливание цветов обводки",
        "overlay_opacity": "Прозрачность оверлея",
        "overlay_opacity_desc": "Уровень прозрачности (0-100%)",
        "overlay_position": "Расположение оверлея",
        "position_top_center": "Сверху по центру",
        "position_top_left": "Сверху слева",
        "position_top_right": "Сверху справа",
        "position_bottom_center": "Снизу по центру",
        "position_bottom_left": "Снизу слева",
        "position_bottom_right": "Снизу справа",
        "loaded_messages_progress": "Загружено {current}/{target} сообщений",
        "loaded_messages_no_target": "Загружено {current} сообщений...",
        "chunk_progress": "Порция {chunk}: всего {total} сообщений",
        "rendered_messages": "Отрендерено {current}/{total} сообщений...",
        "generating_json": "Генерация JSON: {current}/{total} сообщений...",
        "generating_txt": "Генерация TXT: {current}/{total} сообщений...",
        "txt_header_chat": "Экспорт чата",
        "txt_header_exported": "Экспортировано",
        "txt_header_messages": "Сообщения",
        "txt_footer": "Экспортировано с любовью @mihailkotovski"
    },
    "en": {
        "export_chat": "Export Chat",
        "exporting": "Exporting chat...",
        "cancel": "Cancel",
        "export_complete": "Export complete!",
        "export_failed": "Export failed",
        "export_in_progress": "Export already in progress",
        "run_in_background": "Run in background",
        "background_export": "Export continues in background",
        "cannot_determine_chat": "Cannot determine chat ID",
        "loading_messages": "Loading messages from {chat}...",
        "generating_export": "Generating export for {chat}...",
        "preparing_share": "Preparing to share...",
        "export_settings": "Export Settings",
        "export_format": "Export Format",
        "media_handling": "Media Handling",
        "message_filters": "Message Filters",
        "max_messages": "Max Messages",
        "empty_all": "Empty = all",
        "advanced": "Advanced",
        "max_size_mb": "Max Size (MB)",
        "include_timestamps": "Include Timestamps",
        "include_avatars": "Include Avatars",
        "group_messages": "Group Messages",
        "by_sender_time": "By sender and time",
        "menu_help": "Use 'Export Chat' button in chat menu",
        "chunk_mode": "Optimization Mode",
        "chunk_mode_desc": "For large chats (45k+ messages)",
        "chunk_size": "Chunk Size",
        "processing_chunk": "Processing {current}/{total} chunks...",
        "progress_overlay_settings": "Progress Overlay Settings",
        "enable_overlay_stroke": "Overlay Stroke",
        "enable_overlay_stroke_desc": "Show stroke around progress overlay",
        "enable_stroke_animation": "Stroke Animation",
        "enable_stroke_animation_desc": "Color-shifting stroke animation",
        "overlay_opacity": "Overlay Opacity",
        "overlay_opacity_desc": "Opacity level (0-100%)",
        "overlay_position": "Overlay Position",
        "position_top_center": "Top Center",
        "position_top_left": "Top Left",
        "position_top_right": "Top Right",
        "position_bottom_center": "Bottom Center",
        "position_bottom_left": "Bottom Left",
        "position_bottom_right": "Bottom Right",
        "loaded_messages_progress": "Loaded {current}/{target} messages",
        "loaded_messages_no_target": "Loaded {current} messages...",
        "chunk_progress": "Chunk {chunk}: {total} msgs total",
        "rendered_messages": "Rendered {current}/{total} messages...",
        "generating_json": "Generating JSON: {current}/{total} messages...",
        "generating_txt": "Generating TXT: {current}/{total} messages...",
        "txt_header_chat": "Chat Export",
        "txt_header_exported": "Exported",
        "txt_header_messages": "Messages",
        "txt_footer": "Exported with love by @mihailkotovski"
    }
}


def _encode_file_to_base64(file_path: str, max_size_bytes: int) -> Optional[str]:
    try:
        if not file_path or file_path == "" or file_path == "/" or file_path == "\\":
            return None

        if not os.path.exists(file_path):
            return None

        if not os.path.isfile(file_path):
            return None

        file_size = os.path.getsize(file_path)
        if file_size > max_size_bytes or file_size == 0:
            return None

        with open(file_path, "rb") as f:
            return base64.b64encode(f.read()).decode("ascii")
    except Exception as e:
        log(f"[ChatExport] Base64 encoding error for {file_path}: {e}")
        return None


def _get_file_mime_type(file_path: str) -> str:
    try:
        ext = file_path.lower().split('.')[-1] if '.' in file_path else ''
        mime_types = {
            'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 
            'gif': 'image/gif', 'webp': 'image/webp', 'bmp': 'image/bmp',
            'tgs': 'application/json',
            'mp4': 'video/mp4', 'webm': 'video/webm', 'mov': 'video/quicktime',
            'ogg': 'audio/ogg', 'opus': 'audio/opus', 'mp3': 'audio/mpeg',
            'wav': 'audio/wav', 'm4a': 'audio/mp4', 'avi': 'video/x-msvideo',
            'pdf': 'application/pdf', 'zip': 'application/zip',
            'doc': 'application/msword', 'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'xls': 'application/vnd.ms-excel', 'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'txt': 'text/plain', 'json': 'application/json', 'xml': 'application/xml'
        }
        return mime_types.get(ext, 'application/octet-stream')
    except Exception:
        return 'application/octet-stream'


def _wait_for_file(file_path: str, timeout_ms: int) -> bool:
    if not file_path or file_path in ("", "/", "\\"):
        return False

    start = time.time()
    timeout_sec = timeout_ms / 1000.0
    while time.time() - start < timeout_sec:
        if os.path.exists(file_path):
            return True
        time.sleep(0.05)
    return os.path.exists(file_path)


def _get_best_photo_size(photo):
    try:
        sizes = getattr(photo, "sizes", None)
        if not sizes:
            return None
        
        best_size = None
        max_width = -1
        
        if hasattr(sizes, 'toArray'):
            sizes = list(sizes.toArray())
        
        for size in sizes:
            width = getattr(size, "w", 0) or getattr(size, "width", 0) or 0
            size_type = getattr(size, "type", "")
            
            if size_type == "i":
                continue
                
            if width >= max_width:
                best_size = size
                max_width = width
        
        return best_size
    except Exception as e:
        log(f"[ChatExport] Error getting best photo size: {e}")
        return None


def _get_media_type_from_message(msg) -> str:
    try:
        media = getattr(msg, "media", None)
        if not media:
            return "unknown"
        
        if isinstance(media, TLRPC.TL_messageMediaPhoto):
            return "photo"
        
        if isinstance(media, TLRPC.TL_messageMediaDocument):
            doc = getattr(media, "document", None)
            if not doc:
                return "document"
            
            attrs = getattr(doc, "attributes", [])
            if hasattr(attrs, 'toArray'):
                attrs = list(attrs.toArray())
            
            mime = getattr(doc, "mime_type", "")
            
            for attr in attrs:
                if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                    if mime == "application/x-tgsticker":
                        return "sticker_animated"
                    elif mime == "video/webm":
                        return "sticker_video"
                    else:
                        return "sticker"
                elif isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                    return "gif"
                elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                    if getattr(attr, "round_message", False):
                        return "video_circle"
                    return "video"
                elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                    if getattr(attr, "voice", False):
                        return "voice"
                    return "audio"
            
            mime = getattr(doc, "mime_type", "")
            if mime.startswith("video/"):
                return "video"
            elif mime.startswith("audio/"):
                return "audio"
            elif mime == "image/gif":
                return "gif"
            
            return "document"
        
        return "unknown"
    except Exception as e:
        log(f"[ChatExport] Error determining media type: {e}")
        return "unknown"


class MediaDownloadManager:
    
    def __init__(self, account_id: int, max_workers: int = 6, max_media_mb: int = 10):
        self.account_id = account_id
        self.max_workers = max_workers
        self.max_media_bytes = max_media_mb * 1024 * 1024
        self.download_tasks = deque()
        self.download_results = {}
        self.lock = threading.Lock()
        self.active_threads = 0
        self._cache = {}
    
    def add_avatar_download(self, user_id: int, user_obj):
        with self.lock:
            self.download_tasks.append(('avatar', user_id, user_obj))
    
    def add_media_download(self, msg_id: int, msg_obj, media_type: str = 'photo'):
        with self.lock:
            self.download_tasks.append(('media', msg_id, msg_obj, media_type))
    
    def _download_worker(self):
        while True:
            task = None
            with self.lock:
                if not self.download_tasks:
                    self.active_threads -= 1
                    break
                task = self.download_tasks.popleft()
            
            if not task:
                break
            
            task_type = task[0]
            item_id = task[1]
            item_obj = task[2]
            media_type = task[3] if len(task) > 3 else 'photo'
            
            try:
                if task_type == 'avatar':
                    self._process_avatar(item_id, item_obj)
                elif task_type == 'media':
                    self._process_media(item_id, item_obj, media_type)
            except Exception as e:
                log(f"[ChatExport] Download worker error for {task_type} {item_id}: {e}")
                with self.lock:
                    self.download_results[f'{task_type}_{item_id}'] = None
    
    def _process_avatar(self, user_id: int, user_obj):
        try:
            cache_key = f"avatar_{user_id}"

            if cache_key in self._cache:
                with self.lock:
                    self.download_results[cache_key] = self._cache[cache_key]
                return

            photo = getattr(user_obj, "photo", None)
            if not photo:
                with self.lock:
                    self.download_results[cache_key] = None
                return

            photo_loc = getattr(photo, "photo_small", None) or getattr(photo, "photo_big", None)
            if not photo_loc:
                with self.lock:
                    self.download_results[cache_key] = None
                return

            fl = FileLoader.getInstance(self.account_id)
            file_obj = fl.getPathToAttach(photo_loc, True)

            if not file_obj:
                log(f"[ChatExport] Avatar file_obj is None for user {user_id}")
                with self.lock:
                    self.download_results[cache_key] = None
                return

            file_path = file_obj.getAbsolutePath()

            if not file_path or file_path == "" or file_path == "/" or file_path == "\\":
                log(f"[ChatExport] Invalid avatar path for user {user_id}: '{file_path}'")
                with self.lock:
                    self.download_results[cache_key] = None
                return

            if not os.path.exists(file_path):
                try:
                    image_location = ImageLocation.getForUser(user_obj, ImageLocation.TYPE_SMALL)
                    if image_location:
                        fl.loadFile(image_location, user_obj, "jpg", 0, 1)
                        if _wait_for_file(file_path, 500):
                            pass
                except Exception as e:
                    log(f"[ChatExport] Avatar download error: {e}")

            if os.path.exists(file_path):
                b64_data = _encode_file_to_base64(file_path, 180000)
                if b64_data:
                    data_uri = f"data:image/jpeg;base64,{b64_data}"
                    self._cache[cache_key] = data_uri
                    with self.lock:
                        self.download_results[cache_key] = data_uri
                    return

            with self.lock:
                self.download_results[cache_key] = None

        except Exception as e:
            log(f"[ChatExport] Avatar processing error: {e}")
            with self.lock:
                self.download_results[f'avatar_{user_id}'] = None
    
    def _process_media(self, msg_id: int, msg_obj, media_type: str):
        try:
            cache_key = f"media_{msg_id}"
            
            if cache_key in self._cache:
                with self.lock:
                    self.download_results[cache_key] = self._cache[cache_key]
                    self.download_results[f'media_type_{msg_id}'] = media_type
                return
            
            
            file_path = self._get_media_file_path(msg_obj)
            
            is_valid_path = file_path and file_path not in ("", "/", "\\")
            file_exists = is_valid_path and os.path.exists(file_path)
            
            if not file_exists:
                file_path = self._download_media_file(msg_obj)
                is_valid_path = file_path and file_path not in ("", "/", "\\")
                file_exists = is_valid_path and os.path.exists(file_path)
            
            if file_exists:
                file_size = os.path.getsize(file_path)
                
                if file_size > self.max_media_bytes:
                    with self.lock:
                        self.download_results[cache_key] = None
                        self.download_results[f'media_type_{msg_id}'] = media_type
                        self.download_results[f'media_size_{msg_id}'] = file_size
                    return
                
                b64_data = _encode_file_to_base64(file_path, self.max_media_bytes)
                if b64_data:
                    mime_type = _get_file_mime_type(file_path)
                    data_uri = f"data:{mime_type};base64,{b64_data}"
                    self._cache[cache_key] = data_uri
                    with self.lock:
                        self.download_results[cache_key] = data_uri
                        self.download_results[f'media_type_{msg_id}'] = media_type
                    return
            
            with self.lock:
                self.download_results[cache_key] = None
                self.download_results[f'media_type_{msg_id}'] = media_type
                
        except Exception as e:
            log(f"[ChatExport] Media processing error: {e}")
            with self.lock:
                self.download_results[f'media_{msg_id}'] = None
    
    def _get_media_file_path(self, msg_obj) -> Optional[str]:
        try:
            media = getattr(msg_obj, "media", None)
            if not media:
                return None

            fl = FileLoader.getInstance(self.account_id)

            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo_size = _get_best_photo_size(media.photo)
                if photo_size:
                    file_obj = fl.getPathToAttach(photo_size, True)
                    if file_obj:
                        file_path = file_obj.getAbsolutePath()
                        if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                            return file_path

            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                doc = getattr(media, "document", None)
                if doc:
                    file_obj = fl.getPathToAttach(doc, True)
                    if file_obj:
                        file_path = file_obj.getAbsolutePath()
                        if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                            return file_path

            msg_owner = getattr(msg_obj, "messageOwner", msg_obj)
            file_obj = fl.getPathToMessage(msg_owner)
            if file_obj:
                file_path = file_obj.getAbsolutePath()
                if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                    return file_path

            return None

        except Exception as e:
            log(f"[ChatExport] Error getting media path: {e}")
            import traceback
            log(f"[ChatExport] Traceback: {traceback.format_exc()}")
            return None
    
    def _download_media_file(self, msg_obj) -> Optional[str]:
        try:
            media = getattr(msg_obj, "media", None)
            if not media:
                return None

            fl = FileLoader.getInstance(self.account_id)
            
            expected_path = None
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo_size = _get_best_photo_size(media.photo)
                if photo_size:
                    file_obj = fl.getPathToAttach(photo_size, True)
                    if file_obj:
                        expected_path = file_obj.getAbsolutePath()
            
            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                doc = getattr(media, "document", None)
                if doc:
                    file_obj = fl.getPathToAttach(doc, True)
                    if file_obj:
                        expected_path = file_obj.getAbsolutePath()
            
            if not expected_path or expected_path in ("", "/", "\\"):
                return None
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo_size = _get_best_photo_size(media.photo)
                if photo_size:
                    try:
                        image_location = ImageLocation.getForPhoto(photo_size, media.photo)
                        if image_location:
                            fl.loadFile(image_location, media.photo, "jpg", 0, 1)
                            if _wait_for_file(expected_path, 3000):
                                return expected_path
                    except Exception as e:
                        log(f"[ChatExport] Photo download error: {e}")

            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                doc = getattr(media, "document", None)
                if doc:
                    try:
                        image_location = ImageLocation.getForDocument(doc)
                        if image_location:
                            fl.loadFile(image_location, msg_obj, None, 0, 1)
                            if _wait_for_file(expected_path, 3000):
                                return expected_path
                    except Exception as e:
                        log(f"[ChatExport] Document download error: {e}")

            return None

        except Exception as e:
            log(f"[ChatExport] Media download error: {e}")
            return None
    
    def execute_downloads(self):
        with self.lock:
            queue_size = len(self.download_tasks)
            if queue_size == 0:
                return
            
            workers_needed = min(self.max_workers, queue_size)
            self.active_threads = workers_needed
        
        threads = []
        for _ in range(workers_needed):
            thread = threading.Thread(target=self._download_worker)
            thread.daemon = True
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join(timeout=30)
        
        log(f"[ChatExport] Downloaded {len(self.download_results)} items with {workers_needed} workers")
    
    def get_result(self, key: str):
        with self.lock:
            return self.download_results.get(key)


class ExportSettingsBottomSheet:
    
    def __init__(self, context, plugin, dialog_id):
        self.plugin = plugin
        self.dialog_id = dialog_id
        self.context = context
        
        self.media_handling_cell = None
        self.include_avatars_cell = None
        
        self.bottom_sheet = BottomSheet(context, False)
        
        self.temp_settings = {
            'export_format': plugin.get_setting('export_format', 0),
            'media_handling': plugin.get_setting('media_handling', 0),
            'max_messages': plugin.get_setting('max_messages', ''),
            'max_size_mb': plugin.get_setting('max_size_mb', '100'),
            'use_api_mode': plugin.get_setting('use_api_mode', True),
            'include_timestamps': plugin.get_setting('include_timestamps', True),
            'include_avatars': plugin.get_setting('include_avatars', True),
            'group_messages': plugin.get_setting('group_messages', True),
            'use_chunked_mode': plugin.get_setting('use_chunked_mode', False),
            'chunk_size': plugin.get_setting('chunk_size', DEFAULT_CHUNK_SIZE),
            'enable_overlay_stroke': plugin.get_setting('enable_overlay_stroke', True),
            'enable_stroke_animation': plugin.get_setting('enable_stroke_animation', True),
            'overlay_opacity': plugin.get_setting('overlay_opacity', '100'),
            'overlay_position': plugin.get_setting('overlay_position', 0),
        }
        
        container_layout = LinearLayout(context)
        container_layout.setOrientation(LinearLayout.VERTICAL)
        container_layout.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
        
        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)
        
        self.content_layout = LinearLayout(context)
        self.content_layout.setOrientation(LinearLayout.VERTICAL)
        self.content_layout.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        self._build_settings_cells()
        
        scroll_view.addView(self.content_layout)
        
        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            0,
            1.0
        )
        container_layout.addView(scroll_view, scroll_params)
        
        button_container = self._create_button_container()
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        container_layout.addView(button_container, button_params)
        
        self.bottom_sheet.setCustomView(container_layout)
    
    def show(self):
        self.bottom_sheet.show()
    
    def dismiss(self):
        self.bottom_sheet.dismiss()
    
    def _build_settings_cells(self):
        is_russian = self.plugin._is_russian()
        
        self._add_header(self.plugin._t('export_format'))
        self._add_selector_cell(
            'export_format',
            self.plugin._t('export_format'),
            ['HTML', 'JSON', 'TXT']
        )
        
        self.media_handling_cell = self._add_selector_cell(
            'media_handling',
            self.plugin._t('media_handling'),
            ['Пропустить', 'Ссылки', 'Скачать'] if is_russian else ['Skip', 'References', 'Download']
        )
        
        self._add_header(self.plugin._t('message_filters'))
        self._add_input_cell(
            'max_messages',
            self.plugin._t('max_messages'),
            self.plugin._t('empty_all'),
            InputType.TYPE_CLASS_NUMBER
        )
        
        self._add_header(self.plugin._t('advanced'))
        self._add_input_cell(
            'max_size_mb',
            self.plugin._t('max_size_mb'),
            '100',
            InputType.TYPE_CLASS_NUMBER
        )
        self._add_switch_cell(
            'include_timestamps',
            self.plugin._t('include_timestamps'),
            ''
        )
        self.include_avatars_cell = self._add_switch_cell(
            'include_avatars',
            self.plugin._t('include_avatars'),
            ''
        )
        self._add_switch_cell(
            'group_messages',
            self.plugin._t('group_messages'),
            self.plugin._t('by_sender_time')
        )
        self._add_switch_cell(
            'use_api_mode',
            'Use API Mode' if not is_russian else 'Режим API',
            'Fetch all messages from server' if not is_russian else 'Загружать все сообщения с сервера'
        )
        
        self._add_header(self.plugin._t('chunk_mode'))
        self._add_switch_cell(
            'use_chunked_mode',
            self.plugin._t('chunk_mode'),
            self.plugin._t('chunk_mode_desc')
        )
        self._add_input_cell(
            'chunk_size',
            self.plugin._t('chunk_size'),
            str(DEFAULT_CHUNK_SIZE),
            InputType.TYPE_CLASS_NUMBER
        )
        
        self._add_header(self.plugin._t('progress_overlay_settings'))
        self._add_switch_cell(
            'enable_overlay_stroke',
            self.plugin._t('enable_overlay_stroke'),
            self.plugin._t('enable_overlay_stroke_desc')
        )
        self._add_switch_cell(
            'enable_stroke_animation',
            self.plugin._t('enable_stroke_animation'),
            self.plugin._t('enable_stroke_animation_desc')
        )
        self._add_input_cell(
            'overlay_opacity',
            self.plugin._t('overlay_opacity'),
            self.plugin._t('overlay_opacity_desc'),
            InputType.TYPE_CLASS_NUMBER
        )
        self._add_selector_cell(
            'overlay_position',
            self.plugin._t('overlay_position'),
            [
                self.plugin._t('position_top_center'),
                self.plugin._t('position_top_left'),
                self.plugin._t('position_top_right'),
                self.plugin._t('position_bottom_center'),
                self.plugin._t('position_bottom_left'),
                self.plugin._t('position_bottom_right')
            ]
        )
        
        self._update_media_cells_state()
    
    def _update_media_cells_state(self):
        export_format = self.temp_settings.get('export_format', 0)
        is_html = export_format == 0
        is_russian = self.plugin._is_russian()
        
        if not is_html:
            self.temp_settings['media_handling'] = 0
            self.temp_settings['include_avatars'] = False
        
        if self.media_handling_cell:
            self.media_handling_cell.setEnabled(is_html)
            self.media_handling_cell.setAlpha(1.0 if is_html else 0.5)
            
            if not is_html:
                options = ['Пропустить', 'Ссылки', 'Скачать'] if is_russian else ['Skip', 'References', 'Download']
                self.media_handling_cell.setTextAndValue(
                    self.plugin._t('media_handling'),
                    options[0],
                    True
                )
        
        if self.include_avatars_cell:
            self.include_avatars_cell.setEnabled(is_html)
            self.include_avatars_cell.setAlpha(1.0 if is_html else 0.5)
            
            if not is_html:
                try:
                    checkbox = self.include_avatars_cell.getCheckBox()
                    if checkbox:
                        checkbox.setChecked(False, True)
                except Exception as e:
                    self.include_avatars_cell.setTextAndCheck(
                        self.plugin._t('include_avatars'),
                        False,
                        True
                    )
    
    def _add_header(self, text):
        cell = HeaderCell(self.context)
        cell.setText(text)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _add_switch_cell(self, key, text, subtext):
        cell = TextCheckCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        value = self.temp_settings[key]
        if subtext:
            cell.setTextAndValueAndCheck(text, subtext, value, True, False)
        else:
            cell.setTextAndCheck(text, value, False)
        
        def on_click(*_):
            self.temp_settings[key] = not self.temp_settings[key]
            new_value = self.temp_settings[key]
            try:
                checkbox = cell.getCheckBox()
                if checkbox:
                    checkbox.setChecked(new_value, True)
            except Exception as e:
                if subtext:
                    cell.setTextAndValueAndCheck(text, subtext, new_value, True, True)
                else:
                    cell.setTextAndCheck(text, new_value, True)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
        
        return cell
    
    def _add_selector_cell(self, key, text, options):
        cell = TextSettingsCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        current_index = self.temp_settings[key]
        current_value = options[current_index] if 0 <= current_index < len(options) else options[0]
        cell.setTextAndValue(text, current_value, True)
        
        def on_click(*_):
            self._show_selector_dialog(key, text, options, cell)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
        
        return cell
    
    def _add_input_cell(self, key, text, hint, input_type):
        cell = TextSettingsCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        value = str(self.temp_settings[key])
        cell.setTextAndValue(text, value if value else hint, False)
        
        def on_click(*_):
            self._show_input_dialog(key, text, hint, input_type, cell)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _show_selector_dialog(self, key, text, options, cell):
        def on_item_selected(builder, which):
            self.temp_settings[key] = which
            new_value = options[which]
            cell.setTextAndValue(text, new_value, True)
            builder.dismiss()
            
            if key == 'export_format':
                self._update_media_cells_state()
        
        builder = AlertDialogBuilder(self.context)
        builder.set_title(text)
        builder.set_items(options, on_item_selected)
        builder.set_negative_button(self.plugin._t('cancel'), lambda b, w: b.dismiss())
        builder.show()
    
    def _show_input_dialog(self, key, text, hint, input_type, cell):
        current_value = str(self.temp_settings[key])
        
        edit_text = EditTextBoldCursor(self.context)
        edit_text.setText(current_value)
        edit_text.setInputType(input_type)
        edit_text.setHint(hint)
        try:
            edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextGray3))
            edit_text.setLineColors(
                Theme.getColor(Theme.key_dialogInputField),
                Theme.getColor(Theme.key_dialogInputFieldActivated),
                Theme.getColor(Theme.key_text_RedBold)
            )
            edit_text.setBackground(ColorDrawable(0))
            edit_text.setBackgroundTintList(ColorStateList.valueOf(Color.TRANSPARENT))
        except:
            pass
        edit_text.setSingleLine(True)
        
        padding_h = AndroidUtilities.dp(32)
        padding_v = AndroidUtilities.dp(16)
        edit_text.setPadding(padding_h, padding_v, padding_h, padding_v)
        
        def on_ok_click(builder, which):
            new_value = str(edit_text.getText())
            self.temp_settings[key] = new_value
            cell.setTextAndValue(text, new_value if new_value else hint, False)
            builder.dismiss()
        
        builder = AlertDialogBuilder(self.context)
        builder.set_title(text)
        builder.set_view(edit_text)
        builder.set_positive_button("OK", on_ok_click)
        builder.set_negative_button(self.plugin._t('cancel'), lambda b, w: b.dismiss())
        builder.show()
    
    def _create_button_container(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
        
        divider = View(self.context)
        divider.setBackgroundColor(Theme.getColor(Theme.key_divider))
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            1
        )
        container.addView(divider, divider_params)
        
        button_row = LinearLayout(self.context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)
        button_row.setPadding(
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12)
        )
        
        cancel_btn = self._create_text_button(self.plugin._t('cancel'), False)
        cancel_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))
        
        is_russian = self.plugin._is_russian()
        save_btn = self._create_text_button(
            'Сохр.' if is_russian else 'Save',
            False
        )
        save_btn.setOnClickListener(OnClickListener(lambda *args: self._on_save_default_click()))
        
        export_btn = self._create_text_button(
            'Экспорт' if is_russian else 'Export', 
            True
        )
        export_btn.setOnClickListener(OnClickListener(lambda *args: self._on_export_click()))
        
        button_params = LinearLayout.LayoutParams(
            0,
            LinearLayout.LayoutParams.WRAP_CONTENT,
            1.0
        )
        button_params.setMargins(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
        
        button_row.addView(cancel_btn, button_params)
        button_row.addView(save_btn, button_params)
        button_row.addView(export_btn, button_params)
        
        container.addView(button_row)
        
        return container
    
    def _create_text_button(self, text, is_primary):
        button = TextView(self.context)
        button.setText(text)
        button.setGravity(Gravity.CENTER)
        button.setSingleLine(True)
        button.setPadding(
            AndroidUtilities.dp(8),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(8),
            AndroidUtilities.dp(12)
        )
        
        background = GradientDrawable()
        background.setCornerRadius(AndroidUtilities.dp(8))
        
        if is_primary:
            button.setTextColor(Color.WHITE)
            bg_color = Theme.getColor(Theme.key_featuredStickers_addButton)
            background.setColor(bg_color)
            
            button.setShadowLayer(
                AndroidUtilities.dp(1),
                0,
                AndroidUtilities.dp(1),
                0x40000000
            )
        else:
            button.setTextColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            background.setColor(Color.TRANSPARENT)
            background.setStroke(AndroidUtilities.dp(2), Theme.getColor(Theme.key_featuredStickers_addButton))
        
        button.setBackground(background)
        button.setTextSize(1, 15 if is_primary else 14)
        button.setTypeface(None, Typeface.BOLD)
        
        button.setClickable(True)
        button.setFocusable(True)
        
        if is_primary:
            try:
                button.setElevation(AndroidUtilities.dp(2))
            except:
                pass
        
        return button
    
    def _on_export_click(self):
        try:
            self.dismiss()
            self.plugin._start_export_with_settings(self.dialog_id, self.temp_settings)
        except Exception as e:
            log(f"[ChatExport] Error in export click: {e}")
            import traceback
            log(traceback.format_exc())
    
    def _on_save_default_click(self):
        try:
            for key, value in self.temp_settings.items():
                self.plugin.set_setting(key, value)
            
            self.dismiss()
            self.plugin._start_export_with_settings(self.dialog_id, self.temp_settings)
            
            run_on_ui_thread(lambda: BulletinHelper.show_success(
                'Настройки сохранены' if self.plugin._is_russian() else 'Settings saved'
            ))
        except Exception as e:
            log(f"[ChatExport] Error in save default click: {e}")
            import traceback
            log(traceback.format_exc())


class FloatingProgressOverlay:
    
    def __init__(self, context, enable_stroke=True, enable_animation=True, opacity=1.0):
        self.context = context
        self.progress = 0.0
        self.progress_text = ""
        self.is_minimized = False
        self.stroke_animator = None
        self.current_stroke_color = int(Theme.getColor(Theme.key_featuredStickers_addButton))
        self.enable_stroke = enable_stroke
        self.enable_animation = enable_animation
        self.opacity = max(0.0, min(1.0, opacity))
        
        from android.util import DisplayMetrics
        display_metrics = DisplayMetrics()
        context.getWindowManager().getDefaultDisplay().getMetrics(display_metrics)
        self.screen_width = display_metrics.widthPixels
        
        self.container = FrameLayout(context)
        
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(28))
        bg.setColor(Theme.getColor(Theme.key_undo_background))
        if self.enable_stroke:
            bg.setStroke(
                AndroidUtilities.dp(2),
                Theme.getColor(Theme.key_featuredStickers_addButton)
            )
        self.container.setBackground(bg)
        
        self.container.setElevation(AndroidUtilities.dp(6))
        
        self.container.setAlpha(self.opacity)
        
        self.progress_view = self._create_progress_view()
        progress_params = FrameLayout.LayoutParams(
            AndroidUtilities.dp(40),
            AndroidUtilities.dp(40)
        )
        progress_params.gravity = Gravity.START | Gravity.CENTER_VERTICAL
        progress_params.leftMargin = AndroidUtilities.dp(8)
        self.container.addView(self.progress_view, progress_params)
        
        self.text_view = TextView(context)
        self.text_view.setTextColor(Theme.getColor(Theme.key_undo_infoColor))
        self.text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        self.text_view.setTypeface(Typeface.DEFAULT_BOLD)
        self.text_view.setSingleLine(True)
        self.text_view.setText("Экспорт...")
        from android.text import TextUtils
        self.text_view.setEllipsize(TextUtils.TruncateAt.END)
        max_text_width = self.screen_width - AndroidUtilities.dp(112)
        self.text_view.setMaxWidth(max_text_width)
        
        text_params = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
        text_params.gravity = Gravity.START | Gravity.CENTER_VERTICAL
        text_params.leftMargin = AndroidUtilities.dp(56)
        text_params.rightMargin = AndroidUtilities.dp(12)
        self.container.addView(self.text_view, text_params)
        
        self.container.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
        
    def _create_progress_view(self):
        from org.telegram.ui.Components import RadialProgressView
        
        progress_view = RadialProgressView(self.context)
        progress_view.setProgressColor(Theme.getColor(Theme.key_undo_infoColor))
        progress_view.setSize(AndroidUtilities.dp(32))
        
        progress_container = FrameLayout(self.context)
        progress_container.addView(progress_view, FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT,
            Gravity.CENTER
        ))
        
        return progress_container
    
    def set_progress(self, progress, text):
        self.progress = max(0.0, min(1.0, progress))
        self.progress_text = text
        self.text_view.setText(text)
        
        try:
            if self.progress_view and hasattr(self.progress_view, 'setProgress'):
                self.progress_view.setProgress(progress)
        except Exception as e:
            log(f"[ChatExport] Could not update progress view: {e}")
    
    def get_view(self):
        return self.container
    
    def toggle_minimize(self):
        self.is_minimized = not self.is_minimized
        
        if self.is_minimized:
            def hide_text():
                self.text_view.setVisibility(View.GONE)
            
            self.text_view.animate() \
                .alpha(0.0) \
                .setDuration(150) \
                .withEndAction(R(hide_text)) \
                .start()
            
            bg = GradientDrawable()
            bg.setShape(GradientDrawable.OVAL)
            bg.setColor(Theme.getColor(Theme.key_undo_background))
            if self.enable_stroke:
                bg.setStroke(
                    AndroidUtilities.dp(2),
                    Theme.getColor(Theme.key_featuredStickers_addButton)
                )
            
            try:
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    bg,
                    None
                )
                self.container.setBackground(ripple)
            except:
                self.container.setBackground(bg)
            
            params = self.container.getLayoutParams()
            if params:
                params.width = AndroidUtilities.dp(56)
                params.height = AndroidUtilities.dp(56)
                self.container.setLayoutParams(params)
                
            self.container.animate() \
                .scaleX(0.95) \
                .scaleY(0.95) \
                .setDuration(150) \
                .start()
            
            if self.enable_stroke and self.enable_animation:
                run_on_ui_thread(lambda: self._start_stroke_animation(), 160)
        else:
            self.text_view.setVisibility(View.VISIBLE)
            self.text_view.setAlpha(0.0)
            self.text_view.animate() \
                .alpha(1.0) \
                .setDuration(200) \
                .start()
            
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(28))
            bg.setColor(Theme.getColor(Theme.key_undo_background))
            if self.enable_stroke:
                bg.setStroke(
                    AndroidUtilities.dp(2),
                    Theme.getColor(Theme.key_featuredStickers_addButton)
                )
            
            try:
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    bg,
                    None
                )
                self.container.setBackground(ripple)
            except:
                self.container.setBackground(bg)
            
            params = self.container.getLayoutParams()
            if params:
                params.width = ViewGroup.LayoutParams.WRAP_CONTENT
                params.height = AndroidUtilities.dp(56)
                self.container.setLayoutParams(params)
                
            self.container.animate() \
                .scaleX(1.0) \
                .scaleY(1.0) \
                .setDuration(200) \
                .start()
            
            if self.enable_stroke and self.enable_animation:
                run_on_ui_thread(lambda: self._start_stroke_animation(), 210)
    
    def show_with_animation(self):
        self.container.setAlpha(0.0)
        self.container.setTranslationY(-AndroidUtilities.dp(20))
        
        self.container.animate() \
            .alpha(self.opacity) \
            .translationY(0) \
            .setDuration(300) \
            .setInterpolator(AndroidUtilities.decelerateInterpolator) \
            .start()
        
        if self.enable_stroke and self.enable_animation:
            self._start_stroke_animation()
    
    def _start_stroke_animation(self):
        try:
            from android.animation import ValueAnimator, ArgbEvaluator
            from android.view.animation import LinearInterpolator
            from java.lang import Integer
            
            color1 = Integer(int(Theme.getColor(Theme.key_featuredStickers_addButton)))
            color2 = Integer(int(Theme.getColor(Theme.key_chat_messagePanelSend)))
            color3 = Integer(int(Theme.getColor(Theme.key_avatar_nameInMessageBlue)))
            
            colors = [color1, color2, color3, color2, color1]
            
            if self.stroke_animator:
                self.stroke_animator.cancel()
            
            self.stroke_animator = ValueAnimator.ofObject(ArgbEvaluator(), colors)
            self.stroke_animator.setDuration(3000)
            self.stroke_animator.setRepeatCount(ValueAnimator.INFINITE)
            self.stroke_animator.setRepeatMode(ValueAnimator.RESTART)
            self.stroke_animator.setInterpolator(LinearInterpolator())
            
            overlay_ref = self
            
            def update_stroke_color():
                try:
                    if overlay_ref.stroke_animator:
                        animated_value = overlay_ref.stroke_animator.getAnimatedValue()
                        if animated_value:
                            color_int = int(animated_value.intValue()) if hasattr(animated_value, 'intValue') else int(animated_value)
                            overlay_ref.current_stroke_color = color_int
                            bg = overlay_ref.container.getBackground()
                            
                            if isinstance(bg, RippleDrawable):
                                drawable = bg.getDrawable(0)
                                if isinstance(drawable, GradientDrawable):
                                    drawable.setStroke(AndroidUtilities.dp(2), color_int)
                            elif isinstance(bg, GradientDrawable):
                                bg.setStroke(AndroidUtilities.dp(2), color_int)
                            
                            overlay_ref.container.invalidate()
                        
                        if overlay_ref.stroke_animator:
                            overlay_ref.container.postDelayed(R(update_stroke_color), 16)
                except Exception as e:
                    log(f"[ChatExport] Error updating stroke color: {e}")
            
            self.stroke_animator.start()
            self.container.postDelayed(R(update_stroke_color), 16)
            
        except Exception as e:
            log(f"[ChatExport] Error starting stroke animation: {e}")
    
    def _stop_stroke_animation(self):
        try:
            if self.stroke_animator:
                self.stroke_animator.cancel()
                self.stroke_animator = None
        except Exception as e:
            log(f"[ChatExport] Error stopping stroke animation: {e}")
    
    def setOnClickListener(self, listener):
        self.container.setOnClickListener(listener)
    
    def setOnLongClickListener(self, listener):
        self.container.setOnLongClickListener(listener)
    
    def setClickable(self, clickable):
        self.container.setClickable(clickable)
    
    def setFocusable(self, focusable):
        self.container.setFocusable(focusable)
    
    def setBackground(self, background):
        self.container.setBackground(background)
    
    def getBackground(self):
        return self.container.getBackground()


class ChatExportPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.menu_item_id = None
        self.export_in_progress = False
        self.cancel_requested = False
        self.progress_dialog = None
        self.progress_overlay = None
        self.progress_overlay_container = None
        self.selected_chats = []
        self.current_progress_text = ""
        self.current_progress_value = 0.0
        self.request_lock = threading.Lock()
        self.request_response = None
        self.request_error = None
        self.request_done = False
        
    def _t(self, key: str, **kwargs) -> str:
        lang = "ru" if self._is_russian() else "en"
        text = TRANSLATIONS.get(lang, {}).get(key, TRANSLATIONS["en"].get(key, key))
        if kwargs:
            text = text.format(**kwargs)
        return text
        
    def _is_russian(self) -> bool:
        try:
            locale_lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            return locale_lang and str(locale_lang).lower().startswith('ru')
        except:
            return False
        
    def on_plugin_load(self):
        try:
            self.menu_item_id = self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    item_id="export_chat_button",
                    text=self._t("export_chat"),
                    icon="msg_download",
                    on_click=self._handle_export_click
                )
            )
            log("[ChatExport] Plugin loaded successfully")
        except Exception as e:
            log(f"[ChatExport] Error loading plugin: {e}")
            
    def on_plugin_unload(self):
        if self.menu_item_id:
            self.remove_menu_item(self.menu_item_id)
        log("[ChatExport] Plugin unloaded")
    
    def on_app_event(self, event_type):
        try:
            from base_plugin import AppEvent
            
            if event_type == AppEvent.RESUME:
                if self.export_in_progress and not self.progress_overlay and not self.progress_dialog:
                    log("[ChatExport] App resumed during export, restoring progress dialog")
                    run_on_ui_thread(self._show_progress_dialog)
                    
        except Exception as e:
            log(f"[ChatExport] Error handling app event: {e}")
        
    def _handle_export_click(self, context):
        try:
            chat = context.get("chat")
            user = context.get("user")
            dialog_id = context.get("dialog_id")
            
            if not dialog_id:
                if chat:
                    dialog_id = -chat.id
                elif user:
                    dialog_id = user.id
                    
            if not dialog_id:
                BulletinHelper.show_error(self._t("cannot_determine_chat"))
                return
                
            log(f"[ChatExport] Export clicked for dialog_id: {dialog_id}")
            
            run_on_ui_thread(lambda: self._show_export_settings_dialog(dialog_id))
            
        except Exception as e:
            log(f"[ChatExport] Error in export click handler: {e}")
            BulletinHelper.show_error(f"{self._t('export_failed')}: {str(e)}")
    
    def _show_export_settings_dialog(self, dialog_id):
        try:
            fragment = get_last_fragment()
            if not fragment:
                log("[ChatExport] Cannot get fragment for settings dialog")
                return
            
            context = fragment.getParentActivity()
            if not context:
                log("[ChatExport] Cannot get activity for settings dialog")
                return
            
            settings_sheet = ExportSettingsBottomSheet(context, self, dialog_id)
            settings_sheet.show()
            
        except Exception as e:
            log(f"[ChatExport] Error showing settings dialog: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"Error: {str(e)}")
    
    def _start_export_with_settings(self, dialog_id, temp_settings):
        try:
            self.temp_export_settings = temp_settings
            self.selected_chats = [dialog_id]
            self._start_export()
        except Exception as e:
            log(f"[ChatExport] Error starting export with settings: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"{self._t('export_failed')}: {str(e)}")
            
    def _get_export_setting(self, key, default=None):
        if hasattr(self, 'temp_export_settings') and self.temp_export_settings:
            return self.temp_export_settings.get(key, default)
        return self.get_setting(key, default)
    
    def _start_export(self):
        if self.export_in_progress:
            BulletinHelper.show_error(self._t("export_in_progress"))
            return
            
        self.export_in_progress = True
        self.cancel_requested = False
        
        run_on_ui_thread(self._show_progress_dialog)
        
        threading.Thread(
            target=self._export_chats_background,
            daemon=True
        ).start()
        
    def _show_progress_dialog(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
                
            context = fragment.getParentActivity()
            if not context:
                return
            
            self.progress_dialog = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_LOADING)
            self.progress_dialog.set_title(self._t("exporting"))
            self.progress_dialog.set_neutral_button(
                self._t("run_in_background"),
                lambda b, w: self._run_export_in_background()
            )
            self.progress_dialog.set_negative_button(
                self._t("cancel"),
                lambda b, w: self._cancel_export()
            )
            self.progress_dialog.show()
            self.progress_dialog.set_cancelable(False)
            
            if self.current_progress_text or self.current_progress_value > 0:
                progress_percent = int(self.current_progress_value * 100)
                self.progress_dialog.set_title(self.current_progress_text)
                self.progress_dialog.set_progress(progress_percent)
                log(f"[ChatExport] Progress dialog restored: {self.current_progress_text} ({progress_percent}%)")
            
        except Exception as e:
            log(f"[ChatExport] Error showing progress dialog: {e}")
            
    def _cancel_export(self):
        self.cancel_requested = True
        self._dismiss_progress_dialog()
        self._dismiss_progress_overlay()
        
    def _run_export_in_background(self):
        try:
            self._dismiss_progress_dialog()
            run_on_ui_thread(self._create_progress_overlay)
        except Exception as e:
            log(f"[ChatExport] Error moving to background: {e}")

    def _create_progress_overlay(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                log("[ChatExport] Cannot get fragment for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            context = fragment.getParentActivity()
            if not context:
                log("[ChatExport] Cannot get context for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            content_view_id = 0x01020002
            root_view = context.getWindow().getDecorView()
            container = root_view.findViewById(content_view_id)
            
            if not container:
                container = root_view
            
            if not container:
                log("[ChatExport] Cannot get root container for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            if self.progress_overlay_container:
                try:
                    container.removeView(self.progress_overlay_container)
                except:
                    pass
            
            self.progress_overlay_container = FrameLayout(context)
            self.progress_overlay_container.setClickable(False)
            self.progress_overlay_container.setFocusable(False)
            
            enable_stroke = self._get_export_setting('enable_overlay_stroke', True)
            enable_animation = self._get_export_setting('enable_stroke_animation', True)
            try:
                overlay_opacity_percent = int(self._get_export_setting('overlay_opacity', '100'))
            except (ValueError, TypeError):
                overlay_opacity_percent = 100
            overlay_opacity = max(0.0, min(1.0, overlay_opacity_percent / 100.0))
            self.progress_overlay = FloatingProgressOverlay(context, enable_stroke, enable_animation, overlay_opacity)
            
            progress_text = self.current_progress_text or self._t("exporting")
            if self.current_progress_value > 0:
                progress_percent = int(self.current_progress_value * 100)
                progress_text = f"{progress_text} {progress_percent}%"
            
            self.progress_overlay.set_progress(self.current_progress_value, progress_text)
            
            self.progress_overlay.setOnClickListener(OnClickListener(self._on_progress_overlay_click))
            self.progress_overlay.setOnLongClickListener(OnLongClickListener(self._on_progress_overlay_long_click))
            self.progress_overlay.setClickable(True)
            self.progress_overlay.setFocusable(True)
            
            try:
                self.progress_overlay.original_background = self.progress_overlay.getBackground()
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    self.progress_overlay.getBackground(),
                    None
                )
                self.progress_overlay.setBackground(ripple)
                self.progress_overlay.ripple_drawable = ripple
            except Exception as e:
                log(f"[ChatExport] Could not add ripple effect: {e}")
            
            overlay_params = FrameLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                AndroidUtilities.dp(56)
            )
            
            overlay_position = self._get_export_setting('overlay_position', 0)
            
            if overlay_position == 0:
                overlay_params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
                overlay_params.topMargin = AndroidUtilities.dp(80)
                overlay_params.leftMargin = AndroidUtilities.dp(16)
                overlay_params.rightMargin = AndroidUtilities.dp(16)
            elif overlay_position == 1:
                overlay_params.gravity = Gravity.TOP | Gravity.LEFT
                overlay_params.topMargin = AndroidUtilities.dp(80)
                overlay_params.leftMargin = AndroidUtilities.dp(16)
            elif overlay_position == 2:
                overlay_params.gravity = Gravity.TOP | Gravity.RIGHT
                overlay_params.topMargin = AndroidUtilities.dp(80)
                overlay_params.rightMargin = AndroidUtilities.dp(16)
            elif overlay_position == 3:
                overlay_params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL
                overlay_params.bottomMargin = AndroidUtilities.dp(80)
                overlay_params.leftMargin = AndroidUtilities.dp(16)
                overlay_params.rightMargin = AndroidUtilities.dp(16)
            elif overlay_position == 4:
                overlay_params.gravity = Gravity.BOTTOM | Gravity.LEFT
                overlay_params.bottomMargin = AndroidUtilities.dp(80)
                overlay_params.leftMargin = AndroidUtilities.dp(16)
            elif overlay_position == 5:
                overlay_params.gravity = Gravity.BOTTOM | Gravity.RIGHT
                overlay_params.bottomMargin = AndroidUtilities.dp(80)
                overlay_params.rightMargin = AndroidUtilities.dp(16)
            else:
                overlay_params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
                overlay_params.topMargin = AndroidUtilities.dp(80)
                overlay_params.leftMargin = AndroidUtilities.dp(16)
                overlay_params.rightMargin = AndroidUtilities.dp(16)
            
            overlay_view = self.progress_overlay.get_view()
            self.progress_overlay_container.addView(overlay_view, overlay_params)
            
            container_params = FrameLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT
            )
            container.addView(self.progress_overlay_container, container_params)
            
            self.progress_overlay.show_with_animation()
            
            log("[ChatExport] Floating progress overlay created and shown")
            
        except Exception as e:
            log(f"[ChatExport] Error creating progress overlay: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_info(self._t("background_export"))
    
    def _on_progress_overlay_click(self, view=None):
        try:
            log("[ChatExport] Progress overlay clicked - toggling minimize")
            if self.progress_overlay:
                self.progress_overlay.toggle_minimize()
        except Exception as e:
            log(f"[ChatExport] Error handling overlay click: {e}")
    
    def _on_progress_overlay_long_click(self, view=None):
        try:
            log("[ChatExport] Progress overlay long clicked - reopening dialog")
            self._dismiss_progress_overlay()
            run_on_ui_thread(self._show_progress_dialog)
            return True
        except Exception as e:
            log(f"[ChatExport] Error handling overlay long click: {e}")
            import traceback
            log(traceback.format_exc())
            return False
    
    def _dismiss_progress_overlay(self):
        def dismiss():
            try:
                if self.progress_overlay:
                    self.progress_overlay._stop_stroke_animation()
                
                if self.progress_overlay_container:
                    parent = self.progress_overlay_container.getParent()
                    if parent:
                        parent.removeView(self.progress_overlay_container)
                    else:
                        fragment = get_last_fragment()
                        if fragment:
                            context = fragment.getParentActivity()
                            if context:
                                content_view_id = 0x01020002
                                root_view = context.getWindow().getDecorView()
                                container = root_view.findViewById(content_view_id)
                                if not container:
                                    container = root_view
                                if container:
                                    container.removeView(self.progress_overlay_container)
                    
                    self.progress_overlay_container = None
                    self.progress_overlay = None
            except Exception as e:
                log(f"[ChatExport] Error dismissing progress overlay: {e}")
        run_on_ui_thread(dismiss)
    
    def _dismiss_progress_dialog(self):
        def dismiss():
            try:
                if self.progress_dialog:
                    self.progress_dialog.dismiss()
                    self.progress_dialog = None
            except:
                pass
        run_on_ui_thread(dismiss)
        
    def _export_chats_background(self):
        try:
            for dialog_id in self.selected_chats:
                if self.cancel_requested:
                    break
                    
                self._export_single_chat(dialog_id)
                
            if not self.cancel_requested:
                self._dismiss_progress_overlay()
                run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("export_complete")))
        except Exception as e:
            log(f"[ChatExport] Export error: {e}")
            error_msg = f"{self._t('export_failed')}: {str(e)}"
            self._dismiss_progress_overlay()
            run_on_ui_thread(lambda msg=error_msg: BulletinHelper.show_error(msg))
        finally:
            self.export_in_progress = False
            self._dismiss_progress_dialog()
            self._dismiss_progress_overlay()
            if hasattr(self, 'temp_export_settings'):
                delattr(self, 'temp_export_settings')
            
    def _load_messages_chunked_generator(self, dialog_id: int, chunk_size: int, max_messages: Optional[int] = None):
        messages_loaded = 0
        offset_id = 0
        use_api = self._get_export_setting("use_api_mode", True)
        
        log(f"[ChatExport] Starting chunked message loading (chunk_size={chunk_size}, max_messages={max_messages})")
        
        if use_api:
            mc = get_messages_controller()
            input_peer = mc.getInputPeer(dialog_id)
            
            if not input_peer:
                log(f"[ChatExport] Cannot get input peer for dialog {dialog_id}")
                return
            
            chunk_number = 0
            reached_end = False
            
            while not reached_end:
                if self.cancel_requested:
                    log("[ChatExport] Chunked loading cancelled by user")
                    break
                
                if max_messages and messages_loaded >= max_messages:
                    log(f"[ChatExport] Reached max messages limit: {max_messages}")
                    break
                
                chunk_number += 1
                
                limit_for_this_chunk = chunk_size
                if max_messages:
                    limit_for_this_chunk = min(chunk_size, max_messages - messages_loaded)
                
                if chunk_number == 1 or chunk_number % 5 == 0:
                    log(f"[ChatExport] Starting chunk #{chunk_number}, target: {limit_for_this_chunk} messages")
                
                chunk = []
                batch_size = API_BATCH_SIZE
                
                while len(chunk) < limit_for_this_chunk and not reached_end:
                    if self.cancel_requested:
                        break
                    
                    messages_to_fetch = batch_size
                    
                    req = TLRPC.TL_messages_getHistory()
                    req.peer = input_peer
                    req.offset_id = offset_id
                    req.limit = messages_to_fetch
                    req.add_offset = 0
                    req.offset_date = 0
                    req.hash = 0
                    
                    response = self._send_request_sync(req)
                    
                    if not response or not isinstance(response, TLRPC.messages_Messages):
                        log("[ChatExport] No response from API - reached end of chat")
                        reached_end = True
                        break
                    
                    if hasattr(response, 'users') and response.users:
                        mc.putUsers(response.users, False)
                    if hasattr(response, 'chats') and response.chats:
                        mc.putChats(response.chats, False)
                    
                    batch = response.messages
                    batch_size_count = batch.size() if hasattr(batch, 'size') else len(batch)
                    
                    if batch_size_count == 0:
                        log("[ChatExport] Empty batch received - reached end of chat")
                        reached_end = True
                        break
                    
                    for i in range(batch_size_count):
                        msg = batch.get(i) if hasattr(batch, 'get') else batch[i]
                        try:
                            msg_dict = self._tlrpc_message_to_dict(msg)
                            chunk.append(msg_dict)
                        except Exception as e:
                            log(f"[ChatExport] Error converting message: {e}")
                    
                    last_msg = batch.get(batch_size_count - 1) if hasattr(batch, 'get') else batch[batch_size_count - 1]
                    offset_id = last_msg.id
                    
                    sleep_time = 0.1 if messages_loaded > 3000 else 0.15
                    time.sleep(sleep_time)
                
                if chunk:
                    chunk.reverse()
                    messages_loaded += len(chunk)
                    
                    if chunk_number == 1 or chunk_number % 5 == 0 or reached_end:
                        log(f"[ChatExport] Chunk #{chunk_number}: {len(chunk)} messages (total: {messages_loaded})")
                    
                    yield chunk
                else:
                    log(f"[ChatExport] No messages in chunk #{chunk_number} - stopping")
                    break
        else:
            try:
                storage = get_messages_storage()
                database = get_private_field(storage, "database")
                
                if not database:
                    log("[ChatExport] Cannot access database")
                    return
                
                limit = max_messages if max_messages else 100000
                query = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {dialog_id} ORDER BY date ASC LIMIT {limit}"
                
                log(f"[ChatExport] Querying database for dialog_id={dialog_id}, limit={limit}")
                cursor = database.queryFinalized(query)
                
                chunk = []
                while cursor.next():
                    if self.cancel_requested:
                        break
                    
                    try:
                        data = cursor.byteBufferValue(0)
                        if data:
                            msg = TLRPC.Message.TLdeserialize(data, data.readInt32(False), False)
                            if msg:
                                msg.id = cursor.intValue(1)
                                msg.date = cursor.intValue(2)
                                msg.dialog_id = cursor.longValue(3)
                                
                                msg_dict = self._tlrpc_message_to_dict(msg)
                                chunk.append(msg_dict)
                                messages_loaded += 1
                            
                            data.reuse()
                        
                        if len(chunk) >= chunk_size:
                            log(f"[ChatExport] Yielding chunk with {len(chunk)} messages (total: {messages_loaded})")
                            yield chunk
                            chunk = []
                    
                    except Exception as e:
                        log(f"[ChatExport] Error deserializing message: {e}")
                        continue
                
                cursor.dispose()
                
                if chunk:
                    log(f"[ChatExport] Yielding final chunk with {len(chunk)} messages")
                    yield chunk
                    
            except Exception as e:
                log(f"[ChatExport] Database error in chunked loading: {e}")
                import traceback
                log(traceback.format_exc())
    
    def _export_single_chat(self, dialog_id: int):
        try:
            chat_name = self._get_chat_name(dialog_id)
            log(f"[ChatExport] Exporting chat: {chat_name} ({dialog_id})")
            
            use_chunked_mode = self._get_export_setting("use_chunked_mode", False)
            chunk_size_str = self._get_export_setting("chunk_size", str(DEFAULT_CHUNK_SIZE))
            try:
                chunk_size = int(chunk_size_str) if chunk_size_str else DEFAULT_CHUNK_SIZE
            except:
                chunk_size = DEFAULT_CHUNK_SIZE
            
            if use_chunked_mode:
                log(f"[ChatExport] Using OPTIMIZED CHUNKED MODE (chunk_size={chunk_size})")
                self._export_single_chat_chunked(dialog_id, chunk_size)
            else:
                log("[ChatExport] Using STANDARD MODE (loads all messages)")
                self._export_single_chat_standard(dialog_id)
                
        except Exception as e:
            log(f"[ChatExport] Error exporting chat {dialog_id}: {e}")
            raise
    
    def _export_single_chat_standard(self, dialog_id: int):
        try:
            chat_name = self._get_chat_name(dialog_id)
            log(f"[ChatExport] Standard export for: {chat_name} ({dialog_id})")
            
            self._update_progress(self._t("loading_messages", chat=chat_name), 10)
            
            messages = self._load_chat_messages(dialog_id)
            
            if self.cancel_requested:
                return
                
            log(f"[ChatExport] Loaded {len(messages)} messages")
            
            self._update_progress(self._t("generating_export", chat=chat_name), 50)
            
            export_format = self._get_export_setting("export_format", 0)
            
            if export_format == 0:
                content = self._generate_html(dialog_id, chat_name, messages)
                extension = "html"
                mime_type = "text/html"
            elif export_format == 1:
                content = self._generate_json(dialog_id, chat_name, messages)
                extension = "json"
                mime_type = "application/json"
            else:
                content = self._generate_txt(dialog_id, chat_name, messages)
                extension = "txt"
                mime_type = "text/plain"
                
            file_path = self._save_export_file(chat_name, content, extension)
            
            if self.cancel_requested:
                return
                
            self._update_progress(self._t("preparing_share"), 95)
            run_on_ui_thread(lambda: self._share_export_file(file_path, mime_type))
            
        except Exception as e:
            log(f"[ChatExport] Error exporting chat {dialog_id}: {e}")
            raise
    
    def _get_total_message_count(self, dialog_id: int) -> Optional[int]:
        try:
            use_api = self._get_export_setting("use_api_mode", True)
            
            if use_api:
                mc = get_messages_controller()
                input_peer = mc.getInputPeer(dialog_id)
                
                if not input_peer:
                    log(f"[ChatExport] Cannot get input peer for dialog {dialog_id}")
                    return None
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = input_peer
                req.offset_id = 0
                req.limit = 1
                req.add_offset = 0
                req.offset_date = 0
                req.hash = 0
                
                response = self._send_request_sync(req)
                
                if response and hasattr(response, 'count'):
                    log(f"[ChatExport] Total message count from API: {response.count}")
                    return response.count
            else:
                storage = get_messages_storage()
                db = storage.getDatabase()
                cursor = db.queryFinalized(
                    f"SELECT COUNT(*) FROM messages_v2 WHERE uid = {dialog_id}"
                )
                if cursor and cursor.next():
                    count = cursor.intValue(0)
                    cursor.dispose()
                    log(f"[ChatExport] Total message count from DB: {count}")
                    return count
                if cursor:
                    cursor.dispose()
        except Exception as e:
            log(f"[ChatExport] Error getting message count: {e}")
        
        return None
    
    def _export_single_chat_chunked(self, dialog_id: int, chunk_size: int):
        try:
            chat_name = self._get_chat_name(dialog_id)
            log(f"[ChatExport] Chunked export for: {chat_name} ({dialog_id})")
            
            self._update_progress(self._t("loading_messages", chat=chat_name), 5)
            
            max_messages_str = self._get_export_setting("max_messages", "")
            max_messages = int(max_messages_str) if max_messages_str.strip() else None
            
            total_count = self._get_total_message_count(dialog_id)
            
            display_count = total_count
            if display_count is not None and max_messages is not None:
                display_count = min(display_count, max_messages)
            elif max_messages is not None:
                display_count = max_messages
            
            export_format = self._get_export_setting("export_format", 0)
            
            base_dir = ApplicationLoader.getFilesDirFixed()
            export_dir = File(base_dir, "ChatExports")
            if not export_dir.exists():
                export_dir.mkdirs()
            
            timestamp = int(time.time())
            safe_name = "".join(c for c in chat_name if c.isalnum() or c in (' ', '-', '_'))[:50]
            
            if export_format == 0:
                extension = "html"
                mime_type = "text/html"
            elif export_format == 1:
                extension = "json"
                mime_type = "application/json"
            else:
                extension = "txt"
                mime_type = "text/plain"
            
            filename = f"chat_export_{safe_name}_{timestamp}.{extension}"
            file_path = File(export_dir, filename).getAbsolutePath()
            
            log(f"[ChatExport] Writing chunked export to: {file_path}")
            
            with open(file_path, 'w', encoding='utf-8') as file:
                chunk_count = 0
                total_messages = 0
                
                if export_format == 0:
                    self._write_html_header(file, chat_name, display_count)
                elif export_format == 1:
                    self._write_json_header(file, chat_name, dialog_id)
                else:
                    self._write_txt_header(file, chat_name)
                
                log(f"[ChatExport] ===== STARTING CHUNKED EXPORT =====")
                log(f"[ChatExport] Will load ALL messages in chunks of {chunk_size}")
                
                for chunk in self._load_messages_chunked_generator(dialog_id, chunk_size, max_messages):
                    if self.cancel_requested:
                        log("[ChatExport] Chunked export cancelled by user")
                        break
                    
                    chunk_count += 1
                    chunk_size_actual = len(chunk)
                    total_messages += chunk_size_actual
                    
                    log(f"[ChatExport] ===== CHUNK #{chunk_count} =====")
                    log(f"[ChatExport] - Loaded: {chunk_size_actual} messages")
                    log(f"[ChatExport] - Total so far: {total_messages} messages")
                    
                    if export_format == 0:
                        log(f"[ChatExport] - Processing media for chunk #{chunk_count}...")
                        self._process_chunk_media(chunk)
                    
                    log(f"[ChatExport] - Writing chunk to file...")
                    
                    progress_percent = min(10 + int((total_messages / (max_messages or 50000)) * 80), 90)
                    self._update_progress(
                        self._t("chunk_progress", chunk=chunk_count, total=total_messages),
                        progress_percent
                    )
                    
                    if export_format == 0:
                        self._write_html_chunk(file, chunk, dialog_id, total_messages - chunk_size_actual)
                    elif export_format == 1:
                        self._write_json_chunk(file, chunk, chunk_count > 1)
                    else:
                        self._write_txt_chunk(file, chunk)
                    
                    log(f"[ChatExport] - Chunk #{chunk_count} written successfully")
                    log(f"[ChatExport] - Clearing chunk from memory...")
                    
                    chunk.clear()
                    
                    log(f"[ChatExport] - Memory cleared, ready for next chunk")
                
                log(f"[ChatExport] ===== EXPORT COMPLETE =====")
                log(f"[ChatExport] Total chunks processed: {chunk_count}")
                log(f"[ChatExport] Total messages exported: {total_messages}")
                
                if export_format == 0:
                    self._write_html_footer(file)
                elif export_format == 1:
                    self._write_json_footer(file, total_messages)
                else:
                    self._write_txt_footer(file)
            
            log(f"[ChatExport] Chunked export complete: {total_messages} messages written to {file_path}")
            
            if self.cancel_requested:
                return
            
            self._update_progress(self._t("preparing_share"), 95)
            run_on_ui_thread(lambda: self._share_export_file(file_path, mime_type))
            
        except Exception as e:
            log(f"[ChatExport] Error in chunked export: {e}")
            import traceback
            log(traceback.format_exc())
            raise
    
    def _process_chunk_media(self, chunk: List[Dict[str, Any]]):
        try:
            current_account = UserConfig.selectedAccount
            
            media_handling = self._get_export_setting("media_handling", 0)
            want_media = (media_handling == 2)
            want_avatars = self._get_export_setting("include_avatars", True)
            
            max_media_mb_str = self._get_export_setting("max_size_mb", "100")
            try:
                max_media_mb = int(max_media_mb_str) if max_media_mb_str else 10
            except:
                max_media_mb = 10
            
            if not want_media and not want_avatars:
                log(f"[ChatExport] Skipping media processing (media={want_media}, avatars={want_avatars})")
                return
            
            all_user_ids = set()
            for msg in chunk:
                from_id = msg.get("from_id", 0)
                if from_id > 0:
                    all_user_ids.add(from_id)
                if "fwd_from_id" in msg:
                    fwd_id = msg.get("fwd_from_id", 0)
                    if fwd_id > 0:
                        all_user_ids.add(fwd_id)
            
            if all_user_ids:
                self._load_missing_users(all_user_ids)
            
            media_manager = MediaDownloadManager(
                account_id=current_account,
                max_workers=6,
                max_media_mb=max_media_mb
            )
            
            log(f"[ChatExport] Preparing media download: media={want_media}, avatars={want_avatars}, max_mb={max_media_mb}")
            
            user_ids_seen = set()
            
            media_count = 0
            for msg in chunk:
                from_id = msg.get("from_id", 0)
                
                if want_avatars and from_id and from_id not in user_ids_seen:
                    user_ids_seen.add(from_id)
                    sender_user = self._get_user_object(from_id)
                    if sender_user:
                        media_manager.add_avatar_download(from_id, sender_user)
                
                if want_media and msg.get("media"):
                    media_type = _get_media_type_from_message(msg)
                    tlrpc_msg = self._reconstruct_tlrpc_message(msg)
                    if tlrpc_msg:
                        media_manager.add_media_download(msg.get("id", 0), tlrpc_msg, media_type)
                        media_count += 1
                    else:
                        log(f"[ChatExport] WARNING: Failed to reconstruct TLRPC for msg {msg.get('id', 0)}, has media: {msg.get('media', {}).get('type', 'N/A')}, has _tlrpc_obj: {'_tlrpc_obj' in msg}, has _media_obj: {'_media_obj' in msg.get('media', {})}")
            
            log(f"[ChatExport] Media tasks queued: {media_count}, Avatar users: {len(user_ids_seen)}")
            
            log(f"[ChatExport] Starting parallel download of {len(user_ids_seen)} avatars and {media_count} media files...")
            download_start = time.time()
            media_manager.execute_downloads()
            download_time = time.time() - download_start
            log(f"[ChatExport] Download completed in {download_time:.2f}s")
            
            log(f"[ChatExport] Attaching media data to {len(chunk)} messages...")
            attach_start = time.time()
            
            for msg in chunk:
                msg_id = msg.get("id", 0)
                
                if want_avatars:
                    from_id = msg.get("from_id", 0)
                    if from_id:
                        avatar_data = media_manager.get_result(f"avatar_{from_id}")
                        if avatar_data:
                            msg["_avatar_data_uri"] = avatar_data
                
                if want_media and msg.get("media"):
                    media_data = media_manager.get_result(f"media_{msg_id}")
                    if media_data:
                        msg["_media_data_uri"] = media_data
            
            attach_time = time.time() - attach_start
            log(f"[ChatExport] Media data attached in {attach_time:.2f}s")
            
        except Exception as e:
            log(f"[ChatExport] Error processing chunk media: {e}")
            import traceback
            log(traceback.format_exc())
            
    def _get_chat_name(self, dialog_id: int) -> str:
        try:
            mc = get_messages_controller()

            if dialog_id > 0:
                log(f"[ChatExport] Getting name for private chat (user_id={dialog_id})")
                user = mc.getUser(dialog_id)
                if user:
                    name = user.first_name or ""
                    if user.last_name:
                        name += " " + user.last_name
                    name = name.strip()

                    if not name and hasattr(user, 'username') and user.username:
                        name = f"@{user.username}"

                    if not name:
                        if hasattr(user, 'deleted') and user.deleted:
                            return "Deleted Account"
                        return f"User_{dialog_id}"

                    log(f"[ChatExport] Private chat name: {name}")
                    return name
            else:
                log(f"[ChatExport] Getting name for group/channel (chat_id={-dialog_id})")
                chat = mc.getChat(-dialog_id)
                if chat:
                    title = getattr(chat, 'title', None)
                    if title:
                        title = title.strip()
                    
                    username = getattr(chat, 'username', None)
                    
                    is_broadcast = getattr(chat, 'broadcast', False)
                    is_megagroup = getattr(chat, 'megagroup', False)
                    
                    log(f"[ChatExport] Getting name for dialog {-dialog_id}: title='{title}', username='{username}', broadcast={is_broadcast}, megagroup={is_megagroup}")
                    
                    if title and username:
                        return f"{title} (@{username})"
                    elif title:
                        return title
                    elif username:
                        return f"@{username}"
                    if is_broadcast:
                        return f"Channel_{-dialog_id}"
                    elif is_megagroup:
                        return f"Supergroup_{-dialog_id}"
                    else:
                        return f"Group_{-dialog_id}"

            return f"Chat_{dialog_id}"
        except Exception as e:
            log(f"[ChatExport] Error getting chat name: {e}")
            return f"Chat_{dialog_id}"
            
    def _send_request_sync(self, request):
        with self.request_lock:
            self.request_response = None
            self.request_error = None
            self.request_done = False
        
        def callback(response, error):
            with self.request_lock:
                self.request_response = response
                self.request_error = error
                self.request_done = True
        
        try:
            send_request(request, callback)
            
            timeout = 30
            start_time = time.time()
            
            while True:
                with self.request_lock:
                    if self.request_done:
                        return self.request_response
                
                if time.time() - start_time > timeout:
                    log("[ChatExport] Request timeout")
                    return None
                    
                if self.cancel_requested:
                    log("[ChatExport] Request cancelled by user")
                    return None
                
                time.sleep(0.1)
                
        except Exception as e:
            log(f"[ChatExport] Error sending request: {e}")
            return None
    
    def _load_messages_from_api(self, dialog_id: int, max_messages: Optional[int] = None) -> List[Dict[str, Any]]:
        messages = []
        offset_id = 0
        batch_size = API_BATCH_SIZE
        total_count = None
        
        try:
            mc = get_messages_controller()
            input_peer = mc.getInputPeer(dialog_id)
            
            if not input_peer:
                log(f"[ChatExport] Cannot get input peer for dialog {dialog_id}")
                return []
            
            log(f"[ChatExport] Starting API fetch for dialog {dialog_id} (batch_size={batch_size})")
            
            batch_count = 0
            while True:
                if self.cancel_requested:
                    log("[ChatExport] API fetch cancelled by user")
                    break
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = input_peer
                req.offset_id = offset_id
                req.limit = batch_size
                req.add_offset = 0
                req.offset_date = 0
                req.hash = 0
                
                response = self._send_request_sync(req)
                
                if not response:
                    log("[ChatExport] No response from API")
                    break
                
                if not isinstance(response, TLRPC.messages_Messages):
                    log(f"[ChatExport] Unexpected response type: {type(response)}")
                    break
                
                if batch_count == 0 and hasattr(response, 'count'):
                    total_count = response.count
                    log(f"[ChatExport] Total messages in chat: {total_count}")

                if hasattr(response, 'users') and response.users:
                    mc.putUsers(response.users, False)
                    log(f"[ChatExport] Cached {response.users.size()} users from API response")

                if hasattr(response, 'chats') and response.chats:
                    mc.putChats(response.chats, False)
                    log(f"[ChatExport] Cached {response.chats.size()} chats from API response")

                batch = response.messages
                batch_count += 1
                
                if hasattr(batch, 'size'):
                    batch_size_count = batch.size()
                    batch_list = [batch.get(i) for i in range(batch_size_count)]
                else:
                    batch_size_count = len(batch)
                    batch_list = list(batch)
                
                log(f"[ChatExport] Batch {batch_count}: received {batch_size_count} messages")
                
                if not batch or batch_size_count == 0:
                    log("[ChatExport] No more messages, reached beginning of chat")
                    break
                
                for msg in batch_list:
                    try:
                        msg_dict = self._tlrpc_message_to_dict(msg)
                        messages.append(msg_dict)
                    except Exception as e:
                        log(f"[ChatExport] Error converting message: {e}")
                
                offset_id = batch_list[-1].id
                
                current_count = len(messages)
                
                if total_count and total_count > 0:
                    target = min(total_count, max_messages) if max_messages else total_count
                    progress_percent = min(int((current_count / target) * 100), 100)
                    progress_text = self._t("loaded_messages_progress", current=current_count, target=target)
                elif max_messages:
                    progress_percent = min(int((current_count / max_messages) * 100), 100)
                    progress_text = self._t("loaded_messages_progress", current=current_count, target=max_messages)
                else:
                    progress_percent = min(int((current_count / 10000) * 100), 99)
                    progress_text = self._t("loaded_messages_no_target", current=current_count)
                
                self._update_progress(progress_text, progress_percent)
                log(f"[ChatExport] {progress_text} ({progress_percent}%)")
                
                if max_messages and len(messages) >= max_messages:
                    log(f"[ChatExport] Reached max messages limit: {max_messages}")
                    messages = messages[:max_messages]
                    break
                
                sleep_time = 0.1 if current_count > 3000 else 0.15
                time.sleep(sleep_time)
            
            messages.reverse()
            
            log(f"[ChatExport] API fetch complete: {len(messages)} messages loaded")
            return messages
            
        except Exception as e:
            log(f"[ChatExport] Error in API fetch: {e}")
            import traceback
            log(traceback.format_exc())
            return []
            
    def _load_chat_messages(self, dialog_id: int) -> List[Dict[str, Any]]:
        
        use_api = self._get_export_setting("use_api_mode", True)
        
        max_messages_str = self._get_export_setting("max_messages", "")
        max_messages = int(max_messages_str) if max_messages_str.strip() else None
        
        if use_api:
            log(f"[ChatExport] Using API mode to fetch messages")
            messages = self._load_messages_from_api(dialog_id, max_messages)
            
            if not messages and not self.cancel_requested:
                log("[ChatExport] API fetch failed, falling back to database")
                return self._load_messages_from_database(dialog_id, max_messages)
            
            return messages if messages else self._create_demo_messages(dialog_id)
        else:
            log(f"[ChatExport] Using database mode to fetch messages")
            return self._load_messages_from_database(dialog_id, max_messages)
    
    def _load_messages_from_database(self, dialog_id: int, max_messages: Optional[int] = None) -> List[Dict[str, Any]]:
        messages = []
        
        try:
            storage = get_messages_storage()
            
            database = get_private_field(storage, "database")
            
            if not database:
                log("[ChatExport] Cannot access database")
                return self._create_demo_messages(dialog_id)
            
            limit = max_messages if max_messages else 10000
            
            query = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {dialog_id} ORDER BY date DESC LIMIT {limit}"
            
            log(f"[ChatExport] Querying database for dialog_id={dialog_id}, limit={limit}")
            
            cursor = database.queryFinalized(query)
            
            loaded_count = 0
            progress_update_interval = 500 if limit > 3000 else 100
            
            while cursor.next():
                if self.cancel_requested:
                    log("[ChatExport] Database fetch cancelled by user")
                    break
                    
                try:
                    data = cursor.byteBufferValue(0)
                    if data:
                        msg = TLRPC.Message.TLdeserialize(data, data.readInt32(False), False)
                        if msg:
                            msg.id = cursor.intValue(1)
                            msg.date = cursor.intValue(2)
                            msg.dialog_id = cursor.longValue(3)
                            
                            messages.append(self._tlrpc_message_to_dict(msg))
                            loaded_count += 1
                            
                            if loaded_count % progress_update_interval == 0:
                                progress_percent = min(int((loaded_count / limit) * 100), 99)
                                self._update_progress(self._t("loaded_messages_no_target", current=loaded_count), progress_percent)
                        
                        data.reuse()
                except Exception as e:
                    log(f"[ChatExport] Error deserializing message: {e}")
                    continue
            
            cursor.dispose()
            
            messages.reverse()
            
            log(f"[ChatExport] Loaded {len(messages)} real messages from database")
            
        except Exception as e:
            log(f"[ChatExport] Database error: {e}")
            import traceback
            log(traceback.format_exc())
            return self._create_demo_messages(dialog_id)
        
        if not messages:
            log(f"[ChatExport] No messages found in database, using demo")
            return self._create_demo_messages(dialog_id)
        
        return messages
        
    def _create_demo_messages(self, dialog_id: int) -> List[Dict[str, Any]]:
        current_user_id = get_user_config().getClientUserId()
        chat_name = self._get_chat_name(dialog_id)
        
        return [
            {
                "id": 1,
                "from_id": current_user_id,
                "text": "This is a demo export showing the structure.",
                "date": int(time.time()) - 3600,
                "out": True
            },
            {
                "id": 2,
                "from_id": dialog_id if dialog_id > 0 else current_user_id,
                "text": f"Actual message export requires database access. This demo shows how your chat with {chat_name} would be exported.",
                "date": int(time.time()) - 3000,
                "out": False
            },
            {
                "id": 3,
                "from_id": current_user_id,
                "text": "The export includes message text, timestamps, sender information, and media placeholders.",
                "date": int(time.time()) - 2400,
                "out": True
            },
            {
                "id": 4,
                "from_id": current_user_id,
                "text": "You can configure export settings in the plugin settings.",
                "date": int(time.time()) - 1800,
                "out": True,
                "media": {"type": "photo", "caption": "Example photo"}
            },
            {
                "id": 5,
                "from_id": dialog_id if dialog_id > 0 else current_user_id,
                "text": "Supported formats: HTML (Telegram Desktop style), JSON, and plain text.",
                "date": int(time.time()) - 600,
                "out": False
            }
        ]
        
    def _tlrpc_message_to_dict(self, msg: TLRPC.Message) -> Dict[str, Any]:
        try:
            result = {
                "id": msg.id,
                "date": msg.date,
                "text": msg.message or "",
                "out": msg.out,
                "_tlrpc_obj": msg,
            }
            
            if hasattr(msg, 'from_id') and msg.from_id:
                if hasattr(msg.from_id, 'user_id'):
                    result["from_id"] = msg.from_id.user_id
                elif hasattr(msg.from_id, 'channel_id'):
                    result["from_id"] = -msg.from_id.channel_id
            elif hasattr(msg, 'peer_id') and msg.peer_id:
                if hasattr(msg.peer_id, 'user_id'):
                    result["from_id"] = msg.peer_id.user_id
                elif hasattr(msg.peer_id, 'channel_id'):
                    result["from_id"] = -msg.peer_id.channel_id
                elif hasattr(msg.peer_id, 'chat_id'):
                    result["from_id"] = -msg.peer_id.chat_id
            
            if msg.media:
                result["media"] = self._extract_media_info(msg.media, msg.message or "")
                result["media"]["_media_obj"] = msg.media
            
            if hasattr(msg, 'reply_to') and msg.reply_to:
                if hasattr(msg.reply_to, 'reply_to_msg_id'):
                    result["reply_to_msg_id"] = msg.reply_to.reply_to_msg_id
            
            if hasattr(msg, 'fwd_from') and msg.fwd_from:
                result["forwarded"] = True

                if hasattr(msg.fwd_from, 'from_name') and msg.fwd_from.from_name:
                    result["fwd_from_name"] = msg.fwd_from.from_name
                    log(f"[ChatExport] Forward from_name: {msg.fwd_from.from_name}")

                if hasattr(msg.fwd_from, 'post_author') and msg.fwd_from.post_author:
                    if "fwd_from_name" not in result:
                        result["fwd_from_name"] = msg.fwd_from.post_author
                    else:
                        result["fwd_post_author"] = msg.fwd_from.post_author
                    log(f"[ChatExport] Forward post_author: {msg.fwd_from.post_author}")

                if hasattr(msg.fwd_from, 'from_id') and msg.fwd_from.from_id:
                    if hasattr(msg.fwd_from.from_id, 'user_id'):
                        result["fwd_from_id"] = msg.fwd_from.from_id.user_id
                        log(f"[ChatExport] Forward from user_id: {msg.fwd_from.from_id.user_id}")
                    elif hasattr(msg.fwd_from.from_id, 'channel_id'):
                        result["fwd_from_id"] = -msg.fwd_from.from_id.channel_id
                        log(f"[ChatExport] Forward from channel_id: {msg.fwd_from.from_id.channel_id}")
                    elif hasattr(msg.fwd_from.from_id, 'chat_id'):
                        result["fwd_from_id"] = -msg.fwd_from.from_id.chat_id
                        log(f"[ChatExport] Forward from chat_id: {msg.fwd_from.from_id.chat_id}")
            
            if hasattr(msg, 'edit_date') and msg.edit_date:
                result["edited"] = True
                result["edit_date"] = msg.edit_date
            
            if hasattr(msg, 'action') and msg.action:
                result["action"] = True
                result["action_type"] = msg.action.__class__.__name__
            
            return result
            
        except Exception as e:
            log(f"[ChatExport] Error converting TLRPC message: {e}")
            return {
                "id": 0,
                "date": int(time.time()),
                "text": "[Error converting message]",
                "out": False
            }
    
    def _extract_media_info(self, media, caption="", msg_obj=None) -> Dict[str, Any]:
        media_info = {"type": "unknown", "caption": caption}
        
        try:
            media_class = media.__class__.__name__
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto):
                media_info["type"] = "photo"
                if hasattr(media, 'photo') and media.photo:
                    photo_size = _get_best_photo_size(media.photo)
                    if photo_size:
                        media_info["width"] = getattr(photo_size, "w", 0) or getattr(photo_size, "width", 0)
                        media_info["height"] = getattr(photo_size, "h", 0) or getattr(photo_size, "height", 0)
                        
            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                if hasattr(media, 'document'):
                    doc = media.document
                    mime = getattr(doc, 'mime_type', '')
                    
                    if hasattr(doc, 'file_name'):
                        media_info["filename"] = doc.file_name
                    if hasattr(doc, 'size'):
                        media_info["size"] = doc.size
                    
                    attrs = getattr(doc, 'attributes', [])
                    if hasattr(attrs, 'toArray'):
                        attrs = list(attrs.toArray())
                    
                    for attr in attrs:
                        if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                            if mime == "application/x-tgsticker":
                                media_info["type"] = "sticker_animated"
                            elif mime == "video/webm":
                                media_info["type"] = "sticker_video"
                            else:
                                media_info["type"] = "sticker"
                            if hasattr(attr, 'alt'):
                                media_info["emoji"] = attr.alt
                                
                        elif isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                            media_info["type"] = "gif"
                            
                        elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                            if getattr(attr, "round_message", False):
                                media_info["type"] = "video_circle"
                            else:
                                media_info["type"] = "video"
                            media_info["duration"] = getattr(attr, "duration", 0)
                            media_info["width"] = getattr(attr, "w", 0)
                            media_info["height"] = getattr(attr, "h", 0)
                            
                        elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                            if media_info["type"] != "video_circle":
                                if getattr(attr, "voice", False):
                                    media_info["type"] = "voice"
                                else:
                                    media_info["type"] = "audio"
                            media_info["duration"] = getattr(attr, "duration", 0)
                            media_info["title"] = getattr(attr, "title", "")
                            media_info["performer"] = getattr(attr, "performer", "")
                        
                        elif isinstance(attr, TLRPC.TL_documentAttributeFilename):
                            media_info["filename"] = getattr(attr, "file_name", "")
                    
                    if media_info["type"] == "unknown":
                        if mime.startswith('video/'):
                            media_info["type"] = "video"
                        elif mime.startswith('audio/'):
                            media_info["type"] = "audio"
                        elif mime == "image/gif":
                            media_info["type"] = "gif"
                        else:
                            media_info["type"] = "document"
                            
            elif "WebPage" in media_class:
                media_info["type"] = "webpage"
                if hasattr(media, 'webpage'):
                    webpage = media.webpage
                    if hasattr(webpage, 'url'):
                        media_info["url"] = webpage.url
                    if hasattr(webpage, 'site_name'):
                        media_info["site"] = webpage.site_name
                    if hasattr(webpage, 'title'):
                        media_info["title"] = webpage.title
                    if hasattr(webpage, 'description'):
                        media_info["description"] = webpage.description
                        
            elif "Geo" in media_class or "Venue" in media_class:
                media_info["type"] = "location"
                if hasattr(media, 'geo') and media.geo:
                    if hasattr(media.geo, 'lat') and hasattr(media.geo, 'long'):
                        media_info["lat"] = media.geo.lat
                        media_info["lon"] = media.geo.long
                if "Venue" in media_class:
                    media_info["type"] = "venue"
                    if hasattr(media, 'title'):
                        media_info["title"] = media.title
                    if hasattr(media, 'address'):
                        media_info["address"] = media.address
                        
            elif "Contact" in media_class:
                media_info["type"] = "contact"
                if hasattr(media, 'phone_number'):
                    media_info["phone"] = media.phone_number
                if hasattr(media, 'first_name'):
                    media_info["name"] = media.first_name
                if hasattr(media, 'last_name'):
                    media_info["name"] = f"{media.first_name} {media.last_name}".strip()
                    
            elif "Poll" in media_class:
                media_info["type"] = "poll"
                if hasattr(media, 'poll') and media.poll:
                    if hasattr(media.poll, 'question'):
                        media_info["question"] = media.poll.question
                    if hasattr(media.poll, 'closed'):
                        media_info["closed"] = media.poll.closed
                        
            elif "Game" in media_class:
                media_info["type"] = "game"
                if hasattr(media, 'game'):
                    game = media.game
                    if hasattr(game, 'title'):
                        media_info["title"] = game.title
                    if hasattr(game, 'description'):
                        media_info["description"] = game.description
                        
            elif "Invoice" in media_class:
                media_info["type"] = "invoice"
                if hasattr(media, 'title'):
                    media_info["title"] = media.title
                if hasattr(media, 'description'):
                    media_info["description"] = media.description
                    
            elif "GeoLive" in media_class:
                media_info["type"] = "live_location"
                
            elif "Unsupported" in media_class:
                media_info["type"] = "unsupported"
                
        except Exception as e:
            log(f"[ChatExport] Error extracting media info: {e}")
        
        return media_info
        
    def _get_html_template(self, chat_name: str, export_date: str, info_text: str) -> str:
        return f"""<!DOCTYPE html>
<html lang="en" class="dark">
<head>
 <meta charset="utf-8"/>
 <title>{chat_name}</title>
 <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
 <style>
  :root {{
   --background: oklch(0.98 0.005 264);
   --foreground: oklch(0.25 0.01 264);
   --card: oklch(0.99 0.003 264);
   --card-foreground: oklch(0.25 0.01 264);
   --muted: oklch(0.94 0.008 264);
   --muted-foreground: oklch(0.5 0.01 264);
   --accent: oklch(0.65 0.22 200);
   --accent-foreground: oklch(0.99 0.003 264);
   --border: oklch(0.65 0.05 264);
   --radius: 0.75rem;
  }}
  
  .dark {{
   --background: oklch(0.14 0.015 264);
   --foreground: oklch(0.92 0.01 264);
   --card: oklch(0.18 0.018 264);
   --card-foreground: oklch(0.92 0.01 264);
   --muted: oklch(0.2 0.018 264);
   --muted-foreground: oklch(0.6 0.012 264);
   --accent: oklch(0.65 0.22 200);
   --accent-foreground: oklch(0.14 0.015 264);
   --border: oklch(0.24 0.02 264);
  }}
  
  * {{
   margin: 0;
   padding: 0;
   box-sizing: border-box;
  }}
  
  body {{
   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
   font-size: 15px;
   background: var(--background);
   color: var(--foreground);
   line-height: 1.6;
   min-height: 100vh;
  }}
  
  .page_wrap {{
   min-height: 100vh;
  }}
  
  .page_header {{
   background: color-mix(in oklch, var(--card) 50%, transparent);
   backdrop-filter: blur(20px);
   border-bottom: 1px solid var(--border);
   padding: 12px 16px;
   position: sticky;
   top: 0;
   z-index: 10;
  }}
  
  .page_header .content {{
   max-width: 1024px;
   margin: 0 auto;
  }}
  
  .page_header .header-top {{
   display: flex;
   align-items: center;
   justify-content: space-between;
   gap: 16px;
  }}
  
  .page_header .text {{
   font-size: 20px;
   font-weight: 600;
   color: var(--foreground);
   margin-bottom: 4px;
   letter-spacing: -0.02em;
  }}
  
  .page_header .details {{
   display: flex;
   align-items: center;
   gap: 12px;
   color: var(--muted-foreground);
   font-size: 13px;
  }}
  
  .page_header .details .separator {{
   color: color-mix(in oklch, var(--muted-foreground) 50%, transparent);
  }}
  
  .theme-toggle {{
   position: relative;
   background: var(--muted);
   border: 1px solid var(--border);
   border-radius: calc(var(--radius) + 2px);
   padding: 4px;
   cursor: pointer;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   white-space: nowrap;
   flex-shrink: 0;
   width: 64px;
   height: 32px;
   display: flex;
   align-items: center;
   justify-content: space-between;
   overflow: hidden;
  }}
  
  .theme-toggle:hover {{
   background: color-mix(in oklch, var(--muted) 80%, var(--accent) 20%);
   border-color: var(--accent);
   transform: translateY(-1px);
   box-shadow: 0 4px 12px color-mix(in oklch, var(--accent) 20%, transparent);
  }}
  
  .theme-toggle:active {{
   transform: translateY(0);
   box-shadow: 0 2px 6px color-mix(in oklch, var(--accent) 15%, transparent);
  }}
  
  .theme-toggle-track {{
   position: absolute;
   top: 2px;
   left: 2px;
   right: 2px;
   bottom: 2px;
   background: linear-gradient(90deg, 
     color-mix(in oklch, var(--background) 90%, var(--accent) 10%) 0%,
     color-mix(in oklch, var(--background) 70%, var(--accent) 30%) 100%);
   border-radius: calc(var(--radius) - 2px);
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   box-shadow: inset 0 1px 3px color-mix(in oklch, var(--foreground) 10%, transparent);
  }}
  
  .theme-toggle-thumb {{
   position: relative;
   width: 24px;
   height: 24px;
   background: var(--background);
   border: 1px solid var(--border);
   border-radius: 50%;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   display: block;
   z-index: 2;
   box-shadow: 0 2px 6px color-mix(in oklch, var(--foreground) 15%, transparent),
               0 1px 2px color-mix(in oklch, var(--foreground) 5%, transparent);
  }}
  
  .theme-toggle-thumb::before {{
   content: '';
   position: absolute;
   inset: -2px;
   background: linear-gradient(135deg, 
     color-mix(in oklch, var(--accent) 30%, transparent) 0%,
     color-mix(in oklch, var(--accent) 60%, transparent) 100%);
   border-radius: 50%;
   opacity: 0;
   transition: opacity 0.3s ease;
   z-index: -1;
  }}
  
  .theme-toggle:hover .theme-toggle-thumb::before {{
   opacity: 1;
  }}
  
  /* Icons removed */
  
  /* Dark theme state */
  .dark .theme-toggle-track {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, var(--background) 70%, var(--accent) 30%) 0%,
     color-mix(in oklch, var(--background) 90%, var(--accent) 10%) 100%);
  }}
  
  .dark .theme-toggle-thumb {{
   transform: translateX(32px);
  }}
  
  .dark .theme-toggle-icon.sun {{
   opacity: 0;
   transform: translateY(-50%) scale(0.8) rotate(180deg);
  }}
  
  .dark .theme-toggle-icon.moon {{
   opacity: 1;
   transform: translateY(-50%) scale(1.1) rotate(0deg);
  }}
  
  /* Light theme state */
  .theme-toggle-icon.sun {{
   opacity: 1;
   transform: translateY(-50%) scale(1.1) rotate(0deg);
  }}
  
  .theme-toggle-icon.moon {{
   opacity: 0;
   transform: translateY(-50%) scale(0.8) rotate(-180deg);
  }}
  
  .page_body {{
   max-width: 1024px;
   margin: 0 auto;
   padding: 32px 24px;
  }}
  
  .history {{
   padding: 0;
  }}
  
  .date-divider {{
   display: flex;
   align-items: center;
   gap: 16px;
   margin: 32px 0;
  }}
  
  .date-divider .line {{
   flex: 1;
   height: 1px;
   background: var(--border);
  }}
  
  .date-divider .text {{
   font-size: 14px;
   font-weight: 500;
   color: var(--muted-foreground);
   padding: 6px 16px;
   background: color-mix(in oklch, var(--muted) 80%, transparent);
   border-radius: 9999px;
   border: 1px solid var(--border);
  }}
  
  .message {{
   margin: 4px 0;
   clear: both;
  }}
  
  .message.default {{
   display: flex;
   gap: 16px;
   padding: 12px 16px;
   border-radius: calc(var(--radius) + 4px);
   transition: background 0.2s ease;
  }}
  
  .message.default:hover {{
   background: color-mix(in oklch, var(--muted) 70%, transparent);
  }}
  
  .message.service {{
   text-align: center;
   padding: 16px 0;
  }}
  
  .message.service .body {{
   color: var(--muted-foreground);
   font-size: 13px;
  }}
  
  .userpic_wrap {{
   flex-shrink: 0;
  }}
  
  .userpic {{
   width: 40px;
   height: 40px;
   border-radius: 50%;
   display: flex;
   align-items: center;
   justify-content: center;
   font-weight: 500;
   font-size: 14px;
   color: #FFFFFF;
   position: relative;
   overflow: hidden;
  }}
  
  .userpic::after {{
   content: '';
   position: absolute;
   inset: 0;
   border-radius: 50%;
   box-shadow: inset 0 0 0 2px var(--background);
  }}
  
  .userpic img {{
   width: 100%;
   height: 100%;
   object-fit: cover;
   border-radius: 50%;
  }}
  
  .userpic1 {{ background: linear-gradient(135deg, #E17076, #DA5B62); }}
  .userpic2 {{ background: linear-gradient(135deg, #F2C94C, #E8B73B); }}
  .userpic3 {{ background: linear-gradient(135deg, #66BB6A, #5AAD5E); }}
  .userpic4 {{ background: linear-gradient(135deg, #64B5EF, #5AA1DB); }}
  .userpic5 {{ background: linear-gradient(135deg, #9575CD, #8462BC); }}
  .userpic6 {{ background: linear-gradient(135deg, #F06292, #E05480); }}
  .userpic7 {{ background: linear-gradient(135deg, #4FC3F7, #45B0E5); }}
  .userpic8 {{ background: linear-gradient(135deg, #FFB74D, #F0A73B); }}
  
  .initials {{
   text-align: center;
   font-size: 16px;
  }}
  
  .body {{
   flex: 1;
   min-width: 0;
  }}
  
  .message-header {{
   display: flex;
   align-items: baseline;
   gap: 12px;
   margin-bottom: 4px;
  }}
  
  .from_name {{
   font-weight: 600;
   color: var(--accent);
   font-size: 14px;
  }}
  
  .date {{
   color: var(--muted-foreground);
   font-size: 12px;
   white-space: nowrap;
  }}
  
  .date.edited {{
   color: color-mix(in oklch, var(--muted-foreground) 60%, transparent);
  }}
  
  .text {{
   color: var(--foreground);
   line-height: 1.6;
   word-wrap: break-word;
   white-space: pre-wrap;
   font-size: 15px;
  }}
  
  .text a {{
   color: var(--accent);
   text-decoration: none;
  }}
  
  .text a:hover {{
   text-decoration: underline;
  }}
  
  .media_wrap {{
   margin: 12px 0;
  }}
  
  .photo {{
   max-width: 100%;
   border-radius: var(--radius);
   display: block;
  }}
  
  .media-placeholder {{
   background: var(--muted);
   padding: 16px 20px;
   border-radius: var(--radius);
   color: var(--muted-foreground);
   font-size: 14px;
   margin: 12px 0;
  }}
  
  img.media {{
   max-width: 100%;
   max-height: 500px;
   border-radius: var(--radius);
   margin-top: 12px;
   cursor: pointer;
   object-fit: contain;
   display: block;
   transition: opacity 0.2s ease, transform 0.1s ease;
  }}
  
  img.media:hover {{
   opacity: 0.9;
   transform: scale(1.005);
  }}
  
  img.media:active {{
   transform: scale(0.995);
  }}
  
  .sticker {{
   max-width: 180px;
   max-height: 180px;
   margin-top: 12px;
   display: inline-block;
  }}
  
  .sticker-video {{
   max-width: 180px;
   max-height: 180px;
   margin-top: 12px;
   display: inline-block;
   background: transparent;
  }}
  
  .sticker-animated-container {{
   margin-top: 12px;
   display: inline-block;
   position: relative;
   text-align: center;
  }}
  
  .sticker-animated {{
   width: 200px;
   height: 200px;
   display: block;
  }}
  
  .sticker-emoji {{
   position: absolute;
   bottom: -25px;
   left: 50%;
   transform: translateX(-50%);
   font-size: 14px;
   color: var(--muted-foreground);
   opacity: 0.7;
  }}
  
  .gif {{
   max-width: 100%;
   max-height: 400px;
   border-radius: var(--radius);
   margin-top: 12px;
   display: block;
   background: transparent;
  }}
  
  .video-circle-wrapper {{
   margin-top: 12px;
   display: inline-block;
  }}
  
  .video-circle-container {{
   position: relative;
   width: 200px;
   height: 200px;
   display: inline-block;
   cursor: pointer;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }}
  
  .video-circle-container:hover {{
   transform: scale(1.05);
  }}
  
  .video-circle-container:active {{
   transform: scale(0.98);
  }}
  
  /* Progress ring SVG - Enhanced style */
  .video-circle-progress {{
   position: absolute;
   inset: 0;
   width: 100%;
   height: 100%;
   transform: rotate(-90deg);
   opacity: 0;
   transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   pointer-events: none;
   z-index: 3;
   filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
  }}
  
  .video-circle-container.playing .video-circle-progress {{
   opacity: 1;
  }}
  
  .video-circle-progress-ring {{
   fill: none;
   stroke: white;
   stroke-width: 4;
   stroke-linecap: round;
   transition: stroke-dashoffset 0.2s ease-out;
  }}
  
  /* Video element wrapper - Enhanced shadows */
  .video-circle-thumbnail {{
   position: absolute;
   inset: 8px;
   border-radius: 50%;
   overflow: hidden;
   box-shadow: 0 8px 24px color-mix(in oklch, var(--foreground) 15%, transparent),
               0 0 0 3px color-mix(in oklch, var(--card) 80%, transparent);
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }}
  
  .video-circle-container:hover .video-circle-thumbnail {{
   box-shadow: 0 12px 32px color-mix(in oklch, var(--foreground) 20%, transparent),
               0 0 0 3px color-mix(in oklch, var(--accent) 30%, transparent);
  }}
  
  .dark .video-circle-thumbnail {{
   box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4),
               0 0 0 3px rgba(255, 255, 255, 0.05);
  }}
  
  .dark .video-circle-container:hover .video-circle-thumbnail {{
   box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5),
               0 0 0 3px rgba(255, 255, 255, 0.1);
  }}
  
  .video-circle {{
   width: 100%;
   height: 100%;
   object-fit: cover;
   display: block;
  }}
  
  /* Overlay gradient - Enhanced */
  .video-circle-overlay {{
   position: absolute;
   inset: 0;
   background: radial-gradient(circle at center, transparent 30%, rgba(0, 0, 0, 0.3) 100%);
   opacity: 1;
   transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   pointer-events: none;
   z-index: 1;
  }}
  
  .video-circle-container:hover .video-circle-overlay {{
   background: radial-gradient(circle at center, transparent 25%, rgba(0, 0, 0, 0.25) 100%);
  }}
  
  .video-circle-container.playing .video-circle-overlay {{
   opacity: 0;
  }}
  
  /* Play/Pause button - Modern style */
  .video-circle-play-icon {{
   position: absolute;
   top: 50%;
   left: 50%;
   transform: translate(-50%, -50%);
   width: 72px;
   height: 72px;
   background: rgba(255, 255, 255, 0.15);
   backdrop-filter: blur(10px);
   -webkit-backdrop-filter: blur(10px);
   border-radius: 50%;
   display: flex;
   align-items: center;
   justify-content: center;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   pointer-events: none;
   z-index: 2;
   box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  }}
  
  .video-circle-container:hover .video-circle-play-icon {{
   transform: translate(-50%, -50%) scale(1.15);
   background: rgba(255, 255, 255, 0.25);
  }}
  
  .video-circle-container.playing .video-circle-play-icon {{
   opacity: 0;
   transform: translate(-50%, -50%) scale(0.8);
  }}
  
  .video-circle-play-icon svg {{
   width: 32px;
   height: 32px;
   fill: white;
   margin-left: 3px;
   filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }}
  
  .video-circle-play-icon.paused svg {{
   margin-left: 0;
  }}
  
  /* Duration badge - Enhanced style */
  .video-circle-duration {{
   position: absolute;
   bottom: 16px;
   left: 50%;
   transform: translateX(-50%);
   padding: 6px 12px;
   border-radius: 16px;
   background: rgba(0, 0, 0, 0.7);
   backdrop-filter: blur(8px);
   -webkit-backdrop-filter: blur(8px);
   color: white;
   font-size: 13px;
   font-weight: 600;
   z-index: 2;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   font-variant-numeric: tabular-nums;
   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }}
  
  .video-circle-container:hover .video-circle-duration {{
   background: rgba(0, 0, 0, 0.85);
   transform: translateX(-50%) scale(1.05);
  }}
  
  .video-circle-container.playing .video-circle-duration {{
   opacity: 0.7;
  }}
  
  /* Modern Telegram-style video player */
  .video-player-wrapper {{
   margin-top: 12px;
   max-width: 100%;
   position: relative;
   display: block;
  }}
  
  .video-player-container {{
   position: relative;
   width: 100%;
   max-width: 640px;
   background: var(--card);
   border-radius: calc(var(--radius) * 1.5);
   overflow: hidden;
   box-shadow: 0 8px 24px color-mix(in oklch, var(--foreground) 15%, transparent);
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }}
  
  .video-player-container:hover {{
   box-shadow: 0 12px 32px color-mix(in oklch, var(--foreground) 20%, transparent);
  }}
  
  .dark .video-player-container {{
   box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  }}
  
  .dark .video-player-container:hover {{
   box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
  }}
  
  .video-player-video {{
   width: 100%;
   display: block;
   aspect-ratio: 16 / 9;
   object-fit: contain;
   background: #000;
   cursor: pointer;
  }}
  
  /* Play/Pause overlay button */
  .video-player-play-overlay {{
   position: absolute;
   inset: 0;
   display: flex;
   align-items: center;
   justify-content: center;
   pointer-events: none;
   transition: opacity 0.3s ease;
   z-index: 2;
  }}
  
  .video-player-play-overlay.hidden {{
   opacity: 0;
  }}
  
  .video-player-play-btn-big {{
   width: 80px;
   height: 80px;
   display: flex;
   align-items: center;
   justify-content: center;
   background: rgba(255, 255, 255, 0.15);
   backdrop-filter: blur(10px);
   -webkit-backdrop-filter: blur(10px);
   border-radius: 50%;
   box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
   pointer-events: auto;
   cursor: pointer;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }}
  
  .video-player-play-btn-big:hover {{
   transform: scale(1.1);
   background: rgba(255, 255, 255, 0.25);
  }}
  
  .video-player-play-btn-big:active {{
   transform: scale(0.95);
  }}
  
  .video-player-play-btn-big svg {{
   width: 36px;
   height: 36px;
   fill: white;
   margin-left: 4px;
   filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
  }}
  
  /* Controls bar */
  .video-player-controls {{
   position: absolute;
   bottom: 0;
   left: 0;
   right: 0;
   background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.5) 70%, transparent 100%);
   padding: 12px 16px;
   transition: all 0.3s ease;
   z-index: 3;
  }}
  
  .video-player-controls.hidden {{
   opacity: 0;
   transform: translateY(100%);
  }}
  
  /* Progress bar */
  .video-player-progress-container {{
   width: 100%;
   height: 4px;
   background: rgba(255, 255, 255, 0.3);
   border-radius: 2px;
   margin-bottom: 12px;
   cursor: pointer;
   position: relative;
   transition: height 0.2s ease;
  }}
  
  /* Time tooltip */
  .video-player-progress-tooltip {{
   position: absolute;
   bottom: 12px;
   transform: translateX(-50%);
   padding: 4px 8px;
   background: rgba(0, 0, 0, 0.85);
   backdrop-filter: blur(8px);
   -webkit-backdrop-filter: blur(8px);
   color: white;
   font-size: 12px;
   font-weight: 600;
   border-radius: 6px;
   pointer-events: none;
   opacity: 0;
   transition: opacity 0.2s ease;
   white-space: nowrap;
   z-index: 10;
   font-variant-numeric: tabular-nums;
  }}
  
  .video-player-progress-container:hover .video-player-progress-tooltip {{
   opacity: 1;
  }}
  
  .video-player-progress-container.seeking .video-player-progress-tooltip {{
   opacity: 1;
  }}
  
  .video-player-progress-bar {{
   height: 100%;
   background: white;
   border-radius: 2px;
   width: 0%;
   transition: width 0.1s linear;
   position: relative;
  }}
  
  .video-player-progress-bar::after {{
   content: '';
   position: absolute;
   right: -6px;
   top: 50%;
   transform: translateY(-50%) scale(1);
   width: 12px;
   height: 12px;
   background: white;
   border-radius: 50%;
   opacity: 0;
   transition: opacity 0.2s ease, transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
   box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
  }}
  
  .video-player-progress-container:hover .video-player-progress-bar::after {{
   opacity: 1;
  }}
  
  .video-player-progress-container.seeking .video-player-progress-bar::after {{
   opacity: 1;
   transform: translateY(-50%) scale(1.3);
  }}
  
  .video-player-progress-container.seeking {{
   height: 6px;
  }}
  
  .video-player-progress-container.seeking .video-player-progress-bar {{
   transition: width 0.05s linear;
  }}
  
  /* Control buttons row */
  .video-player-controls-row {{
   display: flex;
   align-items: center;
   justify-content: space-between;
   gap: 12px;
  }}
  
  .video-player-controls-left {{
   display: flex;
   align-items: center;
   gap: 12px;
  }}
  
  .video-player-controls-right {{
   display: flex;
   align-items: center;
   gap: 8px;
  }}
  
  /* Play/Pause button */
  .video-player-play-btn {{
   width: 36px;
   height: 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   background: rgba(255, 255, 255, 0.1);
   backdrop-filter: blur(5px);
   -webkit-backdrop-filter: blur(5px);
   border-radius: 50%;
   cursor: pointer;
   transition: all 0.2s ease;
   border: none;
   padding: 0;
  }}
  
  .video-player-play-btn:hover {{
   background: rgba(255, 255, 255, 0.2);
   transform: scale(1.05);
  }}
  
  .video-player-play-btn:active {{
   transform: scale(0.95);
  }}
  
  .video-player-play-btn svg {{
   width: 20px;
   height: 20px;
   fill: white;
  }}
  
  /* Time display */
  .video-player-time {{
   color: white;
   font-size: 14px;
   font-weight: 500;
   font-variant-numeric: tabular-nums;
   white-space: nowrap;
   user-select: none;
  }}
  
  /* Volume control */
  .video-player-volume {{
   display: flex;
   align-items: center;
   gap: 8px;
  }}
  
  .video-player-volume-btn {{
   width: 36px;
   height: 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   background: rgba(255, 255, 255, 0.1);
   backdrop-filter: blur(5px);
   -webkit-backdrop-filter: blur(5px);
   border-radius: 50%;
   cursor: pointer;
   transition: all 0.2s ease;
   border: none;
   padding: 0;
  }}
  
  .video-player-volume-btn:hover {{
   background: rgba(255, 255, 255, 0.2);
   transform: scale(1.05);
  }}
  
  .video-player-volume-btn:active {{
   transform: scale(0.95);
  }}
  
  .video-player-volume-btn svg {{
   width: 20px;
   height: 20px;
   fill: white;
  }}
  
  /* Volume slider */
  .video-player-volume-slider {{
   width: 0;
   opacity: 0;
   transition: all 0.3s ease;
   -webkit-appearance: none;
   appearance: none;
   height: 4px;
   background: rgba(255, 255, 255, 0.3);
   border-radius: 2px;
   outline: none;
   cursor: pointer;
  }}
  
  .video-player-volume:hover .video-player-volume-slider {{
   width: 80px;
   opacity: 1;
  }}
  
  .video-player-volume-slider::-webkit-slider-thumb {{
   -webkit-appearance: none;
   appearance: none;
   width: 12px;
   height: 12px;
   background: white;
   border-radius: 50%;
   cursor: pointer;
   transition: transform 0.15s ease;
  }}
  
  .video-player-volume-slider::-webkit-slider-thumb:hover {{
   transform: scale(1.25);
  }}
  
  .video-player-volume-slider::-moz-range-thumb {{
   width: 12px;
   height: 12px;
   background: white;
   border: none;
   border-radius: 50%;
   cursor: pointer;
   transition: transform 0.15s ease;
  }}
  
  .video-player-volume-slider::-moz-range-thumb:hover {{
   transform: scale(1.25);
  }}
  
  /* Fullscreen button */
  .video-player-fullscreen-btn {{
   width: 36px;
   height: 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   background: rgba(255, 255, 255, 0.1);
   backdrop-filter: blur(5px);
   -webkit-backdrop-filter: blur(5px);
   border-radius: 50%;
   cursor: pointer;
   transition: all 0.2s ease;
   border: none;
   padding: 0;
  }}
  
  .video-player-fullscreen-btn:hover {{
   background: rgba(255, 255, 255, 0.2);
   transform: scale(1.05);
  }}
  
  .video-player-fullscreen-btn:active {{
   transform: scale(0.95);
  }}
  
  .video-player-fullscreen-btn svg {{
   width: 20px;
   height: 20px;
   fill: white;
  }}
  
  /* Timestamp badge */
  .video-player-timestamp {{
   position: absolute;
   bottom: 12px;
   right: 12px;
   padding: 4px 10px;
   background: rgba(0, 0, 0, 0.7);
   backdrop-filter: blur(8px);
   -webkit-backdrop-filter: blur(8px);
   color: white;
   font-size: 12px;
   font-weight: 600;
   border-radius: 12px;
   z-index: 1;
   transition: opacity 0.3s ease;
   font-variant-numeric: tabular-nums;
  }}
  
  .video-player-container.playing .video-player-timestamp {{
   opacity: 0;
  }}
  
  /* Legacy video.media for backwards compatibility */
  video.media {{
   max-width: 100%;
   max-height: 500px;
   border-radius: var(--radius);
   margin-top: 12px;
   background: var(--muted);
   display: block;
  }}
  
  audio.media {{
   max-width: 100%;
   border-radius: var(--radius);
   margin-top: 12px;
   background: var(--muted);
   display: block;
  }}
  
  /* Voice message Telegram-style */
  .voice-message {{
   display: flex;
   align-items: center;
   gap: 12px;
   padding: 12px 16px;
   border-radius: 18px;
   background: var(--card);
   border: 1px solid var(--border);
   margin-top: 12px;
   max-width: 320px;
   transition: all 0.3s ease;
   cursor: pointer;
  }}
  
  .voice-message:hover {{
   transform: scale(1.02);
  }}
  
  /* Play/Pause button for voice */
  .voice-play-btn {{
   flex-shrink: 0;
   width: 40px;
   height: 40px;
   border-radius: 50%;
   background: var(--accent);
   display: flex;
   align-items: center;
   justify-content: center;
   transition: all 0.3s ease;
   cursor: pointer;
  }}
  
  .voice-play-btn:hover {{
   transform: scale(1.05);
   filter: brightness(1.1);
  }}
  
  .voice-play-btn.playing {{
   transform: scale(0.95);
  }}
  
  .voice-play-btn svg {{
   width: 20px;
   height: 20px;
   fill: white;
  }}
  
  .voice-play-btn svg.play-icon {{
   margin-left: 2px;
  }}
  
  /* Waveform container */
  .voice-waveform {{
   flex: 1;
   display: flex;
   align-items: center;
   gap: 2px;
   height: 40px;
   min-width: 0;
   overflow: hidden;
  }}
  
  .voice-waveform-bar {{
   flex: 1;
   min-width: 3px;
   background: color-mix(in oklch, var(--accent) 30%, var(--muted));
   border-radius: 2px;
   transition: all 0.2s ease-out;
   opacity: 0.6;
  }}
  
  .voice-waveform-bar.active {{
   background: var(--accent);
   transform: scaleY(1.05);
   opacity: 1;
  }}
  
  .voice-message.playing .voice-waveform-bar.active {{
   animation: pulse-bar 1s ease-in-out infinite;
  }}
  
  @keyframes pulse-bar {{
   0%, 100% {{ opacity: 1; }}
   50% {{ opacity: 0.7; }}
  }}
  
  /* Duration/time display */
  .voice-duration {{
   flex-shrink: 0;
   font-size: 14px;
   font-weight: 500;
   color: var(--muted-foreground);
   font-variant-numeric: tabular-nums;
   min-width: 40px;
   text-align: right;
  }}
  
  .document-card {{
   display: flex;
   align-items: center;
   gap: 12px;
   padding: 14px 16px;
   background: color-mix(in oklch, var(--muted) 30%, transparent);
   border-radius: var(--radius);
   margin-top: 8px;
   border: 1px solid var(--border);
   transition: background 0.2s ease;
  }}
  
  .document-card:hover {{
   background: color-mix(in oklch, var(--muted) 50%, transparent);
  }}
  
  .document-icon {{
   font-size: 28px;
   width: 40px;
   height: 40px;
   display: flex;
   align-items: center;
   justify-content: center;
   background: var(--accent);
   border-radius: 8px;
   flex-shrink: 0;
  }}
  
  .document-info {{
   flex: 1;
   min-width: 0;
  }}
  
  .document-name {{
   font-size: 14px;
   font-weight: 500;
   color: var(--foreground);
   overflow: hidden;
   text-overflow: ellipsis;
   white-space: nowrap;
  }}
  
  .document-size {{
   font-size: 12px;
   color: var(--muted-foreground);
   margin-top: 2px;
  }}
  
  .document-download {{
   font-size: 24px;
   color: var(--accent);
   text-decoration: none;
   width: 36px;
   height: 36px;
   display: flex;
   align-items: center;
   justify-content: center;
   border-radius: 50%;
   transition: background 0.2s ease;
   flex-shrink: 0;
  }}
  
  .document-download:hover {{
   background: color-mix(in oklch, var(--accent) 20%, transparent);
  }}
  
  .forwarded-header {{
   font-size: 13px;
   color: var(--muted-foreground);
   margin-bottom: 8px;
   padding-left: 12px;
   border-left: 2px solid var(--accent);
  }}
  
  .reply-reference {{
   font-size: 13px;
   background: color-mix(in oklch, var(--muted) 40%, transparent);
   padding: 10px 12px;
   border-radius: calc(var(--radius) - 2px);
   margin-bottom: 8px;
   border-left: 3px solid color-mix(in oklch, var(--accent) 60%, transparent);
   cursor: pointer;
   transition: all 0.2s ease;
  }}

  .reply-reference:hover {{
   background: color-mix(in oklch, var(--muted) 60%, transparent);
   border-left-color: var(--accent);
  }}
  
  .reply-author {{
   font-size: 12px;
   font-weight: 600;
   color: var(--accent);
   margin-bottom: 2px;
  }}
  
  .reply-text {{
   color: var(--muted-foreground);
   overflow: hidden;
   text-overflow: ellipsis;
   display: -webkit-box;
   -webkit-line-clamp: 2;
   -webkit-box-orient: vertical;
  }}

  .reply-not-found {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, oklch(0.6 0.12 35) 10%, transparent) 0%,
     color-mix(in oklch, var(--muted) 5%, transparent) 100%);
   border-left: 2px solid oklch(0.6 0.15 35) !important;
   border-radius: calc(var(--radius) - 2px);
   opacity: 0.85;
   position: relative;
   padding-left: 36px;
   box-shadow: inset 0 0 0 1px color-mix(in oklch, oklch(0.6 0.1 35) 15%, transparent);
  }}
  
  .reply-not-found::before {{
   content: '⚠️';
   position: absolute;
   left: 11px;
   top: 50%;
   transform: translateY(-50%);
   font-size: 16px;
   opacity: 0.7;
   filter: grayscale(0.3);
  }}

  .reply-not-found:hover {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, oklch(0.6 0.12 35) 18%, transparent) 0%,
     color-mix(in oklch, var(--muted) 10%, transparent) 100%);
   border-left-color: oklch(0.65 0.18 35) !important;
   opacity: 1;
   box-shadow: inset 0 0 0 1px color-mix(in oklch, oklch(0.6 0.1 35) 25%, transparent);
  }}
  
  .reply-not-found .reply-author {{
   color: color-mix(in oklch, var(--foreground) 75%, transparent);
   font-style: italic;
   font-weight: 500;
  }}
  
  .reply-not-found .reply-text {{
   color: color-mix(in oklch, var(--muted-foreground) 80%, transparent);
   font-style: italic;
   font-size: 12px;
  }}

  .clearfix::after {{
   content: "";
   display: table;
   clear: both;
  }}

  .bold {{
   font-weight: 600;
  }}

  /* Highlight animation for scrolled-to message */
  @keyframes messageHighlight {{
   0% {{
    background-color: color-mix(in oklch, var(--accent) 30%, transparent);
   }}
   100% {{
    background-color: transparent;
   }}
  }}

  .message.highlighted {{
   animation: messageHighlight 2s ease-out;
  }}

  /* Lightbox */
  .lightbox {{
   position: fixed;
   inset: 0;
   z-index: 9999;
   background: rgba(0, 0, 0, 0.95);
   backdrop-filter: blur(8px);
   display: none;
   align-items: center;
   justify-content: center;
   animation: lightboxFadeIn 0.2s ease-out;
  }}
  
  .lightbox.active {{
   display: flex;
  }}
  
  @keyframes lightboxFadeIn {{
   from {{
    opacity: 0;
   }}
   to {{
    opacity: 1;
   }}
  }}
  
  .lightbox-header {{
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   z-index: 10;
   display: flex;
   align-items: center;
   justify-content: space-between;
   padding: 16px;
   background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%);
  }}
  
  .lightbox-controls {{
   display: flex;
   gap: 8px;
  }}
  
  .lightbox-btn {{
   background: rgba(255, 255, 255, 0.1);
   border: none;
   border-radius: 8px;
   width: 40px;
   height: 40px;
   display: flex;
   align-items: center;
   justify-content: center;
   color: white;
   cursor: pointer;
   transition: all 0.2s ease;
   font-size: 20px;
   line-height: 1;
   padding: 0;
  }}
  
  .lightbox-btn svg {{
   width: 20px;
   height: 20px;
   stroke: white;
   stroke-width: 2;
   stroke-linecap: round;
   stroke-linejoin: round;
   fill: none;
   transition: transform 0.2s ease;
  }}
  
  .lightbox-btn:hover {{
   background: rgba(255, 255, 255, 0.2);
   transform: translateY(-1px);
  }}
  
  .lightbox-btn:hover svg {{
   transform: translateY(1px);
  }}
  
  .lightbox-btn:active {{
   transform: scale(0.95) translateY(0);
  }}
  
  .lightbox-btn:active svg {{
   transform: translateY(2px);
  }}
  
  .lightbox-content {{
   max-width: 95vw;
   max-height: 95vh;
   padding: 80px 20px 20px;
   display: flex;
   align-items: center;
   justify-content: center;
  }}
  
  .lightbox-image {{
   max-width: 100%;
   max-height: 100%;
   object-fit: contain;
   border-radius: 12px;
   box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
   animation: lightboxImageZoom 0.3s ease-out;
   user-select: none;
  }}
  
  @keyframes lightboxImageZoom {{
   from {{
    opacity: 0;
    transform: scale(0.95);
   }}
   to {{
    opacity: 1;
    transform: scale(1);
   }}
  }}
  
  .lightbox-footer {{
   position: absolute;
   bottom: 0;
   left: 0;
   right: 0;
   height: 100px;
   background: linear-gradient(0deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%);
   pointer-events: none;
  }}
  
  body.lightbox-open {{
   overflow: hidden;
  }}

  @media (max-width: 768px) {{
   .page_header {{
    padding: 10px 12px;
   }}
   
   .page_body {{
    padding: 20px 16px;
   }}
   
   .page_header .text {{
    font-size: 18px;
   }}
   
   .page_header .details {{
    font-size: 12px;
    gap: 8px;
   }}
   
   .theme-toggle {{
    width: 56px;
    height: 28px;
   }}
   
   .theme-toggle-thumb {{
    width: 20px;
    height: 20px;
    font-size: 10px;
   }}
   
   .dark .theme-toggle-thumb {{
    transform: translateX(28px);
   }}
   
   .message.default {{
    gap: 12px;
    padding: 8px 12px;
   }}
   
   .lightbox-content {{
    padding: 60px 12px 12px;
   }}
   
   .lightbox-btn {{
    width: 36px;
    height: 36px;
    font-size: 18px;
   }}
   
   .lightbox-btn svg {{
    width: 18px;
    height: 18px;
   }}
  }}
 </style>
 <script src="https://unpkg.com/@lottiefiles/lottie-player@2.0.2/dist/lottie-player.js"></script>
 <script>
  function toggleTheme() {{
   const html = document.documentElement;
   const currentTheme = html.classList.contains('dark') ? 'dark' : 'light';
   const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
   
   html.style.transition = 'background-color 0.3s ease, color 0.3s ease';
   
   if (newTheme === 'light') {{
    html.classList.remove('dark');
   }} else {{
    html.classList.add('dark');
   }}
   
   try {{
    localStorage.setItem('theme', newTheme);
   }} catch (e) {{}}
   
   setTimeout(() => {{
    html.style.transition = '';
   }}, 300);
   
   const button = document.getElementById('theme-toggle');
   if (button) {{
    button.style.transform = 'scale(0.95)';
    setTimeout(() => {{
     button.style.transform = '';
    }}, 150);
   }}
  }}
  
  document.addEventListener('DOMContentLoaded', function() {{
   try {{
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {{
     document.documentElement.classList.remove('dark');
    }}
   }} catch (e) {{}}
  }});
  
  function scrollToMessage(messageId) {{
   const targetElement = document.getElementById('message' + messageId);
   if (targetElement) {{
    targetElement.scrollIntoView({{
     behavior: 'smooth',
     block: 'center'
    }});

    targetElement.classList.remove('highlighted');
    void targetElement.offsetWidth;
    targetElement.classList.add('highlighted');

    setTimeout(() => {{
     targetElement.classList.remove('highlighted');
    }}, 2000);
   }}
  }}

  let currentLightboxImage = null;
  
  function openLightbox(imageSrc, imageAlt) {{
   const lightbox = document.getElementById('image-lightbox');
   const lightboxImage = document.getElementById('lightbox-image');
   
   if (lightbox && lightboxImage) {{
    currentLightboxImage = imageSrc;
    lightboxImage.src = imageSrc;
    lightboxImage.alt = imageAlt || 'Image';
    lightbox.classList.add('active');
    document.body.classList.add('lightbox-open');
   }}
  }}
  
  function closeLightbox() {{
   const lightbox = document.getElementById('image-lightbox');
   if (lightbox) {{
    lightbox.classList.remove('active');
    document.body.classList.remove('lightbox-open');
    currentLightboxImage = null;
   }}
  }}
  
  function downloadImage() {{
   if (currentLightboxImage) {{
    const link = document.createElement('a');
    link.href = currentLightboxImage;
    link.download = 'image';
    link.click();
   }}
  }}
  
  document.addEventListener('DOMContentLoaded', function() {{
   const replyElements = document.querySelectorAll('.reply-reference');
   replyElements.forEach(function(element) {{
    const replyToId = element.getAttribute('data-reply-to');
    if (replyToId) {{
     element.addEventListener('click', function() {{
      scrollToMessage(replyToId);
     }});
    }}
   }});
   
   const mediaImages = document.querySelectorAll('img.media, img.photo');
   mediaImages.forEach(function(img) {{
    img.style.cursor = 'pointer';
    img.addEventListener('click', function() {{
     openLightbox(this.src, this.alt);
    }});
   }});
   
   const lightbox = document.getElementById('image-lightbox');
   if (lightbox) {{
    lightbox.addEventListener('click', function(e) {{
     if (e.target === lightbox) {{
      closeLightbox();
     }}
    }});
   }}
   
   document.addEventListener('keydown', function(e) {{
    if (e.key === 'Escape') {{
     closeLightbox();
    }}
   }});
   
   const videoPlayers = document.querySelectorAll('.video-player-container');
   
   videoPlayers.forEach(function(container) {{
    const video = container.querySelector('.video-player-video');
    const playOverlay = container.querySelector('.video-player-play-overlay');
    const playBtnBig = container.querySelector('.video-player-play-btn-big');
    const playBtn = container.querySelector('.video-player-play-btn');
    const playBtnIcon = playBtn.querySelector('svg path');
    const progressContainer = container.querySelector('.video-player-progress-container');
    const progressBar = container.querySelector('.video-player-progress-bar');
    const progressTooltip = container.querySelector('.video-player-progress-tooltip');
    const timeCurrent = container.querySelector('.video-player-time-current');
    const timeTotal = container.querySelector('.video-player-time-total');
    const volumeBtn = container.querySelector('.video-player-volume-btn');
    const volumeBtnIcon = volumeBtn.querySelector('svg');
    const volumeSlider = container.querySelector('.video-player-volume-slider');
    const fullscreenBtn = container.querySelector('.video-player-fullscreen-btn');
    const controls = container.querySelector('.video-player-controls');
    const timestamp = container.querySelector('.video-player-timestamp');
    
    let isHovering = false;
    let hideControlsTimeout = null;
    let isSeeking = false;
    let wasPlayingBeforeSeek = false;
    let volumeBeforeMute = 1;
    
    function formatTime(seconds) {{
     const mins = Math.floor(seconds / 60);
     const secs = Math.floor(seconds % 60);
     return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }}
    
    function updateProgress() {{
     if (!video.duration) return;
     const progress = (video.currentTime / video.duration) * 100;
     progressBar.style.width = progress + '%';
     timeCurrent.textContent = formatTime(video.currentTime);
    }}
    
    function togglePlay() {{
     if (video.paused) {{
      video.play();
     }} else {{
      video.pause();
     }}
    }}
    
    function showControls() {{
     controls.classList.remove('hidden');
     if (video.paused) {{
      playOverlay.classList.remove('hidden');
     }}
     if (hideControlsTimeout) clearTimeout(hideControlsTimeout);
    }}
    
    function hideControlsAfterDelay() {{
     if (hideControlsTimeout) clearTimeout(hideControlsTimeout);
     if (!video.paused && !isHovering) {{
      hideControlsTimeout = setTimeout(function() {{
       controls.classList.add('hidden');
       playOverlay.classList.add('hidden');
      }}, 2000);
     }}
    }}
    
    video.addEventListener('play', function() {{
     container.classList.add('playing');
     playBtnIcon.setAttribute('d', 'M6 4h4v16H6V4zm8 0h4v16h-4V4z');
     playOverlay.classList.add('hidden');
     hideControlsAfterDelay();
    }});
    
    video.addEventListener('pause', function() {{
     container.classList.remove('playing');
     playBtnIcon.setAttribute('d', 'M8 5v14l11-7z');
     playOverlay.classList.remove('hidden');
     showControls();
    }});
    
    video.addEventListener('timeupdate', updateProgress);
    
    video.addEventListener('ended', function() {{
     container.classList.remove('playing');
     playOverlay.classList.remove('hidden');
     progressBar.style.width = '0%';
     video.currentTime = 0;
    }});
    
    video.addEventListener('loadedmetadata', function() {{
     timeTotal.textContent = formatTime(video.duration);
    }});
    
    video.addEventListener('click', function(e) {{
     e.preventDefault();
     togglePlay();
    }});
    
    playBtnBig.addEventListener('click', function(e) {{
     e.preventDefault();
     e.stopPropagation();
     togglePlay();
    }});
    
    playBtn.addEventListener('click', function(e) {{
     e.preventDefault();
     togglePlay();
    }});
    
    function updateTooltip(clientX) {{
     const rect = progressContainer.getBoundingClientRect();
     const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
     const hoverTime = percent * video.duration;
     
     if (!isNaN(hoverTime)) {{
      progressTooltip.textContent = formatTime(hoverTime);
      progressTooltip.style.left = (percent * 100) + '%';
     }}
    }}
    
    function seekToPosition(clientX) {{
     const rect = progressContainer.getBoundingClientRect();
     const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
     const newTime = percent * video.duration;
     if (!isNaN(newTime)) {{
      video.currentTime = newTime;
      progressBar.style.width = (percent * 100) + '%';
      timeCurrent.textContent = formatTime(newTime);
      updateTooltip(clientX);
     }}
    }}
    
    progressContainer.addEventListener('mousedown', function(e) {{
     isSeeking = true;
     wasPlayingBeforeSeek = !video.paused;
     if (wasPlayingBeforeSeek) {{
      video.pause();
     }}
     progressContainer.classList.add('seeking');
     seekToPosition(e.clientX);
     
     e.preventDefault();
    }});
    
    progressContainer.addEventListener('mousemove', function(e) {{
     updateTooltip(e.clientX);
    }});
    
    document.addEventListener('mousemove', function(e) {{
     if (isSeeking) {{
      seekToPosition(e.clientX);
     }}
    }});
    
    document.addEventListener('mouseup', function(e) {{
     if (isSeeking) {{
      isSeeking = false;
      progressContainer.classList.remove('seeking');
      seekToPosition(e.clientX);
      
      if (wasPlayingBeforeSeek) {{
       video.play();
      }}
     }}
    }});
    
    progressContainer.addEventListener('click', function(e) {{
     if (!isSeeking) {{
      seekToPosition(e.clientX);
     }}
    }});
    
    progressContainer.addEventListener('touchstart', function(e) {{
     isSeeking = true;
     wasPlayingBeforeSeek = !video.paused;
     if (wasPlayingBeforeSeek) {{
      video.pause();
     }}
     progressContainer.classList.add('seeking');
     const touch = e.touches[0];
     seekToPosition(touch.clientX);
     e.preventDefault();
    }});
    
    document.addEventListener('touchmove', function(e) {{
     if (isSeeking && e.touches.length > 0) {{
      const touch = e.touches[0];
      seekToPosition(touch.clientX);
     }}
    }});
    
    document.addEventListener('touchend', function(e) {{
     if (isSeeking) {{
      isSeeking = false;
      progressContainer.classList.remove('seeking');
      if (wasPlayingBeforeSeek) {{
       video.play();
      }}
     }}
    }});
    
    volumeBtn.addEventListener('click', function() {{
     if (video.muted || video.volume === 0) {{
      video.muted = false;
      const volumeToRestore = volumeBeforeMute > 0 ? volumeBeforeMute : 1;
      video.volume = volumeToRestore;
      volumeSlider.value = volumeToRestore;
      updateVolumeIcon(volumeToRestore);
     }} else {{
      volumeBeforeMute = video.volume;
      video.muted = true;
      volumeSlider.value = 0;
      updateVolumeIcon(0);
     }}
    }});
    
    volumeSlider.addEventListener('input', function() {{
     const newVolume = parseFloat(volumeSlider.value);
     video.volume = newVolume;
     video.muted = false;
     
     if (newVolume > 0) {{
      volumeBeforeMute = newVolume;
     }}
     
     updateVolumeIcon(newVolume);
    }});
    
    function updateVolumeIcon(volume) {{
     if (volume === 0 || video.muted) {{
      volumeBtnIcon.innerHTML = '<path d="M11 5L6 9H2v6h4l5 4V5zM23 9l-6 6m0-6l6 6"/>';
     }} else if (volume < 0.5) {{
      volumeBtnIcon.innerHTML = '<path d="M11 5L6 9H2v6h4l5 4V5zM15.54 8.46a5 5 0 0 1 0 7.07"/>';
     }} else {{
      volumeBtnIcon.innerHTML = '<path d="M11 5L6 9H2v6h4l5 4V5zM15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"/>';
     }}
    }}
    
    fullscreenBtn.addEventListener('click', function() {{
     if (!document.fullscreenElement) {{
      if (container.requestFullscreen) {{
       container.requestFullscreen();
      }} else if (container.webkitRequestFullscreen) {{
       container.webkitRequestFullscreen();
      }} else if (container.mozRequestFullScreen) {{
       container.mozRequestFullScreen();
      }} else if (container.msRequestFullscreen) {{
       container.msRequestFullscreen();
      }}
     }} else {{
      if (document.exitFullscreen) {{
       document.exitFullscreen();
      }} else if (document.webkitExitFullscreen) {{
       document.webkitExitFullscreen();
      }} else if (document.mozCancelFullScreen) {{
       document.mozCancelFullScreen();
      }} else if (document.msExitFullscreen) {{
       document.msExitFullscreen();
      }}
     }}
    }});
    
    container.addEventListener('mouseenter', function() {{
     isHovering = true;
     showControls();
    }});
    
    container.addEventListener('mouseleave', function() {{
     isHovering = false;
     hideControlsAfterDelay();
    }});
    
    container.addEventListener('mousemove', function() {{
     showControls();
     hideControlsAfterDelay();
    }});
    
    video.addEventListener('playing', function() {{
     playOverlay.classList.add('hidden');
    }});
    
    updateVolumeIcon(video.volume);
   }});
   
   const videoCircleContainers = document.querySelectorAll('.video-circle-container');
   
   videoCircleContainers.forEach(function(container) {{
    const video = container.querySelector('.video-circle');
    const playIcon = container.querySelector('.video-circle-play-icon');
    const playIconSvg = playIcon.querySelector('svg path');
    const durationBadge = container.querySelector('.video-circle-duration');
    const progressRing = container.querySelector('.video-circle-progress-ring');
    const duration = parseFloat(container.getAttribute('data-duration')) || 0;
    
    const radius = 96;
    const circumference = 2 * Math.PI * radius;
    
    function formatTime(seconds) {{
     const mins = Math.floor(seconds / 60);
     const secs = Math.floor(seconds % 60);
     return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }}
    
    function updateProgress() {{
     if (!video.duration || video.paused) return;
     const progress = video.currentTime / video.duration;
     const offset = circumference * (1 - progress);
     progressRing.style.strokeDashoffset = offset;
     
     if (durationBadge) {{
      durationBadge.textContent = formatTime(video.currentTime);
     }}
    }}
    
    function togglePlay() {{
     if (video.paused) {{
      video.play();
     }} else {{
      video.pause();
     }}
    }}
    
    container.addEventListener('click', togglePlay);
    
    video.addEventListener('play', function() {{
     container.classList.add('playing');
     playIcon.classList.remove('paused');
     
     playIconSvg.setAttribute('d', 'M6 4h4v16H6V4zm8 0h4v16h-4V4z');
    }});
    
    video.addEventListener('pause', function() {{
     container.classList.remove('playing');
     playIcon.classList.add('paused');
     
     playIconSvg.setAttribute('d', 'M8 5v14l11-7z');
     
     if (durationBadge && duration > 0) {{
      durationBadge.textContent = formatTime(duration);
     }}
    }});
    
    video.addEventListener('timeupdate', updateProgress);
    
    video.addEventListener('ended', function() {{
     progressRing.style.strokeDashoffset = circumference;
     container.classList.remove('playing');
     if (durationBadge && duration > 0) {{
      durationBadge.textContent = formatTime(duration);
     }}
    }});
    
    progressRing.style.strokeDasharray = circumference;
    progressRing.style.strokeDashoffset = circumference;
   }});
   
   const voiceMessages = document.querySelectorAll('.voice-message');
   
   voiceMessages.forEach(function(voiceMsg) {{
    const audio = voiceMsg.querySelector('.voice-audio');
    const playBtn = voiceMsg.querySelector('.voice-play-btn');
    const playIconSvg = playBtn.querySelector('svg path');
    const durationDisplay = voiceMsg.querySelector('.voice-duration');
    const waveformBars = voiceMsg.querySelectorAll('.voice-waveform-bar');
    const duration = parseFloat(voiceMsg.getAttribute('data-duration')) || 0;
    
    function formatTime(seconds) {{
     const mins = Math.floor(seconds / 60);
     const secs = Math.floor(seconds % 60);
     return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }}
    
    function updateWaveform() {{
     if (!audio.duration) return;
     const progress = audio.currentTime / audio.duration;
     const activeBarCount = Math.floor(progress * waveformBars.length);
     
     waveformBars.forEach(function(bar, index) {{
      if (index < activeBarCount) {{
       bar.classList.add('active');
      }} else {{
       bar.classList.remove('active');
      }}
     }});
     
     const remaining = duration - audio.currentTime;
     durationDisplay.textContent = formatTime(remaining > 0 ? remaining : 0);
    }}
    
    function togglePlay() {{
     if (audio.paused) {{
      audio.play();
     }} else {{
      audio.pause();
     }}
    }}
    
    voiceMsg.addEventListener('click', function(e) {{
     if (e.target === audio) return;
     togglePlay();
    }});
    
    audio.addEventListener('play', function() {{
     voiceMsg.classList.add('playing');
     playBtn.classList.add('playing');
     
     playIconSvg.setAttribute('d', 'M6 4h4v16H6V4zm8 0h4v16h-4V4z');
     playIconSvg.classList.remove('play-icon');
     playIconSvg.classList.add('pause-icon');
    }});
    
    audio.addEventListener('pause', function() {{
     voiceMsg.classList.remove('playing');
     playBtn.classList.remove('playing');
     
     playIconSvg.setAttribute('d', 'M8 5v14l11-7z');
     playIconSvg.classList.remove('pause-icon');
     playIconSvg.classList.add('play-icon');
    }});
    
    audio.addEventListener('timeupdate', updateWaveform);
    
    audio.addEventListener('ended', function() {{
     voiceMsg.classList.remove('playing');
     playBtn.classList.remove('playing');
     
     waveformBars.forEach(function(bar) {{
      bar.classList.remove('active');
     }});
     
     if (duration > 0) {{
      durationDisplay.textContent = formatTime(duration);
     }}
     
     playIconSvg.setAttribute('d', 'M8 5v14l11-7z');
     playIconSvg.classList.remove('pause-icon');
     playIconSvg.classList.add('play-icon');
    }});
   }});
  }});
 </script>
</head>
<body>
 <div class="page_wrap">
  <div class="page_header">
   <div class="content">
    <div class="header-top">
     <div>
      <div class="text bold">
{chat_name}
      </div>
      <div class="details">
       <span>📅 Exported on {export_date}</span>
       <span class="separator">•</span>
       <span>{info_text}</span>
      </div>
     </div>
    <button id="theme-toggle" class="theme-toggle" onclick="toggleTheme()">
     <div class="theme-toggle-track"></div>
     <div class="theme-toggle-thumb"></div>
    </button>
    </div>
   </div>
  </div>
  <div class="page_body">
   <div class="history">
"""
        
    def _generate_html(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        
        current_user_id = get_user_config().getClientUserId()
        current_account = UserConfig.selectedAccount
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        
        media_handling = self._get_export_setting("media_handling", 0)
        want_media = (media_handling == 2)
        want_avatars = self._get_export_setting("include_avatars", True)
        
        max_media_mb_str = self._get_export_setting("max_size_mb", "100")
        try:
            max_media_mb = int(max_media_mb_str) if max_media_mb_str else 10
        except:
            max_media_mb = 10
        
        log(f"[ChatExport] Collecting user IDs from {len(messages)} messages...")
        all_user_ids = set()
        for msg in messages:
            from_id = msg.get("from_id", 0)
            if from_id > 0:
                all_user_ids.add(from_id)

            if "fwd_from_id" in msg:
                fwd_id = msg.get("fwd_from_id", 0)
                if fwd_id > 0:
                    all_user_ids.add(fwd_id)

        if all_user_ids:
            log(f"[ChatExport] Found {len(all_user_ids)} unique users in messages")
            self._load_missing_users(all_user_ids)

        msg_id_map = {msg.get("id"): msg for msg in messages if msg.get("id")}
        log(f"[ChatExport] Created message ID map with {len(msg_id_map)} messages for reply lookups")

        media_manager = None
        if want_media or want_avatars:
            media_manager = MediaDownloadManager(
                account_id=current_account,
                max_workers=6,
                max_media_mb=max_media_mb
            )

            log(f"[ChatExport] Preparing media download: media={want_media}, avatars={want_avatars}, max_mb={max_media_mb}")

            user_ids_seen = set()

            for msg in messages:
                from_id = msg.get("from_id", 0)

                if want_avatars and from_id and from_id not in user_ids_seen:
                    user_ids_seen.add(from_id)
                    sender_user = self._get_user_object(from_id)
                    if sender_user:
                        media_manager.add_avatar_download(from_id, sender_user)
                
                if want_media and msg.get("media"):
                    media_type = _get_media_type_from_message(msg)
                    tlrpc_msg = self._reconstruct_tlrpc_message(msg)
                    if tlrpc_msg:
                        media_manager.add_media_download(msg.get("id", 0), tlrpc_msg, media_type)
            
            log(f"[ChatExport] Starting parallel download of {len(user_ids_seen)} avatars and media...")
            download_start = time.time()
            media_manager.execute_downloads()
            download_time = time.time() - download_start
            log(f"[ChatExport] Download completed in {download_time:.2f}s")

            log(f"[ChatExport] Attaching media data to {len(messages)} messages...")
            attach_start = time.time()

            for msg in messages:
                msg_id = msg.get("id", 0)

                if want_avatars:
                    from_id = msg.get("from_id", 0)
                    if from_id:
                        avatar_data = media_manager.get_result(f"avatar_{from_id}")
                        if avatar_data:
                            msg["_avatar_data_uri"] = avatar_data

                if want_media and msg.get("media"):
                    media_data = media_manager.get_result(f"media_{msg_id}")
                    if media_data:
                        msg["_media_data_uri"] = media_data

            attach_time = time.time() - attach_start
            log(f"[ChatExport] Media data attached in {attach_time:.2f}s")

        log(f"[ChatExport] Generating HTML for {len(messages)} messages...")
        html_start = time.time()

        html = self._get_html_template(chat_name, export_date, f"{len(messages)} messages")
        
        include_timestamps = self._get_export_setting("include_timestamps", True)
        group_messages = self._get_export_setting("group_messages", True)
        
        if not messages:
            html += """
    <div class="message service">
     <div class="body details">
No messages available for export.
     </div>
    </div>
"""
        else:
            last_sender = None
            last_date = None

            log(f"[ChatExport] Rendering {len(messages)} messages to HTML...")
            render_start = time.time()
            msg_count = 0

            html_parts = [html]
            
            progress_interval = 1000 if len(messages) > 3000 else 500

            for msg in messages:
                if self.cancel_requested:
                    log("[ChatExport] HTML rendering cancelled by user")
                    break
                    
                date_obj = time.localtime(msg.get("date", 0))
                msg_date = time.strftime("%d %B %Y", date_obj)
                if msg_date.startswith("0"):
                    msg_date = msg_date[1:]

                if last_date != msg_date:
                    html_parts.append(f"""
    <div class="date-divider" id="message-date-{msg.get('date', 0)}">
     <div class="line"></div>
     <span class="text">{msg_date}</span>
     <div class="line"></div>
    </div>
""")
                    last_date = msg_date

                html_parts.append(self._format_message_html(msg, current_user_id, include_timestamps, group_messages, last_sender, msg_id_map))
                last_sender = msg.get("from_id")

                msg_count += 1
                if msg_count % progress_interval == 0:
                    progress_percent = int((msg_count / len(messages)) * 100)
                    progress_text = self._t("rendered_messages", current=msg_count, total=len(messages))
                    self._update_progress(progress_text, progress_percent)
                    log(f"[ChatExport] {progress_text}")

            html = "".join(html_parts)

            render_time = time.time() - render_start
            log(f"[ChatExport] HTML rendering completed in {render_time:.2f}s")

        html += """
   </div>
  </div>
 </div>
 
 <!-- Image Lightbox -->
 <div id="image-lightbox" class="lightbox">
  <div class="lightbox-header">
   <div class="lightbox-controls">
    <button class="lightbox-btn" onclick="downloadImage()" title="Download image">
     <svg viewBox="0 0 24 24">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
      <polyline points="7 10 12 15 17 10"></polyline>
      <line x1="12" y1="15" x2="12" y2="3"></line>
     </svg>
    </button>
   </div>
   <button class="lightbox-btn" onclick="closeLightbox()" title="Close (Esc)">
    <svg viewBox="0 0 24 24">
     <line x1="18" y1="6" x2="6" y2="18"></line>
     <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
   </button>
  </div>
  
  <div class="lightbox-content" onclick="event.stopPropagation()">
   <img id="lightbox-image" src="" alt="" class="lightbox-image">
  </div>
  
  <div class="lightbox-footer"></div>
 </div>
</body>
</html>
"""

        html_time = time.time() - html_start
        log(f"[ChatExport] Total HTML generation time: {html_time:.2f}s, size: {len(html)} bytes")

        return html
        
    def _format_message_html(self, msg: Dict[str, Any], current_user_id: int,
                            include_timestamps: bool, group_messages: bool,
                            last_sender: Optional[int], msg_id_map: Dict[int, Dict[str, Any]]) -> str:

        if msg.get("action", False):
            action_type = msg.get("action_type", "")
            from_id = msg.get("from_id", 0)
            sender_name = self._get_sender_name(from_id)
            action_text = self._format_service_message(msg, action_type, sender_name)
            return f"""
    <div class="message service" id="message{msg.get('id', 0)}">
     <div class="body details">
{action_text}
     </div>
    </div>
"""
        
        from_id = msg.get("from_id", 0)
        sender_name = self._get_sender_name(from_id)
        
        timestamp = ""
        if include_timestamps:
            msg_time = time.strftime("%H:%M", time.localtime(msg.get("date", 0)))
            timestamp = f' title="{time.strftime("%d.%m.%Y %H:%M:%S", time.localtime(msg.get("date", 0)))}"'
            timestamp_display = msg_time
        else:
            timestamp_display = ""
        
        html = f"""
    <div class="message default" id="message{msg.get('id', 0)}">
"""
        
        avatar_data_uri = msg.get("_avatar_data_uri")
        html += f"""
     <div class="userpic_wrap">
{self._generate_userpic_html(from_id, avatar_data_uri)}
     </div>
"""
        
        html += """
     <div class="body">
"""
        
        html += f"""
      <div class="message-header">
       <span class="from_name">{sender_name}</span>
"""
        
        if include_timestamps:
            edited_mark = " <span class='edited'>(edited)</span>" if msg.get("edited", False) else ""
            html += f"""
       <span class="date"{timestamp}>{timestamp_display}{edited_mark}</span>
"""
        
        html += """
      </div>
"""
        
        if msg.get("forwarded", False):
            fwd_name = msg.get("fwd_from_name", "")

            if not fwd_name and "fwd_from_id" in msg:
                fwd_id = msg["fwd_from_id"]
                fwd_name = self._get_sender_name(fwd_id)

            post_author = msg.get("fwd_post_author", "")
            if post_author and fwd_name and fwd_name != post_author and fwd_name != "Unknown":
                fwd_display = f"{fwd_name} ({post_author})"
            elif post_author:
                fwd_display = post_author
            elif fwd_name and fwd_name != "Unknown":
                fwd_display = fwd_name
            else:
                fwd_display = "Forwarded message"

            fwd_display_escaped = fwd_display.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

            html += f"""
      <div class="forwarded-header">
Forwarded from {fwd_display_escaped}
      </div>
"""
        
        if "reply_to_msg_id" in msg:
            reply_to_id = msg["reply_to_msg_id"]

            if reply_to_id in msg_id_map:
                replied_msg = msg_id_map[reply_to_id]
                reply_sender_name = self._get_sender_name(replied_msg.get("from_id", 0))
                reply_text = replied_msg.get("text", "")

                if not reply_text:
                    if replied_msg.get("media"):
                        media_type = replied_msg.get("media", {}).get("type", "unknown")
                        if media_type == "photo":
                            reply_text = "📷 Photo"
                        elif media_type == "video":
                            reply_text = "🎥 Video"
                        elif media_type == "voice":
                            reply_text = "🎤 Voice message"
                        elif media_type == "audio":
                            reply_text = "🎵 Audio"
                        elif media_type == "sticker":
                            reply_text = "Sticker"
                        elif media_type == "sticker_video":
                            reply_text = "Video Sticker"
                        elif media_type == "sticker_animated":
                            reply_text = "Animated Sticker"
                        elif media_type == "gif":
                            reply_text = "GIF"
                        elif media_type == "document":
                            reply_text = "📎 File"
                        else:
                            reply_text = "[Media]"
                    else:
                        reply_text = "[Message]"

                if len(reply_text) > 100:
                    reply_text = reply_text[:100] + "..."

                reply_text_escaped = reply_text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
                reply_sender_escaped = reply_sender_name.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

                html += f"""
      <div class="reply-reference" data-reply-to="{reply_to_id}" title="Click to scroll to message">
       <div class="reply-author">{reply_sender_escaped}</div>
       <div class="reply-text">{reply_text_escaped}</div>
      </div>
"""
            else:
                html += f"""
      <div class="reply-reference reply-not-found" title="Message not found (may be outside loaded range or deleted)">
       <div class="reply-author">Reply to message #{reply_to_id}</div>
       <div class="reply-text">Message not available in this export</div>
      </div>
"""
        
        media = msg.get("media")
        if media:
            media_type = media.get("type", "unknown")
            msg_id = msg.get("id", 0)
            
            media_data_uri = msg.get("_media_data_uri")
            
            if media_data_uri:
                if media_type == "sticker":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="sticker" src="{media_data_uri}" loading="lazy" alt="Sticker {emoji}" title="{emoji}"/>
      </div>
"""
                elif media_type == "sticker_video":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <video class="sticker-video" src="{media_data_uri}" autoplay loop muted playsinline alt="Video Sticker {emoji}" title="{emoji}"></video>
      </div>
"""
                elif media_type == "sticker_animated":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="sticker-animated-container" title="Animated Sticker {emoji}">
        <lottie-player class="sticker-animated" src="{media_data_uri}" background="transparent" speed="1" style="width: 200px; height: 200px;" loop autoplay></lottie-player>
        <div class="sticker-emoji">{emoji}</div>
       </div>
      </div>
"""
                elif media_type == "gif":
                    html += f"""
      <div class="media_wrap clearfix">
       <video class="gif" src="{media_data_uri}" autoplay loop muted playsinline></video>
      </div>
"""
                elif media_type == "video_circle":
                    duration = media.get("duration", 0)
                    duration_str = f"{int(duration // 60)}:{int(duration % 60):02d}" if duration > 0 else "0:00"
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="video-circle-wrapper">
        <div class="video-circle-container" data-duration="{duration}">
         <!-- Progress ring SVG -->
         <svg class="video-circle-progress" viewBox="0 0 200 200">
          <circle class="video-circle-progress-ring" cx="100" cy="100" r="96" 
                  stroke-dasharray="{2 * 3.14159 * 96}" 
                  stroke-dashoffset="{2 * 3.14159 * 96}"/>
         </svg>
         
         <!-- Video thumbnail wrapper -->
         <div class="video-circle-thumbnail">
          <video class="video-circle" src="{media_data_uri}" loop playsinline preload="metadata"></video>
          <div class="video-circle-overlay"></div>
         </div>
         
         <!-- Play/Pause button -->
         <div class="video-circle-play-icon">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
           <path d="M8 5v14l11-7z"/>
          </svg>
         </div>
         
         <!-- Duration badge -->
         <div class="video-circle-duration">{duration_str}</div>
        </div>
       </div>
      </div>
"""
                elif media_type == "video":
                    duration = media.get("duration", 0)
                    duration_str = f"{int(duration // 60)}:{int(duration % 60):02d}" if duration > 0 else "0:00"
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="video-player-wrapper">
        <div class="video-player-container" data-duration="{duration}">
         <!-- Video element -->
         <video class="video-player-video" src="{media_data_uri}" preload="metadata"></video>
         
         <!-- Play overlay button -->
         <div class="video-player-play-overlay">
          <button class="video-player-play-btn-big" aria-label="Play">
           <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 5v14l11-7z"/>
           </svg>
          </button>
         </div>
         
         <!-- Timestamp badge (shown when not playing) -->
         <div class="video-player-timestamp">{duration_str}</div>
         
         <!-- Controls bar -->
         <div class="video-player-controls">
          <!-- Progress bar -->
          <div class="video-player-progress-container">
           <div class="video-player-progress-bar"></div>
           <div class="video-player-progress-tooltip">0:00</div>
          </div>
          
          <!-- Control buttons -->
          <div class="video-player-controls-row">
           <div class="video-player-controls-left">
            <!-- Play/Pause button -->
            <button class="video-player-play-btn" aria-label="Play/Pause">
             <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 5v14l11-7z"/>
             </svg>
            </button>
            
            <!-- Time display -->
            <div class="video-player-time">
             <span class="video-player-time-current">0:00</span> / <span class="video-player-time-total">{duration_str}</span>
            </div>
           </div>
           
           <div class="video-player-controls-right">
            <!-- Volume control -->
            <div class="video-player-volume">
             <button class="video-player-volume-btn" aria-label="Mute/Unmute">
              <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
               <path d="M11 5L6 9H2v6h4l5 4V5zM15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14"/>
              </svg>
             </button>
             <input type="range" class="video-player-volume-slider" min="0" max="1" step="0.01" value="1" aria-label="Volume"/>
            </div>
            
            <!-- Fullscreen button -->
            <button class="video-player-fullscreen-btn" aria-label="Fullscreen">
             <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
             </svg>
            </button>
           </div>
          </div>
         </div>
        </div>
       </div>
      </div>
"""
                elif media_type == "voice":
                    duration = media.get("duration", 0)
                    duration_str = f"{int(duration // 60)}:{int(duration % 60):02d}" if duration > 0 else "0:00"
                    
                    waveform_bars = ""
                    num_bars = 40
                    for i in range(num_bars):
                        height = random.randint(30, 100)
                        waveform_bars += f'<div class="voice-waveform-bar" style="height: {height}%" data-index="{i}"></div>'
                    
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="voice-message" data-duration="{duration}">
        <!-- Hidden audio element -->
        <audio class="voice-audio" src="{media_data_uri}" preload="metadata"></audio>
        
        <!-- Play/Pause button -->
        <div class="voice-play-btn">
         <svg class="play-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path d="M8 5v14l11-7z"/>
         </svg>
        </div>
        
        <!-- Waveform -->
        <div class="voice-waveform">
         {waveform_bars}
        </div>
        
        <!-- Duration -->
        <div class="voice-duration">{duration_str}</div>
       </div>
      </div>
"""
                elif media_type == "audio":
                    title = media.get("title", "")
                    performer = media.get("performer", "")
                    audio_label = f"{performer} - {title}".strip(" -") if (title or performer) else "Audio"
                    html += f"""
      <div class="media_wrap clearfix">
       <div style="margin-top: 8px;">
        <div style="color: #8A8A8A; font-size: 12px; margin-bottom: 4px;">🎵 {audio_label}</div>
        <audio class="media" src="{media_data_uri}" controls></audio>
       </div>
      </div>
"""
                elif media_type == "photo":
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="media" src="{media_data_uri}" loading="lazy" alt="Photo"/>
      </div>
"""
                elif media_type == "document":
                    filename = media.get("filename", "document")
                    size = media.get("size", 0)
                    size_str = f"{size / 1024:.1f} KB" if size < 1024*1024 else f"{size / 1024 / 1024:.1f} MB"
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="document-card">
        <div class="document-icon">📎</div>
        <div class="document-info">
         <div class="document-name">{filename}</div>
         <div class="document-size">{size_str}</div>
        </div>
        <a class="document-download" href="{media_data_uri}" download="{filename}">⬇</a>
       </div>
      </div>
"""
                else:
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="media" src="{media_data_uri}" loading="lazy" alt="{media_type}"/>
      </div>
"""
            else:
                media_emoji = {
                    "photo": "📷",
                    "video": "🎥",
                    "document": "📎",
                    "audio": "🎵",
                    "voice": "🎤",
                    "sticker": "🎭",
                    "sticker_video": "🎭",
                    "sticker_animated": "🎭",
                    "gif": "🎞️",
                    "video_circle": "🔵",
                    "location": "📍",
                    "venue": "📍",
                    "contact": "👤",
                    "poll": "📊",
                    "webpage": "🔗",
                    "game": "🎮",
                    "invoice": "💳"
                }.get(media_type, "📎")
                
                media_text = {
                    "photo": "Photo",
                    "video": "Video",
                    "document": "Document",
                    "audio": "Audio",
                    "voice": "Voice Message",
                    "sticker": "Sticker",
                    "sticker_video": "Video Sticker",
                    "sticker_animated": "Animated Sticker",
                    "gif": "GIF",
                    "video_circle": "Video Message",
                    "location": "Location",
                    "venue": "Venue",
                    "contact": "Contact",
                    "poll": "Poll",
                    "webpage": "Link Preview",
                    "game": "Game",
                    "invoice": "Invoice"
                }.get(media_type, media_type.title())
                
                extra_info = ""
                if media.get("filename"):
                    extra_info = f" • {media.get('filename')}"
                elif media.get("title"):
                    extra_info = f" • {media.get('title')}"
                elif media.get("duration"):
                    duration = media.get("duration", 0)
                    extra_info = f" • {int(duration // 60)}:{int(duration % 60):02d}"
                
                html += f"""
      <div class="media_wrap clearfix">
       <div class="media-placeholder">
{media_emoji} {media_text}{extra_info}
       </div>
      </div>
"""
        
        text = msg.get("text", "")
        if text:
            text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            url_pattern = r'(https?://[^\s<>"&]+|www\.[^\s<>"&]+)'
            text = re.sub(url_pattern, r'<a href="\1">\1</a>', text)
            
            html += f"""
      <div class="text">
{text}
      </div>
"""
        
        html += """
     </div>
    </div>
"""
        
        return html
    
    def _format_service_message(self, msg: Dict[str, Any], action_type: str, sender_name: str = "") -> str:
        
        actor = sender_name if sender_name and sender_name != "Unknown" else "User"
        
        if "ChatAddUser" in action_type:
            return f"{actor} added users to the group"
        elif "ChatDeleteUser" in action_type:
            return f"{actor} left the group"
        elif "ChatJoinedByLink" in action_type:
            return f"{actor} joined the group via invite link"
        elif "ChatJoinedByRequest" in action_type:
            return f"{actor} joined the group"
        elif "UserJoined" in action_type:
            return f"{actor} joined Telegram"
        
        elif "ChatCreate" in action_type:
            return f"{actor} created the group"
        elif "ChannelCreate" in action_type:
            return f"{actor} created the channel"
        elif "ChatEditTitle" in action_type:
            return f"{actor} changed the group title"
        elif "ChatEditPhoto" in action_type:
            return f"{actor} changed the group photo"
        elif "ChatDeletePhoto" in action_type:
            return f"{actor} removed the group photo"
        elif "ChatMigrateTo" in action_type:
            return f"{actor} upgraded this group to a supergroup"
        elif "ChannelMigrateFrom" in action_type:
            return "migrated from a basic group"
        
        elif "PinMessage" in action_type:
            return f"{actor} pinned a message"
        elif "HistoryClear" in action_type:
            return f"{actor} cleared chat history"
        
        elif "PhoneCall" in action_type:
            return "📞 Phone call"
        elif "GroupCall" in action_type:
            return "📞 Group call"
        elif "GroupCallScheduled" in action_type:
            return "📅 Scheduled a group call"
        elif "InviteToGroupCall" in action_type:
            return "invited members to group call"
        elif "ConferenceCall" in action_type:
            return "📞 Conference call"
        
        elif "ScreenshotTaken" in action_type:
            return "📸 Screenshot taken"
        elif "SecureValuesSent" in action_type:
            return "🔐 Sent Telegram Passport data"
        elif "ContactSignUp" in action_type:
            return "joined Telegram"
        
        elif "PaymentSent" in action_type:
            return "💳 Payment sent"
        elif "PaymentRefunded" in action_type:
            return "💸 Payment refunded"
        elif "GiftPremium" in action_type:
            return "🎁 Sent Telegram Premium gift"
        elif "GiftStars" in action_type:
            return "⭐ Sent Telegram Stars"
        elif "GiftTon" in action_type:
            return "💎 Sent TON gift"
        elif "GiftCode" in action_type:
            return "🎁 Sent gift code"
        elif "StarGift" in action_type:
            return "⭐ Sent star gift"
        elif "StarGiftUnique" in action_type:
            return "⭐ Sent unique star gift"
        elif "PaidMessagesPrice" in action_type:
            return "💰 Set paid messages price"
        elif "PaidMessagesRefunded" in action_type:
            return "💸 Refunded paid messages"
        
        elif "GameScore" in action_type:
            return "🎮 Scored in game"
        elif "BotAllowed" in action_type:
            return "🤖 Allowed bot to send messages"
        elif "AttachMenuBotAllowed" in action_type:
            return "🤖 Added bot to attachment menu"
        elif "WebViewDataSent" in action_type:
            return "📤 Sent data from Web App"
        elif "RequestedPeer" in action_type:
            return "👤 Shared a contact"
        
        elif "SetMessagesTTL" in action_type or "TTLChange" in action_type:
            return "⏱️ Changed self-destruct timer"
        elif "SetChatTheme" in action_type:
            return "🎨 Changed chat theme"
        elif "SetChatWallPaper" in action_type or "SetSameChatWallPaper" in action_type:
            return "🖼️ Changed chat wallpaper"
        elif "UserUpdatedPhoto" in action_type:
            return "📷 Updated profile photo"
        elif "SuggestProfilePhoto" in action_type:
            return "📷 Suggested a profile photo"
        
        elif "TopicCreate" in action_type:
            return "📁 Created topic"
        elif "TopicEdit" in action_type:
            return "📝 Edited topic"
        
        elif "GiveawayLaunch" in action_type:
            return "🎉 Launched giveaway"
        elif "GiveawayResults" in action_type:
            return "🏆 Announced giveaway results"
        elif "PrizeStars" in action_type:
            return "⭐ Won prize stars"
        elif "BoostApply" in action_type:
            return "🚀 Applied boost"
        elif "SuggestedPostSuccess" in action_type:
            return "✅ Post suggestion accepted"
        elif "SuggestedPostRefund" in action_type:
            return "💸 Post suggestion refunded"
        elif "SuggestedPostApproval" in action_type:
            return "👍 Post suggestion pending approval"
        
        elif "CustomAction" in action_type:
            return "ℹ️ Custom action"
        elif "GeoProximityReached" in action_type:
            return "📍 Nearby"
        elif "PhoneNumberRequest" in action_type:
            return "📱 Requested phone number"
        elif "CreatedBroadcastList" in action_type:
            return "📢 Created broadcast list"
        elif "LoginUnknownLocation" in action_type:
            return "🔐 Login from unknown location"
        elif "Empty" in action_type:
            return ""
        
        else:
            clean_name = action_type.replace("TLRPC$TL_messageAction", "")
            clean_name = clean_name.replace("TL_messageAction", "")
            import re
            clean_name = re.sub(r'([a-z])([A-Z])', r'\1 \2', clean_name)
            return f"[{clean_name}]"
        
    def _get_sender_name(self, user_id: int) -> str:
        try:
            if user_id == 0:
                return "Unknown"

            mc = get_messages_controller()

            if user_id > 0:
                user = mc.getUser(user_id)
                if user:
                    name = user.first_name or ""
                    if user.last_name:
                        name += " " + user.last_name
                    name = name.strip()

                    if not name and hasattr(user, 'username') and user.username:
                        name = f"@{user.username}"

                    if not name:
                        if hasattr(user, 'deleted') and user.deleted:
                            return "Deleted Account"
                        return f"User {user_id}"

                    return name
            else:
                chat = mc.getChat(-user_id)
                if chat:
                    title = getattr(chat, 'title', None)
                    if title:
                        title = title.strip()
                    
                    username = getattr(chat, 'username', None)
                    
                    is_broadcast = getattr(chat, 'broadcast', False)
                    is_megagroup = getattr(chat, 'megagroup', False)
                    
                    if not title and not username:
                        log(f"[ChatExport] Chat {-user_id}: title='{title}', username='{username}', broadcast={is_broadcast}, megagroup={is_megagroup}")
                    
                    if title and username:
                        return f"{title} (@{username})"
                    elif title:
                        return title
                    elif username:
                        return f"@{username}"
                    
                    if is_broadcast:
                        log(f"[ChatExport] Warning: Channel {-user_id} has no title or username!")
                        return f"Channel_{-user_id}"
                    elif is_megagroup:
                        log(f"[ChatExport] Warning: Supergroup {-user_id} has no title or username!")
                        return f"Supergroup_{-user_id}"
                    else:
                        log(f"[ChatExport] Warning: Group {-user_id} has no title or username!")
                        return f"Group_{-user_id}"
                else:
                    log(f"[ChatExport] Warning: Could not get chat object for {-user_id}")

            return f"User_{user_id}"
        except Exception as e:
            log(f"[ChatExport] Error getting sender name for {user_id}: {e}")
            return f"User {user_id}"
    
    def _get_user_color(self, user_id: int) -> int:
        return (abs(user_id) % 8) + 1
    
    def _get_user_initial(self, user_id: int) -> str:
        try:
            name = self._get_sender_name(user_id)
            if name and len(name) > 0:
                return name[0].upper()
            return "U"
        except:
            return "U"
    
    def _get_chat_type(self, chat_id: int) -> str:
        try:
            if chat_id > 0:
                return "User"
            
            mc = get_messages_controller()
            chat = mc.getChat(-chat_id)
            
            if not chat:
                return "Unknown"
            
            if hasattr(chat, 'broadcast') and chat.broadcast:
                return "Channel"
            
            if hasattr(chat, 'megagroup') and chat.megagroup:
                return "Supergroup"
            
            if hasattr(chat, 'title') and chat.title:
                return "Group"
            
            return "Unknown"
            
        except Exception as e:
            log(f"[ChatExport] Error determining chat type for {chat_id}: {e}")
            return "Unknown"
    
    def _generate_userpic_html(self, user_id: int, avatar_data_uri: str = None) -> str:
        if avatar_data_uri:
            initial = self._get_user_initial(user_id)
            return f'''
       <img class="userpic" src="{avatar_data_uri}" alt="{initial}" style="width: 42px; height: 42px; border-radius: 50%; object-fit: cover;">'''
        else:
            color_class = self._get_user_color(user_id)
            initial = self._get_user_initial(user_id)
            
            return f'''
       <div class="userpic userpic{color_class}" style="width: 42px; height: 42px">
        <div class="initials" style="line-height: 42px">
{initial}
        </div>
       </div>'''
    
    def _load_missing_users(self, user_ids: set):
        try:
            if not user_ids:
                return

            mc = get_messages_controller()

            missing_ids = []
            cached_count = 0
            for user_id in user_ids:
                if user_id > 0:
                    user = mc.getUser(user_id)
                    if not user:
                        missing_ids.append(user_id)
                    else:
                        cached_count += 1

            log(f"[ChatExport] User cache status: {cached_count} cached, {len(missing_ids)} missing out of {len(user_ids)} total")

            if not missing_ids:
                return

            log(f"[ChatExport] Attempting to resolve {len(missing_ids)} missing users...")

            resolved_count = 0
            for user_id in missing_ids:
                try:
                    input_user = mc.getInputUser(user_id)
                    if input_user and hasattr(input_user, 'user_id'):
                        user = mc.getUser(user_id)
                        if user:
                            resolved_count += 1
                except Exception:
                    pass

            if resolved_count > 0:
                log(f"[ChatExport] Resolved {resolved_count} users via InputUser")

            still_missing = 0
            for user_id in missing_ids:
                if not mc.getUser(user_id):
                    still_missing += 1

            if still_missing > 0:
                log(f"[ChatExport] Warning: {still_missing} users still not in cache. They will be displayed as 'User {id}'")
                log(f"[ChatExport] This usually happens for deleted accounts or users not in your contacts")

        except Exception as e:
            log(f"[ChatExport] Error in _load_missing_users: {e}")
            import traceback
            log(traceback.format_exc())

    def _get_user_object(self, user_id: int):
        try:
            if user_id <= 0:
                return None

            mc = get_messages_controller()
            user = mc.getUser(user_id)
            return user
        except Exception as e:
            log(f"[ChatExport] Error getting user object {user_id}: {e}")
            return None
    
    def _reconstruct_tlrpc_message(self, msg_dict: Dict[str, Any]):
        try:
            if "_tlrpc_obj" in msg_dict:
                return msg_dict["_tlrpc_obj"]
            
            msg_id = msg_dict.get("id", 0)
            if not msg_id:
                return None
            
            if msg_dict.get("media"):
                media_dict = msg_dict.get("media", {})
                
                if "_media_obj" in media_dict:
                    class MockMessage:
                        def __init__(self, media_obj, message_id):
                            self.media = media_obj
                            self.id = message_id
                    
                    return MockMessage(media_dict["_media_obj"], msg_id)
                else:
                    log(f"[ChatExport] Warning: No _media_obj found for message {msg_id}, media type: {media_dict.get('type', 'unknown')}")
            
            return None
            
        except Exception as e:
            log(f"[ChatExport] Error reconstructing TLRPC message: {e}")
            return None
        
    def _generate_json(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        export_data = {
            "chat_name": chat_name,
            "dialog_id": dialog_id,
            "export_date": time.strftime("%Y-%m-%d %H:%M:%S"),
            "message_count": len(messages),
            "messages": []
        }
        
        msg_count = 0
        progress_interval = 1000 if len(messages) > 3000 else 500
        
        for msg in messages:
            if self.cancel_requested:
                log("[ChatExport] JSON generation cancelled by user")
                break
                
            msg_data = {
                "id": msg.get("id", 0),
                "date": msg.get("date", 0),
                "date_formatted": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(msg.get("date", 0))),
                "from_id": msg.get("from_id", 0),
                "from_name": self._get_sender_name(msg.get("from_id", 0)),
                "text": msg.get("text", ""),
                "out": msg.get("out", False)
            }
            
            if "media" in msg:
                msg_data["media"] = msg["media"]
                
            export_data["messages"].append(msg_data)
            
            msg_count += 1
            if msg_count % progress_interval == 0:
                progress_percent = int((msg_count / len(messages)) * 100)
                self._update_progress(self._t("generating_json", current=msg_count, total=len(messages)), progress_percent)
        
        log(f"[ChatExport] Serializing JSON export ({len(export_data['messages'])} messages)...")
        return json.dumps(export_data, indent=2, ensure_ascii=False)
        
    def _generate_txt(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        current_user_id = get_user_config().getClientUserId()
        
        txt_parts = []
        txt_parts.append(f"Chat Export: {chat_name}\n")
        txt_parts.append(f"Exported: {export_date}\n")
        txt_parts.append(f"Messages: {len(messages)}\n")
        txt_parts.append("=" * 50 + "\n\n")
        
        if not messages:
            txt_parts.append("No messages available for export.\n")
        else:
            last_date = None
            msg_count = 0
            progress_interval = 1000 if len(messages) > 3000 else 500
            
            for msg in messages:
                if self.cancel_requested:
                    log("[ChatExport] TXT generation cancelled by user")
                    break
                    
                msg_date = time.strftime("%Y-%m-%d", time.localtime(msg.get("date", 0)))
                
                if last_date != msg_date:
                    txt_parts.append(f"\n--- {msg_date} ---\n\n")
                    last_date = msg_date
                
                timestamp = time.strftime("%H:%M:%S", time.localtime(msg.get("date", 0)))
                is_outgoing = msg.get("out", False) or msg.get("from_id") == current_user_id
                
                if is_outgoing:
                    sender = "You"
                else:
                    sender = self._get_sender_name(msg.get("from_id", 0))
                
                txt_parts.append(f"[{timestamp}] {sender}: ")
                
                message_text = msg.get("text", "")
                if message_text:
                    txt_parts.append(message_text)
                
                if "media" in msg:
                    media_type = msg["media"].get("type", "unknown")
                    if message_text:
                        txt_parts.append(" ")
                    txt_parts.append(f"[{media_type.upper()}]")
                
                txt_parts.append("\n")
                
                msg_count += 1
                if msg_count % progress_interval == 0:
                    progress_percent = int((msg_count / len(messages)) * 100)
                    self._update_progress(self._t("generating_txt", current=msg_count, total=len(messages)), progress_percent)
        
        txt_parts.append("\n" + "=" * 50 + "\n")
        txt_parts.append(f"{self._t('txt_footer')}\n")
        
        return "".join(txt_parts)
    
    def _write_txt_header(self, file, chat_name: str):
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        file.write(f"{self._t('txt_header_chat')}: {chat_name}\n")
        file.write(f"{self._t('txt_header_exported')}: {export_date}\n")
        file.write(f"{self._t('txt_header_messages')}: ...\n")
        file.write("=" * 50 + "\n\n")
    
    def _write_txt_chunk(self, file, messages: List[Dict[str, Any]]):
        current_user_id = get_user_config().getClientUserId()
        last_date = None
        
        for msg in messages:
            msg_date = time.strftime("%Y-%m-%d", time.localtime(msg.get("date", 0)))
            
            if last_date != msg_date:
                file.write(f"\n--- {msg_date} ---\n\n")
                last_date = msg_date
            
            timestamp = time.strftime("%H:%M:%S", time.localtime(msg.get("date", 0)))
            is_outgoing = msg.get("out", False) or msg.get("from_id") == current_user_id
            
            sender = "You" if is_outgoing else self._get_sender_name(msg.get("from_id", 0))
            
            file.write(f"[{timestamp}] {sender}: ")
            
            message_text = msg.get("text", "")
            if message_text:
                file.write(message_text)
            
            if "media" in msg:
                media_type = msg["media"].get("type", "unknown")
                if message_text:
                    file.write(" ")
                file.write(f"[{media_type.upper()}]")
            
            file.write("\n")
    
    def _write_txt_footer(self, file):
        file.write("\n" + "=" * 50 + "\n")
        file.write(f"{self._t('txt_footer')}\n")
    
    def _write_json_header(self, file, chat_name: str, dialog_id: int):
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        file.write("{\n")
        file.write(f'  "chat_name": {json.dumps(chat_name)},\n')
        file.write(f'  "dialog_id": {dialog_id},\n')
        file.write(f'  "export_date": "{export_date}",\n')
        file.write(f'  "export_mode": "chunked_streaming",\n')
        file.write('  "messages": [\n')
    
    def _write_json_chunk(self, file, messages: List[Dict[str, Any]], is_continuation: bool):
        for i, msg in enumerate(messages):
            if is_continuation or i > 0:
                file.write(",\n")
            
            msg_data = {
                "id": msg.get("id", 0),
                "date": msg.get("date", 0),
                "date_formatted": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(msg.get("date", 0))),
                "from_id": msg.get("from_id", 0),
                "from_name": self._get_sender_name(msg.get("from_id", 0)),
                "text": msg.get("text", ""),
                "out": msg.get("out", False)
            }
            
            if "media" in msg:
                msg_data["media"] = msg["media"]
            
            file.write("    " + json.dumps(msg_data, ensure_ascii=False))
    
    def _write_json_footer(self, file, total_messages: int):
        file.write("\n  ],\n")
        file.write(f'  "message_count": {total_messages}\n')
        file.write("}\n")
    
    def _write_html_header(self, file, chat_name: str, total_messages: Optional[int] = None):
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        
        if total_messages is not None:
            info_text = f"{total_messages} messages (Optimized)"
        else:
            info_text = "Optimized Export"
        
        file.write(self._get_html_template(chat_name, export_date, info_text))
    
    def _write_html_chunk(self, file, messages: List[Dict[str, Any]], dialog_id: int, messages_offset: int):
        current_user_id = get_user_config().getClientUserId()
        
        include_timestamps = self._get_export_setting("include_timestamps", True)
        group_messages = self._get_export_setting("group_messages", True)
        
        msg_id_map = {msg.get("id"): msg for msg in messages if msg.get("id")}
        
        last_sender = None
        last_date = None
        
        for msg in messages:
            date_obj = time.localtime(msg.get("date", 0))
            msg_date = time.strftime("%d %B %Y", date_obj)
            if msg_date.startswith("0"):
                msg_date = msg_date[1:]
            
            if last_date != msg_date:
                file.write(f"""
    <div class="date-divider" id="message-date-{msg.get('date', 0)}">
     <div class="line"></div>
     <span class="text">{msg_date}</span>
     <div class="line"></div>
    </div>
""")
                last_date = msg_date
            
            html_msg = self._format_message_html(msg, current_user_id, include_timestamps, group_messages, last_sender, msg_id_map)
            file.write(html_msg)
            
            last_sender = msg.get("from_id")
    
    def _write_html_footer(self, file):
        file.write("""   </div>
  </div>
 </div>
 
 <!-- Image Lightbox -->
 <div id="image-lightbox" class="lightbox">
  <div class="lightbox-header">
   <div class="lightbox-controls">
    <button class="lightbox-btn" onclick="downloadImage()" title="Download image">
     <svg viewBox="0 0 24 24">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
      <polyline points="7 10 12 15 17 10"></polyline>
      <line x1="12" y1="15" x2="12" y2="3"></line>
     </svg>
    </button>
   </div>
   <button class="lightbox-btn" onclick="closeLightbox()" title="Close (Esc)">
    <svg viewBox="0 0 24 24">
     <line x1="18" y1="6" x2="6" y2="18"></line>
     <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
   </button>
  </div>
  
  <div class="lightbox-content" onclick="event.stopPropagation()">
   <img id="lightbox-image" src="" alt="" class="lightbox-image">
  </div>
  
  <div class="lightbox-footer"></div>
 </div>
</body>
</html>
""")
        
    def _save_export_file(self, chat_name: str, content: str, extension: str) -> str:
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            export_dir = File(base_dir, "ChatExports")
            
            if not export_dir.exists():
                export_dir.mkdirs()
                
            timestamp = int(time.time())
            safe_name = "".join(c for c in chat_name if c.isalnum() or c in (' ', '-', '_'))[:50]
            filename = f"chat_export_{safe_name}_{timestamp}.{extension}"
            
            file_path = File(export_dir, filename)
            
            with open(file_path.getAbsolutePath(), 'w', encoding='utf-8') as f:
                f.write(content)
                
            log(f"[ChatExport] Saved export to: {file_path.getAbsolutePath()}")
            return file_path.getAbsolutePath()
            
        except Exception as e:
            log(f"[ChatExport] Error saving export file: {e}")
            raise
            
    def _share_export_file(self, file_path: str, mime_type: str):
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_error("Cannot access activity")
                return
                
            context = fragment.getParentActivity()
            if not context:
                return
            
            import shutil
            from android.os import Environment
            
            source_file = File(file_path)
            filename = source_file.getName()
            
            download_dir = Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_DOWNLOADS
            )
            exteragram_dir = File(download_dir, "exteraGram")
            
            if not exteragram_dir.exists():
                exteragram_dir.mkdirs()
            
            dest_file = File(exteragram_dir, filename)
            
            shutil.copy2(file_path, dest_file.getAbsolutePath())
            log(f"[ChatExport] Copied export to: {dest_file.getAbsolutePath()}")
            
            authority = ApplicationLoader.getApplicationId() + ".provider"
            uri = FileProvider.getUriForFile(context, authority, dest_file)
            
            intent = Intent(Intent.ACTION_SEND)
            intent.setType(mime_type)
            intent.putExtra(Intent.EXTRA_STREAM, uri)
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            
            chooser = Intent.createChooser(intent, self._t("export_chat"))
            
            context.startActivity(chooser)
            
            success_msg = f"Export saved to Download/exteraGram/{filename}"
            BulletinHelper.show_success(success_msg)
            
            threading.Thread(
                target=lambda: self._cleanup_temp_file(file_path, 60),
                daemon=True
            ).start()
            
        except Exception as e:
            log(f"[ChatExport] Error sharing file: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"Share error: {str(e)}")
            
    def _cleanup_temp_file(self, file_path: str, delay_seconds: int):
        try:
            time.sleep(delay_seconds)
            
            if os.path.exists(file_path):
                os.remove(file_path)
                log(f"[ChatExport] Deleted temp file: {file_path}")
                
        except Exception as e:
            log(f"[ChatExport] Temp file cleanup error: {e}")
    
    def _cleanup_old_exports(self, delay_seconds: int):
        try:
            time.sleep(delay_seconds)
            
            base_dir = ApplicationLoader.getFilesDirFixed()
            export_dir = File(base_dir, "ChatExports")
            
            if not export_dir.exists():
                return
                
            now = time.time()
            max_age = 3600
            
            for file in export_dir.listFiles():
                if file.isFile():
                    age = now - (file.lastModified() / 1000)
                    if age > max_age:
                        file.delete()
                        log(f"[ChatExport] Deleted old export: {file.getName()}")
                        
        except Exception as e:
            log(f"[ChatExport] Cleanup error: {e}")
            
    def _update_progress(self, message: str, progress: int = 0):
        self.current_progress_text = message
        self.current_progress_value = max(0.0, min(1.0, progress / 100.0))
        
        def update():
            try:
                if self.progress_dialog:
                    self.progress_dialog.set_title(message)
                    self.progress_dialog.set_progress(progress)
                
                if self.progress_overlay:
                    overlay_text = message
                    if progress > 0:
                        overlay_text = f"{message} {progress}%"
                    self.progress_overlay.set_progress(self.current_progress_value, overlay_text)
                    
            except Exception as e:
                log(f"[ChatExport] Error updating progress: {e}")
        run_on_ui_thread(update)


plugin = ChatExportPlugin()