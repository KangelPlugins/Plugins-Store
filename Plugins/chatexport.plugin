import os
import time
import json
import re
import threading
import base64
from typing import List, Dict, Any, Optional
from collections import deque
from java.util import ArrayList, Locale
from java.io import File, FileOutputStream, FileInputStream
from android.content import Intent, Context
from android.net import Uri
from android.widget import LinearLayout, CheckBox, TextView, ScrollView, FrameLayout, EditText
from android.text import InputType, TextWatcher
from androidx.core.content import FileProvider
from android.view import Gravity, ViewGroup, View
from android.graphics import Color, Typeface, Canvas, Paint, RectF
from android.graphics.drawable import GradientDrawable, RippleDrawable, ColorDrawable
from android.content.res import ColorStateList
from android.util import TypedValue
from org.telegram.messenger import (
    ApplicationLoader, UserConfig, MessagesController, 
    MessagesStorage, FileLoader, LocaleController, AndroidUtilities, R,
    ImageLocation
)
from org.telegram.tgnet import TLRPC, NativeByteBuffer
from org.telegram.SQLite import SQLiteCursor
from org.telegram.ui.ActionBar import Theme, BottomSheet
from org.telegram.ui.Cells import (
    TextCheckCell, TextSettingsCell, HeaderCell
)
from org.telegram.ui.Components import EditTextBoldCursor, Bulletin, BulletinFactory, CircularProgressDrawable
from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import (
    get_messages_storage, get_messages_controller, 
    get_user_config, get_last_fragment, run_on_queue,
    send_request, get_connections_manager
)
from android_utils import log, run_on_ui_thread, OnClickListener, OnLongClickListener, R
from hook_utils import get_private_field
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper

__id__ = "chatexport"
__name__ = "Chat Export"
__description__ = "Export chats to HTML/JSON/TXT with Telegram Desktop style and media."
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "1.3.0 [beta]"
__icon__ = "nibbler_vk_Nyasticks_by_MoiStikiBot/35"
__min_version__ = "11.12.1"

TRANSLATIONS = {
    "ru": {
        "export_chat": "Экспорт чата",
        "exporting": "Экспорт чата...",
        "cancel": "Отмена",
        "export_complete": "Экспорт завершён!",
        "export_failed": "Ошибка экспорта",
        "export_in_progress": "Экспорт уже выполняется",
        "run_in_background": "В фоне",
        "background_export": "Экспорт продолжается в фоне",
        "cannot_determine_chat": "Не удалось определить ID чата",
        "loading_messages": "Загрузка сообщений из {chat}...",
        "generating_export": "Создание экспорта для {chat}...",
        "preparing_share": "Подготовка к отправке...",
        "export_settings": "Настройки экспорта",
        "export_format": "Формат экспорта",
        "media_handling": "Обработка медиа",
        "message_filters": "Фильтры сообщений",
        "max_messages": "Макс. сообщений",
        "empty_all": "Пусто = все",
        "advanced": "Дополнительно",
        "max_size_mb": "Макс. размер (МБ)",
        "include_timestamps": "Временные метки",
        "include_avatars": "Аватары",
        "group_messages": "Группировать сообщения",
        "by_sender_time": "По отправителю и времени",
        "menu_help": "Используйте кнопку 'Экспорт чата' в меню чата"
    },
    "en": {
        "export_chat": "Export Chat",
        "exporting": "Exporting chat...",
        "cancel": "Cancel",
        "export_complete": "Export complete!",
        "export_failed": "Export failed",
        "export_in_progress": "Export already in progress",
        "run_in_background": "Run in background",
        "background_export": "Export continues in background",
        "cannot_determine_chat": "Cannot determine chat ID",
        "loading_messages": "Loading messages from {chat}...",
        "generating_export": "Generating export for {chat}...",
        "preparing_share": "Preparing to share...",
        "export_settings": "Export Settings",
        "export_format": "Export Format",
        "media_handling": "Media Handling",
        "message_filters": "Message Filters",
        "max_messages": "Max Messages",
        "empty_all": "Empty = all",
        "advanced": "Advanced",
        "max_size_mb": "Max Size (MB)",
        "include_timestamps": "Include Timestamps",
        "include_avatars": "Include Avatars",
        "group_messages": "Group Messages",
        "by_sender_time": "By sender and time",
        "menu_help": "Use 'Export Chat' button in chat menu"
    }
}


def _encode_file_to_base64(file_path: str, max_size_bytes: int) -> Optional[str]:
    try:
        if not file_path or file_path == "" or file_path == "/" or file_path == "\\":
            return None

        if not os.path.exists(file_path):
            return None

        if not os.path.isfile(file_path):
            return None

        file_size = os.path.getsize(file_path)
        if file_size > max_size_bytes or file_size == 0:
            return None

        with open(file_path, "rb") as f:
            return base64.b64encode(f.read()).decode("ascii")
    except Exception as e:
        log(f"[ChatExport] Base64 encoding error for {file_path}: {e}")
        return None


def _get_file_mime_type(file_path: str) -> str:
    try:
        ext = file_path.lower().split('.')[-1] if '.' in file_path else ''
        mime_types = {
            'jpg': 'image/jpeg', 'jpeg': 'image/jpeg', 'png': 'image/png', 
            'gif': 'image/gif', 'webp': 'image/webp', 'bmp': 'image/bmp',
            'tgs': 'application/x-tgsticker',
            'mp4': 'video/mp4', 'webm': 'video/webm', 'mov': 'video/quicktime',
            'ogg': 'audio/ogg', 'opus': 'audio/opus', 'mp3': 'audio/mpeg',
            'wav': 'audio/wav', 'm4a': 'audio/mp4', 'avi': 'video/x-msvideo'
        }
        return mime_types.get(ext, 'application/octet-stream')
    except Exception:
        return 'application/octet-stream'


def _wait_for_file(file_path: str, timeout_ms: int) -> bool:
    if not file_path or file_path in ("", "/", "\\"):
        return False

    start = time.time()
    timeout_sec = timeout_ms / 1000.0
    while time.time() - start < timeout_sec:
        if os.path.exists(file_path):
            return True
        time.sleep(0.05)
    return os.path.exists(file_path)


def _get_best_photo_size(photo):
    try:
        sizes = getattr(photo, "sizes", None)
        if not sizes:
            return None
        
        best_size = None
        max_width = -1
        
        if hasattr(sizes, 'toArray'):
            sizes = list(sizes.toArray())
        
        for size in sizes:
            width = getattr(size, "w", 0) or getattr(size, "width", 0) or 0
            size_type = getattr(size, "type", "")
            
            if size_type == "i":
                continue
                
            if width >= max_width:
                best_size = size
                max_width = width
        
        return best_size
    except Exception as e:
        log(f"[ChatExport] Error getting best photo size: {e}")
        return None


def _get_media_type_from_message(msg) -> str:
    try:
        media = getattr(msg, "media", None)
        if not media:
            return "unknown"
        
        if isinstance(media, TLRPC.TL_messageMediaPhoto):
            return "photo"
        
        if isinstance(media, TLRPC.TL_messageMediaDocument):
            doc = getattr(media, "document", None)
            if not doc:
                return "document"
            
            attrs = getattr(doc, "attributes", [])
            if hasattr(attrs, 'toArray'):
                attrs = list(attrs.toArray())
            
            mime = getattr(doc, "mime_type", "")
            
            for attr in attrs:
                if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                    if mime == "application/x-tgsticker":
                        return "sticker_animated"
                    elif mime == "video/webm":
                        return "sticker_video"
                    else:
                        return "sticker"
                elif isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                    return "gif"
                elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                    if getattr(attr, "round_message", False):
                        return "video_circle"
                    return "video"
                elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                    if getattr(attr, "voice", False):
                        return "voice"
                    return "audio"
            
            mime = getattr(doc, "mime_type", "")
            if mime.startswith("video/"):
                return "video"
            elif mime.startswith("audio/"):
                return "audio"
            elif mime == "image/gif":
                return "gif"
            
            return "document"
        
        return "unknown"
    except Exception as e:
        log(f"[ChatExport] Error determining media type: {e}")
        return "unknown"


class MediaDownloadManager:
    
    def __init__(self, account_id: int, max_workers: int = 6, max_media_mb: int = 10):
        self.account_id = account_id
        self.max_workers = max_workers
        self.max_media_bytes = max_media_mb * 1024 * 1024
        self.download_tasks = deque()
        self.download_results = {}
        self.lock = threading.Lock()
        self.active_threads = 0
        self._cache = {}
    
    def add_avatar_download(self, user_id: int, user_obj):
        with self.lock:
            self.download_tasks.append(('avatar', user_id, user_obj))
    
    def add_media_download(self, msg_id: int, msg_obj, media_type: str = 'photo'):
        with self.lock:
            self.download_tasks.append(('media', msg_id, msg_obj, media_type))
    
    def _download_worker(self):
        while True:
            task = None
            with self.lock:
                if not self.download_tasks:
                    self.active_threads -= 1
                    break
                task = self.download_tasks.popleft()
            
            if not task:
                break
            
            task_type = task[0]
            item_id = task[1]
            item_obj = task[2]
            media_type = task[3] if len(task) > 3 else 'photo'
            
            try:
                if task_type == 'avatar':
                    self._process_avatar(item_id, item_obj)
                elif task_type == 'media':
                    self._process_media(item_id, item_obj, media_type)
            except Exception as e:
                log(f"[ChatExport] Download worker error for {task_type} {item_id}: {e}")
                with self.lock:
                    self.download_results[f'{task_type}_{item_id}'] = None
    
    def _process_avatar(self, user_id: int, user_obj):
        try:
            cache_key = f"avatar_{user_id}"

            if cache_key in self._cache:
                with self.lock:
                    self.download_results[cache_key] = self._cache[cache_key]
                return

            photo = getattr(user_obj, "photo", None)
            if not photo:
                with self.lock:
                    self.download_results[cache_key] = None
                return

            photo_loc = getattr(photo, "photo_small", None) or getattr(photo, "photo_big", None)
            if not photo_loc:
                with self.lock:
                    self.download_results[cache_key] = None
                return

            fl = FileLoader.getInstance(self.account_id)
            file_obj = fl.getPathToAttach(photo_loc, True)

            if not file_obj:
                log(f"[ChatExport] Avatar file_obj is None for user {user_id}")
                with self.lock:
                    self.download_results[cache_key] = None
                return

            file_path = file_obj.getAbsolutePath()

            if not file_path or file_path == "" or file_path == "/" or file_path == "\\":
                log(f"[ChatExport] Invalid avatar path for user {user_id}: '{file_path}'")
                with self.lock:
                    self.download_results[cache_key] = None
                return

            if not os.path.exists(file_path):
                try:
                    image_location = ImageLocation.getForUser(user_obj, ImageLocation.TYPE_SMALL)
                    if image_location:
                        fl.loadFile(image_location, user_obj, "jpg", 0, 1)
                        if _wait_for_file(file_path, 500):
                            pass
                except Exception as e:
                    log(f"[ChatExport] Avatar download error: {e}")

            if os.path.exists(file_path):
                b64_data = _encode_file_to_base64(file_path, 180000)
                if b64_data:
                    data_uri = f"data:image/jpeg;base64,{b64_data}"
                    self._cache[cache_key] = data_uri
                    with self.lock:
                        self.download_results[cache_key] = data_uri
                    return

            with self.lock:
                self.download_results[cache_key] = None

        except Exception as e:
            log(f"[ChatExport] Avatar processing error: {e}")
            with self.lock:
                self.download_results[f'avatar_{user_id}'] = None
    
    def _process_media(self, msg_id: int, msg_obj, media_type: str):
        try:
            cache_key = f"media_{msg_id}"
            
            if cache_key in self._cache:
                with self.lock:
                    self.download_results[cache_key] = self._cache[cache_key]
                    self.download_results[f'media_type_{msg_id}'] = media_type
                return
            
            if media_type == "sticker_animated":
                log(f"[ChatExport] Skipping TGS sticker download for msg {msg_id} (not supported in browsers)")
                with self.lock:
                    self.download_results[cache_key] = None
                    self.download_results[f'media_type_{msg_id}'] = media_type
                return
            
            file_path = self._get_media_file_path(msg_obj)
            
            if not file_path or not os.path.exists(file_path):
                file_path = self._download_media_file(msg_obj)
            
            if file_path and os.path.exists(file_path):
                file_size = os.path.getsize(file_path)
                
                if file_size > self.max_media_bytes:
                    log(f"[ChatExport] Media file too large ({file_size} bytes): {file_path}")
                    with self.lock:
                        self.download_results[cache_key] = None
                        self.download_results[f'media_type_{msg_id}'] = media_type
                        self.download_results[f'media_size_{msg_id}'] = file_size
                    return
                
                b64_data = _encode_file_to_base64(file_path, self.max_media_bytes)
                if b64_data:
                    mime_type = _get_file_mime_type(file_path)
                    data_uri = f"data:{mime_type};base64,{b64_data}"
                    self._cache[cache_key] = data_uri
                    with self.lock:
                        self.download_results[cache_key] = data_uri
                        self.download_results[f'media_type_{msg_id}'] = media_type
                    return
            
            with self.lock:
                self.download_results[cache_key] = None
                self.download_results[f'media_type_{msg_id}'] = media_type
                
        except Exception as e:
            log(f"[ChatExport] Media processing error: {e}")
            with self.lock:
                self.download_results[f'media_{msg_id}'] = None
    
    def _get_media_file_path(self, msg_obj) -> Optional[str]:
        try:
            media = getattr(msg_obj, "media", None)
            if not media:
                return None

            fl = FileLoader.getInstance(self.account_id)
            msg_id = getattr(msg_obj, "id", "unknown")

            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo_size = _get_best_photo_size(media.photo)
                if photo_size:
                    file_obj = fl.getPathToAttach(photo_size, True)
                    if file_obj:
                        file_path = file_obj.getAbsolutePath()
                        if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                            return file_path
                        else:
                            log(f"[ChatExport] Invalid photo path for msg {msg_id}: '{file_path}'")

            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                doc = getattr(media, "document", None)
                if doc:
                    file_obj = fl.getPathToAttach(doc, True)
                    if file_obj:
                        file_path = file_obj.getAbsolutePath()
                        if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                            return file_path
                        else:
                            log(f"[ChatExport] Invalid document path for msg {msg_id}: '{file_path}'")

            msg_owner = getattr(msg_obj, "messageOwner", msg_obj)
            file_obj = fl.getPathToMessage(msg_owner)
            if file_obj:
                file_path = file_obj.getAbsolutePath()
                if file_path and file_path != "" and file_path != "/" and file_path != "\\":
                    return file_path
                else:
                    log(f"[ChatExport] Invalid message path for msg {msg_id}: '{file_path}'")

            return None

        except Exception as e:
            log(f"[ChatExport] Error getting media path: {e}")
            import traceback
            log(f"[ChatExport] Traceback: {traceback.format_exc()}")
            return None
    
    def _download_media_file(self, msg_obj) -> Optional[str]:
        try:
            media = getattr(msg_obj, "media", None)
            if not media:
                return None

            fl = FileLoader.getInstance(self.account_id)
            file_path = self._get_media_file_path(msg_obj)

            if not file_path or file_path in ("", "/", "\\"):
                return None

            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo_size = _get_best_photo_size(media.photo)
                if photo_size:
                    try:
                        image_location = ImageLocation.getForPhoto(photo_size, media.photo)
                        if image_location:
                            fl.loadFile(image_location, media.photo, "jpg", 0, 1)
                            if _wait_for_file(file_path, 2000):
                                return file_path
                    except Exception as e:
                        log(f"[ChatExport] Photo download error: {e}")

            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                doc = getattr(media, "document", None)
                if doc:
                    try:
                        image_location = ImageLocation.getForDocument(doc)
                        if image_location:
                            fl.loadFile(image_location, msg_obj, None, 0, 1)
                            if _wait_for_file(file_path, 2000):
                                return file_path
                    except Exception as e:
                        log(f"[ChatExport] Document download error: {e}")

            return None

        except Exception as e:
            log(f"[ChatExport] Media download error: {e}")
            return None
    
    def execute_downloads(self):
        with self.lock:
            queue_size = len(self.download_tasks)
            if queue_size == 0:
                return
            
            workers_needed = min(self.max_workers, queue_size)
            self.active_threads = workers_needed
        
        threads = []
        for _ in range(workers_needed):
            thread = threading.Thread(target=self._download_worker)
            thread.daemon = True
            thread.start()
            threads.append(thread)
        
        for thread in threads:
            thread.join(timeout=30)
        
        log(f"[ChatExport] Downloaded {len(self.download_results)} items with {workers_needed} workers")
    
    def get_result(self, key: str):
        with self.lock:
            return self.download_results.get(key)


class ExportSettingsBottomSheet:
    
    def __init__(self, context, plugin, dialog_id):
        self.plugin = plugin
        self.dialog_id = dialog_id
        self.context = context
        
        self.bottom_sheet = BottomSheet(context, False)
        
        self.temp_settings = {
            'export_format': plugin.get_setting('export_format', 0),
            'media_handling': plugin.get_setting('media_handling', 0),
            'max_messages': plugin.get_setting('max_messages', ''),
            'max_size_mb': plugin.get_setting('max_size_mb', '100'),
            'use_api_mode': plugin.get_setting('use_api_mode', True),
            'include_timestamps': plugin.get_setting('include_timestamps', True),
            'include_avatars': plugin.get_setting('include_avatars', True),
            'group_messages': plugin.get_setting('group_messages', True),
        }
        
        container_layout = LinearLayout(context)
        container_layout.setOrientation(LinearLayout.VERTICAL)
        container_layout.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
        
        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)
        
        self.content_layout = LinearLayout(context)
        self.content_layout.setOrientation(LinearLayout.VERTICAL)
        self.content_layout.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        self._build_settings_cells()
        
        scroll_view.addView(self.content_layout)
        
        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            0,
            1.0
        )
        container_layout.addView(scroll_view, scroll_params)
        
        button_container = self._create_button_container()
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        container_layout.addView(button_container, button_params)
        
        self.bottom_sheet.setCustomView(container_layout)
    
    def show(self):
        self.bottom_sheet.show()
    
    def dismiss(self):
        self.bottom_sheet.dismiss()
    
    def _build_settings_cells(self):
        is_russian = self.plugin._is_russian()
        
        self._add_header(self.plugin._t('export_format'))
        self._add_selector_cell(
            'export_format',
            self.plugin._t('export_format'),
            ['HTML', 'JSON', 'TXT']
        )
        
        self._add_selector_cell(
            'media_handling',
            self.plugin._t('media_handling'),
            ['Пропустить', 'Ссылки', 'Скачать'] if is_russian else ['Skip', 'References', 'Download']
        )
        
        self._add_header(self.plugin._t('message_filters'))
        self._add_input_cell(
            'max_messages',
            self.plugin._t('max_messages'),
            self.plugin._t('empty_all'),
            InputType.TYPE_CLASS_NUMBER
        )
        
        self._add_header(self.plugin._t('advanced'))
        self._add_input_cell(
            'max_size_mb',
            self.plugin._t('max_size_mb'),
            '100',
            InputType.TYPE_CLASS_NUMBER
        )
        self._add_switch_cell(
            'include_timestamps',
            self.plugin._t('include_timestamps'),
            ''
        )
        self._add_switch_cell(
            'include_avatars',
            self.plugin._t('include_avatars'),
            ''
        )
        self._add_switch_cell(
            'group_messages',
            self.plugin._t('group_messages'),
            self.plugin._t('by_sender_time')
        )
        self._add_switch_cell(
            'use_api_mode',
            'Use API Mode' if not is_russian else 'Режим API',
            'Fetch all messages from server' if not is_russian else 'Загружать все сообщения с сервера'
        )
    
    def _add_header(self, text):
        cell = HeaderCell(self.context)
        cell.setText(text)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _add_switch_cell(self, key, text, subtext):
        cell = TextCheckCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        value = self.temp_settings[key]
        if subtext:
            cell.setTextAndValueAndCheck(text, subtext, value, True, False)
        else:
            cell.setTextAndCheck(text, value, False)
        
        def on_click(*_):
            self.temp_settings[key] = not self.temp_settings[key]
            new_value = self.temp_settings[key]
            try:
                checkbox = cell.getCheckBox()
                if checkbox:
                    checkbox.setChecked(new_value, True)
            except Exception as e:
                if subtext:
                    cell.setTextAndValueAndCheck(text, subtext, new_value, True, True)
                else:
                    cell.setTextAndCheck(text, new_value, True)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _add_selector_cell(self, key, text, options):
        cell = TextSettingsCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        current_index = self.temp_settings[key]
        current_value = options[current_index] if 0 <= current_index < len(options) else options[0]
        cell.setTextAndValue(text, current_value, True)
        
        def on_click(*_):
            self._show_selector_dialog(key, text, options, cell)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _add_input_cell(self, key, text, hint, input_type):
        cell = TextSettingsCell(self.context)
        cell.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundWhite))
        
        value = str(self.temp_settings[key])
        cell.setTextAndValue(text, value if value else hint, False)
        
        def on_click(*_):
            self._show_input_dialog(key, text, hint, input_type, cell)
        
        cell.setOnClickListener(OnClickListener(on_click))
        
        params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        self.content_layout.addView(cell, params)
    
    def _show_selector_dialog(self, key, text, options, cell):
        def on_item_selected(builder, which):
            self.temp_settings[key] = which
            new_value = options[which]
            cell.setTextAndValue(text, new_value, True)
            builder.dismiss()
        
        builder = AlertDialogBuilder(self.context)
        builder.set_title(text)
        builder.set_items(options, on_item_selected)
        builder.set_negative_button(self.plugin._t('cancel'), lambda b, w: b.dismiss())
        builder.show()
    
    def _show_input_dialog(self, key, text, hint, input_type, cell):
        current_value = str(self.temp_settings[key])
        
        edit_text = EditTextBoldCursor(self.context)
        edit_text.setText(current_value)
        edit_text.setInputType(input_type)
        edit_text.setHint(hint)
        try:
            edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextGray3))
            edit_text.setLineColors(
                Theme.getColor(Theme.key_dialogInputField),
                Theme.getColor(Theme.key_dialogInputFieldActivated),
                Theme.getColor(Theme.key_text_RedBold)
            )
            edit_text.setBackground(ColorDrawable(0))
            edit_text.setBackgroundTintList(ColorStateList.valueOf(Color.TRANSPARENT))
        except:
            pass
        edit_text.setSingleLine(True)
        
        padding_h = AndroidUtilities.dp(32)
        padding_v = AndroidUtilities.dp(16)
        edit_text.setPadding(padding_h, padding_v, padding_h, padding_v)
        
        def on_ok_click(builder, which):
            new_value = str(edit_text.getText())
            self.temp_settings[key] = new_value
            cell.setTextAndValue(text, new_value if new_value else hint, False)
            builder.dismiss()
        
        builder = AlertDialogBuilder(self.context)
        builder.set_title(text)
        builder.set_view(edit_text)
        builder.set_positive_button("OK", on_ok_click)
        builder.set_negative_button(self.plugin._t('cancel'), lambda b, w: b.dismiss())
        builder.show()
    
    def _create_button_container(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
        
        divider = View(self.context)
        divider.setBackgroundColor(Theme.getColor(Theme.key_divider))
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            1
        )
        container.addView(divider, divider_params)
        
        button_row = LinearLayout(self.context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)
        button_row.setPadding(
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(12)
        )
        
        cancel_btn = self._create_text_button(self.plugin._t('cancel'), False)
        cancel_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))
        
        is_russian = self.plugin._is_russian()
        save_btn = self._create_text_button(
            'Сохр.' if is_russian else 'Save',
            False
        )
        save_btn.setOnClickListener(OnClickListener(lambda *args: self._on_save_default_click()))
        
        export_btn = self._create_text_button(
            'Экспорт' if is_russian else 'Export', 
            True
        )
        export_btn.setOnClickListener(OnClickListener(lambda *args: self._on_export_click()))
        
        button_params = LinearLayout.LayoutParams(
            0,
            LinearLayout.LayoutParams.WRAP_CONTENT,
            1.0
        )
        button_params.setMargins(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
        
        button_row.addView(cancel_btn, button_params)
        button_row.addView(save_btn, button_params)
        button_row.addView(export_btn, button_params)
        
        container.addView(button_row)
        
        return container
    
    def _create_text_button(self, text, is_primary):
        button = TextView(self.context)
        button.setText(text)
        button.setGravity(Gravity.CENTER)
        button.setSingleLine(True)
        button.setPadding(
            AndroidUtilities.dp(8),
            AndroidUtilities.dp(12),
            AndroidUtilities.dp(8),
            AndroidUtilities.dp(12)
        )
        
        background = GradientDrawable()
        background.setCornerRadius(AndroidUtilities.dp(8))
        
        if is_primary:
            button.setTextColor(Color.WHITE)
            bg_color = Theme.getColor(Theme.key_featuredStickers_addButton)
            background.setColor(bg_color)
            
            button.setShadowLayer(
                AndroidUtilities.dp(1),
                0,
                AndroidUtilities.dp(1),
                0x40000000
            )
        else:
            button.setTextColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            background.setColor(Color.TRANSPARENT)
            background.setStroke(AndroidUtilities.dp(2), Theme.getColor(Theme.key_featuredStickers_addButton))
        
        button.setBackground(background)
        button.setTextSize(1, 15 if is_primary else 14)
        button.setTypeface(None, Typeface.BOLD)
        
        button.setClickable(True)
        button.setFocusable(True)
        
        if is_primary:
            try:
                button.setElevation(AndroidUtilities.dp(2))
            except:
                pass
        
        return button
    
    def _on_export_click(self):
        try:
            self.dismiss()
            self.plugin._start_export_with_settings(self.dialog_id, self.temp_settings)
        except Exception as e:
            log(f"[ChatExport] Error in export click: {e}")
            import traceback
            log(traceback.format_exc())
    
    def _on_save_default_click(self):
        try:
            for key, value in self.temp_settings.items():
                self.plugin.set_setting(key, value)
            
            self.dismiss()
            self.plugin._start_export_with_settings(self.dialog_id, self.temp_settings)
            
            run_on_ui_thread(lambda: BulletinHelper.show_success(
                'Настройки сохранены' if self.plugin._is_russian() else 'Settings saved'
            ))
        except Exception as e:
            log(f"[ChatExport] Error in save default click: {e}")
            import traceback
            log(traceback.format_exc())


class FloatingProgressOverlay:
    
    def __init__(self, context):
        self.context = context
        self.progress = 0.0
        self.progress_text = ""
        self.is_minimized = False
        
        self.container = FrameLayout(context)
        
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(28))
        bg.setColor(Theme.getColor(Theme.key_undo_background))
        self.container.setBackground(bg)
        
        self.container.setElevation(AndroidUtilities.dp(4))
        
        self.progress_view = self._create_progress_view()
        progress_params = FrameLayout.LayoutParams(
            AndroidUtilities.dp(40),
            AndroidUtilities.dp(40)
        )
        progress_params.gravity = Gravity.START | Gravity.CENTER_VERTICAL
        progress_params.leftMargin = AndroidUtilities.dp(8)
        self.container.addView(self.progress_view, progress_params)
        
        self.text_view = TextView(context)
        self.text_view.setTextColor(Theme.getColor(Theme.key_undo_infoColor))
        self.text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        self.text_view.setTypeface(Typeface.DEFAULT_BOLD)
        self.text_view.setSingleLine(True)
        self.text_view.setText("Экспорт...")
        
        text_params = FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT
        )
        text_params.gravity = Gravity.START | Gravity.CENTER_VERTICAL
        text_params.leftMargin = AndroidUtilities.dp(56)
        text_params.rightMargin = AndroidUtilities.dp(12)
        self.container.addView(self.text_view, text_params)
        
        self.container.setPadding(0, AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8))
        
    def _create_progress_view(self):
        from org.telegram.ui.Components import RadialProgressView
        
        progress_view = RadialProgressView(self.context)
        progress_view.setProgressColor(Theme.getColor(Theme.key_undo_infoColor))
        progress_view.setSize(AndroidUtilities.dp(32))
        
        progress_container = FrameLayout(self.context)
        progress_container.addView(progress_view, FrameLayout.LayoutParams(
            ViewGroup.LayoutParams.MATCH_PARENT,
            ViewGroup.LayoutParams.MATCH_PARENT,
            Gravity.CENTER
        ))
        
        return progress_container
    
    def set_progress(self, progress, text):
        self.progress = max(0.0, min(1.0, progress))
        self.progress_text = text
        self.text_view.setText(text)
        
        try:
            if self.progress_view and hasattr(self.progress_view, 'setProgress'):
                self.progress_view.setProgress(progress)
        except Exception as e:
            log(f"[ChatExport] Could not update progress view: {e}")
    
    def get_view(self):
        return self.container
    
    def toggle_minimize(self):
        self.is_minimized = not self.is_minimized
        
        if self.is_minimized:
            def hide_text():
                self.text_view.setVisibility(View.GONE)
            
            self.text_view.animate() \
                .alpha(0.0) \
                .setDuration(150) \
                .withEndAction(R(hide_text)) \
                .start()
            
            bg = GradientDrawable()
            bg.setShape(GradientDrawable.OVAL)
            bg.setColor(Theme.getColor(Theme.key_undo_background))
            
            try:
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    bg,
                    None
                )
                self.container.setBackground(ripple)
            except:
                self.container.setBackground(bg)
            
            params = self.container.getLayoutParams()
            if params:
                params.width = AndroidUtilities.dp(56)
                params.height = AndroidUtilities.dp(56)
                self.container.setLayoutParams(params)
                
            self.container.animate() \
                .scaleX(0.95) \
                .scaleY(0.95) \
                .setDuration(150) \
                .start()
        else:
            self.text_view.setVisibility(View.VISIBLE)
            self.text_view.setAlpha(0.0)
            self.text_view.animate() \
                .alpha(1.0) \
                .setDuration(200) \
                .start()
            
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(28))
            bg.setColor(Theme.getColor(Theme.key_undo_background))
            
            try:
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    bg,
                    None
                )
                self.container.setBackground(ripple)
            except:
                self.container.setBackground(bg)
            
            params = self.container.getLayoutParams()
            if params:
                params.width = ViewGroup.LayoutParams.WRAP_CONTENT
                params.height = AndroidUtilities.dp(56)
                self.container.setLayoutParams(params)
                
            self.container.animate() \
                .scaleX(1.0) \
                .scaleY(1.0) \
                .setDuration(200) \
                .start()
    
    def show_with_animation(self):
        self.container.setAlpha(0.0)
        self.container.setTranslationY(-AndroidUtilities.dp(20))
        
        self.container.animate() \
            .alpha(1.0) \
            .translationY(0) \
            .setDuration(300) \
            .setInterpolator(AndroidUtilities.decelerateInterpolator) \
            .start()
    
    def setOnClickListener(self, listener):
        self.container.setOnClickListener(listener)
    
    def setOnLongClickListener(self, listener):
        self.container.setOnLongClickListener(listener)
    
    def setClickable(self, clickable):
        self.container.setClickable(clickable)
    
    def setFocusable(self, focusable):
        self.container.setFocusable(focusable)
    
    def setBackground(self, background):
        self.container.setBackground(background)
    
    def getBackground(self):
        return self.container.getBackground()


class ChatExportPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.menu_item_id = None
        self.export_in_progress = False
        self.cancel_requested = False
        self.progress_dialog = None
        self.progress_overlay = None
        self.progress_overlay_container = None
        self.selected_chats = []
        self.current_progress_text = ""
        self.current_progress_value = 0.0
        self.request_lock = threading.Lock()
        self.request_response = None
        self.request_error = None
        self.request_done = False
        
    def _t(self, key: str, **kwargs) -> str:
        lang = "ru" if self._is_russian() else "en"
        text = TRANSLATIONS.get(lang, {}).get(key, TRANSLATIONS["en"].get(key, key))
        if kwargs:
            text = text.format(**kwargs)
        return text
        
    def _is_russian(self) -> bool:
        try:
            locale_lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            return locale_lang and str(locale_lang).lower().startswith('ru')
        except:
            return False
        
    def on_plugin_load(self):
        try:
            self.menu_item_id = self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    item_id="export_chat_button",
                    text=self._t("export_chat"),
                    icon="msg_download",
                    on_click=self._handle_export_click
                )
            )
            log("[ChatExport] Plugin loaded successfully")
        except Exception as e:
            log(f"[ChatExport] Error loading plugin: {e}")
            
    def on_plugin_unload(self):
        if self.menu_item_id:
            self.remove_menu_item(self.menu_item_id)
        log("[ChatExport] Plugin unloaded")
        
    def _handle_export_click(self, context):
        try:
            chat = context.get("chat")
            user = context.get("user")
            dialog_id = context.get("dialog_id")
            
            if not dialog_id:
                if chat:
                    dialog_id = -chat.id
                elif user:
                    dialog_id = user.id
                    
            if not dialog_id:
                BulletinHelper.show_error(self._t("cannot_determine_chat"))
                return
                
            log(f"[ChatExport] Export clicked for dialog_id: {dialog_id}")
            
            run_on_ui_thread(lambda: self._show_export_settings_dialog(dialog_id))
            
        except Exception as e:
            log(f"[ChatExport] Error in export click handler: {e}")
            BulletinHelper.show_error(f"{self._t('export_failed')}: {str(e)}")
    
    def _show_export_settings_dialog(self, dialog_id):
        try:
            fragment = get_last_fragment()
            if not fragment:
                log("[ChatExport] Cannot get fragment for settings dialog")
                return
            
            context = fragment.getParentActivity()
            if not context:
                log("[ChatExport] Cannot get activity for settings dialog")
                return
            
            settings_sheet = ExportSettingsBottomSheet(context, self, dialog_id)
            settings_sheet.show()
            
        except Exception as e:
            log(f"[ChatExport] Error showing settings dialog: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"Error: {str(e)}")
    
    def _start_export_with_settings(self, dialog_id, temp_settings):
        try:
            self.temp_export_settings = temp_settings
            self.selected_chats = [dialog_id]
            self._start_export()
        except Exception as e:
            log(f"[ChatExport] Error starting export with settings: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"{self._t('export_failed')}: {str(e)}")
            
    def _get_export_setting(self, key, default=None):
        if hasattr(self, 'temp_export_settings') and self.temp_export_settings:
            return self.temp_export_settings.get(key, default)
        return self.get_setting(key, default)
    
    def _start_export(self):
        if self.export_in_progress:
            BulletinHelper.show_error(self._t("export_in_progress"))
            return
            
        self.export_in_progress = True
        self.cancel_requested = False
        
        run_on_ui_thread(self._show_progress_dialog)
        
        threading.Thread(
            target=self._export_chats_background,
            daemon=True
        ).start()
        
    def _show_progress_dialog(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
                
            context = fragment.getParentActivity()
            if not context:
                return
            
            self.progress_dialog = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_LOADING)
            self.progress_dialog.set_title(self._t("exporting"))
            self.progress_dialog.set_neutral_button(
                self._t("run_in_background"),
                lambda b, w: self._run_export_in_background()
            )
            self.progress_dialog.set_negative_button(
                self._t("cancel"),
                lambda b, w: self._cancel_export()
            )
            self.progress_dialog.show()
            self.progress_dialog.set_cancelable(False)
            
        except Exception as e:
            log(f"[ChatExport] Error showing progress dialog: {e}")
            
    def _cancel_export(self):
        self.cancel_requested = True
        self._dismiss_progress_dialog()
        self._dismiss_progress_overlay()
        
    def _run_export_in_background(self):
        try:
            self._dismiss_progress_dialog()
            run_on_ui_thread(self._create_progress_overlay)
        except Exception as e:
            log(f"[ChatExport] Error moving to background: {e}")

    def _create_progress_overlay(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                log("[ChatExport] Cannot get fragment for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            context = fragment.getParentActivity()
            if not context:
                log("[ChatExport] Cannot get context for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            content_view_id = 0x01020002
            root_view = context.getWindow().getDecorView()
            container = root_view.findViewById(content_view_id)
            
            if not container:
                container = root_view
            
            if not container:
                log("[ChatExport] Cannot get root container for progress overlay")
                BulletinHelper.show_info(self._t("background_export"))
                return
            
            if self.progress_overlay_container:
                try:
                    container.removeView(self.progress_overlay_container)
                except:
                    pass
            
            self.progress_overlay_container = FrameLayout(context)
            
            self.progress_overlay = FloatingProgressOverlay(context)
            
            progress_text = self.current_progress_text or self._t("exporting")
            if self.current_progress_value > 0:
                progress_percent = int(self.current_progress_value * 100)
                progress_text = f"{progress_text} {progress_percent}%"
            
            self.progress_overlay.set_progress(self.current_progress_value, progress_text)
            
            self.progress_overlay.setOnClickListener(OnClickListener(self._on_progress_overlay_click))
            self.progress_overlay.setOnLongClickListener(OnLongClickListener(self._on_progress_overlay_long_click))
            self.progress_overlay.setClickable(True)
            self.progress_overlay.setFocusable(True)
            
            try:
                self.progress_overlay.original_background = self.progress_overlay.getBackground()
                ripple_color = Theme.getColor(Theme.key_listSelector)
                ripple = RippleDrawable(
                    ColorStateList.valueOf(ripple_color),
                    self.progress_overlay.getBackground(),
                    None
                )
                self.progress_overlay.setBackground(ripple)
                self.progress_overlay.ripple_drawable = ripple
            except Exception as e:
                log(f"[ChatExport] Could not add ripple effect: {e}")
            
            overlay_params = FrameLayout.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                AndroidUtilities.dp(56)
            )
            overlay_params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
            overlay_params.topMargin = AndroidUtilities.dp(80)
            
            self.progress_overlay_container.addView(self.progress_overlay.get_view(), overlay_params)
            
            container_params = FrameLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT
            )
            container.addView(self.progress_overlay_container, container_params)
            
            self.progress_overlay.show_with_animation()
            
            log("[ChatExport] Floating progress overlay created and shown")
            
        except Exception as e:
            log(f"[ChatExport] Error creating progress overlay: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_info(self._t("background_export"))
    
    def _on_progress_overlay_click(self, view=None):
        try:
            log("[ChatExport] Progress overlay clicked - toggling minimize")
            if self.progress_overlay:
                self.progress_overlay.toggle_minimize()
        except Exception as e:
            log(f"[ChatExport] Error handling overlay click: {e}")
    
    def _on_progress_overlay_long_click(self, view=None):
        try:
            log("[ChatExport] Progress overlay long clicked - reopening dialog")
            self._dismiss_progress_overlay()
            run_on_ui_thread(self._show_progress_dialog)
            return True
        except Exception as e:
            log(f"[ChatExport] Error handling overlay long click: {e}")
            import traceback
            log(traceback.format_exc())
            return False
    
    def _dismiss_progress_overlay(self):
        def dismiss():
            try:
                if self.progress_overlay_container:
                    parent = self.progress_overlay_container.getParent()
                    if parent:
                        parent.removeView(self.progress_overlay_container)
                    else:
                        fragment = get_last_fragment()
                        if fragment:
                            context = fragment.getParentActivity()
                            if context:
                                content_view_id = 0x01020002
                                root_view = context.getWindow().getDecorView()
                                container = root_view.findViewById(content_view_id)
                                if not container:
                                    container = root_view
                                if container:
                                    container.removeView(self.progress_overlay_container)
                    
                    self.progress_overlay_container = None
                    self.progress_overlay = None
            except Exception as e:
                log(f"[ChatExport] Error dismissing progress overlay: {e}")
        run_on_ui_thread(dismiss)
    
    def _dismiss_progress_dialog(self):
        def dismiss():
            try:
                if self.progress_dialog:
                    self.progress_dialog.dismiss()
                    self.progress_dialog = None
            except:
                pass
        run_on_ui_thread(dismiss)
        
    def _export_chats_background(self):
        try:
            for dialog_id in self.selected_chats:
                if self.cancel_requested:
                    break
                    
                self._export_single_chat(dialog_id)
                
            if not self.cancel_requested:
                self._dismiss_progress_overlay()
                run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("export_complete")))
        except Exception as e:
            log(f"[ChatExport] Export error: {e}")
            error_msg = f"{self._t('export_failed')}: {str(e)}"
            self._dismiss_progress_overlay()
            run_on_ui_thread(lambda msg=error_msg: BulletinHelper.show_error(msg))
        finally:
            self.export_in_progress = False
            self._dismiss_progress_dialog()
            self._dismiss_progress_overlay()
            if hasattr(self, 'temp_export_settings'):
                delattr(self, 'temp_export_settings')
            
    def _export_single_chat(self, dialog_id: int):
        try:
            chat_name = self._get_chat_name(dialog_id)
            log(f"[ChatExport] Exporting chat: {chat_name} ({dialog_id})")
            
            self._update_progress(self._t("loading_messages", chat=chat_name), 10)
            
            messages = self._load_chat_messages(dialog_id)
            
            if self.cancel_requested:
                return
                
            log(f"[ChatExport] Loaded {len(messages)} messages")
            
            self._update_progress(self._t("generating_export", chat=chat_name), 50)
            
            export_format = self._get_export_setting("export_format", 0)
            
            if export_format == 0:
                content = self._generate_html(dialog_id, chat_name, messages)
                extension = "html"
                mime_type = "text/html"
            elif export_format == 1:
                content = self._generate_json(dialog_id, chat_name, messages)
                extension = "json"
                mime_type = "application/json"
            else:
                content = self._generate_txt(dialog_id, chat_name, messages)
                extension = "txt"
                mime_type = "text/plain"
                
            file_path = self._save_export_file(chat_name, content, extension)
            
            if self.cancel_requested:
                return
                
            self._update_progress(self._t("preparing_share"), 95)
            run_on_ui_thread(lambda: self._share_export_file(file_path, mime_type))
            
        except Exception as e:
            log(f"[ChatExport] Error exporting chat {dialog_id}: {e}")
            raise
            
    def _get_chat_name(self, dialog_id: int) -> str:
        try:
            mc = get_messages_controller()

            if dialog_id > 0:
                log(f"[ChatExport] Getting name for private chat (user_id={dialog_id})")
                user = mc.getUser(dialog_id)
                if user:
                    name = user.first_name or ""
                    if user.last_name:
                        name += " " + user.last_name
                    name = name.strip()

                    if not name and hasattr(user, 'username') and user.username:
                        name = f"@{user.username}"

                    if not name:
                        if hasattr(user, 'deleted') and user.deleted:
                            return "Deleted Account"
                        return f"User_{dialog_id}"

                    log(f"[ChatExport] Private chat name: {name}")
                    return name
            else:
                log(f"[ChatExport] Getting name for group/channel (chat_id={-dialog_id})")
                chat = mc.getChat(-dialog_id)
                if chat:
                    title = getattr(chat, 'title', None)
                    if title:
                        title = title.strip()
                    
                    username = getattr(chat, 'username', None)
                    
                    is_broadcast = getattr(chat, 'broadcast', False)
                    is_megagroup = getattr(chat, 'megagroup', False)
                    
                    log(f"[ChatExport] Getting name for dialog {-dialog_id}: title='{title}', username='{username}', broadcast={is_broadcast}, megagroup={is_megagroup}")
                    
                    if title and username:
                        return f"{title} (@{username})"
                    elif title:
                        return title
                    elif username:
                        return f"@{username}"
                    if is_broadcast:
                        return f"Channel_{-dialog_id}"
                    elif is_megagroup:
                        return f"Supergroup_{-dialog_id}"
                    else:
                        return f"Group_{-dialog_id}"

            return f"Chat_{dialog_id}"
        except Exception as e:
            log(f"[ChatExport] Error getting chat name: {e}")
            return f"Chat_{dialog_id}"
            
    def _send_request_sync(self, request):
        with self.request_lock:
            self.request_response = None
            self.request_error = None
            self.request_done = False
        
        def callback(response, error):
            with self.request_lock:
                self.request_response = response
                self.request_error = error
                self.request_done = True
        
        try:
            send_request(request, callback)
            
            timeout = 30
            start_time = time.time()
            
            while True:
                with self.request_lock:
                    if self.request_done:
                        return self.request_response
                
                if time.time() - start_time > timeout:
                    log("[ChatExport] Request timeout")
                    return None
                    
                if self.cancel_requested:
                    log("[ChatExport] Request cancelled by user")
                    return None
                
                time.sleep(0.1)
                
        except Exception as e:
            log(f"[ChatExport] Error sending request: {e}")
            return None
    
    def _load_messages_from_api(self, dialog_id: int, max_messages: Optional[int] = None) -> List[Dict[str, Any]]:
        messages = []
        offset_id = 0
        batch_size = 200 if (max_messages and max_messages > 3000) or not max_messages else 100
        total_count = None
        
        try:
            mc = get_messages_controller()
            input_peer = mc.getInputPeer(dialog_id)
            
            if not input_peer:
                log(f"[ChatExport] Cannot get input peer for dialog {dialog_id}")
                return []
            
            log(f"[ChatExport] Starting API fetch for dialog {dialog_id} (batch_size={batch_size})")
            
            batch_count = 0
            while True:
                if self.cancel_requested:
                    log("[ChatExport] API fetch cancelled by user")
                    break
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = input_peer
                req.offset_id = offset_id
                req.limit = batch_size
                req.add_offset = 0
                req.offset_date = 0
                req.hash = 0
                
                response = self._send_request_sync(req)
                
                if not response:
                    log("[ChatExport] No response from API")
                    break
                
                if not isinstance(response, TLRPC.messages_Messages):
                    log(f"[ChatExport] Unexpected response type: {type(response)}")
                    break
                
                if batch_count == 0 and hasattr(response, 'count'):
                    total_count = response.count
                    log(f"[ChatExport] Total messages in chat: {total_count}")

                if hasattr(response, 'users') and response.users:
                    mc.putUsers(response.users, False)
                    log(f"[ChatExport] Cached {response.users.size()} users from API response")

                if hasattr(response, 'chats') and response.chats:
                    mc.putChats(response.chats, False)
                    log(f"[ChatExport] Cached {response.chats.size()} chats from API response")

                batch = response.messages
                batch_count += 1
                
                if hasattr(batch, 'size'):
                    batch_size_count = batch.size()
                    batch_list = [batch.get(i) for i in range(batch_size_count)]
                else:
                    batch_size_count = len(batch)
                    batch_list = list(batch)
                
                log(f"[ChatExport] Batch {batch_count}: received {batch_size_count} messages")
                
                if not batch or batch_size_count == 0:
                    log("[ChatExport] No more messages, reached beginning of chat")
                    break
                
                for msg in batch_list:
                    try:
                        msg_dict = self._tlrpc_message_to_dict(msg)
                        messages.append(msg_dict)
                    except Exception as e:
                        log(f"[ChatExport] Error converting message: {e}")
                
                offset_id = batch_list[-1].id
                
                current_count = len(messages)
                
                if total_count and total_count > 0:
                    target = min(total_count, max_messages) if max_messages else total_count
                    progress_percent = min(int((current_count / target) * 100), 100)
                    progress_text = f"Loaded {current_count}/{target} messages"
                elif max_messages:
                    progress_percent = min(int((current_count / max_messages) * 100), 100)
                    progress_text = f"Loaded {current_count}/{max_messages} messages"
                else:
                    progress_percent = min(int((current_count / 10000) * 100), 99)
                    progress_text = f"Loaded {current_count} messages..."
                
                self._update_progress(progress_text, progress_percent)
                log(f"[ChatExport] {progress_text} ({progress_percent}%)")
                
                if max_messages and len(messages) >= max_messages:
                    log(f"[ChatExport] Reached max messages limit: {max_messages}")
                    messages = messages[:max_messages]
                    break
                
                sleep_time = 0.1 if current_count > 3000 else 0.15
                time.sleep(sleep_time)
            
            messages.reverse()
            
            log(f"[ChatExport] API fetch complete: {len(messages)} messages loaded")
            return messages
            
        except Exception as e:
            log(f"[ChatExport] Error in API fetch: {e}")
            import traceback
            log(traceback.format_exc())
            return []
            
    def _load_chat_messages(self, dialog_id: int) -> List[Dict[str, Any]]:
        
        use_api = self._get_export_setting("use_api_mode", True)
        
        max_messages_str = self._get_export_setting("max_messages", "")
        max_messages = int(max_messages_str) if max_messages_str.strip() else None
        
        if use_api:
            log(f"[ChatExport] Using API mode to fetch messages")
            messages = self._load_messages_from_api(dialog_id, max_messages)
            
            if not messages and not self.cancel_requested:
                log("[ChatExport] API fetch failed, falling back to database")
                return self._load_messages_from_database(dialog_id, max_messages)
            
            return messages if messages else self._create_demo_messages(dialog_id)
        else:
            log(f"[ChatExport] Using database mode to fetch messages")
            return self._load_messages_from_database(dialog_id, max_messages)
    
    def _load_messages_from_database(self, dialog_id: int, max_messages: Optional[int] = None) -> List[Dict[str, Any]]:
        messages = []
        
        try:
            storage = get_messages_storage()
            
            database = get_private_field(storage, "database")
            
            if not database:
                log("[ChatExport] Cannot access database")
                return self._create_demo_messages(dialog_id)
            
            limit = max_messages if max_messages else 10000
            
            query = f"SELECT data, mid, date, uid FROM messages_v2 WHERE uid = {dialog_id} ORDER BY date DESC LIMIT {limit}"
            
            log(f"[ChatExport] Querying database for dialog_id={dialog_id}, limit={limit}")
            
            cursor = database.queryFinalized(query)
            
            loaded_count = 0
            progress_update_interval = 500 if limit > 3000 else 100
            
            while cursor.next():
                if self.cancel_requested:
                    log("[ChatExport] Database fetch cancelled by user")
                    break
                    
                try:
                    data = cursor.byteBufferValue(0)
                    if data:
                        msg = TLRPC.Message.TLdeserialize(data, data.readInt32(False), False)
                        if msg:
                            msg.id = cursor.intValue(1)
                            msg.date = cursor.intValue(2)
                            msg.dialog_id = cursor.longValue(3)
                            
                            messages.append(self._tlrpc_message_to_dict(msg))
                            loaded_count += 1
                            
                            if loaded_count % progress_update_interval == 0:
                                progress_percent = min(int((loaded_count / limit) * 100), 99)
                                self._update_progress(f"Loaded {loaded_count} messages...", progress_percent)
                        
                        data.reuse()
                except Exception as e:
                    log(f"[ChatExport] Error deserializing message: {e}")
                    continue
            
            cursor.dispose()
            
            messages.reverse()
            
            log(f"[ChatExport] Loaded {len(messages)} real messages from database")
            
        except Exception as e:
            log(f"[ChatExport] Database error: {e}")
            import traceback
            log(traceback.format_exc())
            return self._create_demo_messages(dialog_id)
        
        if not messages:
            log(f"[ChatExport] No messages found in database, using demo")
            return self._create_demo_messages(dialog_id)
        
        return messages
        
    def _create_demo_messages(self, dialog_id: int) -> List[Dict[str, Any]]:
        current_user_id = get_user_config().getClientUserId()
        chat_name = self._get_chat_name(dialog_id)
        
        return [
            {
                "id": 1,
                "from_id": current_user_id,
                "text": "This is a demo export showing the structure.",
                "date": int(time.time()) - 3600,
                "out": True
            },
            {
                "id": 2,
                "from_id": dialog_id if dialog_id > 0 else current_user_id,
                "text": f"Actual message export requires database access. This demo shows how your chat with {chat_name} would be exported.",
                "date": int(time.time()) - 3000,
                "out": False
            },
            {
                "id": 3,
                "from_id": current_user_id,
                "text": "The export includes message text, timestamps, sender information, and media placeholders.",
                "date": int(time.time()) - 2400,
                "out": True
            },
            {
                "id": 4,
                "from_id": current_user_id,
                "text": "You can configure export settings in the plugin settings.",
                "date": int(time.time()) - 1800,
                "out": True,
                "media": {"type": "photo", "caption": "Example photo"}
            },
            {
                "id": 5,
                "from_id": dialog_id if dialog_id > 0 else current_user_id,
                "text": "Supported formats: HTML (Telegram Desktop style), JSON, and plain text.",
                "date": int(time.time()) - 600,
                "out": False
            }
        ]
        
    def _tlrpc_message_to_dict(self, msg: TLRPC.Message) -> Dict[str, Any]:
        try:
            result = {
                "id": msg.id,
                "date": msg.date,
                "text": msg.message or "",
                "out": msg.out,
                "_tlrpc_obj": msg,
            }
            
            if hasattr(msg, 'from_id') and msg.from_id:
                if hasattr(msg.from_id, 'user_id'):
                    result["from_id"] = msg.from_id.user_id
                elif hasattr(msg.from_id, 'channel_id'):
                    result["from_id"] = -msg.from_id.channel_id
            elif hasattr(msg, 'peer_id') and msg.peer_id:
                if hasattr(msg.peer_id, 'user_id'):
                    result["from_id"] = msg.peer_id.user_id
                elif hasattr(msg.peer_id, 'channel_id'):
                    result["from_id"] = -msg.peer_id.channel_id
                elif hasattr(msg.peer_id, 'chat_id'):
                    result["from_id"] = -msg.peer_id.chat_id
            
            if msg.media:
                result["media"] = self._extract_media_info(msg.media, msg.message or "")
            
            if hasattr(msg, 'reply_to') and msg.reply_to:
                if hasattr(msg.reply_to, 'reply_to_msg_id'):
                    result["reply_to_msg_id"] = msg.reply_to.reply_to_msg_id
            
            if hasattr(msg, 'fwd_from') and msg.fwd_from:
                result["forwarded"] = True

                if hasattr(msg.fwd_from, 'from_name') and msg.fwd_from.from_name:
                    result["fwd_from_name"] = msg.fwd_from.from_name
                    log(f"[ChatExport] Forward from_name: {msg.fwd_from.from_name}")

                if hasattr(msg.fwd_from, 'post_author') and msg.fwd_from.post_author:
                    if "fwd_from_name" not in result:
                        result["fwd_from_name"] = msg.fwd_from.post_author
                    else:
                        result["fwd_post_author"] = msg.fwd_from.post_author
                    log(f"[ChatExport] Forward post_author: {msg.fwd_from.post_author}")

                if hasattr(msg.fwd_from, 'from_id') and msg.fwd_from.from_id:
                    if hasattr(msg.fwd_from.from_id, 'user_id'):
                        result["fwd_from_id"] = msg.fwd_from.from_id.user_id
                        log(f"[ChatExport] Forward from user_id: {msg.fwd_from.from_id.user_id}")
                    elif hasattr(msg.fwd_from.from_id, 'channel_id'):
                        result["fwd_from_id"] = -msg.fwd_from.from_id.channel_id
                        log(f"[ChatExport] Forward from channel_id: {msg.fwd_from.from_id.channel_id}")
                    elif hasattr(msg.fwd_from.from_id, 'chat_id'):
                        result["fwd_from_id"] = -msg.fwd_from.from_id.chat_id
                        log(f"[ChatExport] Forward from chat_id: {msg.fwd_from.from_id.chat_id}")
            
            if hasattr(msg, 'edit_date') and msg.edit_date:
                result["edited"] = True
                result["edit_date"] = msg.edit_date
            
            if hasattr(msg, 'action') and msg.action:
                result["action"] = True
                result["action_type"] = msg.action.__class__.__name__
            
            return result
            
        except Exception as e:
            log(f"[ChatExport] Error converting TLRPC message: {e}")
            return {
                "id": 0,
                "date": int(time.time()),
                "text": "[Error converting message]",
                "out": False
            }
    
    def _extract_media_info(self, media, caption="", msg_obj=None) -> Dict[str, Any]:
        media_info = {"type": "unknown", "caption": caption}
        
        try:
            media_class = media.__class__.__name__
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto):
                media_info["type"] = "photo"
                if hasattr(media, 'photo') and media.photo:
                    photo_size = _get_best_photo_size(media.photo)
                    if photo_size:
                        media_info["width"] = getattr(photo_size, "w", 0) or getattr(photo_size, "width", 0)
                        media_info["height"] = getattr(photo_size, "h", 0) or getattr(photo_size, "height", 0)
                        
            elif isinstance(media, TLRPC.TL_messageMediaDocument):
                if hasattr(media, 'document'):
                    doc = media.document
                    mime = getattr(doc, 'mime_type', '')
                    
                    if hasattr(doc, 'file_name'):
                        media_info["filename"] = doc.file_name
                    if hasattr(doc, 'size'):
                        media_info["size"] = doc.size
                    
                    attrs = getattr(doc, 'attributes', [])
                    if hasattr(attrs, 'toArray'):
                        attrs = list(attrs.toArray())
                    
                    for attr in attrs:
                        if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                            if mime == "application/x-tgsticker":
                                media_info["type"] = "sticker_animated"
                            elif mime == "video/webm":
                                media_info["type"] = "sticker_video"
                            else:
                                media_info["type"] = "sticker"
                            if hasattr(attr, 'alt'):
                                media_info["emoji"] = attr.alt
                                
                        elif isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                            media_info["type"] = "gif"
                            
                        elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                            if getattr(attr, "round_message", False):
                                media_info["type"] = "video_circle"
                            else:
                                media_info["type"] = "video"
                            media_info["duration"] = getattr(attr, "duration", 0)
                            media_info["width"] = getattr(attr, "w", 0)
                            media_info["height"] = getattr(attr, "h", 0)
                            
                        elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                            if getattr(attr, "voice", False):
                                media_info["type"] = "voice"
                            else:
                                media_info["type"] = "audio"
                            media_info["duration"] = getattr(attr, "duration", 0)
                            media_info["title"] = getattr(attr, "title", "")
                            media_info["performer"] = getattr(attr, "performer", "")
                        
                        elif isinstance(attr, TLRPC.TL_documentAttributeFilename):
                            media_info["filename"] = getattr(attr, "file_name", "")
                    
                    if media_info["type"] == "unknown":
                        if mime.startswith('video/'):
                            media_info["type"] = "video"
                        elif mime.startswith('audio/'):
                            media_info["type"] = "audio"
                        elif mime == "image/gif":
                            media_info["type"] = "gif"
                        else:
                            media_info["type"] = "document"
                            
            elif "WebPage" in media_class:
                media_info["type"] = "webpage"
                if hasattr(media, 'webpage'):
                    webpage = media.webpage
                    if hasattr(webpage, 'url'):
                        media_info["url"] = webpage.url
                    if hasattr(webpage, 'site_name'):
                        media_info["site"] = webpage.site_name
                    if hasattr(webpage, 'title'):
                        media_info["title"] = webpage.title
                    if hasattr(webpage, 'description'):
                        media_info["description"] = webpage.description
                        
            elif "Geo" in media_class or "Venue" in media_class:
                media_info["type"] = "location"
                if hasattr(media, 'geo') and media.geo:
                    if hasattr(media.geo, 'lat') and hasattr(media.geo, 'long'):
                        media_info["lat"] = media.geo.lat
                        media_info["lon"] = media.geo.long
                if "Venue" in media_class:
                    media_info["type"] = "venue"
                    if hasattr(media, 'title'):
                        media_info["title"] = media.title
                    if hasattr(media, 'address'):
                        media_info["address"] = media.address
                        
            elif "Contact" in media_class:
                media_info["type"] = "contact"
                if hasattr(media, 'phone_number'):
                    media_info["phone"] = media.phone_number
                if hasattr(media, 'first_name'):
                    media_info["name"] = media.first_name
                if hasattr(media, 'last_name'):
                    media_info["name"] = f"{media.first_name} {media.last_name}".strip()
                    
            elif "Poll" in media_class:
                media_info["type"] = "poll"
                if hasattr(media, 'poll') and media.poll:
                    if hasattr(media.poll, 'question'):
                        media_info["question"] = media.poll.question
                    if hasattr(media.poll, 'closed'):
                        media_info["closed"] = media.poll.closed
                        
            elif "Game" in media_class:
                media_info["type"] = "game"
                if hasattr(media, 'game'):
                    game = media.game
                    if hasattr(game, 'title'):
                        media_info["title"] = game.title
                    if hasattr(game, 'description'):
                        media_info["description"] = game.description
                        
            elif "Invoice" in media_class:
                media_info["type"] = "invoice"
                if hasattr(media, 'title'):
                    media_info["title"] = media.title
                if hasattr(media, 'description'):
                    media_info["description"] = media.description
                    
            elif "GeoLive" in media_class:
                media_info["type"] = "live_location"
                
            elif "Unsupported" in media_class:
                media_info["type"] = "unsupported"
                
        except Exception as e:
            log(f"[ChatExport] Error extracting media info: {e}")
        
        return media_info
        
    def _generate_html(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        
        current_user_id = get_user_config().getClientUserId()
        current_account = UserConfig.selectedAccount
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        
        media_handling = self._get_export_setting("media_handling", 0)
        want_media = (media_handling == 2)
        want_avatars = self._get_export_setting("include_avatars", True)
        
        max_media_mb_str = self._get_export_setting("max_size_mb", "100")
        try:
            max_media_mb = int(max_media_mb_str) if max_media_mb_str else 10
        except:
            max_media_mb = 10
        
        log(f"[ChatExport] Collecting user IDs from {len(messages)} messages...")
        all_user_ids = set()
        for msg in messages:
            from_id = msg.get("from_id", 0)
            if from_id > 0:
                all_user_ids.add(from_id)

            if "fwd_from_id" in msg:
                fwd_id = msg.get("fwd_from_id", 0)
                if fwd_id > 0:
                    all_user_ids.add(fwd_id)

        if all_user_ids:
            log(f"[ChatExport] Found {len(all_user_ids)} unique users in messages")
            self._load_missing_users(all_user_ids)

        msg_id_map = {msg.get("id"): msg for msg in messages if msg.get("id")}
        log(f"[ChatExport] Created message ID map with {len(msg_id_map)} messages for reply lookups")

        media_manager = None
        if want_media or want_avatars:
            media_manager = MediaDownloadManager(
                account_id=current_account,
                max_workers=6,
                max_media_mb=max_media_mb
            )

            log(f"[ChatExport] Preparing media download: media={want_media}, avatars={want_avatars}, max_mb={max_media_mb}")

            user_ids_seen = set()

            for msg in messages:
                from_id = msg.get("from_id", 0)

                if want_avatars and from_id and from_id not in user_ids_seen:
                    user_ids_seen.add(from_id)
                    sender_user = self._get_user_object(from_id)
                    if sender_user:
                        media_manager.add_avatar_download(from_id, sender_user)
                
                if want_media and msg.get("media"):
                    media_type = _get_media_type_from_message(msg)
                    tlrpc_msg = self._reconstruct_tlrpc_message(msg)
                    if tlrpc_msg:
                        media_manager.add_media_download(msg.get("id", 0), tlrpc_msg, media_type)
            
            log(f"[ChatExport] Starting parallel download of {len(user_ids_seen)} avatars and media...")
            download_start = time.time()
            media_manager.execute_downloads()
            download_time = time.time() - download_start
            log(f"[ChatExport] Download completed in {download_time:.2f}s")

            log(f"[ChatExport] Attaching media data to {len(messages)} messages...")
            attach_start = time.time()

            for msg in messages:
                msg_id = msg.get("id", 0)

                if want_avatars:
                    from_id = msg.get("from_id", 0)
                    if from_id:
                        avatar_data = media_manager.get_result(f"avatar_{from_id}")
                        if avatar_data:
                            msg["_avatar_data_uri"] = avatar_data

                if want_media and msg.get("media"):
                    media_data = media_manager.get_result(f"media_{msg_id}")
                    if media_data:
                        msg["_media_data_uri"] = media_data

            attach_time = time.time() - attach_start
            log(f"[ChatExport] Media data attached in {attach_time:.2f}s")

        log(f"[ChatExport] Generating HTML for {len(messages)} messages...")
        html_start = time.time()

        html = f"""<!DOCTYPE html>
<html lang="en" class="dark">
<head>
 <meta charset="utf-8"/>
 <title>{chat_name}</title>
 <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
 <style>
  :root {{
   --background: oklch(0.98 0.005 264);
   --foreground: oklch(0.25 0.01 264);
   --card: oklch(0.99 0.003 264);
   --card-foreground: oklch(0.25 0.01 264);
   --muted: oklch(0.94 0.008 264);
   --muted-foreground: oklch(0.5 0.01 264);
   --accent: oklch(0.65 0.22 200);
   --accent-foreground: oklch(0.99 0.003 264);
   --border: oklch(0.65 0.05 264);
   --radius: 0.75rem;
  }}
  
  .dark {{
   --background: oklch(0.14 0.015 264);
   --foreground: oklch(0.92 0.01 264);
   --card: oklch(0.18 0.018 264);
   --card-foreground: oklch(0.92 0.01 264);
   --muted: oklch(0.2 0.018 264);
   --muted-foreground: oklch(0.6 0.012 264);
   --accent: oklch(0.65 0.22 200);
   --accent-foreground: oklch(0.14 0.015 264);
   --border: oklch(0.24 0.02 264);
  }}
  
  * {{
   margin: 0;
   padding: 0;
   box-sizing: border-box;
  }}
  
  body {{
   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
   font-size: 15px;
   background: var(--background);
   color: var(--foreground);
   line-height: 1.6;
   min-height: 100vh;
  }}
  
  .page_wrap {{
   min-height: 100vh;
  }}
  
  .page_header {{
   background: color-mix(in oklch, var(--card) 50%, transparent);
   backdrop-filter: blur(20px);
   border-bottom: 1px solid var(--border);
   padding: 12px 16px;
   position: sticky;
   top: 0;
   z-index: 10;
  }}
  
  .page_header .content {{
   max-width: 1024px;
   margin: 0 auto;
  }}
  
  .page_header .header-top {{
   display: flex;
   align-items: center;
   justify-content: space-between;
   gap: 16px;
  }}
  
  .page_header .text {{
   font-size: 20px;
   font-weight: 600;
   color: var(--foreground);
   margin-bottom: 4px;
   letter-spacing: -0.02em;
  }}
  
  .page_header .details {{
   display: flex;
   align-items: center;
   gap: 12px;
   color: var(--muted-foreground);
   font-size: 13px;
  }}
  
  .page_header .details .separator {{
   color: color-mix(in oklch, var(--muted-foreground) 50%, transparent);
  }}
  
  .theme-toggle {{
   position: relative;
   background: var(--muted);
   border: 1px solid var(--border);
   border-radius: calc(var(--radius) + 2px);
   padding: 4px;
   cursor: pointer;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   white-space: nowrap;
   flex-shrink: 0;
   width: 64px;
   height: 32px;
   display: flex;
   align-items: center;
   justify-content: space-between;
   overflow: hidden;
  }}
  
  .theme-toggle:hover {{
   background: color-mix(in oklch, var(--muted) 80%, var(--accent) 20%);
   border-color: var(--accent);
   transform: translateY(-1px);
   box-shadow: 0 4px 12px color-mix(in oklch, var(--accent) 20%, transparent);
  }}
  
  .theme-toggle:active {{
   transform: translateY(0);
   box-shadow: 0 2px 6px color-mix(in oklch, var(--accent) 15%, transparent);
  }}
  
  .theme-toggle-track {{
   position: absolute;
   top: 2px;
   left: 2px;
   right: 2px;
   bottom: 2px;
   background: linear-gradient(90deg, 
     color-mix(in oklch, var(--background) 90%, var(--accent) 10%) 0%,
     color-mix(in oklch, var(--background) 70%, var(--accent) 30%) 100%);
   border-radius: calc(var(--radius) - 2px);
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   box-shadow: inset 0 1px 3px color-mix(in oklch, var(--foreground) 10%, transparent);
  }}
  
  .theme-toggle-thumb {{
   position: relative;
   width: 24px;
   height: 24px;
   background: var(--background);
   border: 1px solid var(--border);
   border-radius: 50%;
   transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
   display: block;
   z-index: 2;
   box-shadow: 0 2px 6px color-mix(in oklch, var(--foreground) 15%, transparent),
               0 1px 2px color-mix(in oklch, var(--foreground) 5%, transparent);
  }}
  
  .theme-toggle-thumb::before {{
   content: '';
   position: absolute;
   inset: -2px;
   background: linear-gradient(135deg, 
     color-mix(in oklch, var(--accent) 30%, transparent) 0%,
     color-mix(in oklch, var(--accent) 60%, transparent) 100%);
   border-radius: 50%;
   opacity: 0;
   transition: opacity 0.3s ease;
   z-index: -1;
  }}
  
  .theme-toggle:hover .theme-toggle-thumb::before {{
   opacity: 1;
  }}
  
  /* Icons removed */
  
  /* Dark theme state */
  .dark .theme-toggle-track {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, var(--background) 70%, var(--accent) 30%) 0%,
     color-mix(in oklch, var(--background) 90%, var(--accent) 10%) 100%);
  }}
  
  .dark .theme-toggle-thumb {{
   transform: translateX(32px);
  }}
  
  .dark .theme-toggle-icon.sun {{
   opacity: 0;
   transform: translateY(-50%) scale(0.8) rotate(180deg);
  }}
  
  .dark .theme-toggle-icon.moon {{
   opacity: 1;
   transform: translateY(-50%) scale(1.1) rotate(0deg);
  }}
  
  /* Light theme state */
  .theme-toggle-icon.sun {{
   opacity: 1;
   transform: translateY(-50%) scale(1.1) rotate(0deg);
  }}
  
  .theme-toggle-icon.moon {{
   opacity: 0;
   transform: translateY(-50%) scale(0.8) rotate(-180deg);
  }}
  
  .page_body {{
   max-width: 1024px;
   margin: 0 auto;
   padding: 32px 24px;
  }}
  
  .history {{
   padding: 0;
  }}
  
  .date-divider {{
   display: flex;
   align-items: center;
   gap: 16px;
   margin: 32px 0;
  }}
  
  .date-divider .line {{
   flex: 1;
   height: 1px;
   background: var(--border);
  }}
  
  .date-divider .text {{
   font-size: 14px;
   font-weight: 500;
   color: var(--muted-foreground);
   padding: 6px 16px;
   background: color-mix(in oklch, var(--muted) 80%, transparent);
   border-radius: 9999px;
   border: 1px solid var(--border);
  }}
  
  .message {{
   margin: 4px 0;
   clear: both;
  }}
  
  .message.default {{
   display: flex;
   gap: 16px;
   padding: 12px 16px;
   border-radius: calc(var(--radius) + 4px);
   transition: background 0.2s ease;
  }}
  
  .message.default:hover {{
   background: color-mix(in oklch, var(--muted) 70%, transparent);
  }}
  
  .message.service {{
   text-align: center;
   padding: 16px 0;
  }}
  
  .message.service .body {{
   color: var(--muted-foreground);
   font-size: 13px;
  }}
  
  .userpic_wrap {{
   flex-shrink: 0;
  }}
  
  .userpic {{
   width: 40px;
   height: 40px;
   border-radius: 50%;
   display: flex;
   align-items: center;
   justify-content: center;
   font-weight: 500;
   font-size: 14px;
   color: #FFFFFF;
   position: relative;
   overflow: hidden;
  }}
  
  .userpic::after {{
   content: '';
   position: absolute;
   inset: 0;
   border-radius: 50%;
   box-shadow: inset 0 0 0 2px var(--background);
  }}
  
  .userpic img {{
   width: 100%;
   height: 100%;
   object-fit: cover;
   border-radius: 50%;
  }}
  
  .userpic1 {{ background: linear-gradient(135deg, #E17076, #DA5B62); }}
  .userpic2 {{ background: linear-gradient(135deg, #F2C94C, #E8B73B); }}
  .userpic3 {{ background: linear-gradient(135deg, #66BB6A, #5AAD5E); }}
  .userpic4 {{ background: linear-gradient(135deg, #64B5EF, #5AA1DB); }}
  .userpic5 {{ background: linear-gradient(135deg, #9575CD, #8462BC); }}
  .userpic6 {{ background: linear-gradient(135deg, #F06292, #E05480); }}
  .userpic7 {{ background: linear-gradient(135deg, #4FC3F7, #45B0E5); }}
  .userpic8 {{ background: linear-gradient(135deg, #FFB74D, #F0A73B); }}
  
  .initials {{
   text-align: center;
   font-size: 16px;
  }}
  
  .body {{
   flex: 1;
   min-width: 0;
  }}
  
  .message-header {{
   display: flex;
   align-items: baseline;
   gap: 12px;
   margin-bottom: 4px;
  }}
  
  .from_name {{
   font-weight: 600;
   color: var(--accent);
   font-size: 14px;
  }}
  
  .date {{
   color: var(--muted-foreground);
   font-size: 12px;
   white-space: nowrap;
  }}
  
  .date.edited {{
   color: color-mix(in oklch, var(--muted-foreground) 60%, transparent);
  }}
  
  .text {{
   color: var(--foreground);
   line-height: 1.6;
   word-wrap: break-word;
   white-space: pre-wrap;
   font-size: 15px;
  }}
  
  .text a {{
   color: var(--accent);
   text-decoration: none;
  }}
  
  .text a:hover {{
   text-decoration: underline;
  }}
  
  .media_wrap {{
   margin: 12px 0;
  }}
  
  .photo {{
   max-width: 100%;
   border-radius: var(--radius);
   display: block;
  }}
  
  .media-placeholder {{
   background: var(--muted);
   padding: 16px 20px;
   border-radius: var(--radius);
   color: var(--muted-foreground);
   font-size: 14px;
   margin: 12px 0;
  }}
  
  img.media {{
   max-width: 100%;
   max-height: 500px;
   border-radius: var(--radius);
   margin-top: 12px;
   cursor: pointer;
   object-fit: contain;
   display: block;
   transition: opacity 0.2s ease, transform 0.1s ease;
  }}
  
  img.media:hover {{
   opacity: 0.9;
   transform: scale(1.005);
  }}
  
  img.media:active {{
   transform: scale(0.995);
  }}
  
  .sticker {{
   max-width: 180px;
   max-height: 180px;
   margin-top: 12px;
   display: inline-block;
  }}
  
  .sticker-video {{
   max-width: 180px;
   max-height: 180px;
   margin-top: 12px;
   display: inline-block;
   background: transparent;
  }}
  
  .sticker-animated {{
   max-width: 180px;
   max-height: 180px;
   margin-top: 12px;
   display: inline-block;
   background: var(--muted);
   border-radius: var(--radius);
   padding: 12px;
   text-align: center;
   color: var(--muted-foreground);
   font-size: 12px;
  }}
  
  .gif {{
   max-width: 100%;
   max-height: 400px;
   border-radius: var(--radius);
   margin-top: 12px;
   display: block;
  }}
  
  .video-circle {{
   width: 220px;
   height: 220px;
   border-radius: 50%;
   object-fit: cover;
   margin-top: 12px;
   display: block;
  }}
  
  video.media {{
   max-width: 100%;
   max-height: 500px;
   border-radius: var(--radius);
   margin-top: 12px;
   background: var(--muted);
   display: block;
  }}
  
  audio.media {{
   max-width: 100%;
   border-radius: var(--radius);
   margin-top: 12px;
   background: var(--muted);
   display: block;
  }}
  
  .voice-message {{
   padding: 12px 16px;
   background: color-mix(in oklch, var(--muted) 20%, transparent);
   border-left: 3px solid var(--accent);
   border-radius: calc(var(--radius) - 2px);
   margin-top: 8px;
   font-size: 13px;
   color: var(--muted-foreground);
   display: flex;
   align-items: center;
   gap: 8px;
  }}
  
  .forwarded-header {{
   font-size: 13px;
   color: var(--muted-foreground);
   margin-bottom: 8px;
   padding-left: 12px;
   border-left: 2px solid var(--accent);
  }}
  
  .reply-reference {{
   font-size: 13px;
   background: color-mix(in oklch, var(--muted) 40%, transparent);
   padding: 10px 12px;
   border-radius: calc(var(--radius) - 2px);
   margin-bottom: 8px;
   border-left: 3px solid color-mix(in oklch, var(--accent) 60%, transparent);
   cursor: pointer;
   transition: all 0.2s ease;
  }}

  .reply-reference:hover {{
   background: color-mix(in oklch, var(--muted) 60%, transparent);
   border-left-color: var(--accent);
  }}
  
  .reply-author {{
   font-size: 12px;
   font-weight: 600;
   color: var(--accent);
   margin-bottom: 2px;
  }}
  
  .reply-text {{
   color: var(--muted-foreground);
   overflow: hidden;
   text-overflow: ellipsis;
   display: -webkit-box;
   -webkit-line-clamp: 2;
   -webkit-box-orient: vertical;
  }}

  .reply-not-found {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, oklch(0.6 0.12 35) 10%, transparent) 0%,
     color-mix(in oklch, var(--muted) 5%, transparent) 100%);
   border-left: 2px solid oklch(0.6 0.15 35) !important;
   border-radius: calc(var(--radius) - 2px);
   opacity: 0.85;
   position: relative;
   padding-left: 36px;
   box-shadow: inset 0 0 0 1px color-mix(in oklch, oklch(0.6 0.1 35) 15%, transparent);
  }}
  
  .reply-not-found::before {{
   content: '⚠️';
   position: absolute;
   left: 11px;
   top: 50%;
   transform: translateY(-50%);
   font-size: 16px;
   opacity: 0.7;
   filter: grayscale(0.3);
  }}

  .reply-not-found:hover {{
   background: linear-gradient(90deg, 
     color-mix(in oklch, oklch(0.6 0.12 35) 18%, transparent) 0%,
     color-mix(in oklch, var(--muted) 10%, transparent) 100%);
   border-left-color: oklch(0.65 0.18 35) !important;
   opacity: 1;
   box-shadow: inset 0 0 0 1px color-mix(in oklch, oklch(0.6 0.1 35) 25%, transparent);
  }}
  
  .reply-not-found .reply-author {{
   color: color-mix(in oklch, var(--foreground) 75%, transparent);
   font-style: italic;
   font-weight: 500;
  }}
  
  .reply-not-found .reply-text {{
   color: color-mix(in oklch, var(--muted-foreground) 80%, transparent);
   font-style: italic;
   font-size: 12px;
  }}

  .clearfix::after {{
   content: "";
   display: table;
   clear: both;
  }}

  .bold {{
   font-weight: 600;
  }}

  /* Highlight animation for scrolled-to message */
  @keyframes messageHighlight {{
   0% {{
    background-color: color-mix(in oklch, var(--accent) 30%, transparent);
   }}
   100% {{
    background-color: transparent;
   }}
  }}

  .message.highlighted {{
   animation: messageHighlight 2s ease-out;
  }}

  /* Lightbox */
  .lightbox {{
   position: fixed;
   inset: 0;
   z-index: 9999;
   background: rgba(0, 0, 0, 0.95);
   backdrop-filter: blur(8px);
   display: none;
   align-items: center;
   justify-content: center;
   animation: lightboxFadeIn 0.2s ease-out;
  }}
  
  .lightbox.active {{
   display: flex;
  }}
  
  @keyframes lightboxFadeIn {{
   from {{
    opacity: 0;
   }}
   to {{
    opacity: 1;
   }}
  }}
  
  .lightbox-header {{
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   z-index: 10;
   display: flex;
   align-items: center;
   justify-content: space-between;
   padding: 16px;
   background: linear-gradient(180deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%);
  }}
  
  .lightbox-controls {{
   display: flex;
   gap: 8px;
  }}
  
  .lightbox-btn {{
   background: rgba(255, 255, 255, 0.1);
   border: none;
   border-radius: 8px;
   width: 40px;
   height: 40px;
   display: flex;
   align-items: center;
   justify-content: center;
   color: white;
   cursor: pointer;
   transition: all 0.2s ease;
   font-size: 20px;
   line-height: 1;
   padding: 0;
  }}
  
  .lightbox-btn svg {{
   width: 20px;
   height: 20px;
   stroke: white;
   stroke-width: 2;
   stroke-linecap: round;
   stroke-linejoin: round;
   fill: none;
   transition: transform 0.2s ease;
  }}
  
  .lightbox-btn:hover {{
   background: rgba(255, 255, 255, 0.2);
   transform: translateY(-1px);
  }}
  
  .lightbox-btn:hover svg {{
   transform: translateY(1px);
  }}
  
  .lightbox-btn:active {{
   transform: scale(0.95) translateY(0);
  }}
  
  .lightbox-btn:active svg {{
   transform: translateY(2px);
  }}
  
  .lightbox-content {{
   max-width: 95vw;
   max-height: 95vh;
   padding: 80px 20px 20px;
   display: flex;
   align-items: center;
   justify-content: center;
  }}
  
  .lightbox-image {{
   max-width: 100%;
   max-height: 100%;
   object-fit: contain;
   border-radius: 12px;
   box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
   animation: lightboxImageZoom 0.3s ease-out;
   user-select: none;
  }}
  
  @keyframes lightboxImageZoom {{
   from {{
    opacity: 0;
    transform: scale(0.95);
   }}
   to {{
    opacity: 1;
    transform: scale(1);
   }}
  }}
  
  .lightbox-footer {{
   position: absolute;
   bottom: 0;
   left: 0;
   right: 0;
   height: 100px;
   background: linear-gradient(0deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%);
   pointer-events: none;
  }}
  
  body.lightbox-open {{
   overflow: hidden;
  }}

  @media (max-width: 768px) {{
   .page_header {{
    padding: 10px 12px;
   }}
   
   .page_body {{
    padding: 20px 16px;
   }}
   
   .page_header .text {{
    font-size: 18px;
   }}
   
   .page_header .details {{
    font-size: 12px;
    gap: 8px;
   }}
   
   .theme-toggle {{
    width: 56px;
    height: 28px;
   }}
   
   .theme-toggle-thumb {{
    width: 20px;
    height: 20px;
    font-size: 10px;
   }}
   
   .dark .theme-toggle-thumb {{
    transform: translateX(28px);
   }}
   
   .message.default {{
    gap: 12px;
    padding: 8px 12px;
   }}
   
   .lightbox-content {{
    padding: 60px 12px 12px;
   }}
   
   .lightbox-btn {{
    width: 36px;
    height: 36px;
    font-size: 18px;
   }}
   
   .lightbox-btn svg {{
    width: 18px;
    height: 18px;
   }}
  }}
 </style>
 <script>
  // Theme toggle functionality
  function toggleTheme() {{
   const html = document.documentElement;
   const currentTheme = html.classList.contains('dark') ? 'dark' : 'light';
   const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
   
   // Add transition class for smooth theme change
   html.style.transition = 'background-color 0.3s ease, color 0.3s ease';
   
   if (newTheme === 'light') {{
    html.classList.remove('dark');
   }} else {{
    html.classList.add('dark');
   }}
   
   // Save preference
   try {{
    localStorage.setItem('theme', newTheme);
   }} catch (e) {{}}
   
   // Remove transition class after animation
   setTimeout(() => {{
    html.style.transition = '';
   }}, 300);
   
   // Add click animation to button
   const button = document.getElementById('theme-toggle');
   if (button) {{
    button.style.transform = 'scale(0.95)';
    setTimeout(() => {{
     button.style.transform = '';
    }}, 150);
   }}
  }}
  
  // Load saved theme preference
  document.addEventListener('DOMContentLoaded', function() {{
   try {{
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'light') {{
     document.documentElement.classList.remove('dark');
    }}
   }} catch (e) {{}}
  }});
  
  // Smooth scroll to message when clicking on reply
  function scrollToMessage(messageId) {{
   const targetElement = document.getElementById('message' + messageId);
   if (targetElement) {{
    // Smooth scroll to the message
    targetElement.scrollIntoView({{
     behavior: 'smooth',
     block: 'center'
    }});

    // Add highlight animation
    targetElement.classList.remove('highlighted');
    // Force reflow to restart animation
    void targetElement.offsetWidth;
    targetElement.classList.add('highlighted');

    // Remove highlight class after animation
    setTimeout(() => {{
     targetElement.classList.remove('highlighted');
    }}, 2000);
   }}
  }}

  // Lightbox functionality
  let currentLightboxImage = null;
  
  function openLightbox(imageSrc, imageAlt) {{
   const lightbox = document.getElementById('image-lightbox');
   const lightboxImage = document.getElementById('lightbox-image');
   
   if (lightbox && lightboxImage) {{
    currentLightboxImage = imageSrc;
    lightboxImage.src = imageSrc;
    lightboxImage.alt = imageAlt || 'Image';
    lightbox.classList.add('active');
    document.body.classList.add('lightbox-open');
   }}
  }}
  
  function closeLightbox() {{
   const lightbox = document.getElementById('image-lightbox');
   if (lightbox) {{
    lightbox.classList.remove('active');
    document.body.classList.remove('lightbox-open');
    currentLightboxImage = null;
   }}
  }}
  
  function downloadImage() {{
   if (currentLightboxImage) {{
    const link = document.createElement('a');
    link.href = currentLightboxImage;
    link.download = 'image';
    link.click();
   }}
  }}
  
  // Add click handlers to all reply references and images
  document.addEventListener('DOMContentLoaded', function() {{
   // Reply references
   const replyElements = document.querySelectorAll('.reply-reference');
   replyElements.forEach(function(element) {{
    const replyToId = element.getAttribute('data-reply-to');
    if (replyToId) {{
     element.addEventListener('click', function() {{
      scrollToMessage(replyToId);
     }});
    }}
   }});
   
   // Image lightbox
   const mediaImages = document.querySelectorAll('img.media, img.photo');
   mediaImages.forEach(function(img) {{
    img.style.cursor = 'pointer';
    img.addEventListener('click', function() {{
     openLightbox(this.src, this.alt);
    }});
   }});
   
   // Lightbox close on background click
   const lightbox = document.getElementById('image-lightbox');
   if (lightbox) {{
    lightbox.addEventListener('click', function(e) {{
     if (e.target === lightbox) {{
      closeLightbox();
     }}
    }});
   }}
   
   // ESC key to close lightbox
   document.addEventListener('keydown', function(e) {{
    if (e.key === 'Escape') {{
     closeLightbox();
    }}
   }});
  }});
 </script>
</head>
<body>
 <div class="page_wrap">
  <div class="page_header">
   <div class="content">
    <div class="header-top">
     <div>
      <div class="text bold">
{chat_name}
      </div>
      <div class="details">
       <span>📅 Exported on {export_date}</span>
       <span class="separator">•</span>
       <span>{len(messages)} messages</span>
      </div>
     </div>
    <button id="theme-toggle" class="theme-toggle" onclick="toggleTheme()">
     <div class="theme-toggle-track"></div>
     <div class="theme-toggle-thumb"></div>
    </button>
    </div>
   </div>
  </div>
  <div class="page_body">
   <div class="history">
"""
        
        include_timestamps = self._get_export_setting("include_timestamps", True)
        group_messages = self._get_export_setting("group_messages", True)
        
        if not messages:
            html += """
    <div class="message service">
     <div class="body details">
No messages available for export.
     </div>
    </div>
"""
        else:
            last_sender = None
            last_date = None

            log(f"[ChatExport] Rendering {len(messages)} messages to HTML...")
            render_start = time.time()
            msg_count = 0

            html_parts = [html]
            
            progress_interval = 1000 if len(messages) > 3000 else 500

            for msg in messages:
                if self.cancel_requested:
                    log("[ChatExport] HTML rendering cancelled by user")
                    break
                    
                date_obj = time.localtime(msg.get("date", 0))
                msg_date = time.strftime("%d %B %Y", date_obj)
                if msg_date.startswith("0"):
                    msg_date = msg_date[1:]

                if last_date != msg_date:
                    html_parts.append(f"""
    <div class="date-divider" id="message-date-{msg.get('date', 0)}">
     <div class="line"></div>
     <span class="text">{msg_date}</span>
     <div class="line"></div>
    </div>
""")
                    last_date = msg_date

                html_parts.append(self._format_message_html(msg, current_user_id, include_timestamps, group_messages, last_sender, msg_id_map))
                last_sender = msg.get("from_id")

                msg_count += 1
                if msg_count % progress_interval == 0:
                    progress_percent = int((msg_count / len(messages)) * 100)
                    self._update_progress(f"Rendered {msg_count}/{len(messages)} messages...", progress_percent)
                    log(f"[ChatExport] Rendered {msg_count}/{len(messages)} messages...")

            html = "".join(html_parts)

            render_time = time.time() - render_start
            log(f"[ChatExport] HTML rendering completed in {render_time:.2f}s")

        html += """
   </div>
  </div>
 </div>
 
 <!-- Image Lightbox -->
 <div id="image-lightbox" class="lightbox">
  <div class="lightbox-header">
   <div class="lightbox-controls">
    <button class="lightbox-btn" onclick="downloadImage()" title="Download image">
     <svg viewBox="0 0 24 24">
      <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
      <polyline points="7 10 12 15 17 10"></polyline>
      <line x1="12" y1="15" x2="12" y2="3"></line>
     </svg>
    </button>
   </div>
   <button class="lightbox-btn" onclick="closeLightbox()" title="Close (Esc)">
    <svg viewBox="0 0 24 24">
     <line x1="18" y1="6" x2="6" y2="18"></line>
     <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
   </button>
  </div>
  
  <div class="lightbox-content" onclick="event.stopPropagation()">
   <img id="lightbox-image" src="" alt="" class="lightbox-image">
  </div>
  
  <div class="lightbox-footer"></div>
 </div>
</body>
</html>
"""

        html_time = time.time() - html_start
        log(f"[ChatExport] Total HTML generation time: {html_time:.2f}s, size: {len(html)} bytes")

        return html
        
    def _format_message_html(self, msg: Dict[str, Any], current_user_id: int,
                            include_timestamps: bool, group_messages: bool,
                            last_sender: Optional[int], msg_id_map: Dict[int, Dict[str, Any]]) -> str:

        if msg.get("action", False):
            action_type = msg.get("action_type", "")
            from_id = msg.get("from_id", 0)
            sender_name = self._get_sender_name(from_id)
            action_text = self._format_service_message(msg, action_type, sender_name)
            return f"""
    <div class="message service" id="message{msg.get('id', 0)}">
     <div class="body details">
{action_text}
     </div>
    </div>
"""
        
        from_id = msg.get("from_id", 0)
        sender_name = self._get_sender_name(from_id)
        
        timestamp = ""
        if include_timestamps:
            msg_time = time.strftime("%H:%M", time.localtime(msg.get("date", 0)))
            timestamp = f' title="{time.strftime("%d.%m.%Y %H:%M:%S", time.localtime(msg.get("date", 0)))}"'
            timestamp_display = msg_time
        else:
            timestamp_display = ""
        
        html = f"""
    <div class="message default" id="message{msg.get('id', 0)}">
"""
        
        avatar_data_uri = msg.get("_avatar_data_uri")
        html += f"""
     <div class="userpic_wrap">
{self._generate_userpic_html(from_id, avatar_data_uri)}
     </div>
"""
        
        html += """
     <div class="body">
"""
        
        html += f"""
      <div class="message-header">
       <span class="from_name">{sender_name}</span>
"""
        
        if include_timestamps:
            edited_mark = " <span class='edited'>(edited)</span>" if msg.get("edited", False) else ""
            html += f"""
       <span class="date"{timestamp}>{timestamp_display}{edited_mark}</span>
"""
        
        html += """
      </div>
"""
        
        if msg.get("forwarded", False):
            fwd_name = msg.get("fwd_from_name", "")

            if not fwd_name and "fwd_from_id" in msg:
                fwd_id = msg["fwd_from_id"]
                fwd_name = self._get_sender_name(fwd_id)

            post_author = msg.get("fwd_post_author", "")
            if post_author and fwd_name and fwd_name != post_author and fwd_name != "Unknown":
                fwd_display = f"{fwd_name} ({post_author})"
            elif post_author:
                fwd_display = post_author
            elif fwd_name and fwd_name != "Unknown":
                fwd_display = fwd_name
            else:
                fwd_display = "Forwarded message"

            fwd_display_escaped = fwd_display.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

            html += f"""
      <div class="forwarded-header">
Forwarded from {fwd_display_escaped}
      </div>
"""
        
        if "reply_to_msg_id" in msg:
            reply_to_id = msg["reply_to_msg_id"]

            if reply_to_id in msg_id_map:
                replied_msg = msg_id_map[reply_to_id]
                reply_sender_name = self._get_sender_name(replied_msg.get("from_id", 0))
                reply_text = replied_msg.get("text", "")

                if not reply_text:
                    if replied_msg.get("media"):
                        media_type = replied_msg.get("media", {}).get("type", "unknown")
                        if media_type == "photo":
                            reply_text = "📷 Photo"
                        elif media_type == "video":
                            reply_text = "🎥 Video"
                        elif media_type == "voice":
                            reply_text = "🎤 Voice message"
                        elif media_type == "audio":
                            reply_text = "🎵 Audio"
                        elif media_type == "sticker":
                            reply_text = "Sticker"
                        elif media_type == "sticker_video":
                            reply_text = "Video Sticker"
                        elif media_type == "sticker_animated":
                            reply_text = "Animated Sticker"
                        elif media_type == "gif":
                            reply_text = "GIF"
                        elif media_type == "document":
                            reply_text = "📎 File"
                        else:
                            reply_text = "[Media]"
                    else:
                        reply_text = "[Message]"

                if len(reply_text) > 100:
                    reply_text = reply_text[:100] + "..."

                reply_text_escaped = reply_text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
                reply_sender_escaped = reply_sender_name.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

                html += f"""
      <div class="reply-reference" data-reply-to="{reply_to_id}" title="Click to scroll to message">
       <div class="reply-author">{reply_sender_escaped}</div>
       <div class="reply-text">{reply_text_escaped}</div>
      </div>
"""
            else:
                html += f"""
      <div class="reply-reference reply-not-found" title="Message not found (may be outside loaded range or deleted)">
       <div class="reply-author">Reply to message #{reply_to_id}</div>
       <div class="reply-text">Message not available in this export</div>
      </div>
"""
        
        media = msg.get("media")
        if media:
            media_type = media.get("type", "unknown")
            msg_id = msg.get("id", 0)
            
            media_data_uri = msg.get("_media_data_uri")
            
            if media_data_uri:
                if media_type == "sticker":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="sticker" src="{media_data_uri}" loading="lazy" alt="Sticker {emoji}" title="{emoji}"/>
      </div>
"""
                elif media_type == "sticker_video":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <video class="sticker-video" src="{media_data_uri}" autoplay loop muted playsinline alt="Video Sticker {emoji}" title="{emoji}"></video>
      </div>
"""
                elif media_type == "sticker_animated":
                    emoji = media.get("emoji", "")
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="sticker-animated" title="Animated Sticker {emoji}">
        {emoji}<br/>
        <small>Animated Sticker (TGS)</small>
       </div>
      </div>
"""
                elif media_type == "gif":
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="gif" src="{media_data_uri}" loading="lazy" alt="GIF"/>
      </div>
"""
                elif media_type == "video_circle":
                    html += f"""
      <div class="media_wrap clearfix">
       <video class="video-circle" src="{media_data_uri}" controls loop></video>
      </div>
"""
                elif media_type == "video":
                    duration = media.get("duration", 0)
                    duration_str = f"{int(duration // 60)}:{int(duration % 60):02d}" if duration > 0 else ""
                    html += f"""
      <div class="media_wrap clearfix">
       <video class="media" src="{media_data_uri}" controls>
        <p>Video{f" ({duration_str})" if duration_str else ""}</p>
       </video>
      </div>
"""
                elif media_type == "voice":
                    duration = media.get("duration", 0)
                    duration_str = f"{int(duration // 60)}:{int(duration % 60):02d}" if duration > 0 else "0:00"
                    html += f"""
      <div class="media_wrap clearfix">
       <div class="voice-message">
        🎤 <audio class="media" src="{media_data_uri}" controls style="flex: 1;"></audio> {duration_str}
       </div>
      </div>
"""
                elif media_type == "audio":
                    title = media.get("title", "")
                    performer = media.get("performer", "")
                    audio_label = f"{performer} - {title}".strip(" -") if (title or performer) else "Audio"
                    html += f"""
      <div class="media_wrap clearfix">
       <div style="margin-top: 8px;">
        <div style="color: #8A8A8A; font-size: 12px; margin-bottom: 4px;">🎵 {audio_label}</div>
        <audio class="media" src="{media_data_uri}" controls></audio>
       </div>
      </div>
"""
                elif media_type == "photo":
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="media" src="{media_data_uri}" loading="lazy" alt="Photo"/>
      </div>
"""
                else:
                    html += f"""
      <div class="media_wrap clearfix">
       <img class="media" src="{media_data_uri}" loading="lazy" alt="{media_type}"/>
      </div>
"""
            else:
                media_emoji = {
                    "photo": "📷",
                    "video": "🎥",
                    "document": "📎",
                    "audio": "🎵",
                    "voice": "🎤",
                    "sticker": "🎭",
                    "sticker_video": "🎭",
                    "sticker_animated": "🎭",
                    "gif": "🎞️",
                    "video_circle": "🔵",
                    "location": "📍",
                    "venue": "📍",
                    "contact": "👤",
                    "poll": "📊",
                    "webpage": "🔗",
                    "game": "🎮",
                    "invoice": "💳"
                }.get(media_type, "📎")
                
                media_text = {
                    "photo": "Photo",
                    "video": "Video",
                    "document": "Document",
                    "audio": "Audio",
                    "voice": "Voice Message",
                    "sticker": "Sticker",
                    "sticker_video": "Video Sticker",
                    "sticker_animated": "Animated Sticker",
                    "gif": "GIF",
                    "video_circle": "Video Message",
                    "location": "Location",
                    "venue": "Venue",
                    "contact": "Contact",
                    "poll": "Poll",
                    "webpage": "Link Preview",
                    "game": "Game",
                    "invoice": "Invoice"
                }.get(media_type, media_type.title())
                
                extra_info = ""
                if media.get("filename"):
                    extra_info = f" • {media.get('filename')}"
                elif media.get("title"):
                    extra_info = f" • {media.get('title')}"
                elif media.get("duration"):
                    duration = media.get("duration", 0)
                    extra_info = f" • {int(duration // 60)}:{int(duration % 60):02d}"
                
                html += f"""
      <div class="media_wrap clearfix">
       <div class="media-placeholder">
{media_emoji} {media_text}{extra_info}
       </div>
      </div>
"""
        
        text = msg.get("text", "")
        if text:
            text = text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            url_pattern = r'(https?://[^\s<>"&]+|www\.[^\s<>"&]+)'
            text = re.sub(url_pattern, r'<a href="\1">\1</a>', text)
            
            html += f"""
      <div class="text">
{text}
      </div>
"""
        
        html += """
     </div>
    </div>
"""
        
        return html
    
    def _format_service_message(self, msg: Dict[str, Any], action_type: str, sender_name: str = "") -> str:
        
        actor = sender_name if sender_name and sender_name != "Unknown" else "User"
        
        if "ChatAddUser" in action_type:
            return f"{actor} added users to the group"
        elif "ChatDeleteUser" in action_type:
            return f"{actor} left the group"
        elif "ChatJoinedByLink" in action_type:
            return f"{actor} joined the group via invite link"
        elif "ChatJoinedByRequest" in action_type:
            return f"{actor} joined the group"
        elif "UserJoined" in action_type:
            return f"{actor} joined Telegram"
        
        elif "ChatCreate" in action_type:
            return f"{actor} created the group"
        elif "ChannelCreate" in action_type:
            return f"{actor} created the channel"
        elif "ChatEditTitle" in action_type:
            return f"{actor} changed the group title"
        elif "ChatEditPhoto" in action_type:
            return f"{actor} changed the group photo"
        elif "ChatDeletePhoto" in action_type:
            return f"{actor} removed the group photo"
        elif "ChatMigrateTo" in action_type:
            return f"{actor} upgraded this group to a supergroup"
        elif "ChannelMigrateFrom" in action_type:
            return "migrated from a basic group"
        
        elif "PinMessage" in action_type:
            return f"{actor} pinned a message"
        elif "HistoryClear" in action_type:
            return f"{actor} cleared chat history"
        
        elif "PhoneCall" in action_type:
            return "📞 Phone call"
        elif "GroupCall" in action_type:
            return "📞 Group call"
        elif "GroupCallScheduled" in action_type:
            return "📅 Scheduled a group call"
        elif "InviteToGroupCall" in action_type:
            return "invited members to group call"
        elif "ConferenceCall" in action_type:
            return "📞 Conference call"
        
        elif "ScreenshotTaken" in action_type:
            return "📸 Screenshot taken"
        elif "SecureValuesSent" in action_type:
            return "🔐 Sent Telegram Passport data"
        elif "ContactSignUp" in action_type:
            return "joined Telegram"
        
        elif "PaymentSent" in action_type:
            return "💳 Payment sent"
        elif "PaymentRefunded" in action_type:
            return "💸 Payment refunded"
        elif "GiftPremium" in action_type:
            return "🎁 Sent Telegram Premium gift"
        elif "GiftStars" in action_type:
            return "⭐ Sent Telegram Stars"
        elif "GiftTon" in action_type:
            return "💎 Sent TON gift"
        elif "GiftCode" in action_type:
            return "🎁 Sent gift code"
        elif "StarGift" in action_type:
            return "⭐ Sent star gift"
        elif "StarGiftUnique" in action_type:
            return "⭐ Sent unique star gift"
        elif "PaidMessagesPrice" in action_type:
            return "💰 Set paid messages price"
        elif "PaidMessagesRefunded" in action_type:
            return "💸 Refunded paid messages"
        
        elif "GameScore" in action_type:
            return "🎮 Scored in game"
        elif "BotAllowed" in action_type:
            return "🤖 Allowed bot to send messages"
        elif "AttachMenuBotAllowed" in action_type:
            return "🤖 Added bot to attachment menu"
        elif "WebViewDataSent" in action_type:
            return "📤 Sent data from Web App"
        elif "RequestedPeer" in action_type:
            return "👤 Shared a contact"
        
        elif "SetMessagesTTL" in action_type or "TTLChange" in action_type:
            return "⏱️ Changed self-destruct timer"
        elif "SetChatTheme" in action_type:
            return "🎨 Changed chat theme"
        elif "SetChatWallPaper" in action_type or "SetSameChatWallPaper" in action_type:
            return "🖼️ Changed chat wallpaper"
        elif "UserUpdatedPhoto" in action_type:
            return "📷 Updated profile photo"
        elif "SuggestProfilePhoto" in action_type:
            return "📷 Suggested a profile photo"
        
        elif "TopicCreate" in action_type:
            return "📁 Created topic"
        elif "TopicEdit" in action_type:
            return "📝 Edited topic"
        
        elif "GiveawayLaunch" in action_type:
            return "🎉 Launched giveaway"
        elif "GiveawayResults" in action_type:
            return "🏆 Announced giveaway results"
        elif "PrizeStars" in action_type:
            return "⭐ Won prize stars"
        elif "BoostApply" in action_type:
            return "🚀 Applied boost"
        elif "SuggestedPostSuccess" in action_type:
            return "✅ Post suggestion accepted"
        elif "SuggestedPostRefund" in action_type:
            return "💸 Post suggestion refunded"
        elif "SuggestedPostApproval" in action_type:
            return "👍 Post suggestion pending approval"
        
        elif "CustomAction" in action_type:
            return "ℹ️ Custom action"
        elif "GeoProximityReached" in action_type:
            return "📍 Nearby"
        elif "PhoneNumberRequest" in action_type:
            return "📱 Requested phone number"
        elif "CreatedBroadcastList" in action_type:
            return "📢 Created broadcast list"
        elif "LoginUnknownLocation" in action_type:
            return "🔐 Login from unknown location"
        elif "Empty" in action_type:
            return ""
        
        else:
            clean_name = action_type.replace("TLRPC$TL_messageAction", "")
            clean_name = clean_name.replace("TL_messageAction", "")
            import re
            clean_name = re.sub(r'([a-z])([A-Z])', r'\1 \2', clean_name)
            return f"[{clean_name}]"
        
    def _get_sender_name(self, user_id: int) -> str:
        try:
            if user_id == 0:
                return "Unknown"

            mc = get_messages_controller()

            if user_id > 0:
                user = mc.getUser(user_id)
                if user:
                    name = user.first_name or ""
                    if user.last_name:
                        name += " " + user.last_name
                    name = name.strip()

                    if not name and hasattr(user, 'username') and user.username:
                        name = f"@{user.username}"

                    if not name:
                        if hasattr(user, 'deleted') and user.deleted:
                            return "Deleted Account"
                        return f"User {user_id}"

                    return name
            else:
                chat = mc.getChat(-user_id)
                if chat:
                    title = getattr(chat, 'title', None)
                    if title:
                        title = title.strip()
                    
                    username = getattr(chat, 'username', None)
                    
                    is_broadcast = getattr(chat, 'broadcast', False)
                    is_megagroup = getattr(chat, 'megagroup', False)
                    
                    if not title and not username:
                        log(f"[ChatExport] Chat {-user_id}: title='{title}', username='{username}', broadcast={is_broadcast}, megagroup={is_megagroup}")
                    
                    if title and username:
                        return f"{title} (@{username})"
                    elif title:
                        return title
                    elif username:
                        return f"@{username}"
                    
                    if is_broadcast:
                        log(f"[ChatExport] Warning: Channel {-user_id} has no title or username!")
                        return f"Channel_{-user_id}"
                    elif is_megagroup:
                        log(f"[ChatExport] Warning: Supergroup {-user_id} has no title or username!")
                        return f"Supergroup_{-user_id}"
                    else:
                        log(f"[ChatExport] Warning: Group {-user_id} has no title or username!")
                        return f"Group_{-user_id}"
                else:
                    log(f"[ChatExport] Warning: Could not get chat object for {-user_id}")

            return f"User_{user_id}"
        except Exception as e:
            log(f"[ChatExport] Error getting sender name for {user_id}: {e}")
            return f"User {user_id}"
    
    def _get_user_color(self, user_id: int) -> int:
        return (abs(user_id) % 8) + 1
    
    def _get_user_initial(self, user_id: int) -> str:
        try:
            name = self._get_sender_name(user_id)
            if name and len(name) > 0:
                return name[0].upper()
            return "U"
        except:
            return "U"
    
    def _get_chat_type(self, chat_id: int) -> str:
        try:
            if chat_id > 0:
                return "User"
            
            mc = get_messages_controller()
            chat = mc.getChat(-chat_id)
            
            if not chat:
                return "Unknown"
            
            if hasattr(chat, 'broadcast') and chat.broadcast:
                return "Channel"
            
            if hasattr(chat, 'megagroup') and chat.megagroup:
                return "Supergroup"
            
            if hasattr(chat, 'title') and chat.title:
                return "Group"
            
            return "Unknown"
            
        except Exception as e:
            log(f"[ChatExport] Error determining chat type for {chat_id}: {e}")
            return "Unknown"
    
    def _generate_userpic_html(self, user_id: int, avatar_data_uri: str = None) -> str:
        if avatar_data_uri:
            initial = self._get_user_initial(user_id)
            return f'''
       <img class="userpic" src="{avatar_data_uri}" alt="{initial}" style="width: 42px; height: 42px; border-radius: 50%; object-fit: cover;">'''
        else:
            color_class = self._get_user_color(user_id)
            initial = self._get_user_initial(user_id)
            
            return f'''
       <div class="userpic userpic{color_class}" style="width: 42px; height: 42px">
        <div class="initials" style="line-height: 42px">
{initial}
        </div>
       </div>'''
    
    def _load_missing_users(self, user_ids: set):
        try:
            if not user_ids:
                return

            mc = get_messages_controller()

            missing_ids = []
            cached_count = 0
            for user_id in user_ids:
                if user_id > 0:
                    user = mc.getUser(user_id)
                    if not user:
                        missing_ids.append(user_id)
                    else:
                        cached_count += 1

            log(f"[ChatExport] User cache status: {cached_count} cached, {len(missing_ids)} missing out of {len(user_ids)} total")

            if not missing_ids:
                return

            log(f"[ChatExport] Attempting to resolve {len(missing_ids)} missing users...")

            resolved_count = 0
            for user_id in missing_ids:
                try:
                    input_user = mc.getInputUser(user_id)
                    if input_user and hasattr(input_user, 'user_id'):
                        user = mc.getUser(user_id)
                        if user:
                            resolved_count += 1
                except Exception:
                    pass

            if resolved_count > 0:
                log(f"[ChatExport] Resolved {resolved_count} users via InputUser")

            still_missing = 0
            for user_id in missing_ids:
                if not mc.getUser(user_id):
                    still_missing += 1

            if still_missing > 0:
                log(f"[ChatExport] Warning: {still_missing} users still not in cache. They will be displayed as 'User {id}'")
                log(f"[ChatExport] This usually happens for deleted accounts or users not in your contacts")

        except Exception as e:
            log(f"[ChatExport] Error in _load_missing_users: {e}")
            import traceback
            log(traceback.format_exc())

    def _get_user_object(self, user_id: int):
        try:
            if user_id <= 0:
                return None

            mc = get_messages_controller()
            user = mc.getUser(user_id)
            return user
        except Exception as e:
            log(f"[ChatExport] Error getting user object {user_id}: {e}")
            return None
    
    def _reconstruct_tlrpc_message(self, msg_dict: Dict[str, Any]):
        try:
            if "_tlrpc_obj" in msg_dict:
                return msg_dict["_tlrpc_obj"]
            
            msg_id = msg_dict.get("id", 0)
            if not msg_id:
                return None
            
            mc = get_messages_controller()
            
            if msg_dict.get("media"):
                
                class MockMessage:
                    def __init__(self, media_dict):
                        self.media = media_dict.get("_media_obj") if "_media_obj" in media_dict else None
                        self.id = msg_dict.get("id", 0)
                
                return MockMessage(msg_dict.get("media", {}))
            
            return None
            
        except Exception as e:
            log(f"[ChatExport] Error reconstructing TLRPC message: {e}")
            return None
        
    def _generate_json(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        export_data = {
            "chat_name": chat_name,
            "dialog_id": dialog_id,
            "export_date": time.strftime("%Y-%m-%d %H:%M:%S"),
            "message_count": len(messages),
            "messages": []
        }
        
        msg_count = 0
        progress_interval = 1000 if len(messages) > 3000 else 500
        
        for msg in messages:
            if self.cancel_requested:
                log("[ChatExport] JSON generation cancelled by user")
                break
                
            msg_data = {
                "id": msg.get("id", 0),
                "date": msg.get("date", 0),
                "date_formatted": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(msg.get("date", 0))),
                "from_id": msg.get("from_id", 0),
                "from_name": self._get_sender_name(msg.get("from_id", 0)),
                "text": msg.get("text", ""),
                "out": msg.get("out", False)
            }
            
            if "media" in msg:
                msg_data["media"] = msg["media"]
                
            export_data["messages"].append(msg_data)
            
            msg_count += 1
            if msg_count % progress_interval == 0:
                progress_percent = int((msg_count / len(messages)) * 100)
                self._update_progress(f"Generating JSON: {msg_count}/{len(messages)} messages...", progress_percent)
        
        log(f"[ChatExport] Serializing JSON export ({len(export_data['messages'])} messages)...")
        return json.dumps(export_data, indent=2, ensure_ascii=False)
        
    def _generate_txt(self, dialog_id: int, chat_name: str, messages: List[Any]) -> str:
        export_date = time.strftime("%Y-%m-%d %H:%M:%S")
        current_user_id = get_user_config().getClientUserId()
        
        txt_parts = []
        txt_parts.append(f"Chat Export: {chat_name}\n")
        txt_parts.append(f"Exported: {export_date}\n")
        txt_parts.append(f"Messages: {len(messages)}\n")
        txt_parts.append("=" * 50 + "\n\n")
        
        if not messages:
            txt_parts.append("No messages available for export.\n")
        else:
            last_date = None
            msg_count = 0
            progress_interval = 1000 if len(messages) > 3000 else 500
            
            for msg in messages:
                if self.cancel_requested:
                    log("[ChatExport] TXT generation cancelled by user")
                    break
                    
                msg_date = time.strftime("%Y-%m-%d", time.localtime(msg.get("date", 0)))
                
                if last_date != msg_date:
                    txt_parts.append(f"\n--- {msg_date} ---\n\n")
                    last_date = msg_date
                
                timestamp = time.strftime("%H:%M:%S", time.localtime(msg.get("date", 0)))
                is_outgoing = msg.get("out", False) or msg.get("from_id") == current_user_id
                
                if is_outgoing:
                    sender = "You"
                else:
                    sender = self._get_sender_name(msg.get("from_id", 0))
                
                txt_parts.append(f"[{timestamp}] {sender}: ")
                
                message_text = msg.get("text", "")
                if message_text:
                    txt_parts.append(message_text)
                
                if "media" in msg:
                    media_type = msg["media"].get("type", "unknown")
                    if message_text:
                        txt_parts.append(" ")
                    txt_parts.append(f"[{media_type.upper()}]")
                
                txt_parts.append("\n")
                
                msg_count += 1
                if msg_count % progress_interval == 0:
                    progress_percent = int((msg_count / len(messages)) * 100)
                    self._update_progress(f"Generating TXT: {msg_count}/{len(messages)} messages...", progress_percent)
        
        txt_parts.append("\n" + "=" * 50 + "\n")
        txt_parts.append("Exported with exteraGram Chat Export Plugin\n")
        
        return "".join(txt_parts)
        
    def _save_export_file(self, chat_name: str, content: str, extension: str) -> str:
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            export_dir = File(base_dir, "ChatExports")
            
            if not export_dir.exists():
                export_dir.mkdirs()
                
            timestamp = int(time.time())
            safe_name = "".join(c for c in chat_name if c.isalnum() or c in (' ', '-', '_'))[:50]
            filename = f"chat_export_{safe_name}_{timestamp}.{extension}"
            
            file_path = File(export_dir, filename)
            
            with open(file_path.getAbsolutePath(), 'w', encoding='utf-8') as f:
                f.write(content)
                
            log(f"[ChatExport] Saved export to: {file_path.getAbsolutePath()}")
            return file_path.getAbsolutePath()
            
        except Exception as e:
            log(f"[ChatExport] Error saving export file: {e}")
            raise
            
    def _share_export_file(self, file_path: str, mime_type: str):
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_error("Cannot access activity")
                return
                
            context = fragment.getParentActivity()
            if not context:
                return
            
            import shutil
            from android.os import Environment
            
            source_file = File(file_path)
            filename = source_file.getName()
            
            download_dir = Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_DOWNLOADS
            )
            exteragram_dir = File(download_dir, "exteraGram")
            
            if not exteragram_dir.exists():
                exteragram_dir.mkdirs()
            
            dest_file = File(exteragram_dir, filename)
            
            shutil.copy2(file_path, dest_file.getAbsolutePath())
            log(f"[ChatExport] Copied export to: {dest_file.getAbsolutePath()}")
            
            authority = ApplicationLoader.getApplicationId() + ".provider"
            uri = FileProvider.getUriForFile(context, authority, dest_file)
            
            intent = Intent(Intent.ACTION_SEND)
            intent.setType(mime_type)
            intent.putExtra(Intent.EXTRA_STREAM, uri)
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            
            chooser = Intent.createChooser(intent, self._t("export_chat"))
            
            context.startActivity(chooser)
            
            success_msg = f"Export saved to Download/exteraGram/{filename}"
            BulletinHelper.show_success(success_msg)
            
            threading.Thread(
                target=lambda: self._cleanup_temp_file(file_path, 60),
                daemon=True
            ).start()
            
        except Exception as e:
            log(f"[ChatExport] Error sharing file: {e}")
            import traceback
            log(traceback.format_exc())
            BulletinHelper.show_error(f"Share error: {str(e)}")
            
    def _cleanup_temp_file(self, file_path: str, delay_seconds: int):
        try:
            time.sleep(delay_seconds)
            
            if os.path.exists(file_path):
                os.remove(file_path)
                log(f"[ChatExport] Deleted temp file: {file_path}")
                
        except Exception as e:
            log(f"[ChatExport] Temp file cleanup error: {e}")
    
    def _cleanup_old_exports(self, delay_seconds: int):
        try:
            time.sleep(delay_seconds)
            
            base_dir = ApplicationLoader.getFilesDirFixed()
            export_dir = File(base_dir, "ChatExports")
            
            if not export_dir.exists():
                return
                
            now = time.time()
            max_age = 3600
            
            for file in export_dir.listFiles():
                if file.isFile():
                    age = now - (file.lastModified() / 1000)
                    if age > max_age:
                        file.delete()
                        log(f"[ChatExport] Deleted old export: {file.getName()}")
                        
        except Exception as e:
            log(f"[ChatExport] Cleanup error: {e}")
            
    def _update_progress(self, message: str, progress: int = 0):
        self.current_progress_text = message
        self.current_progress_value = max(0.0, min(1.0, progress / 100.0))  # Convert to 0.0-1.0 range
        
        def update():
            try:
                # Update dialog if it's visible
                if self.progress_dialog:
                    self.progress_dialog.set_title(message)
                    self.progress_dialog.set_progress(progress)
                
                # Update overlay if it's visible
                if self.progress_overlay:
                    # Add percentage to text for overlay
                    overlay_text = message
                    if progress > 0:
                        overlay_text = f"{message} {progress}%"
                    self.progress_overlay.set_progress(self.current_progress_value, overlay_text)
                    
            except Exception as e:
                log(f"[ChatExport] Error updating progress: {e}")
        run_on_ui_thread(update)


plugin = ChatExportPlugin()

