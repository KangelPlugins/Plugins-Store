import os
import hashlib
import requests
import traceback
from base_plugin import BasePlugin
from android_utils import log, run_on_ui_thread
from client_utils import run_on_queue, get_last_fragment
from java.util import Locale
from org.telegram.ui.ActionBar import AlertDialog
from org.telegram.messenger import NotificationCenter, ApplicationLoader
from com.exteragram.messenger.plugins import PluginsController
from ui.settings import Header, Switch, Divider, Text
from ui.bulletin import BulletinHelper
from java.lang import String, CharSequence
from java import jarray, dynamic_proxy
from android.content import DialogInterface
from android.widget import EditText, LinearLayout
from android.text import TextWatcher
from android.view import ViewGroup
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui.ActionBar import Theme

__id__ = "kangel_plugins_manager"
__name__ = "Kangel Plugins Manager"
__description__ = """Первый плагин , который предоставляет легкое обновление/установку/удаление плагинов через легкий GUI
Требования:exteraGram/AyuGram 12.0.1 или выше"""
__author__ = "@ArThirtyFour | @KangelPlugins"
__min_version__ = "12.0.1"
__icon__ = "Kangelcons_by_fStikBot/5"
__version__ = "0.2 [ALPHA]"



PLUGINS_DIR = f'/data/user/0/{ApplicationLoader.applicationContext.getPackageName()}/files/plugins'

def _get_lang():
    lang = Locale.getDefault().getLanguage().lower()
    return "ru" if lang.startswith("ru") else "en"

def _tr(key):
    lang = _get_lang()
    strings = {
        "en": {
            "header": "Kangel Plugins Manager",
            "auto_update": "Auto-update on start",
            "auto_update_sub": "Update plugins list when app starts",
            "refresh_list": "Refresh plugins list",
            "install_plugin": "Install plugin",
            "update_plugins": "Update installed plugins",
            "delete_plugin": "Delete plugin",
            "install_title": "Install plugin",
            "delete_title": "Delete plugin",
            "cancel": "Cancel",
            "search_hint": "Search...",
            "list_empty": "List is empty",
            "no_installed": "No installed plugins from store",
            "file_not_found": "File not found",
            "installed": "Installed {}",
            "deleted": "Deleted {}",
            "error_download": "Download error: {}",
            "error_write": "Write error: {}",
            "error_delete": "Delete error: {}",
            "updated_stats": "Updated: {}, unchanged: {}, errors: {}",
            "installing_deps": "Installing dependencies...",
            "dep_installed": "Dependency installed: {}",
            "dep_error": "Dependency error: {}"
        },
        "ru": {
            "header": "Kangel Plugins Manager",
            "auto_update": "Автообновление при запуске",
            "auto_update_sub": "Обновлять список плагинов при старте приложения",
            "refresh_list": "Обновить список плагинов",
            "install_plugin": "Установить плагин",
            "update_plugins": "Обновить установленные плагины",
            "delete_plugin": "Удалить плагин",
            "install_title": "Установка плагина",
            "delete_title": "Удалить плагин",
            "cancel": "Отмена",
            "search_hint": "Поиск...",
            "list_empty": "Список пуст",
            "no_installed": "Нет установленных плагинов из стора",
            "file_not_found": "Файл не найден",
            "installed": "Установлен {}",
            "deleted": "Удалён {}",
            "error_download": "Ошибка загрузки: {}",
            "error_write": "Ошибка записи: {}",
            "error_delete": "Ошибка удаления: {}",
            "updated_stats": "Обновлено: {}, без изменений: {}, ошибок: {}",
            "installing_deps": "Установка зависимостей...",
            "dep_installed": "Зависимость установлена: {}",
            "dep_error": "Ошибка зависимости: {}"
        }
    }
    return strings.get(lang, strings["en"]).get(key, key)

class KangelPluginsManager(BasePlugin):
    def __init__(self):
        super().__init__()
        self.store_urls = [
            "https://raw.githubusercontent.com/KangelPlugins/Plugins-Store/refs/heads/main/store.txt",
            "https://raw.githubusercontent.com/KangelPlugins/Plugins-Store/main/store.txt",
        ]
        self.plugins_list = {}
        self.auto_update = True

    def has_settings(self):
        return True

    def create_settings(self):
        return [
            Header(text=_tr("header")),
            Switch(
                key="auto_update_on_start",
                text=_tr("auto_update"),
                default=False,
                icon="files_storage",
                subtext=_tr("auto_update_sub")
            ),
            Divider(),
            Text(
                text=_tr("refresh_list"),
                icon="msg_download",
                on_click=lambda _: run_on_queue(lambda: self.refresh_store())
            ),
            Text(
                text=_tr("install_plugin"),
                icon="msg_addbot",
                on_click=lambda _: self.open_install_dialog()
            ),
            Text(
                text=_tr("update_plugins"),
                icon="ab_progress",
                on_click=lambda _: run_on_queue(lambda: self.update_installed_from_store())
            ),
            Text(
                text=_tr("delete_plugin"),
                icon="msg_delete",
                on_click=lambda _: self.open_delete_dialog()
            )
        ]

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        if self.get_setting("auto_update", True):
            run_on_queue(self.refresh_store)

    def on_plugin_unload(self):
        self.remove_hook("on_send_message_hook")

    def refresh_store(self):
        for url in self.store_urls:
            try:
                r = requests.get(url, timeout=20)
                if r.status_code == 200 and r.text:
                    env = {}
                    try:
                        exec(r.text, {}, env)
                    except Exception as e:
                        log(f"[KPM] exec store error {e}")
                        continue
                    if isinstance(env.get("plugins_list"), dict):
                        # Normalize format: support both old (str) and new (dict) format
                        normalized = {}
                        for pid, value in env["plugins_list"].items():
                            if isinstance(value, str):
                                # Old format: "plugin_id": "url"
                                normalized[pid] = {"url": value, "dependencies": []}
                            elif isinstance(value, dict):
                                # New format: "plugin_id": {"url": "...", "dependencies": [...]}
                                normalized[pid] = {
                                    "url": value.get("url", ""),
                                    "dependencies": value.get("dependencies", [])
                                }
                        self.plugins_list = normalized
                        BulletinHelper.show_error(f"Загружено {len(self.plugins_list)} плагинов из стора")
                        return
            except Exception as e:
                log(f"[KPM] store fetch fail {url}: {e}")
        BulletinHelper.show_error("Не удалось загрузить store.py")

    def list_available_ids(self):
        if not self.plugins_list:
            self.refresh_store()
        return list(self.plugins_list.keys())

    def parse_plugin_metadata(self, content):
        metadata = {"name": None, "description": None}
        try:
            lines = content.decode('utf-8', errors='ignore').split('\n')
            for line in lines:
                line = line.strip()
                if line.startswith('__name__'):
                    # Extract value: __name__ = "Steam"
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        value = parts[1].strip().strip('"').strip("'")
                        metadata["name"] = value
                elif line.startswith('__description__'):
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        value = parts[1].strip().strip('"').strip("'")
                        metadata["description"] = value
                if metadata["name"] and metadata["description"]:
                    break
        except Exception:
            pass
        return metadata

    def get_plugin_display_name(self, plugin_id):
        """Get pretty display name for plugin (from __name__ or fallback to ID)"""
        if plugin_id not in self.plugins_list:
            return plugin_id
        try:
            plugin_info = self.plugins_list[plugin_id]
            url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
            content = self.fetch_remote_bytes(url)
            metadata = self.parse_plugin_metadata(content)
            if metadata["name"]:
                return metadata["name"]
        except Exception:
            pass
        return plugin_id

    def _show_searchable_dialog(self, fragment, title, plugin_ids, display_names, on_click_callback):
        """Show dialog with search field and filtered list"""
        try:
            context = fragment.getParentActivity()
            builder = AlertDialog.Builder(context)
            builder.setTitle(title)
            
            # Create container layout
            container = LinearLayout(context)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(
                AndroidUtilities.dp(16),
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(16),
                AndroidUtilities.dp(8)
            )
            
            search_edit = EditText(context)
            search_edit.setHint(_tr("search_hint"))
            search_edit.setSingleLine(True)
            search_edit.setTextSize(16)
            search_edit.setPadding(
                AndroidUtilities.dp(12),
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(12),
                AndroidUtilities.dp(8)
            )
            try:
                search_edit.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                search_edit.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
                search_edit.setBackground(Theme.createRoundRectDrawable(
                    AndroidUtilities.dp(6),
                    Theme.getColor(Theme.key_windowBackgroundWhite)
                ))
            except Exception as e:
                log(f"[KPM] Error setting EditText colors: {e}")
            
            container.addView(search_edit, LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            ))
            
            builder.setView(container)
            filtered_ids = list(plugin_ids)
            current_dialog = [None]
            
            class ItemClickListener(dynamic_proxy(DialogInterface.OnClickListener)):
                def __init__(self, callback, ids_ref):
                    super().__init__()
                    self.callback = callback
                    self.ids_ref = ids_ref
                
                def onClick(self, dialog, which):
                    if which < len(self.ids_ref):
                        pid = self.ids_ref[which]
                        self.callback(pid)
            
            listener = ItemClickListener(on_click_callback, filtered_ids)
            
            # Set initial items
            charseq_array = jarray(CharSequence)([String(display_names[_id]) for _id in filtered_ids])
            builder.setItems(charseq_array, listener)
            builder.setNegativeButton(_tr("cancel"), None)
            
            dialog = builder.create()
            current_dialog[0] = dialog
            
            # Add text watcher for search
            class SearchTextWatcher(dynamic_proxy(TextWatcher)):
                def __init__(self, dialog_ref, all_ids, names, callback):
                    super().__init__()
                    self.dialog_ref = dialog_ref
                    self.all_ids = all_ids
                    self.names = names
                    self.callback = callback
                    self.filtered = list(all_ids)
                
                def beforeTextChanged(self, s, start, count, after):
                    pass
                
                def onTextChanged(self, s, start, before, count):
                    pass
                
                def afterTextChanged(self, editable):
                    try:
                        query = str(editable).lower()
                        self.filtered.clear()
                        
                        if not query:
                            self.filtered.extend(self.all_ids)
                        else:
                            for pid in self.all_ids:
                                name = self.names.get(pid, pid).lower()
                                if query in name or query in pid.lower():
                                    self.filtered.append(pid)
                        
                        # Rebuild dialog with filtered items
                        if self.dialog_ref[0]:
                            self.dialog_ref[0].dismiss()
                        
                        new_builder = AlertDialog.Builder(context)
                        new_builder.setTitle(title)
                        new_builder.setView(container)
                        
                        new_listener = ItemClickListener(self.callback, self.filtered)
                        new_array = jarray(CharSequence)([String(self.names[_id]) for _id in self.filtered])
                        new_builder.setItems(new_array, new_listener)
                        new_builder.setNegativeButton(_tr("cancel"), None)
                        
                        new_dialog = new_builder.create()
                        self.dialog_ref[0] = new_dialog
                        new_dialog.show()
                    except Exception:
                        pass
            
            watcher = SearchTextWatcher(current_dialog, plugin_ids, display_names, on_click_callback)
            search_edit.addTextChangedListener(watcher)
            
            dialog.show()
        except Exception as e:
            log(f"[KPM] Error creating searchable dialog: {e}")

    def open_install_dialog(self):
        ids = self.list_available_ids()
        if not ids:
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("list_empty")))
            return
        fragment = get_last_fragment()
        if not fragment:
            return
        
        # Get display names for all plugins
        display_names = {}
        for pid in ids:
            display_names[pid] = self.get_plugin_display_name(pid)
        
        def create_dialog():
            try:
                self._show_searchable_dialog(
                    fragment,
                    _tr("install_title"),
                    ids,
                    display_names,
                    lambda pid: run_on_queue(lambda: self.install_plugin_by_id(pid))
                )
            except Exception:
                pass
        run_on_ui_thread(create_dialog)

    def open_delete_dialog(self):
        installed = self.list_installed_plugins()
        if not installed:
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("no_installed")))
            return
        fragment = get_last_fragment()
        if not fragment:
            return

        display_names = {}
        for pid in installed:
            filename = f"{pid}.py"
            local_path = os.path.join(PLUGINS_DIR, filename)
            try:
                content = self.read_file_bytes(local_path)
                if content:
                    metadata = self.parse_plugin_metadata(content)
                    display_names[pid] = metadata["name"] if metadata["name"] else pid
                else:
                    display_names[pid] = pid
            except Exception:
                display_names[pid] = pid
        
        def create_dialog():
            try:
                self._show_searchable_dialog(
                    fragment,
                    _tr("delete_title"),
                    installed,
                    display_names,
                    lambda pid: run_on_queue(lambda: self.delete_plugin_by_id(pid))
                )
            except Exception:
                pass
        run_on_ui_thread(create_dialog)

    def list_installed_plugins(self):
        installed = []
        for pid in self.plugins_list.keys():
            filename = f"{pid}.py"
            if os.path.exists(os.path.join(PLUGINS_DIR, filename)):
                installed.append(pid)
        return installed

    def delete_plugin_by_id(self, plugin_id):
        filename = f"{plugin_id}.py"
        target = os.path.join(PLUGINS_DIR, filename)
        try:
            if os.path.exists(target):
                os.remove(target)
                def notify_deleted():
                    try:
                        controller = PluginsController.getInstance()
                        if controller and hasattr(controller, 'engines'):
                            engine = controller.engines.get("python")
                            if engine:
                                engine.loadPlugins(None)
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginsUpdated)
                    except Exception as e:
                        log(f"[KPM] Error reloading plugins: {e}")
                    BulletinHelper.show_error(_tr("deleted").format(filename))
                run_on_ui_thread(notify_deleted)
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("file_not_found")))
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_delete").format(e)))

    def get_local_plugin_path(self, plugin_id):
        return os.path.join(PLUGINS_DIR, f"{plugin_id}.plugin")

    def read_file_bytes(self, path):
        try:
            with open(path, "rb") as f:
                return f.read()
        except Exception:
            return None

    def sha256(self, data):
        h = hashlib.sha256()
        h.update(data)
        return h.hexdigest()

    def fetch_remote_bytes(self, url):
        r = requests.get(url, timeout=30)
        if r.status_code != 200:
            raise Exception(f"HTTP {r.status_code}")
        return r.content

    def install_plugin_by_id(self, plugin_id, _installing_deps=None):
        """Install plugin with dependencies support"""
        log(f"[KPM] === install_plugin_by_id called for: {plugin_id} ===")
        
        if _installing_deps is None:
            _installing_deps = set()
        
        log(f"[KPM] Current installing_deps set: {_installing_deps}")
        
        # Prevent circular dependencies
        if plugin_id in _installing_deps:
            log(f"[KPM] Circular dependency detected: {plugin_id}")
            return
        
        if not self.plugins_list:
            log(f"[KPM] plugins_list is empty, refreshing store...")
            self.refresh_store()
        
        if plugin_id not in self.plugins_list:
            log(f"[KPM] ERROR: {plugin_id} not found in plugins_list")
            log(f"[KPM] Available plugins: {list(self.plugins_list.keys())}")
            error_msg = f"Plugin {plugin_id} not found in store"
            run_on_ui_thread(lambda: BulletinHelper.show_error(error_msg))
            raise Exception(error_msg)
        
        plugin_info = self.plugins_list[plugin_id]
        log(f"[KPM] plugin_info for {plugin_id}: {plugin_info}")
        
        url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
        dependencies = plugin_info.get("dependencies", []) if isinstance(plugin_info, dict) else []
        
        log(f"[KPM] URL: {url}")
        log(f"[KPM] Dependencies: {dependencies}")
        
        # Install dependencies first
        if dependencies:
            log(f"[KPM] Found {len(dependencies)} dependencies, installing...")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("installing_deps")))
            _installing_deps.add(plugin_id)
            log(f"[KPM] Added {plugin_id} to installing_deps: {_installing_deps}")
            
            for dep_id in dependencies:
                log(f"[KPM] Processing dependency: {dep_id}")
                
                # Check if dependency is already installed
                dep_filename = f"{dep_id}.py"
                dep_path = os.path.join(PLUGINS_DIR, dep_filename)
                log(f"[KPM] Checking if {dep_id} exists at: {dep_path}")
                
                if os.path.exists(dep_path):
                    log(f"[KPM] Dependency {dep_id} already installed, skipping")
                    continue
                
                # Install dependency recursively
                try:
                    log(f"[KPM] Installing dependency: {dep_id}")
                    self.install_plugin_by_id(dep_id, _installing_deps)
                    log(f"[KPM] Successfully installed dependency: {dep_id}")
                    run_on_ui_thread(lambda d=dep_id: BulletinHelper.show_error(_tr("dep_installed").format(d)))
                except Exception as e:
                    error_msg = _tr("dep_error").format(f"{dep_id}: {e}")
                    log(f"[KPM] ERROR installing dependency {dep_id}: {e}")
                    log(f"[KPM] Traceback: {traceback.format_exc()}")
                    run_on_ui_thread(lambda msg=error_msg: BulletinHelper.show_error(msg))
                    return
        
        # Install the plugin itself
        log(f"[KPM] Starting download for {plugin_id} from: {url}")
        try:
            remote = self.fetch_remote_bytes(url)
            log(f"[KPM] Downloaded {len(remote)} bytes for {plugin_id}")
        except Exception as e:
            log(f"[KPM] ERROR downloading {plugin_id}: {e}")
            log(f"[KPM] Traceback: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_download").format(e)))
            raise  # Re-raise exception so caller knows installation failed
        
        filename = f"{plugin_id}.py"
        target = os.path.join(PLUGINS_DIR, filename)
        log(f"[KPM] Target path: {target}")
        
        url_filename = url.split("/")[-1] if "/" in url else ""
        log(f"[KPM] URL filename: {url_filename}")
        
        # Remove old files with different names
        if url_filename.endswith(".plugin"):
            old_name = url_filename[:-7]
            log(f"[KPM] Removing old files with name: {old_name}")
            for ext in [".plugin", ".py"]:
                old_file = os.path.join(PLUGINS_DIR, old_name + ext)
                if old_file != target and os.path.exists(old_file):
                    try:
                        os.remove(old_file)
                        log(f"[KPM] Removed old file: {old_file}")
                    except Exception as e:
                        log(f"[KPM] Failed to remove old file {old_file}: {e}")
        
        try:
            tmp = target + ".tmp"
            log(f"[KPM] Writing to temp file: {tmp}")
            with open(tmp, "wb") as f:
                f.write(remote)
            log(f"[KPM] Wrote {len(remote)} bytes to temp file")
            
            if os.path.exists(target):
                log(f"[KPM] Removing existing file: {target}")
                os.remove(target)
            
            log(f"[KPM] Renaming {tmp} to {target}")
            os.rename(tmp, target)
            log(f"[KPM] Successfully installed {plugin_id} to {target}")
            
            def notify_installed():
                try:
                    controller = PluginsController.getInstance()
                    if controller and hasattr(controller, 'engines'):
                        engine = controller.engines.get("python")
                        if engine:
                            engine.loadPlugins(None)
                    NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginsUpdated)
                except Exception as e:
                    log(f"[KPM] Error reloading plugins: {e}")
                BulletinHelper.show_error(_tr("installed").format(filename))
            run_on_ui_thread(notify_installed)
        except Exception as e:
            log(f"[KPM] ERROR writing file for {plugin_id}: {e}")
            log(f"[KPM] Traceback: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_write").format(e)))
            raise  # Re-raise exception so caller knows installation failed

    def update_installed_from_store(self):
        if not self.plugins_list:
            self.refresh_store()
        if not self.plugins_list:
            return
        updated = 0
        skipped = 0
        failed = 0
        for pid, plugin_info in self.plugins_list.items():
            url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
            filename = f"{pid}.py"
            local_path = os.path.join(PLUGINS_DIR, filename)
            if not os.path.exists(local_path):
                continue
            local_bytes = self.read_file_bytes(local_path) or b""
            local_hash = self.sha256(local_bytes)
            try:
                remote = self.fetch_remote_bytes(url)
                remote_hash = self.sha256(remote)
            except Exception:
                failed += 1
                continue
            if local_hash != remote_hash:
                try:
                    tmp = local_path + ".tmp"
                    with open(tmp, "wb") as f:
                        f.write(remote)
                    os.remove(local_path)
                    os.rename(tmp, local_path)
                    updated += 1
                except Exception:
                    failed += 1
            else:
                skipped += 1
        run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("updated_stats").format(updated, skipped, failed)))
