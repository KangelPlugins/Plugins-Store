import os
import hashlib
import requests
import traceback
import json
import time
from base_plugin import BasePlugin
from android_utils import log, run_on_ui_thread
from client_utils import run_on_queue, get_last_fragment
from java.util import Locale
from org.telegram.ui.ActionBar import AlertDialog
from org.telegram.messenger import NotificationCenter, ApplicationLoader
from com.exteragram.messenger.plugins import PluginsController
from ui.settings import Header, Switch, Divider, Text
from ui.bulletin import BulletinHelper
from java.lang import String, CharSequence
from java import jarray, dynamic_proxy
from android.content import DialogInterface
from android.widget import EditText, LinearLayout, ListView, ArrayAdapter, AdapterView, TextView as AndroidTextView
from android.text import TextWatcher
from android.view import ViewGroup, View, Gravity
from android.util import TypedValue
from android import R as android_R
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui.ActionBar import Theme

__id__ = "kangel_plugins_manager"
__name__ = "Kangel Plugins Manager"
__description__ = """üá∑üá∫ | –ü–µ—Ä–≤—ã–π –ø–ª–∞–≥–∏–Ω , –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ª–µ–≥–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–ª–∞–≥–∏–Ω–∞–º–∏ —á–µ—Ä–µ–∑ –ª–µ–≥–∫–∏–π GUI
–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:exteraGram/AyuGram 12.0.1 –∏–ª–∏ –≤—ã—à–µ

üá∫üá∏ |First plugin that provides easy management of plugins through a simple GUI
Requirements:exteraGram/AyuGram 12.0.1 or higher
"""
__author__ = "@ArThirtyFour | @KangelPlugins"
__min_version__ = "12.0.1"
__icon__ = "Kangelcons_by_fStikBot/5"
__version__ = "0.3 [ALPHA]"

PLUGINS_DIR = f'/data/user/0/{ApplicationLoader.applicationContext.getPackageName()}/files/plugins'

def _get_lang():
    lang = Locale.getDefault().getLanguage().lower()
    return "ru" if lang.startswith("ru") else "en"

def _tr(key):
    lang = _get_lang()
    strings = {
        "en": {
            "header": "Kangel Plugins Manager",
            "auto_update": "Auto-update on start",
            "auto_update_sub": "Update plugins list when app starts",
            "refresh_list": "Refresh plugins list",
            "install_plugin": "Install plugin",
            "update_plugins": "Update installed plugins",
            "delete_plugin": "Delete plugin",
            "install_title": "Install plugin",
            "delete_title": "Delete plugin",
            "cancel": "Cancel",
            "search_hint": "Search...",
            "list_empty": "List is empty",
            "no_installed": "No installed plugins from store",
            "file_not_found": "File not found",
            "installed": "Installed {}",
            "deleted": "Deleted {}",
            "error_download": "Download error: {}",
            "error_write": "Write error: {}",
            "error_delete": "Delete error: {}",
            "updated_stats": "Updated: {}, unchanged: {}, errors: {}",
            "installing_deps": "Installing dependencies...",
            "dep_installed": "Dependency installed: {}",
            "dep_error": "Dependency error: {}",
            "clear_cache": "Clear cache",
            "cache_cleared": "Cache cleared successfully",
            "error_window": "All plugins are cached, you can open install menu"
        },
        "ru": {
            "header": "Kangel Plugins Manager",
            "auto_update": "–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ",
            "auto_update_sub": "–û–±–Ω–æ–≤–ª—è—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–≥–∏–Ω–æ–≤ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è",
            "refresh_list": "–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–ª–∞–≥–∏–Ω–æ–≤",
            "install_plugin": "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–∞–≥–∏–Ω",
            "update_plugins": "–û–±–Ω–æ–≤–∏—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –ø–ª–∞–≥–∏–Ω—ã",
            "delete_plugin": "–£–¥–∞–ª–∏—Ç—å –ø–ª–∞–≥–∏–Ω",
            "install_title": "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–ª–∞–≥–∏–Ω–∞",
            "delete_title": "–£–¥–∞–ª–∏—Ç—å –ø–ª–∞–≥–∏–Ω",
            "cancel": "–û—Ç–º–µ–Ω–∞",
            "search_hint": "–ü–æ–∏—Å–∫...",
            "list_empty": "–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç",
            "no_installed": "–ù–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –ø–ª–∞–≥–∏–Ω–æ–≤ –∏–∑ —Å—Ç–æ—Ä–∞",
            "file_not_found": "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω",
            "installed": "–£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω {}",
            "deleted": "–£–¥–∞–ª—ë–Ω {}",
            "error_download": "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {}",
            "error_write": "–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏: {}",
            "error_delete": "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: {}",
            "updated_stats": "–û–±–Ω–æ–≤–ª–µ–Ω–æ: {}, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π: {}, –æ—à–∏–±–æ–∫: {}",
            "installing_deps": "–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π...",
            "dep_installed": "–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {}",
            "dep_error": "–û—à–∏–±–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: {}",
            "clear_cache": "–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à",
            "cache_cleared": "–ö—ç—à —É—Å–ø–µ—à–Ω–æ –æ—á–∏—â–µ–Ω",
            "error_window": "–í—Å–µ –ø–ª–∞–≥–∏–Ω—ã –∫—ç—à–∏—Ä–æ–≤–∞–Ω—ã , –º–æ–∂–µ—Ç–µ –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –º–µ–Ω—é —É—Å—Ç–∞–Ω–æ–≤–∫–∏"
        }
    }
    return strings.get(lang, strings["en"]).get(key, key)

class KangelPluginsManager(BasePlugin):
    def __init__(self):
        super().__init__()
        self.store_urls = [
            "https://raw.githubusercontent.com/KangelPlugins/Plugins-Store/refs/heads/main/store.txt",
            "https://raw.githubusercontent.com/KangelPlugins/Plugins-Store/main/store.txt",
        ]
        self.github_api_url = "https://api.github.com/repos/KangelPlugins/Plugins-Store/commits/main"
        self.cache_file = os.path.join(PLUGINS_DIR, ".kpm_cache.json")
        self.plugins_list = {}
        self.plugin_names_cache = {}
        self.auto_update = True
        self.load_cache()

    def has_settings(self):
        return True

    def create_settings(self):
        return [
            Header(text=_tr("header")),
            Switch(
                key="auto_update_on_start",
                text=_tr("auto_update"),
                default=False,
                icon="files_storage",
                subtext=_tr("auto_update_sub")
            ),
            Divider(),
            Text(
                text=_tr("refresh_list"),
                icon="msg_download",
                on_click=lambda _: run_on_queue(lambda: self.refresh_store())
            ),
            Text(
                text=_tr("install_plugin"),
                icon="msg_addbot",
                on_click=lambda _: self.open_install_dialog()
            ),
            Text(
                text=_tr("update_plugins"),
                icon="ab_progress",
                on_click=lambda _: run_on_queue(lambda: self.update_installed_from_store())
            ),
            Text(
                text=_tr("delete_plugin"),
                icon="msg_delete",
                on_click=lambda _: self.open_delete_dialog()
            ),
            Divider(),
            Text(
                text=_tr("clear_cache"),
                icon="msg_clear",
                on_click=lambda _: run_on_queue(lambda: self.clear_cache())
            )
        ]

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        if self.get_setting("auto_update", True):
            run_on_queue(self.refresh_store)

    def on_plugin_unload(self):
        self.remove_hook("on_send_message_hook")

    def load_cache(self):
        """Load plugins list from cache"""
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, "r", encoding="utf-8") as f:
                    cache_data = json.load(f)
                    self.plugins_list = cache_data.get("plugins_list", {})
                    self.plugin_names_cache = cache_data.get("plugin_names", {})
                    cached_commit = cache_data.get("commit_sha", "")
                    log(f"[KPM] Loaded cache with {len(self.plugins_list)} plugins, {len(self.plugin_names_cache)} names (commit: {cached_commit[:7]})")
        except Exception as e:
            log(f"[KPM] Error loading cache: {e}")

    def save_cache(self, commit_sha):
        """Save plugins list and names to cache with commit SHA"""
        try:
            cache_data = {
                "plugins_list": self.plugins_list,
                "plugin_names": self.plugin_names_cache,
                "commit_sha": commit_sha,
                "timestamp": int(time.time())
            }
            with open(self.cache_file, "w", encoding="utf-8") as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)
            log(f"[KPM] Saved cache with {len(self.plugins_list)} plugins, {len(self.plugin_names_cache)} names (commit: {commit_sha[:7]})")
        except Exception as e:
            log(f"[KPM] Error saving cache: {e}")
    
    def clear_cache(self):
        """Clear cache file and reload from network"""
        try:
            if os.path.exists(self.cache_file):
                os.remove(self.cache_file)
                log("[KPM] Cache file deleted")
            
            self.plugins_list.clear()
            self.plugin_names_cache.clear()
            log("[KPM] Cache cleared from memory")
            
            # Reload from network
            self.refresh_store(force=True)
            
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("cache_cleared")))
        except Exception as e:
            log(f"[KPM] Error clearing cache: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}"))

    def get_latest_commit_sha(self):
        try:
            log(f"[KPM] Checking latest commit from GitHub API...")
            r = requests.get(self.github_api_url, timeout=10)
            if r.status_code == 200:
                commit_data = json.loads(r.text)
                sha = commit_data.get("sha", "")
                log(f"[KPM] Latest commit: {sha[:7]}")
                return sha
        except Exception as e:
            log(f"[KPM] Error getting commit SHA: {e}")
        return None

    def get_cached_commit_sha(self):
        try:
            if os.path.exists(self.cache_file):
                with open(self.cache_file, "r", encoding="utf-8") as f:
                    cache_data = json.load(f)
                    return cache_data.get("commit_sha", "")
        except Exception:
            pass
        return ""

    def is_cache_valid(self):
        """Check if cache is still valid by comparing commit SHAs"""
        cached_sha = self.get_cached_commit_sha()
        if not cached_sha:
            log("[KPM] No cached commit SHA, cache invalid")
            return False

        latest_sha = self.get_latest_commit_sha()
        if not latest_sha:
            log("[KPM] Could not get latest commit SHA, using cache")
            return True  # Use cache if API fails

        is_valid = cached_sha == latest_sha
        log(f"[KPM] Cache valid: {is_valid} (cached: {cached_sha[:7]}, latest: {latest_sha[:7]})")
        return is_valid

    def force_refresh_store(self):
        log("[KPM] Force refreshing store (clearing cache)...")
        self.plugins_list.clear()
        self.refresh_store(force=True)

    def refresh_store(self, force=False):
        if not force and self.is_cache_valid():
            log("[KPM] Cache is valid, skipping refresh")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫—ç—à ({len(self.plugins_list)} –ø–ª–∞–≥–∏–Ω–æ–≤)"))
            return

        log("[KPM] Refreshing store from URLs...")
        for url in self.store_urls:
            try:
                log(f"[KPM] Trying URL: {url}")
                r = requests.get(url, timeout=20)
                log(f"[KPM] Response status: {r.status_code}")
                if r.status_code == 200 and r.text:
                    env = {}
                    try:
                        exec(r.text, {}, env)
                    except Exception as e:
                        log(f"[KPM] exec store error {e}")
                        continue
                    if isinstance(env.get("plugins_list"), dict):
                        # Normalize format: support both old (str) and new (dict) format
                        normalized = {}
                        for pid, value in env["plugins_list"].items():
                            if isinstance(value, str):
                                # Old format: "plugin_id": "url"
                                normalized[pid] = {"url": value, "dependencies": []}
                            elif isinstance(value, dict):
                                # New format: "plugin_id": {"url": "...", "dependencies": [...]}
                                normalized[pid] = {
                                    "url": value.get("url", ""),
                                    "dependencies": value.get("dependencies", [])
                                }
                        self.plugins_list = normalized
                        log(f"[KPM] Loaded {len(self.plugins_list)} plugins from store")
                        log(f"[KPM] Plugins: {list(self.plugins_list.keys())}")
                        
                        # Save to cache with latest commit SHA
                        latest_sha = self.get_latest_commit_sha()
                        if latest_sha:
                            self.save_cache(latest_sha)
                        
                        run_on_ui_thread(lambda: BulletinHelper.show_error(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.plugins_list)} –ø–ª–∞–≥–∏–Ω–æ–≤ –∏–∑ —Å—Ç–æ—Ä–∞"))
                        return
            except Exception as e:
                log(f"[KPM] store fetch fail {url}: {e}")
        run_on_ui_thread(lambda: BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å store.py"))

    def list_available_ids(self):
        if not self.plugins_list:
            log("[KPM] plugins_list is empty, loading from cache...")
            self.load_cache()
        if not self.plugins_list:
            log("[KPM] Cache is empty, refreshing from network...")
            self.refresh_store()
        
        return list(self.plugins_list.keys())

    def parse_plugin_metadata(self, content):
        metadata = {"name": None, "description": None}
        try:
            lines = content.decode('utf-8', errors='ignore').split('\n')
            for line in lines:
                line = line.strip()
                if line.startswith('__name__'):
                    # Extract value: __name__ = "Steam"
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        value = parts[1].strip().strip('"').strip("'")
                        metadata["name"] = value
                elif line.startswith('__description__'):
                    parts = line.split('=', 1)
                    if len(parts) == 2:
                        value = parts[1].strip().strip('"').strip("'")
                        metadata["description"] = value
                if metadata["name"] and metadata["description"]:
                    break
        except Exception:
            pass
        return metadata

    def get_plugin_display_name(self, plugin_id):
        """Get pretty display name for plugin (from cache or __name__ or fallback to ID)"""
        # Check cache first
        if plugin_id in self.plugin_names_cache:
            return self.plugin_names_cache[plugin_id]
        
        if plugin_id not in self.plugins_list:
            return plugin_id
        
        # Not in cache, fetch from network
        try:
            plugin_info = self.plugins_list[plugin_id]
            url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
            content = self.fetch_remote_bytes(url)
            metadata = self.parse_plugin_metadata(content)
            if metadata["name"]:
                # Save to cache
                self.plugin_names_cache[plugin_id] = metadata["name"]
                return metadata["name"]
        except Exception as e:
            log(f"[KPM] Error getting display name for {plugin_id}: {e}")
        
        self.plugin_names_cache[plugin_id] = plugin_id
        return plugin_id

    def _show_searchable_dialog(self, fragment, title, plugin_ids, display_names, on_click_callback):
        try:
            context = fragment.getParentActivity()
            if not context:
                log("[KPM] Error: context is None")
                run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_window")))
                return
            
            builder = AlertDialog.Builder(context)
            builder.setTitle(title)
            
            container = LinearLayout(context)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(
                AndroidUtilities.dp(16),
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(16),
                AndroidUtilities.dp(8)
            )
            
            search_edit = EditText(context)
            search_edit.setHint(_tr("search_hint"))
            search_edit.setSingleLine(True)
            search_edit.setTextSize(16)
            search_edit.setPadding(
                AndroidUtilities.dp(12),
                AndroidUtilities.dp(8),
                AndroidUtilities.dp(12),
                AndroidUtilities.dp(8)
            )
            
            try:
                search_edit.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                search_edit.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
                search_edit.setBackground(Theme.createRoundRectDrawable(
                    AndroidUtilities.dp(6),
                    Theme.getColor(Theme.key_windowBackgroundWhite)
                ))
            except Exception as e:
                log(f"[KPM] Error setting EditText colors: {e}")
            
            container.addView(search_edit, LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            ))
            
            list_view = ListView(context)
            filtered_ids = [list(plugin_ids)]  
            from java.util import ArrayList
            items_list = ArrayList()
            for pid in plugin_ids:
                items_list.add(String(display_names[pid]))
            
            adapter = ArrayAdapter(context, android_R.layout.simple_list_item_1, items_list)
            list_view.setAdapter(adapter)
            
            def fix_text_colors():
                try:
                    for i in range(list_view.getChildCount()):
                        child = list_view.getChildAt(i)
                        if child and isinstance(child, AndroidTextView):
                            child.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                except Exception as e:
                    log(f"[KPM] Error fixing text colors: {e}")
            
            class LayoutListener(dynamic_proxy(View.OnLayoutChangeListener)):
                def onLayoutChange(self, v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom):
                    fix_text_colors()
            
            list_view.addOnLayoutChangeListener(LayoutListener())
            from android.widget import AbsListView
            class ScrollListener(dynamic_proxy(AbsListView.OnScrollListener)):
                def onScrollStateChanged(self, view, scrollState):
                    pass
                
                def onScroll(self, view, firstVisibleItem, visibleItemCount, totalItemCount):
                    fix_text_colors()
            
            list_view.setOnScrollListener(ScrollListener())
            
            try:
                list_view.setDivider(None)
                list_view.setDividerHeight(0)
                list_view.setSelector(Theme.getSelectorDrawable(False))
            except Exception as e:
                log(f"[KPM] Error setting ListView styling: {e}")
            
            class ItemClickListener(dynamic_proxy(AdapterView.OnItemClickListener)):
                def __init__(self, callback, ids_ref):
                    super().__init__()
                    self.callback = callback
                    self.ids_ref = ids_ref
                
                def onItemClick(self, parent, view, position, id):
                    if position < len(self.ids_ref[0]):
                        pid = self.ids_ref[0][position]
                        self.callback(pid)
            
            listener = ItemClickListener(on_click_callback, filtered_ids)
            list_view.setOnItemClickListener(listener)
            
            list_params = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(400)  
            )
            list_params.topMargin = AndroidUtilities.dp(8)
            container.addView(list_view, list_params)
            
            builder.setView(container)
            builder.setNegativeButton(_tr("cancel"), None)
            
            dialog = builder.create()
            current_dialog = [dialog]
            
            class SearchTextWatcher(dynamic_proxy(TextWatcher)):
                def __init__(self, adapter_ref, ids_ref, all_ids, names, color_fixer):
                    super().__init__()
                    self.adapter = adapter_ref
                    self.ids_ref = ids_ref
                    self.all_ids = all_ids
                    self.names = names
                    self.color_fixer = color_fixer
                
                def beforeTextChanged(self, s, start, count, after):
                    pass
                
                def onTextChanged(self, s, start, before, count):
                    pass
                
                def afterTextChanged(self, editable):
                    try:
                        query = str(editable).lower()
                        self.ids_ref[0].clear()
                        
                        if not query:
                            self.ids_ref[0].extend(self.all_ids)
                        else:
                            for pid in self.all_ids:
                                name = self.names.get(pid, pid).lower()
                                if query in name or query in pid.lower():
                                    self.ids_ref[0].append(pid)
                        
                        self.adapter.clear()
                        for pid in self.ids_ref[0]:
                            self.adapter.add(String(self.names[pid]))
                        self.adapter.notifyDataSetChanged()
                        
                        run_on_ui_thread(lambda: self.color_fixer())
                    except Exception as e:
                        log(f"[KPM] Search error: {e}")
            
            watcher = SearchTextWatcher(adapter, filtered_ids, plugin_ids, display_names, fix_text_colors)
            search_edit.addTextChangedListener(watcher)
            
            dialog.show()
        except Exception as e:
            log(f"[KPM] Error creating searchable dialog: {e}")

    def open_install_dialog(self):
        fragment = get_last_fragment()
        if not fragment:
            return
        
        def load_and_show():
            try:
                ids = self.list_available_ids()
                if not ids:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("list_empty")))
                    return
                
                log(f"[KPM] Loading display names for {len(ids)} plugins...")
                display_names = {}
                for pid in ids:
                    display_names[pid] = self.get_plugin_display_name(pid)
                log(f"[KPM] Loaded {len(display_names)} display names")
                
                # Save updated cache with names
                if self.plugin_names_cache:
                    cached_sha = self.get_cached_commit_sha()
                    if cached_sha:
                        self.save_cache(cached_sha)
                
                # Show dialog on UI thread
                def create_dialog():
                    try:
                        self._show_searchable_dialog(
                            fragment,
                            _tr("install_title"),
                            ids,
                            display_names,
                            lambda pid: run_on_queue(lambda: self.install_plugin_by_id(pid))
                        )
                    except Exception as e:
                        log(f"[KPM] Error creating install dialog: {e}")
                
                run_on_ui_thread(create_dialog)
            except Exception as e:
                log(f"[KPM] Error loading plugins: {e}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}"))
        
        # Run in background thread
        run_on_queue(load_and_show)

    def open_delete_dialog(self):
        installed = self.list_installed_plugins()
        if not installed:
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("no_installed")))
            return
        fragment = get_last_fragment()
        if not fragment:
            return

        display_names = {}
        for pid in installed:
            filename = f"{pid}.py"
            local_path = os.path.join(PLUGINS_DIR, filename)
            try:
                content = self.read_file_bytes(local_path)
                if content:
                    metadata = self.parse_plugin_metadata(content)
                    display_names[pid] = metadata["name"] if metadata["name"] else pid
                else:
                    display_names[pid] = pid
            except Exception:
                display_names[pid] = pid
        
        def create_dialog():
            try:
                self._show_searchable_dialog(
                    fragment,
                    _tr("delete_title"),
                    installed,
                    display_names,
                    lambda pid: run_on_queue(lambda: self.delete_plugin_by_id(pid))
                )
            except Exception:
                pass
        run_on_ui_thread(create_dialog)

    def list_installed_plugins(self):
        installed = []
        for pid in self.plugins_list.keys():
            filename = f"{pid}.py"
            if os.path.exists(os.path.join(PLUGINS_DIR, filename)):
                installed.append(pid)
        return installed

    def delete_plugin_by_id(self, plugin_id):
        filename = f"{plugin_id}.py"
        target = os.path.join(PLUGINS_DIR, filename)
        try:
            if os.path.exists(target):
                os.remove(target)
                def notify_deleted():
                    try:
                        controller = PluginsController.getInstance()
                        if controller and hasattr(controller, 'engines'):
                            engine = controller.engines.get("python")
                            if engine:
                                engine.loadPlugins(None)
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginsUpdated)
                    except Exception as e:
                        log(f"[KPM] Error reloading plugins: {e}")
                    BulletinHelper.show_error(_tr("deleted").format(filename))
                run_on_ui_thread(notify_deleted)
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("file_not_found")))
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_delete").format(e)))

    def get_local_plugin_path(self, plugin_id):
        return os.path.join(PLUGINS_DIR, f"{plugin_id}.plugin")

    def read_file_bytes(self, path):
        try:
            with open(path, "rb") as f:
                return f.read()
        except Exception:
            return None

    def sha256(self, data):
        h = hashlib.sha256()
        h.update(data)
        return h.hexdigest()

    def fetch_remote_bytes(self, url):
        r = requests.get(url, timeout=30)
        if r.status_code != 200:
            raise Exception(f"HTTP {r.status_code}")
        return r.content

    def install_plugin_by_id(self, plugin_id, _installing_deps=None):
        """Install plugin with dependencies support"""
        log(f"[KPM] === install_plugin_by_id called for: {plugin_id} ===")
        
        if _installing_deps is None:
            _installing_deps = set()
        
        log(f"[KPM] Current installing_deps set: {_installing_deps}")
        
        # Prevent circular dependencies
        if plugin_id in _installing_deps:
            log(f"[KPM] Circular dependency detected: {plugin_id}")
            return
        
        if not self.plugins_list:
            log(f"[KPM] plugins_list is empty, refreshing store...")
            self.refresh_store()
        
        if plugin_id not in self.plugins_list:
            log(f"[KPM] ERROR: {plugin_id} not found in plugins_list")
            log(f"[KPM] Available plugins: {list(self.plugins_list.keys())}")
            error_msg = f"Plugin {plugin_id} not found in store"
            run_on_ui_thread(lambda: BulletinHelper.show_error(error_msg))
            raise Exception(error_msg)
        
        plugin_info = self.plugins_list[plugin_id]
        log(f"[KPM] plugin_info for {plugin_id}: {plugin_info}")
        
        url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
        dependencies = plugin_info.get("dependencies", []) if isinstance(plugin_info, dict) else []
        
        log(f"[KPM] URL: {url}")
        log(f"[KPM] Dependencies: {dependencies}")
        
        # Install dependencies first
        if dependencies:
            log(f"[KPM] Found {len(dependencies)} dependencies, installing...")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("installing_deps")))
            _installing_deps.add(plugin_id)
            log(f"[KPM] Added {plugin_id} to installing_deps: {_installing_deps}")
            
            for dep_id in dependencies:
                log(f"[KPM] Processing dependency: {dep_id}")
                
                # Check if dependency is already installed
                dep_filename = f"{dep_id}.py"
                dep_path = os.path.join(PLUGINS_DIR, dep_filename)
                log(f"[KPM] Checking if {dep_id} exists at: {dep_path}")
                
                if os.path.exists(dep_path):
                    log(f"[KPM] Dependency {dep_id} already installed, skipping")
                    continue
                
                # Install dependency recursively
                try:
                    log(f"[KPM] Installing dependency: {dep_id}")
                    self.install_plugin_by_id(dep_id, _installing_deps)
                    log(f"[KPM] Successfully installed dependency: {dep_id}")
                    run_on_ui_thread(lambda d=dep_id: BulletinHelper.show_error(_tr("dep_installed").format(d)))
                except Exception as e:
                    error_msg = _tr("dep_error").format(f"{dep_id}: {e}")
                    log(f"[KPM] ERROR installing dependency {dep_id}: {e}")
                    log(f"[KPM] Traceback: {traceback.format_exc()}")
                    run_on_ui_thread(lambda msg=error_msg: BulletinHelper.show_error(msg))
                    return
        
        # Install the plugin itself
        log(f"[KPM] Starting download for {plugin_id} from: {url}")
        try:
            remote = self.fetch_remote_bytes(url)
            log(f"[KPM] Downloaded {len(remote)} bytes for {plugin_id}")
        except Exception as e:
            log(f"[KPM] ERROR downloading {plugin_id}: {e}")
            log(f"[KPM] Traceback: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_download").format(e)))
            raise  # Re-raise exception so caller knows installation failed
        
        filename = f"{plugin_id}.py"
        target = os.path.join(PLUGINS_DIR, filename)
        log(f"[KPM] Target path: {target}")
        
        url_filename = url.split("/")[-1] if "/" in url else ""
        log(f"[KPM] URL filename: {url_filename}")
        
        # Remove old files with different names
        if url_filename.endswith(".plugin"):
            old_name = url_filename[:-7]
            log(f"[KPM] Removing old files with name: {old_name}")
            for ext in [".plugin", ".py"]:
                old_file = os.path.join(PLUGINS_DIR, old_name + ext)
                if old_file != target and os.path.exists(old_file):
                    try:
                        os.remove(old_file)
                        log(f"[KPM] Removed old file: {old_file}")
                    except Exception as e:
                        log(f"[KPM] Failed to remove old file {old_file}: {e}")
        
        try:
            tmp = target + ".tmp"
            log(f"[KPM] Writing to temp file: {tmp}")
            with open(tmp, "wb") as f:
                f.write(remote)
            log(f"[KPM] Wrote {len(remote)} bytes to temp file")
            
            if os.path.exists(target):
                log(f"[KPM] Removing existing file: {target}")
                os.remove(target)
            
            log(f"[KPM] Renaming {tmp} to {target}")
            os.rename(tmp, target)
            log(f"[KPM] Successfully installed {plugin_id} to {target}")
            
            def notify_installed():
                try:
                    controller = PluginsController.getInstance()
                    if controller and hasattr(controller, 'engines'):
                        engine = controller.engines.get("python")
                        if engine:
                            engine.loadPlugins(None)
                    NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginsUpdated)
                except Exception as e:
                    log(f"[KPM] Error reloading plugins: {e}")
                BulletinHelper.show_error(_tr("installed").format(filename))
            run_on_ui_thread(notify_installed)
        except Exception as e:
            log(f"[KPM] ERROR writing file for {plugin_id}: {e}")
            log(f"[KPM] Traceback: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("error_write").format(e)))
            raise  # Re-raise exception so caller knows installation failed

    def update_installed_from_store(self):
        if not self.plugins_list:
            self.refresh_store()
        if not self.plugins_list:
            return
        updated = 0
        skipped = 0
        failed = 0
        for pid, plugin_info in self.plugins_list.items():
            url = plugin_info.get("url") if isinstance(plugin_info, dict) else plugin_info
            filename = f"{pid}.py"
            local_path = os.path.join(PLUGINS_DIR, filename)
            if not os.path.exists(local_path):
                continue
            local_bytes = self.read_file_bytes(local_path) or b""
            local_hash = self.sha256(local_bytes)
            try:
                remote = self.fetch_remote_bytes(url)
                remote_hash = self.sha256(remote)
            except Exception:
                failed += 1
                continue
            if local_hash != remote_hash:
                try:
                    tmp = local_path + ".tmp"
                    with open(tmp, "wb") as f:
                        f.write(remote)
                    os.remove(local_path)
                    os.rename(tmp, local_path)
                    updated += 1
                except Exception:
                    failed += 1
            else:
                skipped += 1
        run_on_ui_thread(lambda: BulletinHelper.show_error(_tr("updated_stats").format(updated, skipped, failed)))
