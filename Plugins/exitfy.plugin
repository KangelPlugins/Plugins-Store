#░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓████████▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓██████▓▒░  ░▒▓██████▓▒░░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓██████▓▒░  ░▒▓██████▓▒░  
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░     
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░     
#░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░  

import threading, time, requests, urllib.parse, socket, ctypes, base64, json, re, random
import os
from html import unescape

from base_plugin import BasePlugin, MenuItemData, MenuItemType, MethodHook
from android_utils import log, run_on_ui_thread
from ui.settings import Header, Switch, Selector, Text, Divider, Input
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from hook_utils import find_class, get_private_field, set_private_field
from client_utils import get_last_fragment
from java.util import Locale
from android.os import Build
from android.provider import Settings
from org.telegram.messenger import (
    ApplicationLoader, SharedConfig, MessagesController,
    NotificationCenter, UserConfig,
)
from org.telegram.tgnet import ConnectionsManager

__id__ = "exitfy"
__name__ = "exitFy"
__description__ = "Application download speed optimization"
__icon__ = "exitFy/0"
__author__ = "@exteraPluginsSup"
__version__ = "2.1.1"
__min_version__ = "12.1.1"

PROXY_API_URLS = {
    0: ["https://exitfy.ishrimp.xyz/proxy/latest"],
    1: ["https://exitfy.vpnetproxy.xyz/proxy/latest"],
    2: ["https://a.stemstep.cloud/proxy/socks"],
}
PROVIDER_NAMES = {0: "Shrimp", 1: "VPNET", 2: "Sworkle"}
VLESS_PROVIDER_SUBS = { 
    0: ["https://subs.invisibleshrimp.su/T1JSS-y0uNkBdCy-"],
    1: ["https://sub.vpnet.club/7q6wzBFL8huaB1nU"],
    2: ["https://s3.stemstep.cloud/sub/exitfy"],
}
SPONSOR_VLESS_URLS = set([u for arr in VLESS_PROVIDER_SUBS.values() for u in arr])
REFERRAL = {
    0: "https://t.me/invisibleshrimpbot?start=exitfy",
    1: "https://t.me/vpnetvpn_bot?start=exitfy",
    2: "https://t.me/sworklevpnbot?start=ref1208",
}
CHECK_INTERVAL_SEC = 5
RANDOM_PROXY_CHANCE = 0.15

TRANSLATIONS = {
    "settings_header":      ("Настройки плагина", "Plugin settings"),
    "enable_plugin":        ("Включить плагин", "Enable plugin"),
    "open_tg_settings":     ("Настройки Telegram", "Telegram settings"),
    "select_mode":          ("Режим подключения", "Connection mode"),
    "mode_proxy":           ("Прокси", "Proxy"),
    "mode_vless":           ("VLESS", "VLESS"),
    "menu_settings":        ("Настройки exitFy", "exitFy settings"),
    "select_provider":      ("Провайдер", "Provider"),
    "node":                 ("Сервер", "Server"),
    "refresh":              ("Обновить список", "Refresh list"),
    "auto_switch":          ("Автопереключение", "Auto switch"),
    "auto_switch_desc":     ("Автоматически менять сервер при потере соединения", "Automatically switch server on connection loss"),
    "auto_switch_header":   ("Параметры автопереключения", "Auto switch parameters"),
    "connect_try":          ("Ожидание подключения (сек)", "Connect wait (sec)"),
    "stuck":                ("Порог зависания (сек)", "Stuck threshold (sec)"),
    "cooldown":             ("Кулдаун переключения (сек)", "Switch cooldown (sec)"),
    "referral_btn":         ("Включить интернет везде", "Enable internet everywhere"),
    "vless_provider":       ("Провайдер", "Provider"),
    "vless_prov_custom":    ("Кастом", "Custom"),
    "vless_nodes_header":   ("Узлы подключения", "Connection nodes"),
    "vless_add_key":        ("Ключ VLESS", "VLESS key"),
    "vless_add_sub":        ("Подписка VLESS", "VLESS subscription"),
    "vless_no_nodes":       ("Смените провайдера или добавьте свой", "Change provider or add custom"),
    "vless_nodes_manage":   ("Управление узлами", "Manage nodes"),
    "vless_nodes_update":   ("Обновить узлы", "Update nodes"),
    "vless_nodes_clear":    ("Очистить свои узлы", "Clear custom nodes"),
    "vless_node_default":   ("VLESS узел", "VLESS node"),
    "addon_download_title": ("VLESS", "VLESS"),
    "addon_downloading":    ("Скачивание дополнения...", "Downloading add-on..."),
    "addon_download_error": ("Ошибка скачивания", "Download error"),
    "addon_delete":         ("Удалить дополнение", "Delete add-on"),
    "addon_delete_title":   ("Удалить дополнение?", "Delete add-on?"),
    "addon_delete_msg":     ("Дополнение будет удалено.", "The add-on will be removed."),
    "btn_delete":           ("Удалить", "Delete"),
    "btn_cancel":           ("Отмена", "Cancel"),
    "addon_delete_error":   ("Ошибка удаления", "Delete error"),
    "vless_no_core_msg":    ("Нет ядра VLESS.\nНажмите кнопку ниже, чтобы скачать дополнение.", "VLESS core is not available.\nTap the button below to download the add-on."),
    "vless_download_addon": ("Скачать дополнение", "Download add-on"),
    "settings_error":       ("Ошибка настроек", "Settings error"),
    "proxy_settings_error": ("Ошибка настроек прокси", "Proxy settings error"),
    "proxy_node":           ("Узел", "Node"),
    "vless_custom_sub_err": ("Ошибка подписки", "Subscription error"),
    "vless_custom_sub_empty": ("Подписка не содержит узлов", "Subscription contains no nodes"),
    "vless_custom_sub_bad": ("Неверная ссылка подписки", "Invalid subscription URL"),
    "vless_app_not_supported": ("Приложение не поддерживается", "App is not supported"),
}

def Z(key):
    lang = Locale.getDefault().getLanguage()
    idx = 0 if str(lang).startswith("ru") else 1
    try: return str(TRANSLATIONS.get(key, (key, key))[idx])
    except: return str(key)

def _prefs():
    return ApplicationLoader.applicationContext.getSharedPreferences("exitfy_prefs", 0)

def _pget_int(k, d=0):
    try: return int(_prefs().getInt(k, int(d)))
    except: return d

def _pset_int(k, v):
    try: ed = _prefs().edit(); ed.putInt(k, int(v)); ed.commit()
    except: pass

def _pget_str(k, d=""):
    try: return str(_prefs().getString(k, str(d)) or "")
    except: return d

def _pset_str(k, v):
    try: ed = _prefs().edit(); ed.putString(k, str(v or "")); ed.commit()
    except: pass

def _to_int(v, d=0):
    try: return int(v)
    except: return int(d)

def _norm(s):
    try: s = str(s or "")
    except: return ""
    try: s = unescape(s)
    except: pass
    s = s.strip()
    if not s: return ""
    try: s = re.sub(r"[\s\)\]>,\.;]+$", "", s)
    except: pass
    try: s = re.sub(r"^[\s\(\[<]+", "", s)
    except: pass
    return s

def _parse_link(link):
    try:
        link = _norm(str(link))
        if not link: return None
        if link.startswith("https://t.me/socks"):
            link = link.replace("https://t.me/socks", "tg://socks", 1)
        elif link.startswith("https://t.me/proxy"):
            link = link.replace("https://t.me/proxy", "tg://proxy", 1)
        if "?" not in link: return None
        qs = link.split("?", 1)[1]
        params = {}
        for part in qs.split("&"):
            if "=" in part:
                k, v = part.split("=", 1); params[k.lower()] = urllib.parse.unquote(v)
        server = params.get("server", ""); port_s = params.get("port", "")
        if not server or not port_s: return None
        return SharedConfig.ProxyInfo(str(server), int(port_s), "", "", str(params.get("secret", "")))
    except: return None

def _is_bypass_host(p):
    try:
        h = str(p.address or "").lower()
        return ("ishrimp.xyz" in h or "vpnet" in h or "sworkle" in h or
                "stemstep" in h or h == "127.0.0.1" or h.startswith("exitfy-"))
    except: return False

def _apply_proxy_info(info):
    if info is None: return
    try: SharedConfig.loadProxyList()
    except: pass
    existing = None
    try:
        if hasattr(SharedConfig, "proxyList") and SharedConfig.proxyList is not None:
            for i in range(int(SharedConfig.proxyList.size())):
                try:
                    p = SharedConfig.proxyList.get(i)
                    if _is_bypass_host(p): existing = p; break
                except: continue
    except: pass
    added = None
    if existing is not None:
        try:
            existing.address = str(info.address); existing.port = int(info.port)
            existing.username = ""; existing.password = ""
            existing.secret = str(info.secret or ""); added = existing
        except: pass
    if added is None:
        try:
            added = SharedConfig.addProxy(str(info.address), int(info.port), "", "", str(info.secret or ""))
        except: added = info
    try: SharedConfig.currentProxy = added
    except: pass
    enabled_now = _tg_proxy_enabled()
    try: SharedConfig.proxyEnabled = bool(enabled_now); SharedConfig.saveConfig()
    except: pass
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putString("proxy_ip", str(added.address)); ed.putInt("proxy_port", int(added.port))
        ed.putString("proxy_user", ""); ed.putString("proxy_pass", "")
        ed.putString("proxy_secret", str(added.secret or ""))
        ed.putBoolean("proxy_enabled", bool(enabled_now)); ed.apply()
    except: pass
    try:
        if bool(enabled_now):
            ConnectionsManager.setProxySettings(True, added.address, int(added.port), "", "", added.secret)
        else:
            ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
    except: pass
    try:
        run_on_ui_thread(lambda: NotificationCenter.getGlobalInstance().postNotificationName(
            NotificationCenter.proxySettingsChanged), 350)
    except: pass

def _tg_proxy_enabled():
    try: return bool(MessagesController.getGlobalMainSettings().getBoolean("proxy_enabled", False))
    except: return False

def _set_tg_proxy_enabled(enabled):
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putBoolean("proxy_enabled", bool(enabled)); ed.commit()
    except: pass
    try: SharedConfig.proxyEnabled = bool(enabled); SharedConfig.saveConfig()
    except: pass
    try:
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm:
                    if bool(enabled) and SharedConfig.currentProxy is not None:
                        p = SharedConfig.currentProxy
                        cm.setProxySettings(True, p.address, int(p.port), p.username, p.password, p.secret)
                    else:
                        cm.setProxySettings(False, "", 0, "", "", "")
            except: pass
    except: pass
    try: NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
    except: pass

def _fetch_proxy_links(proxy_type):
    urls = PROXY_API_URLS.get(proxy_type) or []
    out = []
    for url in urls:
        try:
            r = requests.get(url, timeout=10)
            if r.status_code != 200: continue
            text = (r.text or "").strip()
            if not text: continue
            for line in str(text).splitlines():
                s = (line or "").strip()
                if not s: continue
                found = []
                try: found = re.findall(r"(tg://[^\s\"']+)", s)
                except: pass
                if found:
                    out.extend([_norm(x) for x in found if _norm(x)]); continue
                try: found = re.findall(r"(https?://t\.me/[^\s\"']+)", s)
                except: pass
                if found:
                    out.extend([_norm(x) for x in found if _norm(x)]); continue
                if "tg://" in s or "t.me/" in s:
                    ns = _norm(s)
                    if ns: out.append(ns)
            if out: return out
        except: continue
    return out

def _proxy_latency(link):
    try:
        info = _parse_link(str(link))
        if not info: return None
        start = time.monotonic()
        s = socket.create_connection((str(info.address), int(info.port)), timeout=3)
        dt = float(time.monotonic() - start); s.close(); return dt
    except: return None

def _score_links(links):
    results = []; lock = threading.Lock()
    def worker(l):
        dt = _proxy_latency(str(l))
        if dt is not None:
            with lock: results.append((float(dt), str(l)))
    threads = [threading.Thread(target=worker, args=(l,), daemon=True) for l in links[:20]]
    for t in threads: t.start()
    deadline = time.time() + 5
    for t in threads:
        remain = float(deadline - time.time())
        if remain <= 0: break
        t.join(timeout=remain)
    results.sort(key=lambda x: x[0])
    return results if results else [(0.0, str(l)) for l in links[:5]]

def _log(msg): log(f"[exitfy] {msg}")

class VlessConfigParser:
    @staticmethod
    def parse(uri_str, local_port):
        try:
            if not uri_str.startswith("vless://"): return None, None
            part = uri_str[8:]; name = Z("vless_node_default")
            if "#" in part:
                part, name = part.split("#", 1); name = urllib.parse.unquote(name).strip()
            if "@" not in part: return None, None
            uuid_str, rest = part.split("@", 1)
            if "?" in rest: host_port, params_raw = rest.split("?", 1)
            else: host_port, params_raw = rest, ""
            host_port = str(host_port).strip().rstrip("/")
            if ":" not in host_port: return None, None
            host, port = host_port.split(":", 1)
            try:
                port = int(str(port).strip())
            except:
                return None, None
            params = {}
            if params_raw:
                for pair in params_raw.split("&"):
                    if "=" in pair:
                        k, v = pair.split("=", 1); params[k] = urllib.parse.unquote(v)
            config = {
                "log": {"loglevel": "none"},
                "inbounds": [{"tag": "socks-in", "port": local_port, "listen": "127.0.0.1",
                              "protocol": "socks",
                              "settings": {"auth": "noauth", "udp": True, "ip": "127.0.0.1"},
                              "sniffing": {"enabled": True, "destOverride": ["http", "tls"], "routeOnly": False}}],
                "outbounds": [{"tag": "proxy", "protocol": "vless",
                               "settings": {"vnext": [{"address": host, "port": port,
                                                        "users": [{"id": uuid_str, "encryption": "none",
                                                                   "flow": params.get("flow", "")}]}]},
                               "streamSettings": {"network": params.get("type", "tcp"),
                                                  "security": params.get("security", "none")}}]
            }
            stream = config["outbounds"][0]["streamSettings"]
            fp = params.get("fp", "chrome")

            try:
                if "packetEncoding" not in stream:
                    stream["packetEncoding"] = str(params.get("packetEncoding", "xudp"))
            except:
                pass

            if params.get("security") == "reality":
                stream["realitySettings"] = {"show": False, "fingerprint": fp,
                    "serverName": params.get("sni", ""), "publicKey": params.get("pbk", ""),
                    "shortId": params.get("sid", ""), "spiderX": params.get("spx", "")}
            elif params.get("security") == "tls":
                stream["tlsSettings"] = {"serverName": params.get("sni", ""),
                                         "allowInsecure": False, "fingerprint": fp}
            net = params.get("type", "tcp")
            if net == "ws":
                stream["wsSettings"] = {"path": params.get("path", "/"),
                    "headers": {"Host": params.get("host", params.get("sni", ""))}}
            elif net == "grpc":
                stream["grpcSettings"] = {"serviceName": params.get("serviceName", ""),
                    "multiMode": params.get("mode", "multi") == "multi"}
            return json.dumps(config), name
        except Exception as e:
            _log(f"VLESS parse error: {e}"); return None, None

class VlessCore:
    def __init__(self):
        self.lib = None
        self.mode = None
        self.libc = None

        self._try_init_standalone()

    def _try_init_standalone(self):
        try:
            ctx = ApplicationLoader.applicationContext
            dir_path = os.path.join(str(ctx.getFilesDir()), "exitfy_modules")
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            so_path = os.path.join(dir_path, "libvless.so")

            if (not os.path.exists(so_path)) or (os.path.getsize(so_path) < 1024):
                return

            linker = _NativeLinker()
            lib = linker.load(so_path)
            if not lib:
                return

            lib.StartCore.argtypes = [ctypes.c_char_p]
            lib.StartCore.restype = ctypes.c_void_p
            lib.StopCore.argtypes = []
            lib.StopCore.restype = None
            self.lib = lib
            self.mode = "standalone"

            try:
                self.libc = ctypes.CDLL("libc.so")
                self.libc.free.argtypes = [ctypes.c_void_p]
                self.libc.free.restype = None
            except:
                self.libc = None
        except Exception as e:
            _log(f"libvless standalone init failed: {e}")
            return

    def is_available(self): return self.lib is not None

    def start(self, config_json):
        if not self.is_available(): return "Native library not loaded"
        try:
            res_ptr = self.lib.StartCore(config_json.encode('utf-8'))
            if not res_ptr:
                return ""
            try:
                res_str = ctypes.cast(res_ptr, ctypes.c_char_p).value
                out = res_str.decode('utf-8', errors='ignore') if res_str else ""
            except:
                out = ""
            try:
                if self.libc:
                    self.libc.free(res_ptr)
            except:
                pass
            return out
        except Exception as e: return str(e)

    def stop(self):
        if self.is_available():
            try: self.lib.StopCore()
            except: pass

class _NativeLinker:
    def __init__(self):
        self.libdl = ctypes.CDLL("libdl.so")
        try:
            self.open_ext = self.libdl.android_dlopen_ext
            class Info(ctypes.Structure):
                _fields_ = [
                    ("flags", ctypes.c_uint64),
                    ("reserved_addr", ctypes.c_void_p),
                    ("reserved_size", ctypes.c_size_t),
                    ("relro_fd", ctypes.c_int),
                    ("library_fd", ctypes.c_int),
                    ("library_fd_offset", ctypes.c_uint64),
                    ("library_namespace", ctypes.c_void_p),
                ]
            self.Info = Info
            self.open_ext.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.POINTER(self.Info)]
            self.open_ext.restype = ctypes.c_void_p
        except:
            self.open_ext = None

    def load(self, path: str):
        if not os.path.exists(path):
            return None

        try:
            if int(Build.VERSION.SDK_INT) >= 29 and self.open_ext:
                fd = os.open(path, os.O_RDONLY)
                try:
                    info = self.Info(flags=0x10, library_fd=fd)
                    h = self.open_ext(path.encode(), 2 | 0x100, ctypes.byref(info))
                    if h:
                        return ctypes.CDLL(path, handle=h)
                finally:
                    try: os.close(fd)
                    except: pass
        except:
            pass

        try:
            return ctypes.CDLL(path, mode=2 | 0x100)
        except:
            return None

def _vless_apply_tg_proxy(port, enable):
    try:
        ProxyInfoClass = find_class("org.telegram.messenger.SharedConfig$ProxyInfo")
        ed = MessagesController.getGlobalMainSettings().edit()
        try:
            proxy_list = SharedConfig.proxyList
            if proxy_list:
                to_remove = []
                for i in range(proxy_list.size()):
                    p = proxy_list.get(i)
                    if str(p.address) == "127.0.0.1":
                        to_remove.append(p)
                for p in to_remove:
                    SharedConfig.deleteProxy(p)
        except: pass

        try:
            curr = SharedConfig.currentProxy
            if curr and str(curr.address) == "127.0.0.1":
                SharedConfig.currentProxy = None
        except:
            pass

        if enable:
            proxy_obj = ProxyInfoClass("127.0.0.1", port, "", "", "")
            SharedConfig.addProxy(proxy_obj)
            SharedConfig.currentProxy = proxy_obj
            SharedConfig.proxyEnabled = True
            ed.putString("proxy_ip", "127.0.0.1"); ed.putInt("proxy_port", port)
            try:
                ed.remove("proxy_user"); ed.remove("proxy_pass")
            except:
                ed.putString("proxy_user", ""); ed.putString("proxy_pass", "")
            ed.putString("proxy_secret", ""); ed.putBoolean("proxy_enabled", True)
        else:
            SharedConfig.proxyEnabled = False
            ed.putBoolean("proxy_enabled", False)
        try:
            ed.commit()
        except:
            ed.apply()
        try:
            SharedConfig.saveProxyList()
        except:
            pass
        SharedConfig.saveConfig()
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm:
                    if enable: cm.setProxySettings(True, "127.0.0.1", port, "", "", "")
                    else: cm.setProxySettings(False, "", 0, "", "", "")
            except: pass
        def _notify():
            try:
                from java import jarray
                from java.lang import Object
                NotificationCenter.getGlobalInstance().postNotificationName(
                    NotificationCenter.proxySettingsChanged, jarray(Object)(0))
            except:
                try:
                    NotificationCenter.getGlobalInstance().postNotificationName(
                        NotificationCenter.proxySettingsChanged)
                except: pass
        run_on_ui_thread(_notify, 300)
        try:
            prefs = MessagesController.getGlobalMainSettings()
            _log(
                "vless_apply_tg_proxy: "
                f"enable={enable} port={port} "
                f"proxy_enabled={prefs.getBoolean('proxy_enabled', False)} "
                f"ip={prefs.getString('proxy_ip', '')} "
                f"p={prefs.getInt('proxy_port', 0)} "
                f"secret_len={len(str(prefs.getString('proxy_secret', '') or ''))}"
            )
        except:
            _log(f"vless_apply_tg_proxy: enable={enable} port={port}")
    except Exception as e: _log(f"vless_apply_tg_proxy error: {e}")

def _check_vless_port(port, timeout=0.2):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout); return s.connect_ex(('127.0.0.1', port)) == 0
    except: return False

def _get_free_port():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0)); return s.getsockname()[1]

def _fetch_vless_nodes(url):
    try:
        url2 = str(url or "")
        r = requests.get(url2, timeout=15)
        if r.status_code != 200: return []
        text = r.text.strip()
        if "vless://" not in text:
            try:
                b64 = str(text or "").strip()
                b64 = b64.replace("\n", "").replace("\r", "")
                b64 = b64.replace("-", "+").replace("_", "/")
                missing = len(b64) % 4
                if missing:
                    b64 += '=' * (4 - missing)
                raw = base64.b64decode(b64, validate=False)
                text = raw.decode('utf-8', errors='ignore')
            except: pass
        nodes = []
        try:
            links = re.findall(r"vless://[^\s]+", str(text or ""))
        except:
            links = []

        if not links:
            try:
                raw = str(text or "").lstrip()
                if raw.startswith("{") or raw.startswith("["):
                    def _walk(obj, out):
                        if isinstance(obj, dict):
                            t = obj.get("type")
                            p = obj.get("protocol")
                            if str(t).lower() == "vless" or str(p).lower() == "vless":
                                out.append(obj)
                            for v in obj.values():
                                _walk(v, out)
                        elif isinstance(obj, list):
                            for v in obj:
                                _walk(v, out)

                    try:
                        parsed = json.loads(raw)
                    except Exception as je:
                        parsed = None

                    if parsed is None:
                        raise Exception("json parse failed")

                    found = []
                    _walk(parsed, found)

                    built = []
                    for ob in found:
                        try:
                            uuid_str = ob.get("uuid") or ob.get("id") or ob.get("user")
                            server = ob.get("server") or ob.get("address")
                            port = ob.get("server_port") or ob.get("port")

                            if not uuid_str:
                                users = ob.get("users")
                                if isinstance(users, list) and users:
                                    u0 = users[0] if isinstance(users[0], dict) else None
                                    if u0:
                                        uuid_str = u0.get("uuid") or u0.get("id") or u0.get("user")

                            if (not uuid_str or not server or not port) and isinstance(ob.get("settings"), dict):
                                st = ob.get("settings") or {}
                                vnext = st.get("vnext")
                                if isinstance(vnext, list):
                                    for vn in vnext:
                                        try:
                                            if not isinstance(vn, dict):
                                                continue
                                            server2 = vn.get("address") or vn.get("server") or vn.get("address")
                                            port2 = vn.get("port")
                                            users2 = vn.get("users")
                                            uuid2 = None
                                            if isinstance(users2, list) and users2:
                                                u = users2[0] if isinstance(users2[0], dict) else None
                                                if u:
                                                    uuid2 = u.get("id") or u.get("uuid")
                                            if not uuid2 or not server2 or not port2:
                                                continue
                                            link2 = f"vless://{uuid2}@{server2}:{int(port2)}"
                                            tag2 = ob.get("tag") or ob.get("name") or ""
                                            if tag2:
                                                link2 += "#" + urllib.parse.quote(str(tag2))
                                            built.append(link2)
                                        except:
                                            continue
                                continue

                            if not uuid_str or not server or not port:
                                continue

                            tls = ob.get("tls") or {}
                            security = ""
                            sni = ""
                            if isinstance(tls, dict):
                                enabled = tls.get("enabled")
                                if enabled is True or str(enabled).lower() == "true":
                                    security = "tls"
                                sni = tls.get("server_name") or tls.get("sni") or ""

                            transport = ob.get("transport") or {}
                            net = "tcp"
                            path = ""
                            host = ""
                            if isinstance(transport, dict):
                                net = transport.get("type") or transport.get("network") or net
                                net = str(net or "tcp")
                                path = transport.get("path") or ""
                                headers2 = transport.get("headers") or {}
                                if isinstance(headers2, dict):
                                    host = headers2.get("Host") or headers2.get("host") or ""

                            params = {}
                            if security:
                                params["security"] = security
                            if sni:
                                params["sni"] = str(sni)
                            if net:
                                params["type"] = str(net)
                            if path:
                                params["path"] = str(path)
                            if host:
                                params["host"] = str(host)

                            qs = "&".join([f"{urllib.parse.quote(str(k))}={urllib.parse.quote(str(v))}" for k, v in params.items()])
                            tag = ob.get("tag") or ob.get("name") or ""
                            frag = urllib.parse.quote(str(tag)) if tag else ""
                            link = f"vless://{uuid_str}@{server}:{int(port)}"
                            if qs:
                                link += "?" + qs
                            if frag:
                                link += "#" + frag
                            built.append(link)
                        except:
                            continue

                    if built:
                        links.extend(built)
            except:
                pass

        if not links:
            for line in str(text or "").splitlines():
                line = str(line or "").strip()
                if line.startswith("vless://"):
                    links.append(line)

        filtered = 0
        any_not_supported = False
        for link in links:
            try:
                link = str(link or "").strip()
                if not link.startswith("vless://"):
                    continue
                try:
                    low = link.lower()
                    if "@0.0.0.0:1" in low:
                        filtered += 1
                        any_not_supported = True
                        continue
                    if "приложение" in urllib.parse.unquote(link).lower() and "не поддерж" in urllib.parse.unquote(link).lower():
                        filtered += 1
                        any_not_supported = True
                        continue
                except:
                    pass
                conf, name = VlessConfigParser.parse(link, 1080)
                if conf:
                    nodes.append({"name": name, "uri": link, "ping": -1})
            except:
                continue
        return nodes
    except Exception as e:
        _log(f"fetch_vless_nodes error ({url}): {e}"); return []

class exitfyPlugin(BasePlugin):
    def on_plugin_load(self):
        self._vless_core = VlessCore()
        self._vless_port = 20808
        self._vless_running = False
        self._ping_event = threading.Event()

        self._chat_menu_item_id = "exitfy_settings_chat"
        self._drawer_menu_item_id = "exitfy_settings_drawer"

        self._proxy_links = []
        self._proxy_cycle_idx = 0
        self._watchdog_stop = threading.Event()

        self._vpn_guard_stop = threading.Event()
        self._vpn_guard_was_active = False

        self._vless_data = self.get_setting("vless_data", {"manual": [], "subs": [], "active_uri": ""})
        self._vless_active_uri = self._vless_data.get("active_uri", "")
        self._vless_custom_sub_url = self.get_setting("vless_custom_sub_url", "")
        self._ping_stop = threading.Event()
        self._vless_init_in_progress = False
        self._last_custom_key_applied = ""
        self._last_custom_sub_applied = ""

        try:
            self._proxy_custom_urls = json.loads(_pget_str("proxy_custom_urls", "[]"))
            if not isinstance(self._proxy_custom_urls, list):
                self._proxy_custom_urls = []
        except:
            self._proxy_custom_urls = []

        self._add_menu_items()

        self._vpn_guard_stop.clear()
        threading.Thread(target=self._vpn_guard_loop, daemon=True).start()

        mode = self.get_setting("mode", 1)
        if mode == 0:
            if self.get_setting("proxy_enabled", False):
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        else:
            threading.Thread(target=self._vless_pinger_loop, daemon=True).start()
            if self.get_setting("vless_enabled", False) and self._vless_active_uri:
                threading.Thread(target=self._vless_connect, daemon=True).start()

    def on_plugin_unload(self):
        self._watchdog_stop.set()
        self._ping_stop.set()
        self._vpn_guard_stop.set()
        self._vless_disconnect(silent=True)
        self._remove_menu_items()

    def _download_libvless(self):
        return self._download_libvless_with_progress(None)

    def _download_libvless_with_progress(self, on_progress):
        try:
            ctx = ApplicationLoader.applicationContext
            dir_path = os.path.join(str(ctx.getFilesDir()), "exitfy_modules")
            if not os.path.exists(dir_path):
                os.makedirs(dir_path)
            so_path = os.path.join(dir_path, "libvless.so")
            url = "https://github.com/coidarashka/MandreLib-Modules/releases/download/LocalAiChat/libvless.so"

            _log("libvless download: start")
            r = requests.get(url, stream=True, timeout=30)
            r.raise_for_status()

            total = 0
            try:
                total = int(r.headers.get("content-length") or 0)
            except:
                total = 0

            done = 0
            if callable(on_progress):
                try: on_progress(0.0)
                except: pass

            with open(so_path, "wb") as f:
                for chunk in r.iter_content(8192):
                    if not chunk:
                        continue
                    f.write(chunk)
                    done += len(chunk)
                    if callable(on_progress):
                        try:
                            if total > 0:
                                on_progress(float(done) / float(total))
                            else:
                                # fallback if size unknown
                                on_progress(0.0)
                        except:
                            pass

            if callable(on_progress):
                try: on_progress(1.0)
                except: pass

            _log(f"libvless download: done bytes={done} total={total}")
            try:
                if os.path.getsize(so_path) < 1024:
                    _log("libvless download: file too small")
                    return False
            except:
                return False
            return True
        except Exception as e:
            _log(f"libvless download error: {e}")
            return False

    def _download_libvless_and_reload(self):
        try:
            frag = get_last_fragment()
            act = frag.getParentActivity() if frag else None
        except:
            act = None

        if not act:
            threading.Thread(target=lambda: self._download_libvless_and_reload_bg(None), daemon=True).start()
            return

        dialog_box = {"builder": None}

        def show_dialog():
            try:
                builder = AlertDialogBuilder(act, AlertDialogBuilder.ALERT_TYPE_SPINNER)
                try:
                    builder.set_title(Z("addon_download_title"))
                except:
                    pass
                try:
                    builder.set_message(Z("addon_downloading"))
                except:
                    pass
                builder.show()
                try:
                    builder.set_cancelable(False)
                except:
                    pass
                try:
                    builder.set_canceled_on_touch_outside(False)
                except:
                    pass

                dialog_box["builder"] = builder
            except Exception as e:
                _log(f"download dialog show error: {e}")

        def close_dialog():
            try:
                b = dialog_box.get("builder")
                if b:
                    b.dismiss()
            except:
                pass

        def set_progress(p):
            try:
                # Spinner dialog: progress updates are optional.
                return
            except:
                pass

        run_on_ui_thread(show_dialog)

        def task():
            try:
                def on_progress(p):
                    run_on_ui_thread(lambda: set_progress(p))

                ok = self._download_libvless_with_progress(on_progress)
                if ok:
                    _log("libvless download: init core")
                    self._vless_core = VlessCore()
                    try:
                        _log(f"libvless core available={self._vless_core.is_available()} mode={getattr(self._vless_core, 'mode', None)}")
                    except:
                        pass
                run_on_ui_thread(close_dialog)
                run_on_ui_thread(self._reload_settings_ui)
                if not ok:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(Z("addon_download_error")))
                    except:
                        pass
            except Exception as e:
                _log(f"download libvless task error: {e}")
                run_on_ui_thread(close_dialog)
                run_on_ui_thread(self._reload_settings_ui)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(Z("addon_download_error")))
                except:
                    pass

        threading.Thread(target=task, daemon=True).start()

    def _download_libvless_and_reload_bg(self, on_progress):
        try:
            ok = self._download_libvless_with_progress(on_progress)
            if ok:
                self._vless_core = VlessCore()
            run_on_ui_thread(self._reload_settings_ui)
        except Exception as e:
            _log(f"download libvless bg error: {e}")
            run_on_ui_thread(self._reload_settings_ui)

    def _libvless_so_path(self):
        try:
            ctx = ApplicationLoader.applicationContext
            dir_path = os.path.join(str(ctx.getFilesDir()), "exitfy_modules")
            return os.path.join(dir_path, "libvless.so")
        except:
            return None

    def _has_libvless_addon(self):
        try:
            p = self._libvless_so_path()
            return bool(p) and os.path.exists(p) and os.path.getsize(p) >= 1024
        except:
            return False

    def _delete_libvless_and_reload(self):
        try:
            self._vless_disconnect(silent=True)
        except:
            pass

        def task():
            ok = False
            try:
                p = self._libvless_so_path()
                if p and os.path.exists(p):
                    try:
                        os.remove(p)
                        ok = True
                    except Exception as e:
                        _log(f"libvless delete error: {e}")
                self._vless_core = VlessCore()
            except Exception as e:
                _log(f"libvless delete task error: {e}")
            run_on_ui_thread(self._reload_settings_ui)
            if not ok:
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(Z("addon_delete_error")))
                except:
                    pass

        threading.Thread(target=task, daemon=True).start()

    def _is_system_vpn_active(self):
        try:
            ctx = ApplicationLoader.applicationContext
            cm = ctx.getSystemService("connectivity")
            if not cm:
                return False

            try:
                active = cm.getActiveNetwork()
                caps = cm.getNetworkCapabilities(active) if active else None
                if caps:
                    try:
                        from android.net import NetworkCapabilities
                        return bool(caps.hasTransport(NetworkCapabilities.TRANSPORT_VPN))
                    except:
                        pass
            except:
                pass

            try:
                info = cm.getActiveNetworkInfo()
                if info and info.isConnected():
                    try:
                        from android.net import ConnectivityManager
                        return int(info.getType()) == int(ConnectivityManager.TYPE_VPN)
                    except:
                        pass
            except:
                pass
        except:
            return False
        return False

    def _disable_plugin_due_to_vpn(self):
        try:
            mode = _to_int(self.get_setting("mode", 1), 1)

            self._watchdog_stop.set()
            if mode == 1:
                self._vless_disconnect(silent=True)
                try:
                    self.set_setting("vless_enabled", False, reload_settings=True)
                except:
                    pass
            else:
                try:
                    self.set_setting("proxy_enabled", False, reload_settings=True)
                except:
                    pass

            _set_tg_proxy_enabled(False)
            try:
                _vless_apply_tg_proxy(0, False)
            except:
                pass

            run_on_ui_thread(self._reload_settings_ui)
            _log("system VPN detected -> plugin disabled")
        except Exception as e:
            _log(f"vpn auto-disable error: {e}")

    def _vpn_guard_loop(self):
        while not self._vpn_guard_stop.is_set():
            try:
                vpn_active = bool(self._is_system_vpn_active())

                enabled_any = bool(self.get_setting("proxy_enabled", False)) or bool(self.get_setting("vless_enabled", False))
                if vpn_active and enabled_any:
                    if not self._vpn_guard_was_active:
                        self._vpn_guard_was_active = True
                    self._disable_plugin_due_to_vpn()
                elif not vpn_active:
                    self._vpn_guard_was_active = False
            except:
                pass

            self._vpn_guard_stop.wait(3.0)

    def _init_default_vless_sub(self, provider=None):
        self._vless_init_in_progress = True
        if provider is None:
            provider = self.get_setting("vless_provider", 0)
        urls = VLESS_PROVIDER_SUBS.get(provider, list(VLESS_PROVIDER_SUBS.get(0, [])))
        for url in urls:
            nodes = _fetch_vless_nodes(url)
            if nodes:
                if "subs" not in self._vless_data: self._vless_data["subs"] = []
                existing_urls = [s["url"] for s in self._vless_data["subs"]]
                if url not in existing_urls:
                    self._vless_data["subs"].append({
                        "id": url, "url": url,
                        "name": urllib.parse.urlparse(url).netloc,
                        "nodes": nodes
                    })
                self._vless_save_data()
                self._ping_event.set()
        self.set_setting("_subs_loaded_for", provider)
        self._vless_init_in_progress = False
        self._reload_settings_ui()

    def create_settings(self):
        mode = _to_int(self.get_setting("mode", 1), 1)
        if mode == 0:
            en_key = "proxy_enabled"
        else:
            en_key = "vless_enabled"
        en_text = Z("enable_plugin")
        items = [
            Header(text=Z("settings_header")),
            Switch(key=en_key, text=en_text,
                   default=False,
                   icon="msg_permissions", on_change=self._on_enabled_changed),
            Text(text=Z("open_tg_settings"),
                 icon="msg_settings",
                 on_click=lambda v: self._open_tg_proxy_settings()),
            Selector(key="mode", text=Z("select_mode"),
                     default=1,
                     items=[Z("mode_proxy"), Z("mode_vless")],
                     icon="msg_switch", on_change=self._on_mode_changed),
            Divider(),
        ]

        try:
            if mode == 0:
                items += self._proxy_settings_items()
            else:
                items += self._vless_settings_items()
        except Exception as e:
            _log(f"settings error: {e}")
            items += [Text(text=Z("settings_error"), icon="msg_info"), Divider()]

        try:
            del_btn = Z("addon_delete")

            def on_delete(v):
                try:
                    frag = get_last_fragment()
                    act = frag.getParentActivity() if frag else None
                    if not act:
                        self._delete_libvless_and_reload()
                        return

                    title = Z("addon_delete_title")
                    msg = Z("addon_delete_msg")
                    yes = Z("btn_delete")
                    no = Z("btn_cancel")

                    b = AlertDialogBuilder(act)
                    b.set_title(title)
                    b.set_message(msg)
                    b.set_negative_button(no, lambda bb, w: bb.dismiss())
                    b.set_positive_button(yes, lambda bb, w: (bb.dismiss(), self._delete_libvless_and_reload()))
                    try:
                        b.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
                    except:
                        pass
                    b.show()
                except Exception as e:
                    _log(f"delete addon dialog error: {e}")
                    self._delete_libvless_and_reload()

            if self._has_libvless_addon():
                items.append(Divider())
                items.append(Text(text=del_btn, icon="msg_delete", red=True, on_click=on_delete))

        except:
            pass

        return items

    def _proxy_settings_items(self):
        try:
            provider_idx = _to_int(self.get_setting("proxy_provider", 0), 0)
            auto_switch = self.get_setting("proxy_auto_switch", True)

            items = [
                Selector(key="proxy_provider", text=Z("select_provider"),
                         default=0,
                         items=[PROVIDER_NAMES[i] for i in sorted(PROVIDER_NAMES)],
                         icon="msg_channel", on_change=self._on_provider_changed),
            ]

            if not auto_switch:
                proxy_links = getattr(self, "_proxy_links", []) or []
                node_labels = []
                for i, info in enumerate([_parse_link(l) for l in proxy_links]):
                    node_labels.append(str(info.address) if info else f"{Z('proxy_node')} {i+1}")
                if node_labels:
                    items.append(Selector(key="proxy_manual_node", text=Z("node"),
                                          default=0,
                                          items=node_labels, icon="msg_settings_14",
                                          on_change=self._on_manual_node_changed))

            items.append(Text(text=Z("refresh"), icon="msg_retry",
                              on_click=lambda v: self._proxy_refresh()))

            items.append(Switch(key="proxy_auto_switch", text=Z("auto_switch"),
                                subtext=Z("auto_switch_desc"), default=True,
                                icon="media_flip", on_change=self._on_auto_switch_changed))

            if auto_switch:
                items += [
                    Header(text=Z("auto_switch_header")),
                    Input(key="proxy_connect_try", text=Z("connect_try"),
                          default=str(_pget_int("proxy_connect_try", 7)),
                          icon="msg_settings_14",
                          on_change=self._on_connect_try_changed),
                    Input(key="proxy_stuck_sec", text=Z("stuck"),
                          default=str(_pget_int("proxy_stuck_sec", 8)),
                          icon="msg_settings_14",
                          on_change=self._on_stuck_changed),
                    Input(key="proxy_cooldown_sec", text=Z("cooldown"),
                          default=str(_pget_int("proxy_cooldown_sec", 5)),
                          icon="msg_settings_14",
                          on_change=self._on_cooldown_changed),
                ]

            items += [
                Text(text=Z("referral_btn"), icon="msg_link",
                     accent=True,
                     on_click=self._make_referral_click(provider_idx, "proxy")),
                Divider(),
            ]

            for url in (getattr(self, "_proxy_custom_urls", []) or []):
                label = urllib.parse.urlparse(str(url)).netloc or str(url)
                items.append(Text(text=f"✕ {label}", icon="msg_delete",
                                  on_click=self._make_proxy_sub_delete(url)))

            items.append(Divider())
            return items
        except Exception as e:
            _log(f"proxy settings error: {e}")
            return [Text(text=Z("proxy_settings_error"), icon="msg_info"), Divider()]

    def _vless_settings_items(self):
        if not self._vless_core.is_available():
            msg = Z("vless_no_core_msg")
            btn = Z("vless_download_addon")
            items = [
                Divider(text=msg),
                Text(text=btn, icon="msg_download", accent=True,
                     on_click=lambda v: self._download_libvless_and_reload()),
            ]

            if self._has_libvless_addon():
                del_btn = Z("addon_delete")
                items.append(Text(text=del_btn, icon="msg_delete", red=True,
                                  on_click=lambda v: self._delete_libvless_and_reload()))
            items.append(Divider())
            return items

        active = self._vless_active_uri
        vless_provider = _to_int(self.get_setting("vless_provider", 0), 0)
        is_custom = (vless_provider == 3)
        sponsor_idx = min(vless_provider, 2) if not is_custom else -1

        if not is_custom and not self._vless_data.get("subs") and not self._vless_init_in_progress \
                and self.get_setting("_subs_loaded_for", -1) != vless_provider:
            self._vless_init_in_progress = True
            threading.Thread(target=self._init_default_vless_sub, args=(vless_provider,), daemon=True).start()

        items = [
            Selector(key="vless_provider", text=Z("vless_provider"),
                     default=0,
                     items=[PROVIDER_NAMES[i] for i in sorted(PROVIDER_NAMES)] + [Z("vless_prov_custom")],
                     icon="msg_channel", on_change=self._on_vless_provider_changed),
        ]

        try:
            if is_custom:
                pass
        except:
            pass

        if is_custom:
            items += [
                Input(key="vless_custom_key", text=Z("vless_add_key"),
                      default="",
                      icon="msg_link2",
                      on_change=self._on_vless_custom_key_input),
                Input(key="vless_custom_sub", text=Z("vless_add_sub"),
                      default="",
                      icon="msg_link",
                      on_change=self._on_vless_custom_sub_input),
            ]

        items += [
            Divider(),
            Header(text=Z("vless_nodes_header")),
        ]

        if not self._vless_data.get("manual") and not self._vless_data.get("subs"):
            items.append(Text(text=Z("vless_no_nodes")))
        else:
            if self._vless_data.get("manual"):
                for node in self._vless_data["manual"]:
                    is_act = (node["uri"] == active)
                    ping = node.get("ping", -1)
                    ping_str = f" — {ping}ms" if ping > 0 else ""
                    label = node["name"] + ping_str
                    items.append(Text(text=label, accent=bool(is_act),
                                      on_click=self._make_vless_node_select(node["uri"])))

            for sub in self._vless_data.get("subs", []):
                nodes = sub.get("nodes", [])
                if not nodes: continue
                items.append(Header(text=f"{sub['name']} ({len(nodes)})"))
                for node in nodes:
                    is_act = (node["uri"] == active)
                    ping = node.get("ping", -1)
                    ping_str = f" — {ping}ms" if ping > 0 else ""
                    label = node["name"] + ping_str
                    items.append(Text(text=label, accent=bool(is_act),
                                      on_click=self._make_vless_node_select(node["uri"])))

        if not is_custom:
            items += [
                Text(text=Z("referral_btn"),
                     icon="msg_link",
                     accent=True,
                     on_click=self._make_referral_click(sponsor_idx, "vless")),
                Divider(),
            ]
        items += [
            Text(text=Z("vless_nodes_manage"), icon="msg_settings_14",
                 on_click=lambda v: self._vless_open_nodes_menu()),
            Divider(),
        ]
        return items

    def _add_menu_items(self):
        def on_click(ctx):
            self._open_settings()

        try:
            self.remove_menu_item(self._chat_menu_item_id)
        except:
            pass

        try:
            self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                item_id=self._chat_menu_item_id,
                text=Z("menu_settings"),
                on_click=on_click,
                icon="msg_settings",
                priority=1,
            ))
        except:
            pass

        try:
            self.remove_menu_item(self._drawer_menu_item_id)
        except:
            pass

        try:
            self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                item_id=self._drawer_menu_item_id,
                text=Z("menu_settings"),
                on_click=on_click,
                icon="msg_settings",
                priority=1,
            ))
        except:
            pass

    def _remove_menu_items(self):
        try:
            self.remove_menu_item(self._chat_menu_item_id)
        except:
            pass
        try:
            self.remove_menu_item(self._drawer_menu_item_id)
        except:
            pass

    def _open_settings(self):
        try:
            PC = find_class("com.exteragram.messenger.plugins.PluginsController")
        except:
            PC = None
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
        except:
            PSA = None

        try:
            if PC:
                inst = None
                try:
                    inst = PC.getInstance()
                except:
                    inst = None
                if inst is not None and hasattr(inst, "plugins") and PSA:
                    plugin_obj = None
                    try:
                        plugin_obj = inst.plugins.get(self.id)
                    except:
                        plugin_obj = None
                    if plugin_obj is not None:
                        frag = get_last_fragment()
                        if frag is not None:
                            _log("open_settings: PluginSettingsActivity")
                            frag.presentFragment(PSA(plugin_obj))
                            return
                try:
                    _log("open_settings: PC.openPluginSettings(self.id)")
                    PC.openPluginSettings(self.id)
                    return
                except:
                    try:
                        _log("open_settings: PC.openPluginSettings('exitfy')")
                        PC.openPluginSettings("exitfy")
                        return
                    except:
                        pass
            frag = get_last_fragment()
            if frag and PC:
                _log("open_settings: PluginsController.getInstance().openPluginSettings")
                PC.getInstance().openPluginSettings(self.id, frag)
        except:
            pass

    def _on_mode_changed(self, v):
        mode = _to_int(v, _to_int(self.get_setting("mode", 1), 1))
        self._watchdog_stop.set()
        self._vless_disconnect(silent=True)
        _set_tg_proxy_enabled(False)
        if mode == 1:
            self._ping_stop.clear()
            threading.Thread(target=self._vless_pinger_loop, daemon=True).start()
            if not self._vless_data.get("subs") and not self._vless_init_in_progress:
                threading.Thread(target=self._init_default_vless_sub, daemon=True).start()
            if self.get_setting("vless_enabled", False) and self._vless_active_uri:
                threading.Thread(target=self._vless_connect, daemon=True).start()
        else:
            if self.get_setting("proxy_enabled", False):
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                _set_tg_proxy_enabled(True)
                self._watchdog_stop.clear()
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        self._reload_settings_ui()

    def _on_enabled_changed(self, v):
        enabled = bool(v)
        mode = _to_int(self.get_setting("mode", 1), 1)
        if mode == 1:
            if enabled:
                if self._vless_active_uri:
                    threading.Thread(target=self._vless_connect, daemon=True).start()
                else:
                    self.set_setting("vless_enabled", False, reload_settings=True)
            else:
                self._vless_disconnect()
        else:
            if enabled:
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                _set_tg_proxy_enabled(True)
                self._watchdog_stop.clear()
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
            else:
                self._watchdog_stop.set()
                _set_tg_proxy_enabled(False)

    def _on_provider_changed(self, v):
        self._proxy_links = []
        self._proxy_cycle_idx = 0
        if self.get_setting("proxy_enabled", False):
            threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()
        self._reload_settings_ui()

    def _on_vless_provider_changed(self, v):
        provider = int(v)
        self._vless_active_uri = ""
        if provider == 3:
            self._vless_data["manual"] = []
            self._vless_data["subs"] = []
            self._vless_save_data()
            if self._vless_running:
                self._vless_disconnect(silent=True)
            self._reload_settings_ui()
            return
        try:
            self.set_setting("vless_custom_sub_url", "")
            self._vless_custom_sub_url = ""
        except:
            pass
        self._vless_data["subs"] = []
        self._vless_data["manual"] = []
        self._vless_save_data()
        if self._vless_running:
            self._vless_disconnect(silent=True)
        threading.Thread(
            target=self._init_default_vless_sub, args=(provider,), daemon=True
        ).start()
        self._reload_settings_ui()

    def _on_vless_custom_key_input(self, v):
        uri = str(v or "").strip()
        self._vless_custom_key_buf = uri
        if uri.startswith("vless://") and "@" in uri and uri != self._last_custom_key_applied:
            self._last_custom_key_applied = uri
            self._apply_vless_custom_key()

    def _apply_vless_custom_key(self):
        uri = getattr(self, "_vless_custom_key_buf", "").strip()
        if not uri.startswith("vless://") or len(uri) < 20:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Неверный vless:// ключ")); return
        conf, name = VlessConfigParser.parse(uri, 1080)
        if not conf:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка парсинга ключа")); return
        manual = self._vless_data.get("manual", [])
        if not any(n["uri"] == uri for n in manual):
            manual.append({"name": name, "uri": uri, "ping": -1})
            self._vless_data["manual"] = manual
        self._vless_active_uri = uri
        self._vless_save_data()
        self._ping_event.set()
        try:
            self.set_setting("vless_enabled", True, reload_settings=True)
        except:
            pass
        threading.Thread(target=self._vless_connect, daemon=True).start()
        run_on_ui_thread(self._reload_settings_ui)

    def _on_vless_custom_sub_input(self, v):
        url = str(v or "").strip()
        self._vless_custom_sub_buf = url
        if url.startswith("http") and len(url) > 10 and url != self._last_custom_sub_applied:
            self._last_custom_sub_applied = url
            self._apply_vless_custom_sub()

    def _apply_vless_custom_sub(self):
        url = getattr(self, "_vless_custom_sub_buf", "").strip()
        if not url.startswith("http") or len(url) < 10:
            run_on_ui_thread(lambda: BulletinHelper.show_error(Z("vless_custom_sub_bad")))
            return
        try:
            self.set_setting("vless_custom_sub_url", url)
            self._vless_custom_sub_url = url
        except:
            pass
        threading.Thread(target=self._vless_do_add_sub, args=(url,), daemon=True).start()

    def _on_connect_try_changed(self, v):
        try:
            val = max(1, min(30, int(str(v).strip())))
            _pset_int("proxy_connect_try", val)
        except: pass

    def _on_stuck_changed(self, v):
        try:
            val = max(1, min(120, int(str(v).strip())))
            _pset_int("proxy_stuck_sec", val)
        except: pass

    def _on_cooldown_changed(self, v):
        try:
            val = max(0, min(120, int(str(v).strip())))
            _pset_int("proxy_cooldown_sec", val)
        except: pass

    def _on_auto_switch_changed(self, v):
        auto = bool(v)
        mode = _to_int(self.get_setting("mode", 1), 1)
        if mode != 0:
            self._reload_settings_ui()
            return
        if auto:
            self._watchdog_stop.clear()
            if self.get_setting("proxy_enabled", False):
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        else:
            self._watchdog_stop.set()
            if self.get_setting("proxy_enabled", False) and not self._proxy_links:
                threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()
        self._reload_settings_ui()

    def _on_manual_node_changed(self, v):
        try:
            idx = int(v)
            links = self._proxy_links or []
            if idx < 0 or idx >= len(links):
                return
            link = links[idx]
            info = _parse_link(link)
            if info:
                _pset_str("last_proxy_link", link)
                _apply_proxy_info(info)
                self._proxy_cycle_idx = idx
        except Exception as e:
            _log(f"manual node change error: {e}")

    def _reload_settings_ui(self):
        def _do():
            try:
                self.set_setting("__reload__", time.time(), reload_settings=True)
            except: pass
        run_on_ui_thread(_do, 100)

    def _proxy_refresh(self):
        threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()

    def _proxy_refresh_bg(self):
        provider = self.get_setting("proxy_provider", 0)
        links = _fetch_proxy_links(provider)
        if not links: return
        scored = _score_links(links)
        self._proxy_links = [l for _, l in scored]
        self._proxy_cycle_idx = 0
        if not self.get_setting("proxy_auto_switch", True):
            best_link = self._proxy_links[0] if self._proxy_links else None
            if best_link:
                info = _parse_link(best_link)
                if info:
                    _pset_str("last_proxy_link", best_link)
                    _apply_proxy_info(info)
            self._reload_settings_ui()
        else:
            best_link = self._proxy_links[0] if self._proxy_links else None
            if best_link:
                info = _parse_link(best_link)
                if info:
                    _pset_str("last_proxy_link", best_link)
                    _apply_proxy_info(info)

    def _open_tg_proxy_settings(self):
        try:
            frag = get_last_fragment()
            if frag:
                from org.telegram.ui import ProxyListActivity
                frag.presentFragment(ProxyListActivity())
        except: pass

    def _open_tg_link(self, url):
        try:
            url = str(url or "").strip()
            if not url: return
            _log(f"open link: {url}")
            try:
                frag = get_last_fragment()
                act = frag.getParentActivity() if frag else None
            except:
                act = None

            try:
                from org.telegram.messenger.browser import Browser
            except:
                Browser = None

            ctx = act if act else ApplicationLoader.applicationContext
            if Browser:
                _log(f"open link via Browser.openUrl (ctx={type(ctx)})")
                Browser.openUrl(ctx, url)
                return

            from android.content import Intent
            from android.net import Uri
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            if not act:
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            ctx.startActivity(intent)
        except:
            pass

    def _make_referral_click(self, provider_idx, source):
        def handler(v):
            try:
                url = REFERRAL.get(provider_idx, "")
                _log(f"referral click ({source}): idx={provider_idx} url={url}")
                self._open_tg_link(url)
            except Exception as e:
                _log(f"referral click error ({source}): {e}")
        return handler

    def _open_referral(self, provider_idx):
        try:
            url = REFERRAL.get(provider_idx, "")
            self._open_tg_link(url)
        except: pass

    def _make_proxy_sub_delete(self, url):
        def handler(v):
            if url in self._proxy_custom_urls:
                self._proxy_custom_urls.remove(url)
                _pset_str("proxy_custom_urls", json.dumps(self._proxy_custom_urls))
            self._reload_settings_ui()
        return handler

    def _watchdog_loop(self):
        connect_try = _pget_int("proxy_connect_try", 7)
        stuck_sec = _pget_int("proxy_stuck_sec", 8)
        cooldown_sec = _pget_int("proxy_cooldown_sec", 5)

        while not self._watchdog_stop.is_set():
            try:
                if not self.get_setting("proxy_enabled", False):
                    self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue
                if not self.get_setting("proxy_auto_switch", True):
                    self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue

                if not self._proxy_links:
                    provider = self.get_setting("proxy_provider", 0)
                    links = _fetch_proxy_links(provider)
                    if links:
                        scored = _score_links(links)
                        self._proxy_links = [l for _, l in scored]
                        self._proxy_cycle_idx = 0
                    else:
                        self._watchdog_stop.wait(10); continue

                connected = self._wait_connected(connect_try)
                if connected:
                    self._watchdog_stop.wait(stuck_sec)
                    if self._watchdog_stop.is_set(): break
                    still_ok = self._wait_connected(3)
                    if still_ok:
                        self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue

                self._switch_proxy()
                if cooldown_sec > 0:
                    self._watchdog_stop.wait(cooldown_sec)
            except:
                self._watchdog_stop.wait(CHECK_INTERVAL_SEC)

    def _wait_connected(self, timeout_sec):
        deadline = time.time() + timeout_sec
        while time.time() < deadline:
            try:
                state = int(ConnectionsManager.getInstance(0).getConnectionState())
                if state == 3:
                    return True
            except: pass
            time.sleep(0.5)
        return False

    def _switch_proxy(self):
        if not self._proxy_links: return
        if random.random() < RANDOM_PROXY_CHANCE:
            idx = random.randint(0, len(self._proxy_links) - 1)
        else:
            idx = self._proxy_cycle_idx % len(self._proxy_links)
            self._proxy_cycle_idx += 1

        link = self._proxy_links[idx]
        info = _parse_link(link)
        if info:
            _pset_str("last_proxy_link", link)
            _apply_proxy_info(info)

    def _vless_save_data(self):
        self._vless_data["active_uri"] = self._vless_active_uri
        self.set_setting("vless_data", self._vless_data)

    def _vless_connect(self):
        if not self._vless_active_uri: return
        self._vless_disconnect(silent=True)
        if not self._vless_core.is_available():
            self.set_setting("vless_enabled", False, reload_settings=True); return
        port = _get_free_port()
        self._vless_port = port
        config_json, _ = VlessConfigParser.parse(self._vless_active_uri, port)
        if not config_json:
            self.set_setting("vless_enabled", False, reload_settings=True); return
        _log(f"VLESS starting on port {port}")
        err = self._vless_core.start(config_json)
        if err:
            _log(f"VLESS core error: {err}")
            self.set_setting("vless_enabled", False, reload_settings=True); return

        def connection_watchdog():
            for _ in range(20):
                if _check_vless_port(port):
                    _log(f"VLESS port {port} ready, applying TG proxy")
                    _vless_apply_tg_proxy(port, True)
                    self._vless_running = True
                    try:
                        self.set_setting("vless_enabled", True, reload_settings=True)
                    except:
                        pass
                    run_on_ui_thread(self._reload_settings_ui)
                    return
                time.sleep(0.3)
            _log("VLESS port timeout")
            self.set_setting("vless_enabled", False, reload_settings=True)
            run_on_ui_thread(lambda: self._vless_disconnect(silent=True))
        threading.Thread(target=connection_watchdog, daemon=True).start()

    def _vless_disconnect(self, silent=False):
        self._vless_core.stop()
        self._vless_running = False
        _vless_apply_tg_proxy(0, False)
        if not silent:
            self._reload_settings_ui()

    def _make_vless_node_select(self, uri):
        def handler(v):
            prev = self._vless_active_uri
            self._vless_active_uri = uri
            self._vless_save_data()
            if prev == uri and self._vless_running:
                try:
                    self.set_setting("vless_enabled", False, reload_settings=True)
                except:
                    pass
                self._vless_disconnect()
            else:
                try:
                    self.set_setting("vless_enabled", True, reload_settings=True)
                except:
                    pass
                threading.Thread(target=self._vless_connect, daemon=True).start()
            self._reload_settings_ui()
        return handler

    def _vless_open_nodes_menu(self):
        frag = get_last_fragment()
        if not frag: return
        builder = AlertDialogBuilder(frag.getParentActivity())
        items = [Z("vless_nodes_update"), Z("vless_nodes_clear")]

        cancel_text = Z("btn_cancel")
        builder.set_negative_button(cancel_text)

        def on_item(dlg, which):
            try:
                if int(which) == 0:
                    threading.Thread(target=self._vless_update_all_subs, daemon=True).start()
                elif int(which) == 1:
                    self._vless_clear_user_nodes()
            except Exception as e:
                _log(f"nodes menu error: {e}")

        builder.set_title(Z("vless_nodes_manage"))
        builder.set_items(items, on_item)
        builder.set_negative_button(cancel_text, lambda d, w: d.dismiss())
        builder.show()

    def _vless_update_all_subs(self):
        urls = [s.get("url", "") for s in self._vless_data.get("subs", []) if s.get("url")]
        try:
            if _to_int(self.get_setting("vless_provider", 0), 0) == 3:
                u = str(self.get_setting("vless_custom_sub_url", "") or "").strip()
                if u and u not in urls:
                    urls.insert(0, u)
        except:
            pass
        for url in urls:
            self._vless_update_sub(url)

    def _vless_clear_user_nodes(self):
        self._vless_data["manual"] = []
        self._vless_data["subs"] = []
        if self._vless_active_uri:
            self._vless_active_uri = ""
            self._vless_disconnect(silent=True)
        self._vless_save_data()
        self._reload_settings_ui()

    def _vless_do_add_sub(self, url):
        if not url.startswith("http"): return
        nodes = _fetch_vless_nodes(url)
        if not nodes:
            def _notify():
                try:
                    try:
                        r = requests.get(url, timeout=15)
                        t = (r.text or "").strip()
                    except:
                        t = ""
                    low = t.lower()
                    if "приложение не поддерживается" in low or "not supported" in low:
                        BulletinHelper.show_error(Z("vless_app_not_supported"))
                    else:
                        BulletinHelper.show_error(Z("vless_custom_sub_empty"))
                except:
                    BulletinHelper.show_error(Z("vless_custom_sub_empty"))

            run_on_ui_thread(_notify)
            return
        if nodes:
            if "subs" not in self._vless_data: self._vless_data["subs"] = []
            existing = [s["url"] for s in self._vless_data["subs"]]
            if url not in existing:
                self._vless_data["subs"].append({
                    "id": url,
                    "url": url,
                    "name": urllib.parse.urlparse(url).netloc,
                    "nodes": nodes
                })
            self._vless_save_data()
            self._ping_event.set()
            run_on_ui_thread(self._reload_settings_ui)

    def _vless_update_sub(self, url):
        provider = _to_int(self.get_setting("vless_provider", 0), 0)
        nodes = _fetch_vless_nodes(url)
        changed = False
        for sub in self._vless_data.get("subs", []):
            if sub["url"] == url and nodes:
                sub["nodes"] = nodes
                changed = True
        if not changed and provider == 3 and nodes:
            try:
                if "subs" not in self._vless_data:
                    self._vless_data["subs"] = []
                existing = [s.get("url", "") for s in self._vless_data.get("subs", [])]
                if url not in existing:
                    self._vless_data["subs"].append({
                        "id": url,
                        "url": url,
                        "name": urllib.parse.urlparse(url).netloc,
                        "nodes": nodes
                    })
                    changed = True
            except:
                pass
        if changed:
            self._vless_save_data()
            self._ping_event.set()
            run_on_ui_thread(self._reload_settings_ui)

    def _vless_pinger_loop(self):
        while not self._ping_stop.is_set():
            self._ping_event.clear()
            try:
                all_nodes = list(self._vless_data.get("manual", []))
                for sub in self._vless_data.get("subs", []):
                    all_nodes.extend(sub.get("nodes", []))
                if not all_nodes:
                    self._ping_event.wait(600); continue
                changed = False
                for node in all_nodes:
                    if self._ping_stop.is_set(): break
                    try:
                        part = node["uri"].replace("vless://", "")
                        if "@" not in part: continue
                        host_port = part.split("@", 1)[1].split("?", 1)[0].split("#", 1)[0]
                        host, port = host_port.split(":", 1)
                        start = time.time()
                        s = socket.create_connection((host, int(port)), timeout=1.5)
                        p = int((time.time() - start) * 1000); s.close()
                        if node.get("ping") != p: node["ping"] = p; changed = True
                    except:
                        if node.get("ping") != 9999: node["ping"] = 9999; changed = True
                if changed: self._vless_save_data()
            except: pass
            self._ping_event.wait(600)
