import threading
import time
import socket
import random
import re
from html import unescape
from typing import Optional, List, Tuple
import requests
from java.util import Locale
from base_plugin import BasePlugin, AppEvent, MethodHook, MenuItemData, MenuItemType
from hook_utils import find_class
from android_utils import run_on_ui_thread
from ui.settings import Header, Switch, Selector, Text, Divider, Input
from org.telegram.messenger import (
    ApplicationLoader,
    MessagesController,
    NotificationCenter,
    SharedConfig,
    UserConfig,
)
from org.telegram.tgnet import ConnectionsManager
from org.telegram.ui import LaunchActivity

__id__ = "exitfy"
__name__ = "exitFy"
__description__ = "Application download speed optimization"
__icon__ = "exitFy/0"
__author__ = "@exteraPluginsSup"
__version__ = "1.1.1"
__min_version__ = "12.1.1"

API_URLS = {
    0: ["https://exitfy.ishrimp.xyz/proxy/latest"],
    1: ["https://exitfy.vpnetproxy.xyz/proxy/latest"],
    2: ["https://a.stemstep.cloud/proxy/socks"],
}

PROVIDER_NAMES = {
    0: "Shrimp",
    1: "VPNET",
    2: "Sworkle",
}

SPONSOR_TEXT = {
    0: ("Спонсор: @invisibleshrimp", "Sponsor: @invisibleshrimp"),
    1: ("Спонсор: @vpnetvpn", "Sponsor: @vpnetvpn"),
    2: ("Спонсор: @sworklevpnbot", "Sponsor: @sworklevpnbot"),
}

TRANSLATIONS = {
    "settings_header": ("Настройки", "Settings"),
    "show_settings_buttons": ("Кнопка настроек в меню", "Settings button in menu"),
    "enable_plugin": ("Включить плагин", "Enable plugin"),
    "select_provider": ("Выбрать провайдера", "Select provider"),
    "auto_switch": ("Автопереключение", "Auto switch"),
    "refresh": ("Обновить", "Refresh"),
    "open_tg_settings": ("Открыть настройки Telegram", "Open Telegram settings"),
    "menu_settings": ("Настройки exitFy", "exitFy settings"),
    "node": ("Сервер", "Server"),
    "connect_try": ("Ожидание подключения", "Connect wait"),
    "connect_try_desc": ("Значение: 1-30 (сек). По умолчанию: 7", "Value: 1-30 (sec). Default: 7"),
    "stuck": ("Порог зависания", "Stuck threshold"),
    "stuck_desc": ("Значение: 1-120 (сек). По умолчанию: 8", "Value: 1-120 (sec). Default: 8"),
    "cooldown": ("Кулдаун переключения", "Cooldown"),
    "cooldown_desc": ("Значение: 0-120 (сек). По умолчанию: 5", "Value: 0-120 (sec). Default: 5"),
}


def Z(key: str):
    lang = Locale.getDefault().getLanguage()
    idx = 0 if str(lang).startswith("ru") else 1
    try:
        v = TRANSLATIONS.get(key, (key, key))
        return str(v[idx])
    except:
        try:
            return str(key)
        except:
            return ""

CHECK_INTERVAL_SEC = 5
CONNECT_TRY_SEC = 7
RANDOM_PROXY_CHANCE = 0.15

def _prefs():
    ctx = ApplicationLoader.applicationContext
    return ctx.getSharedPreferences("exitfy_prefs", 0)


def _get_selected_type() -> int:
    try:
        return int(_prefs().getInt("selected_type", 0))
    except:
        return 0


def _set_selected_type(t: int):
    try:
        ed = _prefs().edit()
        ed.putInt("selected_type", int(t))
        ed.commit()
    except:
        pass


def _get_last_fragment():
    try:
        return LaunchActivity.getSafeLastFragment()
    except:
        return None


def _force_show_dialogs_proxy_button(da) -> None:
    try:
        if da is None:
            return
        cls = None
        try:
            cls = da.getClass()
        except:
            cls = None

        from android.view import View

        proxy_item = None
        if cls is not None:
            try:
                f = cls.getDeclaredField("proxyItem")
                f.setAccessible(True)
                proxy_item = f.get(da)
            except:
                proxy_item = None
        if proxy_item is not None:
            try:
                proxy_item.setVisibility(View.VISIBLE)
            except:
                pass

        proxy_sub_item = None
        if cls is not None:
            try:
                f = cls.getDeclaredField("proxyMenuSubItem")
                f.setAccessible(True)
                proxy_sub_item = f.get(da)
            except:
                proxy_sub_item = None
        if proxy_sub_item is not None:
            try:
                proxy_sub_item.setVisibility(View.VISIBLE)
            except:
                pass

        if cls is not None:
            try:
                vf = cls.getDeclaredField("proxyItemVisible")
                vf.setAccessible(True)
                try:
                    vf.setBoolean(da, True)
                except:
                    try:
                        vf.set(da, True)
                    except:
                        pass
            except:
                pass

        proxy_drawable = None
        if cls is not None:
            try:
                df = cls.getDeclaredField("proxyDrawable")
                df.setAccessible(True)
                proxy_drawable = df.get(da)
            except:
                proxy_drawable = None

        if proxy_drawable is not None:
            state = None
            if cls is not None:
                try:
                    sf = cls.getDeclaredField("currentConnectionState")
                    sf.setAccessible(True)
                    state = sf.getInt(da)
                except:
                    state = None

            try:
                proxy_enabled = bool(_tg_proxy_enabled())
            except:
                proxy_enabled = False

            connected = False
            try:
                connected = state == ConnectionsManager.ConnectionStateConnected or state == ConnectionsManager.ConnectionStateUpdating
            except:
                connected = False

            try:
                proxy_drawable.setConnected(proxy_enabled, bool(connected), False)
            except:
                pass
    except:
        pass


def _tg_proxy_enabled() -> bool:
    try:
        return bool(MessagesController.getGlobalMainSettings().getBoolean("proxy_enabled", False))
    except:
        return False


def _set_tg_proxy_enabled(enabled: bool):
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putBoolean("proxy_enabled", bool(enabled))
        ed.commit()
    except:
        pass
    try:
        SharedConfig.proxyEnabled = bool(enabled)
        SharedConfig.saveConfig()
    except:
        pass
    try:
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm is not None:
                    if bool(enabled) and SharedConfig.currentProxy is not None:
                        p = SharedConfig.currentProxy
                        cm.setProxySettings(True, str(p.address), int(p.port), str(p.username or ""), str(p.password or ""), str(p.secret or ""))
                    else:
                        cm.setProxySettings(False, "", 0, "", "", "")
            except:
                pass
    except:
        pass
    try:
        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
    except:
        pass


def _get_last_applied_link() -> str:
    try:
        return str(_prefs().getString("last_applied_link", "") or "")
    except:
        return ""


def _set_last_applied_link(link: str):
    try:
        ed = _prefs().edit()
        ed.putString("last_applied_link", str(link or ""))
        ed.commit()
    except:
        pass


def _get_last_check_ts() -> int:
    try:
        return int(_prefs().getLong("last_check_ts", 0))
    except:
        return 0


def _set_last_check_ts(ts: int):
    try:
        ed = _prefs().edit()
        ed.putLong("last_check_ts", int(ts))
        ed.commit()
    except:
        pass


def _normalize_proxy_link(s: str) -> str:
    try:
        s = str(s or "")
    except:
        return ""
    try:
        s = unescape(s)
    except:
        pass
    try:
        s = s.replace("\\/", "/")
    except:
        pass
    try:
        s = s.replace("tg:/\/\/", "tg://")
    except:
        pass
    s = s.strip()
    if not s:
        return ""
    try:
        s = re.sub(r"[\s\)\]>,\.;]+$", "", s)
    except:
        pass
    try:
        s = re.sub(r"^[\s\(\[<]+", "", s)
    except:
        pass
    return s.strip()


def _parse_proxy_link(link: str) -> Optional[SharedConfig.ProxyInfo]:
    try:
        if not isinstance(link, str):
            return None
        link = _normalize_proxy_link(link)
        if not link:
            return None

        from urllib.parse import urlparse, parse_qs
        if "tg://" not in link and "t.me/" not in link:
            return None

        parsed = urlparse(link)
        q = parse_qs(parsed.query)

        server = (q.get("server") or [""])[0]
        port_s = (q.get("port") or [""])[0]
        user = (q.get("user") or [""])[0]
        password = (q.get("pass") or [""])[0]
        secret = (q.get("secret") or [""])[0]

        if not server or not port_s:
            return None

        try:
            port = int(port_s)
        except:
            return None

        return SharedConfig.ProxyInfo(server, port, user, password, secret)
    except:
        return None


def _apply_proxy_info(info: SharedConfig.ProxyInfo):
    if info is None:
        return
    SharedConfig.loadProxyList()

    enabled_now = False
    try:
        enabled_now = bool(_tg_proxy_enabled())
    except:
        enabled_now = False

    def _is_exitfy_host(host: str) -> bool:
        try:
            h = str(host or "").lower()
        except:
            return False
        if not h:
            return False
        try:
            if h.startswith("exitfy-"):
                return True
        except:
            pass
        try:
            if "ishrimp.xyz" in h or "vpnet" in h or "sworkle" in h or "stemstep" in h:
                return True
        except:
            pass
        return False

    def _is_exitfy_proxy(p) -> bool:
        try:
            return _is_exitfy_host(str(p.address or ""))
        except:
            return False

    def _get_exitfy_proxy_from_list():
        try:
            if hasattr(SharedConfig, "proxyList") and SharedConfig.proxyList is not None:
                for i in range(0, int(SharedConfig.proxyList.size())):
                    try:
                        p = SharedConfig.proxyList.get(i)
                    except:
                        continue
                    if _is_exitfy_proxy(p):
                        return p
        except:
            pass
        return None

    added = None
    try:
        existing = _get_exitfy_proxy_from_list()
    except:
        existing = None

    if existing is not None:
        ok = False
        try:
            existing.address = str(info.address)
            existing.port = int(info.port)
            existing.username = str(info.username or "")
            existing.password = str(info.password or "")
            existing.secret = str(info.secret or "")
            ok = True
        except:
            ok = False
        if ok:
            added = existing

    if added is None:
        try:
            added = SharedConfig.addProxy(str(info.address), int(info.port), str(info.username or ""), str(info.password or ""), str(info.secret or ""))
        except:
            added = info

    try:
        SharedConfig.currentProxy = added
    except:
        pass

    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putString("proxy_ip", added.address)
        ed.putString("proxy_user", added.username)
        ed.putString("proxy_pass", added.password)
        ed.putInt("proxy_port", int(added.port))
        ed.putString("proxy_secret", added.secret)
        ed.putBoolean("proxy_enabled", bool(enabled_now))
        if added.secret and len(added.secret) > 0:
            ed.putBoolean("proxy_enabled_calls", False)
        else:
            ed.putBoolean("proxy_enabled_calls", True)
        ed.apply()
    except:
        pass

    try:
        if bool(enabled_now):
            ConnectionsManager.setProxySettings(True, added.address, int(added.port), added.username, added.password, added.secret)
        else:
            ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
    except:
        pass

    try:
        def _notify_proxy_changed():
            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except:
                pass

        run_on_ui_thread(_notify_proxy_changed, 350)
    except:
        pass


def _fetch_links(proxy_type: int) -> List[str]:
    urls = API_URLS.get(proxy_type) or []
    out: List[str] = []
    for url in urls:
        try:
            r = requests.get(url, timeout=10)
            if r.status_code != 200:
                continue
            text = (r.text or "").strip()
            if not text:
                continue
            for line in str(text).splitlines():
                s = (line or "").strip()
                if not s:
                    continue
                try:
                    found = re.findall(r"(tg://[^\s\"']+)", s)
                except:
                    found = []
                if found:
                    out.extend([_normalize_proxy_link(x) for x in found if _normalize_proxy_link(x)])
                    continue
                try:
                    found = re.findall(r"(https?://t\.me/[^\s\"']+)", s)
                except:
                    found = []
                if found:
                    out.extend([_normalize_proxy_link(x) for x in found if _normalize_proxy_link(x)])
                    continue
                if "tg://" in s or "t.me/" in s:
                    ns = _normalize_proxy_link(s)
                    if ns:
                        out.append(ns)
            if out:
                return out
        except:
            continue

    return out


def _proxy_link_latency(link: str) -> Optional[float]:
    if not link:
        return None
    try:
        info = _parse_proxy_link(str(link))
    except:
        info = None
    if info is None:
        return None

    host = None
    port = None
    try:
        host = str(info.address)
        port = int(info.port)
    except:
        host = None
        port = None

    if not host or not port:
        return None

    s = None
    try:
        start = time.monotonic()
        s = socket.create_connection((host, port), timeout=3)
        return float(time.monotonic() - start)
    except:
        return None
    finally:
        try:
            if s is not None:
                s.close()
        except:
            pass


def _pick_best_proxy_link(links: List[str]) -> Tuple[Optional[str], Optional[float]]:
    best_link = None
    best_dt = None
    for link in links or []:
        try:
            dt = _proxy_link_latency(link)
        except:
            dt = None
        if dt is None:
            continue
        if best_dt is None or dt < best_dt:
            best_dt = dt
            best_link = link
    return best_link, best_dt


def _score_links(proxy_type: int, links: List[str]) -> List[Tuple[float, str]]:
    scored: List[Tuple[float, str]] = []
    for l in links or []:
        try:
            nl = _normalize_proxy_link(l)
        except:
            nl = ""
        if not nl:
            continue
        try:
            if _parse_proxy_link(str(nl)) is None:
                continue
        except:
            continue
        try:
            dt = _proxy_link_latency(str(nl))
        except:
            dt = None
        if dt is None:
            scored.append((9999.0, str(nl)))
        else:
            scored.append((float(dt), str(nl)))
    scored.sort(key=lambda x: x[0])
    return scored


def _score_links_with_wl_fallback(proxy_type: int, links: List[str]) -> List[Tuple[float, str]]:
    try:
        pt = int(proxy_type)
    except:
        pt = proxy_type

    if pt == 0 and links:
        primary: List[str] = []
        wl: List[str] = []

        for l in links or []:
            nl = _normalize_proxy_link(l)
            if not nl:
                continue
            host = ""
            try:
                info = _parse_proxy_link(str(nl))
                if info is not None:
                    host = str(info.address or "").lower()
            except:
                host = ""

            is_wl = False
            try:
                if ".wl." in host or "-wl." in host or host.startswith("wl.") or host.endswith(".wl"):
                    is_wl = True
                else:
                    tokens = re.split(r"[\.-]", host)
                    if "wl" in tokens:
                        is_wl = True
            except:
                is_wl = False

            if is_wl:
                wl.append(str(nl))
            else:
                primary.append(str(nl))

        scored = _score_links(pt, primary)
        if scored:
            return scored
        return _score_links(pt, wl)

    return _score_links(pt, links)


def _measure_provider_latency(proxy_type: int) -> Optional[float]:
    try:
        links = _fetch_links(int(proxy_type))
    except:
        links = []
    if not links:
        return None
    try:
        _, best_dt = _pick_best_proxy_link(links)
        return best_dt
    except:
        return None


class ForceDialogsProxyButtonHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _DialogsShowSearchForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _DialogsShowDoneItemForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            da = param.thisObject
            _force_show_dialogs_proxy_button(da)
        except:
            pass


class _ProxySettingsChangedNotifyHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def after_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            if not param.args or len(param.args) < 1:
                return
            try:
                event_id = int(param.args[0])
            except:
                return

            try:
                proxy_changed_id = int(NotificationCenter.proxySettingsChanged)
            except:
                proxy_changed_id = -1

            if event_id != proxy_changed_id:
                return
        except:
            pass


class _DialogsPresentFragmentRedirectHook(MethodHook):
    def __init__(self, plugin):
        self.p = plugin

    def before_hooked_method(self, param):
        try:
            if not self.p._active:
                return
            if self.p._allow_open_tg_proxy_screen:
                return
            if not param.args or len(param.args) < 1:
                return
            frag_to_present = param.args[0]
            if frag_to_present is None:
                return
            ProxyListActivity = find_class("org.telegram.ui.ProxyListActivity")
            if ProxyListActivity and isinstance(frag_to_present, ProxyListActivity):
                try:
                    PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                    if PC:
                        PC.openPluginSettings("exitfy")
                except:
                    pass
                try:
                    param.setResult(False)
                except:
                    pass
        except:
            pass


class ExitfyPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._refresh_lock = threading.Lock()
        self._watchdog_token = 0
        self._active = False
        self._hooks_installed = False
        self._sync_hooks_installed = False
        self._allow_open_tg_proxy_screen = False
        self._last_connected_ts = 0
        self._auto_monitor_started = False
        self._last_auto_switch_ts = 0
        self._switch_cycle_lock = threading.Lock()
        self._chat_menu_item_id = "exitfy_proxy_open"
        self._drawer_menu_item_id = "exitfy_proxy_open_drawer"

    def _set_settings_menu_items_visible(self, visible: bool):
        try:
            if bool(visible):
                self.add_menu_item(
                    MenuItemData(
                        menu_type=MenuItemType.CHAT_ACTION_MENU,
                        item_id=self._chat_menu_item_id,
                        text=Z("menu_settings"),
                        icon="msg_settings",
                        priority=1,
                        on_click=self._open_plugin_settings,
                    )
                )
            else:
                self.remove_menu_item(self._chat_menu_item_id)
        except:
            pass

        try:
            if bool(visible):
                self.add_menu_item(
                    MenuItemData(
                        menu_type=MenuItemType.DRAWER_MENU,
                        item_id=self._drawer_menu_item_id,
                        text=Z("menu_settings"),
                        icon="msg_settings",
                        priority=1,
                        on_click=self._open_plugin_settings,
                    )
                )
            else:
                self.remove_menu_item(self._drawer_menu_item_id)
        except:
            pass

    def on_plugin_load(self):
        self._active = True

        try:
            self._last_connected_ts = int(time.time())
        except:
            self._last_connected_ts = 0

        try:
            first_done = bool(_prefs().getBoolean("first_auto_enable_done", False))
            if not first_done:
                try:
                    self.set_setting("plugin_enabled", True, reload_settings=False)
                except:
                    pass
                try:
                    ed = _prefs().edit()
                    ed.putBoolean("first_auto_enable_done", True)
                    ed.commit()
                except:
                    pass
        except:
            pass

        try:
            if bool(self.get_setting("plugin_enabled", True)):
                _set_tg_proxy_enabled(True)
            else:
                _set_tg_proxy_enabled(False)
        except:
            pass

        try:
            show_btn = bool(self.get_setting("show_settings_buttons", True))
        except:
            show_btn = True
        try:
            self._set_settings_menu_items_visible(bool(show_btn))
        except:
            pass

        self._install_redirect_hooks()
        self._install_sync_hooks()
        self._start_auto_monitor()
        try:
            auto_switch = bool(self.get_setting("auto_switch", True))
        except:
            auto_switch = True
        if auto_switch:
            self._select_best_provider_and_refresh(manual=True)
        else:
            self.refresh_proxy(manual=True)

    def on_plugin_unload(self):
        self._active = False

    def _is_connected_state(self, state: Optional[int]) -> bool:
        try:
            return state == ConnectionsManager.ConnectionStateConnected or state == ConnectionsManager.ConnectionStateUpdating
        except:
            return False

    def _is_bad_state(self, state: Optional[int]) -> bool:
        try:
            return state == ConnectionsManager.ConnectionStateConnecting or state == ConnectionsManager.ConnectionStateConnectingToProxy
        except:
            return False

    def _should_auto_switch_now(self) -> bool:
        try:
            if not bool(self._active):
                return False
        except:
            return False

        try:
            if not bool(self.get_setting("auto_switch", True)):
                return False
        except:
            return False

        try:
            if not bool(_tg_proxy_enabled()):
                return False
        except:
            return False

        state = None
        try:
            state = self._get_any_connection_state()
        except:
            state = None

        now = 0
        try:
            now = int(time.time())
        except:
            now = 0

        if self._is_connected_state(state):
            try:
                self._last_connected_ts = int(now)
            except:
                pass
            return False

        bad = False
        try:
            bad = bool(self._is_bad_state(state))
        except:
            bad = False
        if not bad:
            return False

        try:
            stuck_sec = int(self.get_setting("stuck_sec", 8))
        except:
            stuck_sec = 8
        try:
            if int(now) - int(self._last_connected_ts) < int(stuck_sec):
                return False
        except:
            return False

        try:
            cooldown = int(self.get_setting("cooldown_sec", 5))
        except:
            cooldown = 5
        try:
            if int(now) - int(self._last_auto_switch_ts) < int(cooldown):
                return False
        except:
            pass

        return True

    def _try_next_proxy_in_current_provider(self) -> bool:
        try:
            t = int(_get_selected_type())
        except:
            t = 0
        prev = _get_last_applied_link()
        links = []
        try:
            links = _fetch_links(int(t))
        except:
            links = []
        if not links:
            return False

        try:
            scored = _score_links_with_wl_fallback(int(t), list(links))
        except:
            scored = []
        if not scored:
            return False

        ordered_links = [str(x[1]) for x in scored]
        next_link = None
        for l in ordered_links:
            try:
                if prev and str(l) == str(prev):
                    continue
            except:
                pass
            next_link = str(l)
            break
        if not next_link:
            return False

        def apply_on_ui():
            self._apply_proxy_link(str(next_link))
            try:
                self._start_connect_watchdog(list(ordered_links or []), str(next_link))
            except:
                pass

        try:
            run_on_ui_thread(apply_on_ui)
        except:
            try:
                apply_on_ui()
            except:
                pass
        return True

    def _start_auto_monitor(self):
        try:
            if bool(self._auto_monitor_started):
                return
        except:
            pass

        try:
            self._auto_monitor_started = True
        except:
            pass

        def job():
            while True:
                try:
                    if not bool(self._active):
                        return
                except:
                    return

                try:
                    if self._should_auto_switch_now():
                        try:
                            self._last_auto_switch_ts = int(time.time())
                        except:
                            pass
                        try:
                            self._start_switch_cycle()
                        except:
                            pass
                except:
                    pass

                try:
                    time.sleep(5)
                except:
                    return

        threading.Thread(target=job, daemon=True).start()

    def create_settings(self):
        enabled = True
        try:
            enabled = bool(self.get_setting("plugin_enabled", True))
        except:
            enabled = True

        tg_state = False
        try:
            tg_state = bool(_tg_proxy_enabled())
        except:
            tg_state = False
        try:
            t = int(self.get_setting("provider", _get_selected_type()))
        except:
            t = _get_selected_type()
        if t != _get_selected_type():
            try:
                _set_selected_type(t)
            except:
                pass
        sponsor = ""
        try:
            lang = Locale.getDefault().getLanguage()
            idx = 0 if str(lang).startswith("ru") else 1
            sponsor = str((SPONSOR_TEXT.get(t) or ("", ""))[idx])
        except:
            sponsor = ""
        try:
            auto_switch = bool(self.get_setting("auto_switch", True))
        except:
            auto_switch = True

        try:
            connect_try = int(self.get_setting("connect_try_sec", CONNECT_TRY_SEC))
        except:
            connect_try = CONNECT_TRY_SEC
        try:
            stuck_sec = int(self.get_setting("stuck_sec", 8))
        except:
            stuck_sec = 8
        try:
            cooldown = int(self.get_setting("cooldown_sec", 5))
        except:
            cooldown = 5

        manual_nodes: List[str] = []
        links = []
        try:
            if not bool(auto_switch):
                links = _fetch_links(int(t))
        except:
            links = []
        if links:
            for l in links:
                info = None
                try:
                    info = _parse_proxy_link(str(l))
                except:
                    info = None
                if info is None:
                    continue
                host = ""
                try:
                    host = str(info.address or "")
                except:
                    host = ""
                if not host:
                    continue
                node = host.split(".")[0]
                if node and node not in manual_nodes:
                    manual_nodes.append(node)
        manual_nodes.sort()

        try:
            manual_idx = int(self.get_setting("manual_node_idx", 0))
        except:
            manual_idx = 0
        if manual_idx < 0:
            manual_idx = 0
        if manual_nodes and manual_idx >= len(manual_nodes):
            manual_idx = len(manual_nodes) - 1

        out = [
            Header(text=Z("settings_header")),
            Switch(
                key="plugin_enabled",
                text=Z("enable_plugin"),
                default=bool(enabled),
                subtext=None,
                icon="msg_policy",
                on_change=self._on_tg_proxy_enabled_changed,
            ),
            Selector(
                key="provider",
                text=Z("select_provider"),
                default=int(t),
                items=[PROVIDER_NAMES.get(0, "Shrimp"), PROVIDER_NAMES.get(1, "VPNET"), PROVIDER_NAMES.get(2, "Sworkle")],
                icon="msg_list",
                on_change=self._on_provider_changed,
            ),
        ]

        if not bool(auto_switch):
            out.append(
                Selector(
                    key="manual_node_idx",
                    text=Z("node"),
                    default=int(manual_idx),
                    items=(manual_nodes if manual_nodes else ["-"]),
                    icon="msg_instant_link",
                    on_change=(lambda idx: self._on_manual_node_changed(int(idx), manual_nodes, links)),
                )
            )

        out.append(Divider(text=sponsor))
        out.append(
            Switch(
                key="auto_switch",
                text=Z("auto_switch"),
                default=bool(auto_switch),
                subtext=None,
                icon="media_flip",
                on_change=self._on_auto_switch_changed,
            )
        )

        if bool(auto_switch):
            out.extend(
                [
                    Input(
                        key="connect_try_sec",
                        text=Z("connect_try"),
                        icon="msg_autodelete",
                        default=str(int(connect_try)),
                        subtext=Z("connect_try_desc"),
                    ),
                    Input(
                        key="stuck_sec",
                        text=Z("stuck"),
                        icon="msg_contacts_time",
                        default=str(int(stuck_sec)),
                        subtext=Z("stuck_desc"),
                    ),
                    Input(
                        key="cooldown_sec",
                        text=Z("cooldown"),
                        icon="msg_recent",
                        default=str(int(cooldown)),
                        subtext=Z("cooldown_desc"),
                    ),
                ]
            )

        out.extend(
            [
                Text(text=Z("refresh"), icon="msg_download", accent=True, on_click=lambda v: self.refresh_proxy(manual=True)),
                Divider(),
                Switch(
                    key="show_settings_buttons",
                    text=Z("show_settings_buttons"),
                    default=bool(self.get_setting("show_settings_buttons", True)),
                    icon="msg_settings",
                    on_change=self._on_show_settings_buttons_changed,
                ),
                Divider(),
                Text(text=Z("open_tg_settings"), icon="msg_settings", on_click=lambda v: self._open_tg_proxy_screen()),
            ]
        )

        return out

    def _on_show_settings_buttons_changed(self, v: bool):
        try:
            self.set_setting("show_settings_buttons", bool(v), reload_settings=False)
        except:
            pass
        try:
            self._set_settings_menu_items_visible(bool(v))
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _get_any_connection_state(self) -> Optional[int]:
        try:
            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    cm = ConnectionsManager.getInstance(ac)
                    if cm is None:
                        continue
                    return int(cm.getConnectionState())
                except:
                    continue
        except:
            pass
        return None

    def _apply_proxy_link(self, link: str):
        try:
            info = _parse_proxy_link(str(link))
        except:
            info = None
        if not info:
            return
        try:
            _apply_proxy_info(info)
        except:
            pass
        try:
            _set_last_applied_link(str(link))
        except:
            pass

    def _start_connect_watchdog(self, ordered_links: List[str], applied_link: str):
        try:
            self._watchdog_token = int(self._watchdog_token) + 1
            token = int(self._watchdog_token)
        except:
            token = 0

        def job():
            try:
                time.sleep(5)
            except:
                return

            try:
                if not self._active:
                    return
            except:
                return

            try:
                if int(self._watchdog_token) != int(token):
                    return
            except:
                return

            try:
                if not bool(_tg_proxy_enabled()):
                    return
            except:
                return

            state = None
            try:
                state = self._get_any_connection_state()
            except:
                state = None

            bad = False
            try:
                bad = state == ConnectionsManager.ConnectionStateConnecting or state == ConnectionsManager.ConnectionStateConnectingToProxy
            except:
                bad = False
            if not bad:
                return

            next_link = None
            try:
                for l in ordered_links or []:
                    if str(l) == str(applied_link):
                        continue
                    next_link = l
                    break
            except:
                next_link = None

            if not next_link:
                return

            try:
                run_on_ui_thread(lambda: self._apply_proxy_link(str(next_link)))
            except:
                try:
                    self._apply_proxy_link(str(next_link))
                except:
                    pass

        threading.Thread(target=job, daemon=True).start()

    def _select_best_provider_and_refresh(self, manual: bool = False):
        def job():
            if not manual:
                try:
                    now = int(time.time())
                    last = _get_last_check_ts()
                    if now - last < CHECK_INTERVAL_SEC:
                        return
                except:
                    pass

            try:
                providers = list((API_URLS or {}).keys())
            except:
                providers = []

            if not providers:
                self.refresh_proxy(manual=True)
                return

            prev_t = None
            try:
                prev_t = int(_get_selected_type())
            except:
                prev_t = None

            results = {}
            lock = threading.Lock()

            def _worker(pt: int):
                try:
                    links = _fetch_links(int(pt))
                except:
                    links = []
                if not links:
                    r = (None, None, [])
                else:
                    scored = _score_links_with_wl_fallback(int(pt), list(links))
                    if not scored:
                        r = (None, None, [])
                    else:
                        best_dt = float(scored[0][0])
                        best_link = str(scored[0][1]).strip()
                        ordered = [str(x[1]) for x in scored]
                        r = (best_dt, best_link, ordered)
                try:
                    lock.acquire()
                    results[int(pt)] = r
                except:
                    pass
                finally:
                    try:
                        lock.release()
                    except:
                        pass

            threads = []
            for t in providers:
                try:
                    th = threading.Thread(target=_worker, args=(int(t),), daemon=True)
                    threads.append(th)
                    th.start()
                except:
                    continue

            deadline = time.time() + 7
            for th in threads:
                try:
                    remain = float(deadline - time.time())
                    if remain <= 0:
                        break
                    th.join(timeout=remain)
                except:
                    pass

            best_t = None
            best_dt = None
            best_link = None
            best_ordered = []
            for t in providers:
                try:
                    dt, link, ordered = results.get(int(t), (None, None, []))
                except:
                    dt, link, ordered = (None, None, [])
                if dt is None or link is None:
                    continue
                if best_dt is None or float(dt) < float(best_dt):
                    best_dt = float(dt)
                    best_t = int(t)
                    best_link = str(link)
                    best_ordered = list(ordered or [])

            if best_t is None or not best_link:
                self.refresh_proxy(manual=True)
                return

            try:
                _set_selected_type(int(best_t))
            except:
                pass
            try:
                self.set_setting("provider", int(best_t), reload_settings=False)
            except:
                pass

            try:
                if prev_t is None or int(prev_t) != int(best_t):
                    self._reload_settings_ui()
            except:
                pass

            prev_link = _get_last_applied_link()
            if (not manual) and prev_link and str(prev_link) == str(best_link):
                return

            def apply_on_ui():
                self._apply_proxy_link(str(best_link))
                try:
                    self._start_connect_watchdog(list(best_ordered or []), str(best_link))
                except:
                    pass

            run_on_ui_thread(apply_on_ui)
        threading.Thread(target=job, daemon=True).start()

    def _reload_settings_ui(self):
        def _run():
            try:
                PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                if PC:
                    try:
                        inst = PC.getInstance()
                    except:
                        inst = None
                    if inst is not None:
                        try:
                            inst.loadPluginSettings("exitfy")
                        except:
                            pass
            except:
                pass

        try:
            run_on_ui_thread(_run)
        except:
            _run()

    def _on_tg_proxy_enabled_changed(self, v: bool):
        try:
            self.set_setting("plugin_enabled", bool(v), reload_settings=False)
        except:
            pass
        try:
            _set_tg_proxy_enabled(bool(v))
        except:
            pass
        if bool(v):
            try:
                self.refresh_proxy(manual=True)
            except:
                pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _on_manual_node_changed(self, idx: int, nodes: List[str], links: List[str]):
        try:
            if not nodes:
                return
            i = int(idx)
            if i < 0:
                i = 0
            if i >= len(nodes):
                i = len(nodes) - 1
            node = str(nodes[i])
            self.set_setting("manual_node_idx", int(i), reload_settings=False)
        except:
            return

        chosen = None
        for l in links or []:
            info = None
            try:
                info = _parse_proxy_link(str(l))
            except:
                info = None
            if info is None:
                continue
            host = ""
            try:
                host = str(info.address or "")
            except:
                host = ""
            if not host:
                continue
            if host.split(".")[0] == node:
                chosen = str(l)
                break
        if chosen:
            try:
                self._apply_proxy_link(str(chosen))
            except:
                pass

    def _on_auto_switch_changed(self, v: bool):
        try:
            self.set_setting("auto_switch", bool(v), reload_settings=False)
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _sync_tg_proxy_setting(self, reload_settings: bool = False) -> bool:
        tg_state = False
        try:
            tg_state = bool(_tg_proxy_enabled())
        except:
            tg_state = False

        cur = None
        try:
            cur = bool(self.get_setting("tg_proxy_enabled", tg_state))
        except:
            cur = None

        if cur is None or cur != tg_state:
            try:
                self.set_setting("tg_proxy_enabled", tg_state, reload_settings=bool(reload_settings))
            except:
                pass
            return True
        return False

    def _install_redirect_hooks(self):
        if self._hooks_installed:
            return
        try:
            DA = find_class("org.telegram.ui.DialogsActivity")
            if DA:
                try:
                    self.hook_all_methods(DA, "updateProxyButton", ForceDialogsProxyButtonHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "showSearch", _DialogsShowSearchForceProxyHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "showDoneItem", _DialogsShowDoneItemForceProxyHook(self))
                except:
                    pass
                try:
                    self.hook_all_methods(DA, "presentFragment", _DialogsPresentFragmentRedirectHook(self))
                except:
                    pass
            self._hooks_installed = True
        except:
            pass

    def _install_sync_hooks(self):
        if self._sync_hooks_installed:
            return
        self._sync_hooks_installed = True

    def _on_provider_changed(self, idx: int):
        try:
            i = int(idx)
        except:
            i = 0
        try:
            _set_selected_type(int(i))
        except:
            pass
        try:
            self.set_setting("provider", int(i), reload_settings=False)
        except:
            pass
        try:
            self.refresh_proxy(manual=True)
        except:
            pass
        try:
            self._reload_settings_ui()
        except:
            pass

    def _open_tg_proxy_screen(self):
        try:
            frag = _get_last_fragment()
            if frag is None:
                return
            ProxyListActivity = find_class("org.telegram.ui.ProxyListActivity")
            if not ProxyListActivity:
                return

            self._allow_open_tg_proxy_screen = True
            try:
                frag.presentFragment(ProxyListActivity())
            finally:
                def _reset():
                    try:
                        self._allow_open_tg_proxy_screen = False
                    except:
                        pass

                run_on_ui_thread(_reset, 500)
        except:
            try:
                self._allow_open_tg_proxy_screen = False
            except:
                pass

    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.START or event_type == AppEvent.RESUME:
            try:
                changed = self._sync_tg_proxy_setting(reload_settings=False)
                if changed:
                    self._reload_settings_ui()
            except:
                pass

            try:
                if self._should_auto_switch_now():
                    try:
                        self._last_auto_switch_ts = int(time.time())
                    except:
                        pass
                    self._start_switch_cycle()
                else:
                    self.refresh_proxy(manual=False)
            except:
                pass

    def _start_switch_cycle(self):
        try:
            if not self._switch_cycle_lock.acquire(False):
                return
        except:
            return

        def job():
            try:
                self._switch_cycle()
            except:
                pass
            finally:
                try:
                    self._switch_cycle_lock.release()
                except:
                    pass

        threading.Thread(target=job, daemon=True).start()

    def _choose_proxy_from_scored(self, scored: List[Tuple[float, str]], used: set) -> Optional[str]:
        candidates = [str(x[1]) for x in (scored or []) if str(x[1]) not in used]
        if not candidates:
            return None
        try:
            if RANDOM_PROXY_CHANCE > 0 and random.random() < float(RANDOM_PROXY_CHANCE):
                return str(random.choice(candidates))
        except:
            pass
        return str(candidates[0])

    def _wait_connected(self, timeout_sec: int) -> bool:
        deadline = time.time() + float(timeout_sec)
        while True:
            try:
                if not bool(self._active):
                    return False
            except:
                return False

            state = None
            try:
                state = self._get_any_connection_state()
            except:
                state = None
            if self._is_connected_state(state):
                try:
                    self._last_connected_ts = int(time.time())
                except:
                    pass
                return True

            try:
                if time.time() >= deadline:
                    return False
            except:
                return False

            try:
                time.sleep(0.35)
            except:
                return False

    def _switch_cycle(self):
        try:
            if not bool(self.get_setting("auto_switch", True)):
                return
        except:
            return

        try:
            if not bool(_tg_proxy_enabled()):
                return
        except:
            return

        state = None
        try:
            state = self._get_any_connection_state()
        except:
            state = None
        if not self._is_bad_state(state):
            return

        try:
            providers = list((API_URLS or {}).keys())
        except:
            providers = []
        if not providers:
            return

        provider_scored: List[Tuple[float, int, List[Tuple[float, str]]]] = []
        for t in providers:
            links = []
            try:
                links = _fetch_links(int(t))
            except:
                links = []
            if not links:
                continue
            try:
                scored = _score_links_with_wl_fallback(int(t), list(links))
            except:
                scored = []
            if not scored:
                continue
            provider_scored.append((float(scored[0][0]), int(t), scored))

        if not provider_scored:
            return
        provider_scored.sort(key=lambda x: x[0])

        used_links = set()
        for _, t, scored in provider_scored:
            try:
                _set_selected_type(int(t))
            except:
                pass
            try:
                self.set_setting("provider", int(t), reload_settings=False)
            except:
                pass
            try:
                self._reload_settings_ui()
            except:
                pass

            ordered_links = [str(x[1]) for x in scored]
            while True:
                link = self._choose_proxy_from_scored(scored, used_links)
                if not link:
                    break
                used_links.add(str(link))

                def apply_on_ui():
                    self._apply_proxy_link(str(link))

                try:
                    run_on_ui_thread(apply_on_ui)
                except:
                    try:
                        apply_on_ui()
                    except:
                        pass

                try:
                    timeout_sec = int(self.get_setting("connect_try_sec", CONNECT_TRY_SEC))
                except:
                    timeout_sec = CONNECT_TRY_SEC
                if timeout_sec < 1:
                    timeout_sec = 1
                if timeout_sec > 30:
                    timeout_sec = 30

                ok = False
                try:
                    ok = bool(self._wait_connected(int(timeout_sec)))
                except:
                    ok = False
                if ok:
                    try:
                        self._start_connect_watchdog(list(ordered_links or []), str(link))
                    except:
                        pass
                    return

        return

    def _open_plugin_settings(self, context):
        try:
            PC = find_class("com.exteragram.messenger.plugins.PluginsController")
        except:
            PC = None
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
        except:
            PSA = None

        try:
            if PC:
                try:
                    inst = PC.getInstance()
                except:
                    inst = None
                if inst is not None and hasattr(inst, "plugins"):
                    try:
                        plugin_obj = inst.plugins.get(self.id)
                    except:
                        plugin_obj = None
                    if plugin_obj is not None and PSA:
                        try:
                            frag = _get_last_fragment()
                            if frag is not None:
                                frag.presentFragment(PSA(plugin_obj))
                                return
                        except:
                            pass
                try:
                    PC.openPluginSettings("exitfy")
                    return
                except:
                    pass
        except:
            pass

    def refresh_proxy(self, manual: bool = False):
        now = int(time.time())
        if not manual:
            last = _get_last_check_ts()
            if now - last < CHECK_INTERVAL_SEC:
                return
        _set_last_check_ts(now)

        def job():
            if not self._refresh_lock.acquire(False):
                return
            try:
                t = _get_selected_type()
                links = _fetch_links(t)
                if not links:
                    return

                try:
                    auto_switch = bool(self.get_setting("auto_switch", True))
                except:
                    auto_switch = True

                if not bool(auto_switch):
                    try:
                        manual_idx = int(self.get_setting("manual_node_idx", 0))
                    except:
                        manual_idx = 0
                    manual_nodes: List[str] = []
                    for l in links:
                        try:
                            info = _parse_proxy_link(str(l))
                        except:
                            info = None
                        if info is None:
                            continue
                        host = ""
                        try:
                            host = str(info.address or "")
                        except:
                            host = ""
                        if not host:
                            continue
                        node = host.split(".")[0]
                        if node and node not in manual_nodes:
                            manual_nodes.append(node)
                    manual_nodes.sort()
                    if manual_nodes:
                        if manual_idx < 0:
                            manual_idx = 0
                        if manual_idx >= len(manual_nodes):
                            manual_idx = len(manual_nodes) - 1
                        selected_node = str(manual_nodes[int(manual_idx)])
                        chosen = None
                        for l in links:
                            try:
                                info = _parse_proxy_link(str(l))
                            except:
                                info = None
                            if info is None:
                                continue
                            host = ""
                            try:
                                host = str(info.address or "")
                            except:
                                host = ""
                            if not host:
                                continue
                            if host.split(".")[0] == selected_node:
                                chosen = str(l)
                                break
                        if chosen:
                            def apply_on_ui():
                                self._apply_proxy_link(str(chosen))
                            run_on_ui_thread(apply_on_ui)
                            return

                scored = _score_links_with_wl_fallback(int(t), list(links))
                if not scored:
                    return
                link = str(scored[0][1]).strip()
                ordered_links = [str(x[1]) for x in scored]

                prev = _get_last_applied_link()
                if (not manual) and prev and prev == link:
                    return

                def apply_on_ui():
                    self._apply_proxy_link(link)
                    try:
                        self._start_connect_watchdog(ordered_links, link)
                    except:
                        pass

                run_on_ui_thread(apply_on_ui)
            except Exception:
                pass
            finally:
                try:
                    self._refresh_lock.release()
                except:
                    pass

        threading.Thread(target=job, daemon=True).start()


class Hook(ExitfyPlugin):
    pass

__plugin__ = Hook
