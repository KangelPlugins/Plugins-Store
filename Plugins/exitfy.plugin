#░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓████████▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░ 
#░▒▓██████▓▒░  ░▒▓██████▓▒░░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓██████▓▒░  ░▒▓██████▓▒░  
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░     
#░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░     
#░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░         ░▒▓█▓▒░  

import threading, time, requests, urllib.parse, socket, ctypes, base64, json, re, random
from html import unescape

from base_plugin import BasePlugin, MenuItemData, MenuItemType, MethodHook
from android_utils import log, run_on_ui_thread
from ui.settings import Header, Switch, Selector, Text, Divider, Input
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from hook_utils import find_class, get_private_field, set_private_field
from client_utils import get_last_fragment
from java.util import Locale
from org.telegram.messenger import (
    ApplicationLoader, SharedConfig, MessagesController,
    NotificationCenter, UserConfig,
)
from org.telegram.tgnet import ConnectionsManager

try:
    import ReMandre #thx @swagnonher for vless support
except ImportError:
    ReMandre = None

__id__ = "exitfy"
__name__ = "exitFy"
__description__ = "Application download speed optimization"
__icon__ = "exitFy/0"
__author__ = "@exteraPluginsSup"
__version__ = "2.0"
__min_version__ = "12.1.1"

PROXY_API_URLS = {
    0: ["https://exitfy.ishrimp.xyz/proxy/latest"],
    1: ["https://exitfy.vpnetproxy.xyz/proxy/latest"],
    2: ["https://a.stemstep.cloud/proxy/socks"],
}
PROVIDER_NAMES = {0: "Shrimp", 1: "VPNET", 2: "Sworkle"}
VLESS_PROVIDER_SUBS = { #даже если возьмешь, там все равно трафик ограничен только на айпи телеграма
    0: ["https://subs.invisibleshrimp.su/T1JSS-y0uNkBdCy-"],
    1: ["https://sub.vpnet.club/7q6wzBFL8huaB1nU"],
    2: ["https://s3.stemstep.cloud/sub/exitfy"],
}
SPONSOR_VLESS_URLS = set([u for arr in VLESS_PROVIDER_SUBS.values() for u in arr])
REFERRAL = {
    0: "https://t.me/invisibleshrimpbot?start=exitfy",
    1: "https://t.me/vpnetvpn_bot?start=exitfy",
    2: "https://t.me/sworklevpnbot?start=ref1208",
}
CHECK_INTERVAL_SEC = 5
RANDOM_PROXY_CHANCE = 0.15

TRANSLATIONS = {
    "settings_header":      ("Настройки плагина", "Plugin settings"),
    "enable_plugin":        ("Включить плагин", "Enable plugin"),
    "open_tg_settings":     ("Настройки Telegram", "Telegram settings"),
    "select_mode":          ("Режим подключения", "Connection mode"),
    "mode_proxy":           ("Прокси", "Proxy"),
    "mode_vless":           ("VLESS", "VLESS"),
    "menu_settings":        ("Настройки exitFy", "exitFy settings"),
    "select_provider":      ("Провайдер", "Provider"),
    "node":                 ("Сервер", "Server"),
    "refresh":              ("Обновить список", "Refresh list"),
    "auto_switch":          ("Автопереключение", "Auto switch"),
    "auto_switch_desc":     ("Автоматически менять сервер при потере соединения", "Automatically switch server on connection loss"),
    "auto_switch_header":   ("Параметры автопереключения", "Auto switch parameters"),
    "connect_try":          ("Ожидание подключения (сек)", "Connect wait (sec)"),
    "stuck":                ("Порог зависания (сек)", "Stuck threshold (sec)"),
    "cooldown":             ("Кулдаун переключения (сек)", "Switch cooldown (sec)"),
    "referral_btn":         ("Включить интернет везде", "Enable internet everywhere"),
    "vless_provider":       ("Провайдер", "Provider"),
    "vless_prov_custom":    ("Кастом", "Custom"),
    "vless_nodes_header":   ("Узлы подключения", "Connection nodes"),
    "vless_add_key":        ("Ключ VLESS", "VLESS key"),
    "vless_add_sub":        ("Подписка VLESS", "VLESS subscription"),
    "vless_no_nodes":       ("Смените провайдера или добавьте свой", "Change provider or add custom"),
    "vless_nodes_manage":   ("Управление узлами", "Manage nodes"),
    "vless_nodes_update":   ("Обновить узлы", "Update nodes"),
    "vless_nodes_clear":    ("Очистить свои узлы", "Clear custom nodes"),
}

def Z(key):
    lang = Locale.getDefault().getLanguage()
    idx = 0 if str(lang).startswith("ru") else 1
    try: return str(TRANSLATIONS.get(key, (key, key))[idx])
    except: return str(key)

def _prefs():
    return ApplicationLoader.applicationContext.getSharedPreferences("mandre_bypass_prefs", 0)

def _pget_int(k, d=0):
    try: return int(_prefs().getInt(k, int(d)))
    except: return d

def _pset_int(k, v):
    try: ed = _prefs().edit(); ed.putInt(k, int(v)); ed.commit()
    except: pass

def _pget_str(k, d=""):
    try: return str(_prefs().getString(k, str(d)) or "")
    except: return d

def _pset_str(k, v):
    try: ed = _prefs().edit(); ed.putString(k, str(v or "")); ed.commit()
    except: pass

def _to_int(v, d=0):
    try: return int(v)
    except: return int(d)


def _norm(s):
    try: s = str(s or "")
    except: return ""
    try: s = unescape(s)
    except: pass
    s = s.strip()
    if not s: return ""
    try: s = re.sub(r"[\s\)\]>,\.;]+$", "", s)
    except: pass
    try: s = re.sub(r"^[\s\(\[<]+", "", s)
    except: pass
    return s


def _parse_link(link):
    try:
        link = _norm(str(link))
        if not link: return None
        if link.startswith("https://t.me/socks"):
            link = link.replace("https://t.me/socks", "tg://socks", 1)
        elif link.startswith("https://t.me/proxy"):
            link = link.replace("https://t.me/proxy", "tg://proxy", 1)
        if "?" not in link: return None
        qs = link.split("?", 1)[1]
        params = {}
        for part in qs.split("&"):
            if "=" in part:
                k, v = part.split("=", 1); params[k.lower()] = urllib.parse.unquote(v)
        server = params.get("server", ""); port_s = params.get("port", "")
        if not server or not port_s: return None
        return SharedConfig.ProxyInfo(str(server), int(port_s), "", "", str(params.get("secret", "")))
    except: return None


def _is_bypass_host(p):
    try:
        h = str(p.address or "").lower()
        return ("ishrimp.xyz" in h or "vpnet" in h or "sworkle" in h or
                "stemstep" in h or h == "127.0.0.1" or h.startswith("exitfy-"))
    except: return False


def _apply_proxy_info(info):
    if info is None: return
    try: SharedConfig.loadProxyList()
    except: pass
    existing = None
    try:
        if hasattr(SharedConfig, "proxyList") and SharedConfig.proxyList is not None:
            for i in range(int(SharedConfig.proxyList.size())):
                try:
                    p = SharedConfig.proxyList.get(i)
                    if _is_bypass_host(p): existing = p; break
                except: continue
    except: pass
    added = None
    if existing is not None:
        try:
            existing.address = str(info.address); existing.port = int(info.port)
            existing.username = ""; existing.password = ""
            existing.secret = str(info.secret or ""); added = existing
        except: pass
    if added is None:
        try:
            added = SharedConfig.addProxy(str(info.address), int(info.port), "", "", str(info.secret or ""))
        except: added = info
    try: SharedConfig.currentProxy = added
    except: pass
    enabled_now = _tg_proxy_enabled()
    try: SharedConfig.proxyEnabled = bool(enabled_now); SharedConfig.saveConfig()
    except: pass
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putString("proxy_ip", str(added.address)); ed.putInt("proxy_port", int(added.port))
        ed.putString("proxy_user", ""); ed.putString("proxy_pass", "")
        ed.putString("proxy_secret", str(added.secret or ""))
        ed.putBoolean("proxy_enabled", bool(enabled_now)); ed.apply()
    except: pass
    try:
        if bool(enabled_now):
            ConnectionsManager.setProxySettings(True, added.address, int(added.port), "", "", added.secret)
        else:
            ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
    except: pass
    try:
        run_on_ui_thread(lambda: NotificationCenter.getGlobalInstance().postNotificationName(
            NotificationCenter.proxySettingsChanged), 350)
    except: pass


def _tg_proxy_enabled():
    try: return bool(MessagesController.getGlobalMainSettings().getBoolean("proxy_enabled", False))
    except: return False


def _set_tg_proxy_enabled(enabled):
    try:
        ed = MessagesController.getGlobalMainSettings().edit()
        ed.putBoolean("proxy_enabled", bool(enabled)); ed.commit()
    except: pass
    try: SharedConfig.proxyEnabled = bool(enabled); SharedConfig.saveConfig()
    except: pass
    try:
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm:
                    if bool(enabled) and SharedConfig.currentProxy is not None:
                        p = SharedConfig.currentProxy
                        cm.setProxySettings(True, p.address, int(p.port), p.username, p.password, p.secret)
                    else:
                        cm.setProxySettings(False, "", 0, "", "", "")
            except: pass
    except: pass
    try: NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
    except: pass


def _fetch_proxy_links(proxy_type):
    urls = PROXY_API_URLS.get(proxy_type) or []
    out = []
    for url in urls:
        try:
            r = requests.get(url, timeout=10)
            if r.status_code != 200: continue
            text = (r.text or "").strip()
            if not text: continue
            for line in str(text).splitlines():
                s = (line or "").strip()
                if not s: continue
                found = []
                try: found = re.findall(r"(tg://[^\s\"']+)", s)
                except: pass
                if found:
                    out.extend([_norm(x) for x in found if _norm(x)]); continue
                try: found = re.findall(r"(https?://t\.me/[^\s\"']+)", s)
                except: pass
                if found:
                    out.extend([_norm(x) for x in found if _norm(x)]); continue
                if "tg://" in s or "t.me/" in s:
                    ns = _norm(s)
                    if ns: out.append(ns)
            if out: return out
        except: continue
    return out


def _proxy_latency(link):
    try:
        info = _parse_link(str(link))
        if not info: return None
        start = time.monotonic()
        s = socket.create_connection((str(info.address), int(info.port)), timeout=3)
        dt = float(time.monotonic() - start); s.close(); return dt
    except: return None


def _score_links(links):
    results = []; lock = threading.Lock()
    def worker(l):
        dt = _proxy_latency(str(l))
        if dt is not None:
            with lock: results.append((float(dt), str(l)))
    threads = [threading.Thread(target=worker, args=(l,), daemon=True) for l in links[:20]]
    for t in threads: t.start()
    deadline = time.time() + 5
    for t in threads:
        remain = float(deadline - time.time())
        if remain <= 0: break
        t.join(timeout=remain)
    results.sort(key=lambda x: x[0])
    return results if results else [(0.0, str(l)) for l in links[:5]]


def _log(msg): log(f"[exitfy] {msg}")


class AlwaysShowProxyButtonHook(MethodHook):
    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            proxy_item = get_private_field(dialogs_activity, "proxyItem")
            if not proxy_item:
                fields = dialogs_activity.getClass().getDeclaredFields()
                for f in fields:
                    if "ActionBarMenuItem" in f.getType().getName():
                        f.setAccessible(True)
                        item = f.get(dialogs_activity)
                        if item:
                            item.setVisibility(0)
            if proxy_item:
                proxy_item.setVisibility(0)
                set_private_field(dialogs_activity, "proxyItemVisible", True)
        except:
            pass

class VlessConfigParser:
    @staticmethod
    def parse(uri_str, local_port):
        try:
            if not uri_str.startswith("vless://"): return None, None
            part = uri_str[8:]; name = "VLESS Node"
            if "#" in part:
                part, name = part.split("#", 1); name = urllib.parse.unquote(name).strip()
            if "@" not in part: return None, None
            uuid_str, rest = part.split("@", 1)
            if "?" in rest: host_port, params_raw = rest.split("?", 1)
            else: host_port, params_raw = rest, ""
            host_port = str(host_port).strip().rstrip("/")
            if ":" not in host_port: return None, None
            host, port = host_port.split(":", 1)
            try:
                port = int(str(port).strip())
            except:
                return None, None
            params = {}
            if params_raw:
                for pair in params_raw.split("&"):
                    if "=" in pair:
                        k, v = pair.split("=", 1); params[k] = urllib.parse.unquote(v)
            config = {
                "log": {"loglevel": "none"},
                "inbounds": [{"tag": "socks-in", "port": local_port, "listen": "127.0.0.1",
                              "protocol": "socks",
                              "settings": {"auth": "noauth", "udp": True, "ip": "127.0.0.1"},
                              "sniffing": {"enabled": True, "destOverride": ["http", "tls"], "routeOnly": False}}],
                "outbounds": [{"tag": "proxy", "protocol": "vless",
                               "settings": {"vnext": [{"address": host, "port": port,
                                                        "users": [{"id": uuid_str, "encryption": "none",
                                                                   "flow": params.get("flow", "")}]}]},
                               "streamSettings": {"network": params.get("type", "tcp"),
                                                  "security": params.get("security", "none")}}]
            }
            stream = config["outbounds"][0]["streamSettings"]
            fp = params.get("fp", "chrome")
            if params.get("security") == "reality":
                stream["realitySettings"] = {"show": False, "fingerprint": fp,
                    "serverName": params.get("sni", ""), "publicKey": params.get("pbk", ""),
                    "shortId": params.get("sid", ""), "spiderX": params.get("spx", "")}
            elif params.get("security") == "tls":
                stream["tlsSettings"] = {"serverName": params.get("sni", ""),
                                         "allowInsecure": False, "fingerprint": fp}
            net = params.get("type", "tcp")
            if net == "ws":
                stream["wsSettings"] = {"path": params.get("path", "/"),
                    "headers": {"Host": params.get("host", params.get("sni", ""))}}
            elif net == "grpc":
                stream["grpcSettings"] = {"serviceName": params.get("serviceName", ""),
                    "multiMode": params.get("mode", "multi") == "multi"}
            return json.dumps(config), name
        except Exception as e:
            _log(f"VLESS parse error: {e}"); return None, None


class VlessCore:
    def __init__(self):
        self.lib = None
        if ReMandre:
            self.lib = ReMandre.ReLoad.get().loaded_modules.get("libvless")
            if self.lib:
                self.lib.StartCore.argtypes = [ctypes.c_char_p]
                self.lib.StartCore.restype = ctypes.c_char_p

    def is_available(self): return self.lib is not None

    def start(self, config_json):
        if not self.is_available(): return "Native library not loaded"
        try:
            res = self.lib.StartCore(config_json.encode('utf-8'))
            return ctypes.c_char_p(res).value.decode('utf-8') if res else ""
        except Exception as e: return str(e)

    def stop(self):
        if self.is_available():
            try: self.lib.StopCore()
            except: pass

def _vless_apply_tg_proxy(port, enable):
    try:
        ProxyInfoClass = find_class("org.telegram.messenger.SharedConfig$ProxyInfo")
        ed = MessagesController.getGlobalMainSettings().edit()
        try:
            proxy_list = SharedConfig.proxyList
            if proxy_list:
                to_remove = []
                for i in range(proxy_list.size()):
                    p = proxy_list.get(i)
                    if str(p.address) == "127.0.0.1":
                        to_remove.append(p)
                for p in to_remove:
                    SharedConfig.deleteProxy(p)
        except: pass

        try:
            curr = SharedConfig.currentProxy
            if curr and str(curr.address) == "127.0.0.1":
                SharedConfig.currentProxy = None
        except:
            pass

        if enable:
            proxy_obj = ProxyInfoClass("127.0.0.1", port, "", "", "")
            SharedConfig.addProxy(proxy_obj)
            SharedConfig.currentProxy = proxy_obj
            SharedConfig.proxyEnabled = True
            ed.putString("proxy_ip", "127.0.0.1"); ed.putInt("proxy_port", port)
            ed.putString("proxy_user", ""); ed.putString("proxy_pass", "")
            ed.putString("proxy_secret", ""); ed.putBoolean("proxy_enabled", True)
            ed.putBoolean("proxy_enabled_calls", True)
        else:
            SharedConfig.proxyEnabled = False
            ed.putBoolean("proxy_enabled", False)
            ed.putBoolean("proxy_enabled_calls", False)
        ed.apply()
        try:
            SharedConfig.saveProxyList()
        except:
            pass
        SharedConfig.saveConfig()
        for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
            try:
                cm = ConnectionsManager.getInstance(ac)
                if cm:
                    if enable: cm.setProxySettings(True, "127.0.0.1", port, "", "", "")
                    else: cm.setProxySettings(False, "", 0, "", "", "")
            except: pass
        def _notify():
            try:
                from java import jarray
                from java.lang import Object
                NotificationCenter.getGlobalInstance().postNotificationName(
                    NotificationCenter.proxySettingsChanged, jarray(Object)(0))
            except:
                try:
                    NotificationCenter.getGlobalInstance().postNotificationName(
                        NotificationCenter.proxySettingsChanged)
                except: pass
        run_on_ui_thread(_notify, 300)
        _log(f"vless_apply_tg_proxy: enable={enable} port={port}")
    except Exception as e: _log(f"vless_apply_tg_proxy error: {e}")


def _check_vless_port(port, timeout=0.2):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout); return s.connect_ex(('127.0.0.1', port)) == 0
    except: return False


def _get_free_port():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0)); return s.getsockname()[1]

def _fetch_vless_nodes(url):
    try:
        r = requests.get(url, timeout=15)
        if r.status_code != 200: return []
        text = r.text.strip()
        if "vless://" not in text:
            try:
                missing = len(text) % 4
                if missing: text += '=' * (4 - missing)
                text = base64.b64decode(text, validate=False).decode('utf-8', errors='ignore')
            except: pass
        nodes = []
        for line in text.splitlines():
            line = line.strip()
            if line.startswith("vless://"):
                conf, name = VlessConfigParser.parse(line, 1080)
                if conf: nodes.append({"name": name, "uri": line, "ping": -1})
        return nodes
    except Exception as e:
        _log(f"fetch_vless_nodes error ({url}): {e}"); return []

class exitfyPlugin(BasePlugin):
    __ReqRements__ = {
        "libvless": "https://github.com/coidarashka/MandreLib-Modules/releases/download/LocalAiChat/libvless.so - need"
    }

    def on_plugin_load(self):
        if ReMandre:
            try: ReMandre.ReMandreCore.initialize(self)
            except: pass

        self._vless_core = VlessCore()
        self._vless_port = 20808
        self._vless_running = False
        self._ping_event = threading.Event()

        self._chat_menu_item_id = "exitfy_settings_chat"
        self._drawer_menu_item_id = "exitfy_settings_drawer"

        self._proxy_links = []
        self._proxy_cycle_idx = 0
        self._watchdog_stop = threading.Event()

        self._vpn_guard_stop = threading.Event()
        self._vpn_guard_was_active = False

        self._vless_data = self.get_setting("vless_data", {"manual": [], "subs": [], "active_uri": ""})
        self._vless_active_uri = self._vless_data.get("active_uri", "")
        self._ping_stop = threading.Event()
        self._vless_init_in_progress = False
        self._last_custom_key_applied = ""
        self._last_custom_sub_applied = ""

        try:
            self._proxy_custom_urls = json.loads(_pget_str("proxy_custom_urls", "[]"))
            if not isinstance(self._proxy_custom_urls, list):
                self._proxy_custom_urls = []
        except:
            self._proxy_custom_urls = []

        self._add_menu_items()

        self._vpn_guard_stop.clear()
        threading.Thread(target=self._vpn_guard_loop, daemon=True).start()

        try:
            JavaClass = find_class("java.lang.Class")
            DialogsActClass = JavaClass.forName("org.telegram.ui.DialogsActivity")
            jbool = find_class("java.lang.Boolean").TYPE
            m = DialogsActClass.getDeclaredMethod("updateProxyButton", jbool, jbool)
            if m:
                m.setAccessible(True)
                self.hook_method(m, AlwaysShowProxyButtonHook())
                _log("proxy button hook installed")
        except:
            _log("proxy button hook not installed")
            pass

        mode = self.get_setting("mode", 0)
        if mode == 0:
            if self.get_setting("proxy_enabled", False):
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        else:
            threading.Thread(target=self._vless_pinger_loop, daemon=True).start()
            if self.get_setting("vless_enabled", False) and self._vless_active_uri:
                threading.Thread(target=self._vless_connect, daemon=True).start()

    def on_plugin_unload(self):
        self._watchdog_stop.set()
        self._ping_stop.set()
        self._vpn_guard_stop.set()
        self._vless_disconnect(silent=True)
        self._remove_menu_items()

    def _is_system_vpn_active(self):
        try:
            ctx = ApplicationLoader.applicationContext
            cm = ctx.getSystemService("connectivity")
            if not cm:
                return False

            try:
                active = cm.getActiveNetwork()
                caps = cm.getNetworkCapabilities(active) if active else None
                if caps:
                    try:
                        from android.net import NetworkCapabilities
                        return bool(caps.hasTransport(NetworkCapabilities.TRANSPORT_VPN))
                    except:
                        pass
            except:
                pass

            try:
                info = cm.getActiveNetworkInfo()
                if info and info.isConnected():
                    try:
                        from android.net import ConnectivityManager
                        return int(info.getType()) == int(ConnectivityManager.TYPE_VPN)
                    except:
                        pass
            except:
                pass
        except:
            return False
        return False

    def _disable_plugin_due_to_vpn(self):
        try:
            mode = _to_int(self.get_setting("mode", 0), 0)

            self._watchdog_stop.set()
            if mode == 1:
                self._vless_disconnect(silent=True)
                try:
                    self.set_setting("vless_enabled", False, reload_settings=True)
                except:
                    pass
            else:
                try:
                    self.set_setting("proxy_enabled", False, reload_settings=True)
                except:
                    pass

            _set_tg_proxy_enabled(False)
            try:
                _vless_apply_tg_proxy(0, False)
            except:
                pass

            run_on_ui_thread(self._reload_settings_ui)
            _log("system VPN detected -> plugin disabled")
        except Exception as e:
            _log(f"vpn auto-disable error: {e}")

    def _vpn_guard_loop(self):
        while not self._vpn_guard_stop.is_set():
            try:
                vpn_active = bool(self._is_system_vpn_active())

                enabled_any = bool(self.get_setting("proxy_enabled", False)) or bool(self.get_setting("vless_enabled", False))
                if vpn_active and enabled_any:
                    if not self._vpn_guard_was_active:
                        self._vpn_guard_was_active = True
                    self._disable_plugin_due_to_vpn()
                elif not vpn_active:
                    self._vpn_guard_was_active = False
            except:
                pass

            self._vpn_guard_stop.wait(3.0)

    def _init_default_vless_sub(self, provider=None):
        self._vless_init_in_progress = True
        if provider is None:
            provider = self.get_setting("vless_provider", 0)
        urls = VLESS_PROVIDER_SUBS.get(provider, list(VLESS_PROVIDER_SUBS.get(0, [])))
        for url in urls:
            nodes = _fetch_vless_nodes(url)
            if nodes:
                if "subs" not in self._vless_data: self._vless_data["subs"] = []
                existing_urls = [s["url"] for s in self._vless_data["subs"]]
                if url not in existing_urls:
                    self._vless_data["subs"].append({
                        "id": url, "url": url,
                        "name": urllib.parse.urlparse(url).netloc,
                        "nodes": nodes
                    })
                self._vless_save_data()
                self._ping_event.set()
        self.set_setting("_subs_loaded_for", provider)
        self._vless_init_in_progress = False
        self._reload_settings_ui()

    def create_settings(self):
        mode = _to_int(self.get_setting("mode", 0), 0)
        if mode == 0:
            en_key = "proxy_enabled"
        else:
            en_key = "vless_enabled"
        en_text = Z("enable_plugin")
        items = [
            Header(text=Z("settings_header")),
            Switch(key=en_key, text=en_text,
                   default=False,
                   icon="msg_permissions", on_change=self._on_enabled_changed),
            Text(text=Z("open_tg_settings"),
                 icon="msg_settings",
                 on_click=lambda v: self._open_tg_proxy_settings()),
            Selector(key="mode", text=Z("select_mode"),
                     default=0,
                     items=[Z("mode_proxy"), Z("mode_vless")],
                     icon="msg_switch", on_change=self._on_mode_changed),
            Divider(),
        ]

        try:
            if mode == 0:
                items += self._proxy_settings_items()
            else:
                if ReMandre is None or not self._vless_core.is_available():
                    items[-1] = Divider()
                items += self._vless_settings_items()
        except Exception as e:
            _log(f"create_settings error: {e}")
            items += [Divider(), Text(text="Settings render error", icon="msg_info")]

        return items

    def _proxy_settings_items(self):
        try:
            provider_idx = _to_int(self.get_setting("proxy_provider", 0), 0)
            auto_switch = self.get_setting("proxy_auto_switch", True)

            items = [
                Selector(key="proxy_provider", text=Z("select_provider"),
                         default=0,
                         items=[PROVIDER_NAMES[i] for i in sorted(PROVIDER_NAMES)],
                         icon="msg_channel", on_change=self._on_provider_changed),
            ]

            if not auto_switch:
                proxy_links = getattr(self, "_proxy_links", []) or []
                node_labels = []
                for i, info in enumerate([_parse_link(l) for l in proxy_links]):
                    node_labels.append(str(info.address) if info else f"Node {i+1}")
                if node_labels:
                    items.append(Selector(key="proxy_manual_node", text=Z("node"),
                                          default=0,
                                          items=node_labels, icon="msg_settings_14",
                                          on_change=self._on_manual_node_changed))

            items.append(Text(text=Z("refresh"), icon="msg_retry",
                              on_click=lambda v: self._proxy_refresh()))

            items.append(Switch(key="proxy_auto_switch", text=Z("auto_switch"),
                                subtext=Z("auto_switch_desc"), default=True,
                                icon="media_flip", on_change=self._on_auto_switch_changed))

            if auto_switch:
                items += [
                    Header(text=Z("auto_switch_header")),
                    Input(key="proxy_connect_try", text=Z("connect_try"),
                          default=str(_pget_int("proxy_connect_try", 7)),
                          icon="msg_settings_14",
                          on_change=self._on_connect_try_changed),
                    Input(key="proxy_stuck_sec", text=Z("stuck"),
                          default=str(_pget_int("proxy_stuck_sec", 8)),
                          icon="msg_settings_14",
                          on_change=self._on_stuck_changed),
                    Input(key="proxy_cooldown_sec", text=Z("cooldown"),
                          default=str(_pget_int("proxy_cooldown_sec", 5)),
                          icon="msg_settings_14",
                          on_change=self._on_cooldown_changed),
                ]

            items += [
                Text(text=Z("referral_btn"), icon="msg_link",
                     accent=True,
                     on_click=self._make_referral_click(provider_idx, "proxy")),
                Divider(),
            ]

            for url in (getattr(self, "_proxy_custom_urls", []) or []):
                label = urllib.parse.urlparse(str(url)).netloc or str(url)
                items.append(Text(text=f"✕ {label}", icon="msg_delete",
                                  on_click=self._make_proxy_sub_delete(url)))

            items.append(Divider())
            return items
        except Exception as e:
            _log(f"proxy settings error: {e}")
            return [Text(text="Proxy settings error", icon="msg_info"), Divider()]

    def _vless_settings_items(self):
        if ReMandre is None or not self._vless_core.is_available():
            lang = Locale.getDefault().getLanguage()
            ru = str(lang).startswith("ru")
            msg = "Нет нативного модуля ReMandre.\nСкачать: @swagnonher" if ru else "ReMandre native module not found.\nDownload: @swagnonher"
            return [
                Divider(text=msg),
            ]

        active = self._vless_active_uri
        vless_provider = _to_int(self.get_setting("vless_provider", 0), 0)
        is_custom = (vless_provider == 3)
        sponsor_idx = min(vless_provider, 2) if not is_custom else -1

        if not is_custom and not self._vless_data.get("subs") and not self._vless_init_in_progress \
                and self.get_setting("_subs_loaded_for", -1) != vless_provider:
            self._vless_init_in_progress = True
            threading.Thread(target=self._init_default_vless_sub, args=(vless_provider,), daemon=True).start()

        items = [
            Selector(key="vless_provider", text=Z("vless_provider"),
                     default=0,
                     items=[PROVIDER_NAMES[i] for i in sorted(PROVIDER_NAMES)] + [Z("vless_prov_custom")],
                     icon="msg_channel", on_change=self._on_vless_provider_changed),
        ]

        if is_custom:
            items += [
                Input(key="vless_custom_key", text=Z("vless_add_key"),
                      default="",
                      icon="msg_link2",
                      on_change=self._on_vless_custom_key_input),
                Input(key="vless_custom_sub", text=Z("vless_add_sub"),
                      default="",
                      icon="msg_link",
                      on_change=self._on_vless_custom_sub_input),
            ]

        items += [
            Divider(),
            Header(text=Z("vless_nodes_header")),
        ]

        if not self._vless_data.get("manual") and not self._vless_data.get("subs"):
            items.append(Text(text=Z("vless_no_nodes"), icon="msg_disable"))
        else:
            if self._vless_data.get("manual"):
                for node in self._vless_data["manual"]:
                    is_act = (node["uri"] == active)
                    ping = node.get("ping", -1)
                    ping_str = f" — {ping}ms" if ping > 0 else ""
                    prefix = "▶ " if is_act else ""
                    label = prefix + node["name"] + ping_str
                    items.append(Text(text=label, icon="msg_instant_link",
                                      on_click=self._make_vless_node_select(node["uri"])))

            for sub in self._vless_data.get("subs", []):
                nodes = sub.get("nodes", [])
                if not nodes: continue
                items.append(Header(text=f"{sub['name']} ({len(nodes)})"))
                for node in nodes:
                    is_act = (node["uri"] == active)
                    ping = node.get("ping", -1)
                    ping_str = f" — {ping}ms" if ping > 0 else ""
                    prefix = "▶ " if is_act else ""
                    label = prefix + node["name"] + ping_str
                    items.append(Text(text=label, icon="msg_instant_link",
                                      on_click=self._make_vless_node_select(node["uri"])))

        if not is_custom:
            items += [
                Text(text=Z("referral_btn"),
                     icon="msg_link",
                     accent=True,
                     on_click=self._make_referral_click(sponsor_idx, "vless")),
                Divider(),
            ]
        items += [
            Text(text=Z("vless_nodes_manage"), icon="msg_settings_14",
                 on_click=lambda v: self._vless_open_nodes_menu()),
            Divider(),
        ]
        return items

    def _add_menu_items(self):
        def on_click(ctx):
            self._open_settings()

        try:
            self.remove_menu_item(self._chat_menu_item_id)
        except:
            pass

        try:
            self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                item_id=self._chat_menu_item_id,
                text=Z("menu_settings"),
                on_click=on_click,
                icon="msg_settings",
                priority=1,
            ))
        except:
            pass

        try:
            self.remove_menu_item(self._drawer_menu_item_id)
        except:
            pass

        try:
            self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.DRAWER_MENU,
                item_id=self._drawer_menu_item_id,
                text=Z("menu_settings"),
                on_click=on_click,
                icon="msg_settings",
                priority=1,
            ))
        except:
            pass

    def _remove_menu_items(self):
        try:
            self.remove_menu_item(self._chat_menu_item_id)
        except:
            pass
        try:
            self.remove_menu_item(self._drawer_menu_item_id)
        except:
            pass

    def _open_settings(self):
        try:
            PC = find_class("com.exteragram.messenger.plugins.PluginsController")
        except:
            PC = None
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
        except:
            PSA = None

        try:
            if PC:
                inst = None
                try:
                    inst = PC.getInstance()
                except:
                    inst = None
                if inst is not None and hasattr(inst, "plugins") and PSA:
                    plugin_obj = None
                    try:
                        plugin_obj = inst.plugins.get(self.id)
                    except:
                        plugin_obj = None
                    if plugin_obj is not None:
                        frag = get_last_fragment()
                        if frag is not None:
                            _log("open_settings: PluginSettingsActivity")
                            frag.presentFragment(PSA(plugin_obj))
                            return
                try:
                    _log("open_settings: PC.openPluginSettings(self.id)")
                    PC.openPluginSettings(self.id)
                    return
                except:
                    try:
                        _log("open_settings: PC.openPluginSettings('exitfy')")
                        PC.openPluginSettings("exitfy")
                        return
                    except:
                        pass
            frag = get_last_fragment()
            if frag and PC:
                _log("open_settings: PluginsController.getInstance().openPluginSettings")
                PC.getInstance().openPluginSettings(self.id, frag)
        except:
            pass

    def _on_mode_changed(self, v):
        mode = _to_int(v, _to_int(self.get_setting("mode", 0), 0))
        self._watchdog_stop.set()
        self._vless_disconnect(silent=True)
        _set_tg_proxy_enabled(False)
        if mode == 1:
            self._ping_stop.clear()
            threading.Thread(target=self._vless_pinger_loop, daemon=True).start()
            if not self._vless_data.get("subs") and not self._vless_init_in_progress:
                threading.Thread(target=self._init_default_vless_sub, daemon=True).start()
            if self.get_setting("vless_enabled", False) and self._vless_active_uri:
                threading.Thread(target=self._vless_connect, daemon=True).start()
        else:
            if self.get_setting("proxy_enabled", False):
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                _set_tg_proxy_enabled(True)
                self._watchdog_stop.clear()
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        self._reload_settings_ui()

    def _on_enabled_changed(self, v):
        enabled = bool(v)
        mode = _to_int(self.get_setting("mode", 0), 0)
        if mode == 1:
            if enabled:
                if self._vless_active_uri:
                    threading.Thread(target=self._vless_connect, daemon=True).start()
                else:
                    self.set_setting("vless_enabled", False, reload_settings=True)
            else:
                self._vless_disconnect()
        else:
            if enabled:
                last_link = _pget_str("last_proxy_link", "")
                if last_link:
                    info = _parse_link(last_link)
                    if info:
                        _apply_proxy_info(info)
                _set_tg_proxy_enabled(True)
                self._watchdog_stop.clear()
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
            else:
                self._watchdog_stop.set()
                _set_tg_proxy_enabled(False)

    def _on_provider_changed(self, v):
        self._proxy_links = []
        self._proxy_cycle_idx = 0
        if self.get_setting("proxy_enabled", False):
            threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()
        self._reload_settings_ui()

    def _on_vless_provider_changed(self, v):
        provider = int(v)
        self._vless_active_uri = ""
        if provider == 3:
            self._vless_data["manual"] = []
            self._vless_data["subs"] = []
            self._vless_save_data()
            if self._vless_running:
                self._vless_disconnect(silent=True)
            self._reload_settings_ui()
            return
        self._vless_data["subs"] = []
        self._vless_data["manual"] = []
        self._vless_save_data()
        if self._vless_running:
            self._vless_disconnect(silent=True)
        threading.Thread(
            target=self._init_default_vless_sub, args=(provider,), daemon=True
        ).start()
        self._reload_settings_ui()

    def _on_vless_custom_key_input(self, v):
        uri = str(v or "").strip()
        self._vless_custom_key_buf = uri
        if uri.startswith("vless://") and "@" in uri and uri != self._last_custom_key_applied:
            self._last_custom_key_applied = uri
            self._apply_vless_custom_key()

    def _apply_vless_custom_key(self):
        uri = getattr(self, "_vless_custom_key_buf", "").strip()
        if not uri.startswith("vless://") or len(uri) < 20:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Неверный vless:// ключ")); return
        conf, name = VlessConfigParser.parse(uri, 1080)
        if not conf:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка парсинга ключа")); return
        manual = self._vless_data.get("manual", [])
        if not any(n["uri"] == uri for n in manual):
            manual.append({"name": name, "uri": uri, "ping": -1})
            self._vless_data["manual"] = manual
        self._vless_active_uri = uri
        self._vless_save_data()
        self._ping_event.set()
        try:
            self.set_setting("vless_enabled", True, reload_settings=True)
        except:
            pass
        threading.Thread(target=self._vless_connect, daemon=True).start()
        run_on_ui_thread(self._reload_settings_ui)

    def _on_vless_custom_sub_input(self, v):
        url = str(v or "").strip()
        self._vless_custom_sub_buf = url
        if url.startswith("http") and len(url) > 10 and url != self._last_custom_sub_applied:
            self._last_custom_sub_applied = url
            self._apply_vless_custom_sub()

    def _apply_vless_custom_sub(self):
        url = getattr(self, "_vless_custom_sub_buf", "").strip()
        if not url.startswith("http") or len(url) < 10: return
        threading.Thread(target=self._vless_do_add_sub, args=(url,), daemon=True).start()

    def _on_connect_try_changed(self, v):
        try:
            val = max(1, min(30, int(str(v).strip())))
            _pset_int("proxy_connect_try", val)
        except: pass

    def _on_stuck_changed(self, v):
        try:
            val = max(1, min(120, int(str(v).strip())))
            _pset_int("proxy_stuck_sec", val)
        except: pass

    def _on_cooldown_changed(self, v):
        try:
            val = max(0, min(120, int(str(v).strip())))
            _pset_int("proxy_cooldown_sec", val)
        except: pass

    def _on_auto_switch_changed(self, v):
        auto = bool(v)
        mode = _to_int(self.get_setting("mode", 0), 0)
        if mode != 0:
            self._reload_settings_ui()
            return
        if auto:
            self._watchdog_stop.clear()
            if self.get_setting("proxy_enabled", False):
                threading.Thread(target=self._watchdog_loop, daemon=True).start()
        else:
            self._watchdog_stop.set()
            if self.get_setting("proxy_enabled", False) and not self._proxy_links:
                threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()
        self._reload_settings_ui()

    def _on_manual_node_changed(self, v):
        try:
            idx = int(v)
            links = self._proxy_links or []
            if idx < 0 or idx >= len(links):
                return
            link = links[idx]
            info = _parse_link(link)
            if info:
                _pset_str("last_proxy_link", link)
                _apply_proxy_info(info)
                self._proxy_cycle_idx = idx
        except Exception as e:
            _log(f"manual node change error: {e}")

    def _reload_settings_ui(self):
        def _do():
            try:
                self.set_setting("__reload__", time.time(), reload_settings=True)
            except: pass
        run_on_ui_thread(_do, 100)

    def _proxy_refresh(self):
        threading.Thread(target=self._proxy_refresh_bg, daemon=True).start()

    def _proxy_refresh_bg(self):
        provider = self.get_setting("proxy_provider", 0)
        links = _fetch_proxy_links(provider)
        if not links: return
        scored = _score_links(links)
        self._proxy_links = [l for _, l in scored]
        self._proxy_cycle_idx = 0
        if not self.get_setting("proxy_auto_switch", True):
            best_link = self._proxy_links[0] if self._proxy_links else None
            if best_link:
                info = _parse_link(best_link)
                if info:
                    _pset_str("last_proxy_link", best_link)
                    _apply_proxy_info(info)
            self._reload_settings_ui()
        else:
            best_link = self._proxy_links[0] if self._proxy_links else None
            if best_link:
                info = _parse_link(best_link)
                if info:
                    _pset_str("last_proxy_link", best_link)
                    _apply_proxy_info(info)

    def _open_tg_proxy_settings(self):
        try:
            frag = get_last_fragment()
            if frag:
                from org.telegram.ui import ProxyListActivity
                frag.presentFragment(ProxyListActivity())
        except: pass

    def _open_tg_link(self, url):
        try:
            url = str(url or "").strip()
            if not url: return
            _log(f"open link: {url}")
            try:
                frag = get_last_fragment()
                act = frag.getParentActivity() if frag else None
            except:
                act = None

            try:
                from org.telegram.messenger.browser import Browser
            except:
                Browser = None

            ctx = act if act else ApplicationLoader.applicationContext
            if Browser:
                _log(f"open link via Browser.openUrl (ctx={type(ctx)})")
                Browser.openUrl(ctx, url)
                return

            from android.content import Intent
            from android.net import Uri
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            if not act:
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            ctx.startActivity(intent)
        except:
            pass

    def _make_referral_click(self, provider_idx, source):
        def handler(v):
            try:
                url = REFERRAL.get(provider_idx, "")
                _log(f"referral click ({source}): idx={provider_idx} url={url}")
                self._open_tg_link(url)
            except Exception as e:
                _log(f"referral click error ({source}): {e}")
        return handler

    def _open_referral(self, provider_idx):
        try:
            url = REFERRAL.get(provider_idx, "")
            self._open_tg_link(url)
        except: pass

    def _make_proxy_sub_delete(self, url):
        def handler(v):
            if url in self._proxy_custom_urls:
                self._proxy_custom_urls.remove(url)
                _pset_str("proxy_custom_urls", json.dumps(self._proxy_custom_urls))
            self._reload_settings_ui()
        return handler

    def _watchdog_loop(self):
        connect_try = _pget_int("proxy_connect_try", 7)
        stuck_sec = _pget_int("proxy_stuck_sec", 8)
        cooldown_sec = _pget_int("proxy_cooldown_sec", 5)

        while not self._watchdog_stop.is_set():
            try:
                if not self.get_setting("proxy_enabled", False):
                    self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue
                if not self.get_setting("proxy_auto_switch", True):
                    self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue

                if not self._proxy_links:
                    provider = self.get_setting("proxy_provider", 0)
                    links = _fetch_proxy_links(provider)
                    if links:
                        scored = _score_links(links)
                        self._proxy_links = [l for _, l in scored]
                        self._proxy_cycle_idx = 0
                    else:
                        self._watchdog_stop.wait(10); continue

                connected = self._wait_connected(connect_try)
                if connected:
                    self._watchdog_stop.wait(stuck_sec)
                    if self._watchdog_stop.is_set(): break
                    still_ok = self._wait_connected(3)
                    if still_ok:
                        self._watchdog_stop.wait(CHECK_INTERVAL_SEC); continue

                self._switch_proxy()
                if cooldown_sec > 0:
                    self._watchdog_stop.wait(cooldown_sec)
            except:
                self._watchdog_stop.wait(CHECK_INTERVAL_SEC)

    def _wait_connected(self, timeout_sec):
        deadline = time.time() + timeout_sec
        while time.time() < deadline:
            try:
                state = int(ConnectionsManager.getInstance(0).getConnectionState())
                if state == 3:
                    return True
            except: pass
            time.sleep(0.5)
        return False

    def _switch_proxy(self):
        if not self._proxy_links: return
        if random.random() < RANDOM_PROXY_CHANCE:
            idx = random.randint(0, len(self._proxy_links) - 1)
        else:
            idx = self._proxy_cycle_idx % len(self._proxy_links)
            self._proxy_cycle_idx += 1

        link = self._proxy_links[idx]
        info = _parse_link(link)
        if info:
            _pset_str("last_proxy_link", link)
            _apply_proxy_info(info)

    def _vless_save_data(self):
        self._vless_data["active_uri"] = self._vless_active_uri
        self.set_setting("vless_data", self._vless_data)

    def _vless_connect(self):
        if not self._vless_active_uri: return
        self._vless_disconnect(silent=True)
        if not self._vless_core.is_available():
            self.set_setting("vless_enabled", False, reload_settings=True); return
        port = _get_free_port()
        self._vless_port = port
        config_json, _ = VlessConfigParser.parse(self._vless_active_uri, port)
        if not config_json:
            self.set_setting("vless_enabled", False, reload_settings=True); return
        _log(f"VLESS starting on port {port}")
        err = self._vless_core.start(config_json)
        if err:
            _log(f"VLESS core error: {err}")
            self.set_setting("vless_enabled", False, reload_settings=True); return

        def connection_watchdog():
            for _ in range(20):
                if _check_vless_port(port):
                    _log(f"VLESS port {port} ready, applying TG proxy")
                    _vless_apply_tg_proxy(port, True)
                    self._vless_running = True
                    try:
                        self.set_setting("vless_enabled", True, reload_settings=True)
                    except:
                        pass
                    run_on_ui_thread(self._reload_settings_ui)
                    return
                time.sleep(0.3)
            _log("VLESS port timeout")
            self.set_setting("vless_enabled", False, reload_settings=True)
            run_on_ui_thread(lambda: self._vless_disconnect(silent=True))
        threading.Thread(target=connection_watchdog, daemon=True).start()

    def _vless_disconnect(self, silent=False):
        self._vless_core.stop()
        self._vless_running = False
        _vless_apply_tg_proxy(0, False)
        if not silent:
            self._reload_settings_ui()

    def _make_vless_node_select(self, uri):
        def handler(v):
            prev = self._vless_active_uri
            self._vless_active_uri = uri
            self._vless_save_data()
            if prev == uri and self._vless_running:
                try:
                    self.set_setting("vless_enabled", False, reload_settings=True)
                except:
                    pass
                self._vless_disconnect()
            else:
                try:
                    self.set_setting("vless_enabled", True, reload_settings=True)
                except:
                    pass
                threading.Thread(target=self._vless_connect, daemon=True).start()
            self._reload_settings_ui()
        return handler

    def _vless_open_nodes_menu(self):
        frag = get_last_fragment()
        if not frag: return
        builder = AlertDialogBuilder(frag.getParentActivity())
        items = [Z("vless_nodes_update"), Z("vless_nodes_clear")]

        lang = Locale.getDefault().getLanguage()
        cancel_text = "Отмена" if str(lang).startswith("ru") else "Cancel"

        def on_item(dlg, which):
            try:
                if int(which) == 0:
                    threading.Thread(target=self._vless_update_all_subs, daemon=True).start()
                elif int(which) == 1:
                    self._vless_clear_user_nodes()
            except Exception as e:
                _log(f"nodes menu error: {e}")

        builder.set_title(Z("vless_nodes_manage"))
        builder.set_items(items, on_item)
        builder.set_negative_button(cancel_text, lambda d, w: d.dismiss())
        builder.show()

    def _vless_update_all_subs(self):
        urls = [s.get("url", "") for s in self._vless_data.get("subs", []) if s.get("url")]
        for url in urls:
            self._vless_update_sub(url)

    def _vless_clear_user_nodes(self):
        self._vless_data["manual"] = []
        self._vless_data["subs"] = []
        if self._vless_active_uri:
            self._vless_active_uri = ""
            self._vless_disconnect(silent=True)
        self._vless_save_data()
        self._reload_settings_ui()

    def _vless_do_add_sub(self, url):
        if not url.startswith("http"): return
        nodes = _fetch_vless_nodes(url)
        if nodes:
            if "subs" not in self._vless_data: self._vless_data["subs"] = []
            existing = [s["url"] for s in self._vless_data["subs"]]
            if url in existing:
                for s in self._vless_data["subs"]:
                    if s["url"] == url: s["nodes"] = nodes; break
            else:
                self._vless_data["subs"].append({
                    "id": url, "url": url,
                    "name": urllib.parse.urlparse(url).netloc,
                    "nodes": nodes
                })
            self._vless_save_data()
            self._ping_event.set()
            run_on_ui_thread(self._reload_settings_ui)

    def _vless_update_sub(self, url):
        nodes = _fetch_vless_nodes(url)
        changed = False
        for sub in self._vless_data.get("subs", []):
            if sub["url"] == url and nodes:
                sub["nodes"] = nodes; changed = True; break
        if changed:
            self._vless_save_data()
            self._ping_event.set()
            run_on_ui_thread(self._reload_settings_ui)

    def _vless_pinger_loop(self):
        while not self._ping_stop.is_set():
            self._ping_event.clear()
            try:
                all_nodes = list(self._vless_data.get("manual", []))
                for sub in self._vless_data.get("subs", []):
                    all_nodes.extend(sub.get("nodes", []))
                if not all_nodes:
                    self._ping_event.wait(600); continue
                changed = False
                for node in all_nodes:
                    if self._ping_stop.is_set(): break
                    try:
                        part = node["uri"].replace("vless://", "")
                        if "@" not in part: continue
                        host_port = part.split("@", 1)[1].split("?", 1)[0].split("#", 1)[0]
                        host, port = host_port.split(":", 1)
                        start = time.time()
                        s = socket.create_connection((host, int(port)), timeout=1.5)
                        p = int((time.time() - start) * 1000); s.close()
                        if node.get("ping") != p: node["ping"] = p; changed = True
                    except:
                        if node.get("ping") != 9999: node["ping"] = 9999; changed = True
                if changed: self._vless_save_data()
            except: pass
            self._ping_event.wait(600)
