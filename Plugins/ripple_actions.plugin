__id__ = "ripple_actions"
__name__ = "Жировые складки"
__description__ = "Triggers Ripple on many actions (send, record, attach, emoji, stickers, bot buttons, reactions, and more)"
__author__ = "@zhirnosti & @mishabotov"
__version__ = "1.0.0"
__icon__ = "xuan_sol_by_fStikBot/0"
__min_version__ = "11.12.1"

from typing import Any, List, Optional

from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment
from hook_utils import get_private_field
from java.lang import Boolean as JBoolean, Class as JClass, Float as JFloat
from ui.settings import Divider, Header, Input, Selector, Switch


class _SendMessageHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_send_message(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: send hook error: {e}")
            except Exception:
                pass


class _StartRecordHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_start_record()
        except Exception as e:
            try:
                log(f"RippleActions: record hook error: {e}")
            except Exception:
                pass


class _VideoRecordHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_start_video()
        except Exception as e:
            try:
                log(f"RippleActions: video hook error: {e}")
            except Exception:
                pass


class _OpenAttachMenuHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_open_attach_menu(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: attach hook error: {e}")
            except Exception:
                pass


class _ShowPopupHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args or len(param.args) < 2:
                return
            try:
                show = int(param.args[0])
            except Exception:
                show = 0
            try:
                content_type = int(param.args[1])
            except Exception:
                content_type = -1
            if show > 0 and content_type == 0:
                self.plugin._on_open_emoji(param.thisObject)
            if show > 0 and content_type == 1:
                self.plugin._on_open_bot_keyboard(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: popup hook error: {e}")
            except Exception:
                pass


class _OpenScheduledHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_open_scheduled(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: scheduled hook error: {e}")
            except Exception:
                pass


class _OpenSearchHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_open_search(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: search hook error: {e}")
            except Exception:
                pass


class _StopRecordHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            send_val = 0
            try:
                send_val = int(param.args[0]) if param.args and len(param.args) > 0 else 0
            except Exception:
                send_val = 0
            if send_val in (1, 3):
                self.plugin._on_send_record()
            elif send_val == 0:
                self.plugin._on_stop_record()
        except Exception as e:
            try:
                log(f"RippleActions: stop record hook error: {e}")
            except Exception:
                pass


class _VideoSendHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_send_video_message(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: video send hook error: {e}")
            except Exception:
                pass


class _SendStickerHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_send_sticker()
        except Exception as e:
            try:
                log(f"RippleActions: sticker hook error: {e}")
            except Exception:
                pass


class _BotButtonPressHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_bot_button(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: bot button hook error: {e}")
            except Exception:
                pass


class _EditMessageHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            msg = param.args[0] if param.args and len(param.args) > 0 else None
            if msg is None:
                return
            self.plugin._on_edit_message(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: edit hook error: {e}")
            except Exception:
                pass


class _OpenPinnedHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_open_pinned(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: pinned hook error: {e}")
            except Exception:
                pass


class _SendFilesHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_send_files(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: files hook error: {e}")
            except Exception:
                pass


class _SendLocationHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_send_location(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: location hook error: {e}")
            except Exception:
                pass


class _ReactionHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            view = param.args[0] if param.args and len(param.args) > 0 else None
            reaction_count = param.args[1] if param.args and len(param.args) > 1 else None
            chosen = None
            try:
                if reaction_count is not None and hasattr(reaction_count, "chosen"):
                    chosen = bool(getattr(reaction_count, "chosen", False))
            except Exception:
                chosen = None
            x = None
            y = None
            if param.args and len(param.args) >= 5:
                try:
                    x = float(param.args[3])
                    y = float(param.args[4])
                except Exception:
                    x = None
                    y = None
            self.plugin._on_reaction(view, x, y, chosen)
        except Exception as e:
            try:
                log(f"RippleActions: reaction hook error: {e}")
            except Exception:
                pass


class _ReactionBubbleHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            reaction_count = param.args[0] if param.args and len(param.args) > 0 else None
            chosen = None
            try:
                if reaction_count is not None and hasattr(reaction_count, "chosen"):
                    chosen = bool(getattr(reaction_count, "chosen", False))
            except Exception:
                chosen = None
            x = None
            y = None
            if param.args and len(param.args) >= 4:
                try:
                    x = float(param.args[2])
                    y = float(param.args[3])
                except Exception:
                    x = None
                    y = None
            self.plugin._on_reaction_bubble(param.thisObject, x, y, chosen)
        except Exception as e:
            try:
                log(f"RippleActions: reaction(bubble) hook error: {e}")
            except Exception:
                pass


class _SelectReactionHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            args = param.args or []
            cell = args[0] if len(args) > 0 else None
            message = args[1] if len(args) > 1 else None
            reactions_layout = args[2] if len(args) > 2 else None
            from_view = args[3] if len(args) > 3 else None
            visible_reaction = args[6] if len(args) > 6 else None
            self.plugin._on_select_reaction(cell, message, reactions_layout, from_view, visible_reaction)
        except Exception as e:
            try:
                log(f"RippleActions: select reaction hook error: {e}")
            except Exception:
                pass


class _ReplySetHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            msg = param.args[0] if param.args and len(param.args) > 0 else None
            if msg is None:
                return
            self.plugin._on_reply_set(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: reply hook error: {e}")
            except Exception:
                pass


class _BotCommandsOpenHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            opened = False
            try:
                opened = bool(param.args[0])
            except Exception:
                opened = False
            if opened:
                self.plugin._on_bot_commands_open(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: bot commands hook error: {e}")
            except Exception:
                pass


class _ExitChatHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_exit_chat(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: exit hook error: {e}")
            except Exception:
                pass


class _ExitChatBoolHook(MethodHook):
    def __init__(self, plugin: "RippleActionsPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin._is_chat_activity(param.thisObject):
                return
            self.plugin._on_exit_chat(param.thisObject)
        except Exception as e:
            try:
                log(f"RippleActions: exit(bool) hook error: {e}")
            except Exception:
                pass


class RippleActionsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.launch_activity_jclass = None
        self.chat_activity_jclass = None
        self.base_fragment_jclass = None
        self.enter_view_jclass = None
        self.media_controller_jclass = None
        self.instant_camera_jclass = None
        self.bot_commands_jclass = None
        self.message_object_jclass = None
        self.reply_quote_jclass = None
        self.send_messages_helper_jclass = None
        self.reactions_layout_jclass = None
        self.launch_activity_clsobj = None
        self.chat_activity_clsobj = None
        self.base_fragment_clsobj = None
        self.enter_view_clsobj = None
        self.media_controller_clsobj = None
        self.instant_camera_clsobj = None
        self.send_messages_helper_clsobj = None
        self.reactions_layout_clsobj = None
        self._make_ripple_static = None
        self._send_unhook = None
        self._record_unhook = None
        self._video_unhook = None
        self._attach_unhook = None
        self._emoji_unhook = None
        self._scheduled_unhook = None
        self._search_unhook = None
        self._stop_record_unhook = None
        self._reply_unhook = None
        self._bot_commands_unhook = None
        self._exit_unhook = None
        self._exit_bool_unhook = None
        self._video_send_unhook = None
        self._sticker_unhook = None
        self._bot_button_unhook = None
        self._edit_unhook = None
        self._pinned_unhook = None
        self._send_files_unhook = None
        self._send_location_unhook = None
        self._reaction_unhook = None
        self._reaction_bubble_unhook = None
        self._select_reaction_unhook = None
        self._cached_intensity = 1.0
        self._cached_action_send = True
        self._cached_action_send_sticker = True
        self._cached_action_send_files = True
        self._cached_action_send_location = False
        self._cached_action_record = True
        self._cached_action_record_send = True
        self._cached_action_video = True
        self._cached_action_video_send = True
        self._cached_action_attach = True
        self._cached_action_emoji = True
        self._cached_action_bot_keyboard = False
        self._cached_action_scheduled = False
        self._cached_action_search = False
        self._cached_action_record_stop = False
        self._cached_action_reply = False
        self._cached_action_bot_commands = False
        self._cached_action_bot_button = False
        self._cached_action_edit = False
        self._cached_action_pinned = False
        self._cached_action_reaction = False
        self._cached_action_exit = True
        self._cached_vibration_enabled = True
        self._cached_vibration_engine = 0
        self._cached_vibration_strength = 1
        self._cached_vibration_duration_ms = 20

    def on_plugin_load(self):
        self._refresh_settings_cache()

        try:
            self.launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
            self.chat_activity_jclass = JClass.forName("org.telegram.ui.ChatActivity")
            self.base_fragment_jclass = JClass.forName("org.telegram.ui.ActionBar.BaseFragment")
            self.enter_view_jclass = JClass.forName("org.telegram.ui.Components.ChatActivityEnterView")
            self.media_controller_jclass = JClass.forName("org.telegram.messenger.MediaController")
            self.instant_camera_jclass = JClass.forName("org.telegram.ui.Components.InstantCameraView")
            self.bot_commands_jclass = JClass.forName("org.telegram.ui.bots.BotCommandsMenuView")
            self.message_object_jclass = JClass.forName("org.telegram.messenger.MessageObject")
            self.reply_quote_jclass = JClass.forName("org.telegram.ui.ChatActivity$ReplyQuote")
            self.send_messages_helper_jclass = JClass.forName("org.telegram.messenger.SendMessagesHelper")
            self.reactions_layout_jclass = JClass.forName("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble")
        except Exception as e:
            self.log(f"RippleActions: Class.forName failed: {e}")
            return

        try:
            self._make_ripple_static = getattr(self.launch_activity_jclass, "makeRipple")
        except Exception:
            self._make_ripple_static = None

        try:
            self.launch_activity_clsobj = getattr(self.launch_activity_jclass, "class_", None)
            self.chat_activity_clsobj = getattr(self.chat_activity_jclass, "class_", None)
            self.base_fragment_clsobj = getattr(self.base_fragment_jclass, "class_", None)
            self.enter_view_clsobj = getattr(self.enter_view_jclass, "class_", None)
            self.media_controller_clsobj = getattr(self.media_controller_jclass, "class_", None)
            self.instant_camera_clsobj = getattr(self.instant_camera_jclass, "class_", None)
            self.send_messages_helper_clsobj = getattr(self.send_messages_helper_jclass, "class_", None)
            self.reactions_layout_clsobj = getattr(self.reactions_layout_jclass, "class_", None)
        except Exception:
            self.launch_activity_clsobj = None
            self.chat_activity_clsobj = None
            self.base_fragment_clsobj = None
            self.enter_view_clsobj = None
            self.media_controller_clsobj = None
            self.instant_camera_clsobj = None
            self.send_messages_helper_clsobj = None
            self.reactions_layout_clsobj = None

        self._hook_send_message()
        self._hook_send_sticker()
        self._hook_start_record()
        self._hook_stop_record()
        self._hook_start_video()
        self._hook_send_video_message()
        self._hook_open_attach_menu()
        self._hook_send_files()
        self._hook_send_location()
        self._hook_open_emoji()
        self._hook_open_scheduled()
        self._hook_open_search()
        self._hook_reply_set()
        self._hook_bot_commands()
        self._hook_bot_button()
        self._hook_edit_message()
        self._hook_open_pinned()
        self._hook_reaction()
        self._hook_select_reaction()
        self._hook_exit_chat()

    def on_plugin_unload(self):
        for ref in (
            self._send_unhook,
            self._record_unhook,
            self._video_unhook,
            self._stop_record_unhook,
            self._attach_unhook,
            self._emoji_unhook,
            self._scheduled_unhook,
            self._search_unhook,
            self._reply_unhook,
            self._bot_commands_unhook,
            self._bot_button_unhook,
            self._edit_unhook,
            self._pinned_unhook,
            self._reaction_unhook,
            self._reaction_bubble_unhook,
            self._select_reaction_unhook,
            self._send_files_unhook,
            self._send_location_unhook,
            self._video_send_unhook,
            self._sticker_unhook,
            self._exit_unhook,
            self._exit_bool_unhook,
        ):
            if ref:
                try:
                    self.unhook_method(ref)
                except Exception:
                    pass
        self._send_unhook = None
        self._record_unhook = None
        self._video_unhook = None
        self._stop_record_unhook = None
        self._attach_unhook = None
        self._emoji_unhook = None
        self._scheduled_unhook = None
        self._search_unhook = None
        self._reply_unhook = None
        self._bot_commands_unhook = None
        self._bot_button_unhook = None
        self._edit_unhook = None
        self._pinned_unhook = None
        self._reaction_unhook = None
        self._reaction_bubble_unhook = None
        self._select_reaction_unhook = None
        self._send_files_unhook = None
        self._send_location_unhook = None
        self._video_send_unhook = None
        self._sticker_unhook = None
        self._exit_unhook = None
        self._exit_bool_unhook = None

    def _hook_send_message(self):
        enter_owner = self.enter_view_clsobj or self.enter_view_jclass
        if not enter_owner:
            self.log("RippleActions: ChatActivityEnterView not found.")
            return
        method = self._find_method(enter_owner, "sendMessageInternal", param_count=5)
        if method is None:
            method = self._find_method(enter_owner, "sendMessageInternal", param_count=4)
        if method is None:
            self.log("RippleActions: sendMessageInternal not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._send_unhook = self.hook_method(method, _SendMessageHook(self), priority=5)
        if self._send_unhook:
            self.log("RippleActions: Hooked sendMessageInternal.")
        else:
            self.log("RippleActions: Failed to hook sendMessageInternal.")

    def _hook_send_sticker(self):
        helper_owner = self.send_messages_helper_clsobj or self.send_messages_helper_jclass
        if not helper_owner:
            return
        method = self._find_method(helper_owner, "sendSticker", param_count=18)
        if method is None:
            method = self._find_method(helper_owner, "sendSticker")
        if method is None:
            self.log("RippleActions: sendSticker not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._sticker_unhook = self.hook_method(method, _SendStickerHook(self), priority=5)
        if self._sticker_unhook:
            self.log("RippleActions: Hooked SendMessagesHelper.sendSticker.")
        else:
            self.log("RippleActions: Failed to hook SendMessagesHelper.sendSticker.")

    def _hook_start_record(self):
        media_owner = self.media_controller_clsobj or self.media_controller_jclass
        if not media_owner:
            self.log("RippleActions: MediaController not found.")
            return
        method = self._find_method(media_owner, "startRecording", param_count=11)
        if method is None:
            method = self._find_method(media_owner, "startRecording")
        if method is None:
            self.log("RippleActions: startRecording not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._record_unhook = self.hook_method(method, _StartRecordHook(self), priority=5)
        if self._record_unhook:
            self.log("RippleActions: Hooked startRecording.")
        else:
            self.log("RippleActions: Failed to hook startRecording.")

    def _hook_stop_record(self):
        media_owner = self.media_controller_clsobj or self.media_controller_jclass
        if not media_owner:
            return
        method = self._find_method(media_owner, "stopRecording", param_count=5)
        if method is None:
            self.log("RippleActions: stopRecording not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._stop_record_unhook = self.hook_method(method, _StopRecordHook(self), priority=5)
        if self._stop_record_unhook:
            self.log("RippleActions: Hooked stopRecording.")

    def _hook_start_video(self):
        camera_owner = self.instant_camera_clsobj or self.instant_camera_jclass
        if not camera_owner:
            self.log("RippleActions: InstantCameraView not found.")
            return
        method = self._find_method(camera_owner, "showCamera", param_count=1)
        if method is None:
            self.log("RippleActions: InstantCameraView.showCamera not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._video_unhook = self.hook_method(method, _VideoRecordHook(self), priority=5)
        if self._video_unhook:
            self.log("RippleActions: Hooked InstantCameraView.showCamera.")
        else:
            self.log("RippleActions: Failed to hook InstantCameraView.showCamera.")

    def _hook_send_video_message(self):
        camera_owner = self.instant_camera_clsobj or self.instant_camera_jclass
        if not camera_owner:
            return
        method = self._find_method(camera_owner, "send", param_count=7)
        if method is None:
            self.log("RippleActions: InstantCameraView.send not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._video_send_unhook = self.hook_method(method, _VideoSendHook(self), priority=5)
        if self._video_send_unhook:
            self.log("RippleActions: Hooked InstantCameraView.send.")
        else:
            self.log("RippleActions: Failed to hook InstantCameraView.send.")

    def _hook_open_attach_menu(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = None
        try:
            method = chat_owner.getDeclaredMethod("openAttachMenu")
        except Exception:
            try:
                method = chat_owner.getMethod("openAttachMenu")
            except Exception:
                method = None
        if method is None:
            self.log("RippleActions: openAttachMenu not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._attach_unhook = self.hook_method(method, _OpenAttachMenuHook(self), priority=5)
        if self._attach_unhook:
            self.log("RippleActions: Hooked openAttachMenu.")
        else:
            self.log("RippleActions: Failed to hook openAttachMenu.")

    def _hook_send_files(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "didSelectFiles", param_count=10)
        if method is None:
            self.log("RippleActions: didSelectFiles not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._send_files_unhook = self.hook_method(method, _SendFilesHook(self), priority=5)
        if self._send_files_unhook:
            self.log("RippleActions: Hooked didSelectFiles.")

    def _hook_send_location(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "didSelectLocation", param_count=5)
        if method is None:
            self.log("RippleActions: didSelectLocation not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._send_location_unhook = self.hook_method(method, _SendLocationHook(self), priority=5)
        if self._send_location_unhook:
            self.log("RippleActions: Hooked didSelectLocation.")

    def _hook_open_emoji(self):
        enter_owner = self.enter_view_clsobj or self.enter_view_jclass
        if not enter_owner:
            return
        method = self._find_method(enter_owner, "showPopup", param_count=4)
        if method is None:
            method = self._find_method(enter_owner, "showPopup", param_count=2)
        if method is None:
            self.log("RippleActions: showPopup not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._emoji_unhook = self.hook_method(method, _ShowPopupHook(self), priority=5)
        if self._emoji_unhook:
            self.log("RippleActions: Hooked showPopup (emoji).")
        else:
            self.log("RippleActions: Failed to hook showPopup (emoji).")

    def _hook_open_scheduled(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "openScheduledMessages", param_count=0)
        if method is None:
            method = self._find_method(chat_owner, "openScheduledMessages", param_count=2)
        if method is None:
            self.log("RippleActions: openScheduledMessages not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._scheduled_unhook = self.hook_method(method, _OpenScheduledHook(self), priority=5)
        if self._scheduled_unhook:
            self.log("RippleActions: Hooked openScheduledMessages.")

    def _hook_open_search(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "openSearchWithText", param_count=1)
        if method is None:
            self.log("RippleActions: openSearchWithText not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._search_unhook = self.hook_method(method, _OpenSearchHook(self), priority=5)
        if self._search_unhook:
            self.log("RippleActions: Hooked openSearchWithText.")

    def _hook_reply_set(self):
        enter_owner = self.enter_view_clsobj or self.enter_view_jclass
        if not enter_owner or not self.message_object_jclass or not self.reply_quote_jclass:
            return
        method = None
        try:
            method = enter_owner.getDeclaredMethod(
                "setReplyingMessageObject",
                self.message_object_jclass,
                self.reply_quote_jclass,
                self.message_object_jclass,
            )
        except Exception:
            method = None
        if method is None:
            self.log("RippleActions: setReplyingMessageObject not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._reply_unhook = self.hook_method(method, _ReplySetHook(self), priority=5)
        if self._reply_unhook:
            self.log("RippleActions: Hooked setReplyingMessageObject.")

    def _hook_bot_commands(self):
        if not self.bot_commands_jclass:
            return
        method = self._find_method(self.bot_commands_jclass, "setOpened", param_count=1)
        if method is None:
            self.log("RippleActions: BotCommandsMenuView.setOpened not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._bot_commands_unhook = self.hook_method(method, _BotCommandsOpenHook(self), priority=5)
        if self._bot_commands_unhook:
            self.log("RippleActions: Hooked BotCommandsMenuView.setOpened.")

    def _hook_bot_button(self):
        enter_owner = self.enter_view_clsobj or self.enter_view_jclass
        if not enter_owner:
            return
        method = self._find_method(enter_owner, "didPressedBotButton", param_count=4)
        if method is None:
            method = self._find_method(enter_owner, "didPressedBotButton", param_count=3)
        if method is None:
            self.log("RippleActions: didPressedBotButton not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._bot_button_unhook = self.hook_method(method, _BotButtonPressHook(self), priority=5)
        if self._bot_button_unhook:
            self.log("RippleActions: Hooked didPressedBotButton.")

    def _hook_edit_message(self):
        enter_owner = self.enter_view_clsobj or self.enter_view_jclass
        if not enter_owner:
            return
        method = self._find_method(enter_owner, "setEditingMessageObject", param_count=3)
        if method is None:
            self.log("RippleActions: setEditingMessageObject not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._edit_unhook = self.hook_method(method, _EditMessageHook(self), priority=5)
        if self._edit_unhook:
            self.log("RippleActions: Hooked setEditingMessageObject.")

    def _hook_open_pinned(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "openPinnedMessagesList", param_count=1)
        if method is None:
            self.log("RippleActions: openPinnedMessagesList not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._pinned_unhook = self.hook_method(method, _OpenPinnedHook(self), priority=5)
        if self._pinned_unhook:
            self.log("RippleActions: Hooked openPinnedMessagesList.")

    def _hook_reaction(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "didPressReaction", param_count=5)
        if method is None:
            self.log("RippleActions: didPressReaction not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._reaction_unhook = self.hook_method(method, _ReactionHook(self), priority=5)
        if self._reaction_unhook:
            self.log("RippleActions: Hooked didPressReaction.")

        layout_owner = self.reactions_layout_clsobj or self.reactions_layout_jclass
        if not layout_owner:
            return
        layout_method = self._find_method(layout_owner, "didPressReaction", param_count=4)
        if layout_method is None:
            self.log("RippleActions: ReactionsLayoutInBubble.didPressReaction not found.")
            return
        try:
            layout_method.setAccessible(True)
        except Exception:
            pass
        self._reaction_bubble_unhook = self.hook_method(layout_method, _ReactionBubbleHook(self), priority=5)
        if self._reaction_bubble_unhook:
            self.log("RippleActions: Hooked ReactionsLayoutInBubble.didPressReaction.")

    def _hook_select_reaction(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            return
        method = self._find_method(chat_owner, "selectReaction", param_count=11)
        if method is None:
            self.log("RippleActions: selectReaction not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._select_reaction_unhook = self.hook_method(method, _SelectReactionHook(self), priority=5)
        if self._select_reaction_unhook:
            self.log("RippleActions: Hooked selectReaction.")

    def _hook_exit_chat(self):
        chat_owner = self.chat_activity_clsobj or self.chat_activity_jclass
        if not chat_owner:
            self.log("RippleActions: ChatActivity not found.")
            return
        method = None
        try:
            method = chat_owner.getDeclaredMethod("finishFragment")
        except Exception:
            try:
                method = chat_owner.getMethod("finishFragment")
            except Exception:
                method = None
        if method is None:
            self.log("RippleActions: finishFragment not found.")
            return
        try:
            method.setAccessible(True)
        except Exception:
            pass
        self._exit_unhook = self.hook_method(method, _ExitChatHook(self), priority=5)
        if self._exit_unhook:
            self.log("RippleActions: Hooked ChatActivity.finishFragment.")
        else:
            self.log("RippleActions: Failed to hook ChatActivity.finishFragment.")

        base_owner = self.base_fragment_clsobj or self.base_fragment_jclass
        if not base_owner:
            return
        method_bool = None
        try:
            method_bool = base_owner.getDeclaredMethod("finishFragment", JBoolean.TYPE)
        except Exception:
            try:
                method_bool = base_owner.getMethod("finishFragment", JBoolean.TYPE)
            except Exception:
                method_bool = None
        if method_bool is None:
            return
        try:
            method_bool.setAccessible(True)
        except Exception:
            pass
        self._exit_bool_unhook = self.hook_method(method_bool, _ExitChatBoolHook(self), priority=5)
        if self._exit_bool_unhook:
            self.log("RippleActions: Hooked BaseFragment.finishFragment(boolean).")

    def _find_method(self, owner: Any, name: str, param_count: Optional[int] = None):
        try:
            methods = owner.getDeclaredMethods()
            for m in methods:
                try:
                    if m.getName() != name:
                        continue
                    if param_count is not None and len(m.getParameterTypes()) != param_count:
                        continue
                    return m
                except Exception:
                    continue
        except Exception:
            pass
        return None

    def _on_send_message(self, enter_view: Any):
        if not self._cached_action_send:
            return
        target_view = None
        try:
            target_view = enter_view.getSendButton()
        except Exception:
            target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_send_sticker(self):
        if not self._cached_action_send_sticker:
            return
        enter_view = self._get_enter_view()
        self._trigger_ripple(None, fallback_view=enter_view)

    def _on_start_record(self):
        if not self._cached_action_record:
            return
        enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getRecordCircle()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_send_record(self):
        if not self._cached_action_record_send:
            return
        enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getRecordCircle()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_start_video(self):
        if not self._cached_action_video:
            return
        enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getRecordCircle()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_send_video_message(self, camera_view: Any):
        if not self._cached_action_video_send:
            return
        enter_view = self._get_enter_view()
        self._trigger_ripple(camera_view, fallback_view=enter_view)

    def _on_open_attach_menu(self, chat_activity: Any):
        if not self._cached_action_attach:
            return
        enter_view = None
        try:
            enter_view = getattr(chat_activity, "chatActivityEnterView", None)
        except Exception:
            enter_view = None
        if not enter_view:
            enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getAttachButton()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_send_files(self, chat_activity: Any):
        if not self._cached_action_send_files:
            return
        enter_view = None
        try:
            enter_view = getattr(chat_activity, "chatActivityEnterView", None)
        except Exception:
            enter_view = None
        if not enter_view:
            enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getAttachButton()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_send_location(self, chat_activity: Any):
        if not self._cached_action_send_location:
            return
        enter_view = None
        try:
            enter_view = getattr(chat_activity, "chatActivityEnterView", None)
        except Exception:
            enter_view = None
        if not enter_view:
            enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getAttachButton()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_open_emoji(self, enter_view: Any):
        if not self._cached_action_emoji:
            return
        target_view = None
        try:
            target_view = enter_view.getEmojiButton()
        except Exception:
            target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_open_bot_keyboard(self, enter_view: Any):
        if not self._cached_action_bot_keyboard:
            return
        self._trigger_ripple(None, fallback_view=enter_view)

    def _on_open_scheduled(self, chat_activity: Any):
        if not self._cached_action_scheduled:
            return
        target_view = None
        try:
            target_view = getattr(chat_activity, "actionBar", None)
        except Exception:
            target_view = None
        self._trigger_ripple(target_view)

    def _on_open_search(self, chat_activity: Any):
        if not self._cached_action_search:
            return
        target_view = None
        try:
            target_view = getattr(chat_activity, "actionBar", None)
        except Exception:
            target_view = None
        self._trigger_ripple(target_view)

    def _on_stop_record(self):
        if not self._cached_action_record_stop:
            return
        enter_view = self._get_enter_view()
        target_view = None
        if enter_view:
            try:
                target_view = enter_view.getRecordCircle()
            except Exception:
                target_view = None
        self._trigger_ripple(target_view, fallback_view=enter_view)

    def _on_reply_set(self, enter_view: Any):
        if not self._cached_action_reply:
            return
        self._trigger_ripple(None, fallback_view=enter_view)

    def _on_bot_commands_open(self, view: Any):
        if not self._cached_action_bot_commands:
            return
        self._trigger_ripple(view)

    def _on_bot_button(self, enter_view: Any):
        if not self._cached_action_bot_button:
            return
        self._trigger_ripple(None, fallback_view=enter_view)

    def _on_edit_message(self, enter_view: Any):
        if not self._cached_action_edit:
            return
        self._trigger_ripple(None, fallback_view=enter_view)

    def _on_open_pinned(self, chat_activity: Any):
        if not self._cached_action_pinned:
            return
        target_view = None
        try:
            target_view = getattr(chat_activity, "pinnedListButton", None)
        except Exception:
            target_view = None
        if not target_view:
            try:
                target_view = getattr(chat_activity, "actionBar", None)
            except Exception:
                target_view = None
        self._trigger_ripple(target_view)

    def _on_reaction(self, view: Any, x: Optional[float], y: Optional[float], chosen: Optional[bool]):
        if not self._cached_action_reaction:
            return
        if chosen:
            return
        if view is not None and x is not None and y is not None:
            coords = self._get_view_origin(view)
            if coords:
                self._trigger_ripple_at(coords[0] + x, coords[1] + y)
                return
        self._trigger_ripple(view)

    def _on_reaction_bubble(self, layout: Any, x: Optional[float], y: Optional[float], chosen: Optional[bool]):
        if not self._cached_action_reaction:
            return
        if chosen:
            return
        parent_view = None
        try:
            parent_view = get_private_field(layout, "parentView")
        except Exception:
            parent_view = None
        if not parent_view:
            try:
                parent_view = getattr(layout, "parentView", None)
            except Exception:
                parent_view = None
        if parent_view is not None and x is not None and y is not None:
            coords = self._get_view_origin(parent_view)
            if coords:
                self._trigger_ripple_at(coords[0] + x, coords[1] + y)
                return
        self._trigger_ripple(parent_view)

    def _on_select_reaction(self, cell: Any, message: Any, reactions_layout: Any, from_view: Any, visible_reaction: Any):
        if not self._cached_action_reaction:
            return
        if reactions_layout is None and from_view is None:
            return
        if message is None or visible_reaction is None:
            return
        if self._is_reaction_chosen(message, visible_reaction):
            return
        target_view = from_view or cell
        self._trigger_ripple(target_view)

    def _on_exit_chat(self, chat_activity: Any):
        if not self._cached_action_exit:
            return
        target_view = None
        try:
            target_view = getattr(chat_activity, "actionBar", None)
        except Exception:
            target_view = None
        self._trigger_ripple(target_view)

    def _is_chat_activity(self, obj: Any) -> bool:
        try:
            name = obj.getClass().getName()
            return bool(name) and name.endswith("ChatActivity")
        except Exception:
            return False

    def _get_enter_view(self) -> Optional[Any]:
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, "getChatActivityEnterView"):
                return fragment.getChatActivityEnterView()
        except Exception:
            pass
        return None

    def _trigger_ripple(self, target_view: Any, fallback_view: Any = None) -> None:
        intensity = float(self._cached_intensity or 0.0)
        if intensity <= 0:
            return

        def _do():
            view = target_view or fallback_view or self._get_root_view()
            coords = self._get_view_center(view) if view else None
            if not coords:
                return
            x, y = coords
            self._invoke_ripple(x, y, intensity)
            try:
                activity = self._get_activity()
                if activity:
                    self._perform_vibration(activity, intensity)
                elif view:
                    self._perform_vibration(view, intensity)
            except Exception:
                pass

        run_on_ui_thread(_do)

    def _trigger_ripple_at(self, x: float, y: float) -> None:
        intensity = float(self._cached_intensity or 0.0)
        if intensity <= 0:
            return

        def _do():
            self._invoke_ripple(float(x), float(y), intensity)
            try:
                activity = self._get_activity()
                if activity:
                    self._perform_vibration(activity, intensity)
                else:
                    view = self._get_root_view()
                    if view:
                        self._perform_vibration(view, intensity)
            except Exception:
                pass

        run_on_ui_thread(_do)

    def _get_activity(self) -> Optional[Any]:
        try:
            fragment = get_last_fragment()
            if fragment:
                return fragment.getParentActivity()
        except Exception:
            pass
        return None

    def _get_root_view(self) -> Optional[Any]:
        try:
            activity = self._get_activity()
            if not activity:
                return None
            window = activity.getWindow()
            if window:
                return window.getDecorView()
        except Exception:
            pass
        return None

    def _get_view_center(self, view: Any) -> Optional[tuple]:
        if view is None:
            return None
        try:
            coords = view.getLocationOnScreen()
            w = float(view.getWidth() or view.getMeasuredWidth() or 0)
            h = float(view.getHeight() or view.getMeasuredHeight() or 0)
            if not coords or len(coords) < 2:
                return None
            x = float(coords[0]) + (w / 2.0 if w > 0 else 0.0)
            y = float(coords[1]) + (h / 2.0 if h > 0 else 0.0)
            return (x, y)
        except Exception:
            return None

    def _get_view_origin(self, view: Any) -> Optional[tuple]:
        if view is None:
            return None
        try:
            coords = view.getLocationOnScreen()
            if not coords or len(coords) < 2:
                return None
            return (float(coords[0]), float(coords[1]))
        except Exception:
            return None

    def _invoke_ripple(self, x: float, y: float, intensity: float):
        try:
            try:
                if getattr(self, "_make_ripple_static", None):
                    self._make_ripple_static(float(x), float(y), float(intensity))
                    return
            except Exception:
                pass
            method = None
            try:
                owner = self.launch_activity_clsobj or self.launch_activity_jclass
                method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
            except Exception:
                try:
                    methods = (self.launch_activity_clsobj or self.launch_activity_jclass).getDeclaredMethods()
                    for m in methods:
                        try:
                            if m.getName() != "makeRipple":
                                continue
                            if len(m.getParameterTypes()) == 3:
                                method = m
                                break
                        except Exception:
                            method = m
                            break
                except Exception:
                    method = None
            if method:
                try:
                    method.setAccessible(True)
                except Exception:
                    pass
                method.invoke(None, JFloat(x), JFloat(y), JFloat(intensity))
        except Exception as e:
            self.log(f"RippleActions: makeRipple invoke error: {e}")

    def _map_haptic_constant(self, strength_idx: int) -> int:
        try:
            HFC = JClass.forName("android.view.HapticFeedbackConstants")
            if strength_idx <= 0:
                return getattr(HFC, "KEYBOARD_TAP", getattr(HFC, "VIRTUAL_KEY", 1))
            if strength_idx == 1:
                return getattr(HFC, "VIRTUAL_KEY", getattr(HFC, "KEYBOARD_TAP", 1))
            return getattr(HFC, "LONG_PRESS", getattr(HFC, "VIRTUAL_KEY", 1))
        except Exception:
            return 1

    def _map_amplitude(self, strength_idx: int, intensity: float) -> int:
        try:
            mult = 0.4 if strength_idx <= 0 else (0.7 if strength_idx == 1 else 1.0)
            scaled = abs(float(intensity)) * mult
            amp = int(round(255 * scaled))
            if amp < 1:
                amp = 1
            if amp > 255:
                amp = 255
            return amp
        except Exception:
            return 120

    def _perform_vibration(self, activity: Any, intensity: float) -> None:
        if not self._cached_vibration_enabled:
            return
        try:
            if self._cached_vibration_engine == 0:
                try:
                    if hasattr(activity, "performHapticFeedback"):
                        const_val = self._map_haptic_constant(self._cached_vibration_strength)
                        activity.performHapticFeedback(const_val)
                        return
                except Exception:
                    pass
                try:
                    view = None
                    try:
                        window = activity.getWindow()
                        if window:
                            view = window.getDecorView()
                    except Exception:
                        view = None
                    if view:
                        const_val = self._map_haptic_constant(self._cached_vibration_strength)
                        view.performHapticFeedback(const_val)
                        return
                except Exception:
                    pass
            try:
                vibrator = activity.getSystemService("vibrator")
            except Exception:
                vibrator = None
            if vibrator is None:
                return
            duration = int(self._cached_vibration_duration_ms or 20)
            if duration < 1:
                duration = 10
            amp = self._map_amplitude(self._cached_vibration_strength, intensity)
            try:
                version = JClass.forName("android.os.Build$VERSION")
                sdk_int = int(getattr(version, "SDK_INT", 26))
            except Exception:
                sdk_int = 26
            if sdk_int >= 26:
                try:
                    VibrationEffect = JClass.forName("android.os.VibrationEffect")
                    DEFAULT_AMP = getattr(VibrationEffect, "DEFAULT_AMPLITUDE", -1)
                    effect = VibrationEffect.createOneShot(duration, amp if amp > 0 else DEFAULT_AMP)
                    vibrator.vibrate(effect)
                    return
                except Exception:
                    pass
            try:
                vibrator.vibrate(duration)
            except Exception:
                pass
        except Exception as e:
            try:
                self.log(f"RippleActions: vibration error: {e}")
            except Exception:
                pass

    def _refresh_settings_cache(self):
        self._cached_action_send = self._as_bool(self.get_setting("action_send", True))
        self._cached_action_send_sticker = self._as_bool(self.get_setting("action_send_sticker", True))
        self._cached_action_send_files = self._as_bool(self.get_setting("action_send_files", True))
        self._cached_action_send_location = self._as_bool(self.get_setting("action_send_location", False))
        self._cached_action_record = self._as_bool(self.get_setting("action_record", True))
        self._cached_action_record_send = self._as_bool(self.get_setting("action_record_send", True))
        self._cached_action_video = self._as_bool(self.get_setting("action_video", True))
        self._cached_action_video_send = self._as_bool(self.get_setting("action_video_send", True))
        self._cached_action_attach = self._as_bool(self.get_setting("action_attach", True))
        self._cached_action_emoji = self._as_bool(self.get_setting("action_emoji", True))
        self._cached_action_bot_keyboard = self._as_bool(self.get_setting("action_bot_keyboard", False))
        self._cached_action_record_stop = self._as_bool(self.get_setting("action_record_stop", False))
        self._cached_action_bot_commands = self._as_bool(self.get_setting("action_bot_commands", False))
        self._cached_action_bot_button = self._as_bool(self.get_setting("action_bot_button", False))
        self._cached_action_reply = self._as_bool(self.get_setting("action_reply", False))
        self._cached_action_edit = self._as_bool(self.get_setting("action_edit", False))
        self._cached_action_scheduled = self._as_bool(self.get_setting("action_scheduled", False))
        self._cached_action_search = self._as_bool(self.get_setting("action_search", False))
        self._cached_action_pinned = self._as_bool(self.get_setting("action_pinned", False))
        self._cached_action_reaction = self._as_bool(self.get_setting("action_reaction", False))
        self._cached_action_exit = self._as_bool(self.get_setting("action_exit", True))
        try:
            self._cached_intensity = self._as_float(self.get_setting("intensity", "1.0"), 1.0)
        except Exception:
            self._cached_intensity = 1.0
        if self._cached_intensity < 0.05:
            self._cached_intensity = 0.05
        if self._cached_intensity > 3.0:
            self._cached_intensity = 3.0
        try:
            vib_enabled_val = self.get_setting("vibration_enabled", True)
            if isinstance(vib_enabled_val, bool):
                self._cached_vibration_enabled = vib_enabled_val
            else:
                s = str(vib_enabled_val).strip().lower()
                self._cached_vibration_enabled = s in ("1", "true", "yes", "on")
        except Exception:
            self._cached_vibration_enabled = True
        try:
            self._cached_vibration_engine = int(self.get_setting("vibration_engine", 0))
        except Exception:
            self._cached_vibration_engine = 0
        try:
            self._cached_vibration_strength = int(self.get_setting("vibration_strength", 1))
        except Exception:
            self._cached_vibration_strength = 1
        try:
            self._cached_vibration_duration_ms = int(float(self.get_setting("vibration_duration_ms", "20")))
        except Exception:
            self._cached_vibration_duration_ms = 20

    def _as_bool(self, value: Any) -> bool:
        if isinstance(value, bool):
            return value
        try:
            s = str(value).strip().lower()
            return s in ("1", "true", "yes", "on")
        except Exception:
            return False

    def _as_float(self, s: Any, default: float) -> float:
        try:
            return float(str(s).strip().replace(",", "."))
        except Exception:
            return default

    def _is_reaction_chosen(self, message: Any, visible_reaction: Any) -> bool:
        try:
            chosen = message.getChoosenReactions()
            try:
                return bool(chosen.contains(visible_reaction))
            except Exception:
                pass
            size = int(chosen.size()) if chosen is not None else 0
            for i in range(size):
                try:
                    item = chosen.get(i)
                    if item and item.equals(visible_reaction):
                        return True
                except Exception:
                    continue
        except Exception:
            return False
        return False

    def create_settings(self) -> List[Any]:
        def _on_any_change(_):
            try:
                self._refresh_settings_cache()
            except Exception:
                pass

        vib_engine_default = int(self.get_setting("vibration_engine", 0))
        vib_duration_default = str(self.get_setting("vibration_duration_ms", "20"))

        settings = [
            Header(text="Ripple Actions"),
            Switch(key="action_send", text="Send message", default=True, icon="msg_send", on_change=_on_any_change),
            Switch(key="action_send_sticker", text="Send sticker / GIF", default=True, icon="media_sticker_stroke", on_change=_on_any_change),
            Switch(key="action_send_files", text="Send file", default=True, icon="msg_sendfile_solar", on_change=_on_any_change),
            Switch(key="action_send_location", text="Send location", default=False, icon="msg_map_type_solar", on_change=_on_any_change),
            Switch(key="action_record", text="Start voice recording", default=True, icon="input_mic", on_change=_on_any_change),
            Switch(key="action_record_send", text="Send voice message", default=True, icon="send_plane_24", on_change=_on_any_change),
            Switch(key="action_record_stop", text="Cancel recording", default=False, icon="msg_tabs_mic2", on_change=_on_any_change),
            Switch(key="action_video", text="Start video recording", default=True, icon="msg_videocall", on_change=_on_any_change),
            Switch(key="action_video_send", text="Send video message", default=True, icon="msg_video", on_change=_on_any_change),
            Switch(key="action_attach", text="Open attach menu", default=True, icon="msg_input_attach2", on_change=_on_any_change),
            Switch(key="action_emoji", text="Open emoji panel", default=True, icon="input_smile", on_change=_on_any_change),
            Switch(key="action_bot_keyboard", text="Open bot keyboard", default=False, icon="input_bot1", on_change=_on_any_change),
            Switch(key="action_bot_commands", text="Open bot commands", default=False, icon="msg_bot", on_change=_on_any_change),
            Switch(key="action_bot_button", text="Press bot button", default=False, icon="msg_bot", on_change=_on_any_change),
            Switch(key="action_reply", text="Reply", default=False, icon="menu_select_quote", on_change=_on_any_change),
            Switch(key="action_edit", text="Edit message", default=False, icon="msg_edit", on_change=_on_any_change),
            Switch(key="action_scheduled", text="Open scheduled", default=False, icon="msg_calendar2_solar", on_change=_on_any_change),
            Switch(key="action_search", text="Open search", default=False, icon="msg_search", on_change=_on_any_change),
            Switch(key="action_pinned", text="Open pinned list", default=False, icon="msg_pin", on_change=_on_any_change),
            Switch(key="action_reaction", text="React to message", default=False, icon="msg_reactions", on_change=_on_any_change),
            Switch(key="action_exit", text="Exit chat", default=True, icon="ic_ab_back", on_change=_on_any_change),
            Divider(),
            Header(text="Effect"),
            Input(key="intensity", text="Intensity (0.05..3.0)", default=str(self.get_setting("intensity", "1.0")), icon="msg_brightness_high", on_change=_on_any_change),
            Switch(key="vibration_enabled", text="Enable vibration", default=self.get_setting("vibration_enabled", True), icon="media_like_active_solar", on_change=_on_any_change),
            Selector(key="vibration_engine", text="Engine", default=vib_engine_default, items=["System haptics", "Vibrator"], icon="msg_settings", on_change=_on_any_change),
            Selector(key="vibration_strength", text="Vibration strength", default=int(self.get_setting("vibration_strength", 1)), items=["Light", "Medium", "Heavy"], icon="msg_brightness_high", on_change=_on_any_change),
        ]
        if vib_engine_default != 0:
            settings.append(Input(key="vibration_duration_ms", text="Duration (ms / for vibrator)", default=vib_duration_default, icon="msg_calendar2", on_change=_on_any_change))
        return settings
