from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Text, Switch, Input
from markdown_utils import parse_markdown
from client_utils import log as _android_log, get_messages_controller, get_file_loader, get_last_fragment, get_messages_storage, run_on_queue, send_request
from android_utils import run_on_ui_thread
from org.telegram.messenger import AndroidUtilities
import sys
import traceback
import re
import random
import threading
import time
import json
import os
import inspect
import logging
from typing import List, Optional, Any, Callable, Dict, Union
from dataclasses import dataclass, field

try:
    from java.util import ArrayList
    from org.telegram.tgnet import TLRPC
    from org.telegram.ui import ChatActivity
    from org.telegram.messenger import FileLoader, R, Utilities
    from com.exteragram.messenger.plugins import PluginsController, Plugin
except ImportError:
    ArrayList = list

__name__ = "Dont65 Lib"
__description__ = "üìö –Ø–¥—Ä–æ –¥–ª—è –ø–ª–∞–≥–∏–Ω–æ–≤ @dont65. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Markdown, –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ, –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –æ–±—â–∏–π .help"
__icon__ = "random69_by_TgEmojiBot/123"
__version__ = "2.0.0"
__id__ = "dont65_lib"
__author__ = "@dont65"

# ----------------------------------------------------------------------
#  –ö–û–ù–°–¢–ê–ù–¢–´ (–≤—ã–Ω–µ—Å–µ–Ω—ã –≤ –Ω–∞—á–∞–ª–æ, —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –ø–ª–∞–≥–∏–Ω–∞)
# ----------------------------------------------------------------------
AUTOUPDATE_CHANNEL_ID = 3624287619          # @dontplugin
AUTOUPDATE_MSG_ID = 10                      # ‚ö†Ô∏è –ó–ê–ú–ï–ù–ò–¢–ï –ù–ê –†–ï–ê–õ–¨–ù–´–ô ID –ü–û–°–¢–ê –° –ë–ò–ë–õ–ò–û–¢–ï–ö–û–ô!
PLUGINS_DIR = PluginsController.getInstance().pluginsDir.getAbsolutePath() if 'PluginsController' in dir() else "."
CACHE_DIR = os.path.join(PLUGINS_DIR, "dont65_cache")
os.makedirs(CACHE_DIR, exist_ok=True)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–ª–∞–≥–∏–Ω–∞)
_setting_getter: Optional[Callable] = None
_autoupdater: Optional["AutoUpdater"] = None

# ----------------------------------------------------------------------
#  –û–°–ù–û–í–ù–û–ô –ü–õ–ê–ì–ò–ù ‚Äì –ü–ï–†–í–´–ô –ö–õ–ê–°–°!
# ----------------------------------------------------------------------
class Dont65Lib(BasePlugin):
    def __init__(self):
        super().__init__()
        # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –¥–ª—è –æ–±—â–µ–≥–æ —Ö–µ–ª–ø–∞
        self.known_plugins = {
            "dont65_multitool": {
                "name": "üß∞ MultiTool",
                "commands": [
                    ("`.id`", "–∏–Ω—Ñ–æ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏ (—Ä–µ–ø–ª–∞–π)"),
                    ("`.layout`", "—Å–º–µ–Ω–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ (—Ä–µ–ø–ª–∞–π/—Ç–µ–∫—Å—Ç)"),
                    ("`.calc`", "–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä"),
                    ("`.symbols`", "—Å—á–µ—Ç—á–∏–∫ —Å–∏–º–≤–æ–ª–æ–≤ –∏ —Å–ª–æ–≤"),
                    ("`.rev`", "–ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å —Ç–µ–∫—Å—Ç –∑–∞–¥–æ–º –Ω–∞–ø–µ—Ä–µ–¥"),
                    ("`.translit`", "–ø–µ—Ä–µ–≤–æ–¥ –≤ –ª–∞—Ç–∏–Ω–∏—Ü—É –∏ –æ–±—Ä–∞—Ç–Ω–æ"),
                    ("`.upper`", "—Å–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç –ó–ê–ì–õ–ê–í–ù–´–ú"),
                    ("`.lower`", "—Å–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç —Å—Ç—Ä–æ—á–Ω—ã–º"),
                    ("`.tglink`", "—Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"),
                    ("`.time`", "—É–∑–Ω–∞—Ç—å —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è"),
                    ("`.date`", "—Ç–µ–∫—É—â–∞—è –¥–∞—Ç–∞ –∏ –≤—Ä–µ–º—è (–ª–æ–∫–∞–ª—å–Ω–æ–µ)"),
                    ("`.swap`", "—Å–º–µ–Ω–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–π")
                ]
            },
            "dont65_currency": {
                "name": "üí± Currency",
                "commands": [
                    ("`.curs [–∫–æ–ª-–≤–æ] [–≤–∞–ª—é—Ç–∞]`", "–∫—É—Ä—Å –º–æ–Ω–µ—Ç—ã –∫–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º"),
                    ("`.curs [–≤–∞–ª—é—Ç–∞] [–≤–∞–ª—é—Ç–∞]`", "–∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã")
                ]
            },
            "dont65_dice_roller": {
                "name": "üé≤ Dice Roller",
                "commands": [
                    ("`.roll`", "—Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 100"),
                    ("`.roll [max]`", "—Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –¥–æ –º–∞–∫—Å–∏–º—É–º–∞"),
                    ("`.roll [min] [max]`", "—á–∏—Å–ª–æ –≤ –≤–∞—à–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ")
                ]
            },
            "dont65textreplacer": {
                "name": "üìù Replacer",
                "commands": [
                    ("`–≤–∞—à–∏ –∫–æ–º–∞–Ω–¥—ã`", "–∞–≤—Ç–æ–∑–∞–º–µ–Ω–∞ (–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –≤ –º–µ–Ω—é)")
                ]
            },
            "dont65_weather": {
                "name": "üå§ Weather Monitor",
                "commands": [
                    ("`.weather [–≥–æ—Ä–æ–¥]`", "–ø–æ–≥–æ–¥–∞ –∏ –º–∞–≥–Ω–∏—Ç–Ω—ã–µ –±—É—Ä–∏"),
                    ("`.weather`", "–ø–æ–≥–æ–¥–∞ –≤ –≥–æ—Ä–æ–¥–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
                ]
            }
        }
        # –õ–æ–≥–≥–µ—Ä—ã —Å–æ–∑–¥–∞–¥–∏–º –≤ on_plugin_load, —á—Ç–æ–±—ã –∏–º–µ—Ç—å –¥–æ—Å—Ç—É–ø –∫ get_setting
        self.logger = None
        self.cmd_logger = None

    # ---------- –ù–ê–°–¢–†–û–ô–ö–ò ----------
    def create_settings(self):
        # –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç self.logger, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤ –∫ –º–æ–º–µ–Ω—Ç—É –≤—ã–∑–æ–≤–∞)
        def force_update(_):
            if _autoupdater:
                _autoupdater.forced_check = True
                if self.logger:
                    self.logger.info("Forced update triggered")
            else:
                if self.logger:
                    self.logger.info("AutoUpdater not ready")

        return [
            Header("Dont65 Library"),
            Divider(text="–û—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–µ —è–¥—Ä–æ –¥–ª—è –ø–ª–∞–≥–∏–Ω–æ–≤ @dont65."),

            # --- –ö–ù–û–ü–ö–ê-–°–°–´–õ–ö–ê –ù–ê –ö–ê–ù–ê–õ ---
            Text(
                text="–ö–∞–Ω–∞–ª —Å–æ–∑–¥–∞—Ç–µ–ª–µ–π",
                icon="msg_channel",
                accent=False,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("dontplugin", get_last_fragment(), 1))
            ),
            Divider(),

            # --- –°–µ–∫—Ü–∏—è –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ---
            Header("‚öôÔ∏è –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–≥–∏–Ω–æ–≤"),
            Text("üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–µ–π—á–∞—Å", icon="msg_photo_switch2", on_click=force_update),
            Input(
                key="autoupdate_timeout",
                text="–¢–∞–π–º–∞—É—Ç –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Å–µ–∫)",
                subtext="–ß–∞—Å—Ç–æ—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π",
                default="600",
                icon="msg2_autodelete"
            ),
            Switch(
                key="disable_autoupdate",
                text="–û—Ç–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ",
                subtext="–í—Å–µ –∑–∞–¥–∞—á–∏ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –±—É–¥—É—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã",
                default=False,
                icon="msg_download",
                on_change=lambda enabled: _autoupdater.force_stop() if enabled else run_on_ui_thread(_autoupdater.run)
            ),
            Switch(
                key="disable_ts_check",
                text="–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–∞—Ç—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è",
                subtext="–û–±–Ω–æ–≤–ª—è—Ç—å –¥–∞–∂–µ –µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –º–µ–Ω—è–ª—Å—è",
                default=False,
                icon="msg_recent"
            ),
            Divider(),

            # --- –°–µ–∫—Ü–∏—è –æ—Ç–ª–∞–¥–∫–∏ ---
            Header("üõ† –û—Ç–ª–∞–¥–∫–∞"),
            Switch(
                key="debug_mode",
                text="–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏",
                subtext="–ü–æ–¥—Ä–æ–±–Ω—ã–µ –ª–æ–≥–∏ –≤ –∫–æ–Ω—Å–æ–ª–∏",
                default=False,
                icon="msg_log"
                # on_change —É–±—Ä–∞–ª–∏ ‚Äì —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–≥–µ—Ä–∞ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –≤ on_plugin_load –∏ –ø—Ä–∏ –∫–∞–∂–¥–æ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–∏
            ),

            # --- –°–¢–ê–†–´–ï –ù–ê–°–¢–†–û–ô–ö–ò ---
            Switch(key="enable_help", text="–í–∫–ª—é—á–∏—Ç—å –∫–æ–º–∞–Ω–¥—É .help", default=True),
            Divider(),
            Text(
                text = "–ê–≤—Ç–æ—Ä: @dont65", 
                accent=False,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("dont65", get_last_fragment(), 1))
                )
        ]

    # ---------- –ó–ê–ì–†–£–ó–ö–ê / –í–´–ì–†–£–ó–ö–ê ----------
    def on_plugin_load(self):
        global _setting_getter, _autoupdater
        _setting_getter = self.get_setting

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–æ–≤ —Å —É—á—ë—Ç–æ–º debug_mode
        self.logger = self._build_logger(__name__)
        self.cmd_logger = self._build_logger(f"{__name__}.commands")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–æ–≥–≥–µ—Ä—ã –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ —É—Ç–∏–ª–∏—Ç
        global logger, cmd_logger
        logger = self.logger
        cmd_logger = self.cmd_logger

        # –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω–µ –æ—Ç–∫–ª—é—á–µ–Ω–æ)
        if not _setting_getter("disable_autoupdate", False):
            _autoupdater = AutoUpdater(self.logger)  # –ø–µ—Ä–µ–¥–∞—ë–º –ª–æ–≥–≥–µ—Ä
            _autoupdater.add_task(UpdaterTask(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID))
            _autoupdater.run()
            self.logger.info("AutoUpdater initialized")

        self.add_on_send_message_hook(priority=100)
        self.logger.info("Plugin loaded")

    def on_plugin_unload(self):
        if _autoupdater:
            _autoupdater.force_stop()
        if self.logger:
            self.logger.info("Plugin unloaded")

    # ---------- –•–£–ö –°–û–û–ë–©–ï–ù–ò–ô ----------
    def on_send_message_hook(self, account, params):
        msg = getattr(params, 'message', '') or getattr(params, 'caption', '')
        if msg.lower().strip() == ".help" and self.get_setting("enable_help", True):
            lines = ["üõ† **Dont65 Plugins Hub**", ""]
            for p_id, info in self.known_plugins.items():
                installed = p_id in sys.modules
                status = "‚úÖ" if installed else "‚ùå"
                lines.append(f"**{info['name']}** {status}")
                if installed:
                    for cmd, desc in info['commands']:
                        lines.append(f"{cmd} ‚Äî {desc}")
                else:
                    lines.append("–ü–ª–∞–≥–∏–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω ‚ùå")
                lines.append("")
            return HookResult(
                strategy=HookStrategy.MODIFY_FINAL,
                params=Dont65Utils.apply_markdown(params, "\n".join(lines))
            )
        return HookResult()

    # ---------- –í–ù–£–¢–†–ï–ù–ù–ò–ô –ú–ï–¢–û–î –î–õ–Ø –°–û–ó–î–ê–ù–ò–Ø –õ–û–ì–ì–ï–†–ê ----------
    def _build_logger(self, name: str) -> logging.Logger:
        """–°–æ–∑–¥–∞—ë—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–π –ª–æ–≥–≥–µ—Ä —Å –∑–∞–ø–∏—Å—å—é –≤ android log."""
        class Dont65Logger(logging.Logger):
            def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False, stacklevel=1):
                caller = inspect.stack()[2]
                func = caller.function
                level_name = logging.getLevelName(level).upper()
                prefix = " ".join(filter(None, [f"[{level_name}]", self.name, f"[{func}]"]))
                try:
                    formatted = str(msg) % args if args else str(msg)
                except:
                    formatted = f"{msg} {' '.join(map(str, args))}" if args else str(msg)
                _android_log(f"{prefix} {formatted}")

        log = Dont65Logger(name)
        # –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ—Ä—ë–º –∏–∑ —Ç–µ–∫—É—â–µ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        debug_mode = self.get_setting("debug_mode", False)
        log.setLevel(logging.DEBUG if debug_mode else logging.INFO)
        return log


# ----------------------------------------------------------------------
#  –ì–õ–û–ë–ê–õ–¨–ù–´–ï –õ–û–ì–ì–ï–†–´ (–±—É–¥—É—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–ª–∞–≥–∏–Ω–∞)
# ----------------------------------------------------------------------
logger: logging.Logger = None
cmd_logger: logging.Logger = None


# ----------------------------------------------------------------------
#  –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ö–õ–ê–°–°–´ (–ò–î–£–¢ –°–†–ê–ó–£ –ü–û–°–õ–ï –ü–õ–ê–ì–ò–ù–ê)
# ----------------------------------------------------------------------
class CacheFile:
    def __init__(self, filename: str, read_on_init=True):
        self.filename = filename
        self.path = os.path.join(CACHE_DIR, filename)
        self._content: Optional[bytes] = None
        if read_on_init:
            self.read()

    def read(self):
        if not os.path.exists(self.path):
            self._content = None
            return
        try:
            with open(self.path, "rb") as f:
                self._content = f.read()
        except Exception:
            self._content = None

    def write(self):
        if self._content is None:
            return
        try:
            with open(self.path, "wb") as f:
                f.write(self._content)
        except Exception:
            pass

    def wipe(self):
        self._content = None
        self.write()

    def delete(self):
        if os.path.exists(self.path):
            os.remove(self.path)

    @property
    def content(self) -> Optional[bytes]:
        return self._content

    @content.setter
    def content(self, value: Optional[bytes]):
        self._content = value


class JsonCacheFile(CacheFile):
    def __init__(self, filename: str, default: Any, read_on_init=True):
        self._default = default
        self.json_content = default
        super().__init__(filename, read_on_init)

    def read(self):
        super().read()
        if not self._content:
            self.json_content = self._default
            self._content = json.dumps(self.json_content).encode()
            return
        try:
            self.json_content = json.loads(self._content.decode("utf-8", errors="replace"))
        except (UnicodeDecodeError, json.JSONDecodeError):
            self.json_content = self._default

    def write(self):
        self._content = json.dumps(self.json_content).encode("utf-8", errors="replace")
        super().write()

    @property
    def content(self) -> Any:
        return self.json_content

    @content.setter
    def content(self, value: Any):
        self.json_content = value


@dataclass
class UpdaterTask:
    plugin_id: str
    channel_id: int
    message_id: int


class AutoUpdater:
    def __init__(self, log: logging.Logger = None):
        self.thread: Optional[threading.Thread] = None
        self.forced_stop = False
        self.forced_check = False
        self.tasks: List[UpdaterTask] = []
        self.edited_ts = JsonCacheFile("autoupdater_edited.json", {})
        self.logger = log or (globals().get('logger'))  # –µ—Å–ª–∏ –ª–æ–≥–≥–µ—Ä –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π

    def run(self):
        if self.thread and self.thread.is_alive():
            return
        self.forced_stop = False
        self.thread = threading.Thread(target=self._cycle, daemon=True)
        self.thread.start()
        if self.logger:
            self.logger.info("AutoUpdater thread started")

    def force_stop(self):
        self.forced_stop = True
        if self.logger:
            self.logger.info("AutoUpdater stop requested")

    def _cycle(self):
        while not self.forced_stop:
            try:
                self._check_all()
            except Exception as e:
                if self.logger:
                    self.logger.error(f"Check error: {Dont65Utils.format_exc_only(e)}")
            timeout = int(_setting_getter("autoupdate_timeout", "600"))
            start = time.time()
            while (time.time() - start) < timeout and not self.forced_stop and not self.forced_check:
                threading.Event().wait(1)
            if self.forced_check:
                self.forced_check = False
                if self.logger:
                    self.logger.info("Forced update check")

    def _check_all(self):
        for task in list(self.tasks):
            plugin = PluginsController.getInstance().plugins.get(task.plugin_id)
            if not plugin or not plugin.isEnabled():
                if self.logger:
                    self.logger.info(f"Removing task {task.plugin_id} ‚Äì plugin disabled/missing")
                self.tasks.remove(task)
                continue
            self._check_plugin_update(task)

    def _check_plugin_update(self, task: UpdaterTask):
        def on_message(msg: Optional[TLRPC.TL_message]):
            if not msg or isinstance(msg, TLRPC.TL_messageEmpty):
                if self.logger:
                    self.logger.info(f"No message for {task.plugin_id}, removing task")
                self.tasks.remove(task)
                return
            if not msg.media:
                if self.logger:
                    self.logger.info(f"No media in message for {task.plugin_id}, removing")
                self.tasks.remove(task)
                return
            doc = msg.media.getDocument()
            if not PluginsController.getInstance().isPlugin(get_file_loader().getPathToAttach(doc, True)):
                if self.logger:
                    self.logger.info(f"Attached file is not a plugin for {task.plugin_id}, removing")
                self.tasks.remove(task)
                return
            disable_ts = _setting_getter("disable_ts_check", False)
            last_edit = self.edited_ts.content.get(task.plugin_id)
            if not disable_ts and msg.edit_date == last_edit:
                if self.logger:
                    self.logger.info(f"No changes for {task.plugin_id}, skip")
                return
            self.edited_ts.content[task.plugin_id] = msg.edit_date
            self.edited_ts.write()
            run_on_queue(lambda: self._download_and_install(msg, task.plugin_id))

        Requests.get_message(-task.channel_id, task.message_id, on_message)

    def _download_and_install(self, msg: TLRPC.TL_message, plugin_id: str, tries=0, max_tries=10):
        file_loader = get_file_loader()
        doc = msg.media.getDocument()
        path = file_loader.getPathToAttach(doc, True)
        if not path.exists():
            if tries >= max_tries:
                if self.logger:
                    self.logger.error(f"Max tries exceeded for {plugin_id}")
                return
            file_loader.loadFile(doc, "plugin", FileLoader.PRIORITY_NORMAL, 1)
            run_on_queue(lambda: self._download_and_install(msg, plugin_id, tries + 1), delay=1)
            return
        try:
            PluginsController.getInstance().loadPluginFromFile(str(path), None, Utilities.Callback(lambda err: None))
        except TypeError:
            PluginsController.getInstance().loadPluginFromFile(str(path), Utilities.Callback(lambda err: None))
        if self.logger:
            self.logger.info(f"Installed {plugin_id}")

    def add_task(self, task: UpdaterTask):
        if not any(t.plugin_id == task.plugin_id for t in self.tasks):
            self.tasks.append(task)
            if self.logger:
                self.logger.info(f"Added task {task.plugin_id}")

    def remove_task(self, plugin_id: str):
        self.tasks = [t for t in self.tasks if t.plugin_id != plugin_id]
        if self.logger:
            self.logger.info(f"Removed task {plugin_id}")


class Requests:
    @staticmethod
    def get_message(peer_id: int, msg_id: int, callback: Callable):
        ctrl = get_messages_controller()
        def _fetch():
            ctrl.reloadMessages(ArrayList([msg_id]), peer_id, 0)
            msg = get_messages_storage().getMessage(peer_id, msg_id)
            if msg:
                callback(msg)
            else:
                run_on_queue(_fetch, delay=1)
        run_on_queue(_fetch)


# ======================================================================
#  –£–¢–ò–õ–ò–¢–´ Dont65Utils ‚Äì –í–°–ï –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´
# ======================================================================
class Dont65Utils:
    """–ù–∞–±–æ—Ä –ø—É–±–ª–∏—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö –ø–ª–∞–≥–∏–Ω–∞—Ö."""

    # --- –†–ê–ë–û–¢–ê –° MARKDOWN –ò –°–û–û–ë–©–ï–ù–ò–Ø–ú–ò (—Å—Ç–∞—Ä—ã–µ –º–µ—Ç–æ–¥—ã) ---
    @staticmethod
    def apply_markdown(params, text):
        parsed = parse_markdown(text)
        ents = ArrayList()
        if parsed.entities:
            for e in parsed.entities:
                ents.add(e.to_tlrpc_object())
        if hasattr(params, 'caption') and params.caption:
            params.caption = parsed.text
        else:
            params.message = parsed.text
        params.entities = ents
        return params

    @staticmethod
    def reply_with_style(params, body, header=None, source=None, quote='block'):
        full_msg = ""
        ents = ArrayList()
        offset = 0

        def _u16(s):
            return len(s.encode('utf-16-le')) // 2

        if source:
            clean_source = source.replace('\n', ' ')
            src_s = f"üìù {clean_source[:100]}"
            if len(clean_source) > 100:
                src_s += "..."
            b = TLRPC.TL_messageEntityBlockquote()
            b.collapsed = True
            b.offset = 0
            b.length = _u16(src_s)
            ents.add(b)
            full_msg = src_s + "\n\n"
            offset = _u16(src_s) + 2

        if header:
            p = parse_markdown(header)
            if p.entities:
                for e in p.entities:
                    te = e.to_tlrpc_object()
                    te.offset += offset
                    ents.add(te)
            full_msg += p.text + "\n"
            offset += _u16(p.text) + 1

        p_b = parse_markdown(body)
        if p_b.entities:
            for e in p_b.entities:
                te = e.to_tlrpc_object()
                te.offset += offset
                ents.add(te)

        if quote:
            qb = TLRPC.TL_messageEntityBlockquote()
            qb.collapsed = (quote == 'collapsed')
            qb.offset = offset
            qb.length = _u16(p_b.text)
            ents.add(qb)

        full_msg += p_b.text
        if hasattr(params, 'caption') and params.caption:
            params.caption = full_msg
        else:
            params.message = full_msg
        params.entities = ents
        return params

    @staticmethod
    def switch_layout(text):
        en_layout = "qwertyuiop[]asdfghjkl;'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>?~`"
        ru_layout = "–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–ô–¶–£–ö–ï–ù–ì–®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠–Ø–ß–°–ú–ò–¢–¨–ë–Æ,–Å—ë"
        en_chars = len(re.findall(r'[a-zA-Z]', text))
        ru_chars = len(re.findall(r'[–∞-—è–ê-–Ø—ë–Å]', text))
        if en_chars >= ru_chars:
            table = str.maketrans(en_layout, ru_layout)
        else:
            table = str.maketrans(ru_layout, en_layout)
        return text.translate(table)

    @staticmethod
    def quality_symbols(text):
        total_symbols = len(text)
        text_no_newlines = re.sub(r'\n', '', text)
        symbols_no_newlines = len(text_no_newlines)
        text_no_spaces_or_newlines = re.sub(r'\s', '', text)
        symbols_no_spaces_or_newlines = len(text_no_spaces_or_newlines)
        return total_symbols, symbols_no_newlines, symbols_no_spaces_or_newlines

    @staticmethod
    def do_translit(text):
        # –ò–°–ü–†–ê–í–õ–ï–ù–û: '—Ö' -> 'h' (–±—ã–ª–æ 'kh')
        ru_to_en = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'h', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
        }
        en_to_ru = {v: k for k, v in ru_to_en.items()}
        is_cyrillic = bool(re.search('[–∞-—è–ê-–Ø—ë–Å]', text))
        if is_cyrillic:
            result = ""
            for char in text:
                lower_char = char.lower()
                if lower_char in ru_to_en:
                    trans = ru_to_en[lower_char]
                    result += trans.upper() if char.isupper() else trans
                else:
                    result += char
            return result
        else:
            temp_text = text
            sorted_en = sorted(en_to_ru.keys(), key=len, reverse=True)
            for en_char in sorted_en:
                if not en_char:
                    continue
                ru_char = en_to_ru[en_char]
                pattern = re.compile(re.escape(en_char), re.IGNORECASE)
                temp_text = pattern.sub(
                    lambda m: ru_char.upper() if m.group(0).isupper() else ru_char,
                    temp_text
                )
            return temp_text

    @staticmethod
    def get_message_info(reply_msg_obj, params=None):
        def _get_attr(obj, *attrs):
            for attr in attrs:
                if hasattr(obj, attr):
                    val = getattr(obj, attr)
                    if callable(val):
                        try:
                            return val()
                        except:
                            continue
                    return val
            return None

        def _extract_id_safe(peer_obj):
            if peer_obj is None:
                return None
            if isinstance(peer_obj, int):
                return peer_obj
            if hasattr(peer_obj, 'user_id'):
                return peer_obj.user_id
            if hasattr(peer_obj, 'channel_id'):
                return peer_obj.channel_id
            if hasattr(peer_obj, 'chat_id'):
                return peer_obj.chat_id
            return str(peer_obj)

        msg_id = _get_attr(reply_msg_obj, 'id', 'message_id', 'msg_id', 'getId') or "Unknown"
        chat_id = None
        if params:
            chat_id = _get_attr(params, 'chatId', 'chat_id', 'chatId_long', 'getChatId')
        if not chat_id:
            chat_id = _get_attr(reply_msg_obj, 'chat_id', 'chatId', 'getChatId')
        if not chat_id:
            chat_id = "Unknown"

        sender_id = "Unknown"
        if hasattr(reply_msg_obj, 'messageOwner') and hasattr(reply_msg_obj.messageOwner, 'from_id'):
            sender_id = _extract_id_safe(reply_msg_obj.messageOwner.from_id)
        else:
            sender_id = _get_attr(reply_msg_obj, 'fromId', 'from_id', 'sender_id', 'getFromId') or "Unknown"

        link = "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É"
        if str(chat_id) != "Unknown" and str(msg_id) != "Unknown":
            str_chat_id = str(chat_id)
            clean_cid = str_chat_id.replace("-100", "").replace("-", "")
            link = f"https://t.me/c/{clean_cid}/{msg_id}"

        return {
            "sender_id": sender_id,
            "chat_id": chat_id,
            "msg_id": msg_id,
            "link": link
        }

    @staticmethod
    def extract_text_aggressively(reply_msg_obj):
        text = ""
        try:
            if hasattr(reply_msg_obj, 'getMessageText'):
                text_cs = reply_msg_obj.getMessageText()
                if text_cs:
                    return str(text_cs).strip()
        except Exception:
            pass
        for attr in ['message', 'caption', 'text']:
            val = getattr(reply_msg_obj, attr, None)
            if val:
                return str(val).strip()
        if hasattr(reply_msg_obj, 'messageOwner'):
            owner = reply_msg_obj.messageOwner
            for attr in ['message', 'caption', 'text']:
                val = getattr(owner, attr, None)
                if val:
                    return str(val).strip()
        return ""

    @staticmethod
    def generate_random_number(min_val, max_val):
        if min_val > max_val:
            min_val, max_val = max_val, min_val
        if abs(max_val - min_val) > 1000000:
            raise ValueError("–î–∏–∞–ø–∞–∑–æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π")
        return random.randint(min_val, max_val)

    @staticmethod
    def get_current_user_info(account):
        try:
            from org.telegram.messenger import UserConfig
            current_user = UserConfig.getInstance(account).getCurrentUser()
            if not current_user:
                return None
            user_id = current_user.id
            username = getattr(current_user, 'username', None)
            tg_link = f"tg://openmessage?user_id={user_id}"
            display_name = f"@{username}" if username else "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
            markdown_link = f"[{display_name}]({tg_link})"
            return {
                "id": user_id,
                "username": username,
                "link": markdown_link,
                "display_name": display_name
            }
        except Exception:
            return None

    # --- –ù–û–í–´–ï –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´ ---
    @staticmethod
    def add_autoupdater_task(plugin_id: str, channel_id: int, message_id: int):
        """–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–ª–∞–≥–∏–Ω –≤ —Å–∏—Å—Ç–µ–º–µ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."""
        if _autoupdater is None:
            if logger:
                logger.error("AutoUpdater not initialized, cannot add task")
            return
        task = UpdaterTask(plugin_id, channel_id, message_id)
        _autoupdater.add_task(task)

    @staticmethod
    def remove_autoupdater_task(plugin_id: str):
        """–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–ª—è –ø–ª–∞–≥–∏–Ω–∞."""
        if _autoupdater:
            _autoupdater.remove_task(plugin_id)

    @staticmethod
    def build_log(name: str) -> logging.Logger:
        """–°–æ–∑–¥–∞—Ç—å –ª–æ–≥–≥–µ—Ä –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç—É –∂–µ —Å–∏—Å—Ç–µ–º—É)."""
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ—Ç –∂–µ –º–µ—Ç–æ–¥, —á—Ç–æ –∏ –≤ Dont65Lib, –Ω–æ –±–µ–∑ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç–∫–∑–µ–º–ø–ª—è—Ä—É
        class Dont65Logger(logging.Logger):
            def _log(self, level, msg, args, exc_info=None, extra=None, stack_info=False, stacklevel=1):
                caller = inspect.stack()[2]
                func = caller.function
                level_name = logging.getLevelName(level).upper()
                prefix = " ".join(filter(None, [f"[{level_name}]", self.name, f"[{func}]"]))
                try:
                    formatted = str(msg) % args if args else str(msg)
                except:
                    formatted = f"{msg} {' '.join(map(str, args))}" if args else str(msg)
                _android_log(f"{prefix} {formatted}")

        log = Dont65Logger(name)
        # –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–µ debug_mode
        debug_mode = Dont65Utils.is_debug_mode()
        log.setLevel(logging.DEBUG if debug_mode else logging.INFO)
        return log

    @staticmethod
    def format_exc() -> str:
        """–ü–æ–ª–Ω—ã–π —Ç—Ä–µ–π—Å–±–µ–∫ —Ç–µ–∫—É—â–µ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è."""
        return traceback.format_exc().strip()

    @staticmethod
    def format_exc_only(e: Exception) -> str:
        """–¢–æ–ª—å–∫–æ —Ç–∏–ø –∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è."""
        return "".join(traceback.format_exception_only(type(e), e)).strip()

    @staticmethod
    def is_debug_mode() -> bool:
        """–¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ debug-—Ä–µ–∂–∏–º–∞ (–∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏)."""
        return bool(_setting_getter("debug_mode", False)) if _setting_getter else False