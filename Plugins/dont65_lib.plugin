from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Text, Switch
from markdown_utils import parse_markdown
from client_utils import log
import sys, traceback
import re
import random

try:
    from java.util import ArrayList
    from org.telegram.tgnet import TLRPC
except ImportError:
    ArrayList = list

__name__ = "Dont65 Lib"
__description__ = "üìö –Ø–¥—Ä–æ –¥–ª—è –ø–ª–∞–≥–∏–Ω–æ–≤ @dont65. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Markdown –∏ –æ–±—â–∏–π .help"
__icon__ = "random69_by_TgEmojiBot/123"
__version__ = "1.2.0"  # –£–≤–µ–ª–∏—á–∏–ª –≤–µ—Ä—Å–∏—é
__id__ = "dont65_lib"
__author__ = "@dont65"

class Dont65Lib(BasePlugin):
    def __init__(self):
        super().__init__()
        # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –¥–ª—è –æ–±—â–µ–≥–æ —Ö–µ–ª–ø–∞
        self.known_plugins = {
            "dont65_multitool": {
                "name": "üß∞ MultiTool",
                "commands": [
                    ("`.id`", "–∏–Ω—Ñ–æ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏ (—Ä–µ–ø–ª–∞–π)"),
                    ("`.layout`", "—Å–º–µ–Ω–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ (—Ä–µ–ø–ª–∞–π/—Ç–µ–∫—Å—Ç)"),
                    ("`.calc`", "–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∫–∞–ª—å–∫—É–ª—è—Ç–æ—Ä"),
                    ("`.symbols`", "—Å—á–µ—Ç—á–∏–∫ —Å–∏–º–≤–æ–ª–æ–≤ –∏ —Å–ª–æ–≤"),
                    ("`.rev`", "–ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å —Ç–µ–∫—Å—Ç –∑–∞–¥–æ–º –Ω–∞–ø–µ—Ä–µ–¥"),
                    ("`.translit`", "–ø–µ—Ä–µ–≤–æ–¥ –≤ –ª–∞—Ç–∏–Ω–∏—Ü—É –∏ –æ–±—Ä–∞—Ç–Ω–æ"),
                    ("`.upper`", "—Å–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç –ó–ê–ì–õ–ê–í–ù–´–ú"),
                    ("`.lower`", "—Å–¥–µ–ª–∞—Ç—å —Ç–µ–∫—Å—Ç —Å—Ç—Ä–æ—á–Ω—ã–º"),
                    ("`.tglink`", "—Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"),
                    ("`.time`", "—É–∑–Ω–∞—Ç—å —Ç–æ—á–Ω–æ–µ –≤—Ä–µ–º—è"),
                    ("`.swap`", "—Å–º–µ–Ω–∏—Ç—å —Ä–µ–≥–∏—Å—Ç—Ä –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–π")
                ]
            },
            "dont65_currency": {
                "name": "üí± Currency",
                "commands": [
                    ("`.curs [–∫–æ–ª-–≤–æ] [–≤–∞–ª—é—Ç–∞]`", "–∫—É—Ä—Å –º–æ–Ω–µ—Ç—ã –∫–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º"),
                    ("`.curs [–≤–∞–ª—é—Ç–∞] [–≤–∞–ª—é—Ç–∞]`", "–∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ø–∞—Ä—ã")
                ]
            },
            "dont65_dice_roller": {
                "name": "üé≤ Dice Roller",
                "commands": [
                    ("`.roll`", "—Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –æ—Ç 0 –¥–æ 100"),
                    ("`.roll [max]`", "—Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ –¥–æ –º–∞–∫—Å–∏–º—É–º–∞"),
                    ("`.roll [min] [max]`", "—á–∏—Å–ª–æ –≤ –≤–∞—à–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ")
                ]
            },
            "dont65textreplacer": {
                "name": "üìù Replacer",
                "commands": [
                    ("`–≤–∞—à–∏ –∫–æ–º–∞–Ω–¥—ã`", "–∞–≤—Ç–æ–∑–∞–º–µ–Ω–∞ (–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ –≤ –º–µ–Ω—é)")
                ]
            },
            "dont65_weather": {
                "name": "üå§ Weather Monitor",
                "commands": [
                    ("`.weather [–≥–æ—Ä–æ–¥]`", "–ø–æ–≥–æ–¥–∞ –∏ –º–∞–≥–Ω–∏—Ç–Ω—ã–µ –±—É—Ä–∏"),
                    ("`.weather`", "–ø–æ–≥–æ–¥–∞ –≤ –≥–æ—Ä–æ–¥–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é")
                ]
            }
        }

    def create_settings(self):
        return [
            Header("Dont65 Library"),
            Divider(text = "–û—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–µ —è–¥—Ä–æ –¥–ª—è –ø–ª–∞–≥–∏–Ω–æ–≤ @dont65."),
            Switch(key="enable_help", text="–í–∫–ª—é—á–∏—Ç—å –∫–æ–º–∞–Ω–¥—É .help", default=True),
            Divider(),
            Text("–ê–≤—Ç–æ—Ä: @dont65")
        ]

    def on_plugin_load(self):
        self.add_on_send_message_hook(priority=100)

    def on_send_message_hook(self, account, params):
        msg = params.message or params.caption or ""
        if msg.lower().strip() == ".help" and self.get_setting("enable_help", True):
            lines = ["üõ† **Dont65 Plugins Hub**", ""]
            
            for p_id, info in self.known_plugins.items():
                is_installed = p_id in sys.modules
                status = "‚úÖ" if is_installed else "‚ùå"
                lines.append(f"**{info['name']}** {status}")
                
                if is_installed:
                    for cmd, desc in info['commands']:
                        lines.append(f"{cmd} ‚Äî {desc}")
                else:
                    lines.append("–ü–ª–∞–≥–∏–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω ‚ùå")
                lines.append("")
            
            new_params = Dont65Utils.apply_markdown(params, "\n".join(lines))
            return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=new_params)
        return HookResult()

class Dont65Utils:
    @staticmethod
    def apply_markdown(params, text):
        parsed = parse_markdown(text)
        ents = ArrayList()
        if parsed.entities:
            for e in parsed.entities: ents.add(e.to_tlrpc_object())
        if hasattr(params, 'caption') and params.caption: params.caption = parsed.text
        else: params.message = parsed.text
        params.entities = ents
        return params

    @staticmethod
    def reply_with_style(params, body, header=None, source=None, quote='block'):
        full_msg = ""
        ents = ArrayList()
        offset = 0
        def _u16(s): return len(s.encode('utf-16-le')) // 2

        if source:
            clean_source = source.replace('\n', ' ')
            src_s = f"üìù {clean_source[:100]}"
            if len(clean_source) > 100: src_s += "..."
            
            b = TLRPC.TL_messageEntityBlockquote()
            b.collapsed, b.offset, b.length = True, 0, _u16(src_s)
            ents.add(b)
            full_msg, offset = src_s + "\n\n", _u16(src_s) + 2

        if header:
            p = parse_markdown(header)
            if p.entities:
                for e in p.entities:
                    te = e.to_tlrpc_object(); te.offset += offset; ents.add(te)
            full_msg += p.text + "\n"
            offset += _u16(p.text) + 1

        p_b = parse_markdown(body)
        if p_b.entities:
            for e in p_b.entities:
                te = e.to_tlrpc_object(); te.offset += offset; ents.add(te)
        
        if quote:
            qb = TLRPC.TL_messageEntityBlockquote()
            qb.collapsed, qb.offset, qb.length = (quote=='collapsed'), offset, _u16(p_b.text)
            ents.add(qb)
        
        full_msg += p_b.text
        if hasattr(params, 'caption') and params.caption: params.caption = full_msg
        else: params.message = full_msg
        params.entities = ents
        return params

    # ============ –í–´–ù–ï–°–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ó MULTITOOL ============
    
    @staticmethod
    def switch_layout(text):
        """–°–º–µ–Ω–∞ —Ä–∞—Å–∫–ª–∞–¥–∫–∏ (—Ä—É—Å—Å–∫–∞—è/–∞–Ω–≥–ª–∏–π—Å–∫–∞—è)"""
        en_layout = "qwertyuiop[]asdfghjkl;'zxcvbnm,./QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>?~`"
        ru_layout = "–π—Ü—É–∫–µ–Ω–≥—à—â–∑—Ö—ä—Ñ—ã–≤–∞–ø—Ä–æ–ª–¥–∂—ç—è—á—Å–º–∏—Ç—å–±—é.–ô–¶–£–ö–ï–ù–ì–®–©–ó–•–™–§–´–í–ê–ü–†–û–õ–î–ñ–≠–Ø–ß–°–ú–ò–¢–¨–ë–Æ,–Å—ë"
        
        en_chars = len(re.findall(r'[a-zA-Z]', text))
        ru_chars = len(re.findall(r'[–∞-—è–ê-–Ø—ë–Å]', text))
        
        if en_chars >= ru_chars:
            table = str.maketrans(en_layout, ru_layout)
        else:
            table = str.maketrans(ru_layout, en_layout)
        return text.translate(table)

    @staticmethod
    def quality_symbols(text):
        """–ü–æ–¥—Å—á–µ—Ç —Å–∏–º–≤–æ–ª–æ–≤ (–≤—Å–µ—Ö, –±–µ–∑ –ø–µ—Ä–µ–Ω–æ—Å–æ–≤, –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤)"""
        total_symbols = len(text)
        text_no_newlines = re.sub(r'\n', '', text)
        symbols_no_newlines = len(text_no_newlines)
        text_no_spaces_or_newlines = re.sub(r'\s', '', text)
        symbols_no_spaces_or_newlines = len(text_no_spaces_or_newlines)
        return total_symbols, symbols_no_newlines, symbols_no_spaces_or_newlines

    @staticmethod
    def do_translit(text):
        """–¢—Ä–∞–Ω—Å–ª–∏—Ç–µ—Ä–∞—Ü–∏—è (—Ä—É—Å‚Üî–∞–Ω–≥–ª)"""
        ru_to_en = {
            '–∞': 'a', '–±': 'b', '–≤': 'v', '–≥': 'g', '–¥': 'd', '–µ': 'e', '—ë': 'yo',
            '–∂': 'zh', '–∑': 'z', '–∏': 'i', '–π': 'y', '–∫': 'k', '–ª': 'l', '–º': 'm',
            '–Ω': 'n', '–æ': 'o', '–ø': 'p', '—Ä': 'r', '—Å': 's', '—Ç': 't', '—É': 'u',
            '—Ñ': 'f', '—Ö': 'kh', '—Ü': 'ts', '—á': 'ch', '—à': 'sh', '—â': 'sch',
            '—ä': '', '—ã': 'y', '—å': '', '—ç': 'e', '—é': 'yu', '—è': 'ya'
        }
        en_to_ru = {v: k for k, v in ru_to_en.items()}
        is_cyrillic = bool(re.search('[–∞-—è–ê-–Ø—ë–Å]', text))
        
        result = ""
        if is_cyrillic:
            for char in text:
                lower_char = char.lower()
                if lower_char in ru_to_en:
                    trans = ru_to_en[lower_char]
                    result += trans.upper() if char.isupper() else trans
                else: result += char
        else:
            temp_text = text
            sorted_en = sorted(en_to_ru.keys(), key=len, reverse=True)
            for en_char in sorted_en:
                if not en_char: continue
                ru_char = en_to_ru[en_char]
                pattern = re.compile(re.escape(en_char), re.IGNORECASE)
                temp_text = pattern.sub(lambda m: ru_char.upper() if m.group(0).isupper() else ru_char, temp_text)
            result = temp_text

        return result

    @staticmethod
    def get_message_info(reply_msg_obj, params=None):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–æ–æ–±—â–µ–Ω–∏–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ, –Ω–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç)"""
        def _get_attr(obj, *attrs):
            for attr in attrs:
                if hasattr(obj, attr):
                    val = getattr(obj, attr)
                    if callable(val):
                        try: return val()
                        except: continue
                    return val
            return None

        def _extract_id_safe(peer_obj):
            if peer_obj is None: return None
            if isinstance(peer_obj, int): return peer_obj
            if hasattr(peer_obj, 'user_id'): return peer_obj.user_id
            if hasattr(peer_obj, 'channel_id'): return peer_obj.channel_id
            if hasattr(peer_obj, 'chat_id'): return peer_obj.chat_id
            return str(peer_obj)

        msg_id = _get_attr(reply_msg_obj, 'id', 'message_id', 'msg_id', 'getId') or "Unknown"
        
        chat_id = None
        if params:
            chat_id = _get_attr(params, 'chatId', 'chat_id', 'chatId_long', 'getChatId')
        if not chat_id:
            chat_id = _get_attr(reply_msg_obj, 'chat_id', 'chatId', 'getChatId')
        if not chat_id: 
            chat_id = "Unknown"

        sender_id = "Unknown"
        if hasattr(reply_msg_obj, 'messageOwner') and hasattr(reply_msg_obj.messageOwner, 'from_id'):
            sender_id = _extract_id_safe(reply_msg_obj.messageOwner.from_id)
        else:
            sender_id = _get_attr(reply_msg_obj, 'fromId', 'from_id', 'sender_id', 'getFromId') or "Unknown"

        link = "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É"
        if str(chat_id) != "Unknown" and str(msg_id) != "Unknown":
            str_chat_id = str(chat_id)
            clean_cid = str_chat_id.replace("-100", "").replace("-", "")
            link = f"https://t.me/c/{clean_cid}/{msg_id}"

        return {
            "sender_id": sender_id,
            "chat_id": chat_id,
            "msg_id": msg_id,
            "link": link
        }

    @staticmethod
    def extract_text_aggressively(reply_msg_obj):
        """–ê–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏–∑ –æ–±—ä–µ–∫—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è"""
        text = ""
        try:
            if hasattr(reply_msg_obj, 'getMessageText'):
                text_cs = reply_msg_obj.getMessageText()
                if text_cs: return str(text_cs).strip()
        except Exception: pass

        for attr in ['message', 'caption', 'text']:
            val = getattr(reply_msg_obj, attr, None)
            if val: return str(val).strip()

        if hasattr(reply_msg_obj, 'messageOwner'):
            owner = reply_msg_obj.messageOwner
            for attr in ['message', 'caption', 'text']:
                val = getattr(owner, attr, None)
                if val: return str(val).strip()
        return ""

    # ============ –í–´–ù–ï–°–ï–ù–ù–´–ï –§–£–ù–ö–¶–ò–ò –ò–ó DICE_ROLLER ============
    
    @staticmethod
    def generate_random_number(min_val, max_val):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ —á–∏—Å–ª–∞ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤"""
        # –ó–∞—â–∏—Ç–∞: –µ—Å–ª–∏ min –±–æ–ª—å—à–µ max, –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏
        if min_val > max_val:
            min_val, max_val = max_val, min_val
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ —á–∏—Å–ª–∞
        if abs(max_val - min_val) > 1000000:
            raise ValueError("–î–∏–∞–ø–∞–∑–æ–Ω —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π")
        
        return random.randint(min_val, max_val)

    @staticmethod
    def get_current_user_info(account):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"""
        try:
            from org.telegram.messenger import UserConfig
            current_user = UserConfig.getInstance(account).getCurrentUser()
            if not current_user:
                return None
            
            user_id = current_user.id
            username = getattr(current_user, 'username', None)
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –≥–∏–ø–µ—Ä—Å—Å—ã–ª–∫—É –Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            tg_link = f"tg://openmessage?user_id={user_id}"
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º username –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
            display_name = f"@{username}" if username else "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
            markdown_link = f"[{display_name}]({tg_link})"
            
            return {
                "id": user_id,
                "username": username,
                "link": markdown_link,
                "display_name": display_name
            }
        except Exception:
            return None