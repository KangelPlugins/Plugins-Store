import requests
import socket
import json
import time
import ipaddress
import base64
import urllib.parse
import hashlib
import random
import string
import shlex
import re
import traceback
import ssl
import html
import threading
import os
from datetime import datetime
from typing import Any, Dict, Optional, List
from java.io import File

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import run_on_queue, EXTERNAL_NETWORK_QUEUE, send_message, get_last_fragment, get_account_instance, get_user_config
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Switch, Text, Divider, Selector, Input
from android_utils import log, run_on_ui_thread
from org.telegram.messenger import LocaleController, MessagesController, SendMessagesHelper, FileLoader, ApplicationLoader
from org.telegram.tgnet import TLRPC
from java.util import ArrayList

__id__ = "whoisZ"
__icon__ = "TotonoCG/23"
__name__ = "Network Tools"
__version__ = "2.9"
__author__ = "@yzewe"
__min_version__ = "11.12.0"
__description__ = "Network Toolkit. See settings and .zhelp"

class NetworkUtilsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.progress_dialog: Optional[AlertDialogBuilder] = None
        self.lang = "ru" if LocaleController.getInstance().getCurrentLocaleInfo().shortName == "ru" else "en"
        
        self.strings = {
            "ru": {
                "wait": "Обработка...", "err": "Ошибка", "err_net": "Сетевая ошибка",
                "err_url": "URL не найден", "err_target": "Цель не указана",
                "err_inv": "Неверные данные", "err_limit": "Лимит API", "err_notfound": "Не найдено",
                "err_no_ports": "Открытых портов не найдено", "err_api": "Ошибка API",
                "cat_help": "ПОМОЩЬ", "cat_info": "ИНФОРМАЦИЯ", "cat_dns": "DNS / ДОМЕНЫ",
                "cat_net": "СЕТЬ", "cat_web": "WEB", "cat_util": "УТИЛИТЫ",
                "desc_no_set": "Дополнительных настроек нет.",
                "h_out": "Настройки вывода", "h_prov": "Провайдер", "h_rec": "Типы записей", "h_opt": "Опции",
                "s_ip": "IP адрес", "s_cont": "Континент", "s_country": "Страна",
                "s_region": "Регион", "s_city": "Город", "s_zip": "Индекс",
                "s_latlon": "Координаты", "s_tz": "Часовой пояс", "s_curr": "Валюта",
                "s_isp": "Провайдер (ISP)", "s_org": "Организация", "s_as": "ASN",
                "s_rev": "Reverse DNS", "s_mob": "Мобильная сеть", "s_proxy": "Прокси/VPN",
                "s_host": "Хостинг", "s_raw": "Сырой JSON", "s_res": "Авто-резолв домена",
                "s_head": "Заголовки", "s_body": "Тело ответа", "s_redir": "Следовать редиректам",
                "lbl_ip": "IP", "lbl_country": "Страна", "lbl_city": "Город",
                "lbl_isp": "Провайдер", "lbl_org": "Орг.", "lbl_as": "AS", "lbl_prefix": "Префикс", "lbl_asname": "Имя AS",
                "lbl_status": "Статус", "lbl_time": "Время", "lbl_method": "Метод", "lbl_url": "URL",
                "lbl_port": "Порт", "lbl_state": "Состояние", "lbl_net": "Сеть", "lbl_serv": "Сервис",
                "lbl_mask": "Маска", "lbl_wild": "Wildcard", "lbl_bcast": "Broadcast",
                "lbl_min": "HostMin", "lbl_max": "HostMax", "lbl_host": "Хостов", "lbl_name": "Имя",
                "lbl_bin": "Binary", "lbl_issued_to": "Выдан", "lbl_issued_by": "Кем выдан",
                "lbl_valid_u": "Годен до", "lbl_serial": "Серийный №",
                "lbl_count": "Количество", "lbl_list": "Список", "lbl_orig": "Оригинал",
                "lbl_short": "Короткая", "lbl_long": "Полная", "lbl_res": "Результат",
                "lbl_dec": "Decoded", "lbl_enc": "Encoded", "lbl_hsts": "HSTS",
                "lbl_frame": "X-Frame", "lbl_xss": "X-XSS", "lbl_server": "Сервер",
                "lbl_reg": "Регистратор", "lbl_cr_date": "Дата создания",
                "lbl_ex_date": "Истекает", "lbl_ns": "NS Серверы", "lbl_seq": "Seq",
                "lbl_timeout": "таймаут", "lbl_stats": "Статистика", "lbl_avg": "Среднее", "lbl_log": "Лог",
                "lbl_open": "ОТКРЫТ", "lbl_sent": "Отправлен", "lbl_closed": "ЗАКРЫТ",
                "lbl_vendor": "Производитель", "lbl_vuln": "Уязвимости", "lbl_tags": "Теги",
                "lbl_tech": "Технологии", "lbl_cookies": "Cookies", "lbl_jitter": "Джиттер",
                "lbl_loss": "Потеря пакетов", "lbl_license": "Лицензия", "lbl_version": "Версия",
                "lbl_pkg": "Пакет", "lbl_alive": "Живые хосты", "lbl_entities": "Сущности (Entities)",
                "err_reply": "Нужен ответ на сообщение", "err_sending": "Ошибка отправки файла",
                "cmd_whois": "Полная информация об IP", "cmd_dwhois": "Регистрационные данные домена",
                "cmd_myip": "Ваш внешний IP адрес", "cmd_dns": "DNS записи",
                "cmd_dig": "Raw DNS запрос", "cmd_ip": "Резолв домена в IP",
                "cmd_sub": "Поиск поддоменов", "cmd_rev": "Обратный DNS (PTR)",
                "cmd_bgp": "BGP Инфо", "cmd_black": "Проверка IP в блэклистах",
                "cmd_calc": "Калькулятор подсетей", "cmd_scan": "Быстрый TCP сканер портов",
                "cmd_ping": "TCP Пинг", "cmd_ris": "RIPE инфо по маршрутизации",
                "cmd_ports": "Открытые порты (InternetDB)", "cmd_tcp": "Проверка TCP соединения",
                "cmd_udp": "Отправка UDP пакета", "cmd_wport": "Описание порта",
                "cmd_intip": "Конвертация IP <-> Integer", "cmd_cidr": "Список IP в подсети",
                "cmd_curl": "HTTP Запрос", "cmd_red": "Анализ редиректов",
                "cmd_cert": "Инфо о SSL сертификате", "cmd_head": "Заголовки сервера",
                "cmd_short": "Сократить ссылку", "cmd_unshort": "Раскрыть ссылку",
                "cmd_sec": "Заголовки безопасности", "cmd_robot": "Получить robots.txt",
                "cmd_hash": "Вычисление хэшей", "cmd_b64": "Base64",
                "cmd_url": "URL Encode/Decode", "cmd_puny": "Punycode",
                "cmd_json": "Форматирование JSON", "cmd_mac": "MAC Вендор",
                "cmd_traceroute": "Трассировка маршрута", "cmd_time": "Конвертер времени",
                "cmd_color": "Конвертер цветов", "cmd_speedtest": "Тест скорости",
                "cmd_threat": "Репутация IP (Basic)", "cmd_dnshistory": "История DNS",
                "cmd_htmlencode": "HTML Encode", "cmd_htmldecode": "HTML Decode",
                "cmd_cat": "HTTP Кот", "cmd_zhelp": "Список команд",
                "cmd_tld": "Инфо о доменной зоне", "cmd_tor": "Проверка TOR",
                "cmd_extract": "Извлечение ссылок", "cmd_cve": "Поиск CVE",
                "cmd_emailsec": "Безопасность почты", "cmd_gh": "Инфо о GitHub",
                "cmd_waf": "Детектор WAF", "cmd_shodan": "Инфо Shodan (Free API)",
                "cmd_jwt": "Декодер JWT", "cmd_sitemap": "Поиск Sitemap",
                "cmd_tech": "Определение технологий", "cmd_reputation": "Сводная репутация",
                "cmd_flood_check": "Тест Rate Limit", "cmd_pypi": "PyPI Пакет",
                "cmd_npm": "NPM Пакет", "cmd_carbon": "Код в картинку",
                "cmd_pingmap": "Пинг подсети (Sweep)", "cmd_r": "HTML-код сообщения",
                "testing_speed": "Тестирование скорости...", "download_speed": "Скорость загрузки",
                "threat_score": "Оценка угрозы", "threat_info": "Информация",
                "safe": "Безопасный", "risky": "Потенциально опасный",
                "proxy_detected": "Обнаружен прокси/VPN", "hosting_detected": "Адрес принадлежит хостингу",
                "cellular_network": "Мобильная сеть", "history_not_found": "История для домена не найдена.",
                "shodan_desc": "Порты и уязвимости через InternetDB",
                "jwt_desc": "Декодировать Payload токена",
                "tech_desc": "Стек технологий сайта",
                "rep_desc": "IP-API + DNSBL",
                "flood_desc": "Проверка на Rate Limiting",
                "carbon_desc": "Генерация Carbon изображения",
                "pingmap_desc": "Быстрый поиск хостов",
                "r_desc": "Показать исходный код сообщения (HTML)"
            },
            "en": {
                "wait": "Processing...", "err": "Error", "err_net": "Network Error",
                "err_url": "URL not found in arguments", "err_target": "Target required",
                "err_inv": "Invalid Data", "err_limit": "API Limit", "err_notfound": "Not Found",
                "err_no_ports": "No open ports found", "err_api": "API Error",
                "cat_help": "HELP", "cat_info": "INFO", "cat_dns": "DNS / DOMAINS",
                "cat_net": "NETWORK", "cat_web": "WEB", "cat_util": "UTILITIES",
                "desc_no_set": "This command has no additional settings.",
                "h_out": "Output Settings", "h_prov": "Provider", "h_rec": "Record Types", "h_opt": "Options",
                "s_ip": "Show IP", "s_cont": "Continent", "s_country": "Country", "s_region": "Region",
                "s_city": "City", "s_zip": "Zip", "s_latlon": "Coords", "s_tz": "Timezone",
                "s_curr": "Currency", "s_isp": "ISP", "s_org": "Organization", "s_as": "ASN",
                "s_rev": "Reverse DNS", "s_mob": "Mobile", "s_proxy": "Proxy/VPN", "s_host": "Hosting",
                "s_raw": "Raw JSON", "s_res": "Auto-Resolve Domain", "s_head": "Headers",
                "s_body": "Body", "s_redir": "Follow Redirects",
                "lbl_ip": "IP", "lbl_country": "Country", "lbl_city": "City", "lbl_isp": "ISP",
                "lbl_org": "Org", "lbl_as": "AS", "lbl_status": "Status", "lbl_time": "Time", "lbl_prefix": "Prefix", "lbl_asname": "AS Name",
                "lbl_method": "Method", "lbl_url": "URL", "lbl_port": "Port", "lbl_state": "State", "lbl_name": "Name", "lbl_serv": "Service",
                "lbl_net": "Network", "lbl_mask": "Netmask", "lbl_wild": "Wildcard", "lbl_bcast": "Broadcast",
                "lbl_min": "HostMin", "lbl_max": "HostMax", "lbl_cnt": "Hosts", "lbl_bin": "Binary",
                "lbl_issued_to": "Issued To", "lbl_issued_by": "Issued By", "lbl_valid_u": "Valid Until",
                "lbl_serial": "Serial", "lbl_count": "Count", "lbl_list": "List", "lbl_orig": "Original",
                "lbl_short": "Short", "lbl_long": "Expanded", "lbl_res": "Result", "lbl_dec": "Decoded",
                "lbl_enc": "Encoded", "lbl_hsts": "HSTS", "lbl_frame": "X-Frame", "lbl_xss": "X-XSS",
                "lbl_server": "Server", "lbl_reg": "Registrar", "lbl_cr_date": "Creation Date",
                "lbl_ex_date": "Expires", "lbl_ns": "Nameservers", "lbl_seq": "Seq", "lbl_timeout": "timeout",
                "lbl_stats": "Stats", "lbl_avg": "Avg", "lbl_log": "Log", "lbl_open": "OPEN", "lbl_sent": "Sent", "lbl_closed": "CLOSED",
                "lbl_vendor": "Vendor", "lbl_vuln": "Vulns", "lbl_tags": "Tags",
                "lbl_tech": "Tech Stack", "lbl_cookies": "Cookies", "lbl_jitter": "Jitter",
                "lbl_loss": "Packet Loss", "lbl_license": "License", "lbl_version": "Version",
                "lbl_pkg": "Package", "lbl_alive": "Alive Hosts", "lbl_entities": "Entities",
                "err_reply": "Reply required", "err_sending": "File sending error",
                "cmd_whois": "Full IP Info", "cmd_dwhois": "Domain Registration Data", "cmd_myip": "Your External IP",
                "cmd_dns": "DNS Records", "cmd_dig": "Raw DNS Lookup", "cmd_ip": "Resolve Domain to IP",
                "cmd_sub": "Subdomains via SSL", "cmd_rev": "Reverse DNS (PTR)", "cmd_bgp": "BGP Routing Info",
                "cmd_black": "DNSBL IP Check", "cmd_calc": "Subnet Calculator", "cmd_scan": "Fast TCP Port Scanner",
                "cmd_ping": "TCP Ping", "cmd_ris": "RIPE Routing Info", "cmd_ports": "Open Ports (InternetDB)",
                "cmd_tcp": "TCP Connect Check", "cmd_udp": "UDP Packet Send", "cmd_wport": "Port Description",
                "cmd_intip": "IP <-> Integer", "cmd_cidr": "List IPs in CIDR", "cmd_curl": "HTTP Request",
                "cmd_red": "Trace Redirects", "cmd_cert": "SSL Certificate Info", "cmd_head": "HTTP Headers Only",
                "cmd_short": "URL Shortener", "cmd_unshort": "URL Expander", "cmd_sec": "Security Headers",
                "cmd_robot": "Get robots.txt", "cmd_hash": "Hashing", "cmd_b64": "Base64 Encoder",
                "cmd_url": "URL Encoder", "cmd_puny": "Punycode Converter", "cmd_json": "JSON Prettify",
                "cmd_mac": "MAC Vendor",
                "cmd_traceroute": "Traceroute", "cmd_time": "Time Converter",
                "cmd_color": "Color Converter", "cmd_speedtest": "Speed Test",
                "cmd_threat": "IP Reputation (Basic)", "cmd_dnshistory": "DNS History",
                "cmd_htmlencode": "HTML Encode", "cmd_htmldecode": "HTML Decode",
                "cmd_cat": "HTTP Cat", "cmd_zhelp": "Command List",
                "cmd_tld": "TLD Info", "cmd_tor": "Tor Check", "cmd_extract": "Link Extractor",
                "cmd_cve": "CVE Search", "cmd_emailsec": "Email Security", "cmd_gh": "GitHub Info",
                "cmd_waf": "WAF Detector", "cmd_shodan": "Shodan Info (Free API)",
                "cmd_jwt": "JWT Decoder", "cmd_sitemap": "Find Sitemap",
                "cmd_tech": "Tech Detector", "cmd_reputation": "Aggregated Reputation",
                "cmd_flood_check": "Rate Limit Test", "cmd_pypi": "PyPI Package",
                "cmd_npm": "NPM Package", "cmd_carbon": "Code to Image",
                "cmd_pingmap": "Subnet Ping (Sweep)", "cmd_r": "Raw Message HTML",
                "testing_speed": "Testing speed...", "download_speed": "Download Speed",
                "threat_score": "Threat Score", "threat_info": "Information",
                "safe": "Safe", "risky": "Potentially Risky",
                "proxy_detected": "Proxy/VPN detected", "hosting_detected": "Address belongs to a hosting provider",
                "cellular_network": "Cellular network", "history_not_found": "No history found for domain.",
                "shodan_desc": "Ports & Vulns via InternetDB",
                "jwt_desc": "Decode Token Payload",
                "tech_desc": "Website Tech Stack",
                "rep_desc": "IP-API + DNSBL",
                "flood_desc": "Check rate limiting",
                "carbon_desc": "Generate Carbon Image",
                "pingmap_desc": "Fast alive check",
                "r_desc": "Show raw message HTML source"
            }
        }

    def t(self, key):
        return self.strings.get(self.lang, self.strings["en"]).get(key, key)

    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def create_settings(self):
        try:
            return [
                Header(text=self.t("cat_help")),
                self._btn(".zhelp", "cmd_zhelp", self.s_help, "wZ_zhelp"),
                
                Header(text=self.t("cat_info")),
                self._btn(".whois", "cmd_whois", self.s_whois, "wZ_who"),
                self._btn(".dwhois", "cmd_dwhois", None, "wZ_dwho"),
                self._btn(".gh", "cmd_gh", None, "wZ_gh"),
                self._btn(".myip", "cmd_myip", None, "wZ_my"),
                self._btn(".mac", "cmd_mac", None, "wZ_mac"),
                self._btn(".threat", "cmd_threat", None, "wZ_threat"),
                self._btn(".reputation", "cmd_reputation", None, "wZ_rep"),
                self._btn(".shodan", "cmd_shodan", None, "wZ_shodan"),
                self._btn(".tor", "cmd_tor", None, "wZ_tor"),
                self._btn(".cve", "cmd_cve", None, "wZ_cve"),

                Header(text=self.t("cat_dns")),
                self._btn(".dns", "cmd_dns", self.s_dns, "wZ_dns"),
                self._btn(".dig", "cmd_dig", self.s_dig, "wZ_dig"),
                self._btn(".ip", "cmd_ip", None, "wZ_ip"),
                self._btn(".sub", "cmd_sub", None, "wZ_sub"),
                self._btn(".rev", "cmd_rev", None, "wZ_rev"),
                self._btn(".bgp", "cmd_bgp", None, "wZ_bgp"),
                self._btn(".black", "cmd_black", None, "wZ_bl"),
                self._btn(".dnshistory", "cmd_dnshistory", None, "wZ_dnshist"),
                self._btn(".tld", "cmd_tld", None, "wZ_tld"),
                self._btn(".emailsec", "cmd_emailsec", None, "wZ_emailsec"),

                Header(text=self.t("cat_net")),
                self._btn(".ipcalc", "cmd_calc", None, "wZ_calc"),
                self._btn(".scan", "cmd_scan", self.s_scan, "wZ_scan"),
                self._btn(".ping", "cmd_ping", None, "wZ_ping"),
                self._btn(".pingmap", "cmd_pingmap", None, "wZ_pmap"),
                self._btn(".ris", "cmd_ris", None, "wZ_ris"),
                self._btn(".ports", "cmd_ports", None, "wZ_prt"),
                self._btn(".tcp", "cmd_tcp", None, "wZ_tcp"),
                self._btn(".udp", "cmd_udp", None, "wZ_udp"),
                self._btn(".wport", "cmd_wport", None, "wZ_wp"),
                self._btn(".intip", "cmd_intip", None, "wZ_int"),
                self._btn(".cidr", "cmd_cidr", None, "wZ_cidr"),
                self._btn(".traceroute", "cmd_traceroute", None, "wZ_trace"),
                self._btn(".speedtest", "cmd_speedtest", None, "wZ_speed"),
                self._btn(".flood_check", "cmd_flood_check", None, "wZ_flood"),

                Header(text=self.t("cat_web")),
                self._btn(".curl", "cmd_curl", self.s_curl, "wZ_curl"),
                self._btn(".tech", "cmd_tech", None, "wZ_tech"),
                self._btn(".sitemap", "cmd_sitemap", None, "wZ_map"),
                self._btn(".redirects", "cmd_red", None, "wZ_red"),
                self._btn(".cert", "cmd_cert", None, "wZ_cert"),
                self._btn(".header", "cmd_head", None, "wZ_head"),
                self._btn(".short", "cmd_short", None, "wZ_sho"),
                self._btn(".unshort", "cmd_unshort", None, "wZ_un"),
                self._btn(".sec", "cmd_sec", None, "wZ_sec"),
                self._btn(".robot", "cmd_robot", None, "wZ_rob"),
                self._btn(".cat", "cmd_cat", None, "wZ_cat"),
                self._btn(".extract", "cmd_extract", None, "wZ_ext"),
                self._btn(".waf", "cmd_waf", None, "wZ_waf"),

                Header(text=self.t("cat_util")),
                self._btn(".hash", "cmd_hash", None, "wZ_hash"),
                self._btn(".b64", "cmd_b64", None, "wZ_b64"),
                self._btn(".jwt", "cmd_jwt", None, "wZ_jwt"),
                self._btn(".url", "cmd_url", None, "wZ_url"),
                self._btn(".puny", "cmd_puny", None, "wZ_puny"),
                self._btn(".json", "cmd_json", None, "wZ_json"),
                self._btn(".time", "cmd_time", None, "wZ_time"),
                self._btn(".color", "cmd_color", None, "wZ_color"),
                self._btn(".htmlencode", "cmd_htmlencode", None, "wZ_htmlenc"),
                self._btn(".htmldecode", "cmd_htmldecode", None, "wZ_htmldec"),
                self._btn(".carbon", "cmd_carbon", None, "wZ_carbon"),
                self._btn(".pypi", "cmd_pypi", None, "wZ_pypi"),
                self._btn(".npm", "cmd_npm", None, "wZ_npm"),
                self._btn(".r", "cmd_r", None, "wZ_r"),
            ]
        except:
            return [Header(text="Error loading settings")]

    def _btn(self, cmd, desc_key, sub, alias):
        desc = self.t(desc_key)
        if sub is None:
            sub = lambda: [Header(text=f"{cmd}"), Text(text=desc), Divider(text=self.t("desc_no_set"))]
        return Text(text=f"{cmd} • {desc}", create_sub_fragment=sub, link_alias=alias)

    def s_whois(self):
        return [
            Header(text=self.t("h_out")),
            Switch(key="w_ip", text=self.t("s_ip"), default=True),
            Switch(key="w_cont", text=self.t("s_cont"), default=False),
            Switch(key="w_country", text=self.t("s_country"), default=True),
            Switch(key="w_region", text=self.t("s_region"), default=False),
            Switch(key="w_city", text=self.t("s_city"), default=True),
            Switch(key="w_zip", text=self.t("s_zip"), default=False),
            Switch(key="w_latlon", text=self.t("s_latlon"), default=True),
            Switch(key="w_tz", text=self.t("s_tz"), default=False),
            Switch(key="w_curr", text=self.t("s_curr"), default=False),
            Switch(key="w_isp", text=self.t("s_isp"), default=True),
            Switch(key="w_org", text=self.t("s_org"), default=True),
            Switch(key="w_as", text=self.t("s_as"), default=True),
            Switch(key="w_rev", text=self.t("s_rev"), default=True),
            Switch(key="w_mob", text=self.t("s_mob"), default=True),
            Switch(key="w_proxy", text=self.t("s_proxy"), default=True),
            Switch(key="w_host", text=self.t("s_host"), default=True),
        ]

    def s_scan(self): return [Header(text=self.t("h_opt")), Switch(key="scan_resolve", text=self.t("s_res"), default=True)]
    def s_dig(self): return [Header(text=self.t("h_prov")), Selector(key="dig_prov", text="Resolver", default=1, items=["Google", "Cloudflare"])]

    def s_dns(self):
        return [
            Header(text=self.t("h_prov")),
            Selector(key="dns_prov", text="DNS", default=2, items=["Google", "Cloudflare", "Quad9", "All"]),
            Header(text=self.t("h_rec")),
            Switch(key="dns_a", text="A", default=True),
            Switch(key="dns_mx", text="MX", default=True),
            Switch(key="dns_ns", text="NS", default=True),
            Switch(key="dns_txt", text="TXT", default=False),
            Switch(key="dns_cname", text="CNAME", default=True),
            Switch(key="dns_soa", text="SOA", default=False)
        ]

    def s_curl(self):
        return [
            Header(text=self.t("h_opt")),
            Switch(key="curl_head", text=self.t("s_head"), default=True),
            Switch(key="curl_body", text=self.t("s_body"), default=True),
            Switch(key="curl_follow", text=self.t("s_redir"), default=True),
            Selector(key="curl_method", text="Method", default=0, items=["GET", "HEAD", "POST"])
        ]

    def s_help(self):
        cmds = [
            ".whois <ip>", ".dwhois <domain>", ".myip", ".mac <mac>", ".threat <ip>",
            ".dns <domain>", ".dig <domain>", ".ip <domain>", ".sub <domain>", ".rev <ip>",
            ".bgp <ip>", ".black <ip>", ".dnshistory <domain>", ".tld <zone>", ".emailsec <domain>",
            ".ipcalc <cidr>", ".scan <ip>", ".ping <ip>", ".ris <ip>", ".ports <ip>",
            ".tcp <ip:port>", ".udp <ip:port>", ".wport <port>", ".intip <ip/int>", ".cidr <cidr>",
            ".traceroute <ip>", ".speedtest", ".flood_check <ip>", ".pingmap <cidr>",
            ".curl <url>", ".redirects <url>", ".cert <domain>", ".header <url>",
            ".short <url>", ".unshort <url>", ".sec <url>", ".robot <url>", ".cat <url>",
            ".extract <url>", ".waf <url>", ".tech <url>", ".sitemap <url>",
            ".hash <text>", ".b64 <text>", ".url <text>", ".puny <text>", ".json <json>",
            ".jwt <token>", ".time <ts/date>", ".color <hex/rgb>", ".htmlencode <text>", ".htmldecode <text>",
            ".gh <user>", ".cve <soft>", ".pypi <pkg>", ".npm <pkg>", ".carbon <code>",
            ".r"
        ]
        return [Header(text="Commands")] + [Text(text=c) for c in cmds]

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        msg = str(getattr(params, "message", "")).strip()
        if not msg.startswith("."): return HookResult()
        
        msg = msg.replace('\xa0', ' ')
        try: parts = shlex.split(msg)
        except: parts = msg.split()
        if not parts: return HookResult()
        
        cmd = parts[0].lower()
        args = parts[1:]
        handler_name = f"h_{cmd[1:]}"
        
        if hasattr(self, handler_name):
            self._prog(True)
            run_on_queue(lambda: self._exec(handler_name, args, params.peer, account, params), EXTERNAL_NETWORK_QUEUE)
            return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

    def _prog(self, show):
        def _a():
            if show:
                f = get_last_fragment()
                if f and f.getParentActivity():
                    self.progress_dialog = AlertDialogBuilder(f.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                    self.progress_dialog.set_message(self.t("wait"))
                    self.progress_dialog.show()
                    self.progress_dialog.set_cancelable(False)
            elif self.progress_dialog:
                self.progress_dialog.dismiss()
                self.progress_dialog = None
        run_on_ui_thread(_a)

    def _exec(self, h_name, args, peer, account=None, params=None):
        cmd_display = h_name[2:].upper()
        try:
            handler = getattr(self, h_name)
            no_arg = ["h_myip", "h_speedtest", "h_zhelp"]
            
            if h_name not in no_arg and not args and h_name != "h_r":
                self._reply(peer, f"{cmd_display} ERROR", [(self.t("err_target"), f".{h_name[2:]} <args>")])
                return

            if h_name == "h_r":
                result = handler(args, account=account, params=params, peer=peer)
            elif h_name == "h_carbon":
                result = handler(args, params=params)
            else:
                result = handler(args)
            
            if result is None:
                return

            if isinstance(result, tuple) and len(result) == 2 and result[0] == "DIRECT_SEND":
                self._send_direct(peer, **result[1])
                return

            title, lines = result
            self._reply(peer, title, lines)
        except Exception as e:
            self._reply(peer, f"{cmd_display} ERROR", [(self.t("err"), str(e))])
            log(traceback.format_exc())

    def _res(self, t):
        try: return socket.gethostbyname(t)
        except: return t

    def _arg(self, args, flags, default=None):
        for i, a in enumerate(args):
            if a in flags and i+1 < len(args): return args[i+1]
        return default

    def _get_target(self, args, is_url=False):
        for arg in reversed(args):
            if not arg.startswith("-"):
                if is_url and not arg.startswith("http"):
                    return "http://" + arg
                return arg
        return ""
    
    def _url(self, args):
        t = self._get_target(args)
        if not t.startswith("http"):
            t = "http://" + t
        return t

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.applicationContext.getExternalCacheDir()
            if not base_dir: return None
            temp_dir = File(base_dir, "zwy_temp")
            if not temp_dir.exists() and not temp_dir.mkdirs(): return None
            return temp_dir.getAbsolutePath()
        except: return None

    def _delete_file_delayed(self, path: str):
        threading.Thread(target=lambda: (time.sleep(60), os.remove(path) if os.path.exists(path) else None), daemon=True).start()

    def _get_peer_id(self, peer):
        try:
            if "InputPeerSelf" in str(peer): return get_user_config().getClientUserId()
            if hasattr(peer, "user_id"): return peer.user_id
            if hasattr(peer, "chat_id"): return -peer.chat_id
            if hasattr(peer, "channel_id"): return -peer.channel_id
            if str(peer).isdigit(): return int(str(peer))
            return 0
        except: return 0

    def _send_file(self, content, filename, params, is_binary=False):
        temp_dir = self._get_temp_dir()
        if not temp_dir: raise Exception(self.t("err_sending") + " (No Cache)")
        file_path = os.path.join(temp_dir, filename)
        try:
            mode = "wb" if is_binary else "w"
            encoding = None if is_binary else "utf-8"
            with open(file_path, mode, encoding=encoding) as f: f.write(content)
        except Exception as e: raise Exception(f"{self.t('err_sending')}: {e}")

        peer_id = self._get_peer_id(params.peer)
        if peer_id == 0: raise Exception("Invalid Peer ID")

        def _send_ui():
            try:
                account_inst = get_account_instance()
                reply_msg_obj = None
                
                if hasattr(params, "reply_to_msg_id") and params.reply_to_msg_id:
                    fragment = get_last_fragment()
                    if fragment and hasattr(fragment, "getDialogId") and fragment.getDialogId() == peer_id:
                         reply_msg_obj = fragment.getReplyMessage()
                
                mime = "image/png" if filename.endswith(".png") else "text/plain"
                
                SendMessagesHelper.prepareSendingDocument(
                    account_inst, file_path, file_path, None, "", mime,
                    peer_id, reply_msg_obj, None, None, None, None, True, 0, None, None, 0, False
                )
                self._delete_file_delayed(file_path)
                self._prog(False)
            except Exception as e:
                log(f"Send error: {e}")
                self._prog(False)
        run_on_ui_thread(_send_ui)

    def _unparse_entities(self, text, entities):
        if not text: return ""
        if not entities: return html.escape(text)

        py_ents = []
        try:
            py_ents = list(entities)
        except:
            if hasattr(entities, "size"):
                for i in range(entities.size()):
                    py_ents.append(entities.get(i))

        markers = []

        for e in py_ents:
            cls_name = e.__class__.__name__
            off = getattr(e, "offset", 0)
            length = getattr(e, "length", 0)
            end = off + length

            tag_start = ""
            tag_end = ""

            if "MessageEntityBold" in cls_name:
                tag_start, tag_end = "<b>", "</b>"
            elif "MessageEntityItalic" in cls_name:
                tag_start, tag_end = "<i>", "</i>"
            elif "MessageEntityCode" in cls_name:
                tag_start, tag_end = "<code>", "</code>"
            elif "MessageEntityPre" in cls_name:
                lang = getattr(e, "language", "")
                tag_start = f'<pre language="{lang}">' if lang else "<pre>"
                tag_end = "</pre>"
            elif "MessageEntityStrike" in cls_name:
                tag_start, tag_end = "<s>", "</s>"
            elif "MessageEntityUnderline" in cls_name:
                tag_start, tag_end = "<u>", "</u>"
            elif "MessageEntitySpoiler" in cls_name:
                tag_start, tag_end = "<tg-spoiler>", "</tg-spoiler>"
            elif "MessageEntityTextUrl" in cls_name:
                url = getattr(e, "url", "")
                tag_start, tag_end = f'<a href="{url}">', "</a>"
            elif "MessageEntityBlockquote" in cls_name:
                is_collapsed = getattr(e, "collapsed", False)
                tag_start = '<blockquote expandable>' if is_collapsed else '<blockquote>'
                tag_end = "</blockquote>"
            elif "MessageEntityCustomEmoji" in cls_name:
                eid = getattr(e, "document_id", 0)
                tag_start, tag_end = f'<tg-emoji emoji-id="{eid}">', "</tg-emoji>"

            if tag_start:
                markers.append((off, 1, tag_start))
                markers.append((end, 0, tag_end))

        markers.sort(key=lambda x: (x[0], x[1]))

        res = []
        cur = 0
        for pos, priority, tag in markers:
            if pos > cur:
                res.append(html.escape(text[cur:pos]))
                cur = pos
            res.append(tag)
        
        if cur < len(text):
            res.append(html.escape(text[cur:]))

        return "".join(res)

    def h_carbon(self, args, params=None):
        if not params: raise Exception(self.t("err_inv"))
        
        full_text = getattr(params, "message", "")
        code = re.sub(r'^\.carbon\s*', '', full_text, flags=re.IGNORECASE).strip()
        
        if not code: raise Exception(self.t("err_inv"))
        
        try:
            api_url = "https://carbonara.solopov.dev/api/cook"
            payload = {"code": code, "backgroundColor": "#abb8c3", "theme": "seti"}
            r = requests.post(api_url, json=payload, timeout=20)
            r.raise_for_status()
            image_data = r.content
        except Exception as e:
             raise Exception(f"{self.t('err_api')}: {e}")

        self._send_file(image_data, "carbon.png", params, is_binary=True)
        return None

    def h_dwhois(self, args):
        t = self._get_target(args)
        try:
            r = requests.get(f"https://rdap.org/domain/{t}", timeout=20, headers={"User-Agent": "Mozilla/5.0"})
            r.raise_for_status()
        except requests.exceptions.RequestException as e:
            if isinstance(e, requests.exceptions.HTTPError):
                if e.response.status_code == 404:
                    raise Exception(self.t("err_notfound"))
                else:
                    raise Exception(f"{self.t('err_api')}: {e.response.status_code} {e.response.reason}")
            else:
                raise Exception(self.t("err_net"))
        
        d = r.json()
        
        reg_date, exp_date = "", ""
        for event in d.get("events", []):
            if event.get("eventAction") == "registration": reg_date = event.get("eventDate")
            if event.get("eventAction") == "expiration": exp_date = event.get("eventDate")

        registrar = ""
        for entity in d.get("entities", []):
            if "registrar" in entity.get("roles", []):
                registrar = entity.get("vcardArray", [None, [["fn", {}, "text", ""]]])[1][0][3]
                break

        ns = "\n" + "\n".join([ns.get("ldhName") for ns in d.get("nameservers", [])])
        
        l = [
            (self.t("lbl_reg"), registrar),
            (self.t("lbl_cr_date"), reg_date),
            (self.t("lbl_ex_date"), exp_date),
            (self.t("lbl_ns"), ns),
            (self.t("lbl_status"), "\n" + "\n".join(d.get("status", []))),
        ]
        return f"DOMAIN WHOIS: {t}", l

    def h_cert(self, args):
        t = self._get_target(args); p = 443
        try:
            ctx = ssl.create_default_context()
            with socket.create_connection((t, p), timeout=10) as s:
                with ctx.wrap_socket(s, server_hostname=t) as ss:
                    c = ss.getpeercert()
            subj = dict(x[0] for x in c['subject'])
            iss = dict(x[0] for x in c['issuer'])
            return f"SSL: {t}", [
                (self.t("lbl_issued_to"), subj.get('commonName')),
                (self.t("lbl_issued_by"), iss.get('commonName')),
                (self.t("lbl_org"), subj.get('organizationName', 'N/A')),
                (self.t("lbl_valid_u"), c['notAfter']),
                (self.t("lbl_serial"), str(c['serialNumber']))
            ]
        except Exception as e: return f"SSL: {t}", [(self.t("err"), str(e))]

    def h_ipcalc(self, args):
        try:
            n = ipaddress.ip_network(self._res(args[0]), strict=False)
            res = [
                (self.t("lbl_net"), str(n)), (self.t("lbl_mask"), str(n.netmask)),
                (self.t("lbl_wild"), str(n.hostmask)), (self.t("lbl_bcast"), str(n.broadcast_address)),
                (self.t("lbl_min"), str(n[1]) if n.num_addresses > 1 else "N/A"),
                (self.t("lbl_max"), str(n[-2]) if n.num_addresses > 1 else "N/A"),
                (self.t("lbl_cnt"), f"{n.num_addresses - 2 if n.num_addresses > 1 else n.num_addresses:,}"), 
                (self.t("lbl_bin"), f"\n{n.network_address:b}")
            ]
            if n.num_addresses > 1 and n.num_addresses <= 34: 
                res.append(("IPs", "\n" + "\n".join([str(ip) for ip in n.hosts()])))
            return f"IPCALC: {args[0]}", res
        except: raise Exception(self.t("err_inv"))

    def h_dig(self, args):
        rec = "A"; p_idx = self.get_setting("dig_prov", 1); p_url = ["https://dns.google/resolve", "https://cloudflare-dns.com/dns-query"][p_idx]
        t = ""; is_rev = False
        for a in args:
            if a.startswith("@"):
                if "google" in a: p_url = "https://dns.google/resolve"
                elif "cloud" in a: p_url = "https://cloudflare-dns.com/dns-query"
            elif a == "-x": is_rev = True
            elif a.startswith("+") or a.startswith("-"): continue
            elif a.upper() in ["A", "AAAA", "MX", "NS", "TXT", "PTR", "CNAME", "SOA", "ANY"]: rec = a.upper()
            elif not t: t = a
        if not t: raise Exception(self.t("err_target"))
        if is_rev:
            try: t = ipaddress.ip_address(t).reverse_pointer; rec = "PTR"
            except: pass
        try:
            r = requests.get(f"{p_url}?name={t}&type={rec}", headers={"Accept": "application/dns-json"}, timeout=10).json()
            ans = "\n".join([f"{x['name']} {x['type']} {x['data']}" for x in r.get("Answer", [])]) if r.get("Answer") else self.t("err_notfound")
            return f"DIG: {t} ({rec})", [(self.t("lbl_status"), str(r.get("Status"))), ("Answer", "\n" + ans)]
        except Exception as e: raise Exception(str(e))

    def h_curl(self, args):
        t = self._get_target(args, is_url=True); m_idx = self.get_setting("curl_method", 0); m = ["GET", "HEAD", "POST"][m_idx]
        h = {"User-Agent": "Mozilla/5.0"}; d = None; i = 0
        while i < len(args):
            a = args[i]
            if a in ["-X"] and i+1 < len(args): m = args[i+1].upper(); i+=2
            elif a in ["-H"] and i+1 < len(args): 
                if ":" in args[i+1]: k,v = args[i+1].split(":",1); h[k.strip()] = v.strip()
                i+=2
            elif a in ["-d"] and i+1 < len(args): d = args[i+1]; i+=2
            elif a in ["-I"]: m = "HEAD"; i+=1
            else: i+=1
        if not t: raise Exception(self.t("err_url"))
        st = time.time()
        try:
            r = requests.request(m, t, headers=h, data=d, timeout=15, allow_redirects=self.get_setting("curl_follow", True))
            lat = (time.time() - st) * 1000
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))
        l = [(self.t("lbl_url"), t), (self.t("lbl_method"), m), (self.t("lbl_status"), f"{r.status_code} {r.reason}"), (self.t("lbl_time"), f"{lat:.0f}ms")]
        if self.get_setting("curl_head", True): l.append((self.t("s_head"), "\n" + "\n".join([f"{k}: {v}" for k,v in r.headers.items()])))
        if self.get_setting("curl_body", True) and m != "HEAD":
            body_text = r.text.replace("`", "'")
            b = body_text[:2000] + ("\n..." if len(body_text)>2000 else "")
            l.append((self.t("s_body"), f"```\n{b}\n```"))
        return f"CURL", l

    def h_scan(self, args):
        t = self._get_target(args)
        if self.get_setting("scan_resolve", True): t = self._res(t)
        p_arg = self._arg(args, ["-p"], "21,22,23,25,53,80,110,143,443,465,587,993,995,3306,3389,5432,6379,8080")
        to = float(self._arg(args, ["-t"], "0.4"))
        try: ports = [int(x) for x in p_arg.split(",")]
        except: raise Exception(self.t("err_inv"))
        res = []; st = time.time()
        for p in ports:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.settimeout(to)
                if s.connect_ex((t, p)) == 0:
                    try: sv = socket.getservbyport(p)
                    except: sv = "?"
                    res.append(f"{p:<5} {sv:<10} {self.t('lbl_open')}")
                s.close()
            except: pass
        return f"SCAN: {t}", [(self.t("lbl_time"), f"{time.time()-st:.2f}s"), (self.t("lbl_port"), "\n" + "\n".join(res) if res else self.t("err_no_ports"))]

    def h_ping(self, args):
        t = self._get_target(args); p = int(self._arg(args, ["-p"], "80")); c = int(self._arg(args, ["-c"], "4"))
        l = []; ok = 0; tot = 0
        for i in range(c):
            try:
                st = time.time(); s = socket.socket(); s.settimeout(2); s.connect((t, p)); s.close()
                lat = (time.time() - st) * 1000; l.append(f"{self.t('lbl_seq')}={i+1} time={lat:.2f}ms"); tot += lat; ok += 1
            except: l.append(f"{self.t('lbl_seq')}={i+1} {self.t('lbl_timeout')}")
            time.sleep(0.2)
        avg = tot / ok if ok > 0 else 0
        return f"PING: {t}:{p}", [(self.t("lbl_stats"), f"{ok}/{c}"), (self.t("lbl_avg"), f"{avg:.2f}ms"), (self.t("lbl_log"), "\n" + "\n".join(l))]

    def h_wport(self, args):
        try: 
            port = int(args[0])
            service = socket.getservbyport(port)
            return f"PORT {port}", [(self.t("lbl_name"), service)]
        except (ValueError, OSError): 
            return f"PORT {args[0]}", [(self.t("lbl_name"), "?")]

    def h_intip(self, args):
        v = self._res(args[0])
        try:
            if "." in v: return "IP->INT", [(self.t("lbl_ip"), v), ("Int", str(int(ipaddress.IPv4Address(v))))]
            else: return "INT->IP", [("Int", v), (self.t("lbl_ip"), str(ipaddress.IPv4Address(int(v))))]
        except: raise Exception(self.t("err_inv"))

    def h_tcp(self, args):
        t = self._get_target(args); p = int(self._arg(args, ["-p"], "80"))
        if ":" in t: t, p_str = t.split(":", 1); p = int(p_str)
        t = self._res(t)
        try:
            st = time.time(); s = socket.socket(); s.settimeout(3); r = s.connect_ex((t, p)); s.close()
            return f"TCP: {t}:{p}", [(self.t("lbl_state"), "OPEN" if r==0 else f"{self.t('lbl_closed')} ({r})"), (self.t("lbl_time"), f"{(time.time()-st)*1000:.2f}ms")]
        except Exception as e: return f"TCP: {t}:{p}", [(self.t("err"), str(e))]

    def h_udp(self, args):
        t = self._get_target(args); p = int(self._arg(args, ["-p"], "53"))
        if ":" in t: t, p_str = t.split(":", 1); p = int(p_str)
        t = self._res(t)
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.settimeout(2); s.sendto(b'', (t, p))
            return f"UDP: {t}:{p}", [(self.t("lbl_state"), self.t("lbl_sent")), ("Note", "Stateless")]
        except Exception as e: return f"UDP: {t}:{p}", [(self.t("err"), str(e))]

    def h_ip(self, args):
        t = self._get_target(args)
        try: return "RESOLVE", [("Target", t), ("IP", socket.gethostbyname(t))]
        except: return "RESOLVE", [(self.t("err"), "Failed")]

    def h_cidr(self, args):
        try:
            n = ipaddress.ip_network(self._res(args[0]), strict=False)
            if n.num_addresses > 256: return "CIDR", [(self.t("err"), "Max /24")]
            return f"CIDR: {args[0]}", [(self.t("lbl_list"), "\n" + "\n".join([str(ip) for ip in n]))]
        except: raise Exception(self.t("err_inv"))

    def h_sec(self, args):
        t = self._url(args)
        try:
            h = requests.head(t, timeout=10, allow_redirects=True, headers={"User-Agent": "Mozilla/5.0"}).headers
            return f"SEC: {t}", [
                (self.t("lbl_hsts"), h.get("Strict-Transport-Security", "No")),
                (self.t("lbl_frame"), h.get("X-Frame-Options", "No")),
                (self.t("lbl_xss"), h.get("X-XSS-Protection", "No")),
                (self.t("lbl_server"), h.get("Server", "?"))
            ]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_robot(self, args):
        t = self._url(args).rstrip("/") + "/robots.txt"
        try:
            r = requests.get(t, timeout=10)
            r.raise_for_status()
            return f"ROBOTS: {t}", [(self.t("lbl_status"), r.status_code), (self.t("s_body"), "\n" + r.text[:3000])]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_whois(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"http://ip-api.com/json/{t}?fields=status,message,continent,continentCode,country,countryCode,region,regionName,city,district,zip,lat,lon,timezone,offset,currency,isp,org,as,asname,reverse,mobile,proxy,hosting,query", timeout=10).json()
            if r.get("status") != "success": raise Exception("Fail: " + r.get("message", self.t("err_api")))
            l = []
            if self.get_setting("w_ip", True): l.append((self.t("lbl_ip"), r.get("query")))
            if self.get_setting("w_cont", False) and r.get('continent'): l.append((self.t("s_cont"), f"{r.get('continent')} ({r.get('continentCode')})"))
            if self.get_setting("w_country", True) and r.get('country'): l.append((self.t("s_country"), f"{r.get('country')} ({r.get('countryCode')})"))
            if self.get_setting("w_region", False) and r.get('regionName'): l.append((self.t("s_region"), f"{r.get('regionName')} ({r.get('region')})"))
            if self.get_setting("w_city", True) and r.get('city'): l.append((self.t("s_city"), r.get("city")))
            if self.get_setting("w_zip", False) and r.get('zip'): l.append((self.t("s_zip"), r.get("zip")))
            if self.get_setting("w_latlon", True) and r.get('lat'): l.append((self.t("s_latlon"), f"{r.get('lat')}, {r.get('lon')}"))
            if self.get_setting("w_tz", False) and r.get('timezone'): l.append((self.t("s_tz"), r.get("timezone")))
            if self.get_setting("w_curr", False) and r.get('currency'): l.append((self.t("s_curr"), r.get("currency")))
            if self.get_setting("w_isp", True) and r.get('isp'): l.append((self.t("s_isp"), r.get("isp")))
            if self.get_setting("w_org", True) and r.get('org'): l.append((self.t("s_org"), r.get("org")))
            if self.get_setting("w_as", True) and r.get('as'): l.extend([(self.t("lbl_as"), r.get("as")), (self.t("lbl_asname"), r.get("asname"))])
            if self.get_setting("w_rev", True) and r.get('reverse'): l.append((self.t("s_rev"), r.get("reverse")))
            if self.get_setting("w_mob", True): l.append((self.t("s_mob"), str(r.get("mobile"))))
            if self.get_setting("w_proxy", True): l.append((self.t("s_proxy"), str(r.get("proxy"))))
            if self.get_setting("w_host", True): l.append((self.t("s_host"), str(r.get("hosting"))))
            return f"WHOIS: {t}", l
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_dns(self, args):
        t = self._get_target(args); recs = []
        if self.get_setting("dns_a", True): recs.append("A")
        if self.get_setting("dns_mx", True): recs.append("MX")
        if self.get_setting("dns_ns", True): recs.append("NS")
        if self.get_setting("dns_txt", False): recs.append("TXT")
        if self.get_setting("dns_cname", True): recs.append("CNAME")
        if self.get_setting("dns_soa", False): recs.append("SOA")
        if not recs: recs = ["A"]
        
        pidx = self.get_setting("dns_prov", 2)
        provs = []
        if pidx in [0, 3]: provs.append(("Google", "https://dns.google/resolve"))
        if pidx in [1, 3]: provs.append(("Cloudflare", "https://cloudflare-dns.com/dns-query"))
        if pidx in [2, 3]: provs.append(("Quad9", "https://dns.quad9.net:5053/dns-query"))
        
        lines = []
        for name, url in provs:
            if pidx == 3: lines.append(("---", f" {name} ---"))
            for rt in recs:
                try:
                    r = requests.get(f"{url}?name={t}&type={rt}", headers={"Accept": "application/dns-json"}, timeout=5).json()
                    if "Answer" in r: lines.append((rt, "\n" + "\n".join([x['data'] for x in r["Answer"]])))
                except: pass
        if not lines: lines.append((self.t("lbl_res"), self.t("err_notfound")))
        return f"DNS: {t}", lines

    def h_redirects(self, args):
        t = self._url(args)
        try:
            r = requests.get(t, timeout=10, headers={"User-Agent": "Mozilla/5.0"}, allow_redirects=True)
            history = r.history + [r]
            l = []
            for i, resp in enumerate(history):
                step_name = f"Step {i+1}" if i < len(history) - 1 else "Final"
                l.append((step_name, f"`{resp.status_code}` -> {resp.url}"))
            return "REDIRECTS", l
        except requests.exceptions.TooManyRedirects:
            raise Exception("Too many redirects")
        except requests.exceptions.RequestException as e:
            raise Exception(f"{self.t('err_net')}: {type(e).__name__}")

    def h_myip(self, _):
        try:
            r = requests.get("https://ifconfig.co/json", timeout=10).json()
            return "MY IP", [(self.t("lbl_ip"), r.get("ip")), (self.t("lbl_as"), r.get("asn")), (self.t("lbl_isp"), r.get("asn_org")), (self.t("lbl_country"), f"{r.get('city')}, {r.get('country')}")]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_short(self, args):
        try: return "SHORT", [(self.t("lbl_orig"), args[0]), (self.t("lbl_short"), requests.get(f"https://tinyurl.com/api-create.php?url={args[0]}", timeout=10).text)]
        except: raise Exception(self.t("err"))

    def h_unshort(self, args):
        t = self._url(args)
        try: return "UNSHORT", [(self.t("lbl_short"), t), (self.t("lbl_long"), requests.head(t, allow_redirects=True, timeout=10).url)]
        except: raise Exception(self.t("err"))

    def h_hash(self, args):
        a = self._arg(args, ["-a"], "all"); t = " ".join([arg for arg in args if not arg.startswith("-")]).encode()
        algs = ["md5", "sha1", "sha256", "sha512"] if a == "all" else [a]
        l = []
        for x in algs:
            if hasattr(hashlib, x): l.append((x.upper(), getattr(hashlib, x)(t).hexdigest()))
        return "HASH", l

    def h_json(self, args):
        j_str = " ".join(args)
        if not j_str: raise Exception(self.t("err_inv"))
        try:
            return "JSON", [("Pretty", "\n" + json.dumps(json.loads(j_str), indent=2))]
        except json.JSONDecodeError:
            raise Exception(self.t("err_inv"))

    def h_bgp(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"https://api.bgpview.io/ip/{t}", timeout=10)
            r.raise_for_status()
            data = r.json()
            if data.get("status", "") == "error":
                raise Exception(data.get("status_message", self.t("err_api")))
            p = data.get("data", {}).get("prefixes", [])[0] if data.get("data", {}).get("prefixes") else {}
            if not p: return f"BGP: {t}", [(self.t("err"), self.t("err_notfound"))]
            return f"BGP: {t}", [(self.t("lbl_prefix"), p.get("prefix", "N/A")), (self.t("lbl_as"), p.get("asn", {}).get("asn", "N/A")), (self.t("lbl_name"), p.get("asn", {}).get("name", "N/A"))]
        except requests.exceptions.RequestException:
            raise Exception(self.t("err_net"))
        except (IndexError, KeyError):
            raise Exception(f"{self.t('err_api')}: Invalid response format")

    def h_ris(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"https://stat.ripe.net/data/network-info/data.json?resource={t}", timeout=10)
            r.raise_for_status()
            r_json = r.json()
            if r_json.get("status") != "ok":
                raise Exception(f"{self.t('err_api')}: " + r_json.get("messages", [["API error"]])[0][1])
            d = r_json.get("data", {})
            return f"RIPE: {t}", [(self.t("lbl_prefix"), d.get("prefix")), ("ASNs", ", ".join(map(str, d.get("asns", []))))]
        except requests.exceptions.RequestException:
            raise Exception(self.t("err_net"))
        except (KeyError, IndexError):
            raise Exception(f"{self.t('err_api')}: Invalid response format")

    def h_ports(self, args):
        return self.h_shodan(args) 

    def h_sub(self, args):
        d = self._get_target(args)
        try:
            r = requests.get(f"https://crt.sh/?q=%.{d}&output=json", timeout=20).json()
            s = sorted(list(set([x['name_value'] for x in r if '*' not in x['name_value']])))[:30]
            return f"SUBDOMAINS: {d}", [(self.t("lbl_count"), str(len(r))), (self.t("lbl_list"), "\n" + "\n".join(s))]
        except: raise Exception("CRT.SH Error")

    def h_rev(self, args):
        t = self._get_target(args)
        try: return f"REVERSE: {t}", [(self.t("lbl_name"), socket.gethostbyaddr(t)[0])]
        except: return f"REVERSE: {t}", [(self.t("err"), self.t("err_notfound"))]

    def h_black(self, args):
        ip = self._res(self._get_target(args))
        r_ip = ".".join(reversed(ip.split(".")))
        zones = ["zen.spamhaus.org", "bl.spamcop.net", "b.barracudacentral.org"]
        res = []
        for z in zones:
            try:
                socket.gethostbyname(f"{r_ip}.{z}")
                res.append((z, "LISTED"))
            except socket.gaierror:
                res.append((z, "Clean"))
        return f"DNSBL: {ip}", res

    def h_b64(self, a):
        t = " ".join(a)
        try: return "BASE64", [(self.t("lbl_dec"), "\n" + base64.b64decode(t).decode())]
        except: return "BASE64", [(self.t("lbl_enc"), "\n" + base64.b64encode(t.encode()).decode())]

    def h_url(self, a):
        t = " ".join(a)
        return "URL", [(self.t("lbl_res"), "\n" + (urllib.parse.unquote(t) if "%" in t else urllib.parse.quote(t)))]

    def h_puny(self, a):
        t = " ".join(a)
        try:
            if t.startswith("xn--"):
                return "PUNY", [(self.t("lbl_dec"), t.encode('utf-8').decode('idna'))]
            else:
                return "PUNY", [(self.t("lbl_enc"), t.encode('idna').decode('utf-8'))]
        except:
             raise Exception(self.t("err_inv"))
        
    def h_mac(self, args):
        try:
            mac = self._get_target(args)
            r = requests.get(f"https://api.macvendors.co/v1/{mac}", timeout=10).text
            return f"MAC: {mac}", [(self.t("lbl_vendor"), r)]
        except:
            return f"MAC: {mac}", [(self.t("lbl_vendor"), self.t("err_notfound"))]
    
    def h_header(self, args):
        t = self._url(args)
        try:
            r = requests.head(t, timeout=10, allow_redirects=True, headers={"User-Agent": "Mozilla/5.0"})
            r.raise_for_status()
            headers = "\n".join([f"{k}: {v}" for k, v in r.headers.items()])
            return f"HEADERS: {t}", [(f"{r.status_code} {r.reason}", f"```{headers}```")]
        except requests.exceptions.RequestException:
            raise Exception(self.t("err_net"))
    
    def h_traceroute(self, args):
        t = self._res(self._get_target(args))
        try:
            payload = {"type": "traceroute", "target": t, "limit": 1}
            r = requests.post("https://api.globalping.io/v1/measurements", json=payload, headers={"User-Agent": "Mozilla/5.0", "Content-Type": "application/json"}, timeout=15)
            if r.status_code >= 400:
                try: err_text = r.json().get("message", r.text)
                except: err_text = r.text[:100]
                raise Exception(f"API Error {r.status_code}: {err_text}")
            req_id = r.json().get("id")
            if not req_id: raise Exception("API returned success but no ID")
            for _ in range(12):
                time.sleep(1.5)
                r2 = requests.get(f"https://api.globalping.io/v1/measurements/{req_id}", headers={"User-Agent": "Mozilla/5.0"}, timeout=10)
                if r2.status_code == 200:
                    data = r2.json()
                    if data.get("status") == "finished":
                        results = data.get("results", [])
                        if results:
                            item = results[0]
                            raw_out = item.get("result", {}).get("rawOutput", "").strip()
                            probe = item.get("probe", {})
                            loc = f"{probe.get('city', 'Unknown')}, {probe.get('country', 'World')}"
                            if raw_out:
                                full_log = f"From: {loc} (Globalping)\n{'-'*30}\n{raw_out}"
                                return f"Traceroute: {t}", [("Log", f"```\n{full_log}\n```")]
                            else: raise Exception("Empty output (Network unreachable?)")
                        else: raise Exception("Target unreachable or probe error")
            raise Exception("Timeout: Trace took too long")
        except Exception as e:
            err = str(e).replace("HTTPSConnectionPool", "NetErr")
            raise Exception(self.t("err_net") + f": {err}")

    def h_time(self, args):
        inp = " ".join(args)
        if not inp:
            now = datetime.now()
            ts = int(now.timestamp())
            return "Current Time", [
                ("Your Timezone", f"`{now.strftime('%d.%m.%Y %H:%M:%S')}`"),
                ("UTC", f"`{datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}`"),
                ("Timestamp", f"`{ts}`")
            ]

        try:
            ts = float(inp)
            dt_obj = datetime.fromtimestamp(ts)
            utc_dt = datetime.utcfromtimestamp(ts)
            return "Time Convert", [
                ("Timestamp", f"`{inp}`"),
                ("Your Timezone", f"`{dt_obj.strftime('%d.%m.%Y %H:%M:%S')}`"),
                ("UTC", f"`{utc_dt.strftime('%Y-%m-%d %H:%M:%S')}`")
            ]
        except ValueError:
            formats_to_try = [
                '%d.%m.%Y %H:%M',
                '%d.%m.%Y %H:%M:%S',
                '%d.%m.%Y',
                '%Y-%m-%d %H:%M:%S'
            ]
            
            for fmt in formats_to_try:
                try:
                    dt_obj = datetime.strptime(inp, fmt)
                    ts = dt_obj.timestamp()
                    return "Time Convert", [("Date", f"{inp}"), ("Timestamp", f"{int(ts)}")]
                except ValueError:
                    continue 

            raise Exception(self.t("err_inv") + ": Use timestamp or 'DD.MM.YYYY HH:MM'")

    def h_color(self, args):
        inp = "".join(args).lower()
        if inp.startswith("#"):
            hex_val = inp.lstrip('#')
            if len(hex_val) != 6: raise Exception(self.t("err_inv"))
            try:
                r, g, b = tuple(int(hex_val[i:i+2], 16) for i in (0, 2, 4))
                return f"Color HEX -> RGB", [("HEX", inp), ("RGB", f"{r}, {g}, {b}")]
            except ValueError:
                raise Exception(self.t("err_inv"))
        elif "," in inp:
            try:
                r, g, b = [int(c.strip()) for c in inp.split(',')]
                if not all(0 <= c <= 255 for c in [r, g, b]):
                    raise Exception(self.t("err_inv"))
                hex_val = f"#{r:02x}{g:02x}{b:02x}"
                return f"Color RGB -> HEX", [("RGB", inp), ("HEX", hex_val)]
            except (ValueError, TypeError):
                raise Exception(self.t("err_inv"))
        else:
            raise Exception(self.t("err_inv") + ": Use #RRGGBB or R,G,B")
            
    def h_speedtest(self, args):
        run_on_ui_thread(lambda: self.progress_dialog.set_message(self.t("testing_speed")))
        test_url = "https://speed.cloudflare.com/__down?bytes=10485760"
        file_size_bytes = 10 * 1024 * 1024
        try:
            start_time = time.time()
            r = requests.get(test_url, timeout=30, stream=True)
            r.raise_for_status()
            for _ in r.iter_content(chunk_size=8192): pass
            end_time = time.time()
            duration = end_time - start_time
            if duration < 0.01: duration = 0.01
            speed_mbps = (file_size_bytes * 8) / (1024 * 1024) / duration
            return "Speed Test", [(self.t("download_speed"), f"{speed_mbps:.2f} Mbps")]
        except requests.exceptions.RequestException as e:
            raise Exception(f"{self.t('err_net')}: {str(e)}")

    def h_threat(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"http://ip-api.com/json/{t}?fields=status,message,proxy,hosting,mobile", timeout=10).json()
            if r.get("status") != "success": raise Exception(r.get("message", self.t("err_api")))
            is_proxy = r.get("proxy", False)
            is_hosting = r.get("hosting", False)
            is_mobile = r.get("mobile", False)
            score = self.t("safe")
            info = []
            if is_proxy:
                score = self.t("risky")
                info.append(self.t("proxy_detected"))
            if is_hosting:
                score = self.t("risky")
                info.append(self.t("hosting_detected"))
            if is_mobile: info.append(self.t("cellular_network"))
            if not info: info.append(self.t("safe"))
            return f"Threat Intel: {t}", [(self.t("threat_score"), score), (self.t("threat_info"), "\n- " + "\n- ".join(info))]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_dnshistory(self, args):
        t = self._get_target(args)
        try:
            h = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Referer": "https://viewdns.info/",
                "Accept-Language": "en-US,en;q=0.9"
            }
            r = requests.get(f"https://viewdns.info/iphistory/?domain={t}", headers=h, timeout=20)
            
            if r.status_code == 403:
                 return f"DNS History: {t}", [("Result", f"Blocked by anti-bot.\n[Open Link in Browser](https://viewdns.info/iphistory/?domain={t})")]
            
            r.raise_for_status()
            history = re.findall(r'<tr><td>(\d{4}-\d{2}-\d{2})</td><td>([\d\.]+)</td><td>(.*?)</td></tr>', r.text)
            if not history: raise Exception(self.t("history_not_found"))
            lines = ["Date | IP Address | Owner", "---|---|---"]
            for date, ip, owner in history[:20]:
                lines.append(f"{date} | {ip} | {owner.strip()}")
            return f"DNS History: {t}", [("History", "\n```\n" + "\n".join(lines) + "\n```")]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_htmlencode(self, args):
        text = " ".join(args)
        return "HTML Encode", [(self.t("lbl_res"), f"```{html.escape(text)}```")]

    def h_htmldecode(self, args):
        text = " ".join(args)
        return "HTML Decode", [(self.t("lbl_res"), f"```{html.unescape(text)}```")]

    def h_cat(self, args):
        t = self._url(args)
        try:
            r = requests.head(t, timeout=10, allow_redirects=True, headers={"User-Agent": "Mozilla/5.0"})
            status = r.status_code
            url_no_proto = re.sub(r'^https?:\/\/', '', t)
            cat_url = f"http.cat/{status}"
            message = f"{url_no_proto} [\u200b](https://{cat_url})"
            return "DIRECT_SEND", {"message": message, "noWebpage": False}
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))

    def h_tld(self, args):
        tld = args[0].replace(".", "").lower() if args else ""
        if not tld: raise Exception("Usage: .tld <com/net/ru>")
        try:
            r = requests.get(f"https://www.iana.org/domains/root/db/{tld}.html", timeout=10)
            if r.status_code == 404: raise Exception("TLD not found")
            org_match = re.search(r"<b>Sponsoring Organisation</b><br>(.*?)<br>", r.text, re.DOTALL)
            org = org_match.group(1).strip() if org_match else "Unknown"
            whois_match = re.search(r"<b>WHOIS Server:</b> (.*?)<", r.text)
            whois_srv = whois_match.group(1).strip() if whois_match else "N/A"
            return f"TLD Info: .{tld}", [("Manager", org), ("Whois Server", whois_srv), ("IANA URL", f"https://www.iana.org/domains/root/db/{tld}.html")]
        except Exception as e: raise Exception(self.t("err_net") + f": {e}")

    def h_tor(self, args):
        ip = self._res(self._get_target(args))
        try:
            r = requests.get("https://raw.githubusercontent.com/SecOps-Institute/Tor-IP-Addresses/master/tor-exit-nodes.lst", timeout=10)
            if r.status_code != 200: raise Exception("List Unavailable")
            is_tor = ip in r.text
            status = "🦊 YES, this is a TOR Exit Node!" if is_tor else "✅ No, clean IP."
            return f"Tor Check: {ip}", [("Status", status)]
        except: raise Exception(self.t("err_net"))

    def h_extract(self, args):
        t = self._url(args)
        try:
            r = requests.get(t, timeout=10, headers={"User-Agent": "Mozilla/5.0"})
            links = re.findall(r'href=[\'"]?(https?://[^\'" >]+)', r.text)
            domain = urllib.parse.urlparse(t).netloc
            external = sorted(list(set([l for l in links if domain not in l])))[:20]
            count = len(links)
            ext_count = len(external)
            out_text = "\n".join(external) if external else "No external links found."
            return f"Link Extractor: {domain}", [("Total Links", str(count)), ("External Links", str(ext_count)), ("List (First 20)", f"```\n{out_text}\n```")]
        except: raise Exception(self.t("err_net"))

    def h_cve(self, args):
        if not args: raise Exception("Usage: .cve <software name>")
        query = args[0]
        try:
            r = requests.get(f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={query}&resultsPerPage=20", timeout=25)
            if r.status_code != 200: raise Exception(f"Service error: {r.status_code}")
            
            data = r.json()
            items = data.get("vulnerabilities", [])
            
            if not items: return "CVE Search", [("Result", "No vulnerabilities found.")]
            
            items.sort(key=lambda x: x.get("cve", {}).get("published", ""), reverse=True)
            
            lines = []
            for item in items[:5]:
                cve_item = item.get("cve", {})
                cve_id = cve_item.get("id")
                date = cve_item.get("published", "")[:10] 
                
                desc = "No description"
                for d in cve_item.get("descriptions", []):
                    if d.get("lang") == "en":
                        desc = d.get("value")
                        break
                
                summary = desc[:100] + "..." if len(desc) > 100 else desc
                lines.append(f"🔻 {cve_id} ({date})\n{summary}\n")
            
            return f"CVE (NIST): {query}", [("Latest Vulns", "\n".join(lines))]
        except Exception as e: raise Exception(self.t("err_net") + f" ({e})")

    def h_emailsec(self, args):
        domain = self._get_target(args)
        dns_url = "https://dns.google/resolve"
        try:
            res_lines = []
            r_spf = requests.get(f"{dns_url}?name={domain}&type=TXT", timeout=10).json()
            spf_rec = "❌ Missing"
            if "Answer" in r_spf:
                for a in r_spf["Answer"]:
                    if "v=spf1" in a["data"]:
                        spf_rec = "✅ " + a["data"].strip('"')
                        break
            res_lines.append(f"**SPF:**\n{spf_rec}")
            r_dmarc = requests.get(f"{dns_url}?name=_dmarc.{domain}&type=TXT", timeout=10).json()
            dmarc_rec = "❌ Missing"
            if "Answer" in r_dmarc:
                for a in r_dmarc["Answer"]:
                    if "v=DMARC1" in a["data"]:
                        dmarc_rec = "✅ " + a["data"].strip('"')
                        break
            res_lines.append(f"**DMARC:**\n{dmarc_rec}")
            return f"Email Security: {domain}", [("Records", "\n\n".join(res_lines))]
        except: raise Exception(self.t("err_net"))
    
    def h_gh(self, args):
        user = args[0]
        try:
            r = requests.get(f"https://api.github.com/users/{user}", timeout=10).json()
            if "message" in r: raise Exception("User not found")
            return f"GitHub: {user}", [("Name", r.get("name")), ("Bio", r.get("bio")), ("Repos", str(r.get("public_repos"))), ("Followers", str(r.get("followers"))), ("Created", r.get("created_at"))]
        except Exception as e: raise Exception(str(e))

    def h_waf(self, args):
        t = self._url(args)
        try:
            r = requests.head(t, timeout=10)
            serv = r.headers.get("Server", "").lower()
            waf = "No WAF detected (Passive)"
            wafs = {"cloudflare": "Cloudflare", "nginx": "Nginx (Generic)", "apache": "Apache (Generic)", "succuri": "Sucuri", "imperva": "Imperva", "incapsula": "Incapsula", "akamaighost": "Akamai"}
            for k, v in wafs.items():
                if k in serv:
                    waf = v
                    break
            try:
                r_bad = requests.get(t, params={"x": "<script>alert(1)</script>"}, timeout=10)
                if r_bad.status_code in [403, 406, 501]: waf += f"\n(Blocked suspicious request: {r_bad.status_code})"
            except: pass
            return f"WAF: {urllib.parse.urlparse(t).netloc}", [("Result", waf)]
        except Exception as e: raise Exception(self.t("err_net"))

    def h_shodan(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"https://internetdb.shodan.io/{t}", timeout=10)
            if r.status_code == 404: raise Exception(self.t("err_notfound"))
            r.raise_for_status()
            data = r.json()
            return f"Shodan (InternetDB): {t}", [
                (self.t("lbl_port"), ", ".join(map(str, data.get("ports", [])))),
                (self.t("lbl_tags"), ", ".join(data.get("tags", []))),
                (self.t("lbl_vuln"), ", ".join(data.get("vulns", [])))
            ]
        except requests.exceptions.RequestException:
             raise Exception(self.t("err_net"))

    def h_jwt(self, args):
        if not args: raise Exception("Usage: .jwt <token>")
        token = args[0]
        try:
            parts = token.split(".")
            if len(parts) != 3: raise Exception(self.t("err_inv"))
            
            payload = parts[1]
            padded = payload + '=' * (-len(payload) % 4)
            decoded = base64.urlsafe_b64decode(padded).decode()
            pretty = json.dumps(json.loads(decoded), indent=2)
            
            return "JWT Payload", [("Decoded", f"```\n{pretty}\n```")]
        except Exception as e: raise Exception(f"{self.t('err_inv')}: {e}")

    def h_sitemap(self, args):
        url = self._url(args)
        domain = urllib.parse.urlparse(url).netloc
        try:
            targets = [f"{url.rstrip('/')}/sitemap.xml", f"https://{domain}/sitemap.xml", f"http://{domain}/sitemap.xml"]
            found_url = ""
            content = ""
            
            try:
                r_rob = requests.get(f"http://{domain}/robots.txt", timeout=10)
                if r_rob.status_code == 200:
                    sm_match = re.search(r'Sitemap: (https?://\S+)', r_rob.text, re.IGNORECASE)
                    if sm_match:
                        targets.insert(0, sm_match.group(1))
            except: pass

            for t in targets:
                try:
                    r = requests.get(t, timeout=10, headers={"User-Agent": "Mozilla/5.0"})
                    if r.status_code == 200 and ("<urlset" in r.text or "<sitemapindex" in r.text):
                        found_url = t
                        content = r.text
                        break
                except: continue
            
            if not found_url: raise Exception(self.t("err_notfound"))
            
            locs = re.findall(r'<loc>(.*?)</loc>', content)
            count = len(locs)
            sample = "\n".join(locs[:10])
            
            return f"Sitemap: {domain}", [("URL", found_url), (self.t("lbl_count"), str(count)), ("Sample", f"```\n{sample}\n```")]
        except Exception: raise Exception(self.t("err_notfound"))

    def h_tech(self, args):
        url = self._url(args)
        try:
            r = requests.get(url, timeout=10, headers={"User-Agent": "Mozilla/5.0"})
            tech = []
            
            if "Server" in r.headers: tech.append(f"Server: {r.headers['Server']}")
            if "X-Powered-By" in r.headers: tech.append(f"Powered-By: {r.headers['X-Powered-By']}")
            
            meta_gen = re.search(r'<meta\s+name=["\']generator["\']\s+content=["\']([^"\']+)["\']', r.text, re.IGNORECASE)
            if meta_gen: tech.append(f"Generator: {meta_gen.group(1)}")
            
            cookies = r.cookies.get_dict().keys()
            cookie_sigs = {
                "PHPSESSID": "PHP", "JSESSIONID": "Java", "ASP.NET_SessionId": "ASP.NET", 
                "laravel_session": "Laravel", "csrftoken": "Django", "rack.session": "Ruby/Rack"
            }
            for c in cookies:
                if c in cookie_sigs: tech.append(f"Framework: {cookie_sigs[c]}")
            
            if not tech: tech.append("No specific tech detected.")
            
            return f"Tech Stack: {urllib.parse.urlparse(url).netloc}", [(self.t("lbl_tech"), "\n".join(set(tech))), (self.t("lbl_cookies"), ", ".join(cookies) if cookies else "None")]
        except: raise Exception(self.t("err_net"))

    def h_reputation(self, args):
        t = self._res(self._get_target(args))
        try:
            r = requests.get(f"http://ip-api.com/json/{t}?fields=status,proxy,hosting,mobile,isp,org", timeout=10).json()
            is_proxy = r.get("proxy", False)
            is_hosting = r.get("hosting", False)
            
            r_ip = ".".join(reversed(t.split(".")))
            bl_zones = {"zen.spamhaus.org": "Spamhaus", "bl.spamcop.net": "Spamcop"}
            listed_in = []
            for zone, name in bl_zones.items():
                try:
                    socket.gethostbyname(f"{r_ip}.{zone}")
                    listed_in.append(name)
                except: pass
            
            score = self.t("safe")
            reasons = []
            
            if listed_in:
                score = "CRITICAL"
                reasons.append(f"Blacklisted: {', '.join(listed_in)}")
            if is_proxy:
                score = self.t("risky") if score != "CRITICAL" else score
                reasons.append(self.t("proxy_detected"))
            if is_hosting:
                reasons.append(self.t("hosting_detected"))
            
            if not reasons: reasons.append("Clean")
            
            return f"Reputation: {t}", [
                (self.t("threat_score"), score),
                (self.t("lbl_isp"), r.get("isp", "N/A")),
                ("Details", "\n- " + "\n- ".join(reasons))
            ]
        except: raise Exception(self.t("err_net"))

    def h_flood_check(self, args):
        t = self._get_target(args)
        t_ip = self._res(t)
        try:
            times = []
            errs = 0
            for _ in range(15):
                st = time.time()
                try:
                    s = socket.create_connection((t_ip, 80), timeout=2)
                    s.close()
                    times.append((time.time() - st) * 1000)
                except:
                    errs += 1
                time.sleep(0.05) 
            
            if not times: raise Exception("Host down")
            
            avg = sum(times) / len(times)
            jitter = max(times) - min(times)
            loss_pct = (errs / 15) * 100
            
            status = "Stable"
            if loss_pct > 20: status = "Packet Loss Detected"
            if jitter > 100: status = "High Jitter (Rate Limiting?)"
            
            return f"Rate Limit Test: {t_ip}", [
                (self.t("lbl_avg"), f"{avg:.2f}ms"),
                (self.t("lbl_jitter"), f"{jitter:.2f}ms"),
                (self.t("lbl_loss"), f"{loss_pct:.0f}%"),
                ("Result", status)
            ]
        except Exception as e: raise Exception(f"{self.t('err')}: {e}")

    def h_pypi(self, args):
        pkg = args[0]
        try:
            r = requests.get(f"https://pypi.org/pypi/{pkg}/json", timeout=10)
            if r.status_code == 404: raise Exception(self.t("err_notfound"))
            d = r.json()
            info = d.get("info", {})
            lic = info.get("license", "N/A")
            if lic is None: lic = "N/A"
            return f"PyPI: {pkg}", [
                (self.t("lbl_version"), info.get("version")),
                (self.t("lbl_license"), str(lic)[:20]),
                ("Author", info.get("author")),
                ("URL", f"https://pypi.org/project/{pkg}/")
            ]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))
        except Exception as e: raise Exception(str(e))

    def h_npm(self, args):
        pkg = args[0]
        try:
            r = requests.get(f"https://registry.npmjs.org/{pkg}", timeout=10)
            if r.status_code == 404: raise Exception(self.t("err_notfound"))
            d = r.json()
            latest = d.get("dist-tags", {}).get("latest")
            lic = d.get("license", "N/A")
            if isinstance(lic, dict): lic = lic.get("type", "N/A")
            if lic is None: lic = "N/A"
            return f"NPM: {pkg}", [
                (self.t("lbl_version"), latest),
                (self.t("lbl_license"), str(lic)[:20]),
                ("URL", f"https://www.npmjs.com/package/{pkg}")
            ]
        except requests.exceptions.RequestException: raise Exception(self.t("err_net"))
        except Exception as e: raise Exception(str(e))

    def h_pingmap(self, args):
        cidr = args[0]
        try:
            net = ipaddress.ip_network(cidr, strict=False)
            if net.num_addresses > 256: raise Exception("Max /24 allowed")
        except: raise Exception(self.t("err_inv"))
        
        run_on_ui_thread(lambda: self.progress_dialog.set_message("Scanning..."))
        
        alive = []
        lock = threading.Lock()
        
        def check(ip):
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(0.3)
                if s.connect_ex((str(ip), 80)) == 0:
                    with lock: alive.append(str(ip))
                s.close()
            except: pass

        threads = []
        for ip in net:
            if str(ip).endswith(".0") or str(ip).endswith(".255"): continue
            t = threading.Thread(target=check, args=(ip,))
            threads.append(t)
            t.start()
            if len(threads) > 50:
                 for th in threads: th.join()
                 threads = []

        for t in threads: t.join()
        
        alive_sorted = sorted(alive, key=lambda ip: int(ipaddress.IPv4Address(ip)))
        
        return f"PingMap: {cidr}", [(self.t("lbl_alive"), str(len(alive_sorted))), (self.t("lbl_list"), "\n" + "\n".join(alive_sorted) if alive_sorted else "None")]

    def h_r(self, args, account=None, params=None, peer=None):
        if not params: raise Exception(self.t("err_inv"))
        
        reply_obj = getattr(params, "replyToMsg", None)
        
        if not reply_obj:
            reply_id = getattr(params, "reply_to_msg_id", 0)
            if not reply_id: raise Exception(self.t("err_reply"))
            peer_id = self._get_peer_id(peer)
            if peer_id:
                reply_obj = MessagesController.getInstance(account).getMessageObject(peer_id, reply_id)

        if not reply_obj: raise Exception(self.t("err_notfound"))

        try:
            text_obj = getattr(reply_obj, "messageOwner", reply_obj)
            content = getattr(text_obj, "message", "")

            ents = getattr(reply_obj, "entities", [])
            if not ents and hasattr(reply_obj, "messageOwner"):
                ents = getattr(reply_obj.messageOwner, "entities", [])
            
            if content:
                html_source = self._unparse_entities(content, ents)
                final_message = f'i use parse_mode="HTML" btw:\n\n```{html_source}```'
                return "DIRECT_SEND", {"message": final_message}
            else:
                final_message = 'i use parse_mode="HTML" btw:\n\n[Сообщение не содержит текста]'
                return "DIRECT_SEND", {"message": final_message}
            
        except Exception as e:
            log(traceback.format_exc())
            raise Exception(f"Failed to fetch: {e}")
            
    def _unparse_entities(self, text, entities):
        if not text: return ""
        
        py_ents = []
        if entities:
            try:
                py_ents = list(entities)
            except TypeError: # Not iterable
                if hasattr(entities, "size") and hasattr(entities, "get"):
                    for i in range(entities.size()):
                        py_ents.append(entities.get(i))

        if not py_ents: return html.escape(text)

        markers = []

        for e in py_ents:
            cls_name = e.__class__.__name__
            off = getattr(e, "offset", 0)
            length = getattr(e, "length", 0)
            end = off + length

            tag_start, tag_end = "", ""

            if "Bold" in cls_name: tag_start, tag_end = "<b>", "</b>"
            elif "Italic" in cls_name: tag_start, tag_end = "<i>", "</i>"
            elif "Code" in cls_name: tag_start, tag_end = "<code>", "</code>"
            elif "Pre" in cls_name:
                lang = getattr(e, "language", "")
                tag_start = f'<pre language="{lang}">' if lang else "<pre>"
                tag_end = "</pre>"
            elif "Strike" in cls_name: tag_start, tag_end = "<s>", "</s>"
            elif "Underline" in cls_name: tag_start, tag_end = "<u>", "</u>"
            elif "Spoiler" in cls_name: tag_start, tag_end = "<tg-spoiler>", "</tg-spoiler>"
            elif "TextUrl" in cls_name:
                url = getattr(e, "url", "")
                tag_start, tag_end = f'<a href="{html.escape(url)}">', "</a>"
            elif "Blockquote" in cls_name:
                is_collapsed = getattr(e, "collapsed", False)
                tag_start = '<blockquote expandable>' if is_collapsed else '<blockquote>'
                tag_end = "</blockquote>"
            elif "CustomEmoji" in cls_name:
                eid = getattr(e, "document_id", 0)
                tag_start = f'<tg-emoji emoji-id="{eid}">'
                tag_end = "</tg-emoji>"

            if tag_start:
                markers.append((off, 1, tag_start))
                markers.append((end, 0, tag_end))

        markers.sort(key=lambda x: (x, x))

        res = []
        cur = 0
        utf16_text = text.encode('utf-16-le')

        for pos, priority, tag in markers:
            utf16_pos = pos * 2
            if utf16_pos > cur:
                res.append(html.escape(utf16_text[cur:utf16_pos].decode('utf-16-le')))
            
            res.append(tag)
            cur = utf16_pos
        
        if cur < len(utf16_text):
            res.append(html.escape(utf16_text[cur:].decode('utf-16-le')))

        return "".join(res)

    def h_zhelp(self, args):
        cmds = [
            ".whois <ip>", ".dwhois <domain>", ".myip", ".mac <mac>", ".threat <ip>",
            ".dns <domain>", ".dig <domain>", ".ip <domain>", ".sub <domain>", ".rev <ip>",
            ".bgp <ip>", ".black <ip>", ".dnshistory <domain>", ".tld <zone>", ".emailsec <domain>",
            ".ipcalc <cidr>", ".scan <ip>", ".ping <ip>", ".ris <ip>", ".ports <ip>",
            ".tcp <ip:port>", ".udp <ip:port>", ".wport <port>", ".intip <ip/int>", ".cidr <cidr>",
            ".traceroute <ip>", ".speedtest", ".flood_check <ip>", ".pingmap <cidr>",
            ".curl <url>", ".redirects <url>", ".cert <domain>", ".header <url>",
            ".short <url>", ".unshort <url>", ".sec <url>", ".robot <url>", ".cat <url>",
            ".extract <url>", ".waf <url>", ".tech <url>", ".sitemap <url>",
            ".hash <text>", ".b64 <text>", ".url <text>", ".puny <text>", ".json <json>",
            ".jwt <token>", ".time <ts/date>", ".color <hex/rgb>", ".htmlencode <text>", ".htmldecode <text>",
            ".gh <user>", ".cve <soft>", ".pypi <pkg>", ".npm <pkg>", ".carbon <code>",
            ".shodan <ip>", ".reputation <ip>", ".tor <ip>", ".r"
        ]
        help_text = "\n" + "\n".join([f"`{c}`" for c in cmds])
        return self.t("cmd_zhelp"), [(self.t("lbl_list"), help_text)]
    
    def _send_direct(self, peer, message, **kwargs):
        def _do():
            self._prog(False)
            params = {"peer": peer, "message": message}
            params.update(kwargs)
            try:
                from markdown_utils import parse_markdown
                p = parse_markdown(message)
                params["message"] = p.text
                if p.entities:
                    params["entities"] = [e.to_tlrpc_object() for e in p.entities]
                send_message(params)
            except Exception as e:
                log(f"Markdown parsing failed: {e}. Sending as plain text.")
                params["message"] = re.sub(r'([*_`\[\]\u200b])', '', message)
                if "entities" in params:
                    del params["entities"]
                send_message(params)
        run_on_ui_thread(_do)
        
    def _reply(self, peer, title, lines):
        def _do():
            self._prog(False)
            sb = [f"**{title}**", ""]
            for k, v in lines:
                if v is not None:
                    val_str = str(v).strip()
                    if val_str.startswith("```"):
                        sb.append(f"**{k}:**\n{val_str}")
                    elif "\n" in val_str:
                        sb.append(f"**{k}:**\n{val_str}")
                    else:
                        clean_val = val_str.replace('`', "'")
                        sb.append(f"**{k}:** `{clean_val}`")

            full = "\n".join(sb)
            
            try:
                from markdown_utils import parse_markdown
                p = parse_markdown(full)
                
                quote = TLRPC.TL_messageEntityBlockquote()
                quote.collapsed = True
                quote.offset = 0
                quote.length = len(p.text.encode('utf-16-le')) // 2
                
                ents = [quote]
                if p.entities:
                    other_ents = [e.to_tlrpc_object() for e in p.entities]
                    ents.extend(other_ents)
                
                send_message({"peer": peer, "message": p.text, "entities": ents})
            except Exception as e:
                log(f"Markdown parsing failed: {e}. Sending as plain text.")
                plain_text = re.sub(r'([*_`])', '', full)
                send_message({"peer": peer, "message": plain_text})
        run_on_ui_thread(_do)