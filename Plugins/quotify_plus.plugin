from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook
from ui.settings import Header, Input, Divider, Switch, Selector, Text
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from java.io import File, FileOutputStream, ByteArrayOutputStream, FileInputStream
from java.util import Locale, ArrayList
from java.lang import Integer, Long
from client_utils import send_message, get_send_messages_helper, run_on_queue, get_last_fragment, send_request, get_user_config, RequestCallback, get_messages_controller
from hook_utils import find_class, get_private_field
from android.view.animation import DecelerateInterpolator, AccelerateDecelerateInterpolator
from android.content import Intent, Context, ClipData, ClipboardManager
from android.os import Handler, Looper, Environment
from android.graphics import Bitmap, BitmapFactory, Canvas, Paint, Typeface, Rect as AndroidRect, Color
from android.media import MediaMetadataRetriever
from android_utils import run_on_ui_thread, log
from android.provider import MediaStore
from android.app import Activity
from android.net import Uri
from android.widget import TextView, LinearLayout
from android.view import View
from android.graphics import Canvas, Paint, Typeface, Rect as AndroidRect
from android.text import TextPaint
from com.exteragram.messenger.plugins import PluginsController
from org.telegram.messenger import FileLoader, UserConfig, ImageLocation, MessageObject, ApplicationLoader, AndroidUtilities, ImageLoader, Emoji
from org.telegram.ui.Components import RLottieDrawable
from org.telegram.tgnet import TLRPC
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps, ImageEnhance
import threading
import traceback
import requests
import datetime
import random
import uuid
import math
import time
import json
import re
import os
import io

__id__ = "quotify_plus"
__name__ = "[FORK] Quotify+"
__author__ = "@mur_live & Raitorinkus (Original authors: @TailedPlugins & @KangelPlugins)"
__min_version__ = "12.1.1"
__icon__ = "Quotify_Plus/1"
__version__ = "1.2.0"
__description__ = """
Улучшенная версия Quotify, позволяющая делать стильные цитаты в виде картинок.

Команды использования:
.q [автор] - обычная цитата
.qa [автор] - с кастом аватаркой
.qb [автор] - с кастом фоном
.qm [автор] - смешанная (аватарка и фон)
.fq <текст> | [автор] - обычная фейк цитата
.fqa <текст> | [автор] - фейк с кастом аватаркой
.fqb <текст> | [автор] - фейк с кастом фоном
.fqm <текст> | [автор] - фейк смешанная (аватарка и фон)

Краткая справка:
<текст> (обязательно): Текст цитаты
[автор] (необязательно): Юзернейм, номер телефона, ID
"""

FILE_PICK_REQUEST_CODE = 2040
PICK_BG_REQUEST_CODE = 2041
PICK_AVA_REQUEST_CODE = 2042
IMPORT_SETTINGS_CODE = 2043
FALLBACK_AVATAR_USERNAME = "extreme_demon" 
DEFAULT_FAKE_NAME_SEPARATOR = "|"

def copy_error_to_clipboard(error_msg):
    try:
        if not plugin_instance.get_setting("copy_error_to_clipboard", True):
            return
        ctx = ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
        clip = ClipData.newPlainText("Quotify Error", str(error_msg))
        clipboard.setPrimaryClip(clip)
        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка скопирована в буфер!"))
    except Exception:
        pass
        
def qlog(message, error=None):
    if error:
        tb = traceback.format_exc()
        full_msg = f"{message}\n[ERROR]: {str(error)}\n[TRACEBACK]:\n{tb}"
    else:
        full_msg = message
    log(f"[Quotify_Plus] {full_msg}")
    DebugLogger.log(full_msg, is_error=bool(error))

class DebugLogger:
    logs = []
    enabled = False
    last_log_content = None

    @staticmethod
    def init(plugin_instance=None):
        if plugin_instance:
             DebugLogger.enabled = plugin_instance.get_setting("debug_logging", False)
        else:
            DebugLogger.enabled = False

    @staticmethod
    def log(message, is_error=False):
        if not DebugLogger.enabled:
            return
        try:
            timestamp = datetime.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
            prefix = "[ERROR] " if is_error else "[INFO] "
            log_entry = f"[{timestamp}] {prefix}{message}"
            DebugLogger.logs.append(log_entry)
            if len(DebugLogger.logs) > 500:
                DebugLogger.logs.pop(0)
        except:
            pass

    @staticmethod
    def save_logs(export_dir, is_error=False):
        try:
            if not DebugLogger.logs:
                return None
            
            if not os.path.exists(export_dir):
                os.makedirs(export_dir)
                
            prefix = "quotify_error_log_" if is_error else "quotify_log_"
            filename = f"{prefix}{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
            file_path = os.path.join(export_dir, filename)
            
            with open(file_path, "w", encoding="utf-8") as f:
                f.write("\n".join(DebugLogger.logs))
                
            return file_path
        except Exception as e:
            log(f"Failed to save logs: {e}")
            return None

    @staticmethod
    def clear_logs():
        DebugLogger.logs.clear()
        DebugLogger.last_log_content = None

class LocalizationManager:
    language = "en"
    strings = {
        "ru": {
            "FORGOT_TO_REPLY": "⚠️ Ты забыл реплайнуть сообщение!",
            "TLRPC_USERPHOTOS_ERROR": "⛔ Произошла ошибка при попытке получить аву пользователя!",
            "TLRPC_GETFILE_ERROR": "⛔ Произошла ошибка при скачивании авы пользователя!",
            "PLUGIN_ERROR": "⛔ Произошла ошибка в коде плагина",
            "USERPHOTOS_ERROR": "⛔ Произошла ошибка в коde получения изображения пользователя!",
            "GETFILE_ERROR": "⛔ Произошла ошибка в коде скачки изображения пользователя!",
            "ERROR_NO_ACTIVITY": "⛔ Не удалось получить текущий экран!",
            "ERROR_FILE_PICKER": "⛔ Ошибка при открытии выбора файла!",
            "ERROR_INVALID_FONT": "⛔ Файл не является шрифтом (.ttf/.otf)!",
            "ERROR_OPEN_FILE": "⛔ Не удалось открыть файл!",
            "ERROR_PROCESS_FILE": "⛔ Ошибка при обработке файла!",
            "FONT_UPLOADED": "✅ Шрифт '{}' успешно загружен!",
            "SELECT_FONT_FILE": "Выберите файл шрифта",
            "SETTINGS_TITLE": "Настройки плагина Quotify Fork",
            "FAKE_QUOTE_EMPTY": "⚠️ Укажи текст после команды",
            "SETTINGS_LAYOUT": "Стиль цитаты",
            "SETTINGS_LAYOUT_HORIZONTAL": "Горизонтальная",
            "SETTINGS_LAYOUT_VERTICAL": "Вертикальная",
            "SETTINGS_FONT": "Шрифт",
            "SETTINGS_QUOTE_FONT_SIZE": "Размер шрифта цитаты",
            "SETTINGS_AUTHOR_FONT_SIZE": "Размер шрифта автора",
            "SETTINGS_FONT_SIZE_SUB": "Введите размер шрифта (20-60)",
            "SETTINGS_TEXT_COLOR": "Цвет текста",
            "TEXT_COLOR_WHITE": "Белый",
            "TEXT_COLOR_BLACK": "Чёрный",
            "TEXT_COLOR_CUSTOM": "Пользовательский",
            "SETTINGS_CUSTOM_TEXT_COLOR": "Пользовательский цвет текста",
            "SETTINGS_CUSTOM_TEXT_COLOR_SUB": "Введите HEX-код цвета (например, #B4B4B4)",
            "SETTINGS_RANDOM_BG": "Случайный цвет фона",
            "SETTINGS_RANDOM_BG_SUB": "Использовать случайный цвет фона, если аватар недоступен",
            "SETTINGS_CUSTOM_BG_COLOR": "Пользовательский цвет фона",
            "SETTINGS_CUSTOM_BG_COLOR_SUB": "Введите HEX-код цвета (например, #000000)",
            "SETTINGS_SHOW_AVATAR": "Показывать аватар",
            "SETTINGS_SHOW_AVATAR_SUB": "Показывать аватар или заглушку в цитате",
            "SETTINGS_AVATAR_SIZE": "Размер аватара",
            "SETTINGS_AVATAR_SIZE_SUB": "Размер аватара в пикселях (50-400)",
            "SETTINGS_AVATAR_POSITION": "Положение аватара",
            "SETTINGS_AVATAR_POSITION_LEFT": "Слева",
            "SETTINGS_AVATAR_POSITION_RIGHT": "Справа",
            "SETTINGS_AVATAR_SHAPE": "Форма аватара",
            "SETTINGS_AVATAR_SHAPE_CIRCLE": "Круглая",
            "SETTINGS_AVATAR_SHAPE_SQUARE": "Квадратная",
            "SETTINGS_AVATAR_SHAPE_ROUNDED": "Скругленная",
            "SETTINGS_AVATAR_ROUNDING": "Скругление аватара",
            "SETTINGS_AVATAR_ROUNDING_SUB": "Радиус скругления (0-100)",
            "SETTINGS_BG_STYLE": "Стиль фона",
            "SETTINGS_BG_STYLE_BLUR": "Блюр",
            "SETTINGS_BG_STYLE_GLASS": "Мокрое стекло",
            "SETTINGS_BG_STYLE_OLD_TV": "Старый TV",
            "SETTINGS_BG_STYLE_PIXEL": "Пиксели",
            "SETTINGS_BG_STYLE_SOLID": "Сплошной цвет",
            "SETTINGS_BG_STYLE_GRADIENT": "Градиент",
            "SETTINGS_BG_STYLE_WAVES": "Волны",
            "SETTINGS_USE_BG_FILTERS": "Фильтры фона",
            "SETTINGS_USE_BG_FILTERS_SUB": "Применять фильтры к фону аватара",
            "SETTINGS_BG_FILTER": "Фильтр фона",
            "SETTINGS_BG_FILTER_NONE": "Без фильтра",
            "SETTINGS_BG_FILTER_GRAYSCALE": "Чёрно-белый",
            "SETTINGS_BG_FILTER_SEPIA": "Сепия",
            "SETTINGS_BG_FILTER_INVERT": "Инверсия",
            "SETTINGS_BG_FILTER_POSTERIZE": "Постеризация",
            "SETTINGS_BG_FILTER_COLORIZE": "Окрашивание",
            "SETTINGS_BG_FILTER_CONTRAST": "Контраст",
            "SETTINGS_BG_FILTER_EMBOSS": "Тиснение",
            "UPLOAD_FONT": "Загрузить файл шрифта (.ttf/.otf)",
            "CURRENT_FONT": "Текущий шрифт: {}",
            "NONE": "Нет",
            "SETTINGS_CUSTOM_FONT_FAQ": "Как использовать кастомные шрифты",
            "SETTINGS_CUSTOM_FONT_URL": "Ссылка на кастомный шрифт (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Вставьте прямую ссылку на .ttf файл.\nПример: https://example.com/font.ttf",
            "SETTINGS_FIXED_WIDTH": "Фиксированная ширина",
            "SETTINGS_GFONTS_QUERY": "Поиск Google Fonts",
            "SETTINGS_GFONTS_SEARCH": "Найти шрифт в Google Fonts",
            "GFONTS_NO_RESULTS": "Ничего не найдено",
            "GFONTS_ONLY_TTF": "Доступны только варианты .ttf/.otf",
            "GFONTS_ERROR": "Ошибка Google Fonts",
            "ATTACH_TYPE_1": "[фото]",
            "ATTACH_TYPE_2": "[голосовое]",
            "ATTACH_TYPE_3": "[видео]",
            "ATTACH_TYPE_4": "[гео]",
            "ATTACH_TYPE_5": "[кружок]",
            "ATTACH_TYPE_6": "[загрузка]",
            "ATTACH_TYPE_8": "[гиф]",
            "ATTACH_TYPE_9": "[файл]",
            "ATTACH_TYPE_10": "[дата]",
            "ATTACH_TYPE_11": "[фото]",
            "ATTACH_TYPE_12": "[контакт]",
            "ATTACH_TYPE_13": "[стикер]",
            "ATTACH_TYPE_14": "[музыка]",
            "ATTACH_TYPE_15": "[премиум стикер]",
            "ATTACH_TYPE_16": "[звонок]",
            "ATTACH_TYPE_17": "[опрос]",
            "ATTACH_TYPE_18": "[премиум]",
            "ATTACH_TYPE_20": "[превью]",
            "ATTACH_TYPE_21": "[предложение фото]",
            "ATTACH_TYPE_22": "[задний фон]",
            "ATTACH_TYPE_23": "[история]",
            "ATTACH_TYPE_24": "[упоминание в истории]",
            "ATTACH_TYPE_25": "[премиум]",
            "ATTACH_TYPE_26": "[раздача]",
            "ATTACH_TYPE_27": "[зашёл в канал]",
            "ATTACH_TYPE_28": "[результат раздачи]",
            "ATTACH_TYPE_29": "[платное вложение]",
            "ATTACH_TYPE_30": "[звёзды]",
            "IN_REPLY": "[в ответ {0}]",
            "TLRPC_GETCHANNELS_ERROR": "⛔ Произошла ошибка при получении данных чата!",
            "SETTINGS_BG_USE_CUSTOM": "Использовать кастомный фон",
            "SETTINGS_PICK_BG": "Выбрать фон из галереи",
            "SETTINGS_CLEAR_BG": "Сбросить кастомный фон",
            "PICK_BG_ERROR": "Не удалось выбрать изображение",
            "PICK_BG_SUCCESS": "Фон обновлён",
            "IMAGE_UPLOADED": "✅ Изображение '{}' успешно загружено!",
            "CLEAR_BG_SUCCESS": "Фон сброшен",
            "AVATAR_SETTINGS_TITLE": "Настройка аватарки",
            "SETTINGS_AVATAR_USE_CUSTOM": "Использовать кастомную аву",
            "SETTINGS_PICK_AVATAR": "Выбрать аватар из галереи",
            "SETTINGS_CLEAR_AVATAR": "Сбросить кастомную аватарку",
            "PICK_AVATAR_SUCCESS": "Аватар обновлён",
            "CLEAR_AVATAR_SUCCESS": "Аватар сброшен"
        },
        "en": {
            "FORGOT_TO_REPLY": "⚠️ You forgot to reply to message!",
            "TLRPC_USERPHOTOS_ERROR": "⛔ An error occurred while trying to fetch the user's avatar!",
            "TLRPC_GETFILE_ERROR": "⛔ An error occurred while downloading avatar!",
            "PLUGIN_ERROR": "⛔ An error occurred in plugin code!",
            "USERPHOTOS_ERROR": "⛔ An error occurred in user image retrieval code!",
            "GETFILE_ERROR": "⛔ An error occurred in user image download code!",
            "ERROR_NO_ACTIVITY": "⛔ Failed to get current activity!",
            "ERROR_FILE_PICKER": "⛔ Error opening file picker!",
            "ERROR_INVALID_FONT": "⛔ File is not a font (.ttf/.otf)!",
            "ERROR_OPEN_FILE": "⛔ Failed to open file!",
            "ERROR_PROCESS_FILE": "⛔ Error processing file!",
            "FONT_UPLOADED": "✅ Font '{}' uploaded successfully!",
            "SELECT_FONT_FILE": "Select font file",
            "SETTINGS_TITLE": "Quotify Fork Plugin Settings",
            "FAKE_QUOTE_EMPTY": "⚠️ Specify text after the command",
            "SETTINGS_LAYOUT": "Quote style",
            "SETTINGS_LAYOUT_HORIZONTAL": "Horizontal",
            "SETTINGS_LAYOUT_VERTICAL": "Vertical",
            "SETTINGS_FONT": "Font",
            "SETTINGS_QUOTE_FONT_SIZE": "Quote font size",
            "SETTINGS_AUTHOR_FONT_SIZE": "Author font size",
            "SETTINGS_FONT_SIZE_SUB": "Enter font size (20-60)",
            "SETTINGS_TEXT_COLOR": "Text color",
            "TEXT_COLOR_WHITE": "White",
            "TEXT_COLOR_BLACK": "Black",
            "TEXT_COLOR_CUSTOM": "Custom",
            "SETTINGS_CUSTOM_TEXT_COLOR": "Custom text color",
            "SETTINGS_CUSTOM_TEXT_COLOR_SUB": "Enter HEX color code (e.g., #B4B4B4)",
            "SETTINGS_RANDOM_BG": "Random background color",
            "SETTINGS_RANDOM_BG_SUB": "Use random background color if avatar is unavailable",
            "SETTINGS_CUSTOM_BG_COLOR": "Custom background color",
            "SETTINGS_CUSTOM_BG_COLOR_SUB": "Enter HEX color code (e.g., #000000)",
            "SETTINGS_SHOW_AVATAR": "Show avatar",
            "SETTINGS_SHOW_AVATAR_SUB": "Show avatar or placeholder in quote",
            "SETTINGS_AVATAR_SIZE": "Avatar size",
            "SETTINGS_AVATAR_SIZE_SUB": "Avatar size in pixels (50-400)",
            "SETTINGS_AVATAR_POSITION": "Avatar position",
            "SETTINGS_AVATAR_POSITION_LEFT": "Left",
            "SETTINGS_AVATAR_POSITION_RIGHT": "Right",
            "SETTINGS_AVATAR_SHAPE": "Avatar shape",
            "SETTINGS_AVATAR_SHAPE_CIRCLE": "Circle",
            "SETTINGS_AVATAR_SHAPE_SQUARE": "Square",
            "SETTINGS_AVATAR_SHAPE_ROUNDED": "Rounded",
            "SETTINGS_AVATAR_ROUNDING": "Avatar rounding",
            "SETTINGS_AVATAR_ROUNDING_SUB": "Rounding radius (0-100)",
            "SETTINGS_BG_STYLE": "Background style",
            "SETTINGS_BG_STYLE_BLUR": "Blur",
            "SETTINGS_BG_STYLE_GLASS": "Wet glass",
            "SETTINGS_BG_STYLE_OLD_TV": "Old TV",
            "SETTINGS_BG_STYLE_PIXEL": "Pixel",
            "SETTINGS_BG_STYLE_SOLID": "Solid color",
            "SETTINGS_BG_STYLE_GRADIENT": "Gradient",
            "SETTINGS_BG_STYLE_WAVES": "Waves",
            "SETTINGS_USE_BG_FILTERS": "Background filters",
            "SETTINGS_USE_BG_FILTERS_SUB": "Apply filters to avatar background",
            "SETTINGS_BG_FILTER": "Background filter",
            "SETTINGS_BG_FILTER_NONE": "No filter",
            "SETTINGS_BG_FILTER_GRAYSCALE": "Grayscale",
            "SETTINGS_BG_FILTER_SEPIA": "Sepia",
            "SETTINGS_BG_FILTER_INVERT": "Invert",
            "SETTINGS_BG_FILTER_POSTERIZE": "Posterize",
            "SETTINGS_BG_FILTER_COLORIZE": "Colorize",
            "SETTINGS_BG_FILTER_CONTRAST": "Contrast",
            "SETTINGS_BG_FILTER_EMBOSS": "Emboss",
            "UPLOAD_FONT": "Upload font file (.ttf/.otf)",
            "CURRENT_FONT": "Current font: {}",
            "NONE": "None",
            "SETTINGS_CUSTOM_FONT_FAQ": "How to use custom fonts",
            "SETTINGS_CUSTOM_FONT_URL": "Custom font URL (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Paste a direct link to a .ttf file.\nExample: https://example.com/font.ttf",
            "SETTINGS_FIXED_WIDTH": "Fixed width",
            "SETTINGS_GFONTS_QUERY": "Google Fonts search",
            "SETTINGS_GFONTS_SEARCH": "Search in Google Fonts",
            "GFONTS_NO_RESULTS": "Nothing found",
            "GFONTS_ONLY_TTF": "Only .ttf/.otf variants are available",
            "GFONTS_ERROR": "Google Fonts error",
            "ATTACH_TYPE_1": "[photo]",
            "ATTACH_TYPE_2": "[voice message]",
            "ATTACH_TYPE_3": "[video]",
            "ATTACH_TYPE_4": "[geo]",
            "ATTACH_TYPE_5": "[round message]",
            "ATTACH_TYPE_6": "[upload]",
            "ATTACH_TYPE_8": "[gif]",
            "ATTACH_TYPE_9": "[file]",
            "ATTACH_TYPE_10": "[date]",
            "ATTACH_TYPE_11": "[photo]",
            "ATTACH_TYPE_12": "[contact]",
            "ATTACH_TYPE_13": "[sticker]",
            "ATTACH_TYPE_14": "[music]",
            "ATTACH_TYPE_15": "[animated sticker]",
            "ATTACH_TYPE_16": "[call]",
            "ATTACH_TYPE_17": "[poll]",
            "ATTACH_TYPE_18": "[premium]",
            "ATTACH_TYPE_20": "[preview]",
            "ATTACH_TYPE_21": "[photo suggestion]",
            "ATTACH_TYPE_22": "[background]",
            "ATTACH_TYPE_23": "[story]",
            "ATTACH_TYPE_24": "[story mention]",
            "ATTACH_TYPE_25": "[premium]",
            "ATTACH_TYPE_26": "[giveaway]",
            "ATTACH_TYPE_27": "[joined channel]",
            "ATTACH_TYPE_28": "[giveaway result]",
            "ATTACH_TYPE_29": "[paid attachment]",
            "ATTACH_TYPE_30": "[stars]",
            "IN_REPLY": "[in reply to {0}]",
            "TLRPC_GETCHANNELS_ERROR": "⛔ An error occurred while fetching chat data!",
            "SETTINGS_BG_USE_CUSTOM": "Use custom background",
            "SETTINGS_PICK_BG": "Pick background from gallery",
            "SETTINGS_CLEAR_BG": "Clear custom background",
            "PICK_BG_ERROR": "Failed to pick image",
            "PICK_BG_SUCCESS": "Background updated",
            "IMAGE_UPLOADED": "✅ Image '{}' uploaded successfully!",
            "CLEAR_BG_SUCCESS": "Background cleared",
            "AVATAR_SETTINGS_TITLE": "Avatar settings",
            "SETTINGS_AVATAR_USE_CUSTOM": "Use custom avatar",
            "SETTINGS_PICK_AVATAR": "Pick avatar from gallery",
            "SETTINGS_CLEAR_AVATAR": "Clear custom avatar",
            "PICK_AVATAR_SUCCESS": "Avatar updated",
            "CLEAR_AVATAR_SUCCESS": "Avatar cleared"
        }
    }

    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager.strings else "en"

    @staticmethod
    def get_string(string, *args):
        try:
            locali = LocalizationManager.strings.get(LocalizationManager.language, LocalizationManager.strings["en"]).get(string, string)
            return locali.format(*args) if args else locali
        except Exception:
            return string

class FontManager:
    fonts = []
    custom_font_url = ""
    custom_font_path = None
    last_custom_url = None
    
    @staticmethod
    def init():
        FontManager.fonts = [
            Font("Hack", "https://github.com/source-foundry/Hack/raw/master/build/ttf/Hack-Bold.ttf"),
            Font("Zpix", "https://github.com/Ar4ikTrirtyFour/windose20/raw/main/fonts/zpix.ttf"),
            Font("Times New Roman", "https://github.com/misuchiru03/font-times-new-roman/raw/master/Times%20New%20Roman.ttf"),
            Font("Bounded Regular", "https://github.com/churkinvlad/Bounded/raw/refs/heads/main/OTF/Bounded-Regular.otf"),
            Font("Кастомный шрифт", None)
        ]
        threading.Thread(target=FontManager._download_fonts, daemon=True).start()
    
    @staticmethod
    def _download_fonts():
        for font in FontManager.fonts:
            if font.download_uri and not font.exists():
                try:
                    font.download()
                except Exception as e:
                    qlog(f"Ошибка загрузки шрифта {font.name}: {e}")
    
    @staticmethod
    def get(index, plugin=None):
        if index == 4:
            if plugin:
                custom_url = plugin.get_setting("custom_font_url", "").strip()
                custom_path = plugin.get_setting("custom_font_path", "").strip()
                if custom_url:
                    if FontManager.last_custom_url != custom_url:
                        temp_dir = Filesystem.get_temp_dir()
                        font_path = Filesystem.get_absolute_path(temp_dir, "custom_font.ttf")
                        try:
                            response = requests.get(custom_url, timeout=15)
                            with open(font_path, 'wb') as f:
                                f.write(response.content)
                            FontManager.last_custom_url = custom_url
                            FontManager.custom_font_path = font_path
                        except Exception as e:
                            qlog(f"Ошибка загрузки кастомного шрифта: {e}")
                            return FontManager.fonts[0]
                    return Font("Кастомный шрифт", None, custom_path=FontManager.custom_font_path)
                elif custom_path and os.path.exists(custom_path):
                    return Font("Кастомный шрифт", None, custom_path=custom_path)
            return FontManager.fonts[0]
        if index >= len(FontManager.fonts):
            return FontManager.fonts[0]
        return FontManager.fonts[index]
    
    @staticmethod
    def get_fonts_names():
        return [font.name for font in FontManager.fonts]

class Font:
    def __init__(self, name, download_uri, custom_path=None):
        self.name = name
        self.download_uri = download_uri
        self.custom_path = custom_path
    
    def get_path(self):
        if self.custom_path and os.path.exists(self.custom_path):
            return self.custom_path
        temp_dir = Filesystem.get_temp_dir()
        if not temp_dir:
            return "/system/fonts/DroidSans.ttf"
        fonts_dir = os.path.join(temp_dir, "fonts")
        if not os.path.exists(fonts_dir):
            os.makedirs(fonts_dir)
        file_name = self.name.replace(" ", "_") + ".ttf"
        return os.path.join(fonts_dir, file_name)
    
    def exists(self):
        return os.path.exists(self.get_path())
    
    def download(self):
        if self.exists() or not self.download_uri:
            return
        font_path = self.get_path()
        try:
            response = requests.get(self.download_uri, timeout=15)
            response.raise_for_status()
            with open(font_path, 'wb') as file:
                file.write(response.content)
            qlog(f"Шрифт {self.name} загружен: {font_path}")
        except Exception as e:
            qlog(f"Ошибка загрузки {self.name}: {e}")

class Filesystem:
    @staticmethod
    def write_file(file_path, content):
        file_dir = os.path.dirname(file_path)
        if not os.path.exists(file_dir):
            os.makedirs(file_dir)
        with open(file_path, 'wb') as file:
            file.write(content)
    
    @staticmethod
    def get_absolute_path(dir, file_name):
        return os.path.join(dir, file_name)
    
    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            if not fixed_dir:
                return None
            temp_dir = os.path.join(fixed_dir.getAbsolutePath(), "quotify_fork")
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            return temp_dir
        except Exception:
            return None

class EmojiRenderer:
    _cache = {}

    @staticmethod
    def render_emoji_to_pil(emoji_char, size_px=64):
        cache_key = f"{emoji_char}_{size_px}"
        if cache_key in EmojiRenderer._cache:
            return EmojiRenderer._cache[cache_key]

        try:
            result_holder = [None]
            event = threading.Event()

            def run_render():
                try:
                    drawable = Emoji.getEmojiDrawable(emoji_char)
                    success = False
                    
                    if drawable:
                        bitmap = Bitmap.createBitmap(size_px, size_px, Bitmap.Config.ARGB_8888)
                        canvas = Canvas(bitmap)
                        pad = int(size_px * 0.05)
                        drawable.setBounds(pad, pad, size_px - pad, size_px - pad)
                        drawable.draw(canvas)
                        
                        cx, cy = size_px // 2, size_px // 2
                        if bitmap.getPixel(cx, cy) != 0 or \
                           bitmap.getPixel(cx, cy - 5) != 0 or \
                           bitmap.getPixel(cx, cy + 5) != 0:
                            result_holder[0] = bitmap
                            success = True
                        else:
                            bitmap.recycle()

                    if not success:
                        ctx = ApplicationLoader.applicationContext
                        tv = TextView(ctx)
                        tv.setText(emoji_char)
                        tv.setTextSize(0, float(size_px * 0.9))
                        tv.setTextColor(0xFF000000)
                        tv.setGravity(17)
                        tv.setIncludeFontPadding(False)
                        
                        tv.measure(
                            View.MeasureSpec.makeMeasureSpec(size_px, View.MeasureSpec.EXACTLY),
                            View.MeasureSpec.makeMeasureSpec(size_px, View.MeasureSpec.EXACTLY)
                        )
                        tv.layout(0, 0, size_px, size_px)
                        
                        bitmap_sys = Bitmap.createBitmap(size_px, size_px, Bitmap.Config.ARGB_8888)
                        canvas_sys = Canvas(bitmap_sys)
                        tv.draw(canvas_sys)
                        
                        result_holder[0] = bitmap_sys

                except Exception as e:
                    log(f"Emoji render inner error: {e}")
                finally:
                    event.set()

            run_on_ui_thread(run_render)
            event.wait(3.0)

            bitmap = result_holder[0]
            if not bitmap:
                return None

            temp_path = Filesystem.get_absolute_path(
                Filesystem.get_temp_dir(),
                f"emoji_{abs(hash(emoji_char))%100000}_{size_px}.png"
            )

            fos = FileOutputStream(temp_path)
            try:
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos)
                fos.flush()
            finally:
                fos.close()
                bitmap.recycle()

            pil_img = Image.open(temp_path).convert("RGBA")
            
            try:
                os.remove(temp_path)
            except:
                pass

            EmojiRenderer._cache[cache_key] = pil_img
            return pil_img

        except Exception as e:
            qlog(f"Emoji render error for '{emoji_char}': {e}")
            return None

class TelegramUtils:
    @staticmethod
    def get_user(user_id):
        return get_messages_controller().getUser(user_id)
    
    @staticmethod 
    def get_channel(channel_id, callback):
        req = TLRPC.TL_channels_getChannels()
        input_channel = get_messages_controller().getInputChannel(channel_id)
        req.id.add(input_channel)
        cb = RequestCallback(callback)
        send_request(req, cb)
        
    @staticmethod
    def get_chat(chat_id, callback):
        req = TLRPC.TL_messages_getChats()
        input_chat = get_messages_controller().getInputChat(chat_id)
        req.id.add(input_chat)
        cb = RequestCallback(callback)
        send_request(req, cb)
        
    @staticmethod
    def create_input_location(photo, size):
        location = TLRPC.TL_inputPhotoFileLocation()
        location.id = photo.id
        location.access_hash = photo.access_hash
        location.file_reference = photo.file_reference
        location.thumb_size = size.type
        return location
        
    @staticmethod
    def create_peer_input_location(chat, peer):
        location = TLRPC.TL_inputPeerPhotoFileLocation()
        location.big = True
        location.peer = get_messages_controller().getInputPeer(peer)
        location.photo_id = chat.photo.photo_id
        return location
        
    @staticmethod
    def get_chat_thumbnail(chat, peer, callback):
        req = TLRPC.TL_upload_getFile()
        cb = RequestCallback(callback)
        location = TelegramUtils.create_peer_input_location(chat, peer)
        req.location = location
        req.offset = 0
        req.limit = 1024 * 1024
        send_request(req, cb)

class ReplyerID:
    def __init__(self, peer):
        if peer is None:
            self.channel_id = 0
            self.chat_id = 0
            self.user_id = -1
            self.peer = None
            return
        self.channel_id = peer.channel_id
        self.chat_id = peer.chat_id
        self.user_id = peer.user_id
        self.peer = peer
        
    def get_replyer_type(self):
        if self.channel_id != 0:
            return 2
        elif self.chat_id != 0:
            return 1
        else:
            return 0
        
    def get_id(self):
        if self.channel_id != 0:
            return self.channel_id
        elif self.chat_id != 0:
            return self.chat_id
        else:
            return self.user_id

class Replyer:
    def __init__(self):
        self.name = ""

class QuoteManager:
    def __init__(self, params, font_index, layout_index, fixed_width, plugin, custom_bg_path="", custom_avatar_path="", force_custom_bg=False, force_custom_avatar=False, override_author_name=None, search_query=None):
        self.params = params
        self.user = None
        self.replyer_id = None
        self.replyer = Replyer()
        self.font_index = font_index
        self.layout_index = layout_index
        self.fixed_width = fixed_width
        self.plugin = plugin
        self.override_quote_text = None
        self.custom_bg_path = custom_bg_path
        self.custom_avatar_path = custom_avatar_path
        self.force_custom_bg = force_custom_bg
        self.force_custom_avatar = force_custom_avatar
        self.override_author_name = override_author_name
        self.search_query = search_query
        self.cached_media_path = None
        self.media_fetch_attempted = False
        self.is_sticker_media = False
        self.is_finalized = False
        self.finalize_lock = threading.Lock()

    def _render_tgs_frame(self, sticker_path):
        drawable = None
        bitmap = None
        stream = None
        try:
            drawable = RLottieDrawable(File(sticker_path), 512, 512, None, False)
            width = drawable.getIntrinsicWidth() or 512
            height = drawable.getIntrinsicHeight() or 512
            bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            drawable.getFirstFrame(bitmap)
            out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"sticker_tgs_{uuid.uuid4()}.png")
            stream = FileOutputStream(out_path)
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            return out_path
        except Exception as e:
            qlog(f"TGS render error: {e}")
            return None
        finally:
            try:
                if stream: stream.close()
                if bitmap: bitmap.recycle()
                if drawable: drawable.recycle()
            except Exception: pass

    def _get_video_first_frame(self, video_path):
        retriever = None
        bitmap = None
        stream = None
        try:
            retriever = MediaMetadataRetriever()
            retriever.setDataSource(video_path)
            bitmap = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)
            if bitmap is None:
                bitmap = retriever.getFrameAtTime()
            if bitmap is None:
                return None
            out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"sticker_video_{uuid.uuid4()}.png")
            stream = FileOutputStream(out_path)
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            return out_path
        except Exception as e:
            qlog(f"Video frame error: {e}")
            return None
        finally:
            try:
                if stream: stream.close()
                if bitmap: bitmap.recycle()
                if retriever: retriever.release()
            except Exception: pass

    def _ensure_raster_image(self, path):
        try:
            ext = os.path.splitext(path)[1].lower()
            if ext in (".webp", ".heic", ".heif", ".avif"):
                bmp = BitmapFactory.decodeFile(path)
                if bmp is None:
                    return path
                out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"raster_{uuid.uuid4()}.png")
                fos = FileOutputStream(out_path)
                try:
                    bmp.compress(Bitmap.CompressFormat.PNG, 100, fos)
                    fos.flush()
                finally:
                    try:
                        fos.close()
                        bmp.recycle()
                    except Exception: pass
                return out_path
        except Exception as e:
            qlog(f"Raster conversion error: {e}")
        return path

    def generate_quote(self):

        extended_logs = self.plugin.get_setting("extended_logging", False)
        try:
            reply_obj = getattr(self.params, 'replyToMsg', None)
            if reply_obj is None:
                qlog("[ERROR] No reply message found", error="replyToMsg is None")
                BulletinHelper.show_error(LocalizationManager.get_string("FORGOT_TO_REPLY"))
                return

            if hasattr(reply_obj, 'messageOwner'):
                real_msg = reply_obj.messageOwner
            else:
                real_msg = reply_obj

            reply_id = real_msg.id if hasattr(real_msg, 'id') else 0
            
            qlog(f"[GEN] Starting quote generation. Reply ID: {reply_id}")

            if self.search_query:
                qlog(f"[SEARCH] Processing custom query: {self.search_query}")
                if self._resolve_user_from_query(self.search_query):
                    return
                self.override_author_name = self.search_query
                self.search_query = None

            self.replyer_id = self._init_replyer_id()
            if not self.replyer_id: 
                 self.replyer_id = ReplyerID(None)

            replyer_type = self.replyer_id.get_replyer_type()
            
            qlog(f"[SOURCE] ID: {self.replyer_id.get_id()}, Type: {replyer_type}")
            
            if replyer_type == 0:
                if self.replyer_id.user_id == -1:
                    return self._create_quote_without_input()
                user = TelegramUtils.get_user(self.replyer_id.user_id)
                self.user = user
                self.replyer.name = self._get_full_replyer_name()
                self._fetch_user_avatar(user)
            elif replyer_type == 1:
                TelegramUtils.get_chat(self.replyer_id.chat_id, self._handle_get_channels_callback)
            elif replyer_type == 2:
                TelegramUtils.get_channel(self.replyer_id.channel_id, self._handle_get_channels_callback)
        except Exception as e:
            qlog("CRITICAL ERROR in generate_quote", e)
            copy_error_to_clipboard(traceback.format_exc())

    def generate_fake_quote(self, text):
        self.override_quote_text = text
        if self.search_query:
            return self._resolve_user_from_query(self.search_query)

        if self.override_author_name is not None:
            self.replyer.name = self.override_author_name
            return self._create_quote_without_input()
        
        try:
            reply_obj = getattr(self.params, 'replyToMsg', None)
            if reply_obj is not None:
                self.replyer_id = self._init_replyer_id()
                replyer_type = self.replyer_id.get_replyer_type()
                if replyer_type == 0:
                    if self.replyer_id.user_id == -1:
                        return self._create_quote_without_input()
                    user = TelegramUtils.get_user(self.replyer_id.user_id)
                    self.user = user
                    self.replyer.name = self._get_full_replyer_name()
                    self._fetch_user_avatar(user)
                    return
                elif replyer_type == 1:
                    TelegramUtils.get_chat(self.replyer_id.chat_id, self._handle_get_channels_callback)
                    return
                elif replyer_type == 2:
                    TelegramUtils.get_channel(self.replyer_id.channel_id, self._handle_get_channels_callback)
                    return

            user_id = get_user_config().getClientUserId()
            me = get_messages_controller().getUser(user_id)
            if me:
                self.user = me
                self.replyer.name = self._get_full_replyer_name()
                self._fetch_user_avatar(me)
            else:
                self.replyer.name = ""
                self._create_quote_without_input()
        except Exception as e:
            copy_error_to_clipboard(traceback.format_exc())

    def _download_voice_message(self, document, message_owner):
        try:
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            
            file_path_obj = file_loader.getPathToMessage(message_owner)
            
            if not file_path_obj or not os.path.exists(file_path_obj.getAbsolutePath()):
                file_loader.loadFile(document, message_owner, 1, 0)
                
                import time
                for _ in range(30):
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()) and os.path.getsize(file_path_obj.getAbsolutePath()) > 0:
                        break
                    time.sleep(0.5)
            
            if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                return file_path_obj.getAbsolutePath()
            return None
        except Exception as e:
            qlog(f"Voice download error: {e}")
            return None

    def _transcribe_voice(self, file_path):
        try:
            extended_logs = self.plugin.get_setting("extended_logging", False)
            run_on_ui_thread(lambda: BulletinHelper.show_info("Начинаю расшифровку..."))
            
            provider = self.plugin.get_setting("transcription_provider", 2)
            if extended_logs:
                qlog(f"Starting transcription. Provider ID: {provider}, File: {file_path}")
            
            text = None

            if provider == 0:
                api_key = self.plugin.get_setting("trans_key_manual", "AIzaSyAN9rzLGEUyCAW2QLIa6GTHHPblV0bIAZI")
                model = self.plugin.get_setting("trans_model", "gemini-2.5-flash")
                
                import base64
                with open(file_path, "rb") as f:
                    audio_data = base64.b64encode(f.read()).decode('utf-8')
                
                url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
                headers = {"Content-Type": "application/json", "x-goog-api-key": api_key}
                payload = {
                    "contents": [{
                        "parts": [
                            {"text": "Transcribe this audio to text. Return only the transcribed text without any additional comments or formatting."},
                            {"inline_data": {"mime_type": "audio/ogg", "data": audio_data}}
                        ]
                    }]
                }
                
                response = requests.post(url, headers=headers, json=payload, timeout=60)
                if response.status_code == 200:
                    result = response.json()
                    try:
                        text = result["candidates"][0]["content"]["parts"][0]["text"]
                        if extended_logs: qlog("Gemini transcription success")
                    except (KeyError, IndexError):
                        qlog(f"Gemini parse error: {result}")
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка разбора ответа Gemini"))
                else:
                    qlog(f"Gemini Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Gemini API Error: {response.status_code}"))

            elif provider == 1:
                api_key = self.plugin.get_setting("trans_key_navy", "sk-navy-yF-biQV5TdZwx567-9MIkeLxcIMZKqJ5sFCvzgICOJk")
                model = self.plugin.get_setting("trans_model_navy", "gpt-4o-transcribe")
                
                url = "https://api.navy/v1/audio/transcriptions"
                headers = {"Authorization": f"Bearer {api_key}"}
                
                with open(file_path, "rb") as f:
                    files = {"file": ("voice.ogg", f, "audio/ogg")}
                    data = {"model": model, "response_format": "json"}
                    response = requests.post(url, headers=headers, files=files, data=data, timeout=60)
                
                if response.status_code == 200:
                    text = response.json().get("text", "")
                    if extended_logs: qlog("NavyAI transcription success")
                else:
                    qlog(f"NavyAI Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"NavyAI Error: {response.status_code}"))

            elif provider == 2:
                api_key = self.plugin.get_setting("trans_key_mistral", "6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF")
                model = self.plugin.get_setting("trans_model_mistral", "voxtral-mini-2507")
                
                if not api_key:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка: Не указан ключ Mistral"))
                    return None

                url = "https://api.mistral.ai/v1/audio/transcriptions"
                headers = {"Authorization": f"Bearer {api_key}"}
                
                with open(file_path, "rb") as f:
                    files = {"file": ("voice.ogg", f, "audio/ogg")}
                    data = {"model": model}
                    response = requests.post(url, headers=headers, files=files, data=data, timeout=60)
                
                if response.status_code == 200:
                    text = response.json().get("text", "")
                    if extended_logs: qlog("Mistral transcription success")
                else:
                    qlog(f"Mistral Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Mistral Error: {response.status_code}"))

            elif provider == 3:
                api_key = self.plugin.get_setting("trans_key_deepgram", "011fb75d769d83fe88822e0c6f4e45cee8810116")
                model = self.plugin.get_setting("trans_model_deepgram", "nova-3-general")
                
                url = f"https://api.deepgram.com/v1/listen?model={model}&punctuate=true&detect_language=true"
                headers = {
                    "Authorization": f"Token {api_key}",
                    "Content-Type": "audio/*",
                }

                with open(file_path, "rb") as audio_file:
                    response = requests.post(url, headers=headers, data=audio_file, timeout=60)

                if response.status_code == 200:
                    try:
                        text = response.json()["results"]["channels"][0]["alternatives"][0]["transcript"]
                        if extended_logs: qlog("Deepgram transcription success")
                    except (KeyError, IndexError):
                        qlog(f"Deepgram parse error: {response.text}")
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка разбора ответа Deepgram"))
                else:
                    qlog(f"Deepgram Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Deepgram Error: {response.status_code}"))

            if text:
                run_on_ui_thread(lambda: BulletinHelper.show_success("Расшифровка завершена!"))
                fmt = self.plugin.get_setting("trans_format", '[Расшифровка: "{text}"]')
                return fmt.replace("{text}", text.strip())
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось получить ответ от API"))
                return None

        except Exception as e:
            qlog(f"Transcription error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка расшифровки (см. логи)"))
            return None

    def _fetch_attached_media(self):
        extended_logs = self.plugin.get_setting("extended_logging", False)
        
        if not self.plugin.get_setting("quote_render_image", True):
            if extended_logs:
                qlog("[MEDIA] Media rendering disabled in settings")
            return None
            
        if self.media_fetch_attempted:
            if extended_logs:
                qlog(f"[MEDIA] Returning cached media path: {self.cached_media_path}")
            return self.cached_media_path
            
        self.media_fetch_attempted = True
        
        reply_msg = getattr(self.params, 'replyToMsg', None)
        if not reply_msg:
            if extended_logs: qlog("[MEDIA] No reply message for media fetch")
            return None

        try:
            message_owner = getattr(reply_msg, 'messageOwner', reply_msg)
            if not message_owner or not hasattr(message_owner, 'media'):
                if extended_logs: qlog("[MEDIA] Message owner has no media")
                return None
            
            media = message_owner.media
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                photo = media.photo
                file_path_obj = file_loader.getPathToMessage(message_owner)
                
                if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                    self.cached_media_path = file_path_obj.getAbsolutePath()
                    return self.cached_media_path

                largest = None
                max_dim = 0
                for size in photo.sizes:
                    if isinstance(size, TLRPC.TL_photoSize):
                        d = max(size.w, size.h)
                        if d > max_dim:
                            max_dim = d
                            largest = size
                
                if largest:
                    file_path_obj = file_loader.getPathToAttach(largest, True)
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                        self.cached_media_path = file_path_obj.getAbsolutePath()
                        return self.cached_media_path
                    
                    image_location = ImageLocation.getForPhoto(largest, photo)
                    if image_location:
                        file_loader.loadFile(image_location, "jpg", None, 1)
                        path = file_path_obj.getAbsolutePath()
                        for i in range(20): 
                            if os.path.exists(path) and os.path.getsize(path) > 0:
                                self.cached_media_path = path
                                return path
                            time.sleep(0.1)

            if hasattr(media, 'document') and media.document:
                document = media.document
                is_sticker = False
                mime = getattr(document, "mime_type", "") or ""
                
                if hasattr(document, 'attributes'):
                    for i in range(document.attributes.size()):
                        attr = document.attributes.get(i)
                        if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                            is_sticker = True
                            break
                
                if not is_sticker and mime == "application/x-tgsticker":
                    is_sticker = True
                
                if is_sticker:
                    self.is_sticker_media = True
                    file_path_obj = file_loader.getPathToAttach(document, True)
                    
                    if not file_path_obj or not os.path.exists(file_path_obj.getAbsolutePath()) or os.path.getsize(file_path_obj.getAbsolutePath()) == 0:
                        ext_hint = "tgs" if mime == "application/x-tgsticker" else ("webm" if mime == "video/webm" else "webp")
                        file_loader.loadFile(document, ext_hint, 0, 1)
                        
                        file_path_obj = file_loader.getPathToAttach(document, True)
                        for i in range(40):
                            if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()) and os.path.getsize(file_path_obj.getAbsolutePath()) > 0:
                                break
                            time.sleep(0.1)
                            
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                        abs_path = file_path_obj.getAbsolutePath()
                        
                        if mime == "application/x-tgsticker":
                            converted = self._render_tgs_frame(abs_path)
                            if converted:
                                self.cached_media_path = converted
                                return converted
                        elif mime == "video/webm":
                            converted = self._get_video_first_frame(abs_path)
                            if converted:
                                self.cached_media_path = converted
                                return converted
                        else:
                            converted = self._ensure_raster_image(abs_path)
                            self.cached_media_path = converted
                            return converted

            return None
        except Exception as e:
            qlog(f"[ERROR] Media fetch error: {e}")
            return None

    def _resolve_user_from_query(self, query):
        query = query.strip().rstrip(',')
        try:
            telegram_domains = ["t.me", "telegram.me", "telegram.dog"]
            for domain in telegram_domains:
                patterns = [f"https://{domain}/", f"{domain}/"]
                for pattern in patterns:
                    if query.lower().startswith(pattern):
                        username_part = query[len(pattern):].split('/')[0].split('?')[0].strip()
                        if username_part:
                            qlog(f"Resolving username from {pattern}: @{username_part}")
                            self._resolve_by_username(username_part)
                            return True
            
            if query.lower().startswith("tg://user?id="):
                user_id = int(re.search(r'\d+', query).group())
                self._resolve_by_id(user_id)
                return True
            
            if query.lower().startswith("id "):
                user_id = int(query[3:].strip())
                self._resolve_by_id(user_id)
                return True
            
            if query.startswith("+") and query[1:].isdigit():
                self._resolve_by_phone(query)
                return True
                
            if query.startswith("@"):
                self._resolve_by_username(query[1:])
                return True
                
            if query.isdigit():
                user_id = int(query)
                self._resolve_by_id(user_id)
                return True
            
            return False
            
        except (ValueError, TypeError, AttributeError) as e:
            qlog(f"Error parsing query '{query}': {e}. Treating as name override.")
            return False

    def _resolve_by_id(self, user_id):
        user = TelegramUtils.get_user(user_id)
        if user:
            self.user = user
            self.replyer.name = self._get_full_replyer_name()
            self._fetch_user_avatar(user)
        else:
            qlog(f"User with ID {user_id} not found.")
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _resolve_by_username(self, username):
        qlog(f"Resolving username: @{username}")
        req = TLRPC.TL_contacts_resolveUsername()
        req.username = username
        send_request(req, RequestCallback(self._handle_resolve_callback))

    def _resolve_by_phone(self, phone):
        qlog(f"Resolving phone: {phone}")
        try:
            req = TLRPC.TL_contacts_resolvePhone()
            req.phone = phone
            send_request(req, RequestCallback(self._handle_resolve_callback))
        except Exception as e:
            qlog(f"Failed to create TL_contacts_resolvePhone request: {e}")
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _handle_resolve_callback(self, response, error):
        if error or not response:
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)
            return
        
        self.search_query = None 
    
        if hasattr(response, 'users') and not response.users.isEmpty():
            user = response.users.get(0)
            self.user = user
            self.replyer.name = self._get_full_replyer_name()
            self._fetch_user_avatar(user)
        elif hasattr(response, 'chats') and not response.chats.isEmpty():
            chat = response.chats.get(0)
            self.replyer.name = chat.title
            self.user = None 
            self._fetch_chat_avatar(chat, response.peer)
        else:
            self.replyer.name = self.search_query if self.search_query else "Unknown"
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _fetch_user_avatar(self, user):
        extended_logs = self.plugin.get_setting("extended_logging", False)
        
        if self.force_custom_avatar and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
            return self._create_quote_without_input()
        
        has_real_photo = user and user.photo and isinstance(user.photo, TLRPC.TL_userProfilePhoto) and user.photo.photo_id != 0
        if not has_real_photo:
            use_custom_avatar = self.plugin.get_setting("avatar_use_custom", False)
            if use_custom_avatar and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
                return self._create_quote_without_input()
            if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                self._create_quote_without_input(skip_service_fallback=True)
            return
        target_cache_file = None
        best_size = None
        try:
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            if hasattr(user.photo, 'sizes'):
                sorted_sizes = []
                for size in user.photo.sizes:
                    if isinstance(size, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive)):
                        sorted_sizes.append(size)
                sorted_sizes.sort(key=lambda s: s.w * s.h, reverse=True)
                if sorted_sizes:
                    best_size = sorted_sizes[0]
            if not best_size:
                tl_big = getattr(user.photo, 'photo_big', None)
            else:
                tl_big = best_size
            if tl_big:
                target_cache_file = file_loader.getPathToAttach(tl_big, True)
                if target_cache_file and target_cache_file.exists() and target_cache_file.length() > 0:
                    def run_cached():
                        try:
                            self._create_and_send_image(
                                image_path=target_cache_file.getAbsolutePath(),
                                output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg"),
                                author=self._get_author(),
                                quote=self._get_quote_message(),
                                layout_vertical=(self.layout_index == 1)
                            )
                        except Exception:
                            pass
                    threading.Thread(target=run_cached).start()
                    return
                image_location = ImageLocation.getForUser(user, 1)
                if image_location:
                    file_loader.loadFile(image_location, None, None, 1, 1)
                    if target_cache_file:
                        def run_waiter():
                            found = False
                            for _ in range(25):
                                if target_cache_file.exists() and target_cache_file.length() > 0:
                                    found = True
                                    self._create_and_send_image(
                                        image_path=target_cache_file.getAbsolutePath(),
                                        output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg"),
                                        author=self._get_author(),
                                        quote=self._get_quote_message(),
                                        layout_vertical=(self.layout_index == 1)
                                    )
                                    break
                                time.sleep(0.1)
                            if not found:
                                self._fetch_avatar_via_upload_getfile(user, target_cache_file)
                        threading.Thread(target=run_waiter).start()
                        return
        except Exception:
            pass
        self._fetch_avatar_via_upload_getfile(user, target_cache_file)

    def _fetch_avatar_via_upload_getfile(self, user, target_cache_file):
        try:
            req = TLRPC.TL_upload_getFile()
            location = TLRPC.TL_inputPeerPhotoFileLocation()
            location.big = True
            location.peer = get_messages_controller().getInputPeer(user.id)
            location.photo_id = user.photo.photo_id
            req.location = location
            req.offset = 0
            req.limit = 1024 * 1024
            send_request(req, RequestCallback(lambda r, e: self._handle_get_file_callback(r, e, target_cache_file)))
        except Exception:
            self._fetch_avatar_via_getphotos(user)

    def _fetch_chat_avatar(self, chat, peer=None):
        if self.force_custom_avatar and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
            return self._create_quote_without_input()
        
        has_chat_photo = chat.photo and chat.photo.photo_id != 0
        if not has_chat_photo:
            use_custom = self.plugin.get_setting("avatar_use_custom", False)
            if use_custom and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
                return self._create_quote_without_input()
            if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                self._create_quote_without_input(skip_service_fallback=True)
            return

        def run_fetch():
            target_cache_file = None
            try:
                current_account = UserConfig.selectedAccount
                file_loader = FileLoader.getInstance(current_account)
                tl_big = getattr(chat.photo, 'photo_big', None)
                if tl_big:
                    target_cache_file = file_loader.getPathToAttach(tl_big, True)
                    if target_cache_file and target_cache_file.exists() and target_cache_file.length() > 0:
                        self._create_and_send_image(
                            image_path=target_cache_file.getAbsolutePath(),
                            output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg"),
                            author=self._get_author(),
                            quote=self._get_quote_message(),
                            layout_vertical=(self.layout_index == 1)
                        )
                        return

                image_location = ImageLocation.getForChat(chat, True)
                if image_location:
                    file_loader.loadFile(image_location, None, None, 1, 1)
                    if target_cache_file:
                        for _ in range(25):
                            if target_cache_file.exists() and target_cache_file.length() > 0:
                                self._create_and_send_image(
                                    image_path=target_cache_file.getAbsolutePath(),
                                    output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg"),
                                    author=self._get_author(),
                                    quote=self._get_quote_message(),
                                    layout_vertical=(self.layout_index == 1)
                                )
                                return
                            time.sleep(0.1)
            except Exception:
                pass

            try:
                input_peer = None
                if isinstance(chat, TLRPC.TL_channel) or isinstance(chat, TLRPC.TL_channelForbidden):
                    input_peer = TLRPC.TL_inputPeerChannel()
                    input_peer.channel_id = chat.id
                    input_peer.access_hash = chat.access_hash
                elif isinstance(chat, TLRPC.TL_chat) or isinstance(chat, TLRPC.TL_chatForbidden):
                    input_peer = TLRPC.TL_inputPeerChat()
                    input_peer.chat_id = chat.id
                else:
                    input_peer = get_messages_controller().getInputPeer(chat.id)

                req = TLRPC.TL_upload_getFile()
                location = TLRPC.TL_inputPeerPhotoFileLocation()
                location.big = True
                location.peer = input_peer
                location.photo_id = chat.photo.photo_id
                req.location = location
                req.offset = 0
                req.limit = 1024 * 1024 * 4
                
                def on_file_result(response, error):
                    if error or not response:
                        has_username = getattr(chat, 'username', None)
                        if not has_username and hasattr(chat, 'usernames') and chat.usernames:
                             has_username = True
                        
                        if has_username:
                            self._fetch_avatar_via_web(chat)
                        else:
                            self._create_quote_without_input(skip_service_fallback=True)
                    else:
                        self._handle_get_file_callback(response, None, target_cache_file)
                send_request(req, RequestCallback(on_file_result))

            except Exception:
                has_username = getattr(chat, 'username', None)
                if not has_username and hasattr(chat, 'usernames') and chat.usernames:
                     has_username = True

                if has_username:
                    self._fetch_avatar_via_web(chat)
                else:
                    self._create_quote_without_input()

        threading.Thread(target=run_fetch).start()

    def _handle_direct_avatar_response(self, response, error, user, cached_path):
        if not error and response:
            self._handle_get_file_callback(response, None, cached_path=cached_path)
        else:
            self._fetch_avatar_via_getphotos(user)

    def _fetch_avatar_via_getphotos(self, user):
        try:
            qlog(f"Attempt 2: Fetching avatar for user {user.id} via getUserPhotos")
            req = TLRPC.TL_photos_getUserPhotos()
            input_user = get_messages_controller().getInputUser(user.id)
            if not input_user:
                qlog(f"Could not get InputUser for {user.id}. Proceeding to service fallback.")
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
                return
            req.user_id = input_user
            req.limit = 1
            req.offset = 0
            req.max_id = 0
            send_request(req, RequestCallback(self._handle_user_photos_callback))
        except Exception as e:
            qlog(f"Exception initiating getUserPhotos fetch: {e}. Proceeding to service fallback.")
            if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                self._create_quote_without_input(skip_service_fallback=True)

    def _fetch_avatar_via_web(self, entity):
        try:
            username = getattr(entity, 'username', None)
            
            if not username and hasattr(entity, 'usernames') and entity.usernames:
                for i in range(entity.usernames.size()):
                    u_obj = entity.usernames.get(i)
                    if getattr(u_obj, 'active', False):
                        username = u_obj.username
                        break
                if not username and entity.usernames.size() > 0:
                    username = entity.usernames.get(0).username

            if not username:
                return self._create_quote_without_input()

            qlog(f"Fetching avatar via web for @{username}")
            url = f"https://t.me/{username}"
            headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}
            
            html_response = requests.get(url, headers=headers, timeout=10)
            html_response.raise_for_status()
            
            avatar_url = None
            match = re.search(r'<meta property="og:image" content="([^"]+)"', html_response.text)
            if match:
                avatar_url = match.group(1)
            else:
                match = re.search(r'<meta name="twitter:image" content="([^"]+)"', html_response.text)
                if match:
                    avatar_url = match.group(1)
                else:
                    match = re.search(r'<img class="tgme_page_photo_image" src="([^"]+)"', html_response.text)
                    if match:
                        avatar_url = match.group(1)
            
            if not avatar_url:
                return self._create_quote_without_input()
            
            avatar_response = requests.get(avatar_url, headers=headers, timeout=10)
            avatar_response.raise_for_status()

            temp_dir = Filesystem.get_temp_dir()
            avatars_dir = os.path.join(temp_dir, "avatars_cache")
            if not os.path.exists(avatars_dir):
                os.makedirs(avatars_dir)

            photo_id = 0
            if hasattr(entity, 'photo') and entity.photo:
                photo_id = entity.photo.photo_id
            
            if photo_id != 0:
                prefix = "u" if isinstance(entity, TLRPC.User) else "c"
                file_name = f"{prefix}_{photo_id}.jpg"
                file_path = os.path.join(avatars_dir, file_name)
            else:
                file_path = Filesystem.get_absolute_path(temp_dir, f"img_web_{entity.id}.jpg")
            
            Filesystem.write_file(file_path, avatar_response.content)
            
            self._create_and_send_image(
                image_path=file_path,
                output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                author=self._get_author(),
                quote=self._get_quote_message(),
                layout_vertical=(self.layout_index == 1)
            )
        except Exception as e:
            qlog(f"Web fallback failed: {e}")
            self._create_quote_without_input()

    def _handle_get_channels_callback(self, response, error):
        if error:
            return self._create_quote_without_input()
        if response and response.chats and response.chats.size() > 0:
            chat = response.chats.get(0)
            self.replyer.name = chat.title
            
            peer = self.replyer_id.peer
            if not peer:
                if chat.id < 0:
                    peer = get_messages_controller().getInputChannel(chat.id)
                else:
                    peer = get_messages_controller().getInputPeer(chat.id)

            self._fetch_chat_avatar(chat, peer)

    def _format_file_metadata(self, document, label_format):
        full_name = None
        name_part = "file"
        ext_part = ""
        file_size_str = ""
        
        try:
            if hasattr(document, 'attributes') and document.attributes:
                for i in range(document.attributes.size()):
                    attr = document.attributes.get(i)
                    if hasattr(attr, 'file_name'):
                        fn = attr.file_name
                        if fn:
                            full_name = str(fn)
                            break
                    elif hasattr(attr, 'fileName'):
                        fn = attr.fileName
                        if fn:
                            full_name = str(fn)
                            break
    
            if full_name:
                if '.' in full_name:
                    parts = full_name.rsplit('.', 1)
                    name_part = parts[0]
                    ext_part = parts[1]
                else:
                    name_part = full_name
                    ext_part = ""
            
            size_val = getattr(document, 'size', 0)
            if size_val > 0:
                if size_val < 1024:
                    file_size_str = f"{size_val}b"
                elif size_val < 1024 * 1024:
                    file_size_str = f"{round(size_val / 1024, 2)}kb"
                else:
                    file_size_str = f"{round(size_val / (1024 * 1024), 2)}mb"
                    
        except Exception as e:
            qlog(f"_format_file_metadata error: {e}")
            pass
    
        result = label_format.replace("{name}", name_part).replace("{ext}", ext_part)
        
        if not ext_part and "." in result:
            result = result.replace(".", "")
    
        if "{size}" in result:
            if file_size_str:
                result = result.replace("{size}", file_size_str)
            else:
                result = result.replace("{size}", "")
        
        return result.replace("  ", " ").strip()
        
    def _strip_custom_emojis(self, text, message_owner):
        if not text or not hasattr(message_owner, 'entities') or not message_owner.entities:
            return text
        
        try:
            custom_entities = [e for e in message_owner.entities if isinstance(e, TLRPC.TL_messageEntityCustomEmoji)]
            if not custom_entities:
                return text
            
            custom_entities.sort(key=lambda x: x.offset, reverse=True)
            
            u16 = text.encode('utf-16-le')
            
            for e in custom_entities:
                start_byte = e.offset * 2
                end_byte = (e.offset + e.length) * 2
                if start_byte < len(u16) and end_byte <= len(u16):
                    u16 = u16[:start_byte] + u16[end_byte:]
            
            return u16.decode('utf-16-le')
        except Exception:
            return text

    def _get_quote_message(self):
        if self.override_quote_text is not None:
            return self._sanitize_text(self.override_quote_text)
        
        self._fetch_attached_media()
        
        reply_obj = getattr(self.params, 'replyToMsg', None)
        if hasattr(reply_obj, 'messageOwner'):
            raw_message = reply_obj.messageOwner
        else:
            raw_message = reply_obj

        original_message = getattr(raw_message, 'message', "") or ""
        if not original_message:
            original_message = getattr(raw_message, 'caption', "") or ""
            
        message = self._strip_custom_emojis(original_message, raw_message)
        
        extended_logs = self.plugin.get_setting("extended_logging", False)

        try:
            should_render_media = self.plugin.get_setting("quote_render_image", True)
            media = getattr(raw_message, 'media', None)

            if should_render_media and media and isinstance(media, TLRPC.TL_messageMediaPhoto):
                return self._sanitize_text(message)
        
            if should_render_media and self.is_sticker_media and self.cached_media_path:
                return self._sanitize_text(message)

            message_type = 999 
            if hasattr(reply_obj, 'type'):
                message_type = reply_obj.type
            elif hasattr(raw_message, 'media') and raw_message.media:
                 pass 

            document = None
            
            if media:
                if isinstance(media, TLRPC.TL_messageMediaGame):
                    message_type = 18
                
                document = getattr(media, 'document', None)
                if not document:
                    webpage = getattr(media, 'webpage', None)
                    if webpage:
                         document = getattr(webpage, 'document', None)

            transcription = None
            is_emoji_only_message = False
        
            if self._is_emoji_only(original_message):
                is_emoji_only_message = True
            
            if document:
                is_gif = False
                is_video = False
                is_round = False
                is_voice = False
                is_sticker = False 
                is_music = False
                
                if hasattr(document, 'attributes'):
                    for i in range(document.attributes.size()):
                        attr = document.attributes.get(i)
                        if isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                            is_gif = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeSticker): 
                            is_sticker = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                            is_video = True
                            if getattr(attr, 'round_message', False):
                                is_round = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                            if getattr(attr, 'voice', False):
                                is_voice = True
                            else:
                                is_music = True

                if is_round: message_type = 5
                elif is_gif: message_type = 8
                elif is_sticker: message_type = 13
                elif is_video: message_type = 3
                elif is_voice: message_type = 2
                elif is_music: message_type = 14
                
                if message_type == 999:
                    message_type = 9

                if is_voice and not is_music and self.plugin.get_setting("enable_transcription", True):
                    voice_path = self._download_voice_message(document, raw_message)
                    if voice_path:
                        transcription = self._transcribe_voice(voice_path)

            label = ""
            
            if message_type == 11 and should_render_media: 
                return self._sanitize_text(message)
            elif message_type == 13 and should_render_media and self.is_sticker_media and self.cached_media_path:
                return self._sanitize_text(message)
            elif message_type == 9:
                raw_label = self.plugin.get_setting("attach_label_file", "[{name}.{ext} {size}]")
                if document:
                    label = self._format_file_metadata(document, raw_label)
                else:
                    label = self.plugin.get_setting("attach_label_none", "[вложение]")
            elif message_type == 2 and transcription:
                label = transcription
            elif message_type == 15 or message_type == 25:
                label = "" 
            elif message_type in range(1, 31):
                label = self.plugin.get_attach_label(message_type)

            if is_emoji_only_message:
                label = ""

            if label:
                if message:
                    message = str(label) + "\n" + message
                else:
                    message = str(label)
            
            return self._sanitize_text(message)
        except Exception as e:
            qlog(f"[ERROR] get_quote_message failed", e)
            return self._sanitize_text(message)
            
    def _init_replyer_id(self):
        replyer = self._get_replyer()
        replyer_peer = replyer.from_id
        
        if replyer.fwd_from is not None:
            replyer_peer = replyer.fwd_from.from_id
            
            if replyer.fwd_from.from_id is None:
                if hasattr(replyer.fwd_from, 'from_name') and replyer.fwd_from.from_name:
                    self.replyer.name = replyer.fwd_from.from_name
                elif hasattr(replyer.fwd_from, 'saved_from_name') and replyer.fwd_from.saved_from_name:
                    self.replyer.name = replyer.fwd_from.saved_from_name
        
        return ReplyerID(replyer_peer)

    def _get_full_replyer_name(self):
        if self.user:
            first_name = self.user.first_name or ""
            last_name = self.user.last_name or ""
            
            ignore_last_name = self.plugin.get_setting("ignore_last_name", False)
            if ignore_last_name:
                last_name = ""

            use_contact_data = self.plugin.get_setting("use_contact_data", True)
            if not use_contact_data and self.user.username:
                if not first_name and not last_name:
                    return self._sanitize_text(self.user.username)
            
            full_name = " ".join(filter(None, [first_name, last_name])).strip()
            if full_name:
                return self._sanitize_text(full_name)
        
        if self.replyer and self.replyer.name:
            return self._sanitize_text(self.replyer.name)
            
        return "Unknown"

    def _get_replyer(self):
        return self.params.replyToMsg.messageOwner

    def _get_replyer_id(self):
        return self.replyer_id.get_id()

    def _handle_user_photos_callback(self, response, error):
        def run():
            if error or not response or not hasattr(response, 'photos') or response.photos.size() == 0:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
                return

            try:
                photo = response.photos.get(0)
                best_size = None
                
                target_cache_file = None
                
                temp_dir = Filesystem.get_temp_dir()
                avatars_dir = os.path.join(temp_dir, "avatars_cache")
                if not os.path.exists(avatars_dir):
                    os.makedirs(avatars_dir)
                
                photo_id = getattr(photo, 'id', 0)
                if photo_id != 0:
                    cache_path = os.path.join(avatars_dir, f"u_{photo_id}.jpg")
                    target_cache_file = File(cache_path)

                sorted_sizes = []
                for size in photo.sizes:
                    if isinstance(size, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive)):
                        sorted_sizes.append(size)
                
                sorted_sizes.sort(key=lambda s: s.w * s.h, reverse=True)

                if sorted_sizes:
                    best_size = sorted_sizes[0]

                if not best_size:
                    return self._fetch_avatar_via_web(self.user)

                req = TLRPC.TL_upload_getFile()
                input_file = TelegramUtils.create_input_location(photo, best_size)
                req.location = input_file
                req.offset = 0
                req.limit = 1024 * 1024 * 4
                
                send_request(req, RequestCallback(lambda r, e: self._handle_get_file_callback(r, e, target_cache_file)))
            except Exception:
                return self._fetch_avatar_via_web(self.user)
        threading.Thread(target=run).start()

    def _try_fetch_username_avatar(self, username):
        if username == FALLBACK_AVATAR_USERNAME:
            temp_dir = Filesystem.get_temp_dir()
            cache_path = os.path.join(temp_dir, "extreme_demon_cache.jpg")
            if os.path.exists(cache_path) and os.path.getsize(cache_path) > 0:
                self._create_and_send_image(
                    image_path=cache_path,
                    output_path=Filesystem.get_absolute_path(temp_dir, f"quote_fb_{uuid.uuid4()}.jpg"),
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
                return True

        try:
            req = TLRPC.TL_contacts_resolveUsername()
            req.username = username
            send_request(req, RequestCallback(self._resolve_username_callback))
            qlog(f"Dispatched resolveUsername for @{username} as fallback")
            return True
        except Exception:
            return False

    def _resolve_username_callback(self, response, error):
        try:
            if error or not response:
                return self._create_quote_without_input(skip_service_fallback=True)
            try:
                if hasattr(response, "users") and response.users is not None and response.users.size() > 0:
                    u = response.users.get(0)
                    input_user = get_messages_controller().getInputUser(u.id)
                    if input_user is not None:
                        req = TLRPC.TL_photos_getUserPhotos()
                        req.user_id = input_user
                        req.limit = 1
                        send_request(req, RequestCallback(self._fallback_user_photos_callback))
                        return
            except Exception:
                pass
            try:
                if hasattr(response, "chats") and response.chats is not None and response.chats.size() > 0:
                    chat = response.chats.get(0)
                    if chat.photo is not None and chat.photo.photo_id != 0:
                        TelegramUtils.get_chat_thumbnail(chat, response.peer, self._handle_get_file_callback)
                        return
            except Exception:
                pass
            self._create_quote_without_input(skip_service_fallback=True)
        except Exception:
            self._create_quote_without_input(skip_service_fallback=True)

    def _fallback_user_photos_callback(self, response, error):
        def run():
            try:
                if not error and response:
                    try:
                        if response.photos is not None and response.photos.size() > 0:
                            photo = response.photos.get(0)
                            best_size = None
                            current_account = UserConfig.selectedAccount
                            file_loader = FileLoader.getInstance(current_account)

                            for size in photo.sizes:
                                if isinstance(size, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive)):
                                    if best_size is None or size.w > best_size.w:
                                        best_size = size

                            if best_size:
                                file_path_obj = file_loader.getPathToAttach(best_size, True)
                                if file_path_obj and file_path_obj.exists():
                                    with open(file_path_obj.getAbsolutePath(), "rb") as f:
                                        content = f.read()
                                    self._handle_get_file_callback_direct(content)
                                    return

                            if not best_size:
                               return self._create_quote_without_input(skip_service_fallback=True)
                            
                            req = TLRPC.TL_upload_getFile()
                            cb = RequestCallback(self._handle_get_file_callback)
                            input_file = TelegramUtils.create_input_location(photo, best_size)
                            req.location = input_file
                            req.offset = 0
                            req.limit = 1024 * 1024 * 4
                            send_request(req, cb)
                            return
                    except Exception:
                        pass
                self._create_quote_without_input(skip_service_fallback=True)
            except Exception:
                self._create_quote_without_input(skip_service_fallback=True)
        threading.Thread(target=run).start()

    def _handle_get_file_callback(self, response, error, target_cache_file=None):
        def run():
            resp_bytes = None
            try:
                if response and hasattr(response, 'bytes'):
                    resp_bytes = response.bytes
            except Exception:
                pass
    
            if error or not response or resp_bytes is None:
                if self.user:
                    return self._fetch_avatar_via_web(self.user)
                else:
                    return self._create_quote_without_input(skip_service_fallback=True)
            try:
                buffer = resp_bytes.buffer
                buffer.rewind()
                length = buffer.remaining()
                py_bytes = bytes([buffer.get() & 0xFF for _ in range(length)])
                
                final_image_path = ""
                
                if target_cache_file:
                    try:
                        final_image_path = target_cache_file.getAbsolutePath()
                        Filesystem.write_file(final_image_path, py_bytes)
                    except Exception:
                        user_id = self.user.id if self.user else uuid.uuid4()
                        final_image_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"temp_dl_{user_id}_{uuid.uuid4()}.jpg")
                        Filesystem.write_file(final_image_path, py_bytes)
                else:
                    user_id = self.user.id if self.user else uuid.uuid4()
                    final_image_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"temp_dl_{user_id}_{uuid.uuid4()}.jpg")
                    Filesystem.write_file(final_image_path, py_bytes)
                
                quote_output_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg")
                
                self._create_and_send_image(
                    image_path=final_image_path,
                    output_path=quote_output_path,
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
            except Exception:
                if self.user:
                    return self._fetch_avatar_via_web(self.user)
                return self._create_quote_without_input(skip_service_fallback=True)
        threading.Thread(target=run).start()

    def _create_quote_without_input(self, skip_service_fallback=False):
        def run():
            try:
                use_custom_avatar = self.plugin.get_setting("avatar_use_custom", False)
                
                if (use_custom_avatar or self.force_custom_avatar) and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
                     self._create_and_send_image(
                        image_path=self.custom_avatar_path,
                        output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"tmp_custom_{uuid.uuid4()}.jpg"),
                        author=self._get_author(),
                        quote=self._get_quote_message(),
                        layout_vertical=(self.layout_index == 1)
                     )
                     return
        
                if not self.force_custom_avatar and not skip_service_fallback:
                    if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                        self._create_quote_without_input(skip_service_fallback=True)
                    return
        
                user_or_chat_id = -1
                if self.user:
                    user_or_chat_id = self.user.id
                elif self.replyer_id:
                    user_or_chat_id = self._get_replyer_id()
                else:
                    user_or_chat_id = uuid.uuid4()
        
                tmp_file = f"tmp_{user_or_chat_id}.jpg"
                temp_dir = Filesystem.get_temp_dir()
                file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
                
                self._create_and_send_image(
                    output_path=file_path,
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
        
            except Exception as e:
                traceback.print_exc()
                copy_error_to_clipboard(traceback.format_exc())
        threading.Thread(target=run).start()

    def _create_color_background(self, width, height, use_random_bg, custom_bg_color):
        if use_random_bg:
            bg_color = tuple(random.randint(100, 255) for _ in range(3))
        else:
            bg_color = self.plugin._parse_hex_color(custom_bg_color, (0, 0, 0))
        return Image.new("RGB", (width, height), bg_color)

    def _apply_bg_style_beta(self, image, width, height, style):
        try:
            if style == 5:
                use_random_bg = self.plugin.get_setting("use_random_bg", True)
                custom_bg_color = self.plugin.get_setting("custom_bg_color", "#000000")
                if use_random_bg:
                    bg_color = tuple(random.randint(100, 255) for _ in range(3))
                else:
                    bg_color = self.plugin._parse_hex_color(custom_bg_color, (0, 0, 0))
                image = Image.new("RGB", (width, height), bg_color)
                result = image
            else:
                img_w, img_h = image.size
                scale = max(width / img_w, height / img_h)
                new_w, new_h = int(img_w * scale), int(img_h * scale)
                resized = image.resize((new_w, new_h), Image.LANCZOS)
                left = (new_w - width) // 2
                top = (new_h - height) // 2
                cropped = resized.crop((left, top, left + width, top + height))
        
                if style == 0:
                    result = cropped.convert("RGB")
                elif style == 1:
                    radius = int(self.plugin.get_setting("bg_blur_radius", "60"))
                    result = cropped.filter(ImageFilter.GaussianBlur(radius))
                elif style == 2:
                    radius = int(self.plugin.get_setting("bg_glass_blur_radius", "60"))
                    opacity = int(self.plugin.get_setting("bg_glass_opacity", "80"))
                    result = cropped.filter(ImageFilter.GaussianBlur(radius))
                    overlay = Image.new("RGBA", (width, height), (255, 255, 255, opacity))
                    result = Image.alpha_composite(result.convert("RGBA"), overlay).convert("RGB")
                elif style == 3:
                    noise_intensity = int(self.plugin.get_setting("bg_tv_noise_intensity", "60"))
                    result = cropped.filter(ImageFilter.GaussianBlur(5)).convert("RGBA")
                    
                    small_w = width // 4
                    small_h = height // 4
                    noise_bytes = os.urandom(small_w * small_h)
                    noise = Image.frombytes("L", (small_w, small_h), noise_bytes)
                    noise = noise.resize((width, height), Image.NEAREST)
                    
                    noise_overlay = Image.new("RGBA", (width, height), (0, 0, 0, 0))
                    mask = noise.point(lambda p: int(p * (noise_intensity / 255.0) * 0.5))
                    noise_overlay.putalpha(mask)
                    
                    result = Image.alpha_composite(result, noise_overlay).convert("RGB")
                elif style == 4:
                    pixel_size = int(self.plugin.get_setting("bg_pixel_size", "20"))
                    pixel_size = max(1, pixel_size)
                    small = cropped.resize((width // pixel_size, height // pixel_size), Image.NEAREST)
                    result = small.resize((width, height), Image.NEAREST)
                elif style == 6:
                    color1_hex = self.plugin.get_setting("bg_gradient_color1", "#FF8040")
                    color2_hex = self.plugin.get_setting("bg_gradient_color2", "#8040FF")
                    color1 = self.plugin._parse_hex_color(color1_hex, (255, 128, 64))
                    color2 = self.plugin._parse_hex_color(color2_hex, (128, 64, 255))
                    result = Image.new("RGB", (width, height))
                    draw = ImageDraw.Draw(result)
                    for i in range(width):
                        ratio = i / width
                        r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
                        g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
                        b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
                        draw.line([(i, 0), (i, height)], fill=(r, g, b))
                elif style == 7:
                    amplitude = float(self.plugin.get_setting("bg_waves_amplitude", "5"))
                    frequency = float(self.plugin.get_setting("bg_waves_frequency", "0.1"))
                    result = cropped.copy()
                    for y in range(height):
                        shift = int(amplitude * math.sin(y * frequency))
                        region = result.crop((0, y, width, y + 1))
                        result.paste(region, (shift, y))
                    result = result.filter(ImageFilter.GaussianBlur(3))
                else:
                    result = cropped.filter(ImageFilter.GaussianBlur(20))
            
            dimming_value = int(self.plugin.get_setting("bg_dimming", "70"))
            if dimming_value <= 0:
                dimming_value = 1
            dimming_value = min(100, dimming_value)
            
            alpha = int(dimming_value / 100 * 255)
            if alpha > 0:
                overlay = Image.new("RGBA", (width, height), (0, 0, 0, alpha))
                if result.mode != 'RGBA':
                    result = result.convert('RGBA')
                result = Image.alpha_composite(result, overlay).convert("RGB")
            return result
        except (ValueError, TypeError) as e:
            qlog(f"BG style value error: {e}")
            return Image.new("RGB", (width, height), (0, 0, 0))
        except Exception as e:
            qlog(f"BG style error: {e}")
            traceback.print_exc()
            return Image.new("RGB", (width, height), (0, 0, 0))

    def _apply_bg_filter_beta(self, image, filter_type):
        try:
            if filter_type == 0:
                return image
            if image.mode != 'RGB':
                image = image.convert('RGB')
            if filter_type == 1:
                return ImageOps.grayscale(image).convert('RGB')
            elif filter_type == 2:
                grayscale = ImageOps.grayscale(image)
                sepia = Image.new('RGB', grayscale.size)
                pixels = grayscale.load()
                sepia_pixels = sepia.load()
                for x in range(grayscale.size[0]):
                    for y in range(grayscale.size[1]):
                        gray = pixels[x, y]
                        r = min(255, int(gray * 1.1))
                        g = min(255, int(gray * 0.9))
                        b = min(255, int(gray * 0.7))
                        sepia_pixels[x, y] = (r, g, b)
                return sepia
            elif filter_type == 3:
                return ImageOps.invert(image)
            elif filter_type == 4:
                levels = int(self.plugin.get_setting("filter_posterize_levels", "4"))
                levels = max(2, min(8, levels))
                posterized = image.copy()
                pixels = posterized.load()
                for x in range(posterized.size[0]):
                    for y in range(posterized.size[1]):
                        r, g, b = pixels[x, y]
                        r = int(round(r / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        g = int(round(g / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        b = int(round(b / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        pixels[x, y] = (r, g, b)
                return posterized
            elif filter_type == 5:
                black_hex = self.plugin.get_setting("filter_colorize_black", "#000000")
                white_hex = self.plugin.get_setting("filter_colorize_white", "#FFD700")
                black_color = self.plugin._parse_hex_color(black_hex, (0,0,0))
                white_color = self.plugin._parse_hex_color(white_hex, (255,215,0))
                grayscale = ImageOps.grayscale(image)
                return ImageOps.colorize(grayscale, black=black_color, white=white_color).convert('RGB')
            elif filter_type == 6:
                factor = float(self.plugin.get_setting("filter_contrast_factor", "2.0"))
                enhancer = ImageEnhance.Contrast(image)
                return enhancer.enhance(factor)
            elif filter_type == 7:
                return image.filter(ImageFilter.EMBOSS)
            else:
                return image
        except (ValueError, TypeError) as e:
            qlog(f"BG filter value error: {e}")
            return image
        except Exception as e:
            qlog(f"BG filter error: {e}")
            return image

    def _get_profile_color(self):
        user_id = 0
        if self.user:
            user_id = self.user.id
        elif self.replyer_id:
            user_id = self._get_replyer_id()
        
        if user_id == 0:
            return self.plugin._parse_hex_color("#B4B4B4", (180, 180, 180))

        color_index = abs(user_id) % 7
        
        colors = [
            "#FF516A", 
            "#FF885E", 
            "#8E85EE", 
            "#53ED97", 
            "#28C9B7", 
            "#549CFC", 
            "#FF7CA8"  
        ]
        
        hex_color = colors[color_index]
        return self.plugin._parse_hex_color(hex_color, (180, 180, 180))

    def _create_and_send_image(self, image_path=None, output_path="quote.jpg", author="", quote="", layout_vertical=False):
        with self.finalize_lock:
            if self.is_finalized:
                return
            self.is_finalized = True

        extended_logs = self.plugin.get_setting("extended_logging", False)
        
        qlog("="*40)
        qlog(f"[RENDER] Starting Render process")
        qlog(f"[RENDER] Output Path: {output_path}")
        qlog(f"[RENDER] Author: {author}")
        
        font_index = self.plugin.get_setting("font", 0)
        quote_style = self.plugin.get_setting("quote_style", 0)
        bg_style = self.plugin.get_setting("bg_style", 0)
        
        try:
            attached_media_path = self._fetch_attached_media()
            selected_font = FontManager.get(font_index, self.plugin)
            font_path = selected_font.get_path()
            
            is_cloud_style = (quote_style == 3)
            
            if quote_style == 2:
                layout_vertical = True
                avatar_position = 0 
            elif is_cloud_style:
                layout_vertical = False
                avatar_position = 0 
            else:
                layout_vertical = False
                avatar_position = quote_style
    
            try:
                if is_cloud_style:
                    quote_font_size = int(self.plugin.get_setting("cloud_quote_font_size", "36"))
                    author_font_size = int(self.plugin.get_setting("cloud_author_font_size", "28"))
                else:
                    quote_font_size = int(self.plugin.get_setting("quote_font_size", "36"))
                    author_font_size = int(self.plugin.get_setting("author_font_size", "28"))
                line_spacing = int(self.plugin.get_setting("line_spacing", "10"))
            except (ValueError, TypeError):
                quote_font_size = 36
                author_font_size = 28
                line_spacing = 10
                            
            text_color_hex = self.plugin.get_setting("text_color_hex", "#FFFFFF")
            author_color_hex = self.plugin.get_setting("author_color_hex", "#B4B4B4")
            text_color = self.plugin._parse_hex_color(text_color_hex, (255, 255, 255))
            
            use_profile_color = self.plugin.get_setting("use_profile_color", True)
            if use_profile_color:
                author_color = self._get_profile_color()
            else:
                author_color = self.plugin._parse_hex_color(author_color_hex, (180, 180, 180))
            
            try:
                cloud_opacity = int(self.plugin.get_setting("cloud_bubble_opacity", "80"))
                cloud_opacity = max(0, min(100, cloud_opacity))
                cloud_opacity = int(cloud_opacity * 2.55)
            except: 
                cloud_opacity = 204
            
            cloud_bubble_color_hex = self.plugin.get_setting("cloud_bubble_color", "#1E1E1E")
            bubble_color_rgb = self.plugin._parse_hex_color(cloud_bubble_color_hex, (30, 30, 30))
            bubble_color = bubble_color_rgb + (cloud_opacity,)
            
            if is_cloud_style:
                if use_profile_color:
                    author_color = self._get_profile_color()
                
            show_avatar = self.plugin.get_setting("show_avatar", True)
            
            try:
                if is_cloud_style:
                    avatar_size = int(self.plugin.get_setting("cloud_avatar_size", "80"))
                else:
                    avatar_size = int(self.plugin.get_setting("avatar_size", "400"))
                avatar_size = max(50, min(400, avatar_size))
            except:
                avatar_size = 80 if is_cloud_style else 400
            
            try:
                avatar_rounding_percent = int(self.plugin.get_setting("avatar_rounding", "100"))
                avatar_rounding_percent = max(0, min(100, avatar_rounding_percent))
                avatar_rounding = int((avatar_rounding_percent / 100.0) * (avatar_size // 2))
            except:
                avatar_rounding = avatar_size // 2

            bg_style = self.plugin.get_setting("bg_style", 0)
            bg_filter = self.plugin.get_setting("bg_filter", 0)
            use_random_bg = self.plugin.get_setting("use_random_bg", True)
            custom_bg_color = self.plugin.get_setting("custom_bg_color", "#000000")
    
            attached_img = None
            if attached_media_path:
                try:
                    attached_img = Image.open(attached_media_path).convert("RGBA")
                    try:
                        reduction_pct = int(self.plugin.get_setting("quote_text_reduction", "14"))
                        reduction_factor = 1.0 - (max(0, min(90, reduction_pct)) / 100.0)
                        quote_font_size = int(quote_font_size * reduction_factor)
                    except: pass
                except Exception as e:
                    if extended_logs: qlog(f"[ERROR] Failed to open attached media: {e}")
                    attached_img = None
    
            try:
                quote_font = ImageFont.truetype(font_path, quote_font_size)
                author_font = ImageFont.truetype(font_path, author_font_size)
            except:
                try:
                    quote_font = ImageFont.load_default()
                    author_font = ImageFont.load_default()
                except: return
    
            temp_img = Image.new("RGB", (1, 1))
            temp_draw = ImageDraw.Draw(temp_img)
            
            safe_author = str(author) if author is not None else ""
            
            if is_cloud_style:
                prefix = self.plugin.get_setting("cloud_author_prefix", "")
                author_text = f"{prefix}{safe_author.strip()}"
            else:
                prefix = self.plugin.get_setting("author_prefix", "— ")
                author_text = f"{prefix}{safe_author.strip()}"
            
            canvas_width = 1200
            padding = 50
            bubble_padding = 40 if is_cloud_style else 0
            
            att_img_processed = None
            att_w, att_h = 0, 0
            
            if attached_img:
                available_w = canvas_width - (padding * 2)
                if not layout_vertical and show_avatar:
                    available_w -= (avatar_size + padding)
                if is_cloud_style:
                    available_w -= (bubble_padding * 2)
    
                try:
                    if layout_vertical:
                        scale_percent = int(self.plugin.get_setting("quote_image_size_vertical", "70"))
                    elif not is_cloud_style:
                        scale_percent = int(self.plugin.get_setting("quote_image_size_horizontal", "100"))
                    else:
                        scale_percent = 100
                    scale_factor = max(10, min(100, scale_percent)) / 100.0
                except:
                    scale_factor = 0.8 if layout_vertical else 1.0
                
                target_w = int(available_w * scale_factor)
                orig_w, orig_h = attached_img.size
                ratio = target_w / float(orig_w)
                att_w = int(orig_w * ratio)
                att_h = int(orig_h * ratio)
                
                if att_h > 1200: 
                    ratio = 1200 / float(att_h)
                    att_w = int(att_w * ratio)
                    att_h = 1200
    
                att_img_processed = attached_img.resize((att_w, att_h), Image.LANCZOS)
                
                try:
                    radius_percent = int(self.plugin.get_setting("quote_image_radius", "3"))
                    radius_percent = max(0, min(100, radius_percent))
                    if radius_percent > 0:
                        radius_pixels = int(min(att_w, att_h) * radius_percent / 100.0)
                        mask = Image.new("L", (att_w, att_h), 0)
                        mdraw = ImageDraw.Draw(mask)
                        mdraw.rounded_rectangle((0, 0, att_w, att_h), radius=radius_pixels, fill=255)
                        att_img_processed.putalpha(mask)
                except: pass
    
            max_text_width = canvas_width - padding * 2
            if not layout_vertical and show_avatar:
                max_text_width -= (avatar_size + padding)
            if is_cloud_style:
                left_offset = padding
                
            wrapped_quote = self._wrap_text(temp_draw, quote, quote_font, max_text_width)
            quote_width, quote_height = self._measure_text_dimensions(temp_draw, wrapped_quote, quote_font, line_spacing)
    
            wrapped_author = self._wrap_text(temp_draw, author_text, author_font, max_text_width)
            author_width, author_height = self._measure_text_dimensions(temp_draw, wrapped_author, author_font, line_spacing)
            
            if is_cloud_style:
                content_height = quote_height + author_height + 34
            else:
                content_height = quote_height + author_height
                
            if att_img_processed:
                content_height += att_h
                
            if is_cloud_style:
                if att_img_processed:
                    content_height += int(bubble_padding * 2.2)
                else:
                    content_height += int(bubble_padding * 1.6)
                    
            if layout_vertical:
                 if show_avatar:
                    content_height += avatar_size + padding
            else:
                 content_height = max(content_height, avatar_size)
            
            canvas_height = int(content_height + padding * 2)
            canvas_height = max(600, canvas_height)
            
            bg_source_path = None
            avatar_source_path = None
            
            if not self.force_custom_bg and not self.force_custom_avatar:
                if image_path and os.path.exists(image_path):
                    bg_source_path = image_path
                avatar_source_path = image_path
            elif self.force_custom_bg and not self.force_custom_avatar:
                if self.custom_bg_path and os.path.exists(self.custom_bg_path): bg_source_path = self.custom_bg_path
                if image_path and os.path.exists(image_path): avatar_source_path = image_path
            elif not self.force_custom_bg and self.force_custom_avatar:
                if image_path and os.path.exists(image_path): bg_source_path = image_path
                if self.custom_avatar_path and os.path.exists(self.custom_avatar_path): avatar_source_path = self.custom_avatar_path
            else:
                if self.custom_bg_path and os.path.exists(self.custom_bg_path): bg_source_path = self.custom_bg_path
                if self.custom_avatar_path and os.path.exists(self.custom_avatar_path): avatar_source_path = self.custom_avatar_path

            if not bg_source_path and avatar_source_path and os.path.exists(avatar_source_path):
                bg_source_path = avatar_source_path
    
            if bg_source_path:
                try:
                    orig_img = Image.open(bg_source_path).convert("RGBA")
                    canvas = self._apply_bg_style_beta(orig_img, canvas_width, canvas_height, bg_style)
                    if bg_filter > 0: canvas = self._apply_bg_filter_beta(canvas, bg_filter)
                except:
                    canvas = self._create_color_background(canvas_width, canvas_height, use_random_bg, custom_bg_color)
            else:
                canvas = self._create_color_background(canvas_width, canvas_height, use_random_bg, custom_bg_color)
    
            avatar_img = None
            if show_avatar:
                if avatar_source_path and os.path.exists(avatar_source_path):
                    try:
                        temp_ava = Image.open(avatar_source_path).convert("RGBA")
                        temp_ava = temp_ava.resize((avatar_size, avatar_size), Image.LANCZOS)
                        mask = Image.new("L", temp_ava.size, 0)
                        mask_draw = ImageDraw.Draw(mask)
                        if avatar_rounding_percent == 100:
                            mask_draw.ellipse((0, 0, avatar_size, avatar_size), fill=255)
                        elif avatar_rounding_percent == 0:
                            mask_draw.rectangle((0, 0, avatar_size, avatar_size), fill=255)
                        else:
                            mask_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=255)
                        temp_ava.putalpha(mask)
                        avatar_img = temp_ava
                    except Exception as e:
                        avatar_img = None
                
                if not avatar_img:
                    try:
                        temp_ava = Image.new("RGBA", (avatar_size, avatar_size), (0, 0, 0, 0))
                        avatar_draw = ImageDraw.Draw(temp_ava)
                        circle_color = tuple(random.randint(100, 255) for _ in range(3))
                        if avatar_rounding_percent == 100:
                            avatar_draw.ellipse((0, 0, avatar_size, avatar_size), fill=circle_color)
                        elif avatar_rounding_percent == 0:
                            avatar_draw.rectangle((0, 0, avatar_size, avatar_size), fill=circle_color)
                        else:
                            avatar_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=circle_color)
                        try:
                            letter_font = ImageFont.truetype(font_path, int(avatar_size * 0.4))
                            base_author = safe_author.strip()
                            letter = base_author[0].upper() if base_author else "?"
                            bbox = avatar_draw.textbbox((0, 0), letter, font=letter_font)
                            w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
                            avatar_draw.text(((avatar_size - w) // 2, (avatar_size - h) // 2), letter, font=letter_font, fill=(255, 255, 255))
                        except: pass
                        mask = Image.new("L", temp_ava.size, 0)
                        mask_draw = ImageDraw.Draw(mask)
                        if avatar_rounding_percent == 100:
                            mask_draw.ellipse((0, 0, avatar_size, avatar_size), fill=255)
                        elif avatar_rounding_percent == 0:
                            mask_draw.rectangle((0, 0, avatar_size, avatar_size), fill=255)
                        else:
                            mask_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=255)
                        temp_ava.putalpha(mask)
                        avatar_img = temp_ava
                    except Exception:
                        avatar_img = None

            draw = ImageDraw.Draw(canvas, 'RGBA')

            if is_cloud_style:
                left_offset = padding
                if show_avatar and avatar_img:
                    ava_x = padding
                    content_total_h = content_height
                    start_y = (canvas_height - content_total_h) // 2
                    ava_y = start_y + content_total_h - avatar_size
                    canvas.paste(avatar_img, (ava_x, ava_y), avatar_img)
                    left_offset = ava_x + avatar_size + 15
                
                content_total_h = content_height
                start_y = (canvas_height - content_total_h) // 2
                bubble_x1 = left_offset
                bubble_y1 = start_y
                max_content_w = max(quote_width, author_width)
                if att_img_processed: 
                    max_content_w = max(max_content_w, att_w)
                bubble_w = max_content_w + (bubble_padding * 2)
                bubble_h = content_total_h
                bubble_x2 = bubble_x1 + bubble_w
                bubble_y2 = bubble_y1 + bubble_h
            
                if show_avatar:
                    tail_coords = [(bubble_x1, bubble_y2 - 20), (bubble_x1 - 10, bubble_y2), (bubble_x1 + 20, bubble_y2)]
                    draw.polygon(tail_coords, fill=bubble_color)
                draw.rounded_rectangle((bubble_x1, bubble_y1, bubble_x2, bubble_y2), radius=30, fill=bubble_color)
                text_x = bubble_x1 + bubble_padding
                current_y = bubble_y1 + bubble_padding
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_author, author_font, author_color, line_spacing, max_width=author_width)
                current_y += author_height + 23
                
                if att_img_processed:
                    canvas.paste(att_img_processed, (text_x, current_y), att_img_processed)
                    current_y += att_h + 25
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, max_width=quote_width)

            elif layout_vertical:
                total_content_h = quote_height + author_height + 16
                if show_avatar and avatar_img:
                    total_content_h += avatar_size + 25
                if att_img_processed:
                    total_content_h += att_h + 15
            
                current_y = (canvas_height - total_content_h) // 2
                        
                if not att_img_processed: 
                    if current_y > 54:
                        current_y += 23
                        
                align_idx = self.plugin.get_setting("vertical_text_align", 1)
                align_map = {0: "left", 1: "center", 2: "right"}
                text_align = align_map.get(align_idx, "center")
                
                if show_avatar and avatar_img:
                    img_x = (canvas_width - avatar_size) // 2
                    canvas.paste(avatar_img, (img_x, current_y), avatar_img)
                    current_y += avatar_size + 24
                
                if att_img_processed: 
                    att_x = (canvas_width - att_w) // 2
                    canvas.paste(att_img_processed, (att_x, current_y), att_img_processed)
                    current_y += att_h + 16
                
                text_x = (canvas_width - quote_width) // 2
                author_x = (canvas_width - author_width) // 2
            
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, align=text_align, max_width=quote_width)
                current_y += quote_height + 10
                self._draw_text_with_emoji(canvas, draw, (author_x, current_y), wrapped_author, author_font, author_color, line_spacing, align=text_align, max_width=author_width)

            else:
                text_align = "left"
                left_offset = padding
                if show_avatar and avatar_img:
                    if avatar_position == 0:
                        img_x = padding
                        left_offset = img_x + avatar_size + padding
                    else:
                        img_x = canvas_width - avatar_size - padding
                        left_offset = padding
                        text_align = "right"
                    img_y = (canvas_height - avatar_size) // 2
                    canvas.paste(avatar_img, (img_x, img_y), avatar_img)
                
                content_block_h = quote_height + 10 + author_height
                if att_img_processed:
                    content_block_h += att_h + 20
                current_y = (canvas_height - content_block_h) // 2
                
                text_x = left_offset
                author_x = left_offset
                att_x = left_offset
                
                if text_align == "right":
                    right_boundary = img_x - padding
                    text_x = right_boundary - quote_width
                    author_x = right_boundary - author_width
                    if att_img_processed:
                        att_x = right_boundary - att_w
                
                if att_img_processed: 
                    canvas.paste(att_img_processed, (att_x, current_y), att_img_processed)
                    current_y += att_h + 14
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, align=text_align, max_width=quote_width)
                current_y += quote_height + 14
                self._draw_text_with_emoji(canvas, draw, (author_x, current_y), wrapped_author, author_font, author_color, line_spacing, align=text_align, max_width=author_width)

            canvas.save(output_path, quality=95, optimize=True)
            self._send_quote(output_path, len(quote))
        except Exception as e:
            qlog("CRITICAL ERROR in create_and_send_image", e)
            copy_error_to_clipboard(traceback.format_exc())

    def _send_quote(self, output_path, text_len=0):
        extended_logs = self.plugin.get_setting("extended_logging", False)
        try:
            threshold = int(self.plugin.get_setting("file_send_threshold", "44444"))
            is_file = text_len >= threshold
            
            if extended_logs:
                qlog(f"Sending quote. Path: {output_path}, Size: {os.path.getsize(output_path)} bytes, As File: {is_file}")
            
            params = {
                "peer": self.params.peer,
                "replyToMsg": self.params.replyToMsg,
                "replyToTopMsg": self.params.replyToTopMsg
            }
            
            if is_file:
                params["document"] = output_path
                params["force_document"] = True
                params["message"] = ""
            else:
                send_helper = get_send_messages_helper()
                photo = send_helper.generatePhotoSizes(output_path, None)
                params["photo"] = photo
                params["message"] = None

            send_message(params)
        except Exception as e:
            qlog("Error sending message", e)
            copy_error_to_clipboard(traceback.format_exc())
            
    def _get_text_width(self, draw, text, font):
        if not text:
            return 0
        
        try:
            font_size = font.size
        except:
            font_size = 36
            
        emoji_size = int(font_size * 1.15)
        total_width = 0
        
        positions = self._extract_emoji_positions(text)
        
        last_idx = 0
        for start, emoji_str in positions:
            if start > last_idx:
                text_part = text[last_idx:start]
                text_part = text_part.replace('\ufe0f', '').replace('\u200d', '')
                if text_part:
                    try:
                        total_width += draw.textlength(text_part, font=font)
                    except:
                        bbox = draw.textbbox((0, 0), text_part, font=font)
                        total_width += bbox[2] - bbox[0]
            
            total_width += emoji_size + 2
            last_idx = start + len(emoji_str)
            
        if last_idx < len(text):
            text_part = text[last_idx:]
            text_part = text_part.replace('\ufe0f', '').replace('\u200d', '')
            if text_part:
                try:
                    total_width += draw.textlength(text_part, font=font)
                except:
                    bbox = draw.textbbox((0, 0), text_part, font=font)
                    total_width += bbox[2] - bbox[0]
                
        return total_width

    def _break_long_word(self, draw, word, font, max_width):
        parts = []
        current = ""
        for ch in word:
            test = current + ch
            if self._get_text_width(draw, test, font) <= max_width:
                current = test
            else:
                if current:
                    parts.append(current)
                current = ch
        if current:
            parts.append(current)
        return parts

    def _sanitize_text(self, text):
        if not text: return " "
        text = str(text).replace("⠀", " ")
        return re.sub(r'[\u0000\u00A0\u00AD\u115F\u1160\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u200C\u200D\u200E\u200F\u202A\u202B\u202C\u202D\u202E\u2060\u2061\u2062\u2063\u2064\u2065\u2066\u2067\u2068\u2069\u206A\u206B\u206C\u206D\u206E\u206F\u3164\uFEFF]', ' ', text)

    def _wrap_text(self, draw, text, font, max_width):
        text = self._sanitize_text(text)
        lines = []
        paragraphs = text.split('\n')
        for p in paragraphs:
            words = p.split(' ')
            if len(words) == 0:
                lines.append('')
                continue
            current = ""
            for word in words:
                candidate = word if current == "" else current + " " + word
                if self._get_text_width(draw, candidate, font) <= max_width:
                    current = candidate
                else:
                    if current:
                        lines.append(current)
                    if self._get_text_width(draw, word, font) > max_width:
                        chunks = self._break_long_word(draw, word, font, max_width)
                        if chunks:
                            lines.extend(chunks[:-1])
                            current = chunks[-1]
                        else:
                            current = word
                    else:
                        current = word
            lines.append(current)
        return '\n'.join(lines)

    def _measure_text_dimensions(self, draw, text, font, spacing):
        if not text:
            return 0, 0
            
        lines = text.split('\n')
        max_width = 0
        total_height = 0
        
        try:
            font_size = font.size
        except:
            font_size = 36
        
        emoji_size = int(font_size * 1.15)
        
        try:
            bbox = draw.textbbox((0, 0), "Mq", font=font)
            text_height = bbox[3] - bbox[1]
        except:
            text_height = font_size
            
        uniform_line_height = max(text_height, emoji_size)
        
        for i, line in enumerate(lines):
            w = self._get_text_width(draw, line, font)
            max_width = max(max_width, w)
            
            total_height += uniform_line_height
            
            if i < len(lines) - 1:
                total_height += spacing
                
        return max_width, total_height

    def _draw_text_with_emoji(self, canvas, draw, position, text, font, color, spacing, align="left", max_width=0):
        x_start, y_start = position
        
        try:
            font_size = font.size
        except:
            font_size = 36
            
        emoji_size = int(font_size * 1.15)
        
        try:
            user_offset = int(self.plugin.get_setting("emoji_y_offset", "0"))
        except:
            user_offset = 0

        try:
            bbox = draw.textbbox((0, 0), "M", font=font)
            text_center_y = (bbox[1] + bbox[3]) / 2
            emoji_y_offset = int(text_center_y - (emoji_size / 2)) + user_offset
        except:
            emoji_y_offset = int((font_size - emoji_size) / 2) + user_offset

        try:
            bbox_h = draw.textbbox((0, 0), "Mq", font=font)
            text_height = bbox_h[3] - bbox_h[1]
        except:
            text_height = font_size
            
        uniform_line_height = max(text_height, emoji_size)

        lines = text.split('\n')
        current_y = y_start
        
        for line in lines:
            line_width = self._get_text_width(draw, line, font)
            
            current_x = x_start
            if align == "center" and max_width > 0:
                current_x = x_start + (max_width - line_width) // 2
            elif align == "right" and max_width > 0:
                current_x = x_start + (max_width - line_width)
            
            positions = self._extract_emoji_positions(line)
            segments = []
            last_idx = 0
            
            for start, emoji_str in positions:
                if start > last_idx:
                    segments.append(('text', line[last_idx:start]))
                segments.append(('emoji', emoji_str))
                last_idx = start + len(emoji_str)
            
            if last_idx < len(line):
                segments.append(('text', line[last_idx:]))
            
            for seg_type, content in segments:
                if seg_type == 'text':
                    clean_content = content.replace('\ufe0f', '').replace('\u200d', '')
                    if clean_content:
                        draw.text((current_x, current_y), clean_content, font=font, fill=color)
                        try:
                            w = draw.textlength(clean_content, font=font)
                        except:
                            bbox = draw.textbbox((0, 0), clean_content, font=font)
                            w = bbox[2] - bbox[0]
                        current_x += w
                else:
                    emoji_img = EmojiRenderer.render_emoji_to_pil(content, emoji_size)
                    if emoji_img:
                        draw_y = current_y + emoji_y_offset
                        try:
                            canvas.paste(emoji_img, (int(current_x), int(draw_y)), emoji_img)
                        except:
                            try:
                                canvas.paste(emoji_img, (int(current_x), int(draw_y)))
                            except:
                                pass
                        current_x += emoji_size + 2
                    else:
                        current_x += emoji_size

            current_y += uniform_line_height + spacing
    
    def _is_telegram_emoji(self, text):
        try:
            return Emoji.getEmojiDrawable(text) is not None
        except:
            return False

    def _extract_emoji_positions(self, text):
        positions = []
        i = 0
        length = len(text)
        
        while i < length:
            c = ord(text[i])
            if c < 128 and c not in (35, 42) and not (48 <= c <= 57):
                i += 1
                continue

            found = None
            found_len = 0
            
            max_lookahead = min(10, length - i)
            for l in range(max_lookahead, 0, -1):
                candidate = text[i:i+l]
                if self._is_telegram_emoji(candidate):
                    found = candidate
                    found_len = l
                    break
            
            if found:
                positions.append((i, found))
                i += found_len
                if i < length and ord(text[i]) == 0xFE0F:
                    i += 1
            else:
                i += 1
                
        return positions

    def _is_emoji_only(self, text):
        if not text or not text.strip():
            return False
        
        text = text.strip()
        
        emoji_count = 0
        char_count = 0
        
        for char in text:
            if self._is_emoji_char(char):
                emoji_count += 1
            elif not char.isspace():
                char_count += 1
        
        return emoji_count > 0 and char_count == 0
    
    def _is_emoji_char(self, char):
        try:
            codepoint = ord(char)
            
            if (0x1F000 <= codepoint <= 0x1FFFF or
                0x2600 <= codepoint <= 0x27BF or
                0x2300 <= codepoint <= 0x23FF or
                0x2B00 <= codepoint <= 0x2BFF or
                0xFE00 <= codepoint <= 0xFE0F or
                0x1F300 <= codepoint <= 0x1F9FF or
                0x1FA00 <= codepoint <= 0x1FAFF or
                0x203C <= codepoint <= 0x3299 or
                codepoint == 0x200D or
                codepoint == 0xFE0F):
                return True
        except:
            pass
        
        return False
        
    def _get_author(self):
        try:
            if self.override_author_name:
                name = str(self.override_author_name)
                if name.strip():
                    return name.strip()

            if self.user and self.replyer.name is not None:
                return self.replyer.name

            if self.replyer.name:
                name = str(self.replyer.name)
                if name.strip():
                    return name.strip()

            if self.search_query:
                name = str(self.search_query)
                if name.strip():
                    return name.strip()
        except Exception:
            pass
            
        default = self.plugin.get_setting("unknown_author_label", "Неизвестен")
        return str(default) if default is not None else "Неизвестен"

class QuotifyForkPlugin(BasePlugin):
    class ActivityResultHook(MethodHook):
        def __init__(self, plugin_instance):
            self.plugin = plugin_instance

        def before_hooked_method(self, param):
            request_code = param.args[0]
            result_code = param.args[1]
            data = param.args[2]
            
            handled = False
            if result_code == Activity.RESULT_OK and data is not None and data.getData() is not None:
                uri_string = data.getData().toString()
                
                if request_code == FILE_PICK_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'font'))
                    handled = True
                elif request_code == PICK_BG_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'bg'))
                    handled = True
                elif request_code == PICK_AVA_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'avatar'))
                    handled = True
                elif request_code == IMPORT_SETTINGS_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_import_json(uri_string))
                    handled = True

            if request_code in (FILE_PICK_REQUEST_CODE, PICK_BG_REQUEST_CODE, PICK_AVA_REQUEST_CODE, IMPORT_SETTINGS_CODE):
                if self.plugin._activity_hook:
                    self.plugin._activity_hook.unhook()
                    self.plugin._activity_hook = None

    def __init__(self):
        super().__init__()
        self._temp_dir_path = None
        self._activity_hook = None

    def on_plugin_load(self):
        try:
            self._prepare_directories()
            LocalizationManager.init()
            FontManager.init()
            DebugLogger.init(self) 
            self.add_on_send_message_hook()
            threading.Thread(target=self._ensure_fallback_avatar_cached).start()
            qlog("Plugin loaded successfully")
        except Exception as e:
            qlog(f"Load error: {e}")

    def _ensure_fallback_avatar_cached(self):
        try:
            temp_dir = self._temp_dir_path
            cache_path = os.path.join(temp_dir, "extreme_demon_cache.jpg")
            if os.path.exists(cache_path) and os.path.getsize(cache_path) > 0:
                return

            def on_resolve(response, error):
                if error or not response:
                    return
                try:
                    peer = None
                    photo = None
                    if hasattr(response, 'users') and not response.users.isEmpty():
                        user = response.users.get(0)
                        peer = get_messages_controller().getInputPeer(user.id)
                        if hasattr(user, 'photo') and hasattr(user.photo, 'photo_big'):
                            photo = user.photo
                    
                    if peer and photo:
                        location = TLRPC.TL_inputPeerPhotoFileLocation()
                        location.big = True
                        location.peer = peer
                        location.photo_id = photo.photo_id
                        
                        req = TLRPC.TL_upload_getFile()
                        req.location = location
                        req.offset = 0
                        req.limit = 1024 * 1024
                        
                        def on_file(res, err):
                            if not err and res and hasattr(res, 'bytes') and res.bytes is not None:
                                try:
                                    buffer = res.bytes.buffer
                                    buffer.rewind()
                                    length = buffer.remaining()
                                    py_bytes = bytes([buffer.get() & 0xFF for _ in range(length)])
                                    with open(cache_path, 'wb') as f:
                                        f.write(py_bytes)
                                except Exception:
                                    pass
                        
                        send_request(req, RequestCallback(on_file))
                except Exception:
                    pass

            req = TLRPC.TL_contacts_resolveUsername()
            req.username = FALLBACK_AVATAR_USERNAME
            send_request(req, RequestCallback(on_resolve))
        except Exception:
            pass

    def _toggle_debug_logging(self, value):
        self.set_setting("debug_logging", value)
        DebugLogger.enabled = value
        if value:
            BulletinHelper.show_success("Логирование включено")
            qlog("Debug logging enabled manually")
        else:
            BulletinHelper.show_info("Логирование выключено")

    def _save_debug_logs(self, view=None):
        export_dir = self._get_export_dir()
        saved_path = DebugLogger.save_logs(export_dir, is_error=False)
        if saved_path:
            BulletinHelper.show_success(f"Сохранено в:\n{saved_path}")
        else:
            BulletinHelper.show_error("Ошибка сохранения или логи пусты")

    def _clear_debug_logs(self, view=None):
        DebugLogger.clear_logs()
        BulletinHelper.show_success("Логи очищены")
        self.refresh_settings()

    def _test_logging(self, view=None):
        qlog("Test log entry")
        BulletinHelper.show_success("Запись добавлена")
        self.refresh_settings()

    def _copy_recent_logs(self, view=None):
        try:
            if not DebugLogger.logs:
                BulletinHelper.show_info("Логи пусты")
                return
            recent_logs = DebugLogger.logs[-10:]
            log_text = "\n".join(recent_logs)
            ctx = ApplicationLoader.applicationContext
            clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
            clip = ClipData.newPlainText("Quotify Logs", log_text)
            clipboard.setPrimaryClip(clip)
            BulletinHelper.show_success("Скопировано")
        except:
            BulletinHelper.show_error("Ошибка копирования")

    def _prepare_directories(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            temp_dir = File(base_dir, "quotify_fork")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            self._temp_dir_path = temp_dir.getAbsolutePath()
            fonts_dir = File(temp_dir, "fonts")
            if not fonts_dir.exists():
                fonts_dir.mkdirs()
            images_dir = File(temp_dir, "images")
            if not images_dir.exists():
                images_dir.mkdirs()
        except Exception as e:
            qlog(f"Directory error: {e}")

    def _parse_hex_color(self, hex_string, default_color):
        try:
            hex_string = hex_string.lstrip('#')
            if len(hex_string) == 6:
                return tuple(int(hex_string[i:i+2], 16) for i in (0, 2, 4))
        except (ValueError, TypeError):
            pass
        return default_color

    def _show_font_faq_alert(self, view=None):
        title = "🎨 Как выбрать кастомный шрифты"
        text = (
            "📝 Как добавить кастомный шрифт?\n\n"
            "1️⃣ Выберите 'Кастомный шрифт' в селекторе шрифтов\n\n"
            "2️⃣ Варианты загрузки:\n"
            "• Вставьте ссылку на .ttf файл\n"
            "• Или загрузите файл с устройства\n\n"
            "🔗 Примеры ссылок:\n"
            "• https://example.com/font.ttf\n"
            "• https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "💡 В КОНЦЕ ОБЯЗАТЕЛЬНО ДОЛЖНО БЫТЬ .ttf\n\n"
            "3️⃣ Сохраните настройки и создайте цитату (.q)\n\n"
            "⚡ Плагин автоматически скачает и будет использовать шрифт!\n\n"
            "🚨 ВАЖНО! ПРИ ПЕРВОМ ИСПОЛЬЗОВАНИИ/СМЕНЕ ШРИФТА КАРТОЧКА БУДЕТ СОЗДАВАТЬСЯ ДОЛЬШЕ\n\n"
            "💻 Рекомендуется загружать шрифты на Github\n\n"
            "🌐 Где искать шрифты (с прямыми ссылками):\n"
            "• https://fontsaddict.com\n"
            "• https://en.bestfonts.pro\n"
        )
        close_button = "Понятно"
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(text)
        builder.set_positive_button(close_button, lambda d, w: None)
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def create_settings(self):
        return [
            Header("Основные настройки"),
            Text(text="Команды", icon="input_bot1", create_sub_fragment=self.create_command_settings),
            Text(text="Макет и текст", icon="msg_theme", create_sub_fragment=self.create_appearance_settings),
            Text(text="Медиа", icon="msg_gallery", create_sub_fragment=self.create_media_settings),
            Text(text="Аватар", icon="msg_contacts_ny_remix", create_sub_fragment=self.create_avatar_settings),
            Text(text="Шрифты", icon="msg_photo_text_regular", create_sub_fragment=self.create_font_settings),
            Text(text="Фон и фильтры", icon="msg_photo_blur", create_sub_fragment=self.create_background_settings),
            Divider(),
            Header("Функции"),
            Text(text="Расшифровка голосовых", icon="ai_chat", create_sub_fragment=self.create_transcription_settings),
            Text(text="Метки вложений", icon="menu_tag_rename", create_sub_fragment=self.create_labels_settings),
            Text(text="Статистика", icon="msg_stats", create_sub_fragment=self.create_statistics_settings),
            Divider(),
            Header("Дополнительно"),
            Text(text="Для разработчиков", icon="files_folder_solar", create_sub_fragment=self.create_developer_settings),
        ]

    def create_media_settings(self):
        current_style = self.get_setting("quote_style", 0)
        settings = [
            Header("Медиа"),
            Switch(key="quote_render_image", text="Отображать медиа", default=True, subtext="Фотографии и стикеры", icon="msg_gallery", on_change=self.refresh_settings),
        ]
        
        if self.get_setting("quote_render_image", True):
            settings.extend([
                Input(key="quote_image_radius", text="% скругления медиа", default="5", subtext="0% = квадратные, 100% = максимальное скругление", icon="msg_mini_autodelete_empty"),
                Input(key="quote_text_reduction", text="% уменьшения текста", default="14", subtext="Если есть вложение", icon="msg_message"),
            ])
    
            if current_style == 2:
                settings.append(Input(key="quote_image_size_vertical", text="Масштаб (Вертикально)", default="70", subtext="% размера медиа", icon="msg_background"))
            elif current_style != 3:
                settings.append(Input(key="quote_image_size_horizontal", text="Масштаб (Горизонтально)", default="100", subtext="% размера медиа", icon="msg_background"))
    
        return settings

    def create_command_settings(self):
        return [
            Header("Обычные цитаты"),
            Input(key="q_default", text="Обычная цитата:", default=".q", subtext="Команда для создания цитаты", icon="menu_select_quote"),
            Input(key="q_force_bg", text="Кастом фон:", default=".qb", subtext="Использует фон из настроек", icon="msg_photos"),
            Input(key="q_force_ava", text="Кастом аватар:", default=".qa", subtext="Использует аватар из настроек", icon="msg_contacts"),
            Input(key="q_force_both", text="Кастом фон и аватар:", default=".qm", subtext="Использует фон и аватар из настроек", icon="menu_feature_reactions"),
            Divider(),
            Header("Фейковые цитаты"),
            Input(key="fq_default", text="Фейковая цитата:", default=".fq", subtext="Команда для создания фейк-цитаты", icon="msg_contacts_name"),
            Input(key="fq_force_bg", text="Кастом фон с фейком:", default=".fqb", subtext="Использует фон из настроек", icon="msg_photos"),
            Input(key="fq_force_ava", text="Кастом аватар с фейком:", default=".fqa", subtext="Использует аватар из настроек", icon="msg_contacts"),
            Input(key="fq_force_both", text="Кастом фон и аватар фейком:", default=".fqm", subtext="Использует фон и аватар из настроек", icon="menu_feature_reactions"),
            Divider(),
            Input(key="fake_name_separator", text="Разделитель текста/ника", default=DEFAULT_FAKE_NAME_SEPARATOR, subtext="Например: .fq текст | данные", icon="msg_search"),
        ]

    def create_appearance_settings(self):
        current_style = self.get_setting("quote_style", 0)
        
        settings = [
            Header("Макеты"),
            Selector(key="quote_style", text="Стиль расположения", default=0, items=["Горизонтальная (Ава слева)", "Горизонтальная (Ава справа)", "Вертикальная", "Облако"], icon="menu_edit_appearance", on_change=self.refresh_settings),
            Switch(key="ignore_last_name", text="Скрывать фамилию", default=False, subtext="Использовать только имя автора", icon="msg_contacts"),
        ]

        if current_style == 3:
            settings.append(Input(key="cloud_bubble_opacity", text="Прозрачность облака", default="84", subtext="От 0 (прозрачный) до 100 (плотный)", icon="msg_photo_flip"))
        
        settings.append(Divider())

        settings.append(Header("Цвета и Текст"))
        settings.append(Switch(key="use_profile_color", text="Профильный ник", default=True, subtext="Цвет ника, который берется с профиля", icon="msg_openprofile", on_change=self.refresh_settings))
        settings.append(Input(key="text_color_hex", text="HEX текста", default="#FFFFFF", subtext="Основной текст", icon="msg_photo_text_regular"))
        
        if not self.get_setting("use_profile_color", True):
            settings.append(Input(key="author_color_hex", text="HEX автора", default="#B4B4B4", subtext="Цвет имени", icon="msg_colors"))

        if current_style == 3:
            settings.append(Input(key="cloud_bubble_color", text="HEX облака", default="#1E1E1E", subtext="Фон облака", icon="msg_msgbubble3"))
            settings.append(Input(key="cloud_author_prefix", text="Префикс автора (облако)", default="", subtext="Текст перед именем (облако)", icon="msg_edit"))
        else:
            settings.append(Input(key="author_prefix", text="Префикс автора", default="— ", subtext="Текст перед именем", icon="msg_edit"))

        settings.extend([
            Divider(),
            Header("Размеры и отступы"),
        ])

        if current_style == 2:
            settings.append(Selector(key="vertical_text_align", text="Выравнивание текста (вертикаль)", default=1, items=["Слева", "По центру", "Справа"], icon="menu_tag_rename"))

        if current_style == 3:
            settings.append(Input(key="cloud_quote_font_size", text="Размер текста (облако)", default="36", subtext="Текст цитаты", icon="menu_select_quote"))
            settings.append(Input(key="cloud_author_font_size", text="Размер имени (облако)", default="28", subtext="Имя автора", icon="msg_contacts"))
        else:
            settings.append(Input(key="quote_font_size", text="Размер текста", default="36", subtext="Текст цитаты", icon="menu_select_quote"))
            settings.append(Input(key="author_font_size", text="Размер имени", default="28", subtext="Имя автора", icon="msg_contacts"))

        settings.append(Input(key="line_spacing", text="Отступ строк", default="10", subtext="В пикселях", icon="msg_list"))
        
        settings.append(Input(key="emoji_y_offset", text="Смещение эмодзи", default="0", subtext="Смещение эмодзи по вертикали", icon="input_smile"))

        return settings
        
    def create_transcription_settings(self):
        provider = self.get_setting("transcription_provider", 2)
        is_enabled = self.get_setting("enable_transcription", True)
        
        settings = [
            Header("Голосовые сообщения"),
            Switch(key="enable_transcription", text="Авто-расшифровка", default=True, subtext="Преобразовывать голос в текст цитаты", icon="ai_chat", on_change=self.refresh_settings),
        ]

        if not is_enabled:
            return settings

        settings.extend([
            Input(key="trans_format", text="Шаблон текста", default='[Расшифровка: "{text}"]', subtext="{text} - это полученный текст", icon="menu_tag_rename"),
            Divider(),
            Header("AI Провайдер"),
            Selector(key="transcription_provider", text="Сервис", default=2, items=["Gemini", "NavyAI", "Mistral", "Deepgram"], icon="msg_language", on_change=self.refresh_settings),
        ])

        if provider == 0:
            settings.extend([
                Input(key="trans_key_manual", text="API-ключ", default="AIzaSyAN9rzLGEUyCAW2QLIa6GTHHPblV0bIAZI", icon="msg_permissions"),
                Input(key="trans_model", text="Модель", default="gemini-2.5-flash", icon="msg_bot"),
                Text(text="Получить API Gemini", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://aistudio.google.com/apikey")),
                Text(text="Для API Gemini нужен VPN", icon="msg_info"),
            ])
        elif provider == 1:
            settings.extend([
                Input(key="trans_key_navy", text="API-ключ", default="sk-navy-yF-biQV5TdZwx567-9MIkeLxcIMZKqJ5sFCvzgICOJk", icon="msg_permissions"),
                Input(key="trans_model_navy", text="Модель", default="gpt-4o-transcribe", icon="msg_bot"),
                Text(text="Получить API NavyAI", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://api.navy/dashboard/#keys")),
            ])
        elif provider == 2:
            settings.extend([
                Input(key="trans_key_mistral", text="API-ключ", default="6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF", icon="msg_permissions"),
                Input(key="trans_model_mistral", text="Модель", default="voxtral-mini-2507", icon="msg_bot"),
                Text(text="Получить API Mistral", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://console.mistral.ai/home?workspace_dialog=apiKeys")),
            ])
        elif provider == 3:
            settings.extend([
                Input(key="trans_key_deepgram", text="API-ключ", default="011fb75d769d83fe88822e0c6f4e45cee8810116", icon="msg_permissions"),
                Input(key="trans_model_deepgram", text="Модель", default="nova-3-general", icon="msg_bot"),
                Text(text="Получить API Deepgram", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://console.deepgram.com")),
            ])
        
        return settings

    def create_developer_settings(self):
        try:
            default_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
        except Exception:
            default_path = os.path.join(ApplicationLoader.getFilesDirFixed().getAbsolutePath(), "Quotify+")
        
        return [
            Header("Экспорт и Импорт"),
            Input(key="export_path", text="Путь экспорта", default=default_path, subtext="Папка для сохранения логов и настроек", icon="files_folder_solar"),
            Text(text="Экспорт настроек (.json)", icon="msg_shareout", on_click=self._export_settings_json),
            Text(text="Импорт настроек (.json)", icon="msg_openin", on_click=self._import_settings_picker),
            Divider(),
            Header("Логирование"),
            Switch(key="debug_logging", text="Включить логи", default=False, icon="msg_log", on_change=self._toggle_debug_logging),
            Switch(key="copy_error_to_clipboard", text="Ошибка в буфере", default=True, subtext="Отправляет ошибку в буфер обмена", icon="msg_copy"),
            Text(text="Сохранить логи в файл", icon="msg_download", on_click=self._save_debug_logs),
            Text(text="Скопировать логи в буфер", icon="msg_copy", on_click=self._copy_recent_logs),
            Text(text="Очистить логи", icon="msg_delete", red=True, on_click=self._clear_debug_logs),
        ]
        
    def _get_settings_defaults(self):
        try:
            dl_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
        except Exception:
            dl_path = os.path.join(ApplicationLoader.getFilesDirFixed().getAbsolutePath(), "Quotify+")
        
        defaults = {
            "quote_render_image": True,
            "quote_image_radius": "5",
            "quote_text_reduction": "14",
            "quote_image_size_vertical": "70",
            "quote_image_size_horizontal": "100",
            
            "q_default": ".q",
            "q_force_bg": ".qb",
            "q_force_ava": ".qa",
            "q_force_both": ".qm",
            "fq_default": ".fq",
            "fq_force_bg": ".fqb",
            "fq_force_ava": ".fqa",
            "fq_force_both": ".fqm",
            "fake_name_separator": "|",
            
            "quote_style": 0,
            "ignore_last_name": False,
            "cloud_bubble_opacity": "84",
            "use_profile_color": True,
            "text_color_hex": "#FFFFFF",
            "author_color_hex": "#B4B4B4",
            "cloud_bubble_color": "#1E1E1E",
            "cloud_quote_font_size": "36",
            "cloud_author_font_size": "28",
            "quote_font_size": "36",
            "author_font_size": "28",
            "author_prefix": "— ",
            "cloud_author_prefix": "",

            "line_spacing": "10",
            "vertical_text_align": 1,
            "emoji_y_offset": "0",

            "enable_transcription": True,
            "trans_format": '[Расшифровка: "{text}"]',
            "transcription_provider": 2,
            "trans_key_manual": "AIzaSyAN9rzLGEUyCAW2QLIa6GTHHPblV0bIAZI",
            "trans_model": "gemini-2.5-flash",
            "trans_key_navy": "sk-navy-yF-biQV5TdZwx567-9MIkeLxcIMZKqJ5sFCvzgICOJk",
            "trans_model_navy": "gpt-4o-transcribe",
            "trans_key_mistral": "6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF",
            "trans_model_mistral": "voxtral-mini-2507",
            "trans_key_deepgram": "011fb75d769d83fe88822e0c6f4e45cee8810116",
            "trans_model_deepgram": "nova-3-general",
            
            "show_avatar": True,
            "avatar_size": "400",
            "cloud_avatar_size": "80",
            "avatar_rounding": "100",
            "avatar_use_custom": False,
            "avatar_custom_path": "",
            "use_random_bg": True,
            
            "font": 0,
            "gfonts_query": "",
            "custom_font_url": "",
            "custom_font_path": "",
            
            "bg_style": 0,
            "bg_blur_radius": "60",
            "bg_glass_blur_radius": "60",
            "bg_glass_opacity": "80",
            "bg_tv_noise_intensity": "60",
            "bg_pixel_size": "20",
            "bg_gradient_color1": "#FF8040",
            "bg_gradient_color2": "#8040FF",
            "bg_waves_amplitude": "5",
            "bg_waves_frequency": "0.1",
            "bg_filter": 0,
            "filter_posterize_levels": "4",
            "filter_colorize_black": "#000000",
            "filter_colorize_white": "#FFD700",
            "filter_contrast_factor": "2.0",
            "bg_dimming": "67",
            "custom_bg_color": "#000000",
            "bg_use_custom": False,
            "bg_custom_path": "",
            
            "enable_attach_labels": True,
            "attach_label_none": "[вложение]",
            "attach_label_file": "[{name}.{ext} {size}]",
            "attach_label_date": "[дата]",
            
            "attach_label_photo": "[фото]",
            "attach_label_video": "[видео]",
            "attach_label_gif": "[гиф]",
            "attach_label_voice": "[голосовое]",
            "attach_label_round": "[кружок]",
            "attach_label_audio": "[музыка]",
            "attach_label_sticker": "[стикер]",
            "attach_label_sticker_anim": "[премиум стикер]",
            "attach_label_gift": "[премиум]",
            "attach_label_poll": "[опрос]",
            "attach_label_geo": "[гео]",
            "attach_label_contact": "[контакт]",
            "attach_label_call": "[звонок]",
            "attach_label_story": "[история]",
            "attach_label_story_mention": "[упоминание в истории]",
    
            "debug_logging": False,
            "extended_logging": False,
            "export_path": dl_path,
            "copy_error_to_clipboard": True,
            
            "quotify_stats_total": 0,
            "quotify_stats_normal": 0,
            "quotify_stats_fake": 0,
            "stats_cmd_q": 0, "stats_cmd_qf": 0, "stats_cmd_qc": 0, "stats_cmd_qm": 0,
            "stats_cmd_fq": 0, "stats_cmd_fqf": 0, "stats_cmd_fqc": 0, "stats_cmd_fqm": 0
        }
        return defaults

    def _get_export_dir(self):
        try:
            default_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
            custom_path = self.get_setting("export_path", default_path)
            if not os.path.exists(custom_path):
                os.makedirs(custom_path)
                qlog(f"Created export directory: {custom_path}")
            return custom_path
        except Exception as e:
            qlog(f"Error creating export directory: {e}")
            return os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")

    def _save_debug_logs(self, view=None):
        export_dir = self._get_export_dir()
        saved_path = DebugLogger.save_logs(export_dir)
        if saved_path:
            BulletinHelper.show_success(f"Сохранено в:\n{saved_path}")
        else:
            BulletinHelper.show_error("Ошибка сохранения или логи пусты")

    def _export_settings_json(self, view=None):
        try:
            qlog("Starting full settings export...")
            settings_data = {}
            defaults = self._get_settings_defaults()
            
            for key, default_val in defaults.items():
                val = self.get_setting(key, default_val)
                settings_data[key] = val
            
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            filename = f"quotify_settings_{timestamp}.json"
            
            export_dir = self._get_export_dir()
            file_path = os.path.join(export_dir, filename)
            
            qlog(f"Writing {len(settings_data)} keys to: {file_path}")
            
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(settings_data, f, indent=4, ensure_ascii=False)
                
            qlog("Export completed successfully.")
            BulletinHelper.show_success(f"Сохранено:\n{filename}")
        except Exception as e:
            qlog(f"Export failed: {e}", error=e)
            BulletinHelper.show_error("Ошибка экспорта")

    def _import_settings_picker(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Ошибка активити!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("application/json") 
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            activity.startActivityForResult(Intent.createChooser(intent, "Выберите JSON с настройками"), IMPORT_SETTINGS_CODE)
        except Exception as e:
            qlog(f"Import picker error: {e}")
            BulletinHelper.show_error("Ошибка выбора файла")

    def _handle_import_json(self, uri_string):
        try:
            qlog(f"Starting import from: {uri_string}")
            uri = Uri.parse(uri_string)
            content_resolver = ApplicationLoader.applicationContext.getContentResolver()
            input_stream = content_resolver.openInputStream(uri)
            
            if not input_stream:
                BulletinHelper.show_error("Ошибка открытия файла")
                return

            byte_stream = ByteArrayOutputStream()
            buffer = bytearray(4096)
            while True:
                read = input_stream.read(buffer)
                if read == -1: break
                byte_stream.write(buffer, 0, read)
            
            json_str = byte_stream.toString("UTF-8")
            data = json.loads(json_str)
            
            count = 0
            for key, value in data.items():
                self.set_setting(key, value)
                count += 1
            
            input_stream.close()
            qlog(f"Successfully imported {count} settings.")
            BulletinHelper.show_success(f"Загружено настроек: {count}")
            self.refresh_settings()
            
        except json.JSONDecodeError as e:
            qlog("Import JSON error", error=e)
            BulletinHelper.show_error("Файл поврежден (не JSON)")
        except Exception as e:
            qlog("Import critical error", error=e)
            BulletinHelper.show_error(f"Ошибка импорта: {e}")

    def _open_url(self, url):
        try:
            current_fragment = get_last_fragment()
            if not current_fragment or not current_fragment.getParentActivity():
                return
            context = current_fragment.getParentActivity()
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            context.startActivity(intent)
        except Exception as e:
            qlog(f"Error opening URL: {e}")

    def create_avatar_settings(self):
        is_avatar_enabled = self.get_setting("show_avatar", True)
    
        settings = [
            Header("Отображение"),
            Switch(key="show_avatar", text="Показывать аватар", default=True, icon="msg_contacts", on_change=self.refresh_settings),
        ]
        
        if is_avatar_enabled:
            settings.extend([
                Input(key="avatar_size", text="Размер аватара", default="400", subtext="Для обычных стилей (50-400)", icon="msg_photo_crop"),
                Input(key="cloud_avatar_size", text="Размер аватара (Облако)", default="80", subtext="Размер в пикселях (рекомендуется 60-100)", icon="msg_msgbubble3"),
                Input(key="avatar_rounding", text="% скругления углов авы", default="100", subtext="0 = квадрат, 100 = круг", icon="msg_status_edit"),
                Divider(),
                Header("Кастомный аватар"),
                Switch(key="avatar_use_custom", text="Использовать кастомную аву", default=self.get_setting("avatar_use_custom", False), subtext="Используется, если аватар у пользователя отсутствует, или принудительно через команды.", icon="msg_photos"),
                Text(text="Выбрать из галереи", icon="msg_gallery", on_click=self._open_gallery_for_avatar),
                Text(text="Удалить кастомный аватар", icon="msg_delete", on_click=self._clear_custom_avatar, red=True),
            ])
            
        return settings

    def create_font_settings(self):
        custom_font_path = self.get_setting("custom_font_path", "")
        current_font_text = f"Текущий шрифт: {os.path.basename(custom_font_path)}" if custom_font_path else "Шрифт не выбран"
        return [
            Header("Основной шрифт"),
            Selector(key="font", text="Шрифт", default=0, items=FontManager.get_fonts_names(), icon="msg_photo_text_regular"),
            Text(text="Как выбрать кастом шрифты", icon="msg_info", on_click=self._show_font_faq_alert),
            Divider(),
            Header("Google Fonts"),
            Input(key="gfonts_query", text="Поисковой запрос", default=self.get_setting("gfonts_query", ""), icon="ic_send"),
            Text(text="Найти и установить", icon="msg_search", on_click=self._search_google_fonts_and_pick),
            Divider(),
            Header("Загрузка своего шрифта"),
            Input(key="custom_font_url", text="Ссылка на кастом шрифт (.ttf)", default="", subtext="Вставьте прямую ссылку на .ttf файл.\nПример: https://example.com/font.ttf", icon="msg_photo_text_framed3"),
            Text(text="Загрузить файл шрифта (.ttf/.otf)", icon="files_folder_solar", accent=True, on_click=self._launch_font_file_picker),
            Text(text=current_font_text, icon="msg_log"),
        ]

    def create_background_settings(self):
        settings = [
            Header("Настройки фона"),
            Selector(
                key="bg_style",
                text="Стиль фона",
                default=0,
                items=["Без стиля", "Блюр", "Мокрое стекло", "Старый TV", "Пиксели", "Сплошной цвет", "Градиент", "Волны"],
                icon="msg_theme",
                on_change=self.refresh_settings
            )
        ]

        current_style = self.get_setting("bg_style", 0)

        if current_style == 1:
            settings.append(Input(key="bg_blur_radius", text="Размытие", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_photo_blur"))
        elif current_style == 2:
            settings.append(Input(key="bg_glass_blur_radius", text="Размытие", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_photo_blur"))
            settings.append(Input(key="bg_glass_opacity", text="Прозрачность наложения", default="80", subtext="Значение от 0 до 255", icon="msg_photo_flip"))
        elif current_style == 3:
            settings.append(Input(key="bg_tv_noise_intensity", text="Интенсивность шума", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_voicechat"))
        elif current_style == 4:
            settings.append(Input(key="bg_pixel_size", text="Размер пикселя", default="20", subtext="Размер пикселя (например, 20)", icon="msg_spoiler"))
        elif current_style == 6:
            settings.append(Input(key="bg_gradient_color1", text="Цвет 1", default="#FF8040", subtext="HEX начального градиента", icon="msg_palette"))
            settings.append(Input(key="bg_gradient_color2", text="Цвет 2", default="#8040FF", subtext="HEX конечного градиента", icon="msg_palette"))
        elif current_style == 7:
            settings.append(Input(key="bg_waves_amplitude", text="Амплитуда", default="5", subtext="Сила искажения", icon="msg_status_edit_solar"))
            settings.append(Input(key="bg_waves_frequency", text="Частота", default="0.1", subtext="Частота волн", icon="msg_stats"))

        settings.extend([
            Selector(
                key="bg_filter",
                text="Фильтр фона",
                default=0,
                items=["Без фильтра", "Чёрно-белый", "Сепия", "Инверсия", "Постеризация", "Окрашивание", "Контраст", "Тиснение"],
                icon="msg_reactions",
                on_change=self.refresh_settings
            )
        ])
        
        current_filter = self.get_setting("bg_filter", 0)

        if current_filter == 4:
            settings.append(Input(key="filter_posterize_levels", text="Количество уровней", default="4", subtext="Количество цветовых уровней (2-8)", icon="msg_fave"))
        elif current_filter == 5:
            settings.append(Input(key="filter_colorize_black", text="HEX для чёрного", default="#000000", subtext="HEX", icon="msg_palette"))
            settings.append(Input(key="filter_colorize_white", text="HEX для белого", default="#FFD700", subtext="HEX", icon="msg_palette"))
        elif current_filter == 6:
            settings.append(Input(key="filter_contrast_factor", text="Сила контраста", default="2.0", subtext="Например, 1.5 или 2.0", icon="menu_feature_cover"))

        settings.extend([
            Input(key="bg_dimming", text="Затемнение фона", default="67", subtext="Значение от 0 (нет) до 100 (черный)", icon="msg_photo_flip"),
            Input(key="custom_bg_color", text="HEX фона", default="#000000", subtext="Введите HEX-код цвета (например, #000000)", icon="msg_colors"),
            Divider(),
            Header("Кастомный фон"),
            Switch(key="bg_use_custom", text="Использовать кастомный фон", default=self.get_setting("bg_use_custom", False), subtext="Принудительно заменяет фон. Может быть вызван командами, даже если выключено.", icon="msg_photos"),
            Text(text="Выбрать фон из галереи", icon="msg_gallery", on_click=self._open_gallery_for_bg),
            Text(text="Сбросить кастомный фон", icon="msg_delete", on_click=self._clear_custom_bg),
        ])
        return settings

    def create_labels_settings(self):
        return [
            Header("Основные"),
            Switch(key="enable_attach_labels", text="Включить метки", default=True, subtext="Добавлять подписи типа [фото] к тексту", icon="menu_tag_rename"),
            Input(key="attach_label_none", text="Неизвестное вложение", default="[вложение]", subtext="Используется, если тип не распознан", icon="msg_photo_flip"),
            Input(key="attach_label_file", text="Файл", default="[{name}.{ext} {size}]", subtext="Поддерживает {name}, {size}, {ext}", icon="msg_sendfile"),
            Divider(),
            Header("Медиа и сообщения"),
            Input(key="attach_label_photo", text="Фото", default="[фото]", icon="msg_photos"),
            Input(key="attach_label_video", text="Видео", default="[видео]", icon="menu_videocall"),
            Input(key="attach_label_gif", text="GIF", default="[гиф]", icon="msg_gif"),
            Input(key="attach_label_voice", text="Голосовое", default="[голосовое]", icon="input_mic"),
            Input(key="attach_label_round", text="Кружок", default="[кружок]", icon="input_video_solar"),
            Input(key="attach_label_audio", text="Музыка", default="[музыка]", icon="msg_tone_on"),
            Divider(),
            Header("Стикеры и эмодзи"),
            Input(key="attach_label_sticker", text="Стикер", default="[стикер]", icon="msg_sticker"),
            Input(key="attach_label_sticker_anim", text="Премиум стикер", default="[премиум стикер]", icon="input_smile"),
            Input(key="attach_label_gift", text="Подарок", default="[премиум]", icon="msg_gift_premium"),
            Divider(),
            Header("Другое"),
            Input(key="attach_label_poll", text="Опрос", default="[опрос]", icon="msg_topics"),
            Input(key="attach_label_geo", text="Геопозиция", default="[гео]", icon="msg_location"),
            Input(key="attach_label_contact", text="Контакт", default="[контакт]", icon="msg_contacts"),
            Input(key="attach_label_call", text="Звонок", default="[звонок]", icon="msg_calls"),
            Input(key="attach_label_story", text="История", default="[история]", icon="msg_msgbubble3"),
            Input(key="attach_label_story_mention", text="Упоминание в истории", default="[упоминание в истории]", icon="msg_mention"),
            Input(key="attach_label_date", text="Дата", default="[дата]", icon="msg_calendar2"),
        ]

    def create_statistics_settings(self):
        total = self.get_setting("quotify_stats_total", 0)
        normal = self.get_setting("quotify_stats_normal", 0)
        fake = self.get_setting("quotify_stats_fake", 0)
        return [
            Header("Статистика использования"),
            Text(text=f"Всего создано цитат: {total}", icon="msg_fave"),
            Text(text=f"Обычные цитаты: {normal}", icon="menu_select_quote"),
            Text(text=f"Фейковые цитаты: {fake}", icon="msg_contacts_name"),
            Divider(),
            Text(text="Подробная статистика по командам", icon="msg_list", create_sub_fragment=self._create_detailed_stats_fragment),
            Divider(),
            Text(text="Сбросить статистику", icon="msg_delete", red=True, on_click=self._confirm_reset_statistics)
        ]

    def _create_detailed_stats_fragment(self):
        cmd_keys = {
            "q_default": "stats_cmd_q", "q_force_bg": "stats_cmd_qf", "q_force_ava": "stats_cmd_qc", "q_force_both": "stats_cmd_qm",
            "fq_default": "stats_cmd_fq", "fq_force_bg": "stats_cmd_fqf", "fq_force_ava": "stats_cmd_fqc", "fq_force_both": "stats_cmd_fqm"
        }
        cmd_defaults = {
            "q_default": ".q", "q_force_bg": ".qb", "q_force_ava": ".qa", "q_force_both": ".qm",
            "fq_default": ".fq", "fq_force_bg": ".fqb", "fq_force_ava": ".fqa", "fq_force_both": ".fqm"
        }
        cmd_icons = {
            "q_default": "menu_select_quote", "q_force_bg": "msg_photos", "q_force_ava": "msg_contacts", "q_force_both": "menu_feature_reactions",
            "fq_default": "msg_contacts_name", "fq_force_bg": "msg_photos", "fq_force_ava": "msg_contacts", "fq_force_both": "menu_feature_reactions"
        }
        
        stats_list = [Header("Использование команд")]
        for key, stat_key in cmd_keys.items():
            cmd_name = self.get_setting(key, cmd_defaults[key])
            count = self.get_setting(stat_key, 0)
            icon = cmd_icons.get(key)
            stats_list.append(Text(text=f"{cmd_name}: использовано {count} раз", icon=icon))
            
        return stats_list

    def _confirm_reset_statistics(self, view=None):
        fragment = get_last_fragment()
        if not fragment or not fragment.getParentActivity():
            return
        activity = fragment.getParentActivity()
        builder = AlertDialogBuilder(activity)
        builder.set_title("Сброс статистики")
        builder.set_message("Вы уверены, что хотите сбросить всю статистику использования? Это действие необратимо.")
        builder.set_positive_button("Сбросить", self._reset_statistics)
        builder.set_negative_button("Отмена", lambda b, w: b.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        builder.show()

    def _reset_statistics(self, bld, which):
        if bld: bld.dismiss()
        keys_to_reset = [
            "quotify_stats_total", "quotify_stats_normal", "quotify_stats_fake",
            "stats_cmd_q", "stats_cmd_qf", "stats_cmd_qc", "stats_cmd_qm",
            "stats_cmd_fq", "stats_cmd_fqf", "stats_cmd_fqc", "stats_cmd_fqm",
        ]
        for key in keys_to_reset:
            self.set_setting(key, 0)
        BulletinHelper.show_success("Статистика сброшена")
        self.refresh_settings()
        
    def _increment_stat(self, key):
        current_value = self.get_setting(key, 0)
        self.set_setting(key, current_value + 1)

    def _search_google_fonts_and_pick(self, view=None):
        try:
            import requests
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")
            return
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass
        query = (self.get_setting("gfonts_query", "") or "").strip().lower()
        api_key = "AIzaSyAN9rzLGEUyCAW2QLIa6GTHHPblV0bIAZI"
        try:
            url = f"https://www.googleapis.com/webfonts/v1/webfonts?key={api_key}&sort=popularity"
            resp = requests.get(url, timeout=20)
            if resp.status_code != 200:
                BulletinHelper.show_error("Ошибка Google Fonts")
                return
            data = resp.json()
            items = data.get("items", []) if isinstance(data, dict) else []
            if query:
                items = [it for it in items if query in (it.get("family", "").lower())]
            if not items:
                BulletinHelper.show_info("Ничего не найдено")
                return
            def show_family_picker():
                try:
                    from client_utils import get_last_fragment
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title("Поиск в Google Fonts")
                    names = [it.get("family", "?") for it in items]
                    def on_family(bld, index):
                        try:
                            bld.dismiss()
                            self._pick_gfont_variant(items[index])
                        except Exception:
                            pass
                    builder.set_items(names, on_family)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass
            run_on_ui_thread(show_family_picker)
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")

    def _pick_gfont_variant(self, item):
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass
        try:
            files = item.get("files", {}) if isinstance(item, dict) else {}
            candidates = [(variant, url) for variant, url in files.items() if isinstance(url, str) and (url.endswith('.ttf') or url.endswith('.otf'))]
            if not candidates:
                BulletinHelper.show_info("Доступны только варианты .ttf/.otf")
                return
            def show_variant_picker():
                try:
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title("Поиск в Google Fonts")
                    items = [v for (v, _) in candidates]
                    def on_variant(bld, index):
                        try:
                            _, url = candidates[index]
                            self.set_setting("custom_font_url", url)
                            self.set_setting("font", 4)
                            BulletinHelper.show_success("Шрифт выбран!")
                            bld.dismiss()
                        except Exception:
                            bld.dismiss()
                    builder.set_items(items, on_variant)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass
            run_on_ui_thread(show_variant_picker)
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")

    def _hook_activity_for_picker(self, activity):
        if self._activity_hook:
            self._activity_hook.unhook()
        method = activity.getClass().getDeclaredMethod("onActivityResult", Integer.TYPE, Integer.TYPE, Intent)
        self._activity_hook = self.hook_method(method, self.ActivityResultHook(self))
        qlog("Hooked onActivityResult for activity.")
        
    def _launch_font_file_picker(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("*/*")
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            activity.startActivityForResult(Intent.createChooser(intent, "Выберите файл шрифта"), FILE_PICK_REQUEST_CODE)
        except Exception as e:
            qlog(f"Font picker error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка при открытии выбора файла!"))

    def _open_gallery_for_bg(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.setType("image/*")
            activity.startActivityForResult(intent, PICK_BG_REQUEST_CODE)
        except Exception as e:
            qlog(f"BG picker error: {e}")
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _open_gallery_for_avatar(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.setType("image/*")
            activity.startActivityForResult(intent, PICK_AVA_REQUEST_CODE)
        except Exception as e:
            qlog(f"Avatar picker error: {e}")
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _clear_custom_bg(self, view=None):
        try:
            path = self.get_setting("bg_custom_path", "")
            if path and os.path.exists(path):
                try:
                    os.remove(path)
                except Exception:
                    pass
            self.set_setting("bg_use_custom", False)
            self.set_setting("bg_custom_path", "")
            BulletinHelper.show_success("Фон сброшен")
        except Exception:
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _clear_custom_avatar(self, view=None):
        try:
            path = self.get_setting("avatar_custom_path", "")
            if path and os.path.exists(path):
                try:
                    os.remove(path)
                except Exception:
                    pass
            self.set_setting("avatar_use_custom", False)
            self.set_setting("avatar_custom_path", "")
            BulletinHelper.show_success("Аватар сброшен")
        except Exception:
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _handle_file_picker_result(self, uri_string: str, file_type: str):
        input_stream = None
        output_stream = None
        try:
            uri = Uri.parse(uri_string)
            content_resolver = ApplicationLoader.applicationContext.getContentResolver()
            
            if file_type == 'font':
                file_name = f"font_{uuid.uuid4()}"
                cursor = content_resolver.query(uri, None, None, None, None)
                if cursor is not None:
                    try:
                        if cursor.moveToFirst() and (idx := cursor.getColumnIndex("_display_name")) != -1:
                            file_name = cursor.getString(idx)
                    finally:
                        cursor.close()
                
                if not file_name.lower().endswith((".ttf", ".otf")):
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Файл не является шрифтом (.ttf/.otf)!"))
                    return
                    
                target_dir = File(self._temp_dir_path, "fonts")
                if not target_dir.exists(): target_dir.mkdirs()
                
                target_file_name = f"custom_{file_name}"
                target_file = File(target_dir, target_file_name)
                
                input_stream = content_resolver.openInputStream(uri)
                if not input_stream:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось открыть файл!"))
                    return
                    
                output_stream = FileOutputStream(target_file)
                buffer = bytearray(4096)
                bytes_read = input_stream.read(buffer)
                while bytes_read != -1:
                    output_stream.write(buffer, 0, bytes_read)
                    bytes_read = input_stream.read(buffer)
                    
                self.set_setting("custom_font_path", target_file.getAbsolutePath())
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"Шрифт '{file_name}' загружен!"))
                
            else:
                try:
                    input_stream = content_resolver.openInputStream(uri)
                    bitmap = BitmapFactory.decodeStream(input_stream)
                    if input_stream: input_stream.close()
                    
                    if bitmap is None:
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось декодировать изображение!"))
                        return

                    target_dir = File(self._temp_dir_path, "images")
                    if not target_dir.exists(): target_dir.mkdirs()
                    
                    target_file_name = f"custom_{file_type}_{uuid.uuid4()}.png"
                    target_file = File(target_dir, target_file_name)
                    
                    output_stream = FileOutputStream(target_file)
                    bitmap.compress(Bitmap.CompressFormat.PNG, 100, output_stream)
                    output_stream.flush()
                    bitmap.recycle()
                    
                    target_path = target_file.getAbsolutePath()
                    
                    if file_type == 'bg':
                        self.set_setting("bg_custom_path", target_path)
                        self.set_setting("bg_use_custom", True)
                        run_on_ui_thread(lambda: BulletinHelper.show_success("Фон обновлён"))
                    elif file_type == 'avatar':
                        self.set_setting("avatar_custom_path", target_path)
                        run_on_ui_thread(lambda: BulletinHelper.show_success("Аватар обновлён"))
                        
                except Exception as e:
                    qlog(f"Image decode error: {e}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка обработки изображения"))
                    
            self.refresh_settings()
        except Exception as e:
            qlog(f"File handle error ({file_type}): {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка при обработке файла!"))
        finally:
            if input_stream:
                try: input_stream.close()
                except: pass
            if output_stream:
                try: output_stream.close()
                except: pass

    def refresh_settings(self, *args):
        def refresher():
            try:
                from android_utils import R as RunnableArg 
                fragment = get_last_fragment()
                listView = None
                
                if fragment:
                    cls_name = str(fragment.getClass().getName())
                    if "PluginSettingsActivity" in cls_name:
                        listView = get_private_field(fragment, "listView")

                if not listView:
                    PluginsController.getInstance().loadPluginSettings(self.id)
                    return

                listView.animate()\
                    .alpha(0.0)\
                    .setDuration(80)\
                    .setInterpolator(AccelerateDecelerateInterpolator())\
                    .withEndAction(RunnableArg(lambda: self._on_fade_out_complete(listView)))\
                    .start()

            except Exception:
                PluginsController.getInstance().loadPluginSettings(self.id)

        run_on_ui_thread(refresher)

    def _on_fade_out_complete(self, listView):
        try:
            from android_utils import R as RunnableArg
            from android.view.animation import DecelerateInterpolator
            
            PluginsController.getInstance().loadPluginSettings(self.id)
            
            def start_fade_in():
                try:
                    listView.setAlpha(0.0)
                    listView.setTranslationY(20.0)
                    listView.animate()\
                        .alpha(1.0)\
                        .translationY(0.0)\
                        .setDuration(180)\
                        .setInterpolator(DecelerateInterpolator())\
                        .start()
                except: pass

            Handler(Looper.getMainLooper()).postDelayed(RunnableArg(start_fade_in), 50)

        except Exception: pass

    def get_attach_label(self, t):
        mapping = {
            1: "attach_label_photo",
            2: "attach_label_voice",
            3: "attach_label_video",
            4: "attach_label_geo",
            5: "attach_label_round",
            8: "attach_label_gif",
            9: "attach_label_file",
            10: "attach_label_date",
            11: "attach_label_photo",
            12: "attach_label_contact",
            13: "attach_label_sticker",
            14: "attach_label_audio",
            15: "attach_label_sticker_anim",
            16: "attach_label_call",
            17: "attach_label_poll",
            21: "attach_label_photo",
            23: "attach_label_story",
            24: "attach_label_story_mention",
            25: "attach_label_gift"
        }
        
        settings_key = mapping.get(t)
        
        default_key = f"ATTACH_TYPE_{t}"
        default_label = LocalizationManager.get_string(default_key)
        
        fallback_label = self.get_setting("attach_label_none", "[вложение]")

        if default_label == default_key:
            actual_default = fallback_label
        else:
            actual_default = default_label

        if not settings_key:
            return actual_default
            
        return self.get_setting(settings_key, actual_default)

    def on_send_message_hook(self, account, params) -> HookStrategy:
        if params.message is None or not isinstance(params.message, str):
            return HookResult()

        message_text = params.message.strip()
        font_index = self.get_setting("font", 0)
        layout_index = self.get_setting("layout", 1)
        fixed_width = self.get_setting("fixed_width", True)
        
        custom_bg_path = self.get_setting("bg_custom_path", "")
        custom_avatar_path = self.get_setting("avatar_custom_path", "")
        is_bg_forced_by_setting = self.get_setting("bg_use_custom", False)
        
        q_cmd = self.get_setting("q_default", ".q").strip().lower()
        qf_cmd = self.get_setting("q_force_bg", ".qb").strip().lower()
        qc_cmd = self.get_setting("q_force_ava", ".qa").strip().lower()
        qm_cmd = self.get_setting("q_force_both", ".qm").strip().lower()
        
        parts_all = message_text.split(" ", 1)
        cmd_token = parts_all[0].lower()
        rest_after_cmd = parts_all[1].strip() if len(parts_all) > 1 else ""

        is_quote = False
        force_bg = is_bg_forced_by_setting
        force_av = False
        override_author = None
        
        if cmd_token == q_cmd:
            is_quote = True
            override_author = rest_after_cmd
        elif cmd_token == qf_cmd:
            is_quote = True
            force_bg = True
            override_author = rest_after_cmd
        elif cmd_token == qc_cmd:
            is_quote = True
            force_av = True
            override_author = rest_after_cmd
        elif cmd_token == qm_cmd:
            is_quote = True
            force_bg = True
            force_av = True
            override_author = rest_after_cmd
        
        if is_quote:
            qlog(f"[CMD] Quote detected: {cmd_token} | Args: '{rest_after_cmd}' | ForceBG: {force_bg} | ForceAva: {force_av}")
            try:
                if force_bg and not (custom_bg_path and os.path.exists(custom_bg_path)):
                    qlog("[ERROR] Custom BG forced but file missing")
                    BulletinHelper.show_error("⚠️ Вы не выбрали кастомный фон! (Настройки -> Фон -> Выбрать)")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                if force_av and not (custom_avatar_path and os.path.exists(custom_avatar_path)):
                    qlog("[ERROR] Custom Avatar forced but file missing")
                    BulletinHelper.show_error("⚠️ Вы не выбрали кастомную аватарку! (Настройки -> Аватар -> Кастом)")
                    return HookResult(strategy=HookStrategy.CANCEL)

                if params.replyToMsg is None:
                    qlog("[ERROR] No reply message")
                    BulletinHelper.show_error("⚠️ Ты забыл реплайнуть сообщение!")
                    return HookResult(strategy=HookStrategy.CANCEL)
                    
                self._increment_stat("quotify_stats_total")
                self._increment_stat("quotify_stats_normal")
                if cmd_token == q_cmd: self._increment_stat("stats_cmd_q")
                elif cmd_token == qf_cmd: self._increment_stat("stats_cmd_qf")
                elif cmd_token == qc_cmd: self._increment_stat("stats_cmd_qc")
                elif cmd_token == qm_cmd: self._increment_stat("stats_cmd_qm")
                
                quote = QuoteManager(params, font_index, layout_index, fixed_width, self, custom_bg_path, custom_avatar_path, force_bg, force_av, search_query=override_author)
                quote.generate_quote()
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                qlog(f"Quote error: {e}", error=e)
                BulletinHelper.show_error("⛔ Произошла ошибка в коде плагина")
                return HookResult(strategy=HookStrategy.CANCEL)

        fq_cmd = self.get_setting("fq_default", ".fq").strip().lower()
        fqf_cmd = self.get_setting("fq_force_bg", ".fqb").strip().lower()
        fqc_cmd = self.get_setting("fq_force_ava", ".fqa").strip().lower()
        fqm_cmd = self.get_setting("fq_force_both", ".fqm").strip().lower()

        is_fake = False
        force_bg_fake = is_bg_forced_by_setting
        force_av_fake = False

        if cmd_token == fq_cmd:
            is_fake = True
        elif cmd_token == fqf_cmd:
            is_fake = True
            force_bg_fake = True
        elif cmd_token == fqc_cmd:
            is_fake = True
            force_av_fake = True
        elif cmd_token == fqm_cmd:
            is_fake = True
            force_bg_fake = True
            force_av_fake = True

        if is_fake:
            qlog(f"[CMD] Fake Quote detected: {cmd_token} | ForceBG: {force_bg_fake} | ForceAva: {force_av_fake}")
            if force_bg_fake and not (custom_bg_path and os.path.exists(custom_bg_path)):
                BulletinHelper.show_error("⚠️ Вы не выбрали кастомный фон! (Настройки -> Фон -> Выбрать)")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            if force_av_fake and not (custom_avatar_path and os.path.exists(custom_avatar_path)):
                BulletinHelper.show_error("⚠️ Вы не выбрали кастомную аватарку! (Настройки -> Аватар -> Кастом)")
                return HookResult(strategy=HookStrategy.CANCEL)

            fake_text = rest_after_cmd
            if not fake_text:
                qlog("[WARN] Fake quote text empty")
                BulletinHelper.show_error("⚠️ Укажи текст после команды")
                return HookResult(strategy=HookStrategy.CANCEL)
                
            sep = self.get_setting("fake_name_separator", DEFAULT_FAKE_NAME_SEPARATOR)
                
            override_author = None
            search_query = None

            if sep and sep in fake_text:
                text_part, name_part = fake_text.rsplit(sep, 1)
                fake_text = text_part.strip()
                search_query = name_part.strip()
                qlog(f"[FAKE] Parsed | Text: {len(fake_text)} chars | Search Query: {search_query}")
                    
            try:
                self._increment_stat("quotify_stats_total")
                self._increment_stat("quotify_stats_fake")
                if cmd_token == fq_cmd: self._increment_stat("stats_cmd_fq")
                elif cmd_token == fqf_cmd: self._increment_stat("stats_cmd_fqf")
                elif cmd_token == fqc_cmd: self._increment_stat("stats_cmd_fqc")
                elif cmd_token == fqm_cmd: self._increment_stat("stats_cmd_fqm")

                quote = QuoteManager(params, font_index, layout_index, fixed_width, self, custom_bg_path, custom_avatar_path, force_bg_fake, force_av_fake, override_author_name=override_author, search_query=search_query)
                quote.generate_fake_quote(fake_text)
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                qlog(f"Fake quote error: {e}", error=e)
                BulletinHelper.show_error("⛔ Произошла ошибка в коде плагина")
                return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()

    def on_plugin_unload(self):
        self._rm()
        if self.tmp and os.path.exists(self.tmp): shutil.rmtree(self.tmp, ignore_errors=True)
        try:
            EmojiRenderer._cache.clear()
        except:
            pass

plugin_instance = QuotifyForkPlugin()