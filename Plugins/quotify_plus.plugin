from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook, MenuItemData, MenuItemType
from ui.settings import Header, Input, Divider, Switch, Selector, Text
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from java import dynamic_proxy
from java.io import File, FileOutputStream, ByteArrayOutputStream, FileInputStream
from java.util import Locale, ArrayList
from java.lang import Integer, Long
from java.lang import Class as JClass
from client_utils import send_message, get_send_messages_helper, run_on_queue, get_last_fragment, send_request, get_user_config, RequestCallback, get_messages_controller
from hook_utils import find_class, get_private_field
from android.graphics.drawable import GradientDrawable
from android.view.animation import DecelerateInterpolator, AccelerateDecelerateInterpolator
from android.content import Intent, Context, ClipData, ClipboardManager
from android.os import Handler, Looper, Environment
from android.graphics import Bitmap, BitmapFactory, Canvas, Paint, Typeface, Rect as AndroidRect, Color
from android.media import MediaMetadataRetriever
from android_utils import run_on_ui_thread, log
from android.provider import MediaStore
from android.util import TypedValue
from android.app import Activity
from android.net import Uri
from android.widget import TextView, LinearLayout, FrameLayout
from android.view import View, Gravity, MotionEvent, HapticFeedbackConstants
from android.graphics import Canvas, Paint, Typeface, Rect as AndroidRect
from android.text import TextPaint
from com.exteragram.messenger.plugins import PluginsController
from org.telegram.messenger import FileLoader, UserConfig, ImageLocation, MessageObject, ApplicationLoader, AndroidUtilities, ImageLoader, Emoji, MediaDataController
from org.telegram.ui.Components import RLottieDrawable, LayoutHelper, BackupImageView
from org.telegram.ui.Components.Premium import StarParticlesView
from org.telegram.ui.ActionBar import Theme
from org.telegram.tgnet import TLRPC
from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageOps, ImageEnhance
import threading
import traceback
import requests
import datetime
import weakref
import random
import base64
import uuid
import math
import time
import json
import re
import os
import io

__requirements__ = "pillow"
__id__ = "quotify_plus"
__name__ = "[FORK] Quotify+"
__author__ = "@mur_live & @Raitorinkus (Original authors: @TailedPlugins & @KangelPlugins)"
__min_version__ = "12.1.1"
__icon__ = "Quotify_Plus/1"
__version__ = "2.0.0"
__description__ = """
Улучшенная версия Quotify, позволяющая делать стильные цитаты в виде картинок.

Команды использования:
.q [автор] - обычная цитата
.fq [текст] | [автор] - обычная фейк цитата

Краткая справка:
[текст] (обязательно): Текст цитаты
[автор] (необязательно): Юзернейм, номер телефона, ID
"""

FILE_PICK_REQUEST_CODE = 2040
PICK_BG_REQUEST_CODE = 2041
PICK_AVA_REQUEST_CODE = 2042
IMPORT_SETTINGS_CODE = 2043
FALLBACK_AVATAR_USERNAME = "NekogramAPKs" 
DEFAULT_FAKE_NAME_SEPARATOR = "|"
CONFIG_FILE_EXTENSION = ".qtfp"
CONFIG_VERSION = 1

def copy_error_to_clipboard(error_msg):
    try:
        if not plugin_instance.get_setting("copy_error_to_clipboard", True):
            return
        ctx = ApplicationLoader.applicationContext
        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
        clip = ClipData.newPlainText("Quotify Error", str(error_msg))
        clipboard.setPrimaryClip(clip)
        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка скопирована в буфер!"))
    except Exception:
        pass
        
def qlog(message, error=None):
    if error:
        tb = traceback.format_exc()
        full_msg = f"{message}\n[ERROR]: {str(error)}\n[TRACEBACK]:\n{tb}"
    else:
        full_msg = message
    log(f"[Quotify_Plus] {full_msg}")
    DebugLogger.log(full_msg, is_error=bool(error))

class DebugLogger:
    logs = []
    enabled = False
    last_log_content = None

    @staticmethod
    def init(plugin_instance=None):
        if plugin_instance:
             DebugLogger.enabled = plugin_instance.get_setting("debug_logging", False)
        else:
            DebugLogger.enabled = False

    @staticmethod
    def log(message, is_error=False):
        if not DebugLogger.enabled:
            return
        try:
            timestamp = datetime.datetime.now().strftime("%d.%m.%Y %H:%M:%S")
            prefix = "[ERROR] " if is_error else "[INFO] "
            log_entry = f"[{timestamp}] {prefix}{message}"
            DebugLogger.logs.append(log_entry)
            if len(DebugLogger.logs) > 500:
                DebugLogger.logs.pop(0)
        except:
            pass

    @staticmethod
    def save_logs(export_dir, is_error=False):
        try:
            if not DebugLogger.logs:
                return None
            
            if not os.path.exists(export_dir):
                os.makedirs(export_dir)
                
            prefix = "quotify_error_log_" if is_error else "quotify_log_"
            filename = f"{prefix}{datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')}.txt"
            file_path = os.path.join(export_dir, filename)
            
            with open(file_path, "w", encoding="utf-8") as f:
                f.write("\n".join(DebugLogger.logs))
                
            return file_path
        except Exception as e:
            log(f"Failed to save logs: {e}")
            return None

    @staticmethod
    def clear_logs():
        DebugLogger.logs.clear()
        DebugLogger.last_log_content = None

class LocalizationManager:
    language = "en"
    strings = {
        "ru": {
            "FORGOT_TO_REPLY": "⚠️ Ты забыл реплайнуть сообщение!",
            "TLRPC_USERPHOTOS_ERROR": "⛔ Произошла ошибка при попытке получить аву пользователя!",
            "TLRPC_GETFILE_ERROR": "⛔ Произошла ошибка при скачивании авы пользователя!",
            "PLUGIN_ERROR": "⛔ Произошла ошибка в коде плагина",
            "USERPHOTOS_ERROR": "⛔ Произошла ошибка в коde получения изображения пользователя!",
            "GETFILE_ERROR": "⛔ Произошла ошибка в коде скачки изображения пользователя!",
            "ERROR_NO_ACTIVITY": "⛔ Не удалось получить текущий экран!",
            "ERROR_FILE_PICKER": "⛔ Ошибка при открытии выбора файла!",
            "ERROR_INVALID_FONT": "⛔ Файл не является шрифтом (.ttf/.otf)!",
            "ERROR_OPEN_FILE": "⛔ Не удалось открыть файл!",
            "ERROR_PROCESS_FILE": "⛔ Ошибка при обработке файла!",
            "FONT_UPLOADED": "✅ Шрифт '{}' успешно загружен!",
            "SELECT_FONT_FILE": "Выберите файл шрифта",
            "SETTINGS_TITLE": "Настройки плагина Quotify Fork",
            "FAKE_QUOTE_EMPTY": "⚠️ Укажи текст после команды",
            "SETTINGS_LAYOUT": "Стиль цитаты",
            "SETTINGS_LAYOUT_HORIZONTAL": "Горизонтальная",
            "SETTINGS_LAYOUT_VERTICAL": "Вертикальная",
            "SETTINGS_FONT": "Шрифт",
            "SETTINGS_QUOTE_FONT_SIZE": "Размер шрифта цитаты",
            "SETTINGS_AUTHOR_FONT_SIZE": "Размер шрифта автора",
            "SETTINGS_FONT_SIZE_SUB": "Введите размер шрифта (20-60)",
            "SETTINGS_TEXT_COLOR": "Цвет текста",
            "TEXT_COLOR_WHITE": "Белый",
            "TEXT_COLOR_BLACK": "Чёрный",
            "TEXT_COLOR_CUSTOM": "Пользовательский",
            "SETTINGS_CUSTOM_TEXT_COLOR": "Пользовательский цвет текста",
            "SETTINGS_CUSTOM_TEXT_COLOR_SUB": "Введите HEX-код цвета (например, #B4B4B4)",
            "SETTINGS_RANDOM_BG": "Случайный цвет фона",
            "SETTINGS_RANDOM_BG_SUB": "Использовать случайный цвет фона, если аватар недоступен",
            "SETTINGS_CUSTOM_BG_COLOR": "Пользовательский цвет фона",
            "SETTINGS_CUSTOM_BG_COLOR_SUB": "Введите HEX-код цвета (например, #000000)",
            "SETTINGS_SHOW_AVATAR": "Показывать аватар",
            "SETTINGS_SHOW_AVATAR_SUB": "Показывать аватар или заглушку в цитате",
            "SETTINGS_AVATAR_SIZE": "Размер аватара",
            "SETTINGS_AVATAR_SIZE_SUB": "Размер аватара в пикселях (50-400)",
            "SETTINGS_AVATAR_POSITION": "Положение аватара",
            "SETTINGS_AVATAR_POSITION_LEFT": "Слева",
            "SETTINGS_AVATAR_POSITION_RIGHT": "Справа",
            "SETTINGS_AVATAR_SHAPE": "Форма аватара",
            "SETTINGS_AVATAR_SHAPE_CIRCLE": "Круглая",
            "SETTINGS_AVATAR_SHAPE_SQUARE": "Квадратная",
            "SETTINGS_AVATAR_SHAPE_ROUNDED": "Скругленная",
            "SETTINGS_AVATAR_ROUNDING": "Скругление аватара",
            "SETTINGS_AVATAR_ROUNDING_SUB": "Радиус скругления (0-100)",
            "SETTINGS_BG_STYLE": "Стиль фона",
            "SETTINGS_BG_STYLE_BLUR": "Блюр",
            "SETTINGS_BG_STYLE_GLASS": "Мокрое стекло",
            "SETTINGS_BG_STYLE_OLD_TV": "Старый TV",
            "SETTINGS_BG_STYLE_PIXEL": "Пиксели",
            "SETTINGS_BG_STYLE_SOLID": "Сплошной цвет",
            "SETTINGS_BG_STYLE_GRADIENT": "Градиент",
            "SETTINGS_BG_STYLE_WAVES": "Волны",
            "SETTINGS_USE_BG_FILTERS": "Фильтры фона",
            "SETTINGS_USE_BG_FILTERS_SUB": "Применять фильтры к фону аватара",
            "SETTINGS_BG_FILTER": "Фильтр фона",
            "SETTINGS_BG_FILTER_NONE": "Без фильтра",
            "SETTINGS_BG_FILTER_GRAYSCALE": "Чёрно-белый",
            "SETTINGS_BG_FILTER_SEPIA": "Сепия",
            "SETTINGS_BG_FILTER_INVERT": "Инверсия",
            "SETTINGS_BG_FILTER_POSTERIZE": "Постеризация",
            "SETTINGS_BG_FILTER_COLORIZE": "Окрашивание",
            "SETTINGS_BG_FILTER_CONTRAST": "Контраст",
            "SETTINGS_BG_FILTER_EMBOSS": "Тиснение",
            "UPLOAD_FONT": "Загрузить файл шрифта (.ttf/.otf)",
            "CURRENT_FONT": "Текущий шрифт: {}",
            "NONE": "Нет",
            "SETTINGS_CUSTOM_FONT_FAQ": "Как использовать кастомные шрифты",
            "SETTINGS_CUSTOM_FONT_URL": "Ссылка на кастомный шрифт (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Вставьте прямую ссылку на .ttf файл.\nПример: https://example.com/font.ttf",
            "SETTINGS_FIXED_WIDTH": "Фиксированная ширина",
            "SETTINGS_GFONTS_QUERY": "Поиск Google Fonts",
            "SETTINGS_GFONTS_SEARCH": "Найти шрифт в Google Fonts",
            "GFONTS_NO_RESULTS": "Ничего не найдено",
            "GFONTS_ONLY_TTF": "Доступны только варианты .ttf/.otf",
            "GFONTS_ERROR": "Ошибка Google Fonts",
            "ATTACH_TYPE_1": "[фото]",
            "ATTACH_TYPE_2": "[голосовое]",
            "ATTACH_TYPE_3": "[видео]",
            "ATTACH_TYPE_4": "[гео]",
            "ATTACH_TYPE_5": "[кружок]",
            "ATTACH_TYPE_6": "[загрузка]",
            "ATTACH_TYPE_8": "[гиф]",
            "ATTACH_TYPE_9": "[файл]",
            "ATTACH_TYPE_10": "[дата]",
            "ATTACH_TYPE_11": "[фото]",
            "ATTACH_TYPE_12": "[контакт]",
            "ATTACH_TYPE_13": "[стикер]",
            "ATTACH_TYPE_14": "[музыка]",
            "ATTACH_TYPE_15": "[премиум стикер]",
            "ATTACH_TYPE_16": "[звонок]",
            "ATTACH_TYPE_17": "[опрос]",
            "ATTACH_TYPE_18": "[премиум]",
            "ATTACH_TYPE_20": "[превью]",
            "ATTACH_TYPE_21": "[предложение фото]",
            "ATTACH_TYPE_22": "[задний фон]",
            "ATTACH_TYPE_23": "[история]",
            "ATTACH_TYPE_24": "[упоминание в истории]",
            "ATTACH_TYPE_25": "[премиум]",
            "ATTACH_TYPE_26": "[раздача]",
            "ATTACH_TYPE_27": "[зашёл в канал]",
            "ATTACH_TYPE_28": "[результат раздачи]",
            "ATTACH_TYPE_29": "[платное вложение]",
            "ATTACH_TYPE_30": "[звёзды]",
            "IN_REPLY": "[в ответ {0}]",
            "TLRPC_GETCHANNELS_ERROR": "⛔ Произошла ошибка при получении данных чата!",
            "SETTINGS_BG_USE_CUSTOM": "Использовать кастомный фон",
            "SETTINGS_PICK_BG": "Выбрать фон из галереи",
            "SETTINGS_CLEAR_BG": "Сбросить кастомный фон",
            "PICK_BG_ERROR": "Не удалось выбрать изображение",
            "PICK_BG_SUCCESS": "Фон обновлён",
            "IMAGE_UPLOADED": "✅ Изображение '{}' успешно загружено!",
            "CLEAR_BG_SUCCESS": "Фон сброшен",
            "AVATAR_SETTINGS_TITLE": "Настройка аватарки",
            "SETTINGS_AVATAR_USE_CUSTOM": "Использовать кастомную аву",
            "SETTINGS_PICK_AVATAR": "Выбрать аватар из галереи",
            "SETTINGS_CLEAR_AVATAR": "Сбросить кастомную аватарку",
            "PICK_AVATAR_SUCCESS": "Аватар обновлён",
            "CLEAR_AVATAR_SUCCESS": "Аватар сброшен"
        },
        "en": {
            "FORGOT_TO_REPLY": "⚠️ You forgot to reply to message!",
            "TLRPC_USERPHOTOS_ERROR": "⛔ An error occurred while trying to fetch the user's avatar!",
            "TLRPC_GETFILE_ERROR": "⛔ An error occurred while downloading avatar!",
            "PLUGIN_ERROR": "⛔ An error occurred in plugin code!",
            "USERPHOTOS_ERROR": "⛔ An error occurred in user image retrieval code!",
            "GETFILE_ERROR": "⛔ An error occurred in user image download code!",
            "ERROR_NO_ACTIVITY": "⛔ Failed to get current activity!",
            "ERROR_FILE_PICKER": "⛔ Error opening file picker!",
            "ERROR_INVALID_FONT": "⛔ File is not a font (.ttf/.otf)!",
            "ERROR_OPEN_FILE": "⛔ Failed to open file!",
            "ERROR_PROCESS_FILE": "⛔ Error processing file!",
            "FONT_UPLOADED": "✅ Font '{}' uploaded successfully!",
            "SELECT_FONT_FILE": "Select font file",
            "SETTINGS_TITLE": "Quotify Fork Plugin Settings",
            "FAKE_QUOTE_EMPTY": "⚠️ Specify text after the command",
            "SETTINGS_LAYOUT": "Quote style",
            "SETTINGS_LAYOUT_HORIZONTAL": "Horizontal",
            "SETTINGS_LAYOUT_VERTICAL": "Vertical",
            "SETTINGS_FONT": "Font",
            "SETTINGS_QUOTE_FONT_SIZE": "Quote font size",
            "SETTINGS_AUTHOR_FONT_SIZE": "Author font size",
            "SETTINGS_FONT_SIZE_SUB": "Enter font size (20-60)",
            "SETTINGS_TEXT_COLOR": "Text color",
            "TEXT_COLOR_WHITE": "White",
            "TEXT_COLOR_BLACK": "Black",
            "TEXT_COLOR_CUSTOM": "Custom",
            "SETTINGS_CUSTOM_TEXT_COLOR": "Custom text color",
            "SETTINGS_CUSTOM_TEXT_COLOR_SUB": "Enter HEX color code (e.g., #B4B4B4)",
            "SETTINGS_RANDOM_BG": "Random background color",
            "SETTINGS_RANDOM_BG_SUB": "Use random background color if avatar is unavailable",
            "SETTINGS_CUSTOM_BG_COLOR": "Custom background color",
            "SETTINGS_CUSTOM_BG_COLOR_SUB": "Enter HEX color code (e.g., #000000)",
            "SETTINGS_SHOW_AVATAR": "Show avatar",
            "SETTINGS_SHOW_AVATAR_SUB": "Show avatar or placeholder in quote",
            "SETTINGS_AVATAR_SIZE": "Avatar size",
            "SETTINGS_AVATAR_SIZE_SUB": "Avatar size in pixels (50-400)",
            "SETTINGS_AVATAR_POSITION": "Avatar position",
            "SETTINGS_AVATAR_POSITION_LEFT": "Left",
            "SETTINGS_AVATAR_POSITION_RIGHT": "Right",
            "SETTINGS_AVATAR_SHAPE": "Avatar shape",
            "SETTINGS_AVATAR_SHAPE_CIRCLE": "Circle",
            "SETTINGS_AVATAR_SHAPE_SQUARE": "Square",
            "SETTINGS_AVATAR_SHAPE_ROUNDED": "Rounded",
            "SETTINGS_AVATAR_ROUNDING": "Avatar rounding",
            "SETTINGS_AVATAR_ROUNDING_SUB": "Rounding radius (0-100)",
            "SETTINGS_BG_STYLE": "Background style",
            "SETTINGS_BG_STYLE_BLUR": "Blur",
            "SETTINGS_BG_STYLE_GLASS": "Wet glass",
            "SETTINGS_BG_STYLE_OLD_TV": "Old TV",
            "SETTINGS_BG_STYLE_PIXEL": "Pixel",
            "SETTINGS_BG_STYLE_SOLID": "Solid color",
            "SETTINGS_BG_STYLE_GRADIENT": "Gradient",
            "SETTINGS_BG_STYLE_WAVES": "Waves",
            "SETTINGS_USE_BG_FILTERS": "Background filters",
            "SETTINGS_USE_BG_FILTERS_SUB": "Apply filters to avatar background",
            "SETTINGS_BG_FILTER": "Background filter",
            "SETTINGS_BG_FILTER_NONE": "No filter",
            "SETTINGS_BG_FILTER_GRAYSCALE": "Grayscale",
            "SETTINGS_BG_FILTER_SEPIA": "Sepia",
            "SETTINGS_BG_FILTER_INVERT": "Invert",
            "SETTINGS_BG_FILTER_POSTERIZE": "Posterize",
            "SETTINGS_BG_FILTER_COLORIZE": "Colorize",
            "SETTINGS_BG_FILTER_CONTRAST": "Contrast",
            "SETTINGS_BG_FILTER_EMBOSS": "Emboss",
            "UPLOAD_FONT": "Upload font file (.ttf/.otf)",
            "CURRENT_FONT": "Current font: {}",
            "NONE": "None",
            "SETTINGS_CUSTOM_FONT_FAQ": "How to use custom fonts",
            "SETTINGS_CUSTOM_FONT_URL": "Custom font URL (.ttf)",
            "SETTINGS_CUSTOM_FONT_URL_SUB": "Paste a direct link to a .ttf file.\nExample: https://example.com/font.ttf",
            "SETTINGS_FIXED_WIDTH": "Fixed width",
            "SETTINGS_GFONTS_QUERY": "Google Fonts search",
            "SETTINGS_GFONTS_SEARCH": "Search in Google Fonts",
            "GFONTS_NO_RESULTS": "Nothing found",
            "GFONTS_ONLY_TTF": "Only .ttf/.otf variants are available",
            "GFONTS_ERROR": "Google Fonts error",
            "ATTACH_TYPE_1": "[photo]",
            "ATTACH_TYPE_2": "[voice message]",
            "ATTACH_TYPE_3": "[video]",
            "ATTACH_TYPE_4": "[geo]",
            "ATTACH_TYPE_5": "[round message]",
            "ATTACH_TYPE_6": "[upload]",
            "ATTACH_TYPE_8": "[gif]",
            "ATTACH_TYPE_9": "[file]",
            "ATTACH_TYPE_10": "[date]",
            "ATTACH_TYPE_11": "[photo]",
            "ATTACH_TYPE_12": "[contact]",
            "ATTACH_TYPE_13": "[sticker]",
            "ATTACH_TYPE_14": "[music]",
            "ATTACH_TYPE_15": "[animated sticker]",
            "ATTACH_TYPE_16": "[call]",
            "ATTACH_TYPE_17": "[poll]",
            "ATTACH_TYPE_18": "[premium]",
            "ATTACH_TYPE_20": "[preview]",
            "ATTACH_TYPE_21": "[photo suggestion]",
            "ATTACH_TYPE_22": "[background]",
            "ATTACH_TYPE_23": "[story]",
            "ATTACH_TYPE_24": "[story mention]",
            "ATTACH_TYPE_25": "[premium]",
            "ATTACH_TYPE_26": "[giveaway]",
            "ATTACH_TYPE_27": "[joined channel]",
            "ATTACH_TYPE_28": "[giveaway result]",
            "ATTACH_TYPE_29": "[paid attachment]",
            "ATTACH_TYPE_30": "[stars]",
            "IN_REPLY": "[in reply to {0}]",
            "TLRPC_GETCHANNELS_ERROR": "⛔ An error occurred while fetching chat data!",
            "SETTINGS_BG_USE_CUSTOM": "Use custom background",
            "SETTINGS_PICK_BG": "Pick background from gallery",
            "SETTINGS_CLEAR_BG": "Clear custom background",
            "PICK_BG_ERROR": "Failed to pick image",
            "PICK_BG_SUCCESS": "Background updated",
            "IMAGE_UPLOADED": "✅ Image '{}' uploaded successfully!",
            "CLEAR_BG_SUCCESS": "Background cleared",
            "AVATAR_SETTINGS_TITLE": "Avatar settings",
            "SETTINGS_AVATAR_USE_CUSTOM": "Use custom avatar",
            "SETTINGS_PICK_AVATAR": "Pick avatar from gallery",
            "SETTINGS_CLEAR_AVATAR": "Clear custom avatar",
            "PICK_AVATAR_SUCCESS": "Avatar updated",
            "CLEAR_AVATAR_SUCCESS": "Avatar cleared"
        }
    }

    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager.strings else "en"

    @staticmethod
    def get_string(string, *args):
        try:
            locali = LocalizationManager.strings.get(LocalizationManager.language, LocalizationManager.strings["en"]).get(string, string)
            return locali.format(*args) if args else locali
        except Exception:
            return string

class FontManager:
    fonts = []
    custom_font_url = ""
    custom_font_path = None
    last_custom_url = None
    
    @staticmethod
    def init():
        FontManager.fonts = [
            Font("Системный", None, custom_path="/system/fonts/Roboto-Regular.ttf"),
            Font("Hack", "https://github.com/source-foundry/Hack/raw/master/build/ttf/Hack-Bold.ttf"),
            Font("Zpix", "https://github.com/Ar4ikTrirtyFour/windose20/raw/main/fonts/zpix.ttf"),
            Font("Times New Roman", "https://github.com/misuchiru03/font-times-new-roman/raw/master/Times%20New%20Roman.ttf"),
            Font("Bounded Regular", "https://github.com/churkinvlad/Bounded/raw/refs/heads/main/OTF/Bounded-Regular.otf"),
            Font("Кастомный шрифт", None)
        ]
        threading.Thread(target=FontManager._download_fonts, daemon=True).start()

    @staticmethod
    def _download_fonts():
        for font in FontManager.fonts:
            if font.download_uri and not font.exists():
                try:
                    font.download()
                except Exception as e:
                    qlog(f"Ошибка загрузки шрифта {font.name}: {e}")
    
    @staticmethod
    def get(index, plugin=None):
        if index == 5:
            if plugin:
                custom_url = plugin.get_setting("custom_font_url", "").strip()
                custom_path = plugin.get_setting("custom_font_path", "").strip()
                if custom_url:
                    if FontManager.last_custom_url != custom_url:
                        temp_dir = Filesystem.get_temp_dir()
                        font_path = Filesystem.get_absolute_path(temp_dir, "custom_font.ttf")
                        try:
                            response = requests.get(custom_url, timeout=15)
                            with open(font_path, 'wb') as f:
                                f.write(response.content)
                            FontManager.last_custom_url = custom_url
                            FontManager.custom_font_path = font_path
                        except Exception as e:
                            qlog(f"Ошибка загрузки кастомного шрифта: {e}")
                            return FontManager.fonts[0]
                    return Font("Кастомный шрифт", None, custom_path=FontManager.custom_font_path)
                elif custom_path and os.path.exists(custom_path):
                    return Font("Кастомный шрифт", None, custom_path=custom_path)
            return FontManager.fonts[0]
        if index >= len(FontManager.fonts):
            return FontManager.fonts[0]
        return FontManager.fonts[index]

    @staticmethod
    def get_fonts_names():
        return [font.name for font in FontManager.fonts]

class Font:
    def __init__(self, name, download_uri, custom_path=None):
        self.name = name
        self.download_uri = download_uri
        self.custom_path = custom_path
    
    def get_path(self):
        if self.custom_path and os.path.exists(self.custom_path):
            return self.custom_path
        temp_dir = Filesystem.get_temp_dir()
        if not temp_dir:
            return "/system/fonts/DroidSans.ttf"
        fonts_dir = os.path.join(temp_dir, "fonts")
        if not os.path.exists(fonts_dir):
            os.makedirs(fonts_dir)
        file_name = self.name.replace(" ", "_") + ".ttf"
        return os.path.join(fonts_dir, file_name)
    
    def exists(self):
        return os.path.exists(self.get_path())
    
    def download(self):
        if self.exists() or not self.download_uri:
            return
        font_path = self.get_path()
        try:
            response = requests.get(self.download_uri, timeout=15)
            response.raise_for_status()
            with open(font_path, 'wb') as file:
                file.write(response.content)
            qlog(f"Шрифт {self.name} загружен: {font_path}")
        except Exception as e:
            qlog(f"Ошибка загрузки {self.name}: {e}")

class Filesystem:
    @staticmethod
    def write_file(file_path, content):
        file_dir = os.path.dirname(file_path)
        if not os.path.exists(file_dir):
            os.makedirs(file_dir)
        with open(file_path, 'wb') as file:
            file.write(content)
    
    @staticmethod
    def get_absolute_path(dir, file_name):
        return os.path.join(dir, file_name)
    
    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            if not fixed_dir:
                return None
            temp_dir = os.path.join(fixed_dir.getAbsolutePath(), "quotify_fork")
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            return temp_dir
        except Exception:
            return None

class EmojiRenderer:
    _cache = {}

    @staticmethod
    def render_emoji_to_pil(emoji_char, size_px=64):
        cache_key = f"{emoji_char}_{size_px}"
        if cache_key in EmojiRenderer._cache:
            return EmojiRenderer._cache[cache_key]

        try:
            result_holder = [None]
            event = threading.Event()

            def run_render():
                try:
                    drawable = Emoji.getEmojiDrawable(emoji_char)
                    success = False
                    
                    if drawable:
                        bitmap = Bitmap.createBitmap(size_px, size_px, Bitmap.Config.ARGB_8888)
                        canvas = Canvas(bitmap)
                        pad = int(size_px * 0.05)
                        drawable.setBounds(pad, pad, size_px - pad, size_px - pad)
                        drawable.draw(canvas)
                        
                        cx, cy = size_px // 2, size_px // 2
                        if bitmap.getPixel(cx, cy) != 0 or \
                           bitmap.getPixel(cx, cy - 5) != 0 or \
                           bitmap.getPixel(cx, cy + 5) != 0:
                            result_holder[0] = bitmap
                            success = True
                        else:
                            bitmap.recycle()

                    if not success:
                        ctx = ApplicationLoader.applicationContext
                        tv = TextView(ctx)
                        tv.setText(emoji_char)
                        tv.setTextSize(0, float(size_px * 0.9))
                        tv.setTextColor(0xFF000000)
                        tv.setGravity(17)
                        tv.setIncludeFontPadding(False)
                        
                        tv.measure(
                            View.MeasureSpec.makeMeasureSpec(size_px, View.MeasureSpec.EXACTLY),
                            View.MeasureSpec.makeMeasureSpec(size_px, View.MeasureSpec.EXACTLY)
                        )
                        tv.layout(0, 0, size_px, size_px)
                        
                        bitmap_sys = Bitmap.createBitmap(size_px, size_px, Bitmap.Config.ARGB_8888)
                        canvas_sys = Canvas(bitmap_sys)
                        tv.draw(canvas_sys)
                        
                        result_holder[0] = bitmap_sys

                except Exception as e:
                    log(f"Emoji render inner error: {e}")
                finally:
                    event.set()

            run_on_ui_thread(run_render)
            event.wait(3.0)

            bitmap = result_holder[0]
            if not bitmap:
                return None

            stream = ByteArrayOutputStream()
            try:
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                py_bytes = bytes([b & 0xFF for b in stream.toByteArray()])
            finally:
                stream.close()
                bitmap.recycle()

            pil_img = Image.open(io.BytesIO(py_bytes)).convert("RGBA")
            EmojiRenderer._cache[cache_key] = pil_img
            return pil_img

        except Exception as e:
            qlog(f"Emoji render error for '{emoji_char}': {e}")
            return None

class PremiumEmojiRenderer:
    _cache = {}
    _docs_cache = {}
    _in_flight = {}
    _lock = None

    @staticmethod
    def _get_lock():
        if PremiumEmojiRenderer._lock is None:
            import threading
            PremiumEmojiRenderer._lock = threading.Lock()
        return PremiumEmojiRenderer._lock

    @staticmethod
    def prefetch_emojis_async(document_ids, size_px, on_done=None):
        import threading
        
        def run():
            try:
                from java.lang import Long
                import os
                from PIL import Image
                
                current_account = UserConfig.selectedAccount
                temp_dir = Filesystem.get_temp_dir()
                
                my_events = []
                fetch_list = []

                with PremiumEmojiRenderer._get_lock():
                    for doc_id in set(document_ids):
                        doc_id_long = Long(int(doc_id)).longValue()
                        cache_key = f"{doc_id_long}_{size_px}"
                        
                        if cache_key in PremiumEmojiRenderer._cache:
                            continue
                            
                        disk_cache_path = os.path.join(temp_dir, f"emoji_render_{cache_key}.png") if temp_dir else None
                        if disk_cache_path and os.path.exists(disk_cache_path):
                            try:
                                pil_img = Image.open(disk_cache_path).convert("RGBA")
                                PremiumEmojiRenderer._cache[cache_key] = pil_img
                                continue
                            except Exception:
                                pass
                        
                        if cache_key in PremiumEmojiRenderer._in_flight:
                            my_events.append(PremiumEmojiRenderer._in_flight[cache_key])
                        else:
                            ev = threading.Event()
                            PremiumEmojiRenderer._in_flight[cache_key] = ev
                            fetch_list.append((doc_id_long, cache_key, ev))

                for ev in my_events:
                    ev.wait(45.0)

                if not fetch_list:
                    return

                docs_map = {}
                still_missing = []

                for doc_id_long, cache_key, ev in fetch_list:
                    if doc_id_long in PremiumEmojiRenderer._docs_cache:
                        docs_map[doc_id_long] = PremiumEmojiRenderer._docs_cache[doc_id_long]
                    else:
                        try:
                            from org.telegram.ui.Components import AnimatedEmojiDrawable
                            doc = AnimatedEmojiDrawable.findDocument(current_account, doc_id_long)
                            if doc:
                                docs_map[doc_id_long] = doc
                                PremiumEmojiRenderer._docs_cache[doc_id_long] = doc
                            else:
                                still_missing.append(doc_id_long)
                        except Exception:
                            still_missing.append(doc_id_long)

                if still_missing:
                    try:
                        req = TLRPC.TL_messages_getCustomEmojiDocuments()
                        for doc_id_long in still_missing:
                            req.document_id.add(doc_id_long)

                        server_event = threading.Event()
                        server_result = []

                        def on_server_response(response, error):
                            if response:
                                try:
                                    items = getattr(response, 'objects', response)
                                    try:
                                        count = items.size()
                                        for i in range(count):
                                            server_result.append(items.get(i))
                                    except:
                                        for item in items:
                                            server_result.append(item)
                                except Exception:
                                    pass
                            server_event.set()

                        send_request(req, RequestCallback(on_server_response))
                        server_event.wait(15.0)

                        for doc in server_result:
                            docs_map[doc.id] = doc
                            PremiumEmojiRenderer._docs_cache[doc.id] = doc
                    except Exception:
                        pass

                file_loader = FileLoader.getInstance(current_account)

                for doc_id_long, cache_key, ev in fetch_list:
                    try:
                        doc = docs_map.get(doc_id_long)
                        if not doc:
                            continue

                        mime = str(getattr(doc, "mime_type", "") or "")
                        if "x-tgsticker" in mime: ext = "tgs"
                        elif "video/webm" in mime: ext = "webm"
                        else: ext = "webp"

                        file_path_obj = None
                        for try_ext in [ext, None]:
                            try:
                                p = file_loader.getPathToAttach(doc, try_ext, True)
                                if p and p.exists() and p.length() > 0:
                                    file_path_obj = p
                                    break
                            except Exception:
                                pass

                        if not file_path_obj or not file_path_obj.exists() or file_path_obj.length() == 0:
                            try:
                                loc = ImageLocation.getForDocument(doc)
                                if loc: file_loader.loadFile(loc, None, "webp", 0, 1)
                            except Exception: pass

                            try: file_loader.loadFile(doc, ext, 0, 1)
                            except Exception:
                                try: file_loader.loadFile(doc, None, 0, 1)
                                except Exception: pass

                            for _ in range(150):
                                try:
                                    p = file_loader.getPathToAttach(doc, True)
                                    if p and p.exists() and p.length() > 0:
                                        file_path_obj = p
                                        break
                                    p2 = file_loader.getPathToAttach(doc, ext, True)
                                    if p2 and p2.exists() and p2.length() > 0:
                                        file_path_obj = p2
                                        break
                                except Exception: pass
                                time.sleep(0.1)

                        if not file_path_obj or not file_path_obj.exists() or file_path_obj.length() == 0:
                            continue

                        abs_path = file_path_obj.getAbsolutePath()
                        actual_ext = os.path.splitext(abs_path)[1].lower().lstrip('.')
                        if actual_ext in ('tgs', 'webm', 'webp', 'jpg', 'jpeg', 'png'):
                            ext = actual_ext

                        thumb_path = None
                        if hasattr(doc, 'thumbs') and doc.thumbs:
                            for i in range(doc.thumbs.size()):
                                t = doc.thumbs.get(i)
                                if isinstance(t, TLRPC.TL_photoSize):
                                    try:
                                        tp = file_loader.getPathToAttach(t, True)
                                        if tp and tp.exists() and tp.length() > 0:
                                            thumb_path = tp.getAbsolutePath()
                                            break
                                    except Exception: pass

                        if thumb_path and ext in ('tgs', 'webm'):
                            abs_path = thumb_path
                            ext = 'webp'

                        bitmap = None
                        if ext == "tgs":
                            try:
                                render_size = size_px * 4
                                drawable = RLottieDrawable(File(abs_path), render_size, render_size, None, False, None, 0)
                                try: drawable.setAllowDecodeSingleFrame(True)
                                except Exception: pass
                                
                                bitmap = Bitmap.createBitmap(render_size, render_size, Bitmap.Config.ARGB_8888)
                                canvas = Canvas(bitmap)
                                drawable.setBounds(0, 0, render_size, render_size)
                                has_pixels = False
                                for _ in range(40):
                                    bitmap.eraseColor(0)
                                    drawable.draw(canvas)
                                    if bitmap.getPixel(render_size // 2, render_size // 2) != 0 or bitmap.getPixel(render_size // 3, render_size // 3) != 0:
                                        has_pixels = True
                                        break
                                    time.sleep(0.05)
                                if has_pixels:
                                    scaled = Bitmap.createScaledBitmap(bitmap, size_px, size_px, True)
                                    if scaled != bitmap:
                                        bitmap.recycle()
                                        bitmap = scaled
                                else:
                                    bitmap.recycle()
                                    bitmap = None
                                try: drawable.recycle(True)
                                except Exception: pass
                            except Exception:
                                bitmap = None
                        elif ext == "webm":
                            try:
                                retriever = MediaMetadataRetriever()
                                retriever.setDataSource(abs_path)
                                bitmap = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)
                                if bitmap is None:
                                    bitmap = retriever.getFrameAtTime()
                                retriever.release()
                                if bitmap:
                                    render_size = size_px * 4
                                    scaled_high = Bitmap.createScaledBitmap(bitmap, render_size, render_size, True)
                                    if scaled_high != bitmap:
                                        bitmap.recycle()
                                        bitmap = scaled_high
                                    scaled = Bitmap.createScaledBitmap(bitmap, size_px, size_px, True)
                                    if scaled != bitmap:
                                        bitmap.recycle()
                                        bitmap = scaled
                            except Exception:
                                bitmap = None
                        else:
                            try:
                                bitmap = BitmapFactory.decodeFile(abs_path)
                                if bitmap:
                                    render_size = size_px * 4
                                    scaled_high = Bitmap.createScaledBitmap(bitmap, render_size, render_size, True)
                                    if scaled_high != bitmap:
                                        bitmap.recycle()
                                        bitmap = scaled_high
                                    scaled = Bitmap.createScaledBitmap(bitmap, size_px, size_px, True)
                                    if scaled != bitmap:
                                        bitmap.recycle()
                                        bitmap = scaled
                            except Exception:
                                bitmap = None

                        if bitmap:
                            try:
                                stream = ByteArrayOutputStream()
                                bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                                py_bytes = bytes([b & 0xFF for b in stream.toByteArray()])
                                stream.close()
                                bitmap.recycle()
                                pil_img = Image.open(io.BytesIO(py_bytes)).convert("RGBA")
                                PremiumEmojiRenderer._cache[cache_key] = pil_img
                                if temp_dir:
                                    try: pil_img.save(os.path.join(temp_dir, f"emoji_render_{cache_key}.png"), "PNG")
                                    except Exception: pass
                            except Exception:
                                pass
                    finally:
                        ev.set()
                        with PremiumEmojiRenderer._get_lock():
                            PremiumEmojiRenderer._in_flight.pop(cache_key, None)

            finally:
                if on_done:
                    on_done()

        threading.Thread(target=run, daemon=True).start()

    @staticmethod
    def render_premium_emoji(document_id, size_px=64):
        doc_id_str = str(int(document_id))
        cache_key = f"{doc_id_str}_{size_px}"
        
        if cache_key in PremiumEmojiRenderer._cache:
            return PremiumEmojiRenderer._cache[cache_key]

        import threading
        ev = threading.Event()
        PremiumEmojiRenderer.prefetch_emojis_async([document_id], size_px, on_done=lambda: ev.set())
        ev.wait(0.67)
        
        return PremiumEmojiRenderer._cache.get(cache_key)

class UniversalTextRenderer:
    _cache = {}

    @staticmethod
    def get_typeface():
        try:
            return Typeface.DEFAULT
        except:
            return Typeface.create("sans-serif", Typeface.NORMAL)

    @staticmethod
    def measure(text, size):
        try:
            paint = TextPaint(Paint.ANTI_ALIAS_FLAG)
            paint.setTextSize(float(size))
            paint.setTypeface(UniversalTextRenderer.get_typeface())
            return paint.measureText(text)
        except:
            return 0

    @staticmethod
    def render(text, size, color_int):
        key = f"{text}_{size}_{color_int}"
        if key in UniversalTextRenderer._cache:
            return UniversalTextRenderer._cache[key]
        
        try:
            paint = TextPaint(Paint.ANTI_ALIAS_FLAG)
            a = (color_int >> 24) & 0xFF
            r = (color_int >> 16) & 0xFF
            g = (color_int >> 8) & 0xFF
            b = color_int & 0xFF
            paint.setARGB(a, r, g, b)
            
            paint.setTextSize(float(size))
            paint.setTypeface(UniversalTextRenderer.get_typeface())
            
            baseline = abs(paint.ascent())
            width = int(paint.measureText(text) + 2)
            height = int(baseline + paint.descent() + 2)
            
            if width <= 0 or height <= 0:
                return None
                
            bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
            canvas = Canvas(bitmap)
            canvas.drawText(text, 0, baseline, paint)
            
            stream = ByteArrayOutputStream()
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            py_bytes = bytes([b & 0xFF for b in stream.toByteArray()])
            stream.close()
            bitmap.recycle()
            
            pil_img = Image.open(io.BytesIO(py_bytes)).convert("RGBA")
            UniversalTextRenderer._cache[key] = pil_img
            return pil_img
        except Exception as e:
            qlog(f"Universal render error: {e}")
            return None

class OpenDocumentHook(MethodHook):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            message = param.args[0]
            if not message:
                return
            
            file_name = str(message.getFileName())
            if file_name.lower().endswith(CONFIG_FILE_EXTENSION):
                m_name = param.method.getName()
                if "openForView" in m_name:
                    param.setResult(True)
                else:
                    param.setResult(None)
                
                path = message.messageOwner.attachPath
                if not path or not os.path.exists(str(path)):
                    try:
                        from java import jclass
                        FileLoader = jclass("org.telegram.messenger.FileLoader")
                        f = FileLoader.getInstance(message.currentAccount).getPathToMessage(message.messageOwner)
                        path = f.getAbsolutePath()
                    except:
                        path = None
                
                if path and os.path.exists(str(path)):
                    run_on_ui_thread(lambda: self.plugin._handle_config_file_open(str(path)))
                else:
                    BulletinHelper.show_error("Файл ещё не загружен или не найден")
        except:
            pass

class TelegramUtils:
    @staticmethod
    def get_user(user_id):
        return get_messages_controller().getUser(user_id)
    
    @staticmethod 
    def get_channel(channel_id, callback):
        req = TLRPC.TL_channels_getChannels()
        input_channel = get_messages_controller().getInputChannel(channel_id)
        req.id.add(input_channel)
        cb = RequestCallback(callback)
        send_request(req, cb)
        
    @staticmethod
    def get_chat(chat_id, callback):
        req = TLRPC.TL_messages_getChats()
        input_chat = get_messages_controller().getInputChat(chat_id)
        req.id.add(input_chat)
        cb = RequestCallback(callback)
        send_request(req, cb)
        
    @staticmethod
    def create_input_location(photo, size):
        location = TLRPC.TL_inputPhotoFileLocation()
        location.id = photo.id
        location.access_hash = photo.access_hash
        location.file_reference = photo.file_reference
        location.thumb_size = size.type
        return location
        
    @staticmethod
    def create_peer_input_location(chat, peer):
        location = TLRPC.TL_inputPeerPhotoFileLocation()
        location.big = True
        location.peer = get_messages_controller().getInputPeer(peer)
        location.photo_id = chat.photo.photo_id
        return location
        
    @staticmethod
    def get_chat_thumbnail(chat, peer, callback):
        req = TLRPC.TL_upload_getFile()
        cb = RequestCallback(callback)
        location = TelegramUtils.create_peer_input_location(chat, peer)
        req.location = location
        req.offset = 0
        req.limit = 1024 * 1024
        send_request(req, cb)

class ReplyerID:
    def __init__(self, peer):
        if peer is None:
            self.channel_id = 0
            self.chat_id = 0
            self.user_id = -1
            self.peer = None
            return
        self.channel_id = peer.channel_id
        self.chat_id = peer.chat_id
        self.user_id = peer.user_id
        self.peer = peer
        
    def get_replyer_type(self):
        if self.channel_id != 0:
            return 2
        elif self.chat_id != 0:
            return 1
        else:
            return 0
        
    def get_id(self):
        if self.channel_id != 0:
            return self.channel_id
        elif self.chat_id != 0:
            return self.chat_id
        else:
            return self.user_id

class Replyer:
    def __init__(self):
        self.name = ""

class QuoteManager:
    def __init__(self, params, font_index, layout_index, fixed_width, plugin, custom_bg_path="", custom_avatar_path="", force_custom_bg=False, force_custom_avatar=False, override_author_name=None, search_query=None):
        self.params = params
        self.user = None
        self.replyer_id = None
        self.replyer = Replyer()
        self.font_index = font_index
        self.layout_index = layout_index
        self.fixed_width = fixed_width
        self.plugin = plugin
        self.override_quote_text = None
        self.custom_bg_path = custom_bg_path
        self.custom_avatar_path = custom_avatar_path
        self.force_custom_bg = force_custom_bg
        self.force_custom_avatar = force_custom_avatar
        self.override_author_name = override_author_name
        self.search_query = search_query
        self.cached_media_path = None
        self.media_fetch_attempted = False
        self.is_sticker_media = False
        self.is_finalized = False
        self.is_round_media = False
        self.finalize_lock = threading.Lock()

    def _render_tgs_frame(self, sticker_path):
        drawable = None
        bitmap = None
        stream = None
        try:
            drawable = RLottieDrawable(File(sticker_path), 1024, 1024, None, False, None, 0)
            try:
                drawable.setAllowDecodeSingleFrame(True)
            except Exception:
                pass
            bitmap = Bitmap.createBitmap(1024, 1024, Bitmap.Config.ARGB_8888)
            canvas = Canvas(bitmap)
            drawable.setBounds(0, 0, 1024, 1024)
            has_pixels = False
            for _ in range(40):
                bitmap.eraseColor(0)
                drawable.draw(canvas)
                for x in range(128, 1024, 128):
                    for y in range(128, 1024, 128):
                        if bitmap.getPixel(x, y) != 0:
                            has_pixels = True
                            break
                    if has_pixels:
                        break
                if has_pixels:
                    break
                time.sleep(0.05)
            if not has_pixels:
                return None
            out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"sticker_tgs_{uuid.uuid4()}.png")
            stream = FileOutputStream(out_path)
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            return out_path
        except Exception:
            return None
        finally:
            try:
                if stream: stream.close()
                if bitmap: bitmap.recycle()
                if drawable: drawable.recycle(True)
            except Exception: pass

    def _get_video_first_frame(self, video_path):
        retriever = None
        bitmap = None
        stream = None
        try:
            retriever = MediaMetadataRetriever()
            retriever.setDataSource(video_path)
            bitmap = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)
            if bitmap is None:
                bitmap = retriever.getFrameAtTime()
            if bitmap is not None:
                width = bitmap.getWidth()
                height = bitmap.getHeight()
                if width < 1024 or height < 1024:
                    scale = max(1024.0 / width, 1024.0 / height)
                    scaled = Bitmap.createScaledBitmap(bitmap, int(width * scale), int(height * scale), True)
                    if scaled != bitmap:
                        bitmap.recycle()
                        bitmap = scaled
            if bitmap is None:
                return None
            out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"sticker_video_{uuid.uuid4()}.png")
            stream = FileOutputStream(out_path)
            bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
            return out_path
        except Exception:
            return None
        finally:
            try:
                if stream: stream.close()
                if bitmap: bitmap.recycle()
                if retriever: retriever.release()
            except Exception: pass

    def _ensure_raster_image(self, path):
        try:
            bmp = BitmapFactory.decodeFile(path)
            if bmp is None:
                return path
            width = bmp.getWidth()
            height = bmp.getHeight()
            if width < 1024 or height < 1024:
                scale = max(1024.0 / width, 1024.0 / height)
                scaled = Bitmap.createScaledBitmap(bmp, int(width * scale), int(height * scale), True)
                if scaled != bmp:
                    bmp.recycle()
                    bmp = scaled
            out_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"raster_{uuid.uuid4()}.png")
            fos = FileOutputStream(out_path)
            try:
                bmp.compress(Bitmap.CompressFormat.PNG, 100, fos)
                fos.flush()
            finally:
                try:
                    fos.close()
                    bmp.recycle()
                except Exception: pass
            return out_path
        except Exception:
            return path

    def _start_emoji_prefetch_from_reply(self):
        try:
            reply_obj = getattr(self.params, 'replyToMsg', None)
            if not reply_obj:
                return

            if hasattr(reply_obj, 'messageOwner'):
                raw_msg = reply_obj.messageOwner
            else:
                raw_msg = reply_obj

            text = getattr(raw_msg, 'message', '') or ''
            if not text:
                text = getattr(raw_msg, 'caption', '') or ''

            if not text or not hasattr(raw_msg, 'entities') or not raw_msg.entities:
                return

            doc_ids = []
            for i in range(raw_msg.entities.size()):
                e = raw_msg.entities.get(i)
                if isinstance(e, TLRPC.TL_messageEntityCustomEmoji):
                    doc_ids.append(e.document_id)

            if not doc_ids:
                return

            try:
                visual_ratio = int(self.plugin.get_setting("emoji_visual_percent", "130")) / 100.0
                quote_font_size = int(self.plugin.get_setting("quote_font_size", "40"))
                author_font_size = int(self.plugin.get_setting("author_font_size", "32"))
            except:
                visual_ratio = 1.30
                quote_font_size = 40
                author_font_size = 32

            size_q = int(quote_font_size * visual_ratio)
            size_a = int(author_font_size * visual_ratio)

            qlog(f"[PREFETCH_EARLY] Starting early prefetch for {len(doc_ids)} doc_id(s), sizes={size_q},{size_a}")
            PremiumEmojiRenderer.prefetch_emojis_async(doc_ids, size_q, on_done=None)
            if size_a != size_q:
                PremiumEmojiRenderer.prefetch_emojis_async(doc_ids, size_a, on_done=None)
        except Exception as e:
            qlog(f"[PREFETCH_EARLY] Error: {e}")

    def generate_quote(self):
        def run():
            try:
                reply_obj = getattr(self.params, 'replyToMsg', None)
                if reply_obj is None:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(LocalizationManager.get_string("FORGOT_TO_REPLY")))
                    return

                if hasattr(reply_obj, 'messageOwner'):
                    real_msg = reply_obj.messageOwner
                else:
                    real_msg = reply_obj

                if self.search_query:
                    if self._resolve_user_from_query(self.search_query):
                        return
                    self.override_author_name = self.search_query
                    self.search_query = None

                self._start_emoji_prefetch_from_reply()
                self.replyer_id = self._init_replyer_id()
                if not self.replyer_id: 
                     self.replyer_id = ReplyerID(None)

                replyer_type = self.replyer_id.get_replyer_type()
                
                if replyer_type == 0:
                    if self.replyer_id.user_id == -1:
                        return self._create_quote_without_input()
                    user = TelegramUtils.get_user(self.replyer_id.user_id)
                    self.user = user
                    self.replyer.name = self._get_full_replyer_name()
                    self._fetch_user_avatar(user)
                elif replyer_type == 1:
                    TelegramUtils.get_chat(self.replyer_id.chat_id, self._handle_get_channels_callback)
                elif replyer_type == 2:
                    TelegramUtils.get_channel(self.replyer_id.channel_id, self._handle_get_channels_callback)
            except Exception as e:
                copy_error_to_clipboard(traceback.format_exc())
        threading.Thread(target=run, daemon=True).start()

    def generate_fake_quote(self, text):
        def run():
            self.override_quote_text = text
            self._start_emoji_prefetch_from_reply()
            if self.search_query:
                return self._resolve_user_from_query(self.search_query)

            if self.override_author_name is not None:
                self.replyer.name = self.override_author_name
                return self._create_quote_without_input()
            
            try:
                reply_obj = getattr(self.params, 'replyToMsg', None)
                if reply_obj is not None:
                    self.replyer_id = self._init_replyer_id()
                    replyer_type = self.replyer_id.get_replyer_type()
                    if replyer_type == 0:
                        if self.replyer_id.user_id == -1:
                            return self._create_quote_without_input()
                        user = TelegramUtils.get_user(self.replyer_id.user_id)
                        self.user = user
                        self.replyer.name = self._get_full_replyer_name()
                        self._fetch_user_avatar(user)
                        return
                    elif replyer_type == 1:
                        TelegramUtils.get_chat(self.replyer_id.chat_id, self._handle_get_channels_callback)
                        return
                    elif replyer_type == 2:
                        TelegramUtils.get_channel(self.replyer_id.channel_id, self._handle_get_channels_callback)
                        return

                user_id = get_user_config().getClientUserId()
                me = get_messages_controller().getUser(user_id)
                if me:
                    self.user = me
                    self.replyer.name = self._get_full_replyer_name()
                    self._fetch_user_avatar(me)
                else:
                    self.replyer.name = ""
                    self._create_quote_without_input()
            except Exception as e:
                copy_error_to_clipboard(traceback.format_exc())
        threading.Thread(target=run, daemon=True).start()

    def _download_voice_message(self, document, message_owner):
        try:
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            
            file_path_obj = file_loader.getPathToMessage(message_owner)
            
            if not file_path_obj or not os.path.exists(file_path_obj.getAbsolutePath()):
                file_loader.loadFile(document, message_owner, 1, 0)
                
                import time
                for _ in range(30):
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()) and os.path.getsize(file_path_obj.getAbsolutePath()) > 0:
                        break
                    time.sleep(0.5)
            
            if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                return file_path_obj.getAbsolutePath()
            return None
        except Exception as e:
            qlog(f"Voice download error: {e}")
            return None

    def _transcribe_voice(self, file_path):
        try:
            extended_logs = self.plugin.get_setting("extended_logging", False)
            run_on_ui_thread(lambda: BulletinHelper.show_info("Начинаю расшифровку..."))
            
            provider = self.plugin.get_setting("transcription_provider", 2)
            if extended_logs:
                qlog(f"Starting transcription. Provider ID: {provider}, File: {file_path}")
            
            text = None

            if provider == 0:
                api_key = self.plugin.get_setting("trans_key_manual", "AIzaSyD8kUluAcDVA-VpHtcaeAW_HQ_dAf44q3s")
                model = self.plugin.get_setting("trans_model", "gemini-2.5-flash")
                
                import base64
                with open(file_path, "rb") as f:
                    audio_data = base64.b64encode(f.read()).decode('utf-8')
                
                url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
                headers = {"Content-Type": "application/json", "x-goog-api-key": api_key}
                payload = {
                    "contents": [{
                        "parts": [
                            {"text": "Transcribe this audio to text. Return only the transcribed text without any additional comments or formatting."},
                            {"inline_data": {"mime_type": "audio/ogg", "data": audio_data}}
                        ]
                    }]
                }
                
                response = requests.post(url, headers=headers, json=payload, timeout=60)
                if response.status_code == 200:
                    result = response.json()
                    try:
                        text = result["candidates"][0]["content"]["parts"][0]["text"]
                        if extended_logs: qlog("Gemini transcription success")
                    except (KeyError, IndexError):
                        qlog(f"Gemini parse error: {result}")
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка разбора ответа Gemini"))
                else:
                    qlog(f"Gemini Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Gemini API Error: {response.status_code}"))

            elif provider == 1:
                api_key = self.plugin.get_setting("trans_key_navy", "sk-navy-bRHcCluxPrlkLkIB5qKJFGPEJOl1cL91xcqxO4vYfeg")
                model = self.plugin.get_setting("trans_model_navy", "gpt-4o-transcribe")
                
                url = "https://api.navy/v1/audio/transcriptions"
                headers = {"Authorization": f"Bearer {api_key}"}
                
                with open(file_path, "rb") as f:
                    files = {"file": ("voice.ogg", f, "audio/ogg")}
                    data = {"model": model, "response_format": "json"}
                    response = requests.post(url, headers=headers, files=files, data=data, timeout=60)
                
                if response.status_code == 200:
                    text = response.json().get("text", "")
                    if extended_logs: qlog("NavyAI transcription success")
                else:
                    qlog(f"NavyAI Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"NavyAI Error: {response.status_code}"))

            elif provider == 2:
                api_key = self.plugin.get_setting("trans_key_mistral", "6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF")
                model = self.plugin.get_setting("trans_model_mistral", "voxtral-mini-latest")
                
                if not api_key:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка: Не указан ключ Mistral"))
                    return None

                url = "https://api.mistral.ai/v1/audio/transcriptions"
                headers = {"Authorization": f"Bearer {api_key}"}
                
                with open(file_path, "rb") as f:
                    files = {"file": ("voice.ogg", f, "audio/ogg")}
                    data = {"model": model}
                    response = requests.post(url, headers=headers, files=files, data=data, timeout=60)
                
                if response.status_code == 200:
                    text = response.json().get("text", "")
                    if extended_logs: qlog("Mistral transcription success")
                else:
                    qlog(f"Mistral Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Mistral Error: {response.status_code}"))

            elif provider == 3:
                api_key = self.plugin.get_setting("trans_key_deepgram", "011fb75d769d83fe88822e0c6f4e45cee8810116")
                model = self.plugin.get_setting("trans_model_deepgram", "nova-3-general")
                
                url = f"https://api.deepgram.com/v1/listen?model={model}&punctuate=true&detect_language=true"
                headers = {
                    "Authorization": f"Token {api_key}",
                    "Content-Type": "audio/*",
                }

                with open(file_path, "rb") as audio_file:
                    response = requests.post(url, headers=headers, data=audio_file, timeout=60)

                if response.status_code == 200:
                    try:
                        text = response.json()["results"]["channels"][0]["alternatives"][0]["transcript"]
                        if extended_logs: qlog("Deepgram transcription success")
                    except (KeyError, IndexError):
                        qlog(f"Deepgram parse error: {response.text}")
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка разбора ответа Deepgram"))
                else:
                    qlog(f"Deepgram Error {response.status_code}: {response.text}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Deepgram Error: {response.status_code}"))

            if text:
                run_on_ui_thread(lambda: BulletinHelper.show_success("Расшифровка завершена!"))
                fmt = self.plugin.get_setting("trans_format", '[Расшифровка: "{text}"]')
                return fmt.replace("{text}", text.strip())
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось получить ответ от API"))
                return None

        except Exception as e:
            qlog(f"Transcription error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка расшифровки (см. логи)"))
            return None

    def _fetch_attached_media(self):
        qlog("[MEDIA] Starting _fetch_attached_media")
        if not self.plugin.get_setting("quote_render_image", True):
            qlog("[MEDIA] Disabled in settings")
            return None
            
        if self.media_fetch_attempted:
            qlog(f"[MEDIA] Using cached path: {self.cached_media_path}")
            return self.cached_media_path
            
        self.media_fetch_attempted = True
        
        reply_msg = getattr(self.params, 'replyToMsg', None)
        if not reply_msg:
            qlog("[MEDIA] No replyToMsg found")
            return None

        try:
            message_owner = getattr(reply_msg, 'messageOwner', reply_msg)
            if not message_owner or not hasattr(message_owner, 'media'):
                qlog("[MEDIA] No message_owner or media attribute")
                return None
            
            media = message_owner.media
            qlog(f"[MEDIA] Media type: {type(media)}")
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            
            if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
                qlog("[MEDIA] Processing photo")
                photo = media.photo
                file_path_obj = file_loader.getPathToMessage(message_owner)
                
                if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                    self.cached_media_path = file_path_obj.getAbsolutePath()
                    qlog(f"[MEDIA] Found photo locally: {self.cached_media_path}")
                    return self.cached_media_path

                largest = None
                max_dim = 0
                for size in photo.sizes:
                    if isinstance(size, TLRPC.TL_photoSize):
                        d = max(size.w, size.h)
                        if d > max_dim:
                            max_dim = d
                            largest = size
                
                if largest:
                    qlog("[MEDIA] Loading largest photo size")
                    file_path_obj = file_loader.getPathToAttach(largest, True)
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                        self.cached_media_path = file_path_obj.getAbsolutePath()
                        qlog(f"[MEDIA] Found largest size locally: {self.cached_media_path}")
                        return self.cached_media_path
                    
                    image_location = ImageLocation.getForPhoto(largest, photo)
                    if image_location:
                        file_loader.loadFile(image_location, "jpg", None, 1)
                        path = file_path_obj.getAbsolutePath()
                        for i in range(20): 
                            if os.path.exists(path) and os.path.getsize(path) > 0:
                                self.cached_media_path = path
                                qlog(f"[MEDIA] Downloaded photo: {self.cached_media_path} at attempt {i}")
                                return path
                            time.sleep(0.1)
                qlog("[MEDIA] Photo fetch failed")

            if hasattr(media, 'document') and media.document:
                document = media.document
                is_sticker = False
                mime = getattr(document, "mime_type", "") or ""
                qlog(f"[MEDIA] Document MIME: {mime}")
                
                is_gif = False
                is_video = False
                if hasattr(document, 'attributes'):
                    for i in range(document.attributes.size()):
                        attr = document.attributes.get(i)
                        if isinstance(attr, TLRPC.TL_documentAttributeSticker):
                            is_sticker = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                            is_gif = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                            is_video = True
                            if getattr(attr, 'round_message', False):
                                self.is_round_media = True
                
                if not is_sticker and mime == "application/x-tgsticker":
                    is_sticker = True
                
                if is_sticker or is_gif or is_video:
                    if is_sticker:
                        self.is_sticker_media = True

                    thumb_path = None
                    try:
                        if mime == "image/webp":
                            doc_path = file_loader.getPathToAttach(document, True)
                            if not doc_path or not doc_path.exists() or doc_path.length() == 0:
                                file_loader.loadFile(document, "webp", 0, 1)
                                for _ in range(30):
                                    doc_path = file_loader.getPathToAttach(document, True)
                                    if doc_path and doc_path.exists() and doc_path.length() > 0:
                                        thumb_path = doc_path.getAbsolutePath()
                                        break
                                    time.sleep(0.1)
                            else:
                                thumb_path = doc_path.getAbsolutePath()
                        else:
                            best_thumb = None
                            if hasattr(document, 'thumbs') and document.thumbs:
                                for i in range(document.thumbs.size()):
                                    t = document.thumbs.get(i)
                                    if isinstance(t, TLRPC.TL_photoSize):
                                        if not best_thumb or t.w > best_thumb.w:
                                            best_thumb = t
                            
                            if best_thumb:
                                tp = file_loader.getPathToAttach(best_thumb, True)
                                if not tp or not tp.exists() or tp.length() == 0:
                                    loc = ImageLocation.getForDocument(document)
                                    if loc:
                                        file_loader.loadFile(loc, "webp", None, 1)
                                        for _ in range(30):
                                            if tp and tp.exists() and tp.length() > 0:
                                                thumb_path = tp.getAbsolutePath()
                                                break
                                            time.sleep(0.1)
                                else:
                                    thumb_path = tp.getAbsolutePath()
                    except Exception: pass

                    if mime == "application/x-tgsticker":
                        qlog("[MEDIA] Processing TGS sticker")
                        file_path_obj = file_loader.getPathToAttach(document, True)
                        if not file_path_obj or not os.path.exists(file_path_obj.getAbsolutePath()) or os.path.getsize(file_path_obj.getAbsolutePath()) == 0:
                            qlog("[MEDIA] TGS not found locally, loading")
                            file_loader.loadFile(document, "tgs", 0, 1)
                            file_path_obj = file_loader.getPathToAttach(document, True)
                            for k in range(40):
                                if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()) and os.path.getsize(file_path_obj.getAbsolutePath()) > 0:
                                    qlog(f"[MEDIA] TGS loaded at attempt {k}")
                                    break
                                time.sleep(0.1)
                                
                        if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                            qlog(f"[MEDIA] Sending to _render_tgs_frame: {file_path_obj.getAbsolutePath()}")
                            converted = self._render_tgs_frame(file_path_obj.getAbsolutePath())
                            if converted:
                                self.cached_media_path = converted
                                qlog(f"[MEDIA] TGS rendered: {converted}")
                                return converted
                            else:
                                qlog("[MEDIA] TGS render returned None")
                        else:
                            qlog("[MEDIA] Failed to get local TGS file")
                        
                        if thumb_path:
                            qlog("[MEDIA] Falling back to TGS thumb")
                            converted = self._ensure_raster_image(thumb_path)
                            if converted:
                                self.cached_media_path = converted
                                return converted

                    if is_sticker and mime == "video/webm" and thumb_path:
                        converted = self._ensure_raster_image(thumb_path)
                        if converted:
                            self.cached_media_path = converted
                            return converted

                    if is_video and thumb_path:
                        converted = self._ensure_raster_image(thumb_path)
                        if converted:
                            self.cached_media_path = converted
                            return converted

                    if is_gif or mime in ("video/webm", "video/mp4", "image/gif") or (is_sticker and mime == "video/webm"):
                        qlog(f"[MEDIA] Processing video/gif. is_gif={is_gif}, mime={mime}")
                        file_path_obj = file_loader.getPathToAttach(document, True)
                        if not file_path_obj or not os.path.exists(file_path_obj.getAbsolutePath()) or os.path.getsize(file_path_obj.getAbsolutePath()) == 0:
                            ext_hint = "mp4" if is_gif else ("webm" if mime == "video/webm" else "webp")
                            qlog(f"[MEDIA] Downloading video with ext_hint={ext_hint}")
                            file_loader.loadFile(document, ext_hint, 0, 1)
                            file_path_obj = file_loader.getPathToAttach(document, True)
                            for k in range(40):
                                if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()) and os.path.getsize(file_path_obj.getAbsolutePath()) > 0:
                                    qlog(f"[MEDIA] Video downloaded at attempt {k}")
                                    break
                                time.sleep(0.1)
                        if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                            qlog(f"[MEDIA] Calling _get_video_first_frame on {file_path_obj.getAbsolutePath()}")
                            converted = self._get_video_first_frame(file_path_obj.getAbsolutePath())
                            if converted:
                                self.cached_media_path = converted
                                qlog(f"[MEDIA] Video frame extracted: {converted}")
                                return converted
                            qlog("[MEDIA] _get_video_first_frame returned None")

                    if thumb_path:
                        qlog("[MEDIA] Fallback to thumb_path")
                        converted = self._ensure_raster_image(thumb_path)
                        if converted:
                            self.cached_media_path = converted
                        return converted
                        
                    file_path_obj = file_loader.getPathToAttach(document, True)
                    if file_path_obj and os.path.exists(file_path_obj.getAbsolutePath()):
                         qlog(f"[MEDIA] Final fallback to document path: {file_path_obj.getAbsolutePath()}")
                         converted = self._ensure_raster_image(file_path_obj.getAbsolutePath())
                         self.cached_media_path = converted
                         return converted
                else:
                    qlog("[MEDIA] Not a sticker or gif")

            qlog("[MEDIA] Returning None at end of _fetch_attached_media")
            return None
        except Exception as e:
            qlog(f"[MEDIA] Exception in _fetch_attached_media: {e}")
            return None

    def _resolve_user_from_query(self, query):
        query = query.strip().rstrip(',')
        try:
            telegram_domains = ["t.me", "telegram.me", "telegram.dog"]
            for domain in telegram_domains:
                patterns = [f"https://{domain}/", f"{domain}/"]
                for pattern in patterns:
                    if query.lower().startswith(pattern):
                        username_part = query[len(pattern):].split('/')[0].split('?')[0].strip()
                        if username_part:
                            qlog(f"Resolving username from {pattern}: @{username_part}")
                            self._resolve_by_username(username_part)
                            return True
            
            if query.lower().startswith("tg://user?id="):
                user_id = int(re.search(r'\d+', query).group())
                self._resolve_by_id(user_id)
                return True
            
            if query.lower().startswith("id "):
                user_id = int(query[3:].strip())
                self._resolve_by_id(user_id)
                return True
            
            if query.startswith("+") and query[1:].isdigit():
                self._resolve_by_phone(query)
                return True
                
            if query.startswith("@"):
                self._resolve_by_username(query[1:])
                return True
                
            if query.isdigit():
                user_id = int(query)
                self._resolve_by_id(user_id)
                return True
            
            return False
            
        except (ValueError, TypeError, AttributeError) as e:
            qlog(f"Error parsing query '{query}': {e}. Treating as name override.")
            return False

    def _resolve_by_id(self, user_id):
        user = TelegramUtils.get_user(user_id)
        if user:
            self.user = user
            self.replyer.name = self._get_full_replyer_name()
            self._fetch_user_avatar(user)
        else:
            qlog(f"User with ID {user_id} not found.")
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _resolve_by_username(self, username):
        qlog(f"Resolving username: @{username}")
        req = TLRPC.TL_contacts_resolveUsername()
        req.username = username
        send_request(req, RequestCallback(self._handle_resolve_callback))

    def _resolve_by_phone(self, phone):
        qlog(f"Resolving phone: {phone}")
        try:
            req = TLRPC.TL_contacts_resolvePhone()
            req.phone = phone
            send_request(req, RequestCallback(self._handle_resolve_callback))
        except Exception as e:
            qlog(f"Failed to create TL_contacts_resolvePhone request: {e}")
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _handle_resolve_callback(self, response, error):
        if error or not response:
            self.replyer.name = self.search_query
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)
            return
        
        self.search_query = None 
    
        if hasattr(response, 'users') and not response.users.isEmpty():
            user = response.users.get(0)
            self.user = user
            self.replyer.name = self._get_full_replyer_name()
            self._fetch_user_avatar(user)
        elif hasattr(response, 'chats') and not response.chats.isEmpty():
            chat = response.chats.get(0)
            
            emoji_suffix = ""
            try:
                if self.plugin.get_setting("show_name_emoji", False) and hasattr(chat, 'emoji_status') and chat.emoji_status:
                    doc_id = getattr(chat.emoji_status, 'document_id', None)
                    if doc_id:
                        emoji_suffix = f" [CEMOJI:{doc_id}]"
            except Exception:
                pass
                
            self.replyer.name = self._sanitize_text(chat.title) + emoji_suffix
            self.user = None 
            self._fetch_chat_avatar(chat, response.peer)
        else:
            self.replyer.name = self.search_query if self.search_query else "Unknown"
            if not self.force_custom_avatar:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
            else:
                self._create_quote_without_input(skip_service_fallback=True)

    def _fetch_user_avatar(self, user):
        if self.force_custom_avatar and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
            return self._create_quote_without_input()
        
        has_real_photo = user and user.photo and isinstance(user.photo, TLRPC.TL_userProfilePhoto) and user.photo.photo_id != 0
        if not has_real_photo:
            return self._create_quote_without_input()

        temp_dir = Filesystem.get_temp_dir()
        avatars_dir = os.path.join(temp_dir, "avatars_cache")
        if not os.path.exists(avatars_dir):
            os.makedirs(avatars_dir)
            
        cached_path = os.path.join(avatars_dir, f"u_{user.id}_{user.photo.photo_id}.jpg")
        
        if os.path.exists(cached_path) and os.path.getsize(cached_path) > 0:
            self._create_and_send_image(
                image_path=cached_path,
                output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                author=self._get_author(),
                quote=self._get_quote_message(),
                layout_vertical=(self.layout_index == 1)
            )
            return

        def run():
            try:
                current_account = UserConfig.selectedAccount
                file_loader = FileLoader.getInstance(current_account)
                best_size = None
                target_cache_file = None

                if hasattr(user.photo, 'sizes'):
                    sorted_sizes = [s for s in user.photo.sizes if isinstance(s, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive))]
                    sorted_sizes.sort(key=lambda s: s.w * s.h, reverse=True)
                    if sorted_sizes:
                        best_size = sorted_sizes[0]

                tl_big = best_size if best_size else getattr(user.photo, 'photo_big', None)

                if tl_big:
                    target_cache_file = file_loader.getPathToAttach(tl_big, True)
                    if target_cache_file and target_cache_file.exists() and target_cache_file.length() > 0:
                        import shutil
                        shutil.copy2(target_cache_file.getAbsolutePath(), cached_path)
                        self._create_and_send_image(
                            image_path=cached_path,
                            output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                            author=self._get_author(),
                            quote=self._get_quote_message(),
                            layout_vertical=(self.layout_index == 1)
                        )
                        return

                self._fetch_avatar_via_upload_getfile(user, target_cache_file, cached_path)
            except Exception as e:
                qlog(f"_fetch_user_avatar run error: {e}")
                self._fetch_avatar_via_upload_getfile(user, None, cached_path)

        threading.Thread(target=run, daemon=True).start()

    def _fetch_avatar_via_upload_getfile(self, user, target_cache_file, custom_cache_path=None):
        try:
            req = TLRPC.TL_upload_getFile()
            location = TLRPC.TL_inputPeerPhotoFileLocation()
            location.big = True
            location.peer = get_messages_controller().getInputPeer(user.id)
            location.photo_id = user.photo.photo_id
            req.location = location
            req.offset = 0
            req.limit = 1024 * 1024
            send_request(req, RequestCallback(lambda r, e: self._handle_get_file_callback(r, e, target_cache_file, custom_cache_path)))
        except Exception:
            self._fetch_avatar_via_getphotos(user)

    def _fetch_chat_avatar(self, chat, peer=None):
        if self.force_custom_avatar and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
            return self._create_quote_without_input()
        
        has_chat_photo = chat.photo and chat.photo.photo_id != 0
        if not has_chat_photo:
            return self._create_quote_without_input()

        temp_dir = Filesystem.get_temp_dir()
        avatars_dir = os.path.join(temp_dir, "avatars_cache")
        if not os.path.exists(avatars_dir):
            os.makedirs(avatars_dir)
            
        cached_path = os.path.join(avatars_dir, f"c_{chat.id}_{chat.photo.photo_id}.jpg")
        
        if os.path.exists(cached_path) and os.path.getsize(cached_path) > 0:
            self._create_and_send_image(
                image_path=cached_path,
                output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                author=self._get_author(),
                quote=self._get_quote_message(),
                layout_vertical=(self.layout_index == 1)
            )
            return

        target_cache_file = None
        try:
            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            tl_big = getattr(chat.photo, 'photo_big', None)
            if tl_big:
                target_cache_file = file_loader.getPathToAttach(tl_big, True)
                if target_cache_file and target_cache_file.exists() and target_cache_file.length() > 0:
                    import shutil
                    shutil.copy2(target_cache_file.getAbsolutePath(), cached_path)
                    self._create_and_send_image(
                        image_path=cached_path,
                        output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                        author=self._get_author(),
                        quote=self._get_quote_message(),
                        layout_vertical=(self.layout_index == 1)
                    )
                    return
        except Exception:
            pass

        try:
            input_peer = None
            if isinstance(chat, TLRPC.TL_channel) or isinstance(chat, TLRPC.TL_channelForbidden):
                input_peer = TLRPC.TL_inputPeerChannel()
                input_peer.channel_id = chat.id
                input_peer.access_hash = chat.access_hash
            elif isinstance(chat, TLRPC.TL_chat) or isinstance(chat, TLRPC.TL_chatForbidden):
                input_peer = TLRPC.TL_inputPeerChat()
                input_peer.chat_id = chat.id
            else:
                input_peer = get_messages_controller().getInputPeer(chat.id)

            req = TLRPC.TL_upload_getFile()
            location = TLRPC.TL_inputPeerPhotoFileLocation()
            location.big = True
            location.peer = input_peer
            location.photo_id = chat.photo.photo_id
            req.location = location
            req.offset = 0
            req.limit = 1024 * 1024 * 4
            
            def on_file_result(response, error):
                if error or not response:
                    has_username = getattr(chat, 'username', None)
                    if not has_username and hasattr(chat, 'usernames') and chat.usernames:
                        has_username = True
                    if has_username:
                        self._fetch_avatar_via_web(chat, cached_path)
                    else:
                        self._create_quote_without_input()
                else:
                    self._handle_get_file_callback(response, None, target_cache_file, cached_path)
            send_request(req, RequestCallback(on_file_result))

        except Exception:
            has_username = getattr(chat, 'username', None)
            if not has_username and hasattr(chat, 'usernames') and chat.usernames:
                 has_username = True
            if has_username:
                self._fetch_avatar_via_web(chat, cached_path)
            else:
                self._create_quote_without_input()
                
        threading.Thread(target=run_fetch).start()

    def _handle_direct_avatar_response(self, response, error, user, cached_path):
        if not error and response:
            self._handle_get_file_callback(response, None, custom_cache_path=cached_path)
        else:
            self._fetch_avatar_via_getphotos(user)

    def _fetch_avatar_via_getphotos(self, user):
        try:
            req = TLRPC.TL_photos_getUserPhotos()
            input_user = get_messages_controller().getInputUser(user.id)
            if not input_user:
                if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                    self._create_quote_without_input(skip_service_fallback=True)
                return
            req.user_id = input_user
            req.limit = 1
            req.offset = 0
            req.max_id = 0
            send_request(req, RequestCallback(self._handle_user_photos_callback))
        except Exception:
            if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                self._create_quote_without_input(skip_service_fallback=True)

    def _fetch_avatar_via_web(self, entity, custom_cache_path=None):
        try:
            username = getattr(entity, 'username', None)
            
            if not username and hasattr(entity, 'usernames') and entity.usernames:
                for i in range(entity.usernames.size()):
                    u_obj = entity.usernames.get(i)
                    if getattr(u_obj, 'active', False):
                        username = u_obj.username
                        break
                if not username and entity.usernames.size() > 0:
                    username = entity.usernames.get(0).username

            if not username:
                return self._create_quote_without_input()

            url = f"https://t.me/{username}"
            headers = {'User-Agent': 'Mozilla/5.0'}
            
            html_response = requests.get(url, headers=headers, timeout=10)
            
            avatar_url = None
            match = re.search(r'<meta property="og:image" content="([^"]+)"', html_response.text)
            if match:
                avatar_url = match.group(1)
            else:
                match = re.search(r'<meta name="twitter:image" content="([^"]+)"', html_response.text)
                if match:
                    avatar_url = match.group(1)
                else:
                    match = re.search(r'<img class="tgme_page_photo_image" src="([^"]+)"', html_response.text)
                    if match:
                        avatar_url = match.group(1)
            
            if not avatar_url:
                return self._create_quote_without_input()
            
            avatar_response = requests.get(avatar_url, headers=headers, timeout=10)

            file_path = custom_cache_path
            if not file_path:
                temp_dir = Filesystem.get_temp_dir()
                file_path = Filesystem.get_absolute_path(temp_dir, f"img_web_{entity.id}.jpg")
            
            Filesystem.write_file(file_path, avatar_response.content)
            
            self._create_and_send_image(
                image_path=file_path,
                output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg"),
                author=self._get_author(),
                quote=self._get_quote_message(),
                layout_vertical=(self.layout_index == 1)
            )
        except Exception:
            self._create_quote_without_input()

    def _handle_get_channels_callback(self, response, error):
        if error:
            return self._create_quote_without_input()
        if response and response.chats and response.chats.size() > 0:
            chat = response.chats.get(0)
            
            emoji_suffix = ""
            try:
                if self.plugin.get_setting("show_name_emoji", False) and hasattr(chat, 'emoji_status') and chat.emoji_status:
                    doc_id = getattr(chat.emoji_status, 'document_id', None)
                    if doc_id:
                        emoji_suffix = f" [CEMOJI:{doc_id}]"
            except Exception:
                pass
            
            self.replyer.name = self._sanitize_text(chat.title) + emoji_suffix
            
            peer = self.replyer_id.peer
            if not peer:
                if chat.id < 0:
                    peer = get_messages_controller().getInputChannel(chat.id)
                else:
                    peer = get_messages_controller().getInputPeer(chat.id)

            self._fetch_chat_avatar(chat, peer)

    def _format_file_metadata(self, document, label_format):
        full_name = None
        name_part = "file"
        ext_part = ""
        file_size_str = ""
        
        try:
            if hasattr(document, 'attributes') and document.attributes:
                for i in range(document.attributes.size()):
                    attr = document.attributes.get(i)
                    if hasattr(attr, 'file_name'):
                        fn = attr.file_name
                        if fn:
                            full_name = str(fn)
                            break
                    elif hasattr(attr, 'fileName'):
                        fn = attr.fileName
                        if fn:
                            full_name = str(fn)
                            break
    
            if full_name:
                if '.' in full_name:
                    parts = full_name.rsplit('.', 1)
                    name_part = parts[0]
                    ext_part = parts[1]
                else:
                    name_part = full_name
                    ext_part = ""
            
            size_val = getattr(document, 'size', 0)
            if size_val > 0:
                if size_val < 1024:
                    file_size_str = f"{size_val}b"
                elif size_val < 1024 * 1024:
                    file_size_str = f"{round(size_val / 1024, 2)}kb"
                else:
                    file_size_str = f"{round(size_val / (1024 * 1024), 2)}mb"
                    
        except Exception as e:
            qlog(f"_format_file_metadata error: {e}")
            pass
    
        result = label_format.replace("{name}", name_part).replace("{ext}", ext_part)
        
        if not ext_part and "." in result:
            result = result.replace(".", "")
    
        if "{size}" in result:
            if file_size_str:
                result = result.replace("{size}", file_size_str)
            else:
                result = result.replace("{size}", "")
        
        return result.replace("  ", " ").strip()
        
    def _strip_custom_emojis(self, text, message_owner):
        if not text or not hasattr(message_owner, 'entities') or not message_owner.entities:
            return text
        try:
            custom_entities = []
            for i in range(message_owner.entities.size()):
                e = message_owner.entities.get(i)
                if isinstance(e, TLRPC.TL_messageEntityCustomEmoji):
                    custom_entities.append(e)
            
            if not custom_entities:
                return text
                
            custom_entities.sort(key=lambda x: x.offset, reverse=True)
            u16 = text.encode('utf-16-le')
            for e in custom_entities:
                start_byte = e.offset * 2
                end_byte = (e.offset + e.length) * 2
                if start_byte < len(u16) and end_byte <= len(u16):
                    doc_id = e.document_id
                    placeholder = f"[CEMOJI:{doc_id}]".encode('utf-16-le')
                    u16 = u16[:start_byte] + placeholder + u16[end_byte:]
            return u16.decode('utf-16-le')
        except Exception as e:
            qlog(f"[PREMIUM_EMOJI] Ошибка извлечения энтити: {e}")
            return text

    def _get_quote_message(self):
        if self.override_quote_text is not None:
            return self._sanitize_text(self.override_quote_text)
        
        self._fetch_attached_media()
        
        reply_obj = getattr(self.params, 'replyToMsg', None)
        if hasattr(reply_obj, 'messageOwner'):
            raw_message = reply_obj.messageOwner
        else:
            raw_message = reply_obj

        original_message = getattr(raw_message, 'message', "") or ""
        if not original_message:
            original_message = getattr(raw_message, 'caption', "") or ""
            
        message = self._strip_custom_emojis(original_message, raw_message)
        
        extended_logs = self.plugin.get_setting("extended_logging", False)

        try:
            should_render_media = self.plugin.get_setting("quote_render_image", True)
            media = getattr(raw_message, 'media', None)

            if should_render_media and media and isinstance(media, TLRPC.TL_messageMediaPhoto):
                return self._sanitize_text(message)
        
            if should_render_media and self.cached_media_path:
                return self._sanitize_text(message)

            message_type = 999 
            if hasattr(reply_obj, 'type'):
                message_type = reply_obj.type
            elif hasattr(raw_message, 'media') and raw_message.media:
                 pass 

            document = None
            
            if media:
                if isinstance(media, TLRPC.TL_messageMediaGame):
                    message_type = 18
                
                document = getattr(media, 'document', None)
                if not document:
                    webpage = getattr(media, 'webpage', None)
                    if webpage:
                         document = getattr(webpage, 'document', None)

            transcription = None
            is_emoji_only_message = False
        
            if self._is_emoji_only(original_message):
                is_emoji_only_message = True
            
            if document:
                is_gif = False
                is_video = False
                is_round = False
                is_voice = False
                is_sticker = False 
                is_music = False
                
                if hasattr(document, 'attributes'):
                    for i in range(document.attributes.size()):
                        attr = document.attributes.get(i)
                        if isinstance(attr, TLRPC.TL_documentAttributeAnimated):
                            is_gif = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeSticker): 
                            is_sticker = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeVideo):
                            is_video = True
                            if getattr(attr, 'round_message', False):
                                is_round = True
                        elif isinstance(attr, TLRPC.TL_documentAttributeAudio):
                            if getattr(attr, 'voice', False):
                                is_voice = True
                            else:
                                is_music = True

                if is_round: message_type = 5
                elif is_gif: message_type = 8
                elif is_sticker: message_type = 13
                elif is_video: message_type = 3
                elif is_voice: message_type = 2
                elif is_music: message_type = 14
                
                if message_type == 999:
                    message_type = 9

                if is_voice and not is_music and self.plugin.get_setting("enable_transcription", True):
                    voice_path = self._download_voice_message(document, raw_message)
                    if voice_path:
                        transcription = self._transcribe_voice(voice_path)

            label = ""
            
            if message_type == 11 and should_render_media: 
                return self._sanitize_text(message)
            elif message_type in (3, 5, 8, 13) and should_render_media and self.cached_media_path:
                return self._sanitize_text(message)
            elif message_type == 9:
                raw_label = self.plugin.get_setting("attach_label_file", "[{name}.{ext} {size}]")
                if document:
                    label = self._format_file_metadata(document, raw_label)
                else:
                    label = self.plugin.get_setting("attach_label_none", "[вложение]")
            elif message_type == 2 and transcription:
                label = transcription
            elif message_type == 15 or message_type == 25:
                label = "" 
            elif message_type in range(1, 31):
                label = self.plugin.get_attach_label(message_type)

            if is_emoji_only_message:
                label = ""

            if label:
                if message:
                    message = str(label) + "\n" + message
                else:
                    message = str(label)
            
            return self._sanitize_text(message)
        except Exception as e:
            qlog(f"[ERROR] get_quote_message failed", e)
            return self._sanitize_text(message)
            
    def _init_replyer_id(self):
        replyer = self._get_replyer()
        replyer_peer = replyer.from_id
        
        if replyer.fwd_from is not None:
            replyer_peer = replyer.fwd_from.from_id
            
            if replyer.fwd_from.from_id is None:
                if hasattr(replyer.fwd_from, 'from_name') and replyer.fwd_from.from_name:
                    self.replyer.name = replyer.fwd_from.from_name
                elif hasattr(replyer.fwd_from, 'saved_from_name') and replyer.fwd_from.saved_from_name:
                    self.replyer.name = replyer.fwd_from.saved_from_name
        
        return ReplyerID(replyer_peer)

    def _get_full_replyer_name(self):
        if self.user:
            first_name = self.user.first_name or ""
            last_name = self.user.last_name or ""
            
            ignore_last_name = self.plugin.get_setting("ignore_last_name", False)
            if ignore_last_name:
                last_name = ""

            emoji_suffix = ""
            try:
                if self.plugin.get_setting("show_name_emoji", False) and hasattr(self.user, 'emoji_status') and self.user.emoji_status:
                    doc_id = getattr(self.user.emoji_status, 'document_id', None)
                    if doc_id:
                        emoji_suffix = f" [CEMOJI:{doc_id}]"
            except Exception:
                pass

            use_contact_data = self.plugin.get_setting("use_contact_data", True)
            if not use_contact_data and self.user.username:
                if not first_name and not last_name:
                    return self._sanitize_text(self.user.username) + emoji_suffix
            
            full_name = " ".join(filter(None, [first_name, last_name])).strip()
            if full_name:
                return self._sanitize_text(full_name) + emoji_suffix
        
        if self.replyer and self.replyer.name:
            return self._sanitize_text(self.replyer.name)
            
        return "Unknown"

    def _get_replyer(self):
        return self.params.replyToMsg.messageOwner

    def _get_replyer_id(self):
        return self.replyer_id.get_id()

    def _handle_user_photos_callback(self, response, error):
        if error or not response or not hasattr(response, 'photos') or response.photos.size() == 0:
            if not self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                self._create_quote_without_input(skip_service_fallback=True)
            return

        try:
            photo = response.photos.get(0)
            target_cache_file = None

            temp_dir = Filesystem.get_temp_dir()
            avatars_dir = os.path.join(temp_dir, "avatars_cache")
            if not os.path.exists(avatars_dir):
                os.makedirs(avatars_dir)
            
            photo_id = getattr(photo, 'id', 0)
            if photo_id != 0:
                cache_path = os.path.join(avatars_dir, f"u_{photo_id}.jpg")
                target_cache_file = File(cache_path)

            sorted_sizes = [s for s in photo.sizes if isinstance(s, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive))]
            sorted_sizes.sort(key=lambda s: s.w * s.h, reverse=True)

            if not sorted_sizes:
                return self._fetch_avatar_via_web(self.user)

            best_size = sorted_sizes[0]

            current_account = UserConfig.selectedAccount
            file_loader = FileLoader.getInstance(current_account)
            file_path_obj = file_loader.getPathToAttach(best_size, True)
            if file_path_obj and file_path_obj.exists() and file_path_obj.length() > 0:
                import shutil
                dest = target_cache_file.getAbsolutePath() if target_cache_file else Filesystem.get_absolute_path(temp_dir, f"temp_{uuid.uuid4()}.jpg")
                shutil.copy2(file_path_obj.getAbsolutePath(), dest)
                self._create_and_send_image(
                    image_path=dest,
                    output_path=Filesystem.get_absolute_path(temp_dir, f"quote_{uuid.uuid4()}.jpg"),
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
                return

            req = TLRPC.TL_upload_getFile()
            input_file = TelegramUtils.create_input_location(photo, best_size)
            req.location = input_file
            req.offset = 0
            req.limit = 1024 * 1024 * 4
            send_request(req, RequestCallback(lambda r, e: self._handle_get_file_callback(r, e, target_cache_file)))
        except Exception:
            return self._fetch_avatar_via_web(self.user)

    def _try_fetch_username_avatar(self, username):
        if username == FALLBACK_AVATAR_USERNAME:
            temp_dir = Filesystem.get_temp_dir()
            cache_path = os.path.join(temp_dir, "fallback_cache.jpg")
            
            if os.path.exists(cache_path) and os.path.getsize(cache_path) > 0:
                self._create_and_send_image(
                    image_path=cache_path,
                    output_path=Filesystem.get_absolute_path(temp_dir, f"quote_fb_{uuid.uuid4()}.jpg"),
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
                return True

            self.plugin._ensure_fallback_avatar_cached()

            for _ in range(50):
                if os.path.exists(cache_path) and os.path.getsize(cache_path) > 0:
                    self._create_and_send_image(
                        image_path=cache_path,
                        output_path=Filesystem.get_absolute_path(temp_dir, f"quote_fb_{uuid.uuid4()}.jpg"),
                        author=self._get_author(),
                        quote=self._get_quote_message(),
                        layout_vertical=(self.layout_index == 1)
                    )
                    return True
                time.sleep(0.1)
            return False

        try:
            if username.startswith("+"):
                req = TLRPC.TL_contacts_resolvePhone()
                req.phone = username
                send_request(req, RequestCallback(self._resolve_username_callback))
            else:
                req = TLRPC.TL_contacts_resolveUsername()
                req.username = username
                send_request(req, RequestCallback(self._resolve_username_callback))
            return True
        except Exception:
            return False

    def _resolve_username_callback(self, response, error):
        try:
            if error or not response:
                return self._create_quote_without_input(skip_service_fallback=True)
            try:
                if hasattr(response, "users") and response.users is not None and response.users.size() > 0:
                    u = response.users.get(0)
                    input_user = get_messages_controller().getInputUser(u.id)
                    if input_user is not None:
                        req = TLRPC.TL_photos_getUserPhotos()
                        req.user_id = input_user
                        req.limit = 1
                        send_request(req, RequestCallback(self._fallback_user_photos_callback))
                        return
            except Exception:
                pass
            try:
                if hasattr(response, "chats") and response.chats is not None and response.chats.size() > 0:
                    chat = response.chats.get(0)
                    if chat.photo is not None and chat.photo.photo_id != 0:
                        TelegramUtils.get_chat_thumbnail(chat, response.peer, self._handle_get_file_callback)
                        return
            except Exception:
                pass
            self._create_quote_without_input(skip_service_fallback=True)
        except Exception:
            self._create_quote_without_input(skip_service_fallback=True)

    def _fallback_user_photos_callback(self, response, error):
        def run():
            try:
                if not error and response:
                    try:
                        if response.photos is not None and response.photos.size() > 0:
                            photo = response.photos.get(0)
                            best_size = None
                            current_account = UserConfig.selectedAccount
                            file_loader = FileLoader.getInstance(current_account)

                            for size in photo.sizes:
                                if isinstance(size, (TLRPC.TL_photoSize, TLRPC.TL_photoSizeProgressive)):
                                    if best_size is None or size.w > best_size.w:
                                        best_size = size

                            if best_size:
                                file_path_obj = file_loader.getPathToAttach(best_size, True)
                                if file_path_obj and file_path_obj.exists():
                                    with open(file_path_obj.getAbsolutePath(), "rb") as f:
                                        content = f.read()
                                    self._handle_get_file_callback_direct(content)
                                    return

                            if not best_size:
                               return self._create_quote_without_input(skip_service_fallback=True)
                            
                            req = TLRPC.TL_upload_getFile()
                            cb = RequestCallback(self._handle_get_file_callback)
                            input_file = TelegramUtils.create_input_location(photo, best_size)
                            req.location = input_file
                            req.offset = 0
                            req.limit = 1024 * 1024 * 4
                            send_request(req, cb)
                            return
                    except Exception:
                        pass
                self._create_quote_without_input(skip_service_fallback=True)
            except Exception:
                self._create_quote_without_input(skip_service_fallback=True)
        threading.Thread(target=run).start()

    def _handle_get_file_callback(self, response, error, target_cache_file=None, custom_cache_path=None):
        resp_bytes = None
        try:
            if response and hasattr(response, 'bytes'):
                resp_bytes = response.bytes
        except Exception:
            pass

        if error or not response or resp_bytes is None:
            if self.user:
                return self._fetch_avatar_via_web(self.user, custom_cache_path)
            else:
                return self._create_quote_without_input(skip_service_fallback=True)
        try:
            buffer = resp_bytes.buffer
            buffer.rewind()
            length = buffer.remaining()
            py_bytes = bytes([buffer.get() & 0xFF for _ in range(length)])
            
            final_image_path = custom_cache_path
            if not final_image_path:
                user_id = self.user.id if self.user else uuid.uuid4()
                final_image_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"temp_dl_{user_id}_{uuid.uuid4()}.jpg")
            
            Filesystem.write_file(final_image_path, py_bytes)
            if target_cache_file:
                try:
                    Filesystem.write_file(target_cache_file.getAbsolutePath(), py_bytes)
                except Exception:
                    pass
            
            quote_output_path = Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"quote_{uuid.uuid4()}.jpg")
            
            self._create_and_send_image(
                image_path=final_image_path,
                output_path=quote_output_path,
                author=self._get_author(),
                quote=self._get_quote_message(),
                layout_vertical=(self.layout_index == 1)
            )
        except Exception:
            if self.user:
                return self._fetch_avatar_via_web(self.user, custom_cache_path)
            return self._create_quote_without_input(skip_service_fallback=True)

    def _create_quote_without_input(self, skip_service_fallback=False):
        def run():
            try:
                use_custom_avatar = self.plugin.get_setting("avatar_use_custom", False)
                
                if (use_custom_avatar or self.force_custom_avatar) and self.custom_avatar_path and os.path.exists(self.custom_avatar_path):
                     self._create_and_send_image(
                        image_path=self.custom_avatar_path,
                        output_path=Filesystem.get_absolute_path(Filesystem.get_temp_dir(), f"tmp_custom_{uuid.uuid4()}.jpg"),
                        author=self._get_author(),
                        quote=self._get_quote_message(),
                        layout_vertical=(self.layout_index == 1)
                     )
                     return
 
                if not self.force_custom_avatar and not skip_service_fallback:
                    if self._try_fetch_username_avatar(FALLBACK_AVATAR_USERNAME):
                        return
      
                user_or_chat_id = -1
                if self.user:
                    user_or_chat_id = self.user.id
                elif self.replyer_id:
                    user_or_chat_id = self._get_replyer_id()
                else:
                    user_or_chat_id = uuid.uuid4()
        
                tmp_file = f"tmp_{user_or_chat_id}.jpg"
                temp_dir = Filesystem.get_temp_dir()
                file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
                
                self._create_and_send_image(
                    output_path=file_path,
                    author=self._get_author(),
                    quote=self._get_quote_message(),
                    layout_vertical=(self.layout_index == 1)
                )
        
            except Exception:
                pass
        threading.Thread(target=run).start()

    def _create_color_background(self, width, height, use_random_bg, custom_bg_color):
        if use_random_bg:
            bg_color = tuple(random.randint(100, 255) for _ in range(3))
        else:
            bg_color = self.plugin._parse_hex_color(custom_bg_color, (0, 0, 0))
        return Image.new("RGB", (width, height), bg_color)

    def _apply_bg_style_beta(self, image, width, height, style):
        try:
            if style == 5:
                use_random_bg = self.plugin.get_setting("use_random_bg", True)
                custom_bg_color = self.plugin.get_setting("custom_bg_color", "#000000")
                if use_random_bg:
                    bg_color = tuple(random.randint(100, 255) for _ in range(3))
                else:
                    bg_color = self.plugin._parse_hex_color(custom_bg_color, (0, 0, 0))
                image = Image.new("RGB", (width, height), bg_color)
                result = image
            else:
                img_w, img_h = image.size
                scale = max(width / img_w, height / img_h)
                new_w, new_h = int(img_w * scale), int(img_h * scale)
                resized = image.resize((new_w, new_h), Image.LANCZOS)
                left = (new_w - width) // 2
                top = (new_h - height) // 2
                cropped = resized.crop((left, top, left + width, top + height))
        
                if style == 0:
                    result = cropped.convert("RGB")
                elif style == 1:
                    radius = int(self.plugin.get_setting("bg_blur_radius", "60"))
                    result = cropped.filter(ImageFilter.GaussianBlur(radius))
                elif style == 2:
                    radius = int(self.plugin.get_setting("bg_glass_blur_radius", "60"))
                    opacity = int(self.plugin.get_setting("bg_glass_opacity", "80"))
                    result = cropped.filter(ImageFilter.GaussianBlur(radius))
                    overlay = Image.new("RGBA", (width, height), (255, 255, 255, opacity))
                    result = Image.alpha_composite(result.convert("RGBA"), overlay).convert("RGB")
                elif style == 3:
                    noise_intensity = int(self.plugin.get_setting("bg_tv_noise_intensity", "60"))
                    result = cropped.filter(ImageFilter.GaussianBlur(5)).convert("RGBA")
                    
                    small_w = width // 4
                    small_h = height // 4
                    noise_bytes = os.urandom(small_w * small_h)
                    noise = Image.frombytes("L", (small_w, small_h), noise_bytes)
                    noise = noise.resize((width, height), Image.NEAREST)
                    
                    noise_overlay = Image.new("RGBA", (width, height), (0, 0, 0, 0))
                    mask = noise.point(lambda p: int(p * (noise_intensity / 255.0) * 0.5))
                    noise_overlay.putalpha(mask)
                    
                    result = Image.alpha_composite(result, noise_overlay).convert("RGB")
                elif style == 4:
                    pixel_size = int(self.plugin.get_setting("bg_pixel_size", "20"))
                    pixel_size = max(1, pixel_size)
                    small = cropped.resize((width // pixel_size, height // pixel_size), Image.NEAREST)
                    result = small.resize((width, height), Image.NEAREST)
                elif style == 6:
                    color1_hex = self.plugin.get_setting("bg_gradient_color1", "#FF8040")
                    color2_hex = self.plugin.get_setting("bg_gradient_color2", "#8040FF")
                    color1 = self.plugin._parse_hex_color(color1_hex, (255, 128, 64))
                    color2 = self.plugin._parse_hex_color(color2_hex, (128, 64, 255))
                    result = Image.new("RGB", (width, height))
                    draw = ImageDraw.Draw(result)
                    for i in range(width):
                        ratio = i / width
                        r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
                        g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
                        b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
                        draw.line([(i, 0), (i, height)], fill=(r, g, b))
                elif style == 7:
                    amplitude = float(self.plugin.get_setting("bg_waves_amplitude", "5"))
                    frequency = float(self.plugin.get_setting("bg_waves_frequency", "0.1"))
                    result = cropped.copy()
                    for y in range(height):
                        shift = int(amplitude * math.sin(y * frequency))
                        region = result.crop((0, y, width, y + 1))
                        result.paste(region, (shift, y))
                    result = result.filter(ImageFilter.GaussianBlur(3))
                else:
                    result = cropped.filter(ImageFilter.GaussianBlur(20))
            
            dimming_value = int(self.plugin.get_setting("bg_dimming", "70"))
            if dimming_value <= 0:
                dimming_value = 1
            dimming_value = min(100, dimming_value)
            
            alpha = int(dimming_value / 100 * 255)
            if alpha > 0:
                overlay = Image.new("RGBA", (width, height), (0, 0, 0, alpha))
                if result.mode != 'RGBA':
                    result = result.convert('RGBA')
                result = Image.alpha_composite(result, overlay).convert("RGB")
            return result
        except (ValueError, TypeError) as e:
            qlog(f"BG style value error: {e}")
            return Image.new("RGB", (width, height), (0, 0, 0))
        except Exception as e:
            qlog(f"BG style error: {e}")
            traceback.print_exc()
            return Image.new("RGB", (width, height), (0, 0, 0))

    def _apply_bg_filter_beta(self, image, filter_type):
        try:
            if filter_type == 0:
                return image
            if image.mode != 'RGB':
                image = image.convert('RGB')
            if filter_type == 1:
                return ImageOps.grayscale(image).convert('RGB')
            elif filter_type == 2:
                grayscale = ImageOps.grayscale(image)
                sepia = Image.new('RGB', grayscale.size)
                pixels = grayscale.load()
                sepia_pixels = sepia.load()
                for x in range(grayscale.size[0]):
                    for y in range(grayscale.size[1]):
                        gray = pixels[x, y]
                        r = min(255, int(gray * 1.1))
                        g = min(255, int(gray * 0.9))
                        b = min(255, int(gray * 0.7))
                        sepia_pixels[x, y] = (r, g, b)
                return sepia
            elif filter_type == 3:
                return ImageOps.invert(image)
            elif filter_type == 4:
                levels = int(self.plugin.get_setting("filter_posterize_levels", "4"))
                levels = max(2, min(8, levels))
                posterized = image.copy()
                pixels = posterized.load()
                for x in range(posterized.size[0]):
                    for y in range(posterized.size[1]):
                        r, g, b = pixels[x, y]
                        r = int(round(r / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        g = int(round(g / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        b = int(round(b / 255.0 * (levels - 1))) * int(255 / (levels - 1))
                        pixels[x, y] = (r, g, b)
                return posterized
            elif filter_type == 5:
                black_hex = self.plugin.get_setting("filter_colorize_black", "#000000")
                white_hex = self.plugin.get_setting("filter_colorize_white", "#FFD700")
                black_color = self.plugin._parse_hex_color(black_hex, (0,0,0))
                white_color = self.plugin._parse_hex_color(white_hex, (255,215,0))
                grayscale = ImageOps.grayscale(image)
                return ImageOps.colorize(grayscale, black=black_color, white=white_color).convert('RGB')
            elif filter_type == 6:
                factor = float(self.plugin.get_setting("filter_contrast_factor", "2.0"))
                enhancer = ImageEnhance.Contrast(image)
                return enhancer.enhance(factor)
            elif filter_type == 7:
                return image.filter(ImageFilter.EMBOSS)
            else:
                return image
        except (ValueError, TypeError) as e:
            qlog(f"BG filter value error: {e}")
            return image
        except Exception as e:
            qlog(f"BG filter error: {e}")
            return image

    def _get_profile_color(self):
        user_id = 0
        if self.user:
            user_id = self.user.id
        elif self.replyer_id:
            user_id = self._get_replyer_id()
        
        if user_id == 0:
            return self.plugin._parse_hex_color("#B4B4B4", (180, 180, 180))

        color_index = abs(user_id) % 7
        
        colors = [
            "#FF516A", 
            "#FF885E", 
            "#8E85EE", 
            "#53ED97", 
            "#28C9B7", 
            "#549CFC", 
            "#FF7CA8"  
        ]
        
        hex_color = colors[color_index]
        return self.plugin._parse_hex_color(hex_color, (180, 180, 180))

    def _create_and_send_image(self, image_path=None, output_path="quote.jpg", author="", quote="", layout_vertical=False):
        with self.finalize_lock:
            if self.is_finalized:
                return
            self.is_finalized = True

        extended_logs = self.plugin.get_setting("extended_logging", False)
        
        qlog("="*40)
        qlog(f"[RENDER] Starting Render process")
        qlog(f"[RENDER] Output Path: {output_path}")
        qlog(f"[RENDER] Author: {author}")
        
        font_index = self.plugin.get_setting("font", 1)
        quote_style = self.plugin.get_setting("quote_style", 0)
        bg_style = self.plugin.get_setting("bg_style", 0)
        
        try:
            attached_media_path = self._fetch_attached_media()
            selected_font = FontManager.get(font_index, self.plugin)
            font_path = selected_font.get_path()
            
            is_cloud_style = (quote_style == 3)
            
            if quote_style == 2:
                layout_vertical = True
                avatar_position = 0 
            elif is_cloud_style:
                layout_vertical = False
                avatar_position = 0 
            else:
                layout_vertical = False
                avatar_position = quote_style

            try:
                if is_cloud_style:
                    quote_font_size = int(self.plugin.get_setting("cloud_quote_font_size", "36"))
                    author_font_size = int(self.plugin.get_setting("cloud_author_font_size", "28"))
                else:
                    quote_font_size = int(self.plugin.get_setting("quote_font_size", "36"))
                    author_font_size = int(self.plugin.get_setting("author_font_size", "28"))
                line_spacing = int(self.plugin.get_setting("line_spacing", "10"))
            except (ValueError, TypeError):
                quote_font_size = 40
                author_font_size = 32
                line_spacing = 0
                            
            text_color_hex = self.plugin.get_setting("text_color_hex", "#FFFFFF")
            author_color_hex = self.plugin.get_setting("author_color_hex", "#B4B4B4")
            text_color = self.plugin._parse_hex_color(text_color_hex, (255, 255, 255))
            
            use_profile_color = self.plugin.get_setting("use_profile_color", True)
            if use_profile_color:
                author_color = self._get_profile_color()
            else:
                author_color = self.plugin._parse_hex_color(author_color_hex, (180, 180, 180))
            
            try:
                cloud_opacity = int(self.plugin.get_setting("cloud_bubble_opacity", "80"))
                cloud_opacity = max(0, min(100, cloud_opacity))
                cloud_opacity = int(cloud_opacity * 2.55)
            except: 
                cloud_opacity = 204
            
            cloud_bubble_color_hex = self.plugin.get_setting("cloud_bubble_color", "#1E1E1E")
            bubble_color_rgb = self.plugin._parse_hex_color(cloud_bubble_color_hex, (30, 30, 30))
            bubble_color = bubble_color_rgb + (cloud_opacity,)
            
            if is_cloud_style:
                if use_profile_color:
                    author_color = self._get_profile_color()
                
            show_avatar = self.plugin.get_setting("show_avatar", True)
            
            try:
                if is_cloud_style:
                    avatar_size = int(self.plugin.get_setting("cloud_avatar_size", "80"))
                else:
                    avatar_size = int(self.plugin.get_setting("avatar_size", "400"))
                avatar_size = max(50, min(400, avatar_size))
            except:
                avatar_size = 80 if is_cloud_style else 400
            
            try:
                avatar_rounding_percent = int(self.plugin.get_setting("avatar_rounding", "100"))
                avatar_rounding_percent = max(0, min(100, avatar_rounding_percent))
                avatar_rounding = int((avatar_rounding_percent / 100.0) * (avatar_size // 2))
            except:
                avatar_rounding = avatar_size // 2

            bg_style = self.plugin.get_setting("bg_style", 0)
            bg_filter = self.plugin.get_setting("bg_filter", 0)
            use_random_bg = self.plugin.get_setting("use_random_bg", True)
            custom_bg_color = self.plugin.get_setting("custom_bg_color", "#000000")
    
            attached_img = None
            if attached_media_path:
                try:
                    attached_img = Image.open(attached_media_path).convert("RGBA")
                    try:
                        reduction_pct = int(self.plugin.get_setting("quote_text_reduction", "14"))
                        reduction_factor = 1.0 - (max(0, min(90, reduction_pct)) / 100.0)
                        quote_font_size = int(quote_font_size * reduction_factor)
                    except: pass
                except Exception as e:
                    if extended_logs: qlog(f"[ERROR] Failed to open attached media: {e}")
                    attached_img = None
    
            try:
                quote_font = ImageFont.truetype(font_path, quote_font_size)
                author_font = ImageFont.truetype(font_path, author_font_size)
            except:
                try:
                    quote_font = ImageFont.load_default()
                    author_font = ImageFont.load_default()
                except: return
    
            temp_img = Image.new("RGB", (1, 1))
            temp_draw = ImageDraw.Draw(temp_img)
            
            safe_author = str(author) if author is not None else ""
            
            if is_cloud_style:
                prefix = self.plugin.get_setting("cloud_author_prefix", "")
                author_text = f"{prefix}{safe_author.strip()}"
            else:
                prefix = self.plugin.get_setting("author_prefix", "— ")
                author_text = f"{prefix}{safe_author.strip()}"
            
            canvas_width = 1200
            padding = 50
            bubble_padding = 40 if is_cloud_style else 0
            
            att_img_processed = None
            att_w, att_h = 0, 0
            
            if attached_img:
                available_w = canvas_width - (padding * 2)
                if not layout_vertical and show_avatar:
                    available_w -= (avatar_size + padding)
                if is_cloud_style:
                    available_w -= (bubble_padding * 2)
    
                try:
                    if layout_vertical:
                        scale_percent = int(self.plugin.get_setting("quote_image_size_vertical", "70"))
                    elif not is_cloud_style:
                        scale_percent = int(self.plugin.get_setting("quote_image_size_horizontal", "100"))
                    else:
                        scale_percent = 100
                    scale_factor = max(10, min(100, scale_percent)) / 100.0
                except:
                    scale_factor = 0.8 if layout_vertical else 1.0
                
                target_w = int(available_w * scale_factor)
                orig_w, orig_h = attached_img.size
                ratio = target_w / float(orig_w)
                att_w = int(orig_w * ratio)
                att_h = int(orig_h * ratio)
                
                if att_h > 1200: 
                    ratio = 1200 / float(att_h)
                    att_w = int(att_w * ratio)
                    att_h = 1200
    
                att_img_processed = attached_img.resize((att_w, att_h), Image.LANCZOS)
                
                try:
                    if getattr(self, 'is_round_media', False):
                        radius_percent = 50
                    else:
                        radius_percent = int(self.plugin.get_setting("quote_image_radius", "3"))
                        radius_percent = max(0, min(100, radius_percent))
                    if radius_percent > 0:
                        radius_pixels = int(min(att_w, att_h) * radius_percent / 100.0)
                        mask = Image.new("L", (att_w, att_h), 0)
                        mdraw = ImageDraw.Draw(mask)
                        mdraw.rounded_rectangle((0, 0, att_w, att_h), radius=radius_pixels, fill=255)
                        
                        if att_img_processed.mode == 'RGBA':
                            current_alpha = att_img_processed.split()[3]
                            mask = Image.composite(current_alpha, Image.new("L", (att_w, att_h), 0), mask)
                            
                        att_img_processed.putalpha(mask)
                except: pass

            max_text_width = canvas_width - padding * 2
            if not layout_vertical and show_avatar:
                max_text_width -= (avatar_size + padding)
            if is_cloud_style:
                left_offset = padding
                max_text_width -= (bubble_padding * 2)
                
            prefetch_list = [(quote, quote_font), (author_text, author_font)]
            try:
                if getattr(self, 'reply_message_text', None): prefetch_list.append((self.reply_message_text, reply_text_font))
                if getattr(self, 'reply_author_name', None): prefetch_list.append((self.reply_author_name, reply_name_font))
            except: pass
            
            self._prefetch_all_emojis(prefetch_list)
            
            wrapped_quote = self._wrap_text(temp_draw, quote, quote_font, max_text_width)
            quote_width, quote_height = self._measure_text_dimensions(temp_draw, wrapped_quote, quote_font, line_spacing)

            wrapped_author = self._wrap_text(temp_draw, author_text, author_font, max_text_width)
            author_width, author_height = self._measure_text_dimensions(temp_draw, wrapped_author, author_font, line_spacing)
            
            if is_cloud_style:
                content_height = quote_height + author_height + 20
            else:
                content_height = quote_height + author_height
                
            if att_img_processed:
                content_height += att_h
                
            if is_cloud_style:
                if att_img_processed:
                    content_height += int(bubble_padding * 2.2)
                else:
                    content_height += int(bubble_padding * 1.6)
                    
            if layout_vertical:
                 if show_avatar:
                    content_height += avatar_size + padding
            else:
                 content_height = max(content_height, avatar_size)
            
            canvas_height = int(content_height + padding * 2)
            canvas_height = max(600, canvas_height)
            
            bg_source_path = None
            avatar_source_path = None
            
            if not self.force_custom_bg and not self.force_custom_avatar:
                if image_path and os.path.exists(image_path):
                    bg_source_path = image_path
                avatar_source_path = image_path
            elif self.force_custom_bg and not self.force_custom_avatar:
                if self.custom_bg_path and os.path.exists(self.custom_bg_path): bg_source_path = self.custom_bg_path
                if image_path and os.path.exists(image_path): avatar_source_path = image_path
            elif not self.force_custom_bg and self.force_custom_avatar:
                if image_path and os.path.exists(image_path): bg_source_path = image_path
                if self.custom_avatar_path and os.path.exists(self.custom_avatar_path): avatar_source_path = self.custom_avatar_path
            else:
                if self.custom_bg_path and os.path.exists(self.custom_bg_path): bg_source_path = self.custom_bg_path
                if self.custom_avatar_path and os.path.exists(self.custom_avatar_path): avatar_source_path = self.custom_avatar_path

            if not bg_source_path and avatar_source_path and os.path.exists(avatar_source_path):
                bg_source_path = avatar_source_path
    
            if bg_source_path:
                try:
                    orig_img = Image.open(bg_source_path).convert("RGBA")
                    canvas = self._apply_bg_style_beta(orig_img, canvas_width, canvas_height, bg_style)
                    if bg_filter > 0: canvas = self._apply_bg_filter_beta(canvas, bg_filter)
                except:
                    canvas = self._create_color_background(canvas_width, canvas_height, use_random_bg, custom_bg_color)
            else:
                canvas = self._create_color_background(canvas_width, canvas_height, use_random_bg, custom_bg_color)
    
            avatar_img = None
            if show_avatar:
                if avatar_source_path and os.path.exists(avatar_source_path):
                    try:
                        temp_ava = Image.open(avatar_source_path).convert("RGBA")
                        temp_ava = temp_ava.resize((avatar_size, avatar_size), Image.LANCZOS)
                        mask = Image.new("L", temp_ava.size, 0)
                        mask_draw = ImageDraw.Draw(mask)
                        if avatar_rounding_percent == 100:
                            mask_draw.ellipse((0, 0, avatar_size, avatar_size), fill=255)
                        elif avatar_rounding_percent == 0:
                            mask_draw.rectangle((0, 0, avatar_size, avatar_size), fill=255)
                        else:
                            mask_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=255)
                        temp_ava.putalpha(mask)
                        avatar_img = temp_ava
                    except Exception as e:
                        avatar_img = None
                
                if not avatar_img:
                    try:
                        temp_ava = Image.new("RGBA", (avatar_size, avatar_size), (0, 0, 0, 0))
                        avatar_draw = ImageDraw.Draw(temp_ava)
                        circle_color = tuple(random.randint(100, 255) for _ in range(3))
                        if avatar_rounding_percent == 100:
                            avatar_draw.ellipse((0, 0, avatar_size, avatar_size), fill=circle_color)
                        elif avatar_rounding_percent == 0:
                            avatar_draw.rectangle((0, 0, avatar_size, avatar_size), fill=circle_color)
                        else:
                            avatar_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=circle_color)
                        try:
                            letter_font = ImageFont.truetype(font_path, int(avatar_size * 0.4))
                            base_author = safe_author.strip()
                            letter = base_author[0].upper() if base_author else "?"
                            bbox = avatar_draw.textbbox((0, 0), letter, font=letter_font)
                            w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
                            avatar_draw.text(((avatar_size - w) // 2, (avatar_size - h) // 2), letter, font=letter_font, fill=(255, 255, 255))
                        except: pass
                        mask = Image.new("L", temp_ava.size, 0)
                        mask_draw = ImageDraw.Draw(mask)
                        if avatar_rounding_percent == 100:
                            mask_draw.ellipse((0, 0, avatar_size, avatar_size), fill=255)
                        elif avatar_rounding_percent == 0:
                            mask_draw.rectangle((0, 0, avatar_size, avatar_size), fill=255)
                        else:
                            mask_draw.rounded_rectangle((0, 0, avatar_size, avatar_size), radius=avatar_rounding, fill=255)
                        temp_ava.putalpha(mask)
                        avatar_img = temp_ava
                    except Exception:
                        avatar_img = None

            draw = ImageDraw.Draw(canvas, 'RGBA')

            if is_cloud_style:
                left_offset = padding
                if show_avatar and avatar_img:
                    ava_x = padding
                    content_total_h = content_height
                    start_y = (canvas_height - content_total_h) // 2
                    ava_y = start_y + content_total_h - avatar_size
                    canvas.paste(avatar_img, (ava_x, ava_y), avatar_img)
                    left_offset = ava_x + avatar_size + 15
                
                content_total_h = content_height
                start_y = (canvas_height - content_total_h) // 2
                bubble_x1 = left_offset
                bubble_y1 = start_y
                max_content_w = max(quote_width, author_width)
                if att_img_processed: 
                    max_content_w = max(max_content_w, att_w)
                bubble_w = max_content_w + (bubble_padding * 2)
                bubble_h = content_total_h
                bubble_x2 = bubble_x1 + bubble_w
                bubble_y2 = bubble_y1 + bubble_h
            
                if show_avatar:
                    tail_coords = [(bubble_x1, bubble_y2 - 20), (bubble_x1 - 10, bubble_y2), (bubble_x1 + 20, bubble_y2)]
                    draw.polygon(tail_coords, fill=bubble_color)
                draw.rounded_rectangle((bubble_x1, bubble_y1, bubble_x2, bubble_y2), radius=30, fill=bubble_color)
                text_x = bubble_x1 + bubble_padding
                current_y = bubble_y1 + bubble_padding
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_author, author_font, author_color, line_spacing, max_width=author_width)
                current_y += author_height + 17
                
                if att_img_processed:
                    canvas.paste(att_img_processed, (text_x, current_y), att_img_processed)
                    current_y += att_h + 15
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, max_width=quote_width)

            elif layout_vertical:
                total_content_h = quote_height + author_height + 16
                if show_avatar and avatar_img:
                    total_content_h += avatar_size + 25
                if att_img_processed:
                    total_content_h += att_h + 15
            
                current_y = (canvas_height - total_content_h) // 2
                        
                if not att_img_processed: 
                    if current_y > 54:
                        current_y += 23
                        
                align_idx = self.plugin.get_setting("vertical_text_align", 1)
                align_map = {0: "left", 1: "center", 2: "right"}
                text_align = align_map.get(align_idx, "center")
                
                if show_avatar and avatar_img:
                    img_x = (canvas_width - avatar_size) // 2
                    canvas.paste(avatar_img, (img_x, current_y), avatar_img)
                    current_y += avatar_size + 24
                
                if att_img_processed: 
                    att_x = (canvas_width - att_w) // 2
                    canvas.paste(att_img_processed, (att_x, current_y), att_img_processed)
                    current_y += att_h + 16
                
                text_x = (canvas_width - quote_width) // 2
                author_x = (canvas_width - author_width) // 2
            
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, align=text_align, max_width=quote_width)
                current_y += quote_height + 10
                self._draw_text_with_emoji(canvas, draw, (author_x, current_y), wrapped_author, author_font, author_color, line_spacing, align=text_align, max_width=author_width)

            else:
                text_align = "left"
                left_offset = padding
                if show_avatar and avatar_img:
                    if avatar_position == 0:
                        img_x = padding
                        left_offset = img_x + avatar_size + padding
                    else:
                        img_x = canvas_width - avatar_size - padding
                        left_offset = padding
                        text_align = "right"
                    img_y = (canvas_height - avatar_size) // 2
                    canvas.paste(avatar_img, (img_x, img_y), avatar_img)
                
                content_block_h = quote_height + 6 + author_height
                if att_img_processed:
                    content_block_h += att_h + 14
                current_y = (canvas_height - content_block_h) // 2
                
                text_x = left_offset
                author_x = left_offset
                att_x = left_offset
                
                if text_align == "right":
                    right_boundary = img_x - padding
                    text_x = right_boundary - quote_width
                    author_x = right_boundary - author_width
                    if att_img_processed:
                        att_x = right_boundary - att_w
                
                if att_img_processed: 
                    canvas.paste(att_img_processed, (att_x, current_y), att_img_processed)
                    current_y += att_h + 10
                
                self._draw_text_with_emoji(canvas, draw, (text_x, current_y), wrapped_quote, quote_font, text_color, line_spacing, align=text_align, max_width=quote_width)
                current_y += quote_height + 4
                self._draw_text_with_emoji(canvas, draw, (author_x, current_y), wrapped_author, author_font, author_color, line_spacing, align=text_align, max_width=author_width)

            canvas.save(output_path, quality=95, optimize=True)
            self._send_quote(output_path, len(quote))
        except Exception as e:
            qlog("CRITICAL ERROR in create_and_send_image", e)
            copy_error_to_clipboard(traceback.format_exc())

    def _send_quote(self, output_path, text_len=0):
        import os
        import time
        import shutil
        dir_name = os.path.dirname(str(output_path))
        ext = os.path.splitext(str(output_path))[1]
        new_name = time.strftime("Quotify_%y%m%d_%H%M%S") + ext
        new_path = os.path.join(dir_name, new_name)
        if str(output_path) != new_path:
            shutil.move(str(output_path), new_path)
            output_path = new_path
            
        plugin_ref = getattr(self, 'plugin', getattr(self, 'pl', getattr(self, '_plugin', None)))
        
        if getattr(self, 'force_preview', False):
            action = 0
        else:
            action = plugin_ref.get_setting("after_gen_action", 0) if plugin_ref else 0
            
        if action == 0:
            from android_utils import run_on_ui_thread
            run_on_ui_thread(lambda: self._show_preview(output_path))
        elif action == 1:
            self._send_final(output_path, "", "photo")
        elif action == 2:
            self._send_final(output_path, "", "file")
        elif action == 3:
            self._send_final(output_path, "", "sticker")

    def _show_preview(self, output_path):
        try:
            from client_utils import get_last_fragment
            from org.telegram.ui.ActionBar import Theme
            from android.widget import LinearLayout, ImageView, EditText, TextView, ScrollView, FrameLayout
            from android.graphics import BitmapFactory, Typeface, Bitmap, Canvas, Paint, RectF, PorterDuffXfermode, PorterDuff, Color
            from android.graphics.drawable import GradientDrawable
            from org.telegram.ui.Components import LayoutHelper
            from android.view import View, Gravity
            from java import dynamic_proxy, jclass
            from org.telegram.messenger import AndroidUtilities
            from android.animation import LayoutTransition
            
            fragment = get_last_fragment()
            if not fragment:
                return
            act = fragment.getParentActivity()
            if not act:
                return
                
            root_layout = LinearLayout(act)
            root_layout.setOrientation(LinearLayout.VERTICAL)
            root_layout.setClickable(True)

            title_tv = TextView(act)
            
            plugin_ref = getattr(self, 'plugin', getattr(self, 'pl', getattr(self, '_plugin', None)))
            hide_comment = plugin_ref.get_setting("preview_hide_comment", False) if plugin_ref else False
            show_comment = not hide_comment
            cmd_text = getattr(plugin_ref, 'last_cmd', '.q') if plugin_ref else '.q'
            
            title_tv.setText(f"Предпросмотр цитаты [{cmd_text}]")
            title_tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            title_tv.setTextSize(1, 20.0)
            title_tv.setTypeface(Typeface.DEFAULT_BOLD)
            title_tv.setGravity(Gravity.CENTER)
            root_layout.addView(title_tv, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 10))

            scroll_view = ScrollView(act)
            scroll_content = LinearLayout(act)
            scroll_content.setOrientation(LinearLayout.VERTICAL)
            
            iv = ImageView(act)
            bmp = BitmapFactory.decodeFile(str(output_path))
            img_w, img_h = 0, 0
            if bmp:
                img_w, img_h = bmp.getWidth(), bmp.getHeight()
                rad = float(AndroidUtilities.dp(12))
                
                out_bmp = Bitmap.createBitmap(img_w, img_h, Bitmap.Config.ARGB_8888)
                canvas = Canvas(out_bmp)
                
                paint = Paint()
                paint.setAntiAlias(True)
                rectF = RectF(0.0, 0.0, float(img_w), float(img_h))
                canvas.drawRoundRect(rectF, rad, rad, paint)
                
                paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.SRC_IN))
                canvas.drawBitmap(bmp, 0.0, 0.0, paint)
                
                iv.setImageBitmap(out_bmp)
                bmp.recycle()
                
            iv.setAdjustViewBounds(True)
            scroll_content.addView(iv, LayoutHelper.createLinear(-1, -2, 12, 4, 12, 0))
            scroll_view.addView(scroll_content)
            
            screen_h = AndroidUtilities.displaySize.y
            screen_w = AndroidUtilities.displaySize.x
            max_h = int(screen_h * 0.55)
            
            dialog_w = screen_w - AndroidUtilities.dp(64)
            expected_img_h = int(img_h * (dialog_w / float(img_w))) if img_w > 0 else 0
            
            if expected_img_h > max_h:
                lp_scroll = LinearLayout.LayoutParams(-1, max_h)
                lp_scroll.weight = 1.0
            else:
                lp_scroll = LinearLayout.LayoutParams(-1, -2)
                
            root_layout.addView(scroll_view, lp_scroll)
            
            caption_input = EditText(act)
            
            if show_comment:
                caption_container = LinearLayout(act)
                caption_container.setOrientation(LinearLayout.VERTICAL)
                
                caption_input.setHint("Добавить комментарий...")
                caption_input.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                caption_input.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
                caption_input.setTextSize(1, 15.0)
                
                input_bg = GradientDrawable()
                bg_color_input = (Theme.getColor(Theme.key_dialogTextBlack) & 0x00FFFFFF) | 0x0C000000
                input_bg.setColor(bg_color_input)
                input_bg.setCornerRadius(AndroidUtilities.dp(6))
                
                caption_input.setBackground(input_bg)
                caption_input.setPadding(AndroidUtilities.dp(18), AndroidUtilities.dp(12), AndroidUtilities.dp(18), AndroidUtilities.dp(12))
                
                caption_container.addView(caption_input, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0))
                root_layout.addView(caption_container, LayoutHelper.createLinear(-1, -2, 12, 4, 12, 0))

            dialog_ref = [None]

            class ClickListener(dynamic_proxy(View.OnClickListener)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                def onClick(self, v):
                    self.fn()
            
            blue_color = Theme.getColor(Theme.key_windowBackgroundWhiteBlueText)
            red_color = Theme.getColor(Theme.key_text_RedRegular)
            
            def make_bg(color_int):
                bg = GradientDrawable()
                bg.setColor((color_int & 0x00FFFFFF) | 0x12000000) 
                bg.setCornerRadius(16.0)
                return bg
              
            btn_text = "Отправить как фото"

            h_layout = LinearLayout(act)
            h_layout.setOrientation(LinearLayout.HORIZONTAL)
            
            transition = LayoutTransition()
            transition.setDuration(150)
            h_layout.setLayoutTransition(transition)
            
            R = jclass("org.telegram.messenger.R")
            
            btn_other = ImageView(act)
            try: btn_other.setImageResource(R.drawable.ic_ab_other)
            except: pass
            btn_other.setColorFilter(blue_color)
            btn_other.setBackground(make_bg(blue_color))
            btn_other.setPadding(AndroidUtilities.dp(11), AndroidUtilities.dp(11), AndroidUtilities.dp(11), AndroidUtilities.dp(11))
            h_layout.addView(btn_other, LayoutHelper.createLinear(46, 46, 0.0, 0, 0, 4, 0))
            
            photo_tv = TextView(act)
            photo_tv.setText(btn_text)
            photo_tv.setTextColor(blue_color)
            photo_tv.setTextSize(1, 15.0)
            photo_tv.setTypeface(Typeface.DEFAULT_BOLD)
            photo_tv.setGravity(Gravity.CENTER)
            photo_tv.setSingleLine(True)
            photo_tv.setBackground(make_bg(blue_color))
                    
            def on_main_click():
                comment = caption_input.getText().toString() if show_comment else ""
                self._send_final(output_path, comment, "photo")
                if dialog_ref[0]: dialog_ref[0].dismiss()

            photo_tv.setOnClickListener(ClickListener(on_main_click))
            h_layout.addView(photo_tv, LayoutHelper.createLinear(0, 46, 1.0, 0, 0, 0, 0))

            options_container = LinearLayout(act)
            options_container.setOrientation(LinearLayout.HORIZONTAL)
            options_container.setVisibility(8) 

            def create_option_btn(icon_names, action_fn, is_last=False):
                btn = ImageView(act)
                for name in icon_names:
                    try:
                        btn.setImageResource(getattr(R.drawable, name))
                        break
                    except: pass
                btn.setColorFilter(blue_color)
                btn.setBackground(make_bg(blue_color))
                btn.setPadding(AndroidUtilities.dp(11), AndroidUtilities.dp(11), AndroidUtilities.dp(11), AndroidUtilities.dp(11))
                
                def click_wrapper():
                    if dialog_ref[0]: dialog_ref[0].dismiss()
                    action_fn()
                
                btn.setOnClickListener(ClickListener(click_wrapper))
                options_container.addView(btn, LayoutHelper.createLinear(0, 46, 1.0, 0, 0, 0 if is_last else 4, 0))

            create_option_btn(["msg_sendfile_solar", "msg_file", "msg_document", "ic_ab_doc"], lambda: self._send_final(output_path, caption_input.getText().toString() if show_comment else "", "file"))
            create_option_btn(["msg_sticker", "ic_smiles_stickers"], lambda: self._send_final(output_path, caption_input.getText().toString() if show_comment else "", "sticker"))
            create_option_btn(["msg_download", "msg_gallery", "ic_photo"], lambda: self._save_to_gallery(output_path, act))
            create_option_btn(["msg_share", "ic_share"], lambda: self._share(output_path, act), is_last=True)
            
            h_layout.addView(options_container, LayoutHelper.createLinear(0, 46, 1.0, 0, 0, 0, 0))

            btn_copy = ImageView(act)
            try: btn_copy.setImageResource(R.drawable.msg_copy)
            except: pass
            btn_copy.setColorFilter(blue_color)
            btn_copy.setBackground(make_bg(blue_color))
            btn_copy.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
            
            def on_copy():
                self._copy_to_clipboard(output_path, act)
                if dialog_ref[0]: dialog_ref[0].dismiss()
                
            btn_copy.setOnClickListener(ClickListener(on_copy))
            h_layout.addView(btn_copy, LayoutHelper.createLinear(46, 46, 0.0, 4, 0, 0, 0))

            root_layout.addView(h_layout, LayoutHelper.createLinear(-1, -2, 12, 4, 12, 4))

            is_expanded = [False]
            def on_other():
                if not is_expanded[0]:
                    photo_tv.setVisibility(8)
                    options_container.setVisibility(0)
                    
                    for name in ["ic_close_white", "msg_close"]:
                        try:
                            btn_other.setImageResource(getattr(R.drawable, name))
                            break
                        except: pass
                    btn_other.setColorFilter(red_color)
                    btn_other.setBackground(make_bg(red_color))
                    is_expanded[0] = True
                else:
                    options_container.setVisibility(8)
                    photo_tv.setVisibility(0)
                    
                    for name in ["ic_ab_other", "msg_more"]:
                        try:
                            btn_other.setImageResource(getattr(R.drawable, name))
                            break
                        except: pass
                    btn_other.setColorFilter(blue_color)
                    btn_other.setBackground(make_bg(blue_color))
                    is_expanded[0] = False
                    
            btn_other.setOnClickListener(ClickListener(on_other))

            cancel_tv = TextView(act)
            cancel_tv.setText("Отмена")
            cancel_tv.setTextColor(red_color)
            cancel_tv.setTextSize(1, 15.0)
            cancel_tv.setTypeface(Typeface.DEFAULT_BOLD)
            cancel_tv.setGravity(Gravity.CENTER)
            cancel_tv.setSingleLine(True)
            cancel_tv.setBackground(make_bg(red_color))
            
            cancel_tv.setOnClickListener(ClickListener(lambda: dialog_ref[0].dismiss() if dialog_ref[0] else None))
            root_layout.addView(cancel_tv, LayoutHelper.createLinear(-1, 46, 12, 0, 12, 4))

            AlertDialog = jclass("org.telegram.ui.ActionBar.AlertDialog")
            java_builder = AlertDialog.Builder(act)
            java_builder.setView(root_layout)
            
            dialog = java_builder.create()
            dialog.setCanceledOnTouchOutside(False)
            dialog.setCancelable(True)
            
            dialog.show()
            dialog_ref[0] = dialog
            
            try:
                window = dialog.getWindow()
                if window:
                    lp = window.getAttributes()
                    lp.width = int(AndroidUtilities.displaySize.x * 0.95)
                    window.setAttributes(lp)
            except: pass

        except Exception as e:
            import traceback
            err = traceback.format_exc()
            try:
                self._copy_to_clipboard(err, act)
            except: pass
            from android_utils import run_on_ui_thread
            from ui.bulletin import BulletinHelper
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка предпросмотра! Скопировано в буфер."))

    def _copy_to_clipboard(self, output_path, act):
        def go():
            try:
                import os
                from android.content import ClipData, Context
                from androidx.core.content import FileProvider
                from java.io import File
                from org.telegram.messenger import ApplicationLoader
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                
                ctx = act if act else ApplicationLoader.applicationContext
                
                ext_cache = ctx.getExternalCacheDir()
                if not ext_cache:
                    ext_cache = ctx.getCacheDir()
                    
                share_dir = os.path.join(ext_cache.getAbsolutePath(), "QuotifyTmp")
                os.makedirs(share_dir, exist_ok=True)
                
                dest = os.path.join(share_dir, os.path.basename(str(output_path)))
                
                with open(str(output_path), 'rb') as src, open(dest, 'wb') as dst:
                    dst.write(src.read())
                
                def copy_on_ui():
                    try:
                        authority = f"{ctx.getPackageName()}.provider"
                        uri = FileProvider.getUriForFile(ctx, authority, File(dest))
                        clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
                        clip = ClipData.newUri(ctx.getContentResolver(), "quotify_image", uri)
                        clipboard.setPrimaryClip(clip)
                        BulletinHelper.show_success("Скопировано в буфер обмена")
                    except Exception as e:
                        err = str(e)[:50]
                        BulletinHelper.show_error(f"Ошибка буфера: {err}")
                        
                run_on_ui_thread(copy_on_ui)
                
            except Exception as e:
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                err = str(e)[:50]
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка: {err}"))
                
        import threading
        threading.Thread(target=go).start()

    def _send_final(self, output_path, comment, send_mode):
        def go():
            try:
                from client_utils import send_message, get_send_messages_helper
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                from org.telegram.tgnet import TLRPC
                import time
                from java.io import File as JFile

                if send_mode == "sticker":
                    self._send_as_sticker_adapted(output_path, comment)
                    return

                params = {
                    "peer": self.params.peer,
                    "replyToMsg": getattr(self.params, 'replyToMsg', None)
                }
                if hasattr(self.params, 'replyToTopMsg') and self.params.replyToTopMsg:
                    params["replyToTopMsg"] = self.params.replyToTopMsg

                comment_text = str(comment).strip() if comment else ""

                if send_mode == "file":
                    f = JFile(str(output_path))
                    document = TLRPC.TL_document()
                    document.id = 0
                    document.access_hash = 0
                    document.file_reference = bytearray()
                    document.date = int(time.time())
                    document.mime_type = "image/jpeg"
                    document.size = f.length()
                    document.dc_id = 0
                    
                    file_name = TLRPC.TL_documentAttributeFilename()
                    file_name.file_name = f.getName()
                    document.attributes.add(file_name)
                    
                    params["document"] = document
                    params["path"] = str(output_path)
                    
                    self._send_media_with_comment(params, comment_text, "Отправлено как файл")

                elif send_mode == "photo":
                    send_helper = get_send_messages_helper()
                    photo = send_helper.generatePhotoSizes(str(output_path), None)
                    params["photo"] = photo
                    params["path"] = str(output_path)
                    
                    self._send_media_with_comment(params, comment_text, "Отправлено как фото")

            except Exception as e:
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                err = str(e)[:50]
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка отправки: {err}"))
        
        import threading
        threading.Thread(target=go).start()

    def _send_media_with_comment(self, params, comment_text, success_msg):
        from client_utils import send_message
        from android_utils import run_on_ui_thread
        from ui.bulletin import BulletinHelper

        try:
            if comment_text:
                params["caption"] = comment_text
            send_message(params)
            run_on_ui_thread(lambda: BulletinHelper.show_success(success_msg))
        except Exception:
            params.pop("caption", None)
            params.pop("message", None)
            send_message(params)
            run_on_ui_thread(lambda: BulletinHelper.show_success(success_msg))
            
            if comment_text:
                send_message({
                    "peer": params["peer"],
                    "message": comment_text,
                    "replyToMsg": params.get("replyToMsg")
                })

    def _send_as_sticker_adapted(self, output_path, comment):
        try:
            from org.telegram.messenger import SendMessagesHelper, ImageLoader, UserConfig
            from org.telegram.tgnet import TLRPC
            from java.io import File as JFile
            from java.io import FileOutputStream
            from android.graphics import Bitmap, BitmapFactory
            from android_utils import run_on_ui_thread
            from ui.bulletin import BulletinHelper
            import time
            import os
            
            file_name = time.strftime("Quotify_%y%m%d_%H%M%S.webp")
            webp_path = os.path.join(Filesystem.get_temp_dir(), file_name)
            
            bmp = BitmapFactory.decodeFile(str(output_path))
            if not bmp:
                raise Exception("Failed to decode image")
                
            w, h = bmp.getWidth(), bmp.getHeight()
            scale = min(1.0, 512 / max(w, h))
            new_w, new_h = max(1, int(w * scale)), max(1, int(h * scale))
            
            scaled_bmp = Bitmap.createScaledBitmap(bmp, new_w, new_h, True)
            bmp.recycle()
            
            fos = FileOutputStream(webp_path)
            try:
                webp_lossless = getattr(Bitmap.CompressFormat, 'WEBP_LOSSLESS', None)
                if webp_lossless:
                    scaled_bmp.compress(webp_lossless, 100, fos)
                else:
                    scaled_bmp.compress(Bitmap.CompressFormat.WEBP, 100, fos)
            finally:
                fos.close()
                scaled_bmp.recycle()

            f = JFile(webp_path)
            if not f.exists():
                raise Exception("WebP file not found")
                
            opts = BitmapFactory.Options()
            opts.inJustDecodeBounds = True
            BitmapFactory.decodeFile(webp_path, opts)
            img_w, img_h = opts.outWidth, opts.outHeight
            
            document = TLRPC.TL_document()
            document.id = 0
            document.access_hash = 0
            document.file_reference = bytearray()
            document.date = int(time.time())
            document.mime_type = "image/webp"
            document.size = f.length()
            document.dc_id = 0
            
            file_name_attr = TLRPC.TL_documentAttributeFilename()
            file_name_attr.file_name = f.getName()
            document.attributes.add(file_name_attr)
            
            sticker_attr = TLRPC.TL_documentAttributeSticker()
            sticker_attr.alt = ""
            sticker_attr.stickerset = TLRPC.TL_inputStickerSetEmpty()
            document.attributes.add(sticker_attr)
            
            size_attr = TLRPC.TL_documentAttributeImageSize()
            size_attr.w = img_w
            size_attr.h = img_h
            document.attributes.add(size_attr)
            
            try:
                bmp_thumb = ImageLoader.loadBitmap(webp_path, None, 90, 90, True)
                if bmp_thumb:
                    thumb = ImageLoader.scaleAndSaveImage(bmp_thumb, 90.0, 90.0, 55, False)
                    if thumb:
                        document.thumbs.add(thumb)
                        document.flags = document.flags | 1
                    bmp_thumb.recycle()
            except Exception: pass
            
            account = UserConfig.selectedAccount
            
            from java.util import HashMap
            params_map = HashMap()
            params_map.put("originalPath", webp_path)
            
            send_helper = SendMessagesHelper.getInstance(account)
            from hook_utils import find_class
            SendMessageParams = find_class("org.telegram.messenger.SendMessagesHelper$SendMessageParams")
            
            peer = self.params.peer
            did = 0
            try:
                if isinstance(peer, (int, float)): did = int(peer)
                elif hasattr(peer, 'user_id'): did = peer.user_id
                elif hasattr(peer, 'chat_id'): did = -peer.chat_id
                elif hasattr(peer, 'channel_id'): did = -peer.channel_id
                else: did = int(str(peer).lstrip('-'))
            except: did = 0
                
            reply_to_msg = self.params.replyToMsg
            reply_to_top_msg = getattr(self.params, 'replyToTopMsg', None)
            
            send_params = SendMessageParams.of(
                document, None, webp_path, did, reply_to_msg, reply_to_top_msg, None,
                None, None, params_map, True, 0, 0, 0, None, None, False
            )
            
            run_on_ui_thread(lambda: send_helper.sendMessage(send_params))
            
            if comment and str(comment).strip():
                from client_utils import send_message
                comment_params = {
                    "peer": self.params.peer,
                    "message": str(comment).strip(),
                    "replyToMsg": self.params.replyToMsg
                }
                if hasattr(self.params, 'replyToTopMsg') and self.params.replyToTopMsg:
                    comment_params["replyToTopMsg"] = self.params.replyToTopMsg
                run_on_ui_thread(lambda: send_message(comment_params))

            run_on_ui_thread(lambda: BulletinHelper.show_success("Стикер отправлен"))
            
        except Exception as e:
            from android_utils import run_on_ui_thread
            from ui.bulletin import BulletinHelper
            err = str(e)[:50]
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка отправки стикера: {err}"))

    def _save_to_gallery(self, output_path, act):
        def go():
            try:
                import shutil, os
                from android.os import Environment
                from android.content import Intent
                from android.net import Uri
                from java.io import File
                from org.telegram.messenger import ApplicationLoader
                
                pics_dir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)
                q_dir = os.path.join(pics_dir.getAbsolutePath(), "Quotify")
                os.makedirs(q_dir, exist_ok=True)
                
                dest = os.path.join(q_dir, os.path.basename(str(output_path)))
                shutil.copy2(str(output_path), dest)
                
                ctx = act if act else ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE)
                intent.setData(Uri.fromFile(File(dest)))
                ctx.sendBroadcast(intent)
                
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                run_on_ui_thread(lambda: BulletinHelper.show_success("Сохранено в галерею"))
            except Exception as e:
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                err = str(e)[:50]
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка сохранения: {err}"))
        import threading
        threading.Thread(target=go).start()

    def _share(self, output_path, act):
        def go():
            try:
                import os
                from android.content import Intent
                from androidx.core.content import FileProvider
                from java.io import File
                from org.telegram.messenger import ApplicationLoader
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                
                ctx = act if act else ApplicationLoader.applicationContext
                
                ext_cache = ctx.getExternalCacheDir()
                if not ext_cache:
                    ext_cache = ctx.getCacheDir()
                    
                share_dir = os.path.join(ext_cache.getAbsolutePath(), "QuotifyTmp")
                os.makedirs(share_dir, exist_ok=True)
                
                dest = os.path.join(share_dir, os.path.basename(str(output_path)))
                
                with open(str(output_path), 'rb') as src, open(dest, 'wb') as dst:
                    dst.write(src.read())
                
                def share_on_ui():
                    try:
                        authority = f"{ctx.getPackageName()}.provider"
                        uri = FileProvider.getUriForFile(ctx, authority, File(dest))
                        
                        intent = Intent(Intent.ACTION_SEND)
                        intent.setType("image/jpeg")
                        intent.putExtra(Intent.EXTRA_STREAM, uri)
                        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                        
                        if not act:
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                            
                        chooser = Intent.createChooser(intent, "Поделиться цитатой")
                        
                        if act:
                            act.startActivity(chooser)
                        else:
                            ctx.startActivity(chooser)
                    except Exception as e:
                        err = str(e)[:50]
                        BulletinHelper.show_error(f"Ошибка отправки: {err}")
                        
                run_on_ui_thread(share_on_ui)
                
            except Exception as e:
                from android_utils import run_on_ui_thread
                from ui.bulletin import BulletinHelper
                err = str(e)[:50]
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка отправки: {err}"))
                
        import threading
        threading.Thread(target=go).start()

    def _break_long_word(self, draw, word, font, max_width):
        parts = []
        current = ""
        segments = self._segment_line(word)
        
        for seg_type, content in segments:
            if seg_type == "premium_emoji":
                chunk = f"[CEMOJI:{content}]"
                test = current + chunk
                if self._get_text_width(draw, test, font) <= max_width:
                    current = test
                else:
                    if current:
                        parts.append(current)
                    current = chunk
            elif seg_type in ("text", "emoji", "sys"):
                i = 0
                while i < len(content):
                    start = i
                    i += 1
                    while i < len(content):
                        try:
                            c = ord(content[i])
                            prev_c = ord(content[i-1]) if i > 0 else 0
                            if c == 0xFE0F or c == 0x200D or (0x1F3FB <= c <= 0x1F3FF) or (0x1F1E6 <= c <= 0x1F1FF and 0x1F1E6 <= prev_c <= 0x1F1FF):
                                if c == 0x200D:
                                    i += 1
                                    if i < len(content):
                                        i += 1
                                else:
                                    i += 1
                            else:
                                break
                        except:
                            break
                    chunk = content[start:i]
                    test = current + chunk
                    if self._get_text_width(draw, test, font) <= max_width:
                        current = test
                    else:
                        if current:
                            parts.append(current)
                        current = chunk
            else:
                chunk = content
                test = current + chunk
                if self._get_text_width(draw, test, font) <= max_width:
                    current = test
                else:
                    if current:
                        parts.append(current)
                    current = chunk
                    
        if current:
            parts.append(current)
        return parts

    def _sanitize_text(self, text):
        if not text: return " "
        return str(text)

    def _wrap_text(self, draw, text, font, max_width):
        text = self._sanitize_text(text)
        lines = []
        paragraphs = text.split('\n')
        for p in paragraphs:
            words = p.split(' ')
            if len(words) == 0:
                lines.append('')
                continue
            current = ""
            for word in words:
                candidate = word if current == "" else current + " " + word
                if self._get_text_width(draw, candidate, font) <= max_width:
                    current = candidate
                else:
                    if current:
                        lines.append(current)
                    if self._get_text_width(draw, word, font) > max_width:
                        chunks = self._break_long_word(draw, word, font, max_width)
                        if chunks:
                            lines.extend(chunks[:-1])
                            current = chunks[-1]
                        else:
                            current = word
                    else:
                        current = word
            lines.append(current)
        return '\n'.join(lines)

    def _measure_text_dimensions(self, draw, text, font, spacing):
        if not text:
            return 0, 0
            
        lines = text.split('\n')
        max_width = 0
        total_height = 0
        
        try:
            font_size = font.size
        except:
            font_size = 36
            
        try:
            ratio = int(self.plugin.get_setting("emoji_size_percent", "125")) / 100.0
        except:
            ratio = 1.25
        emoji_size = int(font_size * ratio)
        
        try:
            bbox = draw.textbbox((0, 0), "Mq", font=font)
            text_height = bbox[3] - bbox[1]
        except:
            text_height = font_size
            
        uniform_line_height = max(text_height, emoji_size)
        
        for i, line in enumerate(lines):
            w = self._get_text_width(draw, line, font)
            max_width = max(max_width, w)
            
            total_height += uniform_line_height
            
            if i < len(lines) - 1:
                total_height += spacing
                
        return max_width, total_height

    def _is_standard_char(self, char):
        code = ord(char)
        if 0x20 <= code <= 0x7E: return True
        if 0x0400 <= code <= 0x04FF: return True
        if code == 0xA0 or code == 0xAD: return True
        return False

    def _segment_line(self, text):
        segments = []
        if not text: return segments
        parts = re.split(r'(\[CEMOJI:-?\d+\])', text)
        render_tg_emoji = self.plugin.get_setting("render_tg_emoji", False)
        for part in parts:
            if not part: continue
            if part.startswith("[CEMOJI:") and part.endswith("]"):
                segments.append(("premium_emoji", part[8:-1]))
                continue
            current_type = None
            current_content = []
            i = 0
            length = len(part)
            while i < length:
                char = part[i]
                char_type = "text"
                content = char
                step = 1
                is_emoji = False
                if render_tg_emoji:
                    c_ord = ord(char)
                    if not (c_ord < 128 and c_ord not in (35, 42) and not (48 <= c_ord <= 57)):
                        max_lookahead = min(10, length - i)
                        for l in range(max_lookahead, 0, -1):
                            candidate = part[i:i+l]
                            if self._is_telegram_emoji(candidate):
                                char_type = "emoji"
                                content = candidate
                                step = l
                                is_emoji = True
                                break
                if not is_emoji:
                    if not self._is_standard_char(char):
                        char_type = "sys"
                    if i + step < length and ord(part[i+step]) == 0xFE0F:
                         if char_type == "sys":
                            content += part[i+step]
                            step += 1
                if current_type is None:
                     current_type = char_type
                     current_content.append(content)
                elif current_type == char_type:
                    current_content.append(content)
                else:
                    segments.append((current_type, "".join(current_content)))
                    current_type = char_type
                    current_content = [content]
                i += step
            if current_content:
                segments.append((current_type, "".join(current_content)))
        return segments

    def _get_text_width(self, draw, text, font):
        if not text: return 0
        try: font_size = font.size
        except: font_size = 36
        
        if not hasattr(self, '_text_width_cache'):
            self._text_width_cache = {}
            
        cache_key = f"{text}_{font_size}"
        if cache_key in self._text_width_cache:
            return self._text_width_cache[cache_key]

        try:
            ratio = int(self.plugin.get_setting("emoji_size_percent", "125")) / 100.0
        except:
            ratio = 1.25
        emoji_size = int(font_size * ratio)
        total_width = 0
        
        segments = self._segment_line(text)
        
        for seg_type, content in segments:
            if seg_type == "text":
                try:
                    total_width += draw.textlength(content, font=font)
                except Exception:
                    try:
                        bbox = draw.textbbox((0, 0), content, font=font)
                        total_width += bbox[2] - bbox[0]
                    except Exception:
                        total_width += len(content) * (font_size * 0.6)
            elif seg_type == "emoji":
                count = 0
                pos = 0
                while pos < len(content):
                    count += 1
                    pos += 1
                    while pos < len(content) and ord(content[pos]) == 0xFE0F:
                        pos += 1
                total_width += (emoji_size * count) + (2 * count)
            elif seg_type == "sys":
                w = UniversalTextRenderer.measure(content, font_size)
                total_width += w
            elif seg_type == "premium_emoji":
                total_width += emoji_size + 2

        self._text_width_cache[cache_key] = total_width
        return total_width

    def _draw_text_with_emoji(self, canvas, draw, position, text, font, color, spacing, align="left", max_width=0):
        x_start, y_start = position
       
        try: font_size = font.size
        except: font_size = 36
            
        try: layout_ratio = int(self.plugin.get_setting("emoji_size_percent", "125")) / 100.0
        except: layout_ratio = 1.25
        
        try: visual_ratio = int(self.plugin.get_setting("emoji_visual_percent", "130")) / 100.0
        except: visual_ratio = 1.30

        layout_emoji_size = int(font_size * layout_ratio)
        render_emoji_size = int(font_size * visual_ratio)

        try: user_offset = int(self.plugin.get_setting("emoji_y_offset", "0"))
        except: user_offset = 0

        try:
            bbox = draw.textbbox((0, 0), "M", font=font)
            text_center_y = (bbox[1] + bbox[3]) / 2
            base_emoji_y_offset = int(text_center_y - (layout_emoji_size / 2)) + user_offset
        except:
            base_emoji_y_offset = int((font_size - layout_emoji_size) / 2) + user_offset

        try:
            bbox_h = draw.textbbox((0, 0), "Mq", font=font)
            text_height = bbox_h[3] - bbox_h[1]
        except:
            text_height = font_size
            
        uniform_line_height = max(text_height, layout_emoji_size)
        
        lines = text.split('\n')
        current_y = y_start
        
        color_int = 0xFF000000
        try:
            if isinstance(color, tuple):
                if len(color) == 3: color_int = (255 << 24) | (color[0] << 16) | (color[1] << 8) | color[2]
                elif len(color) == 4: color_int = (color[3] << 24) | (color[0] << 16) | (color[1] << 8) | color[2]
        except: pass

        for line in lines:
            line_width = self._get_text_width(draw, line, font)
            
            current_x = x_start
            if align == "center" and max_width > 0:
                current_x = x_start + (max_width - line_width) // 2
            elif align == "right" and max_width > 0:
                current_x = x_start + (max_width - line_width)
            
            segments = self._segment_line(line)
            
            for seg_type, content in segments:
                if seg_type == "text":
                    try: draw.text((current_x, current_y), content, font=font, fill=color)
                    except: pass
                    try: w = draw.textlength(content, font=font)
                    except:
                        try:
                            bbox = draw.textbbox((0, 0), content, font=font)
                            w = bbox[2] - bbox[0]
                        except:
                            try: w = len(content) * (font_size * 0.6)
                            except: w = len(content) * 20
                    current_x += w

                elif seg_type == "emoji":
                    emoji_parts = []
                    i = 0
                    while i < len(content):
                        start = i
                        i += 1
                        while i < len(content) and ord(content[i]) == 0xFE0F:
                            i += 1
                        emoji_parts.append(content[start:i])

                    for part in emoji_parts:
                        emoji_img = EmojiRenderer.render_emoji_to_pil(part, render_emoji_size)
                        if emoji_img:
                            offset_x = (layout_emoji_size - render_emoji_size) // 2
                            offset_y = (layout_emoji_size - render_emoji_size) // 2
                            draw_x = current_x + offset_x
                            draw_y = current_y + base_emoji_y_offset + offset_y
                            
                            try: canvas.paste(emoji_img, (int(draw_x), int(draw_y)), emoji_img)
                            except:
                                try: canvas.paste(emoji_img, (int(draw_x), int(draw_y)))
                                except: pass
                            current_x += layout_emoji_size + 2
                        else:
                            current_x += layout_emoji_size
                            
                elif seg_type == "sys":
                    sys_img = UniversalTextRenderer.render(content, font_size, color_int)
                    if sys_img:
                        sys_h = sys_img.height
                        diff = (uniform_line_height - sys_h) // 2
                        final_y = current_y + diff + user_offset
                        
                        try: canvas.paste(sys_img, (int(current_x), int(final_y)), sys_img)
                        except:
                            try: canvas.paste(sys_img, (int(current_x), int(final_y)))
                            except: pass
                        current_x += sys_img.width
                        
                elif seg_type == "premium_emoji":
                    try:
                        doc_id = int(content)
                        emoji_img = PremiumEmojiRenderer.render_premium_emoji(doc_id, render_emoji_size)
                        if emoji_img:
                            offset_x = (layout_emoji_size - render_emoji_size) // 2
                            offset_y = (layout_emoji_size - render_emoji_size) // 2
                            draw_x = current_x + offset_x
                            draw_y = current_y + base_emoji_y_offset + offset_y
                            
                            try: canvas.paste(emoji_img, (int(draw_x), int(draw_y)), emoji_img)
                            except:
                                try: canvas.paste(emoji_img, (int(draw_x), int(draw_y)))
                                except: pass
                        current_x += layout_emoji_size + 2
                    except:
                        current_x += layout_emoji_size + 2

            current_y += uniform_line_height + spacing

    def _prefetch_all_emojis(self, items):
        if not items:
            return
        size_map = {}

        for text, font in items:
            if not text:
                continue
            try:
                font_size = font.size
            except:
                font_size = 36

            try:
                visual_ratio = int(self.plugin.get_setting("emoji_visual_percent", "130")) / 100.0
            except:
                visual_ratio = 1.30

            render_size = int(font_size * visual_ratio)

            segments = self._segment_line(str(text))
            for seg_type, content in segments:
                if seg_type == "premium_emoji":
                    if render_size not in size_map:
                        size_map[render_size] = set()
                    size_map[render_size].add(int(content))

        if not size_map:
            return

        import threading
        events = []
        for size, doc_ids in size_map.items():
            if doc_ids:
                ev = threading.Event()
                events.append(ev)
                PremiumEmojiRenderer.prefetch_emojis_async(list(doc_ids), size, on_done=lambda e=ev: e.set())
                
        for ev in events:
            ev.wait(0.04)

    def _is_telegram_emoji(self, text):
        try: return Emoji.getEmojiDrawable(text) is not None
        except: return False

    def _is_emoji_only(self, text):
        if not text or not text.strip():
            return False
        
        text = text.strip()
        
        emoji_count = 0
        char_count = 0
        
        for char in text:
            if self._is_emoji_char(char):
                emoji_count += 1
            elif not char.isspace():
                char_count += 1
        
        return emoji_count > 0 and char_count == 0
    
    def _is_emoji_char(self, char):
        try:
            codepoint = ord(char)
            
            if (0x1F000 <= codepoint <= 0x1FFFF or
                0x2600 <= codepoint <= 0x27BF or
                0x2300 <= codepoint <= 0x23FF or
                0x2B00 <= codepoint <= 0x2BFF or
                0xFE00 <= codepoint <= 0xFE0F or
                0x1F300 <= codepoint <= 0x1F9FF or
                0x1FA00 <= codepoint <= 0x1FAFF or
                0x203C <= codepoint <= 0x3299 or
                codepoint == 0x200D or
                codepoint == 0xFE0F):
                return True
        except:
            pass
        
        return False
        
    def _get_author(self):
        try:
            if self.override_author_name:
                name = str(self.override_author_name)
                if name.strip():
                    return name.strip()

            if self.user and self.replyer.name is not None:
                return self.replyer.name

            if self.replyer.name:
                name = str(self.replyer.name)
                if name.strip():
                    return name.strip()

            if self.search_query:
                name = str(self.search_query)
                if name.strip():
                    return name.strip()
        except Exception:
            pass
            
        default = self.plugin.get_setting("unknown_author_label", "Неизвестен")
        return str(default) if default is not None else "Неизвестен"

class QuotifyForkPlugin(BasePlugin):
    class ActivityResultHook(MethodHook):
        def __init__(self, plugin_instance):
            self.plugin = plugin_instance

        def before_hooked_method(self, param):
            request_code = param.args[0]
            result_code = param.args[1]
            data = param.args[2]
            
            handled = False
            if result_code == Activity.RESULT_OK and data is not None and data.getData() is not None:
                uri_string = data.getData().toString()
                
                if request_code == FILE_PICK_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'font'))
                    handled = True
                elif request_code == PICK_BG_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'bg'))
                    handled = True
                elif request_code == PICK_AVA_REQUEST_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_file_picker_result(uri_string, 'avatar'))
                    handled = True
                elif request_code == IMPORT_SETTINGS_CODE:
                    param.setResult(None)
                    run_on_ui_thread(lambda: self.plugin._handle_import_json(uri_string))
                    handled = True

            if request_code in (FILE_PICK_REQUEST_CODE, PICK_BG_REQUEST_CODE, PICK_AVA_REQUEST_CODE, IMPORT_SETTINGS_CODE):
                if self.plugin._activity_hook:
                    self.plugin._activity_hook.unhook()
                    self.plugin._activity_hook = None

    def __init__(self):
        super().__init__()
        self._temp_dir_path = None
        self._activity_hook = None
        self._hooks = []

    def on_plugin_load(self):
        try:
            self._prepare_directories()
            LocalizationManager.init()
            FontManager.init()
            DebugLogger.init(self) 
            self.add_on_send_message_hook()
            self._hooks = []
            self._hook_android_utilities()
            self._setup_settings_header_hook()
            
            if self.get_setting("show_quote_context_menu", True):
                self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                    text="Создать цитату",
                    icon="msg_msgbubble3_solar",
                    on_click=self._handle_create_quote_menu
                ))
            
            MediaDataController.getInstance(0).loadStickersByEmojiOrName("bwaaa_pack", False, False)
            MediaDataController.getInstance(0).loadStickersByEmojiOrName("Quotify_Plus", False, False)
            threading.Thread(target=self._ensure_fallback_avatar_cached).start()
            qlog("Plugin loaded successfully")
        except Exception as e:
            qlog(f"Load error: {e}")

    def _handle_create_quote_menu(self, context):
        try:
            message_obj = context.get("message")
            if not message_obj:
                BulletinHelper.show_error("Не удалось получить сообщение")
                return
            
            class DummyParams:
                def __init__(self, msg):
                    self.replyToMsg = msg
                    try:
                        self.peer = msg.getDialogId()
                    except:
                        self.peer = 0
                    self.replyToTopMsg = None
            
            dummy_params = DummyParams(message_obj)
            
            font_index = self.get_setting("font", 1)
            layout_index = self.get_setting("quote_style", 0)
            fixed_width = self.get_setting("fixed_width", True)
            
            custom_bg_path = self.get_setting("bg_custom_path", "")
            custom_avatar_path = self.get_setting("avatar_custom_path", "")
            force_bg = self.get_setting("bg_use_custom", False)
            
            self._increment_stat("quotify_stats_total")
            self._increment_stat("quotify_stats_normal")
            self.last_cmd = '.q'

            quote = QuoteManager(dummy_params, font_index, layout_index, fixed_width, self, custom_bg_path, custom_avatar_path, force_bg, False, search_query=None)
            quote.force_preview = True
            quote.generate_quote()
            
        except Exception as e:
            qlog(f"Context menu quote error: {e}", error=e)
            BulletinHelper.show_error("Ошибка при создании цитаты из меню")

    def _ensure_fallback_avatar_cached(self):
        try:
            temp_dir = self._temp_dir_path
            cache_path = os.path.join(temp_dir, "fallback_cache.jpg")
            if os.path.exists(cache_path) and os.path.getsize(cache_path) > 0:
                return

            def run():
                try:
                    headers = {'User-Agent': 'Mozilla/5.0'}
                    html = requests.get(f"https://t.me/{FALLBACK_AVATAR_USERNAME}", headers=headers, timeout=5)
                    match = re.search(r'<meta property="og:image" content="([^"]+)"', html.text)
                    if match:
                        img_data = requests.get(match.group(1), headers=headers, timeout=5).content
                        with open(cache_path, 'wb') as f:
                            f.write(img_data)
                except Exception:
                    pass
            threading.Thread(target=run).start()
        except Exception:
            pass

    def _toggle_debug_logging(self, value):
        self.set_setting("debug_logging", value)
        DebugLogger.enabled = value
        if value:
            BulletinHelper.show_success("Логирование включено")
            qlog("Debug logging enabled manually")
        else:
            BulletinHelper.show_info("Логирование выключено")

    def _save_debug_logs(self, view=None):
        export_dir = self._get_export_dir()
        saved_path = DebugLogger.save_logs(export_dir, is_error=False)
        if saved_path:
            BulletinHelper.show_success(f"Сохранено в:\n{saved_path}")
        else:
            BulletinHelper.show_error("Ошибка сохранения или логи пусты")

    def _clear_debug_logs(self, view=None):
        DebugLogger.clear_logs()
        BulletinHelper.show_success("Логи очищены")
        self.refresh_settings()

    def _test_logging(self, view=None):
        qlog("Test log entry")
        BulletinHelper.show_success("Запись добавлена")
        self.refresh_settings()

    def _copy_recent_logs(self, view=None):
        try:
            if not DebugLogger.logs:
                BulletinHelper.show_info("Логи пусты")
                return
            recent_logs = DebugLogger.logs[-10:]
            log_text = "\n".join(recent_logs)
            ctx = ApplicationLoader.applicationContext
            clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
            clip = ClipData.newPlainText("Quotify Logs", log_text)
            clipboard.setPrimaryClip(clip)
            BulletinHelper.show_success("Скопировано")
        except:
            BulletinHelper.show_error("Ошибка копирования")

    def _prepare_directories(self):
        try:
            base_dir = ApplicationLoader.getFilesDirFixed()
            temp_dir = File(base_dir, "quotify_fork")
            if not temp_dir.exists():
                temp_dir.mkdirs()
            self._temp_dir_path = temp_dir.getAbsolutePath()
            fonts_dir = File(temp_dir, "fonts")
            if not fonts_dir.exists():
                fonts_dir.mkdirs()
            images_dir = File(temp_dir, "images")
            if not images_dir.exists():
                images_dir.mkdirs()
        except Exception as e:
            qlog(f"Directory error: {e}")

    def _parse_hex_color(self, hex_string, default_color):
        try:
            hex_string = hex_string.lstrip('#')
            if len(hex_string) == 6:
                return tuple(int(hex_string[i:i+2], 16) for i in (0, 2, 4))
        except (ValueError, TypeError):
            pass
        return default_color

    def _show_font_faq_alert(self, view=None):
        title = "🎨 Как выбрать кастомный шрифты"
        text = (
            "📝 Как добавить кастомный шрифт?\n\n"
            "1️⃣ Выберите 'Кастомный шрифт' в селекторе шрифтов\n\n"
            "2️⃣ Варианты загрузки:\n"
            "• Вставьте ссылку на .ttf файл\n"
            "• Или загрузите файл с устройства\n\n"
            "🔗 Примеры ссылок:\n"
            "• https://example.com/font.ttf\n"
            "• https://fonts.gstatic.com/s/roboto/v30/font.ttf\n\n"
            "💡 В КОНЦЕ ОБЯЗАТЕЛЬНО ДОЛЖНО БЫТЬ .ttf\n\n"
            "3️⃣ Сохраните настройки и создайте цитату (.q)\n\n"
            "⚡ Плагин автоматически скачает и будет использовать шрифт!\n\n"
            "🚨 ВАЖНО! ПРИ ПЕРВОМ ИСПОЛЬЗОВАНИИ/СМЕНЕ ШРИФТА КАРТОЧКА БУДЕТ СОЗДАВАТЬСЯ ДОЛЬШЕ\n\n"
            "💻 Рекомендуется загружать шрифты на Github\n\n"
            "🌐 Где искать шрифты (с прямыми ссылками):\n"
            "• https://fontsaddict.com\n"
            "• https://en.bestfonts.pro\n"
        )
        close_button = "Понятно"
        fragment = get_last_fragment()
        ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
        builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        builder.set_title(title)
        builder.set_message(text)
        builder.set_positive_button(close_button, lambda d, w: None)
        builder.set_cancelable(True)
        builder.set_canceled_on_touch_outside(True)
        builder.show()

    def _clear_exported_configs(self, view=None):
        try:
            export_dir = self._get_export_dir()
            if not os.path.exists(export_dir):
                BulletinHelper.show_info("Папка уже пуста")
                return

            files = [f for f in os.listdir(export_dir) if f.endswith(CONFIG_FILE_EXTENSION) or f.endswith(".json")]
            
            if not files:
                BulletinHelper.show_info("Нет сохранённых конфигов")
                return

            count = 0
            for f in files:
                os.remove(os.path.join(export_dir, f))
                count += 1
            
            BulletinHelper.show_success(f"Удалено файлов: {count}")
            
        except Exception as e:
            qlog(f"Clear configs error: {e}")
            BulletinHelper.show_error(f"Ошибка: {e}")

    def _hook_android_utilities(self):
        try:
            AU = JClass.forName("org.telegram.messenger.AndroidUtilities")
            methods = AU.getDeclaredMethods()
            for m in methods:
                if m.getName() == "openDocument" and len(m.getParameterTypes()) == 3:
                    if "MessageObject" in m.getParameterTypes()[0].getName():
                        m.setAccessible(True)
                        self._hooks.append(self.hook_method(m, OpenDocumentHook(self)))
                
                if m.getName() == "openForView" and len(m.getParameterTypes()) == 4:
                    if "MessageObject" in m.getParameterTypes()[0].getName():
                        m.setAccessible(True)
                        self._hooks.append(self.hook_method(m, OpenDocumentHook(self)))
        except Exception as e:
            qlog(f"Error hooking AndroidUtilities: {e}")

    def _setup_settings_header_hook(self):
        try:
            from base_plugin import MethodHook
            
            class SettingsHeaderHook(MethodHook):
                def __init__(self, plugin):
                    self._plugin_ref = weakref.ref(plugin)
                
                def after_hooked_method(self, param):
                    try:
                        plugin = self._plugin_ref()
                        if not plugin:
                            return
                        activity = param.thisObject
                        items = param.args[0]
                        if not items or items.size() == 0:
                            return
                        
                        plugin_obj = get_private_field(activity, "plugin")
                        if not plugin_obj or str(plugin_obj.getId()) != "quotify_plus":
                            return
                        
                        if get_private_field(activity, "createSubFragmentCallback") is not None:
                            return
                        
                        header = plugin._create_settings_header(activity.getContext())
                        if header:
                            from org.telegram.ui.Components import UItem
                            from com.exteragram.messenger.plugins.models import HeaderSetting
                            item = UItem.asCustom(header)
                            item.settingItem = HeaderSetting("quotify_header")
                            try: item.setTransparent(True)
                            except: pass
                            items.add(0, item)
                            items.add(1, UItem.asShadow())
                    except:
                        pass
            
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if PSA:
                method = PSA.getClass().getDeclaredMethod("fillItems", find_class("java.util.ArrayList"), find_class("org.telegram.ui.Components.UniversalAdapter"))
                method.setAccessible(True)
                self._hooks.append(self.hook_method(method, SettingsHeaderHook(self)))
        except Exception as e:
            qlog(f"Failed to setup settings header hook: {e}")

    def _create_settings_header(self, context):
        try:
            container = FrameLayout(context)
            plugin_ref = self
            
            particlesView = StarParticlesView(context)
            particlesView.setClipWithGradient()
            
            effect_index = random.randint(0, 3)
            
            if effect_index == 0:
                particlesView.drawable.colorKey = Theme.key_premiumStarGradient2
                particlesView.drawable.isCircle = True
                particlesView.drawable.useRotate = False
            elif effect_index == 1:
                particlesView.drawable.colorKey = Theme.key_premiumStarGradient1
                particlesView.drawable.isCircle = False
                particlesView.drawable.useRotate = True
            elif effect_index == 2:
                particlesView.drawable.colorKey = Theme.key_premiumStarGradient2
                particlesView.drawable.isCircle = False
                particlesView.drawable.useRotate = True
            else:
                particlesView.drawable.colorKey = Theme.key_premiumStarGradient1
                particlesView.drawable.isCircle = True
                particlesView.drawable.useRotate = True

            particlesView.drawable.centerOffsetY = AndroidUtilities.dp(10)
            particlesView.drawable.minLifeTime = random.randint(2000, 4000)
            particlesView.drawable.randLifeTime = random.randint(1000, 2000)
            particlesView.drawable.updateColors()

            container.addView(particlesView, LayoutHelper.createFrame(-1, 220, Gravity.CENTER_HORIZONTAL | Gravity.TOP, 0, 0, 0, 0))
            
            def play_effect():
                particlesView.flingParticles(360)

            run_on_ui_thread(play_effect, 200)

            imageView = BackupImageView(context)
            imageView.setRoundRadius(AndroidUtilities.dp(24))
            imageView.setClickable(True)
            
            click_state = {'count': 0}

            def try_load_sticker(img, name, idx):
                ss = MediaDataController.getInstance(0).getStickerSetByName(name) or MediaDataController.getInstance(0).getStickerSetByEmojiOrName(name)
                if ss and ss.documents and ss.documents.size() > 0:
                    sticker_index = min(idx, ss.documents.size() - 1)
                    img.setImage(ImageLocation.getForDocument(ss.documents.get(sticker_index)), "108_108", None, None, 0, 1)
                    return True
                return False
            
            if not try_load_sticker(imageView, "Quotify_Plus", 1):
                MediaDataController.getInstance(0).loadStickersByEmojiOrName("Quotify_Plus", False, False)
                run_on_ui_thread(lambda: try_load_sticker(imageView, "Quotify_Plus", 1), 1500)
            
            container.addView(imageView, LayoutHelper.createFrame(108, 108, Gravity.CENTER | Gravity.TOP, 0, 20, 0, 0))
            
            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
            title.setText(f"Quotify+ {__version__}")
            title.setSingleLine(True)
            title.setGravity(Gravity.CENTER)
            container.addView(title, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 50, 145, 50, 0))
            
            subtitle = TextView(context)
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitle.setText("Улучшенная версия Quotify")
            subtitle.setGravity(Gravity.CENTER)
            container.addView(subtitle, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 60, 180, 60, 27))
            
            def ensure_packs_loaded():
                MediaDataController.getInstance(0).loadStickersByEmojiOrName("bwaaa_pack", False, False)
                MediaDataController.getInstance(0).loadStickersByEmojiOrName("Quotify_Plus", False, False)

            def switch_to_bwaaa():
                ss = MediaDataController.getInstance(0).getStickerSetByName("bwaaa_pack") or MediaDataController.getInstance(0).getStickerSetByEmojiOrName("bwaaa_pack")
                if ss and ss.documents and ss.documents.size() > 0:
                    max_idx = min(68, ss.documents.size() - 1)
                    rnd = random.randint(0, max_idx)
                    imageView.setImage(ImageLocation.getForDocument(ss.documents.get(rnd)), "108_108", None, None, 0, 1)

            run_on_ui_thread(ensure_packs_loaded, 500)

            try:
                class BounceTouchListener(dynamic_proxy(View.OnTouchListener)):
                    def onTouch(self, v, event):
                        action = event.getAction()
                        if action == MotionEvent.ACTION_DOWN:
                            v.animate().scaleX(0.9).scaleY(0.9).setDuration(100).start()
                        elif action == MotionEvent.ACTION_UP:
                            v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start()
                            try: v.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
                            except: pass
                            
                            play_effect()
                            
                            click_state['count'] += 1
                            
                            if click_state['count'] == 5:
                                run_on_ui_thread(switch_to_bwaaa)
                                run_on_ui_thread(lambda: BulletinHelper.show_error("BWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"))
                                plugin_ref._increment_stat("quotify_stats_bwaaa")
                            elif click_state['count'] > 5:
                                run_on_ui_thread(switch_to_bwaaa)
                                plugin_ref._increment_stat("quotify_stats_bwaaa")

                        elif action == MotionEvent.ACTION_CANCEL:
                            v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start()
                        return False
                
                imageView.setOnTouchListener(BounceTouchListener())
            except: pass
            
            return container
        except Exception as e:
            qlog(f"Failed to create settings header: {e}")
            return None

    def _open_dev_channel(self, view=None):
        try:
            from org.telegram.messenger.browser import Browser
            fragment = get_last_fragment()
            if fragment:
                Browser.openUrl(fragment.getContext(), "https://t.me/mur_live")
        except Exception:
            pass

    def create_settings(self):
        return [
            Text(text="Макет/Текст", icon="msg_theme", create_sub_fragment=self.create_appearance_settings),
            Text(text="Аватар", icon="msg_contacts_ny_remix", create_sub_fragment=self.create_avatar_settings),
            Text(text="Шрифты", icon="msg_photo_text_regular", create_sub_fragment=self.create_font_settings),
            Text(text="Фон и фильтры", icon="msg_photo_blur", create_sub_fragment=self.create_background_settings),
            Text(text="Расшифровка/Отправка", icon="ai_chat", create_sub_fragment=self.create_transcription_settings),
            Text(text="Конфигурация/Логи", icon="msg_log_solar", create_sub_fragment=self.create_developer_settings),
            Divider(),
            Text(text="Статистика", icon="msg_stats", create_sub_fragment=self.create_statistics_settings),
            Text(text="Эмодзи/Медиа", icon="msg_sticker_solar", create_sub_fragment=self.create_media_settings),
            Text(text="Команды/Меню", icon="input_bot1", create_sub_fragment=self.create_command_settings),
            Text(text="Метки вложений", icon="menu_tag_rename", create_sub_fragment=self.create_labels_settings),
            Divider(),
            Text(text="Канал разработчика", accent=True, icon="msg_channel", on_click=self._open_dev_channel),
        ]

    def create_media_settings(self):
        current_style = self.get_setting("quote_style", 0)
        settings = [
            Header("Эмодзи"),
            Input(key="emoji_size_percent", text="Размер эмодзи (%)", default="125", subtext="Размер места под эмодзи в тексте", icon="msg_photo_crop"),
            Input(key="emoji_visual_percent", text="Статичный размер (%)", default="130", subtext="Статичный размер картинки эмодзи", icon="msg_sticker_solar"),
            Input(key="emoji_y_offset", text="Смещение эмодзи", default="0", subtext="Смещение по вертикали", icon="msg_status_edit"),
            Switch(key="show_name_emoji", text="Эмодзи статуса", default=False, subtext="Показывает премиум эмодзи после никнейма", icon="msg_status_edit", on_change=self.refresh_settings),
            Switch(key="render_tg_emoji", text="Старый рендер", default=False, subtext="Включает поломанный рендеринг с помощью обычных телеграм эмодзи (для тех, кому не нравятся системные по типу Samsung)", icon="msg_bots_solar", on_change=self.refresh_settings),
            Divider(),
            Header("Медиа"),
            Switch(key="quote_render_image", text="Отображать медиа", default=True, subtext="Фотографии и стикеры", icon="msg_gallery", on_change=self.refresh_settings),
        ]
        
        if self.get_setting("quote_render_image", True):
            settings.extend([
                Input(key="quote_image_radius", text="Скругления медиа (%)", default="5", subtext="0% = квадратные, 100% = максимальное скругление", icon="msg_mini_autodelete_empty"),
                Input(key="quote_text_reduction", text="Уменьшение текста (%)", default="14", subtext="Если есть вложение", icon="msg_message"),
            ])
    
        if current_style == 2:
            settings.append(Input(key="quote_image_size_vertical", text="Масштаб (Вертикально)", default="70", subtext="% размера медиа", icon="msg_background"))
        elif current_style != 3:
            settings.append(Input(key="quote_image_size_horizontal", text="Масштаб (Горизонтально)", default="100", subtext="% размера медиа", icon="msg_background"))
    
        return settings

    def create_command_settings(self):
        return [
            Header("Контекстное меню"),
            Switch(key="show_quote_context_menu", text="Кнопка в меню", default=True, subtext='Показывать кнопку "Создать цитату" при нажатии на "Сообщение -> Плагины". Требует перезапуска плагина/клиента.', icon="msg_msgbubble3_solar", on_change=self.refresh_settings),
            Divider(),
            Header("Изменение префиксов команд"),
            Input(key="q_default", text="Обычная цитата:", default=".q", subtext="Команда для создания цитаты", icon="menu_select_quote"),
            Input(key="q_force_bg", text="Кастом фон:", default=".qb", subtext="Использует фон из настроек", icon="msg_photos"),
            Input(key="q_force_ava", text="Кастом аватар:", default=".qa", subtext="Использует аватар из настроек", icon="msg_contacts"),
            Input(key="q_force_both", text="Кастом фон и аватар:", default=".qm", subtext="Использует фон и аватар из настроек", icon="menu_feature_reactions"),
            Divider(),
            Input(key="fq_default", text="Фейковая цитата:", default=".fq", subtext="Команда для создания фейк-цитаты", icon="msg_contacts_name"),
            Input(key="fq_force_bg", text="Кастом фон с фейком:", default=".fqb", subtext="Использует фон из настроек", icon="msg_photos"),
            Input(key="fq_force_ava", text="Кастом аватар с фейком:", default=".fqa", subtext="Использует аватар из настроек", icon="msg_contacts"),
            Input(key="fq_force_both", text="Кастом фон и аватар фейком:", default=".fqm", subtext="Использует фон и аватар из настроек", icon="menu_feature_reactions"),
            Divider(),
            Input(key="fake_name_separator", text="Разделитель текста/ника", default=DEFAULT_FAKE_NAME_SEPARATOR, subtext="Например: .fq текст | данные", icon="msg_search"),
        ]

    def create_appearance_settings(self):
        current_style = self.get_setting("quote_style", 0)
        
        settings = [
            Header("Макеты/Цвета"),
            Selector(key="quote_style", text="Стиль расположения", default=0, items=["Горизонтальная (Ава слева)", "Горизонтальная (Ава справа)", "Вертикальная", "Облако"], icon="menu_edit_appearance", on_change=self.refresh_settings),
            Switch(key="ignore_last_name", text="Скрывать фамилию", default=False, subtext="Использовать только имя автора", icon="msg_contacts"),
        ]

        if current_style == 3:
            settings.append(Input(key="cloud_bubble_opacity", text="Прозрачность облака", default="84", subtext="От 0 (прозрачный) до 100 (плотный)", icon="msg_photo_flip"))
        
        settings.append(Divider())

        settings.append(Switch(key="use_profile_color", text="Профильный ник", default=True, subtext="Цвет ника, который берется с профиля", icon="msg_openprofile", on_change=self.refresh_settings))
        settings.append(Input(key="text_color_hex", text="HEX текста", default="#FFFFFF", subtext="Основной текст", icon="msg_photo_text_regular"))

        if not self.get_setting("use_profile_color", True):
            settings.append(Input(key="author_color_hex", text="HEX автора", default="#B4B4B4", subtext="Цвет имени", icon="msg_colors"))

        if current_style == 3:
            settings.append(Input(key="cloud_bubble_color", text="HEX облака", default="#1E1E1E", subtext="Фон облака", icon="msg_msgbubble3"))
            settings.append(Input(key="cloud_author_prefix", text="Префикс автора (облако)", default="", subtext="Текст перед именем (облако)", icon="msg_edit"))
        else:
            settings.append(Input(key="author_prefix", text="Префикс автора", default="— ", subtext="Текст перед именем", icon="msg_edit"))

        settings.extend([
            Divider(),
            Header("Размеры и отступы"),
        ])

        if current_style == 2:
            settings.append(Selector(key="vertical_text_align", text="Выравнивание текста (вертикаль)", default=1, items=["Слева", "По центру", "Справа"], icon="menu_tag_rename"))

        if current_style == 3:
            settings.append(Input(key="cloud_quote_font_size", text="Размер текста (облако)", default="36", subtext="Текст цитаты", icon="menu_select_quote"))
            settings.append(Input(key="cloud_author_font_size", text="Размер имени (облако)", default="28", subtext="Имя автора", icon="msg_contacts"))
        else:
            settings.append(Input(key="quote_font_size", text="Размер текста", default="40", subtext="Текст цитаты", icon="menu_select_quote"))
            settings.append(Input(key="author_font_size", text="Размер имени", default="32", subtext="Имя автора", icon="msg_contacts"))

        settings.append(Input(key="line_spacing", text="Отступ строк", default="0", subtext="В пикселях", icon="msg_list"))

        return settings

    def create_transcription_settings(self):
        provider = self.get_setting("transcription_provider", 2)
        is_enabled = self.get_setting("enable_transcription", True)
        
        settings = [
            Header("Расшифровка голосовых"),
            Switch(key="enable_transcription", text="Авто-расшифровка", default=True, subtext="Преобразовывать голос в текст цитаты", icon="ai_chat", on_change=self.refresh_settings),
        ]

        if is_enabled:
            settings.extend([
                Input(key="trans_format", text="Шаблон текста", default='[Расшифровка: "{text}"]', subtext="{text} - это полученный текст", icon="menu_tag_rename"),
                Divider(),
                Selector(key="transcription_provider", text="Сервис", default=2, items=["Gemini", "NavyAI", "Mistral", "Deepgram"], icon="msg_language", on_change=self.refresh_settings),
            ])

            if provider == 0:
                settings.extend([
                    Input(key="trans_key_manual", text="API-ключ", default="AIzaSyD8kUluAcDVA-VpHtcaeAW_HQ_dAf44q3s", icon="msg_permissions"),
                    Input(key="trans_model", text="Модель", default="gemini-2.5-flash", icon="msg_bot"),
                    Text(text="Получить API Gemini", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://aistudio.google.com/apikey")),
                    Text(text="Для API Gemini нужен VPN", icon="msg_info"),
                ])
            elif provider == 1:
                settings.extend([
                    Input(key="trans_key_navy", text="API-ключ", default="sk-navy-bRHcCluxPrlkLkIB5qKJFGPEJOl1cL91xcqxO4vYfeg", icon="msg_permissions"),
                    Input(key="trans_model_navy", text="Модель", default="gpt-4o-transcribe", icon="msg_bot"),
                    Text(text="Получить API NavyAI", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://api.navy/dashboard/#keys")),
                ])
            elif provider == 2:
                settings.extend([
                    Input(key="trans_key_mistral", text="API-ключ", default="6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF", icon="msg_permissions"),
                    Input(key="trans_model_mistral", text="Модель", default="voxtral-mini-latest", icon="msg_bot"),
                    Text(text="Получить API Mistral", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://console.mistral.ai/home?workspace_dialog=apiKeys")),
                ])
            elif provider == 3:
                settings.extend([
                    Input(key="trans_key_deepgram", text="API-ключ", default="011fb75d769d83fe88822e0c6f4e45cee8810116", icon="msg_permissions"),
                    Input(key="trans_model_deepgram", text="Модель", default="nova-3-general", icon="msg_bot"),
                    Text(text="Получить API Deepgram", icon="msg_openin", accent=True, on_click=lambda v: self._open_url("https://console.deepgram.com")),
                ])

        settings.extend([
            Divider(),
            Header("Отправка цитаты"),
            Selector(key="after_gen_action", text="Способ отправки", default=0, items=["Предпросмотр", "Как фото", "Как файл", "Как стикер", "В буфер", "В галерею", "Поделиться"], icon="msg_share", on_change=self.refresh_settings),
            Switch(key="preview_hide_comment", text="Скрыть комментарий", default=False, subtext="Скрыть поле для комментария в окне предпросмотра", icon="msg_viewreplies_solar", on_change=self.refresh_settings),
        ])
        
        return settings

    def create_developer_settings(self):
        try:
            default_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
        except Exception:
            default_path = os.path.join(ApplicationLoader.getFilesDirFixed().getAbsolutePath(), "Quotify+")
        
        return [
            Header("Конфигурация"),
            Input(key="export_path", text="Путь экспорта", default=default_path, subtext="Папка для сохранения файлов", icon="files_folder_solar"),
            Text(text="Экспортировать настройки", icon="msg_shareout", on_click=self._save_config_to_file),
            Text(text="Импортировать настройки", icon="msg_openin", on_click=self._show_local_import_dialog),
            Text(text="Очистить конфиги", icon="msg_delete", red=True, on_click=self._clear_exported_configs),
            Divider(),
            Header("Логирование"),
            Switch(key="debug_logging", text="Включить логи", default=False, icon="msg_log", on_change=self._toggle_debug_logging),
            Switch(key="copy_error_to_clipboard", text="Ошибка в буфере", default=True, subtext="Отправляет ошибку в буфер обмена", icon="msg_copy"),
            Text(text="Сохранить логи в файл", icon="msg_download", on_click=self._save_debug_logs),
            Text(text="Скопировать логи в буфер", icon="msg_copy", on_click=self._copy_recent_logs),
            Text(text="Очистить логи", icon="msg_delete", red=True, on_click=self._clear_debug_logs),
            Selector("Действие после создания", "after_gen_action", ["Предпросмотр", "Как фото", "Как файл", "Как стикер"], 0),
        ]

    def _get_settings_defaults(self):
        try:
            dl_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
        except Exception:
            dl_path = os.path.join(ApplicationLoader.getFilesDirFixed().getAbsolutePath(), "Quotify+")
        
        defaults = {
            "quote_render_image": True,
            "quote_image_radius": "5",
            "quote_text_reduction": "14",
            "quote_image_size_vertical": "70",
            "quote_image_size_horizontal": "100",
            
            "q_default": ".q",
            "q_force_bg": ".qb",
            "q_force_ava": ".qa",
            "q_force_both": ".qm",
            "fq_default": ".fq",
            "fq_force_bg": ".fqb",
            "fq_force_ava": ".fqa",
            "fq_force_both": ".fqm",
            "fake_name_separator": "|",
            
            "quote_style": 0,
            "ignore_last_name": False,
            "render_tg_emoji": False,
            "cloud_bubble_opacity": "84",
            "use_profile_color": True,
            "text_color_hex": "#FFFFFF",
            "author_color_hex": "#B4B4B4",
            "cloud_bubble_color": "#1E1E1E",
            "cloud_quote_font_size": "40",
            "cloud_author_font_size": "32",
            "quote_font_size": "40",
            "author_font_size": "32",
            "author_prefix": "— ",
            "cloud_author_prefix": "",

            "line_spacing": "0",
            "vertical_text_align": 1,
            "emoji_y_offset": "0",
            "show_name_emoji": False,
            "show_quote_context_menu": True,
            "emoji_size_percent": "125",
            "emoji_visual_percent": "130",

            "enable_transcription": True,
            "trans_format": '[Расшифровка: "{text}"]',
            "transcription_provider": 2,
            "trans_key_manual": "AIzaSyD8kUluAcDVA-VpHtcaeAW_HQ_dAf44q3s",
            "trans_model": "gemini-2.5-flash",
            "trans_key_navy": "sk-navy-bRHcCluxPrlkLkIB5qKJFGPEJOl1cL91xcqxO4vYfeg",
            "trans_model_navy": "gpt-4o-transcribe",
            "trans_key_mistral": "6dc9clGWIO3RJJkoty0PNIlJ7QOICqbF",
            "trans_model_mistral": "voxtral-mini-latest",
            "trans_key_deepgram": "011fb75d769d83fe88822e0c6f4e45cee8810116",
            "trans_model_deepgram": "nova-3-general",
            
            "after_gen_action": 0,
            "preview_hide_comment": False,

            "show_avatar": True,
            "avatar_size": "400",
            "cloud_avatar_size": "80",
            "avatar_rounding": "100",
            "avatar_use_custom": False,
            "avatar_custom_path": "",
            "use_random_bg": True,
            
            "font": 1,
            "gfonts_query": "",
            "custom_font_url": "",
            "custom_font_path": "",
            
            "bg_style": 0,
            "bg_blur_radius": "60",
            "bg_glass_blur_radius": "60",
            "bg_glass_opacity": "80",
            "bg_tv_noise_intensity": "60",
            "bg_pixel_size": "20",
            "bg_gradient_color1": "#FF8040",
            "bg_gradient_color2": "#8040FF",
            "bg_waves_amplitude": "5",
            "bg_waves_frequency": "0.1",
            "bg_filter": 0,
            "filter_posterize_levels": "4",
            "filter_colorize_black": "#000000",
            "filter_colorize_white": "#FFD700",
            "filter_contrast_factor": "2.0",
            "bg_dimming": "67",
            "custom_bg_color": "#000000",
            "bg_use_custom": False,
            "bg_custom_path": "",
            
            "enable_attach_labels": True,
            "attach_label_none": "[вложение]",
            "attach_label_file": "[{name}.{ext} {size}]",
            "attach_label_date": "[дата]",
            
            "attach_label_photo": "[фото]",
            "attach_label_video": "[видео]",
            "attach_label_gif": "[гиф]",
            "attach_label_voice": "[голосовое]",
            "attach_label_round": "[кружок]",
            "attach_label_audio": "[музыка]",
            "attach_label_sticker": "[стикер]",
            "attach_label_sticker_anim": "[премиум стикер]",
            "attach_label_gift": "[премиум]",
            "attach_label_poll": "[опрос]",
            "attach_label_geo": "[гео]",
            "attach_label_contact": "[контакт]",
            "attach_label_call": "[звонок]",
            "attach_label_story": "[история]",
            "attach_label_story_mention": "[упоминание в истории]",
            
            "debug_logging": False,
            "extended_logging": False,
            "export_path": dl_path,
            "copy_error_to_clipboard": True,
            
            "quotify_stats_total": 0,
            "quotify_stats_normal": 0,
            "quotify_stats_fake": 0,
            "quotify_stats_bwaaa": 0,
            "stats_cmd_q": 0, "stats_cmd_qf": 0, "stats_cmd_qc": 0, "stats_cmd_qm": 0,
            "stats_cmd_fq": 0, "stats_cmd_fqf": 0, "stats_cmd_fqc": 0, "stats_cmd_fqm": 0
        }
        return defaults

    def _get_export_dir(self):
        try:
            default_path = os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")
            custom_path = self.get_setting("export_path", default_path)
            if not os.path.exists(custom_path):
                os.makedirs(custom_path)
                qlog(f"Created export directory: {custom_path}")
            return custom_path
        except Exception as e:
            qlog(f"Error creating export directory: {e}")
            return os.path.join(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath(), "Quotify+")

    def _save_config_to_file(self, view=None):
        try:
            settings_data = {}
            defaults = self._get_settings_defaults()
            for key, default_val in defaults.items():
                val = self.get_setting(key, default_val)
                settings_data[key] = val
            
            config = {
                "version": CONFIG_VERSION,
                "plugin_version": __version__,
                "timestamp": int(time.time()),
                "settings": settings_data
            }
            
            config_json = json.dumps(config, indent=2, ensure_ascii=False)
            
            export_dir = self._get_export_dir()
            
            time_str = time.strftime('%y%m%d.%H%M%S')
            filename = f"quotify_{time_str}{CONFIG_FILE_EXTENSION}"
            filepath = os.path.join(export_dir, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(f"# Quotify+ Config v{__version__}\n")
                f.write(f"# {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write(config_json)
            
            self._show_share_dialog(filepath, filename)
            
        except Exception as e:
            qlog(f"Save error: {e}")
            BulletinHelper.show_error(str(e))

    def _show_local_import_dialog(self, view=None):
        try:
            from org.telegram.ui.ActionBar import Theme
            from android.widget import LinearLayout, TextView, ScrollView
            from android.graphics import Typeface
            from android.graphics.drawable import GradientDrawable
            from org.telegram.ui.Components import LayoutHelper
            from android.view import View, Gravity
            from java import dynamic_proxy, jclass
            from org.telegram.messenger import AndroidUtilities
            import os
            from client_utils import get_last_fragment

            fragment = get_last_fragment()
            if not fragment: return
            act = fragment.getParentActivity()
            if not act: return

            root_layout = LinearLayout(act)
            root_layout.setOrientation(LinearLayout.VERTICAL)
            root_layout.setPadding(0, AndroidUtilities.dp(0), 0, AndroidUtilities.dp(4))

            title_tv = TextView(act)
            title_tv.setText("Импорт конфигурации")
            title_tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            title_tv.setTextSize(1, 20.0)
            title_tv.setTypeface(Typeface.DEFAULT_BOLD)
            title_tv.setGravity(Gravity.CENTER)
            root_layout.addView(title_tv, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 10))

            dialog_ref = [None]

            class ClickListener(dynamic_proxy(View.OnClickListener)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                def onClick(self, v): self.fn()

            blue_color = Theme.getColor(Theme.key_windowBackgroundWhiteBlueText)
            red_color = Theme.getColor(Theme.key_text_RedRegular)
            
            def make_bg(color_base):
                bg = GradientDrawable()
                bg.setColor((color_base & 0x00FFFFFF) | 0x12000000)
                bg.setCornerRadius(16.0)
                return bg

            scroll_view = ScrollView(act)
            scroll_content = LinearLayout(act)
            scroll_content.setOrientation(LinearLayout.VERTICAL)
            scroll_view.addView(scroll_content)

            sys_btn = TextView(act)
            sys_btn.setText("Выбрать из системы")
            sys_btn.setTextColor(-1) 
            sys_btn.setTextSize(1, 15.0)
            sys_btn.setTypeface(Typeface.DEFAULT_BOLD)
            sys_btn.setGravity(Gravity.CENTER)
            
            sys_bg = GradientDrawable()
            sys_bg.setColor(Theme.getColor(Theme.key_chats_actionBackground))
            sys_bg.setCornerRadius(16.0)
            sys_btn.setBackground(sys_bg)
            
            def open_system():
                if dialog_ref[0]: dialog_ref[0].dismiss()
                self._import_settings_picker()
                
            sys_btn.setOnClickListener(ClickListener(open_system))
            scroll_content.addView(sys_btn, LayoutHelper.createLinear(-1, 46, 12, 0, 12, 4))

            export_path = self._get_export_dir()

            files = []
            if os.path.exists(export_path):
                files = [f for f in os.listdir(export_path) if f.endswith(".json") or f.endswith(".qtfp")]
                files.sort(key=lambda x: os.path.getmtime(os.path.join(export_path, x)), reverse=True)

            if not files:
                empty_tv = TextView(act)
                empty_tv.setText("В стандартной папке пусто")
                empty_tv.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                empty_tv.setTextSize(1, 14.0)
                empty_tv.setGravity(Gravity.CENTER)
                empty_tv.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(10))
                scroll_content.addView(empty_tv, LayoutHelper.createLinear(-1, -2, 12, 0, 12, 4))
            else:
                for f_name in files:
                    file_path = os.path.join(export_path, f_name)
                    btn_tv = TextView(act)
                    btn_tv.setText(f_name)
                    btn_tv.setTextColor(blue_color)
                    btn_tv.setTextSize(1, 15.0)
                    btn_tv.setTypeface(Typeface.DEFAULT_BOLD)
                    btn_tv.setGravity(Gravity.CENTER)
                    btn_tv.setSingleLine(True)
                    btn_tv.setBackground(make_bg(blue_color))
                    
                    def make_click(fp, fname):
                        return lambda: (dialog_ref[0].dismiss() if dialog_ref[0] else None, self._load_and_show_config(fp, fname))
                        
                    btn_tv.setOnClickListener(ClickListener(make_click(file_path, f_name)))
                    scroll_content.addView(btn_tv, LayoutHelper.createLinear(-1, 46, 12, 0, 12, 4))

            root_layout.addView(scroll_view, LayoutHelper.createLinear(-1, -2, 1.0, 0, 0, 0, 0))

            cancel_tv = TextView(act)
            cancel_tv.setText("Отмена")
            cancel_tv.setTextColor(red_color)
            cancel_tv.setTextSize(1, 15.0)
            cancel_tv.setTypeface(Typeface.DEFAULT_BOLD)
            cancel_tv.setGravity(Gravity.CENTER)
            cancel_tv.setSingleLine(True)
            cancel_tv.setBackground(make_bg(red_color))
            cancel_tv.setOnClickListener(ClickListener(lambda: dialog_ref[0].dismiss() if dialog_ref[0] else None))
        
            root_layout.addView(cancel_tv, LayoutHelper.createLinear(-1, 46, 12, 0, 12, 4))

            AlertDialog = jclass("org.telegram.ui.ActionBar.AlertDialog")
            java_builder = AlertDialog.Builder(act)
            java_builder.setView(root_layout)
            dialog = java_builder.create()
            dialog.setCanceledOnTouchOutside(True)
            dialog.setCancelable(True)
            dialog.show()
            dialog_ref[0] = dialog

            try:
                window = dialog.getWindow()
                if window:
                    lp = window.getAttributes()
                    lp.width = int(AndroidUtilities.displaySize.x * 0.95)
                    window.setAttributes(lp)
            except: pass

        except Exception as e:
            from ui.bulletin import BulletinHelper
            from android_utils import run_on_ui_thread
            err_msg = str(e)[:50]
            run_on_ui_thread(lambda e_msg=err_msg: BulletinHelper.show_error(f"Ошибка окна: {e_msg}"))

    def _load_and_show_config(self, path, filename):
        config = self._load_config_from_file(path)
        if config:
            self._show_import_config_sheet(config, filename)
        else:
            from ui.bulletin import BulletinHelper
            from android_utils import run_on_ui_thread
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка чтения файла конфигурации"))

    def _show_share_dialog(self, filepath, filename):
        from android_utils import OnClickListener
        from java import jclass
        
        try:
            fragment = get_last_fragment()
            if not fragment: return
            
            activity = fragment.getParentActivity()
            if not activity: return
            
            BottomSheet = jclass("org.telegram.ui.ActionBar.BottomSheet")
            LinearLayout = jclass("android.widget.LinearLayout")
            TextView = jclass("android.widget.TextView")
            ImageView = jclass("android.widget.ImageView")
            FrameLayout = jclass("android.widget.FrameLayout")
            TypedValue = jclass("android.util.TypedValue")
            Gravity = jclass("android.view.Gravity")
            Theme = jclass("org.telegram.ui.ActionBar.Theme")
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            GradientDrawable = jclass("android.graphics.drawable.GradientDrawable")
            LayoutHelper = jclass("org.telegram.ui.Components.LayoutHelper")
            
            sheet = BottomSheet(activity, False)
            
            container = LinearLayout(activity)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16))
            
            icon_frame = FrameLayout(activity)
            
            icon_bg = GradientDrawable()
            icon_bg.setShape(GradientDrawable.OVAL)
            icon_bg.setColor(Theme.getColor(Theme.key_featuredStickers_addButton) & 0x15FFFFFF | 0x10000000)
            
            icon_view = ImageView(activity)
            R = jclass("org.telegram.messenger.R")
            icon_view.setImageResource(R.drawable.files_storage)
            icon_view.setColorFilter(Theme.getColor(Theme.key_featuredStickers_addButton))
            icon_view.setBackground(icon_bg)
            icon_view.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16), AndroidUtilities.dp(16))
            
            icon_params = jclass("android.widget.FrameLayout$LayoutParams")(AndroidUtilities.dp(72), AndroidUtilities.dp(72))
            icon_params.gravity = Gravity.CENTER
            icon_frame.addView(icon_view, icon_params)
            
            container.addView(icon_frame, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0, 16))
            
            title_view = TextView(activity)
            title_view.setText("Конфигурация сохранена")
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            title_view.setTypeface(AndroidUtilities.bold())
            title_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            title_view.setGravity(Gravity.CENTER)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0, 8))
            
            file_view = TextView(activity)
            file_view.setText(filename)
            file_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            file_view.setTypeface(AndroidUtilities.bold())
            file_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueText))
            file_view.setGravity(Gravity.CENTER)
            container.addView(file_view, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0, 8))
            
            desc_view = TextView(activity)
            desc_view.setText("Файл сохранён в папку Quotify+.\nОтправьте его, чтобы поделиться настройками!")
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setTextColor(Theme.getColor(Theme.key_dialogTextGray2))
            desc_view.setGravity(Gravity.CENTER)
            container.addView(desc_view, LayoutHelper.createLinear(-1, -2, 0, 0, 24, 0, 32))
            
            btn_share_frame = FrameLayout(activity)
            btn_share_bg = GradientDrawable()
            btn_share_bg.setCornerRadius(AndroidUtilities.dp(10))
            btn_share_bg.setColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            btn_share_frame.setBackground(btn_share_bg)
            
            share_text_view = TextView(activity)
            share_text_view.setText("Поделиться")
            share_text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            share_text_view.setTypeface(AndroidUtilities.bold())
            share_text_view.setTextColor(-1)
            share_text_view.setGravity(Gravity.CENTER)
            
            btn_share_frame.addView(share_text_view, LayoutHelper.createFrame(-1, -1))
            
            def on_share(v):
                sheet.dismiss()
                self._share_file(filepath, activity)
                
            btn_share_frame.setOnClickListener(OnClickListener(on_share))
            container.addView(btn_share_frame, LayoutHelper.createLinear(-1, 50, 0, 16, 0, 16, 12))
            
            btn_close_frame = FrameLayout(activity)
            btn_close_bg = GradientDrawable()
            btn_close_bg.setCornerRadius(AndroidUtilities.dp(10))
            btn_close_bg.setColor(Theme.getColor(Theme.key_listSelector))
            btn_close_frame.setBackground(btn_close_bg)
            
            close_text_view = TextView(activity)
            close_text_view.setText("Закрыть")
            close_text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            close_text_view.setTypeface(AndroidUtilities.bold())
            close_text_view.setTextColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            close_text_view.setGravity(Gravity.CENTER)
            
            btn_close_frame.addView(close_text_view, LayoutHelper.createFrame(-1, -1))
            
            def on_close(v):
                sheet.dismiss()
                
            btn_close_frame.setOnClickListener(OnClickListener(on_close))
            container.addView(btn_close_frame, LayoutHelper.createLinear(-1, 50, 0, 16, 0, 16, 8))
            
            sheet.setCustomView(container)
            sheet.show()
            
        except Exception as e:
            qlog(f"Error showing share dialog: {e}")
            BulletinHelper.show_success(f"Сохранено: {filename}")
    
    def _share_file(self, filepath, activity):
        try:
            from java import jclass
            
            Intent = jclass("android.content.Intent")
            File = jclass("java.io.File")
            FileProvider = jclass("androidx.core.content.FileProvider")
            ApplicationLoader = jclass("org.telegram.messenger.ApplicationLoader")
            
            file = File(filepath)
            uri = FileProvider.getUriForFile(
                activity,
                ApplicationLoader.getApplicationId() + ".provider",
                file
            )
            
            intent = Intent(Intent.ACTION_SEND)
            intent.setType("application/octet-stream")
            intent.putExtra(Intent.EXTRA_STREAM, uri)
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            
            chooser = Intent.createChooser(intent, "Share Configuration")
            activity.startActivity(chooser)
            
        except Exception as e:
            qlog(f"Error sharing file: {e}")

    def _handle_config_file_open(self, filepath: str):
        config = self._load_config_from_file(filepath)
        if config:
            filename = os.path.basename(filepath)
            run_on_ui_thread(lambda: self._show_import_config_sheet(config, filename))

    def _load_config_from_file(self, filepath: str):
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
            
            lines = content.split('\n')
            json_lines = [line for line in lines if not line.strip().startswith('#')]
            json_str = '\n'.join(json_lines)
            
            return json.loads(json_str)
        except Exception as e:
            qlog(f"Load config error: {e}")
            return None

    def _show_import_config_sheet(self, config_data: dict, filename: str):
        from android_utils import OnClickListener
        from java import jclass
        
        try:
            fragment = get_last_fragment()
            if not fragment: return
            
            activity = fragment.getParentActivity()
            if not activity: return
            
            BottomSheet = jclass("org.telegram.ui.ActionBar.BottomSheet")
            LinearLayout = jclass("android.widget.LinearLayout")
            TextView = jclass("android.widget.TextView")
            ImageView = jclass("android.widget.ImageView")
            FrameLayout = jclass("android.widget.FrameLayout")
            ScrollView = jclass("android.widget.ScrollView")
            TypedValue = jclass("android.util.TypedValue")
            Gravity = jclass("android.view.Gravity")
            Theme = jclass("org.telegram.ui.ActionBar.Theme")
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            GradientDrawable = jclass("android.graphics.drawable.GradientDrawable")
            LayoutHelper = jclass("org.telegram.ui.Components.LayoutHelper")
            TextUtils = jclass("android.text.TextUtils")
            TruncateAt = jclass("android.text.TextUtils$TruncateAt")
            
            sheet = BottomSheet(activity, False)
            
            main_container = LinearLayout(activity)
            main_container.setOrientation(LinearLayout.VERTICAL)
            main_container.setPadding(AndroidUtilities.dp(16), AndroidUtilities.dp(20), AndroidUtilities.dp(16), AndroidUtilities.dp(16))
            
            header_layout = LinearLayout(activity)
            header_layout.setOrientation(LinearLayout.HORIZONTAL)
            header_layout.setGravity(Gravity.CENTER_VERTICAL)
            
            icon_frame = FrameLayout(activity)
            icon_bg = GradientDrawable()
            icon_bg.setShape(GradientDrawable.OVAL)
            icon_bg.setColor(Theme.getColor(Theme.key_featuredStickers_addButton) & 0x15FFFFFF | 0x10000000)
            
            icon_view = ImageView(activity)
            R = jclass("org.telegram.messenger.R")
            icon_view.setImageResource(R.drawable.files_folder)
            icon_view.setColorFilter(Theme.getColor(Theme.key_featuredStickers_addButton))
            icon_view.setBackground(icon_bg)
            icon_view.setPadding(AndroidUtilities.dp(10), AndroidUtilities.dp(10), AndroidUtilities.dp(10), AndroidUtilities.dp(10))
            
            icon_frame.addView(icon_view, LayoutHelper.createFrame(48, 48))
            header_layout.addView(icon_frame, LayoutHelper.createLinear(48, 48, 0, 0, 16, 0))
            
            title_layout = LinearLayout(activity)
            title_layout.setOrientation(LinearLayout.VERTICAL)
            
            title_tv = TextView(activity)
            title_tv.setText("Импорт настроек")
            title_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            title_tv.setTypeface(AndroidUtilities.bold())
            title_tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            title_layout.addView(title_tv)
            
            plugin_ver = config_data.get("plugin_version", "Unknown")
            timestamp = config_data.get("timestamp", 0)
            date_str = time.strftime('%d.%m.%Y %H:%M', time.localtime(timestamp)) if timestamp > 0 else "Unknown"
            
            sub_tv = TextView(activity)
            sub_tv.setText(f"v{plugin_ver} • {date_str}")
            sub_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            sub_tv.setTextColor(Theme.getColor(Theme.key_dialogTextGray2))
            title_layout.addView(sub_tv)
            
            header_layout.addView(title_layout, LayoutHelper.createLinear(-1, -2))
            main_container.addView(header_layout, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0, 16))
            
            scroll = ScrollView(activity)
            scroll_content = LinearLayout(activity)
            scroll_content.setOrientation(LinearLayout.VERTICAL)
            
            settings = config_data.get("settings", {})
            
            key_names = {
                "quote_style": ("Стиль цитаты", {0: "Горизонтали (Левое)", 1: "Горизонтали (Правое)", 2: "Вертикали", 3: "Облако"}),
                "quote_render_image": "Рендеринг фото",
                "enable_transcription": "Авто-расшифровка",
                "transcription_provider": ("AI Провайдер", {0: "Gemini", 1: "NavyAI", 2: "Mistral", 3: "Deepgram"}),
                "text_color_hex": "Цвет текста",
                "author_color_hex": "Цвет автора",
                "cloud_bubble_color": "Цвет облака",
                "custom_bg_color": "Цвет фона",
                "quote_font_size": "Размер текста",
                "author_font_size": "Размер автора",
                "quote_image_radius": "Радиус углов (%)",
                "line_spacing": "Межстрочный интервал",
                "bg_dimming": "Затемнение фона",
                "bg_style": ("Стиль фона", {0: "Нет", 1: "Блюр", 2: "Стекло", 3: "Шум", 4: "Пиксели", 5: "Цвет", 6: "Градиент", 7: "Волны"}),
                "bg_filter": ("Фильтр", {0: "Нет", 1: "ЧБ", 2: "Сепия", 3: "Инверсия", 4: "Постер", 5: "Цвет", 6: "Контраст", 7: "Тиснение"}),
                "use_random_bg": "Случайный фон",
                "bg_use_custom": "Кастомный фон",
                "show_avatar": "Показ аватара",
                "avatar_size": "Размер аватара",
                "avatar_rounding": "Скругление аватара (%)",
                "avatar_use_custom": "Кастомный аватар",
                "use_profile_color": "Цвет из профиля",
                "ignore_last_name": "Скрывать фамилию",
                "vertical_text_align": ("Выравнивание", {0: "Слева", 1: "Центр", 2: "Справа"}),
                "quote_text_reduction": "Уменьшение текста (%)",
                "cloud_bubble_opacity": "Прозрачность облака (%)",
                "enable_attach_labels": "Метки вложений",
                "debug_logging": "Логирование"
            }
            
            list_bg = GradientDrawable()
            list_bg.setCornerRadius(AndroidUtilities.dp(12))
            list_bg.setColor(Theme.getColor(Theme.key_windowBackgroundWhite) & 0x00FFFFFF | 0x08000000)
            scroll_content.setBackground(list_bg)
            scroll_content.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
            
            for key, meta in key_names.items():
                if key in settings:
                    val = settings[key]
                    
                    if isinstance(meta, tuple):
                        name = meta[0]
                        val_str = meta[1].get(val, str(val))
                    else:
                        name = meta
                        if isinstance(val, bool):
                            val_str = "ВКЛ" if val else "ВЫКЛ"
                        else:
                            val_str = str(val)
                    
                    row = LinearLayout(activity)
                    row.setOrientation(LinearLayout.HORIZONTAL)
                    row.setPadding(0, AndroidUtilities.dp(6), 0, AndroidUtilities.dp(6))
                    
                    name_tv = TextView(activity)
                    name_tv.setText(name)
                    name_tv.setSingleLine(True)
                    name_tv.setEllipsize(TruncateAt.END)
                    name_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                    name_tv.setTextColor(Theme.getColor(Theme.key_dialogTextGray2))
                    row.addView(name_tv, LayoutHelper.createLinear(0, -2, 1.0))
                    
                    val_tv = TextView(activity)
                    val_tv.setText(val_str)
                    val_tv.setSingleLine(True)
                    val_tv.setEllipsize(TruncateAt.END)
                    val_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
                    val_tv.setTypeface(AndroidUtilities.bold())
                    
                    if isinstance(val, bool):
                        val_color = Theme.getColor(Theme.key_featuredStickers_addButton) if val else Theme.getColor(Theme.key_text_RedRegular)
                    else:
                        val_color = Theme.getColor(Theme.key_dialogTextBlack)
                        
                    val_tv.setTextColor(val_color)
                    row.addView(val_tv, LayoutHelper.createLinear(-2, -2))
                    
                    scroll_content.addView(row)

            total_keys = len(settings)
            shown_keys = len([k for k in key_names.keys() if k in settings])
            hidden_count = max(0, total_keys - shown_keys)

            if hidden_count > 0:
                more_tv = TextView(activity)
                more_tv.setText(f"...и ещё {hidden_count} системных параметров")
                more_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
                more_tv.setTextColor(Theme.getColor(Theme.key_dialogTextGray2))
                more_tv.setGravity(Gravity.CENTER)
                more_tv.setPadding(0, AndroidUtilities.dp(8), 0, 0)
                scroll_content.addView(more_tv)

            scroll.addView(scroll_content)
            main_container.addView(scroll, LayoutHelper.createLinear(-1, 180, 0, 0, 0, 0, 16))
            
            warn_tv = TextView(activity)
            warn_tv.setText("Текущие настройки будут заменены")
            warn_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            warn_tv.setTextColor(Theme.getColor(Theme.key_text_RedRegular))
            warn_tv.setGravity(Gravity.CENTER)
            main_container.addView(warn_tv, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 0, 20))
            
            btns_layout = LinearLayout(activity)
            btns_layout.setOrientation(LinearLayout.HORIZONTAL)
            
            cancel_frame = FrameLayout(activity)
            cancel_bg = GradientDrawable()
            cancel_bg.setCornerRadius(AndroidUtilities.dp(10))
            cancel_bg.setColor(Theme.getColor(Theme.key_listSelector)) 
            cancel_frame.setBackground(cancel_bg)
            
            cancel_tv = TextView(activity)
            cancel_tv.setText("Отмена")
            cancel_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
            cancel_tv.setTypeface(AndroidUtilities.bold())
            cancel_tv.setTextColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            cancel_tv.setGravity(Gravity.CENTER)
            
            cancel_frame.addView(cancel_tv, LayoutHelper.createFrame(-1, -1))
            
            def on_cancel(v):
                sheet.dismiss()
            
            cancel_frame.setOnClickListener(OnClickListener(on_cancel))
            btns_layout.addView(cancel_frame, LayoutHelper.createLinear(0, 48, 1.0, 0, 0, 8, 0))
            
            apply_frame = FrameLayout(activity)
            apply_bg = GradientDrawable()
            apply_bg.setCornerRadius(AndroidUtilities.dp(10))
            apply_bg.setColor(Theme.getColor(Theme.key_featuredStickers_addButton))
            apply_frame.setBackground(apply_bg)
            
            apply_tv = TextView(activity)
            apply_tv.setText("Применить")
            apply_tv.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
            apply_tv.setTypeface(AndroidUtilities.bold())
            apply_tv.setTextColor(-1)
            apply_tv.setGravity(Gravity.CENTER)
            
            apply_frame.addView(apply_tv, LayoutHelper.createFrame(-1, -1))
            
            def on_apply(v):
                sheet.dismiss()
                self._import_config_wrapper(config_data)
            
            apply_frame.setOnClickListener(OnClickListener(on_apply))
            btns_layout.addView(apply_frame, LayoutHelper.createLinear(0, 48, 1.0, 8, 0, 0, 0))
            
            main_container.addView(btns_layout, LayoutHelper.createLinear(-1, -2))
            
            sheet.setCustomView(main_container)
            sheet.show()
            
        except Exception as e:
            qlog(f"Error showing import sheet: {e}")
            self._import_config_wrapper(config_data)

    def _import_config_wrapper(self, config_data):
        try:
            settings = config_data.get("settings", {})
            count = 0
            for key, value in settings.items():
                self.set_setting(key, value)
                count += 1
            BulletinHelper.show_success(f"Настройки применены: {count}")
            self.refresh_settings()
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка применения: {e}")

    def _export_settings_json(self, view=None):
        try:
            qlog("Starting full settings export...")
            settings_data = {}
            defaults = self._get_settings_defaults()
            
            for key, default_val in defaults.items():
                val = self.get_setting(key, default_val)
                settings_data[key] = val
            
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            filename = f"quotify_settings_{timestamp}.json"
            
            export_dir = self._get_export_dir()
            file_path = os.path.join(export_dir, filename)
            
            qlog(f"Writing {len(settings_data)} keys to: {file_path}")
            
            with open(file_path, "w", encoding="utf-8") as f:
                json.dump(settings_data, f, indent=4, ensure_ascii=False)
                
            qlog("Export completed successfully.")
            BulletinHelper.show_success(f"Сохранено:\n{filename}")
        except Exception as e:
            qlog(f"Export failed: {e}", error=e)
            BulletinHelper.show_error("Ошибка экспорта")

    def _import_settings_picker(self, view=None):
        try:
            from client_utils import get_last_fragment
            from android.content import Intent
            from ui.bulletin import BulletinHelper
            
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Ошибка активити!")
                return
                
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("*/*") 
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            activity.startActivityForResult(Intent.createChooser(intent, "Выберите конфигурацию (.json / .qtfp)"), IMPORT_SETTINGS_CODE)
        except Exception as e:
            from ui.bulletin import BulletinHelper
            from android_utils import run_on_ui_thread
            err = str(e)[:50]
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка выбора файла: {err}"))

    def _handle_import_json(self, uri_string):
        from ui.bulletin import BulletinHelper
        from android_utils import run_on_ui_thread
        import json
        
        try:
            from org.telegram.messenger import ApplicationLoader
            from android.net import Uri
            from java.io import ByteArrayOutputStream
            
            uri = Uri.parse(uri_string)
            content_resolver = ApplicationLoader.applicationContext.getContentResolver()
            
            filename = "imported_config.qtfp"
            try:
                cursor = content_resolver.query(uri, None, None, None, None)
                if cursor and cursor.moveToFirst():
                    idx = cursor.getColumnIndex("_display_name")
                    if idx != -1:
                        filename = cursor.getString(idx)
                    cursor.close()
            except: pass

            input_stream = content_resolver.openInputStream(uri)
            if not input_stream:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка открытия файла"))
                return

            byte_stream = ByteArrayOutputStream()
            buffer = bytearray(4096)
            while True:
                read = input_stream.read(buffer)
                if read == -1: break
                byte_stream.write(buffer, 0, read)
            
            json_str = byte_stream.toString("UTF-8")
            input_stream.close()

            lines = json_str.split('\n')
            json_lines = [line for line in lines if not line.strip().startswith('#')]
            clean_json_str = '\n'.join(json_lines).strip()

            if not clean_json_str:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Файл пуст или имеет неверный формат"))
                return

            try:
                data = json.loads(clean_json_str)
            except json.JSONDecodeError:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Файл поврежден (не JSON)"))
                return

            run_on_ui_thread(lambda: self._show_import_config_sheet(data, filename))
            
        except Exception as e:
            qlog("Import critical error", error=e)
            err_msg = str(e)[:50]
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка импорта: {err_msg}"))

    def _open_url(self, url):
        try:
            current_fragment = get_last_fragment()
            if not current_fragment or not current_fragment.getParentActivity():
                return
            context = current_fragment.getParentActivity()
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            context.startActivity(intent)
        except Exception as e:
            qlog(f"Error opening URL: {e}")

    def create_avatar_settings(self):
        is_avatar_enabled = self.get_setting("show_avatar", True)
    
        settings = [
            Header("Отображение"),
            Switch(key="show_avatar", text="Показывать аватар", default=True, icon="msg_contacts", on_change=self.refresh_settings),
        ]
        
        if is_avatar_enabled:
            settings.extend([
                Input(key="avatar_size", text="Размер аватара", default="400", subtext="Для обычных стилей (50-400)", icon="msg_photo_crop"),
                Input(key="cloud_avatar_size", text="Размер аватара (Облако)", default="80", subtext="Размер в пикселях (рекомендуется 60-100)", icon="msg_msgbubble3"),
                Input(key="avatar_rounding", text="% скругления углов авы", default="100", subtext="0 = квадрат, 100 = круг", icon="msg_status_edit"),
                Divider(),
                Header("Кастомный аватар"),
                Switch(key="avatar_use_custom", text="Использовать кастомную аву", default=self.get_setting("avatar_use_custom", False), subtext="Используется, если аватар у пользователя отсутствует, или принудительно через команды.", icon="msg_photos"),
                Text(text="Выбрать из галереи", icon="msg_gallery", on_click=self._open_gallery_for_avatar),
                Text(text="Удалить кастомный аватар", icon="msg_delete", on_click=self._clear_custom_avatar, red=True),
                Divider(),
                Text(text="Сбросить встроенный аватар", icon="msg_retry", on_click=self._clear_builtin_avatar),
            ])
            
        return settings

    def create_font_settings(self):
        custom_font_path = self.get_setting("custom_font_path", "")
        current_font_text = f"Текущий шрифт: {os.path.basename(custom_font_path)}" if custom_font_path else "Шрифт не выбран"
        return [
            Header("Основной шрифт"),
            Selector(key="font", text="Шрифт", default=1, items=FontManager.get_fonts_names(), icon="msg_photo_text_regular"),
            Text(text="Как выбрать кастом шрифты", icon="msg_info", on_click=self._show_font_faq_alert),
            Divider(),
            Header("Google Fonts"),
            Input(key="gfonts_query", text="Поисковой запрос", default=self.get_setting("gfonts_query", ""), icon="ic_send"),
            Text(text="Найти и установить", icon="msg_search", on_click=self._search_google_fonts_and_pick),
            Divider(),
            Header("Загрузка своего шрифта"),
            Input(key="custom_font_url", text="Ссылка на кастом шрифт (.ttf)", default="", subtext="Вставьте прямую ссылку на .ttf файл.\nПример: https://example.com/font.ttf", icon="msg_photo_text_framed3"),
            Text(text="Загрузить файл шрифта (.ttf/.otf)", icon="files_folder_solar", accent=True, on_click=self._launch_font_file_picker),
            Text(text=current_font_text, icon="msg_log"),
        ]

    def create_background_settings(self):
        settings = [
            Header("Настройки фона"),
            Selector(
                key="bg_style",
                text="Стиль фона",
                default=0,
                items=["Без стиля", "Блюр", "Мокрое стекло", "Старый TV", "Пиксели", "Сплошной цвет", "Градиент", "Волны"],
                icon="msg_theme",
                on_change=self.refresh_settings
            )
        ]

        current_style = self.get_setting("bg_style", 0)

        if current_style == 1:
            settings.append(Input(key="bg_blur_radius", text="Размытие", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_photo_blur"))
        elif current_style == 2:
            settings.append(Input(key="bg_glass_blur_radius", text="Размытие", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_photo_blur"))
            settings.append(Input(key="bg_glass_opacity", text="Прозрачность наложения", default="80", subtext="Значение от 0 до 255", icon="msg_photo_flip"))
        elif current_style == 3:
            settings.append(Input(key="bg_tv_noise_intensity", text="Интенсивность шума", default="60", subtext="Сила эффекта в % (0-100)", icon="msg_voicechat"))
        elif current_style == 4:
            settings.append(Input(key="bg_pixel_size", text="Размер пикселя", default="20", subtext="Размер пикселя (например, 20)", icon="msg_spoiler"))
        elif current_style == 6:
            settings.append(Input(key="bg_gradient_color1", text="Цвет 1", default="#FF8040", subtext="HEX начального градиента", icon="msg_palette"))
            settings.append(Input(key="bg_gradient_color2", text="Цвет 2", default="#8040FF", subtext="HEX конечного градиента", icon="msg_palette"))
        elif current_style == 7:
            settings.append(Input(key="bg_waves_amplitude", text="Амплитуда", default="5", subtext="Сила искажения", icon="msg_status_edit_solar"))
            settings.append(Input(key="bg_waves_frequency", text="Частота", default="0.1", subtext="Частота волн", icon="msg_stats"))

        settings.extend([
            Selector(
                key="bg_filter",
                text="Фильтр фона",
                default=0,
                items=["Без фильтра", "Чёрно-белый", "Сепия", "Инверсия", "Постеризация", "Окрашивание", "Контраст", "Тиснение"],
                icon="msg_reactions",
                on_change=self.refresh_settings
            )
        ])
        
        current_filter = self.get_setting("bg_filter", 0)

        if current_filter == 4:
            settings.append(Input(key="filter_posterize_levels", text="Количество уровней", default="4", subtext="Количество цветовых уровней (2-8)", icon="msg_fave"))
        elif current_filter == 5:
            settings.append(Input(key="filter_colorize_black", text="HEX для чёрного", default="#000000", subtext="HEX", icon="msg_palette"))
            settings.append(Input(key="filter_colorize_white", text="HEX для белого", default="#FFD700", subtext="HEX", icon="msg_palette"))
        elif current_filter == 6:
            settings.append(Input(key="filter_contrast_factor", text="Сила контраста", default="2.0", subtext="Например, 1.5 или 2.0", icon="menu_feature_cover"))

        settings.extend([
            Input(key="bg_dimming", text="Затемнение фона", default="67", subtext="Значение от 0 (нет) до 100 (черный)", icon="msg_photo_flip"),
            Input(key="custom_bg_color", text="HEX фона", default="#000000", subtext="Введите HEX-код цвета (например, #000000)", icon="msg_colors"),
            Divider(),
            Header("Кастомный фон"),
            Switch(key="bg_use_custom", text="Использовать кастомный фон", default=self.get_setting("bg_use_custom", False), subtext="Принудительно заменяет фон. Может быть вызван командами, даже если выключено.", icon="msg_photos"),
            Text(text="Выбрать фон из галереи", icon="msg_gallery", on_click=self._open_gallery_for_bg),
            Text(text="Сбросить кастомный фон", icon="msg_delete", on_click=self._clear_custom_bg, red=True),
        ])
        return settings

    def create_labels_settings(self):
        return [
            Header("Основные"),
            Switch(key="enable_attach_labels", text="Включить метки", default=True, subtext="Добавлять подписи типа [фото] к тексту", icon="menu_tag_rename"),
            Input(key="attach_label_none", text="Неизвестное вложение", default="[вложение]", subtext="Используется, если тип не распознан", icon="msg_photo_flip"),
            Input(key="attach_label_file", text="Файл", default="[{name}.{ext} {size}]", subtext="Поддерживает {name}, {size}, {ext}", icon="msg_sendfile"),
            Divider(),
            Header("Медиа и сообщения"),
            Input(key="attach_label_photo", text="Фото", default="[фото]", icon="msg_photos"),
            Input(key="attach_label_video", text="Видео", default="[видео]", icon="menu_videocall"),
            Input(key="attach_label_gif", text="GIF", default="[гиф]", icon="msg_gif"),
            Input(key="attach_label_voice", text="Голосовое", default="[голосовое]", icon="input_mic"),
            Input(key="attach_label_round", text="Кружок", default="[кружок]", icon="input_video_solar"),
            Input(key="attach_label_audio", text="Музыка", default="[музыка]", icon="msg_tone_on"),
            Divider(),
            Header("Стикеры и эмодзи"),
            Input(key="attach_label_sticker", text="Стикер", default="[стикер]", icon="msg_sticker"),
            Input(key="attach_label_sticker_anim", text="Премиум стикер", default="[премиум стикер]", icon="input_smile"),
            Input(key="attach_label_gift", text="Подарок", default="[премиум]", icon="msg_gift_premium"),
            Divider(),
            Header("Другое"),
            Input(key="attach_label_poll", text="Опрос", default="[опрос]", icon="msg_topics"),
            Input(key="attach_label_geo", text="Геопозиция", default="[гео]", icon="msg_location"),
            Input(key="attach_label_contact", text="Контакт", default="[контакт]", icon="msg_contacts"),
            Input(key="attach_label_call", text="Звонок", default="[звонок]", icon="msg_calls"),
            Input(key="attach_label_story", text="История", default="[история]", icon="msg_msgbubble3"),
            Input(key="attach_label_story_mention", text="Упоминание в истории", default="[упоминание в истории]", icon="msg_mention"),
            Input(key="attach_label_date", text="Дата", default="[дата]", icon="msg_calendar2"),
        ]

    def create_statistics_settings(self):
        total = self.get_setting("quotify_stats_total", 0)
        normal = self.get_setting("quotify_stats_normal", 0)
        fake = self.get_setting("quotify_stats_fake", 0)
        bwaaa_val = self.get_setting("quotify_stats_bwaaa", 0)
        
        bwaaa_title = "Bwaaa?"
        bwaaa_icon = "msg_report_drugs_solar"
        
        if bwaaa_val > 0:
            bwaaa_title = "Noob bwaaa"
            bwaaa_icon = "msg_sticker_solar"

        if bwaaa_val > 99:
            bwaaa_title = "Pro bwaaa"
            bwaaa_icon = "menu_feature_reactions_solar"

        if bwaaa_val > 999:
            bwaaa_title = "Best bwaaa"
            bwaaa_icon = "menu_feature_premium"
        
        return [
            Header("Статистика использования"),
            Text(text=f"Всего создано цитат: {total}", icon="msg_fave"),
            Text(text=f"Обычные цитаты: {normal}", icon="menu_select_quote"),
            Text(text=f"Фейковые цитаты: {fake}", icon="msg_contacts_name"),
            Text(text=f"{bwaaa_title}: {bwaaa_val}", icon=bwaaa_icon),
            Divider(),
            Text(text="Подробная статистика по командам", icon="msg_list", create_sub_fragment=self._create_detailed_stats_fragment),
            Divider(),
            Text(text="Сбросить статистику", icon="msg_delete", red=True, on_click=self._confirm_reset_statistics)
        ]

    def _reset_statistics(self, bld, which):
        if bld: bld.dismiss()
        keys_to_reset = [
            "quotify_stats_total", "quotify_stats_normal", "quotify_stats_fake", "quotify_stats_bwaaa",
            "stats_cmd_q", "stats_cmd_qf", "stats_cmd_qc", "stats_cmd_qm",
            "stats_cmd_fq", "stats_cmd_fqf", "stats_cmd_fqc", "stats_cmd_fqm",
        ]
        for key in keys_to_reset:
            self.set_setting(key, 0)
        BulletinHelper.show_success("Статистика сброшена")
        self.refresh_settings()

    def _create_detailed_stats_fragment(self):
        cmd_keys = {
            "q_default": "stats_cmd_q", "q_force_bg": "stats_cmd_qf", "q_force_ava": "stats_cmd_qc", "q_force_both": "stats_cmd_qm",
            "fq_default": "stats_cmd_fq", "fq_force_bg": "stats_cmd_fqf", "fq_force_ava": "stats_cmd_fqc", "fq_force_both": "stats_cmd_fqm"
        }
        cmd_defaults = {
            "q_default": ".q", "q_force_bg": ".qb", "q_force_ava": ".qa", "q_force_both": ".qm",
            "fq_default": ".fq", "fq_force_bg": ".fqb", "fq_force_ava": ".fqa", "fq_force_both": ".fqm"
        }
        cmd_icons = {
            "q_default": "menu_select_quote", "q_force_bg": "msg_photos", "q_force_ava": "msg_contacts", "q_force_both": "menu_feature_reactions",
            "fq_default": "msg_contacts_name", "fq_force_bg": "msg_photos", "fq_force_ava": "msg_contacts", "fq_force_both": "menu_feature_reactions"
        }
        
        stats_list = [Header("Использование команд")]
        for key, stat_key in cmd_keys.items():
            cmd_name = self.get_setting(key, cmd_defaults[key])
            count = self.get_setting(stat_key, 0)
            icon = cmd_icons.get(key)
            stats_list.append(Text(text=f"{cmd_name}: использовано {count} раз", icon=icon))
            
        return stats_list

    def _confirm_reset_statistics(self, view=None):
        fragment = get_last_fragment()
        if not fragment or not fragment.getParentActivity():
            return
        activity = fragment.getParentActivity()
        builder = AlertDialogBuilder(activity)
        builder.set_title("Сброс статистики")
        builder.set_message("Вы уверены, что хотите сбросить всю статистику использования? Это действие необратимо.")
        builder.set_positive_button("Сбросить", self._reset_statistics)
        builder.set_negative_button("Отмена", lambda b, w: b.dismiss())
        builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
        builder.show()

    def _increment_stat(self, key):
        current_value = self.get_setting(key, 0)
        self.set_setting(key, current_value + 1)

    def _search_google_fonts_and_pick(self, view=None):
        try:
            import requests
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")
            return
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass
        query = (self.get_setting("gfonts_query", "") or "").strip().lower()
        api_key = "AIzaSyD8kUluAcDVA-VpHtcaeAW_HQ_dAf44q3s"
        try:
            url = f"https://www.googleapis.com/webfonts/v1/webfonts?key={api_key}&sort=popularity"
            resp = requests.get(url, timeout=20)
            if resp.status_code != 200:
                BulletinHelper.show_error("Ошибка Google Fonts")
                return
            data = resp.json()
            items = data.get("items", []) if isinstance(data, dict) else []
            if query:
                items = [it for it in items if query in (it.get("family", "").lower())]
            if not items:
                BulletinHelper.show_info("Ничего не найдено")
                return
            def show_family_picker():
                try:
                    from client_utils import get_last_fragment
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title("Поиск в Google Fonts")
                    names = [it.get("family", "?") for it in items]
                    def on_family(bld, index):
                        try:
                            bld.dismiss()
                            self._pick_gfont_variant(items[index])
                        except Exception:
                            pass
                    builder.set_items(names, on_family)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass
            run_on_ui_thread(show_family_picker)
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")

    def _pick_gfont_variant(self, item):
        try:
            from client_utils import get_last_fragment, run_on_ui_thread
            from ui.alert import AlertDialogBuilder
        except Exception:
            pass
        try:
            files = item.get("files", {}) if isinstance(item, dict) else {}
            candidates = [(variant, url) for variant, url in files.items() if isinstance(url, str) and (url.endswith('.ttf') or url.endswith('.otf'))]
            if not candidates:
                BulletinHelper.show_info("Доступны только варианты .ttf/.otf")
                return
            def show_variant_picker():
                try:
                    fragment = get_last_fragment()
                    ctx = fragment.getParentActivity() if fragment else None
                    if not ctx:
                        return
                    builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
                    builder.set_title("Поиск в Google Fonts")
                    items = [v for (v, _) in candidates]
                    def on_variant(bld, index):
                        try:
                            _, url = candidates[index]
                            self.set_setting("custom_font_url", url)
                            self.set_setting("font", 1)
                            BulletinHelper.show_success("Шрифт выбран!")
                            bld.dismiss()
                        except Exception:
                            bld.dismiss()
                    builder.set_items(items, on_variant)
                    builder.set_negative_button("OK", lambda d, w: d.dismiss())
                    builder.show()
                except Exception:
                    pass
            run_on_ui_thread(show_variant_picker)
        except Exception:
            BulletinHelper.show_error("Ошибка Google Fonts")

    def _hook_activity_for_picker(self, activity):
        if self._activity_hook:
            self._activity_hook.unhook()
        method = activity.getClass().getDeclaredMethod("onActivityResult", Integer.TYPE, Integer.TYPE, Intent)
        self._activity_hook = self.hook_method(method, self.ActivityResultHook(self))
        qlog("Hooked onActivityResult for activity.")
        
    def _launch_font_file_picker(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_GET_CONTENT)
            intent.setType("*/*")
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            activity.startActivityForResult(Intent.createChooser(intent, "Выберите файл шрифта"), FILE_PICK_REQUEST_CODE)
        except Exception as e:
            qlog(f"Font picker error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка при открытии выбора файла!"))

    def _open_gallery_for_bg(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.setType("image/*")
            activity.startActivityForResult(intent, PICK_BG_REQUEST_CODE)
        except Exception as e:
            qlog(f"BG picker error: {e}")
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _open_gallery_for_avatar(self, view=None):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                BulletinHelper.show_error("Не удалось получить текущий экран!")
                return
            self._hook_activity_for_picker(activity)
            intent = Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI)
            intent.setType("image/*")
            activity.startActivityForResult(intent, PICK_AVA_REQUEST_CODE)
        except Exception as e:
            qlog(f"Avatar picker error: {e}")
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _clear_custom_bg(self, view=None):
        try:
            path = self.get_setting("bg_custom_path", "")
            if path and os.path.exists(path):
                try:
                    os.remove(path)
                except Exception:
                    pass
            self.set_setting("bg_use_custom", False)
            self.set_setting("bg_custom_path", "")
            BulletinHelper.show_success("Фон сброшен")
        except Exception:
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _clear_builtin_avatar(self, view=None):
        try:
            cache_path = os.path.join(self._temp_dir_path, "fallback_cache.jpg")
            if os.path.exists(cache_path):
                os.remove(cache_path)
                threading.Thread(target=self._ensure_fallback_avatar_cached).start()
                BulletinHelper.show_success("Встроенный аватар сброшен")
            else:
                BulletinHelper.show_info("Аватар уже сброшен")
        except Exception:
            BulletinHelper.show_error("Ошибка при сбросе аватара")

    def _clear_custom_avatar(self, view=None):
        try:
            path = self.get_setting("avatar_custom_path", "")
            if path and os.path.exists(path):
                try:
                    os.remove(path)
                except Exception:
                    pass
            self.set_setting("avatar_use_custom", False)
            self.set_setting("avatar_custom_path", "")
            BulletinHelper.show_success("Аватар сброшен")
        except Exception:
            BulletinHelper.show_error("Не удалось выбрать изображение")

    def _handle_file_picker_result(self, uri_string: str, file_type: str):
        input_stream = None
        output_stream = None
        try:
            uri = Uri.parse(uri_string)
            content_resolver = ApplicationLoader.applicationContext.getContentResolver()
            
            if file_type == 'font':
                file_name = f"font_{uuid.uuid4()}"
                cursor = content_resolver.query(uri, None, None, None, None)
                if cursor is not None:
                    try:
                        if cursor.moveToFirst() and (idx := cursor.getColumnIndex("_display_name")) != -1:
                            file_name = cursor.getString(idx)
                    finally:
                        cursor.close()
                
                if not file_name.lower().endswith((".ttf", ".otf")):
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Файл не является шрифтом (.ttf/.otf)!"))
                    return
                    
                target_dir = File(self._temp_dir_path, "fonts")
                if not target_dir.exists(): target_dir.mkdirs()
                
                target_file_name = f"custom_{file_name}"
                target_file = File(target_dir, target_file_name)
                
                input_stream = content_resolver.openInputStream(uri)
                if not input_stream:
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось открыть файл!"))
                    return
                    
                output_stream = FileOutputStream(target_file)
                buffer = bytearray(4096)
                bytes_read = input_stream.read(buffer)
                while bytes_read != -1:
                    output_stream.write(buffer, 0, bytes_read)
                    bytes_read = input_stream.read(buffer)
                    
                self.set_setting("custom_font_path", target_file.getAbsolutePath())
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"Шрифт '{file_name}' загружен!"))
                
            else:
                try:
                    input_stream = content_resolver.openInputStream(uri)
                    bitmap = BitmapFactory.decodeStream(input_stream)
                    if input_stream: input_stream.close()
                    
                    if bitmap is None:
                        run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось декодировать изображение!"))
                        return

                    target_dir = File(self._temp_dir_path, "images")
                    if not target_dir.exists(): target_dir.mkdirs()
                    
                    target_file_name = f"custom_{file_type}_{uuid.uuid4()}.png"
                    target_file = File(target_dir, target_file_name)
                    
                    output_stream = FileOutputStream(target_file)
                    bitmap.compress(Bitmap.CompressFormat.PNG, 100, output_stream)
                    output_stream.flush()
                    bitmap.recycle()
                    
                    target_path = target_file.getAbsolutePath()
                    
                    if file_type == 'bg':
                        self.set_setting("bg_custom_path", target_path)
                        self.set_setting("bg_use_custom", True)
                        run_on_ui_thread(lambda: BulletinHelper.show_success("Фон обновлён"))
                    elif file_type == 'avatar':
                        self.set_setting("avatar_custom_path", target_path)
                        run_on_ui_thread(lambda: BulletinHelper.show_success("Аватар обновлён"))
                        
                except Exception as e:
                    qlog(f"Image decode error: {e}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка обработки изображения"))
                    
            self.refresh_settings()
        except Exception as e:
            qlog(f"File handle error ({file_type}): {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка при обработке файла!"))
        finally:
            if input_stream:
                try: input_stream.close()
                except: pass
            if output_stream:
                try: output_stream.close()
                except: pass

    def refresh_settings(self, *args):
        def refresher():
            try:
                from android_utils import R as RunnableArg 
                fragment = get_last_fragment()
                listView = None
                
                if fragment:
                    cls_name = str(fragment.getClass().getName())
                    if "PluginSettingsActivity" in cls_name:
                        listView = get_private_field(fragment, "listView")

                if not listView:
                    PluginsController.getInstance().loadPluginSettings(self.id)
                    return

                listView.animate()\
                    .alpha(0.0)\
                    .setDuration(80)\
                    .setInterpolator(AccelerateDecelerateInterpolator())\
                    .withEndAction(RunnableArg(lambda: self._on_fade_out_complete(listView)))\
                    .start()

            except Exception:
                PluginsController.getInstance().loadPluginSettings(self.id)

        run_on_ui_thread(refresher)

    def _on_fade_out_complete(self, listView):
        try:
            from android_utils import R as RunnableArg
            from android.view.animation import DecelerateInterpolator
            
            PluginsController.getInstance().loadPluginSettings(self.id)
            
            def start_fade_in():
                try:
                    listView.setAlpha(0.0)
                    listView.setTranslationY(20.0)
                    listView.animate()\
                        .alpha(1.0)\
                        .translationY(0.0)\
                        .setDuration(180)\
                        .setInterpolator(DecelerateInterpolator())\
                        .start()
                except: pass

            Handler(Looper.getMainLooper()).postDelayed(RunnableArg(start_fade_in), 50)

        except Exception: pass

    def get_attach_label(self, t):
        mapping = {
            1: "attach_label_photo",
            2: "attach_label_voice",
            3: "attach_label_video",
            4: "attach_label_geo",
            5: "attach_label_round",
            8: "attach_label_gif",
            9: "attach_label_file",
            10: "attach_label_date",
            11: "attach_label_photo",
            12: "attach_label_contact",
            13: "attach_label_sticker",
            14: "attach_label_audio",
            15: "attach_label_sticker_anim",
            16: "attach_label_call",
            17: "attach_label_poll",
            21: "attach_label_photo",
            23: "attach_label_story",
            24: "attach_label_story_mention",
            25: "attach_label_gift"
        }
        
        settings_key = mapping.get(t)
        
        default_key = f"ATTACH_TYPE_{t}"
        default_label = LocalizationManager.get_string(default_key)
        
        fallback_label = self.get_setting("attach_label_none", "[вложение]")

        if default_label == default_key:
            actual_default = fallback_label
        else:
            actual_default = default_label

        if not settings_key:
            return actual_default
            
        return self.get_setting(settings_key, actual_default)

    def on_send_message_hook(self, account, params) -> HookStrategy:
        if params.message is None or not isinstance(params.message, str):
            return HookResult()

        message_text = params.message.strip()
        entities = getattr(params, 'entities', None)
        if entities and entities.size() > 0:
            try:
                custom_entities = []
                for i in range(entities.size()):
                    e = entities.get(i)
                    if isinstance(e, TLRPC.TL_messageEntityCustomEmoji):
                        custom_entities.append(e)
                if custom_entities:
                    custom_entities.sort(key=lambda x: x.offset, reverse=True)
                    u16 = message_text.encode('utf-16-le')
                    for e in custom_entities:
                        start_byte = e.offset * 2
                        end_byte = (e.offset + e.length) * 2
                        if start_byte < len(u16) and end_byte <= len(u16):
                            doc_id = e.document_id
                            placeholder = f"[CEMOJI:{doc_id}]".encode('utf-16-le')
                            u16 = u16[:start_byte] + placeholder + u16[end_byte:]
                    message_text = u16.decode('utf-16-le')
            except Exception:
                pass

        font_index = self.get_setting("font", 1)
        layout_index = self.get_setting("layout", 1)
        fixed_width = self.get_setting("fixed_width", True)

        custom_bg_path = self.get_setting("bg_custom_path", "")
        custom_avatar_path = self.get_setting("avatar_custom_path", "")
        is_bg_forced_by_setting = self.get_setting("bg_use_custom", False)
        
        q_cmd = self.get_setting("q_default", ".q").strip().lower()
        qf_cmd = self.get_setting("q_force_bg", ".qb").strip().lower()
        qc_cmd = self.get_setting("q_force_ava", ".qa").strip().lower()
        qm_cmd = self.get_setting("q_force_both", ".qm").strip().lower()
        
        parts_all = message_text.split(" ", 1)
        cmd_token = parts_all[0].lower()
        rest_after_cmd = parts_all[1].strip() if len(parts_all) > 1 else ""

        is_quote = False
        force_bg = is_bg_forced_by_setting
        force_av = False
        override_author = None

        if cmd_token == q_cmd:
            is_quote = True
            override_author = rest_after_cmd
        elif cmd_token == qf_cmd:
            is_quote = True
            force_bg = True
            override_author = rest_after_cmd
        elif cmd_token == qc_cmd:
            is_quote = True
            force_av = True
            override_author = rest_after_cmd
        elif cmd_token == qm_cmd:
            is_quote = True
            force_bg = True
            force_av = True
            override_author = rest_after_cmd
        
        if is_quote:
            qlog(f"[CMD] Quote detected: {cmd_token} | Args: '{rest_after_cmd}' | ForceBG: {force_bg} | ForceAva: {force_av}")
            try:
                if force_bg and not (custom_bg_path and os.path.exists(custom_bg_path)):
                    qlog("[ERROR] Custom BG forced but file missing")
                    BulletinHelper.show_error("⚠️ Вы не выбрали кастомный фон! (Настройки -> Фон -> Выбрать)")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                if force_av and not (custom_avatar_path and os.path.exists(custom_avatar_path)):
                    qlog("[ERROR] Custom Avatar forced but file missing")
                    BulletinHelper.show_error("⚠️ Вы не выбрали кастомную аватарку! (Настройки -> Аватар -> Кастом)")
                    return HookResult(strategy=HookStrategy.CANCEL)

                if params.replyToMsg is None:
                    qlog("[ERROR] No reply message")
                    BulletinHelper.show_error("⚠️ Ты забыл реплайнуть сообщение!")
                    return HookResult(strategy=HookStrategy.CANCEL)
                    
                self._increment_stat("quotify_stats_total")
                self._increment_stat("quotify_stats_normal")
                if cmd_token == q_cmd: self._increment_stat("stats_cmd_q")
                elif cmd_token == qf_cmd: self._increment_stat("stats_cmd_qf")
                elif cmd_token == qc_cmd: self._increment_stat("stats_cmd_qc")
                elif cmd_token == qm_cmd: self._increment_stat("stats_cmd_qm")
                
                self.last_cmd = cmd_token

                quote = QuoteManager(params, font_index, layout_index, fixed_width, self, custom_bg_path, custom_avatar_path, force_bg, force_av, search_query=override_author)
                quote.generate_quote()
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                qlog(f"Quote error: {e}", error=e)
                BulletinHelper.show_error("⛔ Произошла ошибка в коде плагина")
                return HookResult(strategy=HookStrategy.CANCEL)

        fq_cmd = self.get_setting("fq_default", ".fq").strip().lower()
        fqf_cmd = self.get_setting("fq_force_bg", ".fqb").strip().lower()
        fqc_cmd = self.get_setting("fq_force_ava", ".fqa").strip().lower()
        fqm_cmd = self.get_setting("fq_force_both", ".fqm").strip().lower()

        is_fake = False
        force_bg_fake = is_bg_forced_by_setting
        force_av_fake = False

        if cmd_token == fq_cmd:
            is_fake = True
        elif cmd_token == fqf_cmd:
            is_fake = True
            force_bg_fake = True
        elif cmd_token == fqc_cmd:
            is_fake = True
            force_av_fake = True
        elif cmd_token == fqm_cmd:
            is_fake = True
            force_bg_fake = True
            force_av_fake = True

        if is_fake:
            qlog(f"[CMD] Fake Quote detected: {cmd_token} | ForceBG: {force_bg_fake} | ForceAva: {force_av_fake}")
            if force_bg_fake and not (custom_bg_path and os.path.exists(custom_bg_path)):
                BulletinHelper.show_error("⚠️ Вы не выбрали кастомный фон! (Настройки -> Фон -> Выбрать)")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            if force_av_fake and not (custom_avatar_path and os.path.exists(custom_avatar_path)):
                BulletinHelper.show_error("⚠️ Вы не выбрали кастомную аватарку! (Настройки -> Аватар -> Кастом)")
                return HookResult(strategy=HookStrategy.CANCEL)

            fake_text = rest_after_cmd
            if not fake_text:
                qlog("[WARN] Fake quote text empty")
                BulletinHelper.show_error("⚠️ Укажи текст после команды")
                return HookResult(strategy=HookStrategy.CANCEL)
                
            sep = self.get_setting("fake_name_separator", DEFAULT_FAKE_NAME_SEPARATOR)
                
            override_author = None
            search_query = None

            if sep and sep in fake_text:
                text_part, name_part = fake_text.rsplit(sep, 1)
                fake_text = text_part.strip()
                search_query = name_part.strip()
                qlog(f"[FAKE] Parsed | Text: {len(fake_text)} chars | Search Query: {search_query}")
                    
            try:
                self._increment_stat("quotify_stats_total")
                self._increment_stat("quotify_stats_fake")
                if cmd_token == fq_cmd: self._increment_stat("stats_cmd_fq")
                elif cmd_token == fqf_cmd: self._increment_stat("stats_cmd_fqf")
                elif cmd_token == fqc_cmd: self._increment_stat("stats_cmd_fqc")
                elif cmd_token == fqm_cmd: self._increment_stat("stats_cmd_fqm")
                
                self.last_cmd = cmd_token

                quote = QuoteManager(params, font_index, layout_index, fixed_width, self, custom_bg_path, custom_avatar_path, force_bg_fake, force_av_fake, search_query=search_query)
                quote.generate_fake_quote(fake_text)
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception as e:
                qlog(f"Fake quote error: {e}", error=e)
                BulletinHelper.show_error("⛔ Произошла ошибка в коде плагина")
                return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult()

    def on_plugin_unload(self):
        for h in self._hooks:
            self.unhook_method(h)
        self._hooks.clear()
        
        if self._activity_hook:
            self._activity_hook.unhook()
            
        self._rm()
        if self.tmp and os.path.exists(self.tmp): shutil.rmtree(self.tmp, ignore_errors=True)
        try:
            EmojiRenderer._cache.clear()
        except:
            pass

plugin_instance = QuotifyForkPlugin()