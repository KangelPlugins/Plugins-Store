import requests
import socket
import json
import time
import base64
import urllib.parse
import re
import traceback
import yaml
import os
import threading
import shlex
from typing import Any, Dict, Optional, List
from concurrent.futures import ThreadPoolExecutor, as_completed

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import run_on_queue, EXTERNAL_NETWORK_QUEUE, send_message, get_last_fragment, get_account_instance, get_user_config
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Switch, Text, Input
from android_utils import log, run_on_ui_thread
from org.telegram.messenger import LocaleController, SendMessagesHelper, FileLoader, ApplicationLoader
from org.telegram.tgnet import TLRPC
from java.io import File

__id__ = "vlesstools"
__name__ = "VLESS Tools"
__version__ = "1.0"
__icon__ = "jibunNacho/3"
__author__ = "@yzewe"
__min_version__ = "11.12.0"
__description__ = "Proxy Utility. Use .vhelp"

class VlessToolsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.progress_dialog: Optional[AlertDialogBuilder] = None
        self.lang = "ru" if LocaleController.getInstance().getCurrentLocaleInfo().shortName == "ru" else "en"
        self.ping_cache = {}
        self.cache_ttl = 300
        
        self.strings = {
            "ru": {
                "wait": "Обработка...", "err": "Ошибка", "err_net": "Ошибка сети",
                "err_inv": "Неверные аргументы", "err_notfound": "Пустой ответ или файл не найден",
                "err_no_proxies": "Конфигурации не найдены.", "err_sending": "Ошибка отправки",
                "err_reply_format": "Ответьте на сообщение с конфигом/файлом.",
                "err_happ": "Ошибка API Unhapp", "err_dns": "Ошибка DNS",
                "cat_main": "Меню", "cat_settings": "Настройки",
                "cmd_help": "Справка",
                "cmd_download": "Скачать (Link/Happ)",
                "cmd_happ": "Расшифровать Happ",
                "cmd_ping": "Проверка доступности",
                "cmd_convert": "Конвертер",
                "cmd_clean": "Очистка имен",
                "h_net": "Сеть", "h_conv": "Конвертация",
                "s_headers": "HTTP Заголовки", "s_headers_sub": "Header: Value (с новой строки)",
                "s_file": "Результат файлом", "s_live": "Только рабочие",
                "s_dedup": "Удалять дубликаты", "s_timeout": "Таймаут пинга (сек)",
                "rep_ping": "Отчет доступности", "rep_live": "Живых", "rep_total": "Всего",
                "act": "OK", "inact": "DEAD", "conv_ok": "Успешно", "clean_ok": "Очищено",
                "happ_res": "Результат Unhapp", "orig": "Ввод", "res": "Вывод"
            },
            "en": {
                "wait": "Processing...", "err": "Error", "err_net": "Network Error",
                "err_inv": "Invalid arguments", "err_notfound": "Empty response or file not found",
                "err_no_proxies": "No configs found.", "err_sending": "Sending error",
                "err_reply_format": "Reply to a message with config/file.",
                "err_happ": "Unhapp API Error", "err_dns": "DNS Error",
                "cat_main": "Menu", "cat_settings": "Settings",
                "cmd_help": "Help",
                "cmd_download": "Download (Link/Happ)",
                "cmd_happ": "Decrypt Happ",
                "cmd_ping": "Check Availability",
                "cmd_convert": "Converter",
                "cmd_clean": "Name Cleaner",
                "h_net": "Network", "h_conv": "Conversion",
                "s_headers": "HTTP Headers", "s_headers_sub": "Header: Value (new line)",
                "s_file": "Send as file", "s_live": "Keep live only",
                "s_dedup": "Remove duplicates", "s_timeout": "Ping timeout (sec)",
                "rep_ping": "Availability Report", "rep_live": "Live", "rep_total": "Total",
                "act": "OK", "inact": "DEAD", "conv_ok": "Success", "clean_ok": "Cleaned",
                "happ_res": "Unhapp Result", "orig": "Input", "res": "Output"
            }
        }

    def t(self, key):
        return self.strings.get(self.lang, self.strings["en"]).get(key, key)

    def on_plugin_load(self):
        self.add_on_send_message_hook()

    def create_settings(self):
        return [
            Header(text=self.t("cat_main")),
            Text(text=self.t("cmd_help") + ": `.vhelp`"),
            Text(text=self.t("cmd_download") + ": `.vdl <url>`"),
            Text(text=self.t("cmd_happ") + ": `.vhapp <url>`"),
            Text(text=self.t("cmd_ping") + ": `.vping <src>`"),
            Text(text=self.t("cmd_convert") + ": `.vconv <fmt> <src>`"),
            Text(text=self.t("cmd_clean") + ": `.vclean <src>`"),

            Header(text=self.t("h_net")),
            Input(key="custom_headers", text=self.t("s_headers"), default="", subtext=self.t("s_headers_sub")),
            Input(key="ping_timeout", text=self.t("s_timeout"), default="3"),
            
            Header(text=self.t("h_conv")),
            Switch(key="output_as_file", text=self.t("s_file"), default=True),
            Switch(key="keep_live_only", text=self.t("s_live"), default=False),
            Switch(key="remove_duplicates", text=self.t("s_dedup"), default=True),
        ]

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        msg = str(getattr(params, "message", "")).strip()
        if not msg.startswith(".v"): return HookResult()
        
        try: parts = shlex.split(msg)
        except: parts = msg.split()
        if not parts: return HookResult()
        
        cmd = parts[0].lower()
        cmd_map = {
            ".vdl": "h_download",
            ".vhapp": "h_happ", 
            ".vping": "h_ping",
            ".vconv": "h_convert",
            ".vclean": "h_clean",
            ".vhelp": "h_help"
        }
        
        if cmd in cmd_map:
            self._prog(True)
            run_on_queue(lambda: self._exec(cmd_map[cmd], parts[1:], params), EXTERNAL_NETWORK_QUEUE)
            return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

    def _prog(self, show):
        def _a():
            if show:
                f = get_last_fragment()
                if f and f.getParentActivity():
                    self.progress_dialog = AlertDialogBuilder(f.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                    self.progress_dialog.set_message(self.t("wait"))
                    self.progress_dialog.show(); self.progress_dialog.set_cancelable(False)
            elif self.progress_dialog:
                self.progress_dialog.dismiss(); self.progress_dialog = None
        run_on_ui_thread(_a)

    def _exec(self, h_name, args, params):
        try:
            handler = getattr(self, h_name)
            if h_name != "h_help" and not args and not params.replyToMsg:
                self._reply(params, self.t("err"), [("Error", self.t("err_inv"))])
                return

            result = handler(args, params)
            if result is None:
                self._prog(False)
                return

            title, lines = result
            self._reply(params, title, lines)
        except Exception as e:
            self._reply(params, self.t("err"), [(self.t("err"), str(e))])
            log(traceback.format_exc())

    def h_convert(self, args, params):
        to_format = "clash"
        input_args = []
        fmt_aliases = {
            "json": "singbox", "sb": "singbox", "singbox": "singbox",
            "yaml": "clash", "clash": "clash",
            "txt": "txt", "links": "txt", "vless": "txt", "base64": "txt"
        }

        if args and args[0].lower() in fmt_aliases:
            to_format = fmt_aliases[args[0].lower()]
            input_args = args[1:]
        else:
            i = 0
            while i < len(args):
                if args[i] == "-to" and i + 1 < len(args):
                    val = args[i+1].lower()
                    if val in fmt_aliases: to_format = fmt_aliases[val]
                    i += 2
                else:
                    input_args.append(args[i])
                    i += 1
        
        content = self._get_input_content_from_context(input_args, params)
        proxies = self._parse_input(content)
        if not proxies: raise Exception(self.t("err_no_proxies"))

        if self.get_setting("keep_live_only", False):
            live_proxies = []
            with ThreadPoolExecutor(max_workers=10) as executor:
                futures = {executor.submit(self._check_server_availability, p['server'], p['port']): p for p in proxies}
                for future in as_completed(futures):
                    p = futures[future]
                    try: 
                        if future.result(): live_proxies.append(p)
                    except: pass
            proxies = live_proxies
            if not proxies: raise Exception(self.t("err_no_proxies"))
        
        for i, p in enumerate(proxies):
            if not p.get('original_name'): p['original_name'] = f"{p['type']}_{i+1}"
            p['name'] = p['original_name']

        if to_format == "clash":
            out_content = self._generate_clash_yaml(proxies)
            filename = "config.yaml"
        elif to_format == "singbox":
            out_content = self._generate_singbox_json(proxies)
            filename = "config.json"
        else:
            out_content = self._generate_links(proxies)
            filename = "proxies.txt"

        if self.get_setting("output_as_file", True):
            self._save_and_send_file(out_content, filename, params)
            return None
        else:
            return self.t("conv_ok"), [("Format", to_format), ("Content", f"```{out_content}```")]

    def h_clean(self, args, params):
        content = self._get_input_content_from_context(args, params)
        proxies = self._parse_input(content)
        if not proxies: raise Exception(self.t("err_no_proxies"))

        for i, p in enumerate(proxies):
            orig = p.get('original_name', f"Proxy_{i+1}")
            clean = re.sub(r'[^\x00-\x7F]+', '', orig)
            clean = re.sub(r'(@\w+|https?://\S+)', '', clean)
            clean = re.sub(r'[\[\]\(\)\{\}\|]', '', clean)
            clean = re.sub(r'\s+', ' ', clean).strip()
            if not clean or len(clean) < 2:
                clean = f"{p['type'].upper()}_{i+1}"
            p['original_name'] = clean
            p['name'] = clean

        out_content = self._generate_links(proxies)
        
        if self.get_setting("output_as_file", True):
            self._save_and_send_file(out_content, "cleaned.txt", params)
            return None
        else:
            return self.t("clean_ok"), [("Content", f"```{out_content}```")]

    def _parse_input(self, text_content: str) -> List[Dict]:
        proxies = []
        try:
            data = json.loads(text_content)
            if 'outbounds' in data:
                for out in data['outbounds']:
                    p = self._extract_from_singbox(out)
                    if p: proxies.append(p)
                if proxies: return self._post_process(proxies)
        except: pass

        try:
            if 'proxies:' in text_content or 'Proxy:' in text_content:
                data = yaml.safe_load(text_content)
                raw_proxies = data.get('proxies') or data.get('Proxy')
                if raw_proxies and isinstance(raw_proxies, list):
                    for p_data in raw_proxies:
                        p = self._extract_from_clash(p_data)
                        if p: proxies.append(p)
                    if proxies: return self._post_process(proxies)
        except: pass

        lines = text_content.splitlines()
        for line in lines:
            line = line.strip()
            p = None
            if line.startswith('vless://'): p = self._parse_vless(line)
            elif line.startswith('ss://'): p = self._parse_ss(line)
            elif line.startswith('vmess://'): p = self._parse_vmess(line)
            elif line.startswith('trojan://'): p = self._parse_trojan(line)
            if p: proxies.append(p)
            
        return self._post_process(proxies)

    def _post_process(self, proxies):
        if self.get_setting("remove_duplicates", True):
            unique = {}
            for p in proxies:
                k = f"{p.get('server')}:{p.get('port')}:{p.get('type')}"
                if k not in unique: unique[k] = p
            proxies = list(unique.values())
        
        for p in proxies:
            if p.get('original_name'):
                try: p['original_name'] = urllib.parse.unquote(p['original_name'])
                except: pass
        return proxies

    def _extract_from_singbox(self, out):
        t = out.get('type')
        if t in ['selector', 'direct', 'block', 'urltest', 'dns']: return None
        p = {'type': 'unknown', 'server': out.get('server'), 'port': out.get('server_port'), 'original_name': out.get('tag', 'proxy')}
        if t == 'vless':
            p.update({'type': 'vless', 'uuid': out.get('uuid'), 'flow': out.get('flow', '')})
            tls = out.get('tls', {})
            p['security'] = 'tls' if tls.get('enabled') else 'none'
            p['sni'] = tls.get('server_name', '')
            p['fp'] = tls.get('utls', {}).get('fingerprint', 'chrome')
            p['pbk'] = tls.get('reality', {}).get('public_key', '')
            p['sid'] = tls.get('reality', {}).get('short_id', '')
            transport = out.get('transport', {})
            p['network'] = transport.get('type', 'tcp')
            if p['network'] == 'ws':
                p['ws_path'] = transport.get('path', '/')
                p['ws_host'] = transport.get('headers', {}).get('Host', '')
            elif p['network'] == 'grpc':
                p['grpc_service'] = transport.get('service_name', '')
        elif t == 'vmess':
            p.update({'type': 'vmess', 'uuid': out.get('uuid'), 'aid': out.get('alter_id', 0)})
            tls = out.get('tls', {})
            p['security'] = 'tls' if tls.get('enabled') else 'none'
            p['sni'] = tls.get('server_name', '')
            transport = out.get('transport', {})
            p['network'] = transport.get('type', 'tcp')
            if p['network'] == 'ws':
                p['ws_path'] = transport.get('path', '/')
                p['ws_host'] = transport.get('headers', {}).get('Host', '')
        elif t == 'trojan':
            p.update({'type': 'trojan', 'password': out.get('password'), 'sni': out.get('tls', {}).get('server_name', '')})
        elif t == 'shadowsocks':
            p.update({'type': 'ss', 'method': out.get('method'), 'password': out.get('password')})
        else: return None
        return p

    def _extract_from_clash(self, data):
        t = data.get('type')
        p = {'type': 'unknown', 'server': data.get('server'), 'port': data.get('port'), 'original_name': data.get('name', 'proxy')}
        if t == 'vless':
            p.update({'type': 'vless', 'uuid': data.get('uuid'), 'flow': data.get('flow', '')})
            p['security'] = 'tls' if data.get('tls') else 'none'
            p['sni'] = data.get('servername', '')
            p['fp'] = data.get('client-fingerprint', 'chrome')
            p['network'] = data.get('network', 'tcp')
            reality = data.get('reality-opts', {})
            if reality:
                p['pbk'] = reality.get('public-key', '')
                p['sid'] = reality.get('short-id', '')
            if p['network'] == 'ws':
                ws = data.get('ws-opts', {})
                p['ws_path'] = ws.get('path', '/')
                p['ws_host'] = ws.get('headers', {}).get('Host', '')
            elif p['network'] == 'grpc':
                p['grpc_service'] = data.get('grpc-opts', {}).get('grpc-service-name', '')
        elif t == 'vmess':
            p.update({'type': 'vmess', 'uuid': data.get('uuid'), 'aid': data.get('alterId', 0)})
            p['security'] = 'tls' if data.get('tls') else 'auto'
            p['sni'] = data.get('servername', '')
            p['network'] = data.get('network', 'tcp')
            if p['network'] == 'ws':
                ws = data.get('ws-opts', {})
                p['ws_path'] = ws.get('path', '/')
                p['ws_host'] = ws.get('headers', {}).get('Host', '')
        elif t == 'trojan':
            p.update({'type': 'trojan', 'password': data.get('password'), 'sni': data.get('sni', '')})
        elif t == 'ss':
            p.update({'type': 'ss', 'method': data.get('cipher'), 'password': data.get('password')})
        else: return None
        return p

    def _parse_vless(self, link):
        try:
            parsed = urllib.parse.urlparse(link); params = urllib.parse.parse_qs(parsed.query)
            if parsed.scheme != 'vless': return None
            raw_sid = params.get('sid', [''])[0].strip(); clean_sid = ''
            if raw_sid:
                temp_sid = re.sub(r'[^0-9a-fA-F]', '', raw_sid)
                if len(temp_sid) % 2 != 0: temp_sid = '0' + temp_sid
                if len(temp_sid) > 16: temp_sid = temp_sid[:16]
                clean_sid = temp_sid.lower()
            conf = {'type': 'vless', 'uuid': parsed.username, 'server': parsed.hostname, 'port': int(parsed.port), 'flow': params.get('flow', [''])[0], 'security': params.get('security', [''])[0], 'pbk': params.get('pbk', [''])[0], 'sid': clean_sid, 'fp': params.get('fp', ['chrome'])[0], 'sni': params.get('sni', [''])[0], 'raw_link': link, 'original_name': urllib.parse.unquote(parsed.fragment), 'network': params.get('type', ['tcp'])[0], 'grpc_service': params.get('serviceName', [''])[0], 'ws_path': params.get('path', ['/'])[0], 'ws_host': params.get('host', [''])[0]}
            if conf['network'] not in ['grpc', 'ws']:
                if 'grpc' in link or conf['grpc_service']: conf['network'] = 'grpc'
                elif 'ws' in link or conf['ws_path'] != '/': conf['network'] = 'ws'
            return conf
        except: return None

    def _parse_ss(self, link):
        try:
            parsed = urllib.parse.urlparse(link)
            if parsed.scheme != 'ss': return None
            user = base64.b64decode(urllib.parse.unquote(parsed.username) + '=' * (-len(parsed.username) % 4)).decode('utf-8', errors='ignore')
            method, password = user.split(':', 1)
            return {'type': 'ss', 'server': parsed.hostname, 'port': int(parsed.port), 'method': method, 'password': password, 'original_name': urllib.parse.unquote(parsed.fragment), 'raw_link': link}
        except: return None

    def _parse_vmess(self, link):
        try:
            if not link.startswith('vmess://'): return None
            b64 = link[8:]; b64 += '=' * (-len(b64) % 4)
            data = json.loads(base64.b64decode(b64).decode('utf-8', errors='ignore'))
            return {'type': 'vmess', 'server': data.get('add'), 'port': int(data.get('port', 0)), 'uuid': data.get('id'), 'aid': data.get('aid', 0), 'sni': data.get('sni', ''), 'network': data.get('net'), 'security': data.get('tls', 'none'), 'original_name': data.get('ps'), 'raw_link': link}
        except: return None

    def _parse_trojan(self, link):
        try:
            parsed = urllib.parse.urlparse(link); params = urllib.parse.parse_qs(parsed.query)
            if parsed.scheme != 'trojan': return None
            return {'type': 'trojan', 'server': parsed.hostname, 'port': int(parsed.port), 'password': parsed.username, 'sni': params.get('sni', [parsed.hostname])[0], 'original_name': urllib.parse.unquote(parsed.fragment), 'raw_link': link}
        except: return None

    def _resolve_happ_link(self, url):
        try:
            api_url = "https://unhapp.xyz/api.php"
            payload = {"url": url}
            headers = {"Content-Type": "application/json", "User-Agent": "VLESS-Tools-Plugin/1.0"}
            r = requests.post(api_url, json=payload, headers=headers, timeout=20)
            r.raise_for_status()
            result = r.text.strip()
            return result
        except Exception as e:
            raise Exception(f"{self.t('err_happ')}: {e}")

    def _get_input_content_from_context(self, args, params):
        if hasattr(params, 'replyToMsg') and params.replyToMsg:
            reply = params.replyToMsg
            msg_tl = getattr(reply, 'messageOwner', reply)
            
            if hasattr(msg_tl, 'media') and msg_tl.media and isinstance(msg_tl.media, TLRPC.TL_messageMediaDocument):
                current_account = get_account_instance().getCurrentAccount()
                file_path = FileLoader.getInstance(current_account).getPathToMessage(msg_tl).toString()
                if os.path.exists(file_path):
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        return f.read()
                else: raise Exception(self.t("err_notfound"))
            
            if hasattr(msg_tl, 'message') and msg_tl.message:
                return str(msg_tl.message)
            raise Exception(self.t("err_reply_format"))
        
        inp = " ".join(args)
        if inp.startswith("http") or inp.startswith("happ://"):
            return self._fetch_url_content_text(inp)
        else:
            return inp

    def _fetch_url_content_text(self, url):
        if url.startswith("happ://"):
            resolved = self._resolve_happ_link(url)
            if not resolved.startswith("http"): return resolved
            url = resolved

        headers_str = self.get_setting("custom_headers", "")
        headers = {"User-Agent": "Mozilla/5.0"}
        if headers_str:
            for line in headers_str.splitlines():
                if ":" in line:
                    key, val = line.split(":", 1)
                    headers[key.strip()] = val.strip()
        try:
            r = requests.get(url, headers=headers, timeout=30)
            r.raise_for_status()
            text = r.text.strip()
            if text.startswith('\ufeff'): text = text[1:]
            
            if "://" not in text and len(text) > 20 and "{" not in text and "proxies:" not in text:
                try:
                    padded_text = text + '=' * (-len(text) % 4)
                    decoded = base64.b64decode(padded_text).decode('utf-8', errors='ignore')
                    return decoded
                except: pass
            return text
        except requests.exceptions.ConnectionError:
            raise Exception(self.t("err_dns"))
        except Exception as e:
            raise Exception(f"{self.t('err_net')}: {e}")

    def _check_server_availability(self, host, port):
        key = (host, port)
        now = time.time()
        if key in self.ping_cache and now - self.ping_cache[key][0] < self.cache_ttl:
            return self.ping_cache[key][1]
        try:
            timeout = int(self.get_setting("ping_timeout", 3))
            with socket.create_connection((host, port), timeout=timeout) as sock: result = True
        except: result = False
        self.ping_cache[key] = (now, result)
        return result

    def _get_temp_dir(self):
        try:
            base_dir = ApplicationLoader.applicationContext.getExternalCacheDir()
            if not base_dir: return None
            temp_dir = File(base_dir, "vless_temp")
            if not temp_dir.exists() and not temp_dir.mkdirs(): return None
            return temp_dir.getAbsolutePath()
        except: return None

    def _delete_file_delayed(self, path: str):
        threading.Thread(target=lambda: (time.sleep(60), os.remove(path) if os.path.exists(path) else None), daemon=True).start()

    def _get_peer_id(self, peer):
        try:
            if "InputPeerSelf" in str(peer): return get_user_config().getClientUserId()
            if hasattr(peer, "user_id"): return peer.user_id
            if hasattr(peer, "chat_id"): return -peer.chat_id
            if hasattr(peer, "channel_id"): return -peer.channel_id
            if str(peer).isdigit(): return int(str(peer))
            return 0
        except: return 0

    def _save_and_send_file(self, content, filename, params):
        temp_dir = self._get_temp_dir()
        if not temp_dir: raise Exception(self.t("err_sending") + " (No Cache)")
        file_path = os.path.join(temp_dir, filename)
        try:
            with open(file_path, "w", encoding="utf-8") as f: f.write(content)
        except Exception as e: raise Exception(f"{self.t('err_sending')}: {e}")

        peer_id = self._get_peer_id(params.peer)
        if peer_id == 0: raise Exception("Invalid Peer ID")

        def _send_ui():
            try:
                account_inst = get_account_instance()
                reply_msg_obj = None
                
                # Check for reply ID from params (HOOK request)
                # If command was a reply, result should reply to the same original message
                if hasattr(params, "reply_to_msg_id") and params.reply_to_msg_id:
                    fragment = get_last_fragment()
                    if fragment and hasattr(fragment, "getDialogId") and fragment.getDialogId() == peer_id:
                         reply_msg_obj = fragment.getReplyMessage()
                
                SendMessagesHelper.prepareSendingDocument(
                    account_inst, file_path, file_path, None, "", "text/plain",
                    peer_id, reply_msg_obj, None, None, None, None, True, 0, None, None, 0, False
                )
                self._delete_file_delayed(file_path)
                self._prog(False)
            except Exception as e:
                log(f"Send error: {e}")
                self._prog(False)
        run_on_ui_thread(_send_ui)

    def h_help(self, args, params):
        text = (
            "**VLESS Tools Commands:**\n\n"
            "`.vdl <url>` - Download sub/link\n"
            "`.vhapp <url>` - Decrypt happ link (get URL)\n"
            "`.vping <src>` - Check proxies (reply/url)\n"
            "`.vconv [fmt] <src>` - Convert config\n"
            "`.vclean <src>` - Clean proxy names\n\n"
            "Formats: `clash`, `singbox`, `txt`\n"
            "Source can be a URL, Happ link, or reply to file/text."
        )
        return self.t("cmd_help"), [("Info", text)]

    def h_happ(self, args, params):
        url = args[0]
        resolved = self._resolve_happ_link(url)
        return self.t("happ_res"), [(self.t("orig"), url), (self.t("res"), f"`{resolved}`")]

    def h_download(self, args, params):
        url = " ".join(args)
        if not url.startswith("http") and not url.startswith("happ://"): raise Exception(self.t("err_inv"))
        
        content = self._fetch_url_content_text(url)
        proxies = self._parse_input(content)
        if not proxies: raise Exception(self.t("err_no_proxies"))
        
        out_content = self._generate_links(proxies)
        
        if self.get_setting("output_as_file", True):
            self._save_and_send_file(out_content, "subscription.txt", params)
            return None
        else:
            return "Subscription", [("Content", f"```{out_content}```")]

    def h_ping(self, args, params):
        content = self._get_input_content_from_context(args, params)
        proxies = self._parse_input(content)
        if not proxies: raise Exception(self.t("err_no_proxies"))
        
        results = []
        live_count = 0
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = {executor.submit(self._check_server_availability, p['server'], p['port']): (i, p) for i, p in enumerate(proxies)}
            for future in as_completed(futures):
                i, p = futures[future]
                try: is_live = future.result()
                except: is_live = False
                if is_live: live_count += 1
                name = p.get('original_name') or f"Proxy {i+1}"
                status = self.t('act') if is_live else self.t('inact')
                results.append(f"{name}: {status}")

        summary = f"{self.t('rep_live')}: {live_count}\n{self.t('rep_total')}: {len(proxies)}"
        return self.t("rep_ping"), [(summary, "```" + "\n".join(results) + "```")]

    def _generate_links(self, proxies):
        lines = []
        for p in proxies:
            if 'raw_link' in p and p['raw_link'] and p.get('type') != 'vless':
                lines.append(p['raw_link'])
                continue
            
            if p['type'] == 'vless':
                link = f"vless://{p['uuid']}@{p['server']}:{p['port']}?security={p.get('security','none')}&encryption=none&type={p.get('network','tcp')}"
                if p.get('flow'): link += f"&flow={p['flow']}"
                if p.get('sni'): link += f"&sni={p['sni']}"
                if p.get('pbk'): link += f"&pbk={p['pbk']}&fp={p.get('fp','chrome')}"
                if p.get('sid'): link += f"&sid={p['sid']}"
                if p.get('network') == 'ws':
                    if p.get('ws_host'): link += f"&host={p['ws_host']}"
                    if p.get('ws_path'): link += f"&path={p['ws_path']}"
                if p.get('network') == 'grpc':
                    if p.get('grpc_service'): link += f"&serviceName={p['grpc_service']}&mode=gun"
                link += f"#{urllib.parse.quote(p.get('original_name','proxy'))}"
                lines.append(link)
            elif 'raw_link' in p:
                lines.append(p['raw_link'])
                
        return "\n".join(lines)

    def _generate_clash_yaml(self, configs):
        class QuotedStr(str): pass
        def quoted_str_presenter(dumper, data): return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='"')
        try: yaml.add_representer(QuotedStr, quoted_str_presenter)
        except: pass
        
        proxies_list = []
        all_names = []
        
        for c in configs:
            if c.get('network') == 'xhttp': continue
            name = c.get('name', 'proxy')
            all_names.append(name)
            p = {'name': name, 'server': c['server'], 'port': c['port'], 'udp': True}
            
            if c['type'] == 'vless':
                p.update({'type': 'vless', 'uuid': c['uuid'], 'network': c.get('network', 'tcp'), 'tls': c.get('security')=='tls', 'servername': c.get('sni', ''), 'client-fingerprint': c.get('fp', 'chrome')})
                if c.get('flow'): p['flow'] = c['flow']
                if c.get('pbk'):
                    opts = {'public-key': c['pbk']}
                    if c.get('sid'): opts['short-id'] = QuotedStr(c['sid'])
                    p['reality-opts'] = opts
                if c.get('network') == 'grpc': p['grpc-opts'] = {'grpc-service-name': c.get('grpc_service') or 'grpc'}
                elif c.get('network') == 'ws': p['ws-opts'] = {'path': c.get('ws_path', '/'), 'headers': {'Host': c.get('ws_host')} if c.get('ws_host') else {}}
            elif c['type'] == 'ss': p.update({'type': 'ss', 'cipher': c['method'], 'password': c['password']})
            elif c['type'] == 'trojan': p.update({'type': 'trojan', 'password': c['password'], 'sni': c.get('sni', ''), 'tls': True})
            elif c['type'] == 'vmess': p.update({'type': 'vmess', 'uuid': c['uuid'], 'alterId': c.get('aid', 0), 'cipher': 'auto', 'tls': c.get('security', 'none') == 'tls', 'servername': c.get('sni', ''), 'network': c.get('network', 'tcp')})
            if p.get('network') == 'ws' and c['type'] == 'vmess':
                p.update({'ws-opts': {'path': c.get('ws_path', '/'), 'headers': {'Host': c.get('ws_host')} if c.get('ws_host') else {}}})
            
            proxies_list.append(p)

        config = {'port': 7890, 'socks-port': 7891, 'allow-lan': False, 'mode': 'rule', 'log-level': 'info', 'proxies': proxies_list, 'proxy-groups': [{'name': 'PROXY', 'type': 'select', 'proxies': all_names + ['DIRECT']}], 'rules': ['MATCH,PROXY']}
        return yaml.dump(config, allow_unicode=True, sort_keys=False, indent=2)

    def _generate_singbox_json(self, configs):
        sb_outbounds = []
        all_tags = []
        for c in configs:
            if c.get('network') == 'xhttp': continue
            tag = c.get('name', 'proxy')
            all_tags.append(tag)
            out = {'tag': tag, 'server': c['server'], 'server_port': int(c['port'])}
            
            if c['type'] == 'vless':
                out.update({'type': 'vless', 'uuid': c['uuid']})
                if c.get('flow'): out['flow'] = c['flow']
                tls = {'enabled': c.get('security')=='tls', 'server_name': c.get('sni', ''), 'utls': {'enabled': True, 'fingerprint': c.get('fp', 'chrome')}}
                if c.get('pbk'): 
                    tls['reality'] = {'enabled': True, 'public_key': c['pbk']}
                    if c.get('sid'): tls['reality']['short_id'] = c['sid']
                out['tls'] = tls
                
                network = c.get('network')
                if network == 'ws': 
                    ws = {'type': 'ws', 'path': c.get('ws_path', '/')}
                    if c.get('ws_host'): ws['headers'] = {'Host': c['ws_host']}
                    out['transport'] = ws
                elif network == 'grpc': 
                    out['transport'] = {'type': 'grpc', 'service_name': c.get('grpc_service') or 'grpc'}
            elif c['type'] == 'ss': out.update({'type': 'shadowsocks', 'method': c['method'], 'password': c['password']})
            elif c['type'] == 'trojan': out.update({'type': 'trojan', 'password': c['password'], 'tls': {'enabled': True, 'server_name': c.get('sni', '')}})
            elif c['type'] == 'vmess': out.update({'type': 'vmess', 'uuid': c['uuid'], 'alter_id': c.get('aid', 0), 'security': 'auto', 'tls': {'enabled': c.get('security', 'none') == 'tls', 'server_name': c.get('sni', '')}})
            sb_outbounds.append(out)

        sb_outbounds.insert(0, {"tag": "PROXY", "type": "selector", "outbounds": all_tags + ["direct"]})
        sb_outbounds.extend([{"tag": "direct", "type": "direct"}, {"tag": "block", "type": "block"}])
        return json.dumps({"log": {"level": "info"}, "outbounds": sb_outbounds}, indent=2, ensure_ascii=False)

    def _reply(self, params, title, lines):
        def _do():
            self._prog(False)
            sb = [f"**{title}**", ""]
            for k, v in lines:
                if v is not None:
                    val_str = str(v).strip()
                    if val_str.startswith("```"): sb.append(f"**{k}:**\n{val_str}")
                    elif "\n" in val_str: sb.append(f"**{k}:**\n{val_str}")
                    else:
                        clean_val = val_str.replace('`', "'")
                        sb.append(f"**{k}:** `{clean_val}`")
            full = "\n".join(sb)
            
            try:
                from markdown_utils import parse_markdown
                p = parse_markdown(full)
                quote = TLRPC.TL_messageEntityBlockquote(); quote.collapsed = True; quote.offset = 0; quote.length = len(p.text.encode('utf-16-le')) // 2
                ents = [quote]
                if p.entities: ents.extend([e.to_tlrpc_object() for e in p.entities])
                
                # Reply handling
                peer_id = self._get_peer_id(params.peer)
                reply_to_msg_id = None
                if hasattr(params, "reply_to_msg_id") and params.reply_to_msg_id:
                    reply_to_msg_id = params.reply_to_msg_id

                send_message({"peer": peer_id, "message": p.text, "entities": ents, "replyToMsgId": reply_to_msg_id})
            except Exception as e:
                log(f"Markdown parsing failed: {e}. Sending as plain text.")
                plain_text = re.sub(r'([*_`])', '', full)
                send_message({"peer": params.peer, "message": plain_text})
        run_on_ui_thread(_do)