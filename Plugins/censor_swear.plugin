import re
from typing import Any
from base_plugin import BasePlugin, HookResult, HookStrategy

__id__ = "censor_swear"
__name__ = "говорим ,kznm правильно"
__description__ = "скрывает маты посредством смены раскладки\n\n.censor - вкл/выкл"
__icon__ = "feature_plugins/2"
__author__ = "@feature_plugins"
__version__ = "1.1"
__min_version__ = "12.1.1"

class SmartCensor:
    def __init__(self):
        # 1. Раскладка (RU -> EN)
        ru = "ёйцукенгшщзхъфывапролджэячсмитьбюЁЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ"
        en = "`qwertyuiop[]asdfghjkl;'zxcvbnm,.`QWERTYUIOP{}ASDFGHJKL:\"ZXCVBNM<>"
        self.trans_map = str.maketrans(ru, en)

        # 2. Правила исключений (белые префиксы)
        # Ключ: опасный корень.
        # Значение: список окончаний префикса, которые делают слово легальным.
        self.safe_prefixes = {
            'еб': (
                'хл',  # хл-еб (хлеб)
                'тр',  # потр-еб (потреблять, треба)
                'гр',  # гр-еб (гребля)
                'щ',   # щ-еб (щебень)
                'ст',  # ст-еб (стебель)
                'н',   # н-еб (небо)
                'с',   # с-еб (себя)
                'т',   # т-еб (тебя)
                'р',   # хр-еб (хребет)
                'л',   # молибден, колебание (кол-еб)
            ),
            'ху': (
                'ра',  # ст-ра-хуй (страхуй, страхую)
                'с',   # пас-ху (пасху)
                'вер', # вер-ху (наверху)
                'ло'   # ло-ху (лоху - хотя спорно, но не мат)
            ),
            'бля': (
                # Если "бля" в конце существительных/глаголов (рубля, сабля, влюбляться)
                'а', 'о', 'у', 'ы', 'и', 'е', 'ю', 'я', 'р' 
                # са-бля, огло-бля, ру-бля, оскор-бля-ть
            ),
            'сук': (
                'бар', # бар-сук
            )
        }

        # 3. Регулярка
        # \b\w*? — ленивый захват начала слова (префикса)
        # (...) — захватывающая группа №1 (сам корень)
        # \w*\b — хвост слова
        self.pattern = re.compile(
            r'(?iu)\b\w*?('
            r'ху[йяеёию]|'       # ХУЙ
            r'п[иeё]зд|'         # ПИЗДА
            r'еб[а-яё]|'         # ЕБ (самый опасный корень)
            r'бля(?!х)|'         # БЛЯ (кроме бляха)
            r'м[уu]д[аa]|'       # МУДАК
            r'г[ао]нд[оo]н|'     # ГАНДОН
            r'сук[аи]|'          # СУКА
            r'залуп|'            # ЗАЛУПА
            r'дерьм'             # ДЕРЬМО
            r')\w*'
        )

    def _replace(self, match):
        full_word = match.group(0)      # Все слово целиком (напр. "употреблять")
        root = match.group(1).lower()   # Найденный корень (напр. "еб")
        
        # Определяем префикс (часть слова ДО корня)
        root_start_index = match.start(1) - match.start(0)
        prefix = full_word[:root_start_index].lower()

        # 1. Базовая проверка: ищем правила для найденного корня
        clean_root_key = None
        for key in self.safe_prefixes:
            if root.startswith(key):
                clean_root_key = key
                break
        
        # 2. Если есть правило для этого корня
        if clean_root_key:
            allowed_endings = self.safe_prefixes[clean_root_key]
            # Проверяем, заканчивается ли префикс на что-то из белого списка
            if prefix.endswith(allowed_endings):
                return full_word # Слово чистое, возвращаем как есть

        # 3. Если проверки не прошли — меняем раскладку
        return full_word.translate(self.trans_map)

    def filter(self, text):
        return self.pattern.sub(self._replace, text)


class CensorPlugin(BasePlugin):
    def on_plugin_load(self):
        self.censor = SmartCensor()
        self.enabled = bool(self._get_setting_safe("enabled", True))
        self.add_on_send_message_hook()

    def _get_setting_safe(self, key: str, default: Any) -> Any:
        try:
            return self.get_setting(key, default)
        except Exception:
            return default

    def _set_setting_safe(self, key: str, value: Any) -> None:
        try:
            self.set_setting(key, value)
        except Exception:
            pass

    def _handle_toggle_command(self, text: str):
        parts = text.strip().split()
        if not parts:
            return None

        if parts[0].lower() not in (".censor"):
            return None

        action = parts[1].lower() if len(parts) > 1 else "toggle"
        if action == "on":
            self.enabled = True
        elif action == "off":
            self.enabled = False
        elif action == "toggle":
            self.enabled = not self.enabled
        else:
            return HookResult(strategy=HookStrategy.CANCEL)

        self._set_setting_safe("enabled", self.enabled)
        return HookResult(strategy=HookStrategy.CANCEL)

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()

        command_result = self._handle_toggle_command(params.message)
        if command_result is not None:
            return command_result

        if not self.enabled:
            return HookResult()

        original_text = params.message
        censored_text = self.censor.filter(original_text)

        if censored_text != original_text:
            params.message = censored_text
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        return HookResult()