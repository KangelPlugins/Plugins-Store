__id__="slime"
__name__="Слайм"
__description__="Милый Антистресс"
__author__="@RoflPlugins"
__version__="2.0.1"
__min_version__="12.0.1"
__icon__="RoflPlugins/9"

import math
import time
import random

from base_plugin import BasePlugin
from android_utils import run_on_ui_thread, log
from java import dynamic_proxy
from hook_utils import find_class

def _now():
    return time.time()

def _clamp(v,a,b):
    return a if v<a else b if v>b else v

def _hypot(x,y):
    return math.hypot(x,y)

def _jint32(v):
    v=int(v)&0xFFFFFFFF
    if v>=0x80000000:
        v-=0x100000000
    return int(v)

def _hsv_to_argb(h, s, v, a):
    if h != h: h = 0.55
    if s != s: s = 0.8
    if v != v: v = 1.0
    if a != a: a = 1.0
    h = h % 1.0
    s = _clamp(s, 0.0, 1.0)
    v = _clamp(v, 0.0, 1.0)
    a = _clamp(a, 0.0, 1.0)

    i = int(h * 6.0)
    f = h * 6.0 - i
    p = v * (1.0 - s)
    q = v * (1.0 - f * s)
    t = v * (1.0 - (1.0 - f) * s)
    i = i % 6
    if i == 0:
        r, g, b = v, t, p
    elif i == 1:
        r, g, b = q, v, p
    elif i == 2:
        r, g, b = p, v, t
    elif i == 3:
        r, g, b = p, q, v
    elif i == 4:
        r, g, b = t, p, v
    else:
        r, g, b = v, p, q

    A = int(_clamp(a,0.0,1.0)*255.0) & 255
    R = int(_clamp(r,0.0,1.0)*255.0) & 255
    G = int(_clamp(g,0.0,1.0)*255.0) & 255
    B = int(_clamp(b,0.0,1.0)*255.0) & 255
    return _jint32((A<<24) | (R<<16) | (G<<8) | B)

class _Haptics:
    def __init__(self, ctx, view):
        self.ctx=ctx
        self.view=view
        self.Build_VERSION=find_class("android.os.Build$VERSION")
        self.VibrationEffect=find_class("android.os.VibrationEffect")
        self.Context=find_class("android.content.Context")
        self.HFC=find_class("android.view.HapticFeedbackConstants")
        self.vib=None
        try:
            if self.Context and hasattr(self.Context,"VIBRATOR_SERVICE"):
                self.vib=ctx.getSystemService(self.Context.VIBRATOR_SERVICE)
        except Exception as e:
            log(f"[{__id__}] vib VIBRATOR_SERVICE err: {e}")
        if not self.vib:
            try:
                self.vib=ctx.getSystemService("vibrator")
            except Exception as e:
                log(f"[{__id__}] vib 'vibrator' err: {e}")

    def _kind(self, name, default_val):
        try:
            if self.HFC and hasattr(self.HFC,name):
                return int(getattr(self.HFC,name))
        except Exception:
            pass
        return int(default_val)

    def haptic(self, kind_name="KEYBOARD_TAP", fallback_int=3):
        try:
            k=self._kind(kind_name, fallback_int)
            self.view.performHapticFeedback(int(k), 3)
            return True
        except Exception:
            try:
                AU=find_class("org.telegram.messenger.AndroidUtilities")
                if AU:
                    AU.vibrate(self.view)
                    return True
            except Exception:
                pass
        return False

    def oneshot(self, ms, amp):
        if not self.vib:
            return False
        try:
            if self.Build_VERSION and getattr(self.Build_VERSION,"SDK_INT",0) >= 26 and self.VibrationEffect:
                try:
                    self.vib.vibrate(self.VibrationEffect.createOneShot(int(ms), int(_clamp(amp,1,255))))
                    return True
                except Exception:
                    try:
                        self.vib.vibrate(self.VibrationEffect.createOneShot(int(ms), -1))
                        return True
                    except Exception:
                        pass
            self.vib.vibrate(int(ms))
            return True
        except Exception as e:
            log(f"[{__id__}] vibrate oneshot err: {e}")
            return False

    def texture(self, a):
        if not self.vib:
            return False
        try:
            if self.Build_VERSION and getattr(self.Build_VERSION,"SDK_INT",0) >= 26 and self.VibrationEffect:
                a=int(_clamp(a,1,255))
                timings=[0,6,10,6,12,6,10,6,12]
                a1=int(_clamp(a*0.50,1,255))
                a2=int(_clamp(a*0.82,1,255))
                a3=int(_clamp(a*0.62,1,255))
                a4=int(_clamp(a*0.90,1,255))
                amps=[0,a1,a2,a3,a2,a1,a4,a2,0]
                self.vib.vibrate(self.VibrationEffect.createWaveform(timings,amps,-1))
                return True
            return self.oneshot(18,int(_clamp(a,1,255)))
        except Exception as e:
            log(f"[{__id__}] vibrate texture err: {e}")
            return False

class _Piece:
    __slots__=("id","x","y","vx","vy","ax","ay","r",
               "drag","tx","ty","sx","sy","sxv","syv","rot","rotv",
               "wob","wobv","hit","hitv","pulse","pulsev",
               "h","seed","merge_cd","view","bg","spark","spark_bg")
    def __init__(self, pid, x, y, r, hue):
        self.id=pid
        self.x=float(x); self.y=float(y)
        self.vx=0.0; self.vy=0.0
        self.ax=0.0; self.ay=0.0
        self.r=float(r)

        self.drag=False
        self.tx=float(x); self.ty=float(y)

        self.sx=1.0; self.sy=1.0
        self.sxv=0.0; self.syv=0.0
        self.rot=0.0; self.rotv=0.0

        self.wob=0.0; self.wobv=0.0
        self.hit=0.0; self.hitv=0.0
        self.pulse=0.0; self.pulsev=0.0

        self.h=float(hue)
        self.seed=random.random()*9999.0
        self.merge_cd=0.0

        self.view=None
        self.bg=None
        self.spark=None
        self.spark_bg=None

    def speed(self):
        return _hypot(self.vx, self.vy)

class _Engine:
    def __init__(self, ctx):
        self.ctx=ctx

        self.View=find_class("android.view.View")
        self.MotionEvent=find_class("android.view.MotionEvent")
        self.FrameLayout=find_class("android.widget.FrameLayout")
        self.GradientDrawable=find_class("android.graphics.drawable.GradientDrawable")
        self.Gravity=find_class("android.view.Gravity")
        self.Choreographer=find_class("android.view.Choreographer")
        self.FrameCallback=find_class("android.view.Choreographer$FrameCallback")

        dm=ctx.getResources().getDisplayMetrics()
        self.screen_w=float(dm.widthPixels)
        self.screen_h=float(dm.heightPixels)

        self.choreo=self.Choreographer.getInstance()
        self.running=False

        # --- растяжение/окно ---
        self.max_scale=2.35
        self.pad=float(self._dp(44.0))
        self.visual_margin=float(self._dp(2.0))

        # --- физика ---
        self.spring_k=112.0
        self.spring_d=7.0
        self.air=0.9994
        self.damp=0.9963
        self.restitution=0.90
        self.wall_fric=0.94

        # --- split/merge ---
        self.split_speed=1550.0
        self.split_factor=0.72
        self.min_r=float(self._dp(32.0))
        self.max_r=float(self._dp(110.0))
        self.max_pieces=18
        self.merge_dist=0.78
        self.merge_rel_speed=520.0

        # --- attach only in-app ---
        self.root=None
        self.in_app_parent=None
        self.attached=False

        self.bounds_l=0.0
        self.bounds_t=0.0
        self.bounds_r=0.0
        self.bounds_b=0.0
        self._bounds_cd=0.0

        # --- touch ---
        self.pointer_id=-1
        self.drag_piece=None
        self.touch_last_x=0.0
        self.touch_last_y=0.0
        self.touch_last_t=_now()
        self.touch_vx=0.0
        self.touch_vy=0.0

        # --- timers ---
        self.t=0.0
        self._color_acc=0.0
        self._buzz_cd=0.0
        self._tap_cd=0.0
        self._tex_cd=0.0

        self._build_root()
        self.hapt=_Haptics(self.ctx, self.root)

        self.pieces=[]
        self.next_id=1

        cx=self.screen_w*0.5
        cy=self.screen_h*0.58
        base=float(self._dp(92.0))
        p=_Piece(self.next_id, cx, cy, base, random.uniform(0.50, 0.78))
        self.next_id+=1
        self._add_piece_view(p)
        self.pieces.append(p)

        self._install_touch()
        self._install_frame()
        self._recalc_bounds(force=True)

    def _dp(self, v):
        try:
            AU=find_class("org.telegram.messenger.AndroidUtilities")
            if AU:
                return int(AU.dp(float(v)))
        except Exception:
            pass
        return int(v*3.0)

    def _build_root(self):
        root=self.FrameLayout(self.ctx)
        try:
            root.setClipChildren(False)
            root.setClipToPadding(False)
        except Exception:
            pass
        # важно: НЕ clickable, чтобы если мы вернули False — клик ушёл в TG
        try:
            root.setClickable(False)
        except Exception:
            pass
        try:
            root.setBackgroundColor(_jint32(0x00000000))
        except Exception:
            pass
        self.root=root

    def _make_piece_view(self, rpx, hue):
        piece=self.FrameLayout(self.ctx)
        try:
            piece.setClickable(False)
        except Exception:
            pass

        bg=self.GradientDrawable()
        bg.setShape(self.GradientDrawable.OVAL)
        try:
            if hasattr(bg, "setGradientType"):
                bg.setGradientType(self.GradientDrawable.RADIAL_GRADIENT)
        except Exception:
            pass

        h0=(hue+0.00) % 1.0
        h1=(hue+0.08) % 1.0
        h2=(hue+0.20) % 1.0
        c0=_hsv_to_argb(h0, 0.58, 1.00, 0.92)
        c1=_hsv_to_argb(h1, 0.70, 0.99, 0.90)
        c2=_hsv_to_argb(h2, 0.62, 0.98, 0.92)
        try:
            if hasattr(bg, "setColors"):
                bg.setColors([c0,c1,c2])
            else:
                bg.setColor(c1)
        except Exception:
            pass

        try:
            if hasattr(bg, "setGradientCenter"):
                bg.setGradientCenter(0.34, 0.30)
        except Exception:
            pass
        try:
            if hasattr(bg, "setGradientRadius"):
                bg.setGradientRadius(float(rpx*0.92))
        except Exception:
            pass

        rim=_hsv_to_argb((hue+0.06)%1.0, 0.18, 1.00, 0.62)
        try:
            bg.setStroke(int(self._dp(1.8)), rim)
        except Exception:
            pass

        try:
            piece.setBackground(bg)
        except Exception:
            pass

        spark=self.FrameLayout(self.ctx)
        try:
            spark.setClickable(False)
        except Exception:
            pass
        sp=self.GradientDrawable()
        sp.setShape(self.GradientDrawable.OVAL)
        try:
            if hasattr(sp, "setGradientType"):
                sp.setGradientType(self.GradientDrawable.RADIAL_GRADIENT)
        except Exception:
            pass
        try:
            if hasattr(sp, "setColors"):
                sp.setColors([_jint32(0x88FFFFFF), _jint32(0x00FFFFFF)])
            else:
                sp.setColor(_jint32(0x33FFFFFF))
        except Exception:
            pass
        try:
            if hasattr(sp, "setGradientCenter"):
                sp.setGradientCenter(0.34, 0.34)
        except Exception:
            pass
        try:
            if hasattr(sp, "setGradientRadius"):
                sp.setGradientRadius(float(rpx*0.42))
        except Exception:
            pass
        try:
            spark.setBackground(sp)
        except Exception:
            pass
        try:
            spark.setAlpha(0.24)
        except Exception:
            pass

        try:
            FLP=find_class("android.widget.FrameLayout$LayoutParams")
            slp=FLP(int(rpx*0.76), int(rpx*0.76))
            try:
                slp.gravity=self.Gravity.CENTER
            except Exception:
                pass
            spark.setLayoutParams(slp)
            piece.addView(spark)
        except Exception:
            pass

        return piece, bg, spark, sp

    def _set_piece_size(self, p):
        try:
            size=int(max(28, p.r))
            FLP=find_class("android.widget.FrameLayout$LayoutParams")
            lp=FLP(size, size)
            p.view.setLayoutParams(lp)
            try:
                p.view.setPivotX(size*0.5)
                p.view.setPivotY(size*0.5)
            except Exception:
                pass
        except Exception:
            pass

    def _add_piece_view(self, p):
        piece, bg, spark, sp = self._make_piece_view(p.r, p.h)
        p.view=piece
        p.bg=bg
        p.spark=spark
        p.spark_bg=sp
        self._set_piece_size(p)
        try:
            self.root.addView(piece)
        except Exception as e:
            log(f"[{__id__}] addView piece err: {e}")

    def _remove_piece_view(self, p):
        try:
            if p.view:
                self.root.removeView(p.view)
        except Exception:
            pass
        p.view=None
        p.bg=None
        p.spark=None
        p.spark_bg=None

    def _get_launch_activity(self):
        try:
            LA = find_class("org.telegram.ui.LaunchActivity")
        except Exception:
            LA = None
        if not LA:
            return None
        for fname in ("instance", "Instance", "INSTANCE", "lastInstance", "currentActivity"):
            try:
                act = getattr(LA, fname, None)
                if act:
                    return act
            except Exception:
                pass
        for mname in ("getInstance", "getLastInstance", "getLastActivity", "getCurrentActivity"):
            try:
                m = getattr(LA, mname, None)
                if m:
                    act = m()
                    if act:
                        return act
            except Exception:
                pass
        return None

    # ---------- ONLY IN-APP ATTACH ----------
    def _attach_in_app(self):
        act=self._get_launch_activity()
        if not act:
            raise Exception("LaunchActivity not found")
        decor=act.getWindow().getDecorView()
        if not hasattr(decor, "addView"):
            raise Exception("decor has no addView")

        self._recalc_bounds(force=True)

        try:
            FLP=find_class("android.widget.FrameLayout$LayoutParams")
            lp=FLP(int(max(160, self.bounds_r-self.bounds_l)), int(max(160, self.bounds_b-self.bounds_t)))
            self.root.setLayoutParams(lp)
        except Exception:
            pass

        decor.addView(self.root)
        self.in_app_parent=decor
        self.attached=True
        self._apply_layout()
        log(f"[{__id__}] addView OK (Telegram in-app only)")

    def _detach(self):
        if not self.attached:
            return
        try:
            if self.in_app_parent and hasattr(self.in_app_parent, "removeView"):
                self.in_app_parent.removeView(self.root)
        except Exception:
            pass
        self.in_app_parent=None
        self.attached=False

    def _hit_piece(self, x, y):
        best=None
        bestd=1e18
        for p in self.pieces:
            dx=x-p.x
            dy=y-p.y
            rr=(p.r*0.5)*max(p.sx,p.sy)*1.04
            d=dx*dx+dy*dy
            if d <= rr*rr and d < bestd:
                bestd=d
                best=p
        return best

    def _install_touch(self):
        engine=self
        View=self.View
        MotionEvent=self.MotionEvent

        class TL(dynamic_proxy(View.OnTouchListener)):
            def __init__(self):
                super().__init__()
            def onTouch(self, v, ev):
                try:
                    act=ev.getActionMasked()
                    rx=float(ev.getRawX())
                    ry=float(ev.getRawY())
                    tn=_now()

                    if act==MotionEvent.ACTION_DOWN:
                        p=engine._hit_piece(rx, ry)
                        if p is None:
                            return False  # клики уходят в Telegram
                        engine.drag_piece=p
                        p.drag=True
                        p.tx=rx; p.ty=ry
                        engine.pointer_id=0
                        try:
                            engine.pointer_id=ev.getPointerId(0)
                        except Exception:
                            pass
                        engine.touch_last_x=rx
                        engine.touch_last_y=ry
                        engine.touch_last_t=tn
                        engine.touch_vx=0.0
                        engine.touch_vy=0.0
                        p.pulsev += 0.55
                        engine.hapt.texture(150) or engine.hapt.haptic("KEYBOARD_TAP",3)
                        return True

                    if act==MotionEvent.ACTION_MOVE:
                        if engine.drag_piece is None:
                            return False
                        dt=max(0.001, tn-engine.touch_last_t)
                        dx=rx-engine.touch_last_x
                        dy=ry-engine.touch_last_y
                        engine.touch_last_x=rx
                        engine.touch_last_y=ry
                        engine.touch_last_t=tn
                        engine.touch_vx=dx/dt
                        engine.touch_vy=dy/dt

                        p=engine.drag_piece
                        p.tx=rx; p.ty=ry

                        sp=_hypot(engine.touch_vx, engine.touch_vy)
                        engine._tap_cd=max(0.0, engine._tap_cd-dt)
                        engine._buzz_cd=max(0.0, engine._buzz_cd-dt)
                        engine._tex_cd=max(0.0, engine._tex_cd-dt)

                        if engine._tap_cd<=0.0 and sp>260.0:
                            engine.hapt.haptic("TEXT_HANDLE_MOVE",3)
                            engine._tap_cd=0.07

                        if engine._buzz_cd<=0.0 and sp>980.0:
                            amp=int(_clamp(24.0 + sp/14.0, 30.0, 230.0))
                            if engine._tex_cd<=0.0 and sp>1850.0:
                                engine.hapt.texture(amp)
                                engine._tex_cd=0.18
                                engine._buzz_cd=0.065
                            else:
                                engine.hapt.oneshot(9, amp)
                                engine._buzz_cd=0.055

                        return True

                    if act==MotionEvent.ACTION_UP or act==MotionEvent.ACTION_CANCEL:
                        p=engine.drag_piece
                        if p is None:
                            return False

                        p.drag=False
                        p.pulsev += 0.60

                        # бросок — едет дальше
                        p.vx += engine.touch_vx*0.62
                        p.vy += engine.touch_vy*0.62

                        # split при быстром броске
                        rel_sp = _hypot(engine.touch_vx, engine.touch_vy)
                        engine._maybe_split_on_release(p, rel_sp, engine.touch_vx, engine.touch_vy)

                        engine.drag_piece=None
                        engine.pointer_id=-1
                        engine.touch_vx=0.0
                        engine.touch_vy=0.0

                        if rel_sp>1400.0:
                            engine.hapt.texture(165)
                        else:
                            engine.hapt.oneshot(12, 105) or engine.hapt.haptic("VIRTUAL_KEY",1)
                        return True

                    return False
                except Exception as e:
                    log(f"[{__id__}] touch err: {e}")
                    return False

        try:
            self.root.setOnTouchListener(TL())
        except Exception as e:
            log(f"[{__id__}] setOnTouchListener err: {e}")

    def _install_frame(self):
        engine=self
        FrameCallback=self.FrameCallback

        class FC(dynamic_proxy(FrameCallback)):
            def __init__(self):
                super().__init__()
            def doFrame(self, frameTimeNanos):
                if not engine.running:
                    return
                try:
                    tn=_now()
                    dt=_clamp(tn-engine._t_last, 0.001, 0.033)
                    engine._t_last=tn
                    engine.t += dt
                    engine._step(dt)
                    engine._maybe_merge(dt)
                    engine._update_bounds(dt)
                    engine._render_views(dt)
                    engine._animate_colors(dt)
                except Exception as e:
                    log(f"[{__id__}] frame err: {e}")
                try:
                    engine.choreo.postFrameCallback(self)
                except Exception as e:
                    log(f"[{__id__}] postFrameCallback err: {e}")

        self.frame_cb=FC()
        self._t_last=_now()

    def _piece_visual_half(self, p):
        return (p.r*0.5)*max(p.sx,p.sy) + self.visual_margin

    def _bounce_edges(self, p):
        half=self._piece_visual_half(p)
        hit=False

        if p.x < half:
            p.x=half
            if p.vx < 0.0:
                p.vx=-p.vx*self.restitution
                p.vy*=self.wall_fric
                hit=True
        elif p.x > self.screen_w - half:
            p.x=self.screen_w - half
            if p.vx > 0.0:
                p.vx=-p.vx*self.restitution
                p.vy*=self.wall_fric
                hit=True

        if p.y < half:
            p.y=half
            if p.vy < 0.0:
                p.vy=-p.vy*self.restitution
                p.vx*=self.wall_fric
                hit=True
        elif p.y > self.screen_h - half:
            p.y=self.screen_h - half
            if p.vy > 0.0:
                p.vy=-p.vy*self.restitution
                p.vx*=self.wall_fric
                hit=True

        if hit and self._buzz_cd<=0.0:
            sp=p.speed()
            amp=int(_clamp(70.0 + sp/22.0, 85.0, 225.0))
            self.hapt.texture(amp) or self.hapt.haptic("LONG_PRESS",0)
            p.hitv += 1.15
            p.wobv += 1.05
            self._buzz_cd=0.08

    def _apply_deform(self, p, dt):
        sp=p.speed()

        sxm=_clamp(abs(p.vx)/1900.0, 0.0, 1.0)
        sym=_clamp(abs(p.vy)/1900.0, 0.0, 1.0)
        sm =_clamp(sp/2100.0, 0.0, 1.0)

        pullx=0.0
        pully=0.0
        if p.drag:
            pullx=_clamp(abs(p.tx-p.x)/max(1.0, p.r*0.92), 0.0, 1.0)
            pully=_clamp(abs(p.ty-p.y)/max(1.0, p.r*0.92), 0.0, 1.0)

        tx=1.0 + (0.98*sxm + 0.42*sm + 0.65*pullx)
        ty=1.0 + (0.98*sym + 0.42*sm + 0.65*pully)

        area=math.sqrt(max(0.0001, tx*ty))
        keep=area**0.72
        tx/=keep
        ty/=keep

        tx*=(1.0 + p.wob*0.05 + p.hit*0.10)
        ty*=(1.0 - p.wob*0.045 - p.hit*0.14)

        tx=_clamp(tx, 0.62, self.max_scale)
        ty=_clamp(ty, 0.60, self.max_scale)

        k=46.0
        d=12.0
        p.sxv += ((tx-p.sx)*k - p.sxv*d)*dt
        p.syv += ((ty-p.sy)*k - p.syv*d)*dt
        p.sx += p.sxv*dt
        p.sy += p.syv*dt
        p.sx=_clamp(p.sx, 0.62, self.max_scale)
        p.sy=_clamp(p.sy, 0.60, self.max_scale)

        if sp>20.0:
            trg=math.degrees(math.atan2(p.vy, p.vx))*0.28
        else:
            trg=0.0
        rot_k=16.0
        rot_d=6.0
        err=(trg-p.rot)
        while err>180.0: err-=360.0
        while err<-180.0: err+=360.0
        p.rotv += (err*rot_k - p.rotv*rot_d)*dt
        p.rot += p.rotv*dt

    def _step(self, dt):
        self._buzz_cd=max(0.0, self._buzz_cd-dt)

        for p in self.pieces:
            p.merge_cd=max(0.0, p.merge_cd-dt)

            p.pulsev += (-p.pulse*10.0 - p.pulsev*4.0)*dt
            p.pulse += p.pulsev*dt
            p.pulse=_clamp(p.pulse, -0.45, 0.60)

            p.wobv += (-p.wob*14.0 - p.wobv*5.0)*dt
            p.wob += p.wobv*dt
            p.wob=_clamp(p.wob, -0.48, 0.48)

            p.hitv += (-p.hit*20.0 - p.hitv*7.2)*dt
            p.hit += p.hitv*dt
            p.hit=_clamp(p.hit, -0.58, 0.68)

            if p.drag:
                dx=p.tx-p.x
                dy=p.ty-p.y
                p.ax += dx*self.spring_k
                p.ay += dy*self.spring_k
                p.ax += -p.vx*self.spring_d
                p.ay += -p.vy*self.spring_d
            else:
                p.ax += -p.vx*1.25
                p.ay += -p.vy*1.25

            p.vx = p.vx*self.air + p.ax*dt
            p.vy = p.vy*self.air + p.ay*dt
            p.ax=0.0
            p.ay=0.0

            p.x += p.vx*dt
            p.y += p.vy*dt

            p.vx *= self.damp
            p.vy *= self.damp

            self._apply_deform(p, dt)
            self._bounce_edges(p)

    def _maybe_split_on_release(self, p, release_speed, tvx, tvy):
        if len(self.pieces) >= self.max_pieces:
            return
        if release_speed < self.split_speed:
            return
        if p.r * self.split_factor < self.min_r:
            return

        new_r = p.r * self.split_factor
        ang = math.atan2(tvy, tvx) if release_speed > 1e-3 else random.uniform(-math.pi, math.pi)
        ang += random.uniform(-0.28, 0.28)

        sep = max(new_r*0.55, self._dp(10.0))
        dx = math.cos(ang)*sep
        dy = math.sin(ang)*sep

        p2=_Piece(self.next_id, p.x - dx, p.y - dy, new_r, (p.h + random.uniform(-0.03, 0.03)) % 1.0)
        self.next_id += 1
        self._add_piece_view(p2)

        p.r = new_r
        p.h = (p.h + random.uniform(-0.01, 0.01)) % 1.0
        self._set_piece_size(p)

        k = 0.22
        p.vx += dx*2.6 + tvx*k + random.uniform(-120,120)
        p.vy += dy*2.6 + tvy*k + random.uniform(-120,120)
        p2.vx = p.vx - dx*5.2 + tvx*0.10 + random.uniform(-90,90)
        p2.vy = p.vy - dy*5.2 + tvy*0.10 + random.uniform(-90,90)

        p.pulsev += 0.85
        p2.pulsev += 0.85
        p.merge_cd = 0.25
        p2.merge_cd = 0.25

        self.pieces.append(p2)

        self.hapt.texture(190) or self.hapt.oneshot(16, 210)
        log(f"[{__id__}] split -> pieces={len(self.pieces)} r={new_r:.1f} sp={release_speed:.0f}")

    def _maybe_merge(self, dt):
        n=len(self.pieces)
        if n < 2:
            return

        used=set()
        merged=[]
        for i in range(n):
            if i in used:
                continue
            a=self.pieces[i]
            if a.drag or a.merge_cd>0.0:
                continue
            for j in range(i+1, n):
                if j in used:
                    continue
                b=self.pieces[j]
                if b.drag or b.merge_cd>0.0:
                    continue

                dx=b.x-a.x
                dy=b.y-a.y
                d=_hypot(dx,dy)
                if d <= 0.001:
                    continue
                if d > (a.r*0.5 + b.r*0.5) * self.merge_dist:
                    continue

                rel=_hypot(a.vx-b.vx, a.vy-b.vy)
                if rel > self.merge_rel_speed:
                    continue

                area = (a.r*a.r + b.r*b.r)
                new_r = math.sqrt(max(1.0, area))
                new_r = min(new_r, self.max_r)

                w1=a.r*a.r
                w2=b.r*b.r
                x=(a.x*w1 + b.x*w2)/max(1.0, (w1+w2))
                y=(a.y*w1 + b.y*w2)/max(1.0, (w1+w2))

                m=_Piece(self.next_id, x, y, new_r, ((a.h+b.h)*0.5 + random.uniform(-0.01,0.01))%1.0)
                self.next_id += 1
                self._add_piece_view(m)
                m.vx=(a.vx+b.vx)*0.5
                m.vy=(a.vy+b.vy)*0.5
                m.pulsev += 1.10
                m.merge_cd = 0.30

                used.add(i); used.add(j)
                merged.append(m)

                self._remove_piece_view(a)
                self._remove_piece_view(b)

                self.hapt.texture(170) or self.hapt.oneshot(14, 160)
                log(f"[{__id__}] merge -> pieces={n-1} r={new_r:.1f}")
                break

        if not merged:
            return

        new_list=[]
        for idx,p in enumerate(self.pieces):
            if idx in used:
                continue
            new_list.append(p)
        new_list.extend(merged)
        self.pieces=new_list

    def _recalc_bounds(self, force=False):
        if not self.pieces:
            self.bounds_l=0.0; self.bounds_t=0.0; self.bounds_r=160.0; self.bounds_b=160.0
            return True

        minx=1e18; miny=1e18; maxx=-1e18; maxy=-1e18
        for p in self.pieces:
            half = (p.r*0.5)*self.max_scale + self.pad
            minx=min(minx, p.x-half)
            miny=min(miny, p.y-half)
            maxx=max(maxx, p.x+half)
            maxy=max(maxy, p.y+half)

        minx=_clamp(minx, 0.0, self.screen_w-1.0)
        miny=_clamp(miny, 0.0, self.screen_h-1.0)
        maxx=_clamp(maxx, minx+160.0, self.screen_w)
        maxy=_clamp(maxy, miny+160.0, self.screen_h)

        changed = force or (abs(minx-self.bounds_l)>2.0 or abs(miny-self.bounds_t)>2.0 or abs(maxx-self.bounds_r)>2.0 or abs(maxy-self.bounds_b)>2.0)
        if changed:
            self.bounds_l=float(minx); self.bounds_t=float(miny)
            self.bounds_r=float(maxx); self.bounds_b=float(maxy)
        return changed

    def _update_bounds(self, dt):
        self._bounds_cd=max(0.0, self._bounds_cd-dt)
        if self._bounds_cd>0.0:
            return
        self._bounds_cd=1.0/30.0

        if not self._recalc_bounds(force=False):
            return

        w=int(max(160, self.bounds_r-self.bounds_l))
        h=int(max(160, self.bounds_b-self.bounds_t))

        try:
            lp=self.root.getLayoutParams()
            if lp:
                need=False
                if getattr(lp,"width",None)!=w:
                    lp.width=w; need=True
                if getattr(lp,"height",None)!=h:
                    lp.height=h; need=True
                if need:
                    self.root.setLayoutParams(lp)
        except Exception:
            pass

        self._apply_layout()

    def _apply_layout(self):
        try:
            self.root.setTranslationX(float(self.bounds_l))
            self.root.setTranslationY(float(self.bounds_t))
        except Exception:
            pass

    def _render_views(self, dt):
        ox=self.bounds_l
        oy=self.bounds_t

        for p in self.pieces:
            if not p.view:
                continue
            lx=(p.x-ox)
            ly=(p.y-oy)

            try:
                p.view.setX(float(lx - p.r*0.5))
                p.view.setY(float(ly - p.r*0.5))
            except Exception:
                try:
                    p.view.setTranslationX(float(lx - p.r*0.5))
                    p.view.setTranslationY(float(ly - p.r*0.5))
                except Exception:
                    pass

            pulse = 1.0 + p.pulse*0.07
            sx = p.sx * pulse
            sy = p.sy * pulse
            try:
                p.view.setScaleX(float(sx))
                p.view.setScaleY(float(sy))
            except Exception:
                pass
            try:
                p.view.setRotation(float(p.rot))
            except Exception:
                pass

            try:
                if p.spark:
                    offx=_clamp(-p.vx/980.0, -0.32, 0.32) * (p.r*0.13)
                    offy=_clamp(-p.vy/980.0, -0.32, 0.32) * (p.r*0.13)
                    p.spark.setTranslationX(float(offx))
                    p.spark.setTranslationY(float(offy))
            except Exception:
                pass

    def _animate_colors(self, dt):
        self._color_acc += dt
        if self._color_acc < (1.0/24.0):
            t=self.t
            for p in self.pieces:
                if not p.spark:
                    continue
                try:
                    s=0.78 + 0.10*math.sin(t*2.0 + p.seed*0.01)
                    a=0.18 + 0.11*math.sin(t*2.7 + 1.2 + p.seed*0.02)
                    p.spark.setScaleX(float(s))
                    p.spark.setScaleY(float(s))
                    p.spark.setRotation(float((t*82.0 + p.seed*0.2) % 360.0))
                    p.spark.setAlpha(float(_clamp(a, 0.10, 0.34)))
                except Exception:
                    pass
            return

        self._color_acc = 0.0
        t=self.t

        for p in self.pieces:
            if not p.bg:
                continue
            breathe = 0.075*math.sin(t*1.15 + p.seed*0.003) + 0.035*math.sin(t*2.25 + 0.8 + p.seed*0.004)
            hue_w   = 0.017*math.sin(t*0.85 + 1.7 + p.seed*0.002)

            h0=(p.h + hue_w + 0.00) % 1.0
            h1=(p.h + hue_w*0.7 + 0.08) % 1.0
            h2=(p.h + hue_w*0.5 + 0.20) % 1.0

            v0=_clamp(1.00 + breathe*0.55, 0.88, 1.06)
            v1=_clamp(0.99 + breathe*0.50, 0.86, 1.05)
            v2=_clamp(0.98 + breathe*0.45, 0.84, 1.04)

            c0=_hsv_to_argb(h0, 0.58, v0, 0.92)
            c1=_hsv_to_argb(h1, 0.70, v1, 0.90)
            c2=_hsv_to_argb(h2, 0.62, v2, 0.92)
            rim=_hsv_to_argb((p.h + hue_w*0.35 + 0.06) % 1.0, 0.18, 1.00, 0.62)

            try:
                if hasattr(p.bg, "setGradientCenter"):
                    cx=0.33 + 0.10*math.sin(t*1.25 + 0.5 + p.seed*0.001)
                    cy=0.30 + 0.10*math.cos(t*1.05 + 1.1 + p.seed*0.001)
                    p.bg.setGradientCenter(float(_clamp(cx,0.18,0.52)), float(_clamp(cy,0.18,0.52)))
            except Exception:
                pass
            try:
                if hasattr(p.bg, "setGradientRadius"):
                    rr=(p.r)*0.92*(0.98 + 0.07*math.sin(t*0.9 + 0.2 + p.seed*0.001))
                    p.bg.setGradientRadius(float(rr))
            except Exception:
                pass
            try:
                if hasattr(p.bg, "setColors"):
                    p.bg.setColors([c0,c1,c2])
                else:
                    p.bg.setColor(c1)
            except Exception:
                pass
            try:
                p.bg.setStroke(int(self._dp(1.8)), rim)
            except Exception:
                pass

    def start(self):
        if self.running:
            return
        self.running=True
        self._t_last=_now()
        self.t=0.0
        self._color_acc=0.0
        self._bounds_cd=0.0

        try:
            self._attach_in_app()
        except Exception as e:
            log(f"[{__id__}] start aborted: cannot attach to Telegram UI: {e}")
            self.running=False
            return

        try:
            self.choreo.postFrameCallback(self.frame_cb)
        except Exception as e:
            log(f"[{__id__}] postFrameCallback start err: {e}")

        self.hapt.texture(155) or self.hapt.haptic("KEYBOARD_TAP",3)
        log(f"[{__id__}] started (TG only) pieces={len(self.pieces)}")

    def stop(self):
        self.running=False
        try:
            self.choreo.removeFrameCallback(self.frame_cb)
        except Exception:
            pass
        try:
            self._detach()
        except Exception:
            pass
        log(f"[{__id__}] stopped")

class SlimePlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.ctx=None
        self.engine=None

    def _get_app_context(self):
        try:
            ApplicationLoader=find_class("org.telegram.messenger.ApplicationLoader")
            ctx=getattr(ApplicationLoader,"applicationContext",None)
            if ctx:
                return ctx
        except Exception as e:
            log(f"[{__id__}] ctx ApplicationLoader err: {e}")
        try:
            ActivityThread=find_class("android.app.ActivityThread")
            app=ActivityThread.currentApplication()
            if app:
                return app
        except Exception as e:
            log(f"[{__id__}] ctx ActivityThread err: {e}")
        return None

    def on_plugin_load(self):
        log(f"[{__id__}] on_plugin_load")
        run_on_ui_thread(self._start)

    def on_plugin_unload(self):
        log(f"[{__id__}] on_plugin_unload")
        run_on_ui_thread(self._stop)

    def _start(self):
        try:
            ctx=self._get_app_context()
            if not ctx:
                log(f"[{__id__}] no ctx")
                return
            self.ctx=ctx
            self.engine=_Engine(ctx)
            self.engine.start()
        except Exception as e:
            log(f"[{__id__}] start err: {e}")
            self.engine=None

    def _stop(self):
        try:
            if self.engine:
                try:
                    self.engine.stop()
                except Exception as e:
                    log(f"[{__id__}] stop err: {e}")
        finally:
            self.engine=None
            self.ctx=None
            log(f"[{__id__}] unloaded")