__id__ = "custom_bullet"
__name__ = "custom bullet"
__description__ = "Локальная верификация. @nloveuser_verify_bot для получения."
__version__ = "3.0.2"
__icon__ = "KittensAnimMd_by_fStikBot/1"
__author__ = "@nloveuser"
__min_version__ = "12.0.1"

import time
import threading
import requests
import json
from typing import Any, Dict, Union, Optional
from base_plugin import BasePlugin, HookResult
from client_utils import get_messages_controller, get_last_fragment
from org.telegram.tgnet import TLRPC
from org.telegram.tgnet.tl import TL_bots
from org.telegram.messenger import MessagesController, UserConfig, ChatObject
from android_utils import log, run_on_ui_thread
from hook_utils import find_class

API_BASE_URL = "https://verify.nloveuser.ru"
API_SUPPORTED_STATUSES = {"verified", "fake", "scam", "major", "durov", "rkn", "custom", "ton", None}

class CustomBadgesPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._applying_flag = False
        self.last_api_fetch = 0
        self.api_fetch_interval = 600
        self.api_statuses_cache = {}
        self.local_custom_statuses = {}
        self.running = True
        self.monitor_thread = None
        self.hook_monitor_thread = None
        self.hook_refs = []

    def _api_get_all_statuses(self) -> Dict[int, Union[str, Dict]]:
        try:
            response = requests.get(f"{API_BASE_URL}/statuses", timeout=10)
            if response.status_code == 200:
                statuses = response.json()
                result = {}
                for item in statuses:
                    status_value = item.get("status")
                    if status_value == "custom" and isinstance(item.get("custom"), dict):
                        result[item["id"]] = item
                    elif status_value in API_SUPPORTED_STATUSES:
                        result[item["id"]] = status_value
                return result
            else:
                log(f"API error: {response.status_code}")
                return {}
        except Exception as e:
            log(f"API request failed: {e}")
            return {}

    def _get_combined_statuses(self) -> Dict[int, Union[str, Dict]]:
        combined = self.api_statuses_cache.copy()
        combined.update(self.local_custom_statuses)
        return combined

    def _apply_statuses(self, statuses: Dict[int, Union[str, Dict]]):
        if not statuses or self._applying_flag:
            return
            
        messages_controller = get_messages_controller()
        if not messages_controller:
            return
            
        self._applying_flag = True
        try:
            for entity_id, status in statuses.items():
                if entity_id > 0:
                    user = messages_controller.getUser(entity_id)
                    if user:
                        self._apply_badge_to_entity(user, status, messages_controller)
                        messages_controller.putUser(user, True)
                else:
                    chat_id = self._convert_to_chat_id(entity_id)
                    chat = messages_controller.getChat(chat_id)
                    if chat:
                        self._apply_badge_to_entity(chat, status, messages_controller)
                        messages_controller.putChat(chat, True)
        finally:
            self._applying_flag = False

    def _convert_to_chat_id(self, entity_id: int) -> int:
        if str(entity_id).startswith('-100'):
            return abs(entity_id) - 1000000000000
        else:
            return abs(entity_id)

    def _is_channel(self, entity: Union[TLRPC.User, TLRPC.Chat]) -> bool:
        if isinstance(entity, TLRPC.Chat):
            return ChatObject.isChannel(entity)
        return False

    def _get_entity_id(self, entity: Union[TLRPC.User, TLRPC.Chat]) -> int:
        if isinstance(entity, TLRPC.User):
            return entity.id
        else:
            if self._is_channel(entity):
                return -(1000000000000 + entity.id)
            else:
                return -entity.id

    def _get_entity_type_text(self, entity: Union[TLRPC.User, TLRPC.Chat], lang: str = "ru") -> str:
        entity_type_ru = "канал" if self._is_channel(entity) else "аккаунт"
        entity_type_en = "channel" if self._is_channel(entity) else "account"
        return entity_type_en if lang == "en" else entity_type_ru

    def _update_entity_about(self, entity_id: int, about_text: str, messages_controller: MessagesController):
        if entity_id > 0:
            user_full = messages_controller.getUserFull(entity_id)
            if user_full:
                user_full.about = about_text
        else:
            chat_id = self._convert_to_chat_id(entity_id)
            chat_full = messages_controller.getChatFull(chat_id)
            if chat_full:
                chat_full.about = about_text

    def _apply_badge_to_entity(self, entity: Union[TLRPC.User, TLRPC.Chat], 
                              status: Union[str, Dict], 
                              messages_controller: MessagesController):
        if not entity:
            return
        
        entity.verified = False
        entity.fake = False
        entity.scam = False
        
        if hasattr(entity, 'bot_verification_icon'):
            entity.bot_verification_icon = 0
        
        if isinstance(status, str):
            self._apply_string_status(entity, status, messages_controller)
        elif isinstance(status, dict) and status.get("status") == "custom":
            self._apply_custom_status(entity, status, messages_controller)

    def _apply_string_status(self, entity: Union[TLRPC.User, TLRPC.Chat], 
                           status: str, 
                           messages_controller: MessagesController):
        entity_type_ru = self._get_entity_type_text(entity, "ru")
        entity_type_en = self._get_entity_type_text(entity, "en")
        
        entity_id = self._get_entity_id(entity)
        
        if status == "verified":
            entity.verified = True
        elif status == "fake":
            entity.fake = True
            self._update_entity_about(
                entity_id,
                f"⚠️ Внимание: Пользователи жаловались, что этот {entity_type_ru} выдает себя за известное лицо или организацию.",
                messages_controller
            )
        elif status == "scam":
            entity.scam = True
            self._update_entity_about(
                entity_id,
                f"⚠️ Внимание: на этот {entity_type_ru} много жаловались в связи с мошенничеством или попытками выдать себя за официальный {entity_type_ru}. Будьте осторожны, особенно если у Вас попросят денег.",
                messages_controller
            )
        elif status == "major":
            self._set_custom_icon(entity, 6016937066422604737)
            self._update_entity_full_status(entity, status, messages_controller, entity_type_ru, entity_type_en)
        elif status == "durov":
            self._set_custom_icon(entity, 5800995289124838177)
            self._update_entity_full_status(entity, status, messages_controller, entity_type_ru, entity_type_en)
        elif status == "rkn":
            self._set_custom_icon(entity, 5800899949440800754)
            self._update_entity_full_status(entity, status, messages_controller, entity_type_ru, entity_type_en)
        elif status == "ton":
            self._set_custom_icon(entity, 5778244409271260914)
            self._update_entity_full_status(entity, status, messages_controller, entity_type_ru, entity_type_en)

    def _apply_custom_status(self, entity: Union[TLRPC.User, TLRPC.Chat], 
                           status: Dict, 
                           messages_controller: MessagesController):
        custom_data = status.get("custom", {})
        icon = custom_data.get("icon", 0)
        description = custom_data.get("description", "")
        
        if icon:
            self._set_custom_icon(entity, icon)
            entity_type_ru = self._get_entity_type_text(entity, "ru")
            entity_type_en = self._get_entity_type_text(entity, "en")
            self._update_entity_full_custom(entity, icon, description, messages_controller, entity_type_ru, entity_type_en)

    def _set_custom_icon(self, entity: Union[TLRPC.User, TLRPC.Chat], icon: int):
        if hasattr(entity, 'bot_verification_icon'):
            entity.bot_verification_icon = icon

    def _update_entity_full_status(self, entity: Union[TLRPC.User, TLRPC.Chat], status: str,
                                 messages_controller: MessagesController, entity_type_ru: str, entity_type_en: str):
        entity_id = self._get_entity_id(entity)
        
        if entity_id > 0:
            user_full = messages_controller.getUserFull(entity_id)
            if not user_full:
                return
                
            if status == "major":
                self._create_bot_verification(user_full, 6016937066422604737, f"{entity_type_ru.capitalize()} верифицирован организацией «Major»")
            elif status == "durov":
                self._create_bot_verification(user_full, 5800995289124838177, f"This {entity_type_en} is verified as official by the representatives of Telegram.")
            elif status == "rkn":
                self._create_bot_verification(user_full, 5800899949440800754, f"Регистрация в РКН: https://gosuslugi.ru/snet/673761b8b5d2ec30cf7356c3")
            elif status == "ton":
                self._create_bot_verification(user_full, 5778244409271260914, f"Verified {entity_type_en} of The Open Network Foundation member")
        else:
            chat_id = self._convert_to_chat_id(entity_id)
            chat_full = messages_controller.getChatFull(chat_id)
            if not chat_full:
                return
                
            if status == "major":
                self._create_bot_verification(chat_full, 6016937066422604737, f"{entity_type_ru.capitalize()} верифицирован организацией «Major»")
            elif status == "durov":
                self._create_bot_verification(chat_full, 5800995289124838177, f"This {entity_type_en} is verified as official by the representatives of Telegram.")
            elif status == "rkn":
                self._create_bot_verification(chat_full, 5800899949440800754, f"Регистрация в РКН: https://gosuslugi.ru/snet/673761b8b5d2ec30cf7356c3")
            elif status == "ton":
                self._create_bot_verification(chat_full, 5778244409271260914, f"Verified {entity_type_en} of The Open Network Foundation member")

    def _update_entity_full_custom(self, entity: Union[TLRPC.User, TLRPC.Chat], icon: int, description: str,
                                 messages_controller: MessagesController, entity_type_ru: str, entity_type_en: str):
        entity_id = self._get_entity_id(entity)
        
        if entity_id > 0:
            user_full = messages_controller.getUserFull(entity_id)
            if user_full and icon:
                if "account" in description.lower() or "аккаунт" in description.lower():
                    ru_description = description.replace("account", entity_type_ru).replace("аккаунт", entity_type_ru)
                    en_description = description.replace("аккаунт", entity_type_en).replace("account", entity_type_en)
                    final_description = en_description if any(word in description.lower() for word in ["this", "verified", "official", "channel"]) else ru_description
                else:
                    final_description = description
                self._create_bot_verification(user_full, icon, final_description)
        else:
            chat_id = self._convert_to_chat_id(entity_id)
            chat_full = messages_controller.getChatFull(chat_id)
            if chat_full and icon:
                if "account" in description.lower() or "аккаунт" in description.lower():
                    ru_description = description.replace("account", entity_type_ru).replace("аккаунт", entity_type_ru)
                    en_description = description.replace("аккаунт", entity_type_en).replace("account", entity_type_en)
                    final_description = en_description if any(word in description.lower() for word in ["this", "verified", "official", "channel"]) else ru_description
                else:
                    final_description = description
                self._create_bot_verification(chat_full, icon, final_description)

    def _create_bot_verification(self, entity_full: Union[TLRPC.UserFull, TLRPC.ChatFull], icon: int, description: str):
        try:
            bot_verification = TL_bots.botVerification()
            bot_verification.icon = icon
            bot_verification.description = description
            entity_full.bot_verification = bot_verification
        except Exception as e:
            log(f"Failed to create bot verification: {e}")

    def _save_local_custom_statuses(self):
        try:
            self.set_setting("local_custom_statuses", json.dumps(self.local_custom_statuses))
        except Exception as e:
            log(f"Failed to save local statuses: {e}")

    def _reset_entity_status(self, entity_id: int):
        messages_controller = get_messages_controller()
        if not messages_controller:
            return
        
        if entity_id > 0:
            user = messages_controller.getUser(entity_id)
            if user:
                user.verified = False
                user.fake = False
                user.scam = False
                if hasattr(user, 'bot_verification_icon'):
                    user.bot_verification_icon = 0
                messages_controller.putUser(user, True)
            
            user_full = messages_controller.getUserFull(entity_id)
            if user_full:
                if hasattr(user_full, 'bot_verification'):
                    user_full.bot_verification = None
                user_full.about = ""
        else:
            chat_id = self._convert_to_chat_id(entity_id)
            chat = messages_controller.getChat(chat_id)
            if chat:
                chat.verified = False
                chat.fake = False
                chat.scam = False
                if hasattr(chat, 'bot_verification_icon'):
                    chat.bot_verification_icon = 0
                messages_controller.putChat(chat, True)
            
            chat_full = messages_controller.getChatFull(chat_id)
            if chat_full:
                if hasattr(chat_full, 'bot_verification'):
                    chat_full.bot_verification = None
                chat_full.about = ""

    def _monitor_badges_loop(self):
        while self.running:
            try:
                messages_controller = get_messages_controller()
                if messages_controller and not self._applying_flag:
                    combined_statuses = self._get_combined_statuses()
                    self._apply_statuses(combined_statuses)

                current_time = time.time()
                if current_time - self.last_api_fetch >= self.api_fetch_interval:
                    self.last_api_fetch = current_time
                    api_statuses = self._api_get_all_statuses()
                    if api_statuses != self.api_statuses_cache:
                        self.api_statuses_cache = api_statuses
                        self._apply_statuses(self._get_combined_statuses())
                
                time.sleep(0.001)
                
            except Exception as e:
                log(f"Monitor loop error: {e}")
                time.sleep(0.001)

    def _hook_monitor_loop(self):
        hook_check_interval = 5
        last_hook_check = 0
        
        while self.running:
            try:
                current_time = time.time()
                
                if current_time - last_hook_check >= hook_check_interval:
                    last_hook_check = current_time
                    
                    messages_controller = get_messages_controller()
                    if messages_controller:
                        combined_statuses = self._get_combined_statuses()
                        if combined_statuses:
                            self._apply_statuses(combined_statuses)
                    
                    api_statuses = self._api_get_all_statuses()
                    if api_statuses != self.api_statuses_cache:
                        self.api_statuses_cache = api_statuses
                        self._apply_statuses(self._get_combined_statuses())
                
                time.sleep(0.1)
                
            except Exception as e:
                log(f"Hook monitor loop error: {e}")
                time.sleep(1)

    def on_plugin_load(self):
        try:
            custom_json = self.get_setting("local_custom_statuses", "{}")
            self.local_custom_statuses = json.loads(custom_json)
        except Exception as e:
            log(f"Failed to load local statuses: {e}")
            self.local_custom_statuses = {}
        
        self.running = True
        
        # Setup deeplink handling
        self._setup_deeplink_handling()
        
        self.monitor_thread = threading.Thread(target=self._monitor_badges_loop, daemon=True)
        self.monitor_thread.start()
        
        self.hook_monitor_thread = threading.Thread(target=self._hook_monitor_loop, daemon=True)
        self.hook_monitor_thread.start()

        api_statuses = self._api_get_all_statuses()
        self.api_statuses_cache = api_statuses
        self._apply_statuses(self._get_combined_statuses())

    def on_plugin_unload(self):
        self.running = False
        
        # Cleanup deeplink hooks
        for ref in self.hook_refs:
            if ref:
                try:
                    self.unhook_method(ref)
                except:
                    pass
        self.hook_refs.clear()
        
        if self.monitor_thread and self.monitor_thread.is_alive():
            self.monitor_thread.join(timeout=1.0)
        
        if self.hook_monitor_thread and self.hook_monitor_thread.is_alive():
            self.hook_monitor_thread.join(timeout=1.0)
        
        messages_controller = get_messages_controller()
        if messages_controller:
            self._applying_flag = True
            try:
                all_entity_ids = list(self.api_statuses_cache.keys()) + list(self.local_custom_statuses.keys())
                for entity_id in all_entity_ids:
                    self._reset_entity_status(entity_id)
            finally:
                self._applying_flag = False

    def on_account_changed(self, account: int):
        api_statuses = self._api_get_all_statuses()
        self.api_statuses_cache = api_statuses
        self._apply_statuses(self._get_combined_statuses())

    def on_app_restart(self):
        api_statuses = self._api_get_all_statuses()
        self.api_statuses_cache = api_statuses
        self._apply_statuses(self._get_combined_statuses())

    def add_custom_status(self, entity_id: int, icon: int, description: str):
        self.local_custom_statuses[entity_id] = {
            "status": "custom",
            "custom": {
                "icon": icon,
                "description": description
            }
        }
        self._save_local_custom_statuses()
        self._apply_statuses({entity_id: self.local_custom_statuses[entity_id]})

    def remove_custom_status(self, entity_id: int):
        if entity_id in self.local_custom_statuses:
            del self.local_custom_statuses[entity_id]
            self._save_local_custom_statuses()
            
            api_status = self.api_statuses_cache.get(entity_id)
            if api_status:
                self._apply_statuses({entity_id: api_status})
            else:
                self._reset_entity_status(entity_id)

    def get_entity_status(self, entity_id: int) -> Optional[Union[str, Dict]]:
        return self._get_combined_statuses().get(entity_id)

    def get_all_statuses(self) -> Dict[int, Union[str, Dict]]:
        return self._get_combined_statuses().copy()

    def _setup_deeplink_handling(self):
        try:
            LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
            if LaunchActivity:
                method = LaunchActivity.getClass().getDeclaredMethod("handleIntent", 
                    find_class("android.content.Intent").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                self.hook_refs.append(self.hook_method(method, CustomBulletDeeplinkHook(self)))
                log("Deeplink handling setup successfully")
        except Exception as e:
            log(f"Error setting up deeplink handling: {e}")

    def _show_verification_support_dialog(self):
        try:
            log("Showing support development dialog...")
            
            from org.telegram.ui.ActionBar import BottomSheet
            from org.telegram.ui.Components import LayoutHelper
            from org.telegram.messenger import AndroidUtilities
            from android.widget import LinearLayout, TextView, FrameLayout
            from android.view import Gravity
            from android.util import TypedValue
            from androidx.core.widget import NestedScrollView
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.messenger import R as R_tg
            from android.widget import ImageView
            from org.telegram.ui.ActionBar import SimpleTextView
            from java import dynamic_proxy
            
            fragment = get_last_fragment()
            if not fragment:
                log("No fragment available for dialog")
                return
                
            context = fragment.getContext()
            activity = fragment.getParentActivity()
            if not activity:
                log("No activity available for dialog")
                return
            
            bottom_sheet = BottomSheet(context, False, fragment.getResourceProvider())
            bottom_sheet.setApplyBottomPadding(False)
            bottom_sheet.setApplyTopPadding(False)
            bottom_sheet.fixNavigationBar(Theme.getColor(Theme.key_windowBackgroundWhite))
            
            linear_layout = LinearLayout(context)
            linear_layout.setOrientation(LinearLayout.VERTICAL)
            linear_layout.setClickable(True)
            
            frame_layout = FrameLayout(context)
            frame_layout.addView(linear_layout)
            
            scroll_view = NestedScrollView(context)
            scroll_view.addView(frame_layout)
            bottom_sheet.setCustomView(scroll_view)
            
            # Close button
            close_view = ImageView(context)
            close_view.setBackground(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector)))
            close_view.setColorFilter(Theme.getColor(Theme.key_sheet_other))
            close_view.setImageResource(R_tg.drawable.ic_layer_close)
            OnClickInterface = find_class("android.view.View$OnClickListener")
            OnClick = dynamic_proxy(OnClickInterface)
            class CloseClickImpl(OnClick):
                def __init__(self, bottom_sheet):
                    super().__init__()
                    self.bottom_sheet = bottom_sheet
                def onClick(self, v):
                    self.bottom_sheet.dismiss()
            close_view.setOnClickListener(CloseClickImpl(bottom_sheet))
            close_padding = AndroidUtilities.dp(8)
            close_view.setPadding(close_padding, close_padding, close_padding, close_padding)
            frame_layout.addView(close_view, LayoutHelper.createFrame(36, 36, Gravity.TOP | Gravity.END, 6, 8, 8, 0))
            
            # Emoji/Sticker at the top
            from org.telegram.ui.Components import BackupImageView
            from org.telegram.messenger import MediaDataController, ImageLocation
            from org.telegram.tgnet import TLRPC
            
            emoji_image_view = BackupImageView(context)
            emoji_image_view.setRoundRadius(AndroidUtilities.dp(45))
            emoji_image_view.getImageReceiver().setCrossfadeWithOldImage(True)
            linear_layout.addView(emoji_image_view, LayoutHelper.createLinear(90, 90, Gravity.TOP | Gravity.CENTER_HORIZONTAL, 0, 27, 0, 0))
            
            # Load emoji sticker
            try:
                current_account = 0
                try:
                    current_account = fragment.getCurrentAccount()
                except Exception:
                    current_account = 0

                media_controller = MediaDataController.getInstance(current_account)
                sticker_set = media_controller.getStickerSetByName("exteraGramEmoji")
                if sticker_set and sticker_set.documents and sticker_set.documents.size() > 1:
                    sticker_document = sticker_set.documents.get(1)  # Index 2 (0-based)
                    image_location = ImageLocation.getForDocument(sticker_document)
                    emoji_image_view.setImage(image_location, "90_90", None, 0, sticker_document)
                    log("Emoji loaded from cache: exteraGramEmoji/2")
                else:
                    log("Emoji cache miss: exteraGramEmoji, requesting set")
                    try:
                        input_set = TLRPC.TL_inputStickerSetShortName()
                        input_set.short_name = "exteraGramEmoji"

                        def _on_set_response(result):
                            try:
                                if result and result.documents and result.documents.size() > 1:
                                    doc = result.documents.get(1)
                                    img_loc = ImageLocation.getForDocument(doc)
                                    run_on_ui_thread(lambda: emoji_image_view.setImage(img_loc, "90_90", None, 0, doc))
                                    log("Emoji loaded after fetch: exteraGramEmoji/2")
                            except Exception as _e_inner:
                                log(f"Error applying fetched emoji: {_e_inner}")

                        from java import dynamic_proxy
                        from org.telegram.messenger import Utilities
                        class Callback1(dynamic_proxy(Utilities.Callback)):
                            def __init__(self, fn):
                                super().__init__()
                                self._fn = fn
                            def run(self, arg):
                                try:
                                    self._fn(arg)
                                except Exception as e:
                                    log(f"Callback error: {str(e)}")

                        media_controller.getStickerSet(input_set, None, False, Callback1(_on_set_response))
                    except Exception as _e_fetch:
                        log(f"Error requesting emoji set 'exteraGramEmoji': {_e_fetch}")
            except Exception as e:
                log(f"Error loading emoji: {e}")
            
            # Title
            title_text_view = SimpleTextView(context)
            title_text_view.setTypeface(AndroidUtilities.bold())
            title_text_view.setTextSize(20)
            title_text_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            title_text_view.setText("Поддержать разработку")
            title_text_view.setGravity(Gravity.CENTER)
            linear_layout.addView(title_text_view, LayoutHelper.createLinear(-2, -2, Gravity.TOP | Gravity.CENTER_HORIZONTAL, 10, 10, 10, 0))
            
            # Description
            description_text_view = TextView(context)
            description_text_view.setGravity(Gravity.CENTER)
            description_text_view.setText("Поддерживая проект, вы не только поддерживаете его, но и можете получить уникальный значок.")
            description_text_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            description_text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
            linear_layout.addView(description_text_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 10, 24, 20))
            
            # Instructions text
            instructions_text_view = TextView(context)
            instructions_text_view.setGravity(Gravity.CENTER)
            instructions_text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            instructions_text_view.setText("Напишите @nloveuser по кнопке ниже. По реквизитам переводите 100 рублей. После подтверждения оплаты, вы получаете уникальный значок.")
            instructions_text_view.setTextColor(Theme.getColor(Theme.key_dialogTextGray3))
            linear_layout.addView(instructions_text_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 17, 24, 20))
            
            # Donation button
            donation_button = TextView(context)
            donation_button.setBackground(Theme.createSimpleSelectorRoundRectDrawable(
                AndroidUtilities.dp(8), 
                Theme.getColor(Theme.key_featuredStickers_addButton), 
                Theme.getColor(Theme.key_featuredStickers_addButtonPressed)
            ))
            donation_button.setGravity(Gravity.CENTER)
            donation_button.setSingleLine(True)
            donation_button.setText("Сделать пожертвование")
            donation_button.setTextColor(Theme.getColor(Theme.key_featuredStickers_buttonText))
            donation_button.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            donation_button.setTypeface(AndroidUtilities.bold())
            
            class DonationClickImpl(OnClick):
                def __init__(self, bottom_sheet):
                    super().__init__()
                    self.bottom_sheet = bottom_sheet
                def onClick(self, v):
                    self._handle_donation_click()
                    self.bottom_sheet.dismiss()
                
                def _handle_donation_click(self):
                    try:
                        log("User selected: Make donation - opening Telegram with pre-filled message")
                        from org.telegram.messenger import MessagesController
                        from org.telegram.tgnet import TLRPC
                        from org.telegram.messenger import UserConfig
                        
                        # Get current account
                        current_account = 0
                        try:
                            current_account = fragment.getCurrentAccount()
                        except Exception:
                            current_account = 0
                        
                        # Get user by username
                        messages_controller = MessagesController.getInstance(current_account)
                        if messages_controller:
                            # Create input user
                            input_user = TLRPC.TL_inputUser()
                            input_user.user_id = 0  # Will be resolved by username
                            
                            # Create input peer
                            input_peer = TLRPC.TL_inputPeerUser()
                            input_peer.user_id = 0  # Will be resolved
                            
                            # Try to resolve username
                            def on_user_resolved(user):
                                try:
                                    if user:
                                        # Open chat with user
                                        from org.telegram.messenger import AndroidUtilities
                                        
                                        # Create chat activity intent
                                        fragment = get_last_fragment()
                                        if fragment:
                                            activity = fragment.getParentActivity()
                                            if activity:
                                                # Start chat with pre-filled message
                                                from android.content import Intent
                                                intent = Intent(activity, ChatActivity)
                                                intent.putExtra("user_id", user.id)
                                                intent.putExtra("message", "Привет! Я бы хотел поддержать твой проект и получить кастомную метку. Скинь мне реквизиты, я тебе переведу 100₽ и выдай, пожалуйста, кастомную метку.")
                                                activity.startActivity(intent)
                                                log("Opened chat with @nloveuser with pre-filled message")
                                            else:
                                                log("No activity available")
                                        else:
                                            log("No fragment available")
                                    else:
                                        log("User @nloveuser not found")
                                except Exception as e:
                                    log(f"Error opening chat: {e}")
                            
                            # Resolve username
                            try:
                                from java import dynamic_proxy
                                from org.telegram.messenger import Utilities
                                
                                class UserCallback(dynamic_proxy(Utilities.Callback)):
                                    def __init__(self, callback_fn):
                                        super().__init__()
                                        self.callback_fn = callback_fn
                                    def run(self, result):
                                        try:
                                            if result and hasattr(result, 'users') and result.users.size() > 0:
                                                user = result.users.get(0)
                                                self.callback_fn(user)
                                            else:
                                                self.callback_fn(None)
                                        except Exception as e:
                                            log(f"Error in user callback: {e}")
                                            self.callback_fn(None)
                                
                                # Try to resolve by username
                                messages_controller.resolveUsername("nloveuser", UserCallback(on_user_resolved))
                                
                            except Exception as e:
                                log(f"Error resolving username: {e}")
                                # Fallback to external link
                                from android.content import Intent
                                from android.net import Uri
                                intent = Intent(Intent.ACTION_VIEW)
                                intent.setData(Uri.parse("tg://resolve?domain=nloveuser&text=Привет!+Я+бы+хотел+поддержать+твой+проект+и+получить+кастомную+метку.+Скинь+мне+реквизиты,+я+тебе+переведу+100₽+и+выдай,+пожалуйста,+кастомную+метку."))
                                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                                fragment = get_last_fragment()
                                if fragment:
                                    context = fragment.getContext()
                                    context.startActivity(intent)
                                    log("Opened external Telegram link as fallback")
                        else:
                            log("No messages controller available")
                    except Exception as e:
                        log(f"Error opening chat with @nloveuser: {e}")
                        # Fallback to external link
                        try:
                            from android.content import Intent
                            from android.net import Uri
                            intent = Intent(Intent.ACTION_VIEW)
                            intent.setData(Uri.parse("tg://resolve?domain=nloveuser&text=Привет!+Я+бы+хотел+поддержать+твой+проект+и+получить+кастомную+метку.+Скинь+мне+реквизиты,+я+тебе+переведу+100₽+и+выдай,+пожалуйста,+кастомную+метку."))
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                            fragment = get_last_fragment()
                            if fragment:
                                context = fragment.getContext()
                                context.startActivity(intent)
                                log("Opened external Telegram link as fallback")
                        except Exception as e2:
                            log(f"Error opening fallback link: {e2}")
            
            donation_button.setOnClickListener(DonationClickImpl(bottom_sheet))
            linear_layout.addView(donation_button, LayoutHelper.createLinear(-1, 48, Gravity.START, 14, 0, 14, 15))
            
            bottom_sheet.show()
            log("Support development dialog shown successfully")
            
        except Exception as e:
            log(f"Error in _show_verification_support_dialog: {e}")
            import traceback
            log(f"Traceback: {traceback.format_exc()}")


class CustomBulletDeeplinkHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if len(param.args) < 7:
                return
            intent = param.args[0]
            if not intent or intent.getAction() != "android.intent.action.VIEW":
                return
            data = intent.getData()
            if not data:
                return
            url = str(data)
            if url == "tg://verif/support":
                run_on_ui_thread(self.plugin._show_verification_support_dialog)
                param.setResult(None)
        except Exception as e:
            log(f"Error in deeplink hook: {e}")

    def after_hooked_method(self, param):
        pass