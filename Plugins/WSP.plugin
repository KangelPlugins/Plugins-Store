"""‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£§‚£∂‚£æ‚£ø‚£Ω‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¢‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚£Ä‚£Ä‚†Ä‚£Ä‚£Ä‚°¥‚£Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£µ‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£û‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ω‚£§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†ë‚£¶‚£§‚¢§‚°§‚£§‚¢∂‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ª‚°í‚†í‚†í‚†à‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ª‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Å‚£¥
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚°ü‚£ø‚£õ‚£ø‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚°∑‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚£†
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£æ‚°ø‚£ø‚£õ‚°ü‚£ø‚£ª‚¢ª‚£ü‚°ª‚£ü‚£ª‚£õ‚£ü‚£ª‚£õ‚£ü‚£ª‚£õ‚¢Ø‚¢ø‚°π‚£è‚¢ø‚°π‚¢Ø‚£Ω‚¢ø‚£ø‚££‚¢ü‚°º‚£ü‚£Æ‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ω‚£≤‚£§‚£§‚†î‚°†‚†Ç‚£¨
‚†Ä‚††‚†§‚†¥‚†∂‚†ü‚†ã‚£Ω‚£≥‚†ø‚£º‚£π‚£Ø‚¢≥‚¢Ø‚£ú‚°≥‚£ù‚¢∂‚°π‚¢Æ‚°µ‚£´‚°ú‚£ß‚£õ‚¢Æ‚°≥‚£ù‚£Æ‚£≥‚£Ω‚£ß‚£ø‚¢á‚£ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£è‚†â‚†â‚†Å‚†Ä‚†Ä‚†£‚°ò‚£Å
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£∑‚£æ‚£∑‚£ø‚£æ‚£æ‚£∑‚£ø‚£æ‚£ø‚£∑‚£ø‚£∑‚£ø‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†¥‚†¨‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä
‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†°‚°â‚†Ü‚£Ø‚¢ª‚£ø‚£ø‚¢©‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚°∂‚†ñ‚†Å
‚†à‚†ö‚†õ‚†õ‚†õ‚†õ‚†ã‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†è‚††‚¢Å‚†Ç‚£Ω‚†à‚¢ø‚£ø‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†õ‚†õ‚†õ‚†õ‚†ã‚†â‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ø‚†Ω‚†ü‚†í‚†ö‚°ó‚£Ä‚£∏‚£è‚£Ä‚£Ñ‚£ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ü‚£∂‚†∂‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°è‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†ê‚¢©
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†â‚¢†‚†Ñ‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ß‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä‚¢®‚†∞‚†∂‚¢æ
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚¢º‚£ø‚†Å‚†Ä‚†ò‚°Ü‚†Ä‚¢ø‚°ü‚£ø‚£ø‚£ø‚°Ø‚¢ô‚°É‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ω‚°ï‚¢Ñ‚†Ä‚°∞‚¢Ä‚£¥‚¢ü
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†±‚†Ä‚†à‚¢ø‚£ç‚†õ‚†â‚£≥‚°ü‚¢Å‚£û‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ñ‚†ò‚¢ß‚°ª‚¢∑‚£ª
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚£ø‚£ø‚°è‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£Å‚°Ä‚†Ä‚†â‚†ø‚†ø‚¢â‚£∞‚°é‚¢á‚£∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚£ø‚£ø‚¢∑‚°Ä‚†π‚†á‚†Ü
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ü‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°è‚†ò‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†É‚†Ä‚†Ä‚†Ä‚†í‚¢Ñ‚£∫‚†ç‚£â‚£ä‚£ô‚£õ‚°≠‚†ã‚†â‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†ô‚†ª‚†ø‚¢Ø‚£∑‚£§‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢á‚°¥‚¢ª‚°ü‚†â‚†Ä‚£¶‚†Ä‚†Ä‚†Ä‚††‚†î‚¢ì‚¢ë‚¢Ω‚¢õ‚¢≠‚¢è‚¢ù‚†∂‚†Å‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£å‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†à‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ü‚£¶‚£§‚£Ä‚†Ä‚¢†‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ª‚†Ä‚†Ä‚†Ä‚°§‚¢¶‚†§‚£§‚°§‚¢Ñ‚†§‚£§‚°¥‚†û‚†©‚¢∂‚†è‚†Ä‚†Ä‚£†‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ç‚†Å‚†ò‚†Å
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°ê‚†Å‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ü‚£Ä‚†Ä‚†ô‚†•‚¢å‚£Ä‚£â‚£â‚£â‚£Å‚°†‚†§‚†ö‚†Å‚£†‚°∂‚°û‚°ü‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†Å‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†õ‚†í‚°¢‚†§‚¢Ñ‚£Ä‚°Ä‚†Ä‚¢Ä‚£†‚†§‚†í‚†ã‚†Å‚£†‚†è‚†Ä‚°ø‚¢∏‚£ø‚£ø‚£ø‚°ü‚¢Å‚†á‚†Ä‚†Ä‚†â‚†à‚†ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚°â‚†õ‚†ø‚¢ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°æ‚†ü‚†Å‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†§‚°Ä‚†Ä‚¢á‚†Ä‚†Ä‚£≥‚†à‚†â‚†Å‚†Ä‚†Ä‚£Ä‚†¥‚†Æ‚£Ä‚°Ä‚¢Ä‚°á‚¢∏‚†è‚†Ä‚¢π‚†ñ‚¢Å‚£†‚†§‚†Ç‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚£Ä‚†î‚†ö‚†â‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚£ø‚£ø‚†ü‚°ü‚¢ª‚£ø‚£ø‚°á‚†Ä‚†Ä‚°á‚¢£‚†Ä‚†ò‚£Ü‚†ú‚¢π‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£∑‚¢≤‚°Ñ‚†Ä‚†à‚¢π‚†ã‚°ç‚¢Ä‚£Ä‚†Ä‚°∑‚†õ‚†Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£Ω‚°Ä‚†Ä
‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚£ø‚£ø‚†É‚¢∞‚°á‚†ò‚£ø‚£ø‚£ß‚°∏‚°º‚¢Ä‚£®‚£ß‚£†‚†ã‚†Ä‚†ë‚†¶‚†¥‚†ä‚¢â‚£Ä‚¢ª‚†ò‚£∑‚†Ä‚†Ä‚¢∏‚¢ò‚¢†‚†É‚†Ä‚°á‚°ó‚¢à‚£Å‚††‚†§‚†§‚¢Ñ‚°Å‚†¢‚°Ä‚†∏‚£ø‚°ø‚£ø‚£ø‚¢ß‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£è‚†É‚†Ä‚°å‚°á‚†Ä‚†π‚£ø‚£ø‚£ß‚†¥‚†ã‚£ø‚°ø‚°è‚†â‚†ì‚†Ü‚†Ä‚†Ä‚†ñ‚†â‚¢†‚†∫‚£º‚£ø‚£Ü‚†Ä‚¢†‚†á‚¢ú‚†Ä‚†Ä‚°á‚°Ø‚†ï‚†Ç‚†â‚†â‚†â‚†¢‚°ú‚¢¢‚°ú‚†Ü‚£ø‚£ø‚†à‚£ø‚£ø‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ø‚†ã‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚¢Ä‚†π‚£ø‚°∑‚°Ä‚†Ä‚£ø‚†Å‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚††‚¢É‚°æ‚£ø‚¢ü‚°ø‚¢¶‚†É‚†Ä‚†∏‚†Ä‚°∏‚¢Ä‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢Ü‚£ø‚°ê‚£ø‚£ø‚†Ä‚†ò‚£∑‚°á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†î‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚¢°‚£†‚°é‚†Ä‚†ô‚£∑‚†ë‚†Ñ‚¢£‚°Ä‚¢á‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†Å‚£†‚£ø‚°ø‚¢ã‚†û‚†Å‚†Ä‚†Ä‚¢∏‚†Ä‚†ì‚†É‚¢∏‚†Ä‚°†‚†î‚†í‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢ò‚¢æ‚†π‚£π‚£ø‚†Ä‚†Ä‚†∏‚°á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†é‚†Ä‚¢∞‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚¢±‚†Ä‚†Ä‚†Ä‚†à‚¢ß‚†Ä‚¢π‚£∑‚°∏‚£Ü‚†Ä‚¢∞‚†Å‚¢Ä‚£æ‚£Ω‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†á‚†Ä‚†Ä‚†∏‚£Ö‚°Ä‚†Ä‚†Ä‚†Ä‚°ë‚†í‚¢Ñ‚†å‚£∏‚†Ä‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ã‚†Ä‚†Ä‚†Ä‚£∑‚°Ä‚†Ä‚¢†‚†õ‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†°‚†Ä‚¢ø‚£ø‚£Ø‚£ë‚£Ü‚£∞‚£ø‚°ø‚¢É‚°†‚†§‚†§‚†§‚¢Ñ‚°Ä‚†Ä‚†Ä‚°í‚†Ä‚¢Ä‚°ú‚¢ª‚†Ä‚†Ä‚†Ä‚¢∞‚†Å‚†Ä‚†Ä‚†≥‚£á‚£†‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†ç
‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°î‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢≥‚¢£‚†Ä‚°ò‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ø‚£≠‚†∑‚£Ø‚£ø‚£ø‚†ã‚†Ä‚†â‚¢Ñ‚¢†‚°Ç‚†Å‚†Å‚†¢‚°ë‚¢¶‚¢É‚°†‚†ä‚†Ä‚°Ω‚†Ä‚†Ä‚†Ä‚†∏‚°Ñ‚†Ä‚¢†‚†Å‚†Ä‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚°é‚†ò‚°Ñ‚†Ä‚†Ä‚†Ä‚†ê‚°Ä‚¢ß‚†Ç‚†á‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£≥‚¢≠‚£õ‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†´‚¢ñ‚†í‚†¥‚†É‚†Ä‚†±‚°Ñ‚†Ä‚¢Ä‚°è‚†í‚†Ç‚†§‚£∏‚†Å‚†Ä‚¢∏‚†Ü‚†Ä‚†è‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†Ä‚†ò‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢ü‚°å‚¢Ü‚†Ä‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£Ñ‚°Ä‚†Ä‚°á‚†Ä‚†ò‚°á‚†Ä‚†Ä‚£†‚†è‚†à‚†±‚°º‚°Ä‚†Ä‚°ñ‚†ò‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†ú‚†Ä‚†∑‚°Ä‚†Ä‚†∞‚¢Ñ‚†Ä‚†à‚¢Æ‚¢å‚¢£‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ø‚£è‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ë‚¢å‚°í‚†Å‚†Ä‚†Ä‚†ô‚†í‚†ö‚†•‚¢§‚†ñ‚†ä‚†Ä‚£à‚†ñ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢Ä‚†é‚†Ä‚†Ä‚†∏‚†å‚†¢‚£Ñ‚°Ä‚£ë‚¢∂‚£Å‚£Ä‚£π‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚°Ω‚£π‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£©‚†í‚†í‚†í‚£∂‚£§‚°Ä‚†Ä‚£â‚£ª‚†ù‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
–ò —á–µ–≥–æ —Ç—ã —Ç—É—Ç –∏—â–µ—à—å-—Ç–æ?
–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å –∫–∞–∫—É—é —Ç–æ —á–∞—Å—Ç—å –∫–æ–¥–∞ –ø—Ä–æ—à—É —É–∫–∞–∑–∞—Ç—å
@TomokoPlugins & @nokirby
"""
import base64
import hashlib
import hmac
import json
import math
import random
import re
import secrets
import threading
import time
import traceback
import urllib.error
import urllib.request
import urllib.parse
import weakref
import zlib
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta, timezone

from android.animation import ObjectAnimator, ValueAnimator
from android.content.res import ColorStateList
from android.graphics import Color, Paint, Rect, Typeface
from android.graphics.drawable import GradientDrawable, RippleDrawable, ShapeDrawable
from android.graphics.drawable.shapes import ArcShape
from android.view import Gravity, MotionEvent, View, ViewTreeObserver
from android.view.animation import (
    AccelerateDecelerateInterpolator,
    OvershootInterpolator,
)
from android.widget import FrameLayout, HorizontalScrollView, LinearLayout, ScrollView, TextView
from android_utils import OnClickListener, log as android_log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType, MethodHook
from client_utils import get_last_fragment, send_text
from hook_utils import find_class
from java import dynamic_proxy
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui.ActionBar import BottomSheet, Theme
from org.telegram.ui.Components import BackupImageView
from ui.bulletin import BulletinHelper

origRunUiThread = run_on_ui_thread
uiGuardRef = None

def bindUiGuard(plugin):
    global uiGuardRef
    uiGuardRef = weakref.ref(plugin) if plugin else None

def uiAlive():
    try:
        plugin = uiGuardRef() if uiGuardRef else None
        if not plugin:
            return True
        return not plugin.shutdown_event.is_set()
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        return True

def run_on_ui_thread(func, delayMs=0):
    if not func:
        return False
    try:
        if not uiAlive():
            return False
        def runGuarded():
            if not uiAlive():
                return
            try:
                func()
            except Exception as err:
                try:
                    log(f"WSP: ui task error: {err}")
                except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                    pass
        origRunUiThread(runGuarded, delayMs)
        return True
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        return False

logDebug = False
hexMask = re.compile(r"\b[0-9a-fA-F]{16,}\b")
bearerMask = re.compile(r"(Bearer\s+)([A-Za-z0-9._-]{8,})")
kvMask = re.compile(
    r"(?i)\b(install[_-]?id|x-install-id|install[_-]?secret|x-install-secret|token|secret|server_secret|devkey|p2p[_-]?key)\b\s*[:=]\s*([A-Za-z0-9._-]{4,})"
)

def scrubLogText(text):
    if not text:
        return text
    text = bearerMask.sub(r"\1***", text)
    text = kvMask.sub(lambda m: f"{m.group(1)}=***", text)
    def maskHex(match):
        value = match.group(0)
        if len(value) <= 8:
            return value
        return f"{value[:4]}...{value[-4:]}"
    return hexMask.sub(maskHex, text)

def setLogDebug(enabled):
    global logDebug
    logDebug = bool(enabled)

def log(msg, data=None):
    try:
        if not logDebug:
            return
        try:
            text = str(msg)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            text = repr(msg)
        text = scrubLogText(text)
        dataText = None
        if data is not None:
            try:
                dataText = str(data)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                dataText = repr(data)
            dataText = scrubLogText(dataText)
        if dataText is None:
            android_log(f"[WatamoteStreakPet] {text}")
        else:
            android_log(text, dataText)
    except TypeError:
        try:
            if data is None:
                android_log(f"[WatamoteStreakPet] {text}")
            else:
                android_log(f"[WatamoteStreakPet] {text}: {data}")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            pass

__id__ = "WatamoteStreakPet"
__name__ = "WatamoteStreakPet"
__description__ = "üá∑üá∫ –û–≥–æ–Ω–µ–∫ –∏ –ø–∏—Ç–æ–º–µ—Ü –¥–ª—è –≤–∞—à–∏—Ö –õ–°: –ø–∏—à–∏—Ç–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å, –∫–æ—Ä–º–∏—Ç–µ, –∏–≥—Ä–∞–π—Ç–µ –∏ —Ä–∞—Å—Ç–∏—Ç–µ –≤–º–µ—Å—Ç–µ\nüá¨üáß Streak and pet for your PM: message daily, feed, play and grow together"
__author__ = "@nokirby || @TomokoPlugins"
__version__ = "1.0"
__icon__ = "cyber_milshoo_02_vk_by_TgEmojiBot/6"
__min_version__ = "11.12.0"


DEFAULTS = {
    "show_widget": True,
    "widget_position": 3,
    "widget_size": 2,
    "widget_alpha": 4,
    "widget_mode": 0,

    "show_notifications": True,
    "streak_sync_mode": 1,
    "p2p_switch_offer": True,
    "auto_sync_interval": 1,
    "background_sync": True,
    "debug_mode": False,
    "show_last_sync_status": True,
}

class S:
    CLOSE = "–ó–∞–∫—Ä—ã—Ç—å"
    CANCEL = "–û—Ç–º–µ–Ω–∞"
    OK = "OK"
    SAVE = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å"

    FEED = "üçñ –ö–æ—Ä–º–∏—Ç—å"
    FEED_SHORT = "üçñ –ü–æ–∫–æ—Ä–º–∏—Ç—å"
    PLAY = "üéÆ –ò–≥—Ä–∞—Ç—å"
    RENAME = "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å"
    KICK = "–í—ã–≥–Ω–∞—Ç—å"
    START_PET = "–ó–∞–≤–µ—Å—Ç–∏"
    ACTIVATE = "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å"

    ENABLE_STREAK = "–í–∫–ª—é—á–∏—Ç—å —Å—Ç—Ä–∏–∫"
    DISABLE_STREAK = "–í—ã–∫–ª—é—á–∏—Ç—å"
    RESTORE = "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å"

    XP = "‚≠ê –û–ø—ã—Ç"
    MOOD = "‚ù§Ô∏è –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ"
    DAYS = "–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥"
    NEXT_STAGE = "üìà –î–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç–∞–¥–∏–∏"
    MAX_LEVEL = "üéâ –£—Ä–æ–≤–µ–Ω—å"

SAVE_DEBOUNCE_SECONDS = 2
P2P_THROTTLE_SECONDS = 60
P2P_SWITCH_OFFER_COOLDOWN_SECONDS = 6 * 3600
HTTP_TIMEOUT_FIRST = 2
HTTP_TIMEOUT_RETRY = 3
HTTP_MAX_PARALLEL_REQUESTS = 3
SEC_STORE_PREFIX = "wspsec1:"
SEC_STORE_PREFIX_KS = "wspsec2:"

class V:
    MIN_TS = 1600000000
    MAX_TS = 2000000000

    @staticmethod
    def is_dict(v):
        return isinstance(v, dict)

    @staticmethod
    def is_list(v):
        return isinstance(v, list)

    @staticmethod
    def int_range(v, min_v=0, max_v=999999, default=0):
        if not isinstance(v, (int, float)):
            return default
        v = int(v)
        return max(min_v, min(v, max_v))

    @staticmethod
    def float_range(v, min_v=0.0, max_v=999999.0, default=0.0):
        if not isinstance(v, (int, float)):
            return default
        v = float(v)
        return max(min_v, min(v, max_v))

    @staticmethod
    def ts(v, default=None):
        if default is None:
            default = time.time()
        if not isinstance(v, (int, float)):
            return default
        if v < V.MIN_TS or v > V.MAX_TS:
            return default
        return float(v)

    @staticmethod
    def str_or(v, default=""):
        return v if isinstance(v, str) else default

    @staticmethod
    def bool_or(v, default=False):
        return v if isinstance(v, bool) else default

    @staticmethod
    def toFloat(v, default=0.0):
        if v is None:
            return default
        try:
            return float(v)
        except Exception:
            return default

    @staticmethod
    def toInt(v, default=0):
        if v is None:
            return default
        try:
            return int(v)
        except Exception:
            return default

    @staticmethod
    def ts_or_none(v):
        if v is None:
            return None
        if not isinstance(v, (int, float)):
            return None
        if v < V.MIN_TS or v > V.MAX_TS:
            return None
        return float(v)

    @staticmethod
    def month_key(v, default=None):
        if v == 0 or v == "0":
            return None
        if isinstance(v, int):
            if v < 200001 or v > 299912:
                return default
            return v
        if not isinstance(v, str):
            return default
        if len(v) != 7 or v[4] != "-":
            return default
        year, month = v[:4], v[5:]
        if not (year.isdigit() and month.isdigit()):
            return default
        month_i = int(month)
        if month_i < 1 or month_i > 12:
            return default
        return int(f"{year}{month}")

    @staticmethod
    def pet_data(data):
        if not V.is_dict(data):
            return None
        if "chat" not in data:
            return None
        return {
            "chat": str(data["chat"]),
            "xp": V.int_range(data.get("xp"), 0, MAX_PET_XP),
            "stage": V.int_range(data.get("stage"), 0, len(PET_STAGES) - 1),
            "level": V.int_range(data.get("level"), 1, MAX_PET_LEVEL, 1),
            "name": V.str_or(data.get("name"), defaultPetName())[:MAX_PET_NAME_LENGTH],
            "mood": V.int_range(data.get("mood"), 0, 100, 100),
            "hunger": V.int_range(data.get("hunger"), 0, 100, 100),
            "coins": V.int_range(data.get("coins"), 0, MAX_PET_COINS, 0),
            "hunger_block_until": V.ts(data.get("hunger_block_until"), 0),
            "hunger_zero_since": V.ts(data.get("hunger_zero_since"), 0),
            "xp_boost_until": V.ts(data.get("xp_boost_until"), 0),
            "xp_boost_mult": V.float_range(data.get("xp_boost_mult"), 1.0, 1.5, 1.0),
            "accessory": V.int_range(data.get("accessory"), 0, MAX_PET_ACCESSORY, 0),
            "last_feed": V.ts(data.get("last_feed")),
            "last_update": V.ts(data.get("last_update")),
            "last_sync": V.ts(data.get("last_sync"), 0),
            "deleted": V.bool_or(data.get("deleted"))
        }

    @staticmethod
    def streak_data(data):
        if not V.is_dict(data):
            return None
        if "chat" not in data:
            return None
        return {
            "chat": str(data["chat"]),
            "count": V.int_range(data.get("count"), 0, MAX_STREAK_COUNT),
            "last_date": V.str_or(data.get("last_date")),
            "first_date": V.str_or(data.get("first_date")),
            "timestamp": V.ts(data.get("timestamp"), 0),
            "last_message_time": V.ts(data.get("last_message_time")),
            "deleted": V.bool_or(data.get("deleted")),
            "warning_since": V.ts_or_none(data.get("warning_since")),
            "dead_since": V.ts_or_none(data.get("dead_since")),
            "dead_count": V.int_range(data.get("dead_count"), 0, 9999),
            "restores_this_month": V.int_range(
                data.get("restores_this_month"), 0, STREAK_MAX_RESTORES_PER_MONTH
            ),
            "last_restore_month": V.month_key(data.get("last_restore_month"))
        }

class Dp:
    S1 = 1
    S2 = 2
    S3 = 3
    S4 = 4
    S6 = 6
    S8 = 8
    S10 = 10
    S12 = 12
    S14 = 14
    S16 = 16
    S20 = 20
    S24 = 24
    S28 = 28
    S32 = 32
    S40 = 40
    S48 = 48
    S56 = 56
    S80 = 80
    S100 = 100
    S120 = 120
    S160 = 160

    PAD_XS = 4
    PAD_SM = 8
    PAD_MD = 12
    PAD_LG = 16
    PAD_XL = 24
    PAD_XXL = 48

    MARGIN_SM = 8
    MARGIN_MD = 12
    MARGIN_LG = 16

    CORNER_XS = 4
    CORNER_SM = 8
    CORNER_MD = 12
    CORNER_LG = 16
    CORNER_XL = 28
    CORNER_SHEET = 28

    WIDGET_SM = 40
    WIDGET_MD = 80
    WIDGET_LG = 160

    HANDLE_W = 32
    HANDLE_H = 4

    STROKE = 2

    BAR_H = 8

    BTN_H = 48


langCache = {"code": None, "ts": 0}

def getLang():
    try:
        if langCache["code"] and time.time() - langCache["ts"] < 5:
            return langCache["code"]
        LocaleController = find_class("org.telegram.messenger.LocaleController")
        if LocaleController:
            inst = LocaleController.getInstance()
            try:
                locale = inst.getCurrentLocale()
                if locale:
                    code = locale.getLanguage()
                    if code:
                        langCache["code"] = str(code).lower()
                        langCache["ts"] = time.time()
                        return langCache["code"]
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                pass
            try:
                info = inst.getCurrentLocaleInfo()
                if info:
                    code = getattr(info, "shortName", None) or getattr(info, "baseLangCode", None)
                    if code:
                        langCache["code"] = str(code).lower()
                        langCache["ts"] = time.time()
                        return langCache["code"]
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                pass
        from java.util import Locale
        code = Locale.getDefault().getLanguage()
        langCache["code"] = str(code).lower() if code else "ru"
        langCache["ts"] = time.time()
        return langCache["code"]
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        return "ru"

def isEn():
    return getLang().startswith("en")

strings = {
    "ru": {
        "close": "–ó–∞–∫—Ä—ã—Ç—å",
        "cancel": "–û—Ç–º–µ–Ω–∞",
        "save": "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
        "feed": "üçñ –ü–æ–∫–æ—Ä–º–∏—Ç—å",
        "feed_short": "üçñ –ö–æ—Ä–º–∏—Ç—å",
        "play": "üéÆ –ü–æ–∏–≥—Ä–∞—Ç—å",
        "rename": "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å",
        "delete": "–£–¥–∞–ª–∏—Ç—å",
        "create": "–°–æ–∑–¥–∞—Ç—å",
        "turn_on": "–ó–∞–≤–µ—Å—Ç–∏ –ø–∏—Ç–æ–º—Ü–∞",
        "pet_open_menu": "–û—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é",
        "pet_no_pet_title": "–ü–∏—Ç–æ–º—Ü–∞ –µ—â–µ –Ω–µ—Ç",
        "pet_no_pet_desc": "–ó–∞–≤–µ–¥–∏ –ø–∏—Ç–æ–º—Ü–∞ –∏ –ø–æ–ª—É—á–∞–π XP –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏—è",
        "info_active_buffs": "–ß—Ç–æ —Å–µ–π—á–∞—Å –ø–æ–º–æ–≥–∞–µ—Ç –ø–∏—Ç–æ–º—Ü—É",
        "info_no_pet_buffs": "–ü–æ–∫–∞ –ø–∏—Ç–æ–º—Ü–∞ –Ω–µ—Ç, –±–æ–Ω—É—Å–æ–≤ —Ç–æ–∂–µ –Ω–µ—Ç.",
        "info_no_buffs_yet": "–ü–æ–∫–∞ –ø—É—Å—Ç–æ. –ë–æ–Ω—É—Å—ã –ø–æ—è–≤—è—Ç—Å—è –ø–æ—Å–ª–µ –∫–æ—Ä–º–ª–µ–Ω–∏—è, –∏–≥—Ä—ã –∏–ª–∏ –±—É—Å—Ç–∞.",
        "info_buff_skin": "–û—Ç —Å–∫–∏–Ω–∞: {name}",
        "info_buff_xp_boost": "–ë—É—Å—Ç –æ–ø—ã—Ç–∞: +{percent}% (–µ—â—ë ~{remaining} –º–∏–Ω)",
        "info_buff_hunger_block": "–ì–æ–ª–æ–¥ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ –ø–∞–¥–∞–µ—Ç (~{remaining} –º–∏–Ω)",
        "info_buff_accessory": "–ê–∫—Å–µ—Å—Å—É–∞—Ä: {name}",
        "info_earn_coins": "–ì–¥–µ –±—Ä–∞—Ç—å –º–æ–Ω–µ—Ç–∫–∏",
        "info_coin_feed": "–ö–æ—Ä–º–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞: +{amount} ü™ô",
        "info_coin_play": "–ò–≥—Ä–∞—Ç—å —Å –ø–∏—Ç–æ–º—Ü–µ–º: +{amount} ü™ô",
        "info_coin_evolve": "–ó–∞ —ç–≤–æ–ª—é—Ü–∏—é: +{amount} ü™ô",
        "info_skins_effects": "–ß—Ç–æ –¥–∞—é—Ç —Å–∫–∏–Ω—ã",
        "info_skin_no_bonus": "{name}: –±–µ–∑ –±–æ–Ω—É—Å–∞",
        "info_no_perks_yet": "–ü–æ–∫–∞ –±–µ–∑ –±–æ–Ω—É—Å–æ–≤",
        "info_shop": "–ß—Ç–æ –µ—Å—Ç—å –≤ –º–∞–≥–∞–∑–∏–Ω–µ",
        "info_shop_super_food": "–°—É–ø—á–∏–∫: {cost} ü™ô - –º–Ω–æ–≥–æ —Å—ã—Ç–æ—Å—Ç–∏ –∏ –∑–∞—â–∏—Ç–∞ –æ—Ç –≥–æ–ª–æ–¥–∞ –Ω–∞ –≤—Ä–µ–º—è",
        "info_shop_xp_boost": "–ë—É—Å—Ç XP: {min_cost}-{max_cost} ü™ô - –æ–ø—ã—Ç –∏–¥—ë—Ç –±—ã—Å—Ç—Ä–µ–µ",
        "info_shop_skins": "–°–∫–∏–Ω—ã: –æ—Ç {cost} ü™ô",
        "info_shop_accessories": "–ê–∫—Å–µ—Å—Å—É–∞—Ä—ã: –æ—Ç {cost} ü™ô",
        "info_shop_revive": "–í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ: {cost} ü™ô",
        "info_streak_rewards": "–ë–æ–Ω—É—Å—ã –∑–∞ —Å–µ—Ä–∏—é –¥–Ω–µ–π",
        "info_streak_reward_line": "{days}: +{xp} XP",
        "settings_appearance": "–ö–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç",
        "settings_show_widget": "–ü–∏—Ç–æ–º–µ—Ü –ø–æ–≤–µ—Ä—Ö —á–∞—Ç–∞",
        "settings_show_widget_sub": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–∏—Ç–æ–º—Ü–∞ –ø–æ–≤–µ—Ä—Ö —á–∞—Ç–∞",
        "settings_widget_size": "–†–∞–∑–º–µ—Ä –≤–∏–¥–∂–µ—Ç–∞",
        "settings_widget_mode": "–°—Ç–∏–ª—å –≤–∏–¥–∂–µ—Ç–∞",
        "settings_widget_mode_compact": "–ö–æ–º–ø–∞–∫—Ç–Ω–æ",
        "settings_widget_mode_expanded": "–ü–æ–¥—Ä–æ–±–Ω–æ",
        "settings_widget_opacity": "–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –≤–∏–¥–∂–µ—Ç–∞",
        "settings_gameplay": "–ò–≥—Ä–æ–≤—ã–µ —à—Ç—É–∫–∏",
        "settings_pet_style": "–°—Ç–∏–ª—å –ø–∏—Ç–æ–º—Ü–∞",
        "settings_evolution_notifications": "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —ç–≤–æ–ª—é—Ü–∏–∏",
        "settings_evolution_notifications_sub": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É, –∫–æ–≥–¥–∞ –ø–∏—Ç–æ–º–µ—Ü —ç–≤–æ–ª—é—Ü–∏–æ–Ω–∏—Ä—É–µ—Ç",
        "settings_sync": "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "settings_sync_mode": "–†–µ–∂–∏–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_p2p_offer": "–ü—Ä–µ–¥–ª–∞–≥–∞—Ç—å P2P –ø—Ä–∏ –≤—Ö–æ–¥—è—â–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_p2p_offer_sub": "–°–ø—Ä–∞—à–∏–≤–∞—Ç—å, –µ—Å–ª–∏ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ —à–ª–µ—Ç P2P",
        "settings_sync_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞",
        "settings_sync_status": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å—Ç–∞—Ç—É—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_sync_status_sub": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ –º–µ–Ω—é WSP",
        "settings_bg_sync": "–§–æ–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "settings_bg_sync_sub": "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤ —Ñ–æ–Ω–µ, –¥–∞–∂–µ –∫–æ–≥–¥–∞ —á–∞—Ç –∑–∞–∫—Ä—ã—Ç",
        "settings_debug": "–û—Ç–ª–∞–¥–∫–∞ –∏ –ª–æ–≥–∏",
        "settings_debug_mode": "–í–∫–ª—é—á–∏—Ç—å –ª–æ–≥–∏",
        "settings_debug_mode_sub": "–ü–∏—à–µ—Ç –ø–æ–¥—Ä–æ–±–Ω—ã–µ –ª–æ–≥–∏ –≤ –∫–æ–Ω—Å–æ–ª—å",
        "settings_check_server": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ—Ä–≤–µ—Ä",
        "settingsclearCache": "–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à",
        "settings_danger_zone": "–û–ø–∞—Å–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è",
        "settings_reset_data": "–°—Ç–µ—Ä–µ—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–ª–∞–≥–∏–Ω–∞",
        "settings_reset_auth": "–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é",
        "settingsResetP2p": "–°–±—Ä–æ—Å–∏—Ç—å P2P –∫–ª—é—á–∏",
        "p2pResetConfirm": "–£–¥–∞–ª–∏—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ P2P –∫–ª—é—á–∏? –û–Ω–∏ –±—É–¥—É—Ç —Å–æ–∑–¥–∞–Ω—ã –∑–∞–Ω–æ–≤–æ –ø—Ä–∏ —Å–ª–µ–¥—É—é—â–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.",
        "p2pResetDone": "P2P –∫–ª—é—á–∏ —Å–±—Ä–æ—à–µ–Ω—ã",
    },
    "en": {
        "close": "Close",
        "cancel": "Cancel",
        "save": "Save",
        "feed": "üçñ Feed",
        "feed_short": "üçñ Feed",
        "play": "üéÆ Play",
        "rename": "Rename",
        "delete": "Delete",
        "create": "Create",
        "turn_on": "Get a pet",
        "pet_open_menu": "Open menu",
        "pet_no_pet_title": "No pet yet",
        "pet_no_pet_desc": "Get a pet and earn XP from messages",
        "info_active_buffs": "What helps your pet right now",
        "info_no_pet_buffs": "No pet yet, so no active buffs.",
        "info_no_buffs_yet": "Nothing active yet. Buffs appear after feeding, playing, or boosts.",
        "info_buff_skin": "From skin: {name}",
        "info_buff_xp_boost": "XP boost: +{percent}% (~{remaining} min left)",
        "info_buff_hunger_block": "Hunger is paused for ~{remaining} min",
        "info_buff_accessory": "Accessory: {name}",
        "info_earn_coins": "How to earn coins",
        "info_coin_feed": "Feed your pet: +{amount} ü™ô",
        "info_coin_play": "Play with your pet: +{amount} ü™ô",
        "info_coin_evolve": "Evolution: +{amount} ü™ô",
        "info_skins_effects": "What skins give",
        "info_skin_no_bonus": "{name}: no bonus",
        "info_no_perks_yet": "No bonuses yet",
        "info_shop": "What's in the shop",
        "info_shop_super_food": "Super food: {cost} ü™ô - big satiety boost + temporary hunger shield",
        "info_shop_xp_boost": "XP boost: {min_cost}-{max_cost} ü™ô - faster XP gain",
        "info_shop_skins": "Skins: from {cost} ü™ô",
        "info_shop_accessories": "Accessories: from {cost} ü™ô",
        "info_shop_revive": "Revive: {cost} ü™ô",
        "info_streak_rewards": "Streak bonuses",
        "info_streak_reward_line": "{days}: +{xp} XP",
        "settings_appearance": "Look & feel",
        "settings_show_widget": "Pet on screen",
        "settings_show_widget_sub": "Show the pet over the chat",
        "settings_widget_size": "Widget size",
        "settings_widget_mode": "Widget style",
        "settings_widget_mode_compact": "Compact",
        "settings_widget_mode_expanded": "Detailed",
        "settings_widget_opacity": "Widget opacity",
        "settings_gameplay": "Gameplay tweaks",
        "settings_pet_style": "Pet style",
        "settings_evolution_notifications": "Evolution alerts",
        "settings_evolution_notifications_sub": "Show a card when the pet evolves",
        "settings_sync": "Sync",
        "settings_sync_mode": "Sync mode",
        "settings_p2p_offer": "Suggest P2P when sync arrives",
        "settings_p2p_offer_sub": "Ask if the other person uses P2P",
        "settings_sync_interval": "Check interval",
        "settings_sync_status": "Show sync status",
        "settings_sync_status_sub": "Show last sync time in WSP menu",
        "settings_bg_sync": "Background sync",
        "settings_bg_sync_sub": "Sync in background even when chat is closed",
        "settings_debug": "Debug & logs",
        "settings_debug_mode": "Enable logs",
        "settings_debug_mode_sub": "Write detailed logs to console",
        "settings_check_server": "Check server",
        "settingsclearCache": "Clear cache",
        "settings_danger_zone": "Risky actions",
        "settings_reset_data": "Wipe plugin data",
        "settings_reset_auth": "Reset auth",
        "settingsResetP2p": "Reset P2P keys",
        "p2pResetConfirm": "Remove local P2P keys? They will be recreated on next sync.",
        "p2pResetDone": "P2P keys reset",
    },
}

def tr(key, en=None, **kwargs):
    if en is not None:
        text = en if isEn() else key
        if kwargs:
            try:
                return text.format(**kwargs)
            except (KeyError, ValueError, IndexError, TypeError):
                return text
        return text

    lang = "en" if isEn() else "ru"
    text = strings.get(lang, {}).get(key)
    if text is None:
        text = strings.get("en", {}).get(key, key)
    if kwargs:
        try:
            return text.format(**kwargs)
        except (KeyError, ValueError, IndexError, TypeError):
            return text
    return text

def ruPlural(n, one, few, many):
    try:
        n = abs(int(n))
    except (TypeError, ValueError, OverflowError):
        return many
    if n % 10 == 1 and n % 100 != 11:
        return one
    if 2 <= n % 10 <= 4 and not 12 <= n % 100 <= 14:
        return few
    return many

def formatDaysRu(n):
    return f"{n} {ruPlural(n, '–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π')}"

def formatDaysEn(n):
    try:
        n_int = int(n)
    except (TypeError, ValueError, OverflowError):
        n_int = n
    word = "day" if n_int == 1 else "days"
    return f"{n} {word}"

def daysInRowRu(n):
    return ruPlural(n, "–¥–µ–Ω—å –ø–æ–¥—Ä—è–¥", "–¥–Ω—è –ø–æ–¥—Ä—è–¥", "–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥")

def daysInRowEn(n):
    try:
        n_int = int(n)
    except (TypeError, ValueError, OverflowError):
        n_int = n
    return "day in a row" if n_int == 1 else "days in a row"

def formatDaysInRow(n):
    return daysInRowEn(n) if isEn() else daysInRowRu(n)

def defaultPetName():
    return tr("–ß–µ–±—É—Ä–∞—à–∫–∞", "Cheburashka")

bulletin_last = {}
bulletinOps = 0
BULLETIN_KEY_TTL_SECONDS = 180
BULLETIN_KEY_MAX_SIZE = 256

def trimBulletinLast(nowTs=None):
    global bulletin_last
    try:
        nowTs = float(nowTs if nowTs is not None else time.time())
        if bulletin_last:
            for key, ts in list(bulletin_last.items()):
                if nowTs - float(ts or 0) > BULLETIN_KEY_TTL_SECONDS:
                    bulletin_last.pop(key, None)
        if len(bulletin_last) > BULLETIN_KEY_MAX_SIZE:
            items = sorted(bulletin_last.items(), key=lambda kv: float(kv[1] or 0))
            for key, _ in items[: len(bulletin_last) - BULLETIN_KEY_MAX_SIZE]:
                bulletin_last.pop(key, None)
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        pass

def bulletin_safe(kind, message, ui_thread=False):
    global bulletinOps
    try:
        now = time.time()
        bulletinOps += 1
        if bulletinOps % 48 == 0 or len(bulletin_last) > BULLETIN_KEY_MAX_SIZE:
            trimBulletinLast(now)
        key = f"{kind}:{message}"
        last = bulletin_last.get(key, 0)
        if now - last < 0.8:
            return
        bulletin_last[key] = now
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        pass
    def do_show():
        try:
            fn = getattr(BulletinHelper, f"show_{kind}", None)
            if fn:
                fn(message)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            log(f"WSP: bulletin show error: {e}")
    run_on_ui_thread(do_show)


S.CLOSE = tr("close")
S.CANCEL = tr("cancel")
S.OK = "OK"
S.SAVE = tr("save")
S.FEED = tr("feed")
S.FEED_SHORT = tr("feed_short")
S.PLAY = tr("play")
S.RENAME = tr("rename")
S.KICK = tr("delete")
S.START_PET = tr("create")
S.ACTIVATE = tr("turn_on")
S.ENABLE_STREAK = tr("–í–∫–ª—é—á–∏—Ç—å —Å—Ç—Ä–∏–∫", "Enable streak")
S.DISABLE_STREAK = tr("–í—ã–∫–ª—é—á–∏—Ç—å", "Disable")
S.RESTORE = tr("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Restore")
S.XP = tr("‚≠ê –û–ø—ã—Ç", "‚≠ê XP")
S.MOOD = tr("‚ù§Ô∏è –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "‚ù§Ô∏è Mood")
S.DAYS = tr("–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥", "days in a row")
S.NEXT_STAGE = tr("üìà –î–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç–∞–¥–∏–∏", "üìà To next stage")
S.MAX_LEVEL = tr("üéâ –£—Ä–æ–≤–µ–Ω—å", "üéâ Level")

from ui.settings import Divider, Header, Input, Selector, Switch, Text


def OnTouchListener(callback):
    from java import dynamic_proxy

    class TouchListenerProxy(dynamic_proxy(View.OnTouchListener)):
        def __init__(self):
            super().__init__()

        def onTouch(self, v, event):
            try:
                return callback(v, event)
            except Exception as e:
                log(f"OnTouchListener error: {e}")
                return False

    return TouchListenerProxy()


def clamp(v, a, b):
    return a if v < a else b if v > b else v


def jint32(v):
    v = int(v) & 0xFFFFFFFF
    if v >= 0x80000000:
        v -= 0x100000000
    return int(v)


ZW_MAP = {"00": "\u200b", "01": "\u200c", "10": "\u200d", "11": "\ufeff"}
ZW_REV = {v: k for k, v in ZW_MAP.items()}
SYNC_PREFIX = "\u2060"
SYNC_PREFIXES = (SYNC_PREFIX, "\u00ad")


def packZws(data):
    return "".join(ZW_MAP[f"{b:08b}"[i : i + 2]] for b in data for i in (0, 2, 4, 6))


def unpackZws(text):
    if not (bits := "".join(ZW_REV.get(c, "") for c in text)):
        return None
    if len(bits) % 8 != 0:
        bits = bits[2:] if len(bits) > 2 and (len(bits) - 2) % 8 == 0 else bits
    return (
        bytes(int(bits[i : i + 8], 2) for i in range(0, len(bits), 8))
        if len(bits) % 8 == 0
        else None
    )


def looksSyncMsg(text):
    if not isinstance(text, str):
        return False
    if not text or text[0] not in SYNC_PREFIXES:
        return False
    has_zw = False
    for ch in text:
        if ch in ZW_REV:
            has_zw = True
            continue
        if ch in SYNC_PREFIXES:
            continue
        return False
    return has_zw


class BaseWidget:
    def __init__(self, context, plugin_ref, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None
        self.chat_id = chat_id
        self.container = None
        self.is_dragging = False
        self.start_x = 0
        self.start_y = 0
        self.drag_threshold = AndroidUtilities.dp(DRAG_THRESHOLD_PX)

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def runUi(self, func, delayMs=0):
        try:
            p = self.plugin_ref
            if p and hasattr(p, "shutdown_event") and p.shutdown_event.is_set():
                return False
            return bool(run_on_ui_thread(func, delayMs))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return False

    def runUiOnce(self, key, delayMs, func):
        p = self.plugin_ref
        if p and hasattr(p, "runUiOnce"):
            chatPart = self.chat_id if self.chat_id is not None else "na"
            fullKey = f"w:{chatPart}:{key}"
            return p.runUiOnce(fullKey, delayMs, func)
        return self.runUi(func, delayMs)

    def setupTouchBase(self, view):
        widget_ref = self

        def onTouch(v, event):
            try:
                action = event.getAction()

                if action == MotionEvent.ACTION_DOWN:
                    widget_ref.start_x = event.getRawX()
                    widget_ref.start_y = event.getRawY()
                    widget_ref.is_dragging = False
                    widget_ref.onTouchDown(v, event)
                    return True

                elif action == MotionEvent.ACTION_MOVE:
                    dx = event.getRawX() - widget_ref.start_x
                    dy = event.getRawY() - widget_ref.start_y
                    distance = math.sqrt(dx * dx + dy * dy)

                    if distance > widget_ref.drag_threshold:
                        widget_ref.is_dragging = True
                        widget_ref.onDrag(v, event, dx, dy)
                    return True

                elif action == MotionEvent.ACTION_UP:
                    if not widget_ref.is_dragging:
                        widget_ref.onClick(v, event)
                    widget_ref.onTouchUp(v, event)
                    return True

                return False
            except Exception as e:
                widget_ref.log(f"WSP: onTouch error: {e}")
                return False

        listener = OnTouchListener(onTouch)
        view.setOnTouchListener(listener)

    def onTouchDown(self, view, event):
        pass

    def onDrag(self, view, event, dx, dy):
        pass

    def onClick(self, view, event):
        pass

    def onTouchUp(self, view, event):
        pass

    def get_view(self):
        raise NotImplementedError

    def cleanup(self):
        pass


PET_STAGES = {
    0: {"emoji": "ü•ö", "name": "–Ø–π—Ü–æ", "xp": 0},
    1: {"emoji": "üê£", "name": "–ü—Ç–µ–Ω–µ—Ü", "xp": 250},
    2: {"emoji": "üê•", "name": "–¶—ã–ø–∞", "xp": 1500},
    3: {"emoji": "üêì", "name": "–ü–µ—Ç—É—Ö", "xp": 6000},
    4: {"emoji": "ü¶Ö", "name": "–û—Ä—ë–ª", "xp": 25000},
}

PET_STAGES_BY_STYLE = {
    0: PET_STAGES,
    1: {
        0: {"emoji": "ü•ö", "name": "–Ø–π—Ü–æ", "xp": 0},
        1: {"emoji": "üëæ", "name": "–°–ª–∏–∑–µ–Ω—å", "xp": 250},
        2: {"emoji": "üëπ", "name": "–ì–æ–±–ª–∏–Ω", "xp": 1500},
        3: {"emoji": "üë∫", "name": "–î–µ–º–æ–Ω", "xp": 6000},
        4: {"emoji": "üêâ", "name": "–î—Ä–∞–∫–æ–Ω", "xp": 25000},
    },
    2: {
        0: {"emoji": "üå±", "name": "–†–æ—Å—Ç–æ–∫", "xp": 0},
        1: {"emoji": "üåø", "name": "–ü–æ–±–µ–≥", "xp": 250},
        2: {"emoji": "üçÄ", "name": "–ö–ª–µ–≤–µ—Ä", "xp": 1500},
        3: {"emoji": "üå≥", "name": "–î–µ—Ä–µ–≤–æ", "xp": 6000},
        4: {"emoji": "üå∫", "name": "–°–∞–∫—É—Ä–∞", "xp": 25000},
    },
    3: {
        0: {"emoji": "‚≠ê", "name": "–ó–≤–µ–∑–¥–∞", "xp": 0},
        1: {"emoji": "üåü", "name": "–ò—Å–∫—Ä–∞", "xp": 250},
        2: {"emoji": "‚ú®", "name": "–ë–ª–µ—Å–∫", "xp": 1500},
        3: {"emoji": "üí´", "name": "–ö–æ–º–µ—Ç–∞", "xp": 6000},
        4: {"emoji": "üåå", "name": "–ì–∞–ª–∞–∫—Ç–∏–∫–∞", "xp": 25000},
    },
    4: {
        0: {"emoji": "‚öôÔ∏è", "name": "–î–µ—Ç–∞–ª—å", "xp": 0},
        1: {"emoji": "üî©", "name": "–ë–æ–ª—Ç", "xp": 100},
        2: {"emoji": "ü§ñ", "name": "–†–æ–±–æ—Ç", "xp": 500},
        3: {"emoji": "üöÄ", "name": "–†–∞–∫–µ—Ç–∞", "xp": 2000},
        4: {"emoji": "üõ∏", "name": "–ù–õ–û", "xp": 10000},
    },
    5: {
        0: {"emoji": "ü•ö", "name": "–ñ–∏—Ä–Ω–æ—Å—Ç—å", "xp": 0},
        1: {"emoji": "ü•ê", "name": "–ñ–∏—Ä–æ–∫", "xp": 250},
        2: {"emoji": "üç©", "name": "–ü–æ–Ω—á–∏–∫", "xp": 1500},
        3: {"emoji": "üçî", "name": "–ë—É—Ä–≥–µ—Ä", "xp": 6000},
        4: {"emoji": "üê∑", "name": "–°–≤–∏–Ω—Ç—É—Å", "xp": 25000},
    },
}
MAX_PET_SKIN_STYLE = max(PET_STAGES_BY_STYLE.keys()) if PET_STAGES_BY_STYLE else 0

SKIN_PERKS = {
    1: {
        "xp": 1.06,
        "playXp": 1.08,
        "label": tr("+6% XP, +8% –∏–≥—Ä–∞", "+6% XP, +8% play"),
    },
    2: {
        "hunger": 0.85,
        "feedRestore": 1.2,
        "label": tr("-15% –≥–æ–ª–æ–¥, +20% —Å—ã—Ç–æ—Å—Ç—å", "-15% hunger, +20% satiety"),
    },
    3: {
        "nightXp": 1.1,
        "rareChance": 0.06,
        "label": tr("+10% XP –Ω–æ—á—å—é (22-6), —à–∞–Ω—Å –¥–∂–µ–∫–ø–æ—Ç–∞", "+10% XP at night (22-6), jackpot chance"),
    },
    4: {
        "mood": 0.8,
        "playCoins": 1,
        "label": tr("-20% —Å–ø–∞–¥ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è, +1 ü™ô –∏–≥—Ä–∞", "-20% mood decay, +1 ü™ô play"),
    },
    5: {
        "hunger": 1.2,
        "feedXp": 1.15,
        "feedCoins": 1,
        "label": tr("–ì–æ–ª–æ–¥ –±—ã—Å—Ç—Ä–µ–µ, +15% –∫–æ—Ä–º, +1 ü™ô", "Faster hunger, +15% feed, +1 ü™ô"),
    },
}

def skinPerk(pet):
    try:
        if not pet:
            return {}
        return SKIN_PERKS.get(pet.getSkinStyle(), {})
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        return {}

def skinPerkText(skinStyle):
    try:
        data = SKIN_PERKS.get(int(skinStyle), None)
        if not data:
            return ""
        return data.get("label", "")
    except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
        return ""

PET_STAGE_NAME_EN = {
    "–Ø–π—Ü–æ": "Egg",
    "–ü—Ç–µ–Ω–µ—Ü": "Chick",
    "–¶—ã–ø–∞": "Baby chick",
    "–ü–µ—Ç—É—Ö": "Rooster",
    "–û—Ä—ë–ª": "Eagle",
    "–°–ª–∏–∑–µ–Ω—å": "Slime",
    "–ì–æ–±–ª–∏–Ω": "Goblin",
    "–î–µ–º–æ–Ω": "Demon",
    "–î—Ä–∞–∫–æ–Ω": "Dragon",
    "–†–æ—Å—Ç–æ–∫": "Sprout",
    "–ü–æ–±–µ–≥": "Shoot",
    "–ö–ª–µ–≤–µ—Ä": "Clover",
    "–î–µ—Ä–µ–≤–æ": "Tree",
    "–°–∞–∫—É—Ä–∞": "Sakura",
    "–ó–≤–µ–∑–¥–∞": "Star",
    "–ò—Å–∫—Ä–∞": "Spark",
    "–ë–ª–µ—Å–∫": "Glow",
    "–ö–æ–º–µ—Ç–∞": "Comet",
    "–ì–∞–ª–∞–∫—Ç–∏–∫–∞": "Galaxy",
    "–î–µ—Ç–∞–ª—å": "Part",
    "–ë–æ–ª—Ç": "Bolt",
    "–†–æ–±–æ—Ç": "Robot",
    "–†–∞–∫–µ—Ç–∞": "Rocket",
    "–ù–õ–û": "UFO",
    "–ë—É–ª–æ—á–∫–∞": "Bun",
    "–ü–æ–Ω—á–∏–∫": "Donut",
    "–ë—É—Ä–≥–µ—Ä": "Burger",
    "–ü–æ—Ä–æ—Å—ë–Ω–æ–∫": "Piglet",
}

FLAME_COLORS = {
    (0, 6): "üî•",
    (7, 13): "üíô",
    (14, 29): "üíö",
    (30, 99): "üíú",
    (100, 999): "‚≠ê",
}
FLAME_EXTINGUISHED = "üïØÔ∏è"

FLAME_STAGES = [
    {"emoji": "üî•", "name": "–ù–æ–≤—ã–π –æ–≥–æ–Ω—å", "days": "0-6", "min": 0, "max": 6},
    {"emoji": "üíô", "name": "–°–∏–Ω–µ–µ –ø–ª–∞–º—è", "days": "7-13", "min": 7, "max": 13},
    {"emoji": "üíö", "name": "–ó–µ–ª—ë–Ω—ã–π –∂–∞—Ä", "days": "14-29", "min": 14, "max": 29},
    {"emoji": "üíú", "name": "–§–∏–æ–ª–µ—Ç–æ–≤—ã–π –æ–≥–æ–Ω—å", "days": "30-99", "min": 30, "max": 99},
    {"emoji": "‚≠ê", "name": "–ó–≤–µ–∑–¥–∞", "days": "100+", "min": 100, "max": 999},
]
FLAME_STAGE_NAME_EN = {
    "–ù–æ–≤—ã–π –æ–≥–æ–Ω—å": "Fresh flame",
    "–°–∏–Ω–µ–µ –ø–ª–∞–º—è": "Blue flame",
    "–ó–µ–ª—ë–Ω—ã–π –∂–∞—Ä": "Green glow",
    "–§–∏–æ–ª–µ—Ç–æ–≤—ã–π –æ–≥–æ–Ω—å": "Purple flame",
    "–ó–≤–µ–∑–¥–∞": "Star",
}

XP_REWARDS = {
    "msg": 8,
    "first_of_day": 60,
    "night": 14,
    "weekend": 24,
    "streak_3_days": 35,
    "streak_7_days": 80,
    "streak_14_days": 160,
    "streak_30_days": 360,
    "feed": 28,
    "play": 22,
}
COIN_REWARDS = {
    "feed": 1,
    "play": 2,
    "evolve": 5,
}
XP_BOOST_OPTIONS = [
    {"mult": 1.1, "hours": 2, "cost": 15},
    {"mult": 1.2, "hours": 1, "cost": 25},
]
ACCESSORY_STYLES = [
    {"id": 1, "name": tr("–ù–µ–æ–Ω", "Neon"), "cost": 20, "color": 0xFF64FFDA},
    {"id": 2, "name": tr("–õ–∞–≤–∞", "Lava"), "cost": 28, "color": 0xFFFF7043},
    {"id": 3, "name": tr("–õ—ë–¥", "Ice"), "cost": 28, "color": 0xFF82B1FF},
]

def getAccessoryStyle(acc_id):
    for item in ACCESSORY_STYLES:
        if item.get("id") == acc_id:
            return item
    return None
MINIGAME_WIN_BONUS_XP = 14
MINIGAME_COMBO_BONUS_XP = 4
MINIGAME_MAX_COMBO_BONUS = 12
MINIGAME_TIME_LIMIT_SECONDS = 20
MINIGAME_RARE_BONUS_CHANCE = 0.08
MINIGAME_RARE_BONUS_XP = 30
MINIGAME_HIT_XP = 6
MINIGAME_CLEAR_BONUS_XP = 24
MINIGAME_HIT_COIN_STEP = 3
MINIGAME_CLEAR_BONUS_COINS = 2

HUNGER_CONFIG = {
    "decrease_per_hour": 5,
    "critical_level": 20,
    "max_hunger": 100,
    "feed_restore": 40,
}

MOOD_CONFIG = {
    "max_mood": 100,
    "min_mood": 0,
    "hunger_penalty_threshold": 30,
    "mood_decrease_per_hour": 2,
}

MAX_PET_XP = 1_000_000
MAX_PET_COINS = 100_000
MAX_PET_ACCESSORY = 3
MAX_PET_NAME_LENGTH = 100
MAX_PET_LEVEL = 10
MAX_STREAK_COUNT = 10_000
PET_DEATH_HOURS = 12

STREAK_UNLOCK_DAYS = 3
STREAK_WARNING_HOURS = 24
STREAK_RESTORE_WINDOW_HOURS = 48
STREAK_MAX_RESTORES_PER_MONTH = 3

TIMESTAMP_TOLERANCE_SECONDS = 300
ONE_DAY_SECONDS = 86400
LOCAL_PRIORITY_SECONDS = 300

MSK_TZ = timezone(timedelta(hours=3))

MAX_DATA_SIZE_BYTES = 1_048_576
P2P_SIG_HEX_LEN = 64
P2P_KEY_RE = re.compile(r"^[0-9a-fA-F]{32}$")

HTTP_SERVER_ERROR_THRESHOLD = 500

WIDGET_SIZES_DP = [60, 70, 80, 90, 100, 110, 120]
WIDGET_DEFAULT_SIZE_DP = 80
ALPHA_VALUES_PERCENT = [30, 50, 70, 90, 100]
DRAG_THRESHOLD_PX = 10

MOOD_HIGH_THRESHOLD = 80
MOOD_MEDIUM_THRESHOLD = 50
MOOD_LOW_THRESHOLD = 30
HUNGER_MEDIUM_THRESHOLD = 50

ELEVATION_CARD = 1
ELEVATION_BUTTON = 3
ELEVATION_DIALOG = 6
ELEVATION_SHEET = 8
ELEVATION_WIDGET = 12

SECONDS_PER_HOUR = 3600
SECONDS_PER_MINUTE = 60
NIGHT_HOURS_START = 0
NIGHT_HOURS_END = 6

XP_COOLDOWN_SECONDS = 20
XP_MAX_PER_HOUR = 240

FEED_COOLDOWN_SECONDS = 3600
FEED_MOOD_BONUS_HIGH = 10
FEED_MOOD_BONUS_LOW = 5
PLAY_MOOD_BONUS = 15
PLAY_HUNGER_COST = 5

REVIVE_COIN_COST = 25
REVIVE_COOLDOWN_SECONDS = 6 * 3600
HUNGER_BLOCK_HOURS = 6
HUNGER_BLOCK_SECONDS = HUNGER_BLOCK_HOURS * 3600
SUPER_FOOD_COST = 12
SKIN_COST_BASE = 8
SKIN_COST_STEP = 6

SERVER_PET_STAGE_EMOJIS = [
    "ü•ö", "üê£", "üê•", "ü¶Ü", "ü¶Ö",
    "ü¶â", "ü¶ö", "üêâ", "üåü", "üëë",
]

MULTIPLIER_MOOD_HIGH = 1.5
MULTIPLIER_MOOD_MEDIUM = 1.0
MULTIPLIER_MOOD_LOW = 0.7
MULTIPLIER_MOOD_CRITICAL = 0.5
MULTIPLIER_HUNGER_LOW = 0.8
MULTIPLIER_HUNGER_CRITICAL = 0.5

SPAM_CHECK_WINDOW_MESSAGES = 5
SPAM_IDENTICAL_THRESHOLD = 3
SPAM_MIN_MESSAGE_LENGTH = 3
SPAM_REPEATED_CHARS_THRESHOLD = 0.7
SPAM_SIMILARITY_THRESHOLD = 0.9

SYNC_INTERVAL_OPTIONS = [30, 60, 120, 300, 999999]
SYNC_INTERVAL_DEFAULT_INDEX = 1
SYNC_MODE_BY_INDEX = {0: "p2p", 1: "server", 2: "auto", 3: "local"}
SYNC_MODE_DEFAULT_INDEX = 1
SYNC_MODE_DEFAULT = "server"
SYNC_MODE_NAMES = {
    "p2p": tr("P2P (–ª–æ–∫–∞–ª—å–Ω–æ)", "P2P (local)"),
    "server": tr("–°–µ—Ä–≤–µ—Ä (–æ–±–ª–∞–∫–æ)", "Server (cloud)"),
    "auto": tr("–ê–≤—Ç–æ (–≥–∏–±—Ä–∏–¥)", "Auto (hybrid)"),
    "local": tr("–õ–æ–∫–∞–ª—å–Ω–æ (–±–µ–∑ —Å–∏–Ω–∫–∞)", "Local (no sync)"),
}
SYNC_INTERVAL_DISABLED = 999999
SYNC_SERVER_CHECK_COOLDOWN = 15
SYNC_BACKOFF_MAX_SECONDS = 60
SYNC_DEFAULT_WAIT_SECONDS = 60
AUTO_SRV_RETRY_BASE_SECONDS = 20
AUTO_SRV_RETRY_MAX_SECONDS = 300
SYNC_GUARD_MAX_SKEW = 7200
SYNC_GUARD_MAX_STREAK_STEP = 1
SYNC_GUARD_STREAK_WINDOW = 72000
SYNC_GUARD_MAX_XP_STEP = 500
SYNC_GUARD_MAX_STAGE_STEP = 1

TMP_STATE_MAX_SIZE = 1200
UI_PENDING_MAX_SIZE = 400
UI_PENDING_TTL_SECONDS = 90
CHAT_ACCOUNT_MAX_SIZE = 1024
P2P_KEY_MAX_SIZE = 1200
WIDGET_POS_MAX_SIZE = 1200
SAVE_KEY_MAX_SIZE = 1200
SAVE_KEY_TTL_SECONDS = 3600


# —Ü–≤–µ—Ç–∞ –∏ —Ç–µ–º–∞
class UI:
    _cache = {}

    @classmethod
    def getClass(cls, name):
        if name not in cls._cache:
            cls._cache[name] = find_class(name)
        return cls._cache[name]


    @staticmethod
    def primary():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader)

    @staticmethod
    def on_primary():
        return Color.WHITE

    @staticmethod
    def primary_container():
        p = UI.primary()
        return Color.argb(int(Color.alpha(p) * 0.12), Color.red(p), Color.green(p), Color.blue(p))

    @staticmethod
    def on_primary_container():
        return UI.primary()

    @staticmethod
    def surface():
        return Theme.getColor(Theme.key_windowBackgroundWhite)

    @staticmethod
    def on_surface():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlackText)

    @staticmethod
    def surface_variant():
        return Theme.getColor(Theme.key_windowBackgroundGray)

    @staticmethod
    def on_surface_variant():
        return Theme.getColor(Theme.key_windowBackgroundWhiteGrayText)

    @staticmethod
    def outline():
        return Theme.getColor(Theme.key_divider)

    @staticmethod
    def secondary():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlueText)

    @staticmethod
    def secondary_container():
        s = UI.secondary()
        return Color.argb(31, Color.red(s), Color.green(s), Color.blue(s))

    @staticmethod
    def tertiary():
        return Theme.getColor(Theme.key_avatar_backgroundViolet)

    @staticmethod
    def error():
        return Theme.getColor(Theme.key_text_RedBold)

    @staticmethod
    def error_container():
        e = UI.error()
        return Color.argb(40, Color.red(e), Color.green(e), Color.blue(e))

    @staticmethod
    def on_error_container():
        return UI.error()

    @staticmethod
    def withAlpha(color, alpha):
        a = max(0, min(255, int(alpha)))
        return Color.argb(a, Color.red(color), Color.green(color), Color.blue(color))


    @staticmethod
    def bg_filled(radius, color):
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(radius))
        bg.setColor(color)
        return bg

    @staticmethod
    def bg_outlined(radius, stroke_color, stroke_width=1):
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(radius))
        bg.setColor(Color.TRANSPARENT)
        bg.setStroke(AndroidUtilities.dp(stroke_width), stroke_color)
        return bg

    @classmethod
    def bg_ripple(cls, radius, bg_color, ripple_color):
        RippleDrawable = cls.getClass("android.graphics.drawable.RippleDrawable")
        if not RippleDrawable:
            return UI.bg_filled(radius, bg_color)
        mask = UI.bg_filled(radius, Color.WHITE)
        bg = UI.bg_filled(radius, bg_color)
        ColorStateList = cls.getClass("android.content.res.ColorStateList")
        return RippleDrawable(ColorStateList.valueOf(ripple_color), bg, mask)

    @staticmethod
    def bg_sheet(color=None):
        bg = GradientDrawable()
        radii = [AndroidUtilities.dp(Dp.S28)] * 4 + [0] * 4
        bg.setCornerRadii([float(r) for r in radii])
        bg.setColor(color if color else UI.surface())
        return bg


    @staticmethod
    def bump(view, peak=1.02, duration=120):
        if not view:
            return
        try:
            base_x = float(view.getScaleX() or 1.0)
            base_y = float(view.getScaleY() or 1.0)
        except Exception:
            base_x = 1.0
            base_y = 1.0
        peak_x = max(base_x, float(peak))
        peak_y = max(base_y, float(peak))
        try:
            anim_x = ObjectAnimator.ofFloat(view, "scaleX", base_x, peak_x, base_x)
            anim_y = ObjectAnimator.ofFloat(view, "scaleY", base_y, peak_y, base_y)
            anim_x.setDuration(int(duration))
            anim_y.setDuration(int(duration))
            anim_x.setInterpolator(AccelerateDecelerateInterpolator())
            anim_y.setInterpolator(AccelerateDecelerateInterpolator())
            anim_x.start()
            anim_y.start()
        except Exception:
            try:
                view.setScaleX(base_x)
                view.setScaleY(base_y)
            except Exception:
                pass

    @staticmethod
    def button(context, text, on_click, style="filled"):
        btn = TextView(context)
        btn.setText(text)
        btn.setTextSize(1, 14)
        btn.setTypeface(None, Typeface.BOLD)
        btn.setGravity(Gravity.CENTER)
        btn.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S10)
        )
        btn.setClickable(True)

        def on_btn_click(*args):
            view = args[0] if args else btn
            UI.bump(view, 1.018, 110)
            on_click(*args)

        btn.setOnClickListener(OnClickListener(on_btn_click))

        if style == "filled":
            btn.setBackground(UI.bg_ripple(Dp.CORNER_XL, UI.primary(), UI.on_primary()))
            btn.setTextColor(UI.on_primary())
        elif style == "tonal":
            btn.setBackground(UI.bg_ripple(Dp.CORNER_XL, UI.secondary_container(), UI.secondary()))
            btn.setTextColor(UI.secondary())
        elif style == "outlined":
            btn.setBackground(UI.bg_outlined(Dp.CORNER_XL, UI.outline()))
            btn.setTextColor(UI.primary())
        elif style == "text":
            btn.setBackgroundColor(Color.TRANSPARENT)
            btn.setTextColor(UI.primary())
            btn.setPadding(
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10)
            )

        return btn

    @staticmethod
    def elevation(view, dp):
        if hasattr(view, "setElevation"):
            view.setElevation(AndroidUtilities.dp(dp))

    @staticmethod
    def info_row(context, label, value, padding=16):
        row = LinearLayout(context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(
            AndroidUtilities.dp(padding),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(padding),
            AndroidUtilities.dp(Dp.S8),
        )

        label_tv = TextView(context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 14)
        label_tv.setTextColor(UI.on_surface_variant())
        label_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        row.addView(label_tv, label_params)

        value_tv = TextView(context)
        value_tv.setText(str(value))
        value_tv.setTextSize(1, 14)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        row.addView(value_tv)

        return row


def get_on_primary_container():
    return UI.on_primary_container()


def get_on_surface_variant():
    return UI.on_surface_variant()


def get_on_error_container():
    return UI.on_error_container()


def attachDialogDismiss(dialog, on_dismiss=None):
    if not dialog:
        return False
    try:
        from java import dynamic_proxy
        from android.content import DialogInterface

        DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)

        class _DismissListener(DismissListener):
            def onDismiss(self, dialog):
                try:
                    if on_dismiss:
                        on_dismiss()
                except Exception:
                    pass

        dialog.setOnDismissListener(_DismissListener())
        return True
    except Exception:
        return False


def safeShowDialog(builder, on_dismiss=None):
    try:
        dialog = builder.show()
    except Exception:
        return None
    if dialog and on_dismiss:
        attachDialogDismiss(dialog, on_dismiss)
    return dialog


class SafeSheet:
    def __init__(self, context, plugin, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin) if plugin else None
        self.chat_id = chat_id
        self.bottom_sheet = None
        self._dismissed = False
        self._dismiss_listener = None
        self.swipeStartX = 0.0
        self.swipeStartY = 0.0
        self.swipeActive = False

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def animateIn(self, view, delayMs=0, shiftDp=8):
        if not view:
            return
        try:
            shift = float(AndroidUtilities.dp(int(shiftDp)))
            view.setAlpha(0.0)
            view.setTranslationY(shift)
            view.setScaleX(0.985)
            view.setScaleY(0.985)
        except Exception:
            return

        def run():
            try:
                alpha = ObjectAnimator.ofFloat(view, "alpha", 0.0, 1.0)
                move = ObjectAnimator.ofFloat(view, "translationY", view.getTranslationY(), 0.0)
                sx = ObjectAnimator.ofFloat(view, "scaleX", view.getScaleX(), 1.0)
                sy = ObjectAnimator.ofFloat(view, "scaleY", view.getScaleY(), 1.0)
                for anim in (alpha, move, sx, sy):
                    anim.setDuration(220)
                    anim.setInterpolator(AccelerateDecelerateInterpolator())
                    anim.start()
            except Exception:
                try:
                    view.setAlpha(1.0)
                    view.setTranslationY(0.0)
                    view.setScaleX(1.0)
                    view.setScaleY(1.0)
                except Exception:
                    pass

        if delayMs and delayMs > 0:
            run_on_ui_thread(run, int(delayMs))
        else:
            run_on_ui_thread(run)

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        try:
            if self.bottom_sheet and self._dismiss_listener:
                self.bottom_sheet.setOnDismissListener(None)
        except Exception:
            pass
        try:
            scroll = getattr(self, "_tab_scroll", None)
            if scroll:
                scroll.setOnTouchListener(None)
        except Exception:
            pass
        try:
            tabButtons = getattr(self, "_tab_buttons", None)
            if isinstance(tabButtons, dict):
                for btn in list(tabButtons.values()):
                    try:
                        btn.setOnClickListener(None)
                    except Exception:
                        pass
                    try:
                        btn.setOnTouchListener(None)
                    except Exception:
                        pass
        except Exception:
            pass
        try:
            if hasattr(self, "_tab_buttons"):
                self._tab_buttons.clear()
            if hasattr(self, "_tab_indicators"):
                self._tab_indicators.clear()
        except Exception as e:
            self.log(f"WSP: tab state cleanup error: {e}")
        for name in (
            "_tab_content",
            "_tab_streak",
            "_tab_pet",
            "_tab_state",
            "_button_container",
            "_tab_scroll",
            "_dismiss_listener",
        ):
            try:
                if hasattr(self, name):
                    setattr(self, name, None)
            except Exception:
                pass
        self._plugin_ref = None
        self.context = None
        self.chat_id = None
        self.bottom_sheet = None

    def _create_tabs_row(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)

        row = LinearLayout(self.context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            0,
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S6),
        )

        self._tab_buttons = {}
        self._tab_indicators = {}
        tabs = [
            ("streak", tr("–°—Ç—Ä–∏–∫", "Streak")),
            ("pet", tr("–ü–∏—Ç–æ–º–µ—Ü", "Pet")),
            ("shop", tr("–ú–∞–≥–∞–∑–∏–Ω", "Shop")),
            ("rewards", tr("–ò–Ω—Ñ–æ", "Info")),
        ]
        self._tabs_order = [tab_id for tab_id, _ in tabs]

        for tab_id, title in tabs:
            btn = self._create_tab_button(title, tab_id)
            params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
            row.addView(btn, params)
            self._tab_buttons[tab_id] = btn

        indicator_row = LinearLayout(self.context)
        indicator_row.setOrientation(LinearLayout.HORIZONTAL)
        indicator_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            0,
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S2),
        )

        for tab_id, _ in tabs:
            indicator = View(self.context)
            indicator_bg = GradientDrawable()
            indicator_bg.setCornerRadius(AndroidUtilities.dp(Dp.S1))
            indicator_bg.setColor(UI.primary())
            indicator.setBackground(indicator_bg)
            indicator.setAlpha(0.0)
            params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S3), 1.0)
            params.setMargins(AndroidUtilities.dp(Dp.S8), 0, AndroidUtilities.dp(Dp.S8), 0)
            indicator_row.addView(indicator, params)
            self._tab_indicators[tab_id] = indicator

        container.addView(row)
        container.addView(indicator_row)
        return container

    def _create_tab_button(self, text, tab_id):
        btn = TextView(self.context)
        btn.setText(text)
        btn.setTextSize(1, 15)
        btn.setTextColor(Color.WHITE)
        btn.setTypeface(None, Typeface.BOLD)
        btn.setGravity(Gravity.CENTER)
        btn.setPadding(
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S10),
        )
        try:
            btn.setBackground(UI.bg_ripple(Dp.S8, Color.TRANSPARENT, UI.withAlpha(UI.primary(), 64)))
        except Exception:
            btn.setBackgroundColor(Color.TRANSPARENT)
        btn.setOnClickListener(
            OnClickListener(lambda *args, t=tab_id: self._switch_tab(t))
        )
        startDist = float(AndroidUtilities.dp(Dp.S8))
        minDist = float(AndroidUtilities.dp(Dp.S24))
        angleRatio = 1.05
        state = {"x": 0.0, "y": 0.0, "active": False}

        def on_touch(v, event):
            try:
                action = event.getAction()
                if action == MotionEvent.ACTION_DOWN:
                    state["x"] = float(event.getRawX())
                    state["y"] = float(event.getRawY())
                    state["active"] = False
                    return True
                if action == MotionEvent.ACTION_MOVE:
                    dx = float(event.getRawX()) - state["x"]
                    dy = float(event.getRawY()) - state["y"]
                    if not state["active"]:
                        if abs(dx) < startDist or abs(dx) <= abs(dy) * angleRatio:
                            return True
                        state["active"] = True
                    self.previewTabSwipe(dx)
                    return True
                if action == MotionEvent.ACTION_UP:
                    if not state["active"]:
                        self._switch_tab(tab_id)
                        return True
                    state["active"] = False
                    dx = float(event.getRawX()) - state["x"]
                    dy = float(event.getRawY()) - state["y"]
                    if abs(dx) >= minDist and abs(dx) > abs(dy) * angleRatio:
                        if dx < 0:
                            return self.switchTabByStep(1)
                        return self.switchTabByStep(-1)
                    self.resetTabSwipe()
                    return True
                if action == MotionEvent.ACTION_CANCEL:
                    if state["active"]:
                        state["active"] = False
                        self.resetTabSwipe()
                        return True
                    return True
                return True
            except Exception as e:
                self.log(f"WSP: tab button swipe error: {e}")
                return False

        btn.setOnTouchListener(OnTouchListener(on_touch))
        return btn

    def _setButtonClick(self, view, callback):
        if not view or not callback:
            return

        def on_click(*args):
            UI.bump(view, 1.018, 110)
            callback(*args)

        view.setOnClickListener(OnClickListener(on_click))

    def _style_tab_button(self, btn, is_selected):
        target_text = Color.WHITE
        try:
            btn.setTypeface(None, Typeface.BOLD)
        except Exception as e:
            self.log(f"WSP: tab button typeface setup error: {e}")
        btn.setTextColor(target_text)

        try:
            btn.setAlpha(1.0)
        except Exception:
            pass

    def switchTabByStep(self, step):
        if not step:
            return False
        tabs = getattr(self, "_tabs_order", None)
        currentTab = getattr(self, "_tab", None)
        if not tabs or currentTab not in tabs:
            return False
        index = tabs.index(currentTab) + step
        if index < 0 or index >= len(tabs):
            return False
        self._switch_tab(tabs[index])
        return True

    def getTabStepTarget(self, step):
        if not step:
            return None
        tabs = getattr(self, "_tabs_order", None)
        currentTab = getattr(self, "_tab", None)
        if not tabs or currentTab not in tabs:
            return None
        index = tabs.index(currentTab) + step
        if index < 0 or index >= len(tabs):
            return None
        return tabs[index]

    def previewTabSwipe(self, dx):
        view = getattr(self, "_tab_content", None)
        if not view:
            return
        try:
            maxShift = float(AndroidUtilities.dp(Dp.S24))
            fullRange = float(AndroidUtilities.dp(Dp.S56))
            shift = clamp(float(dx) * 0.22, -maxShift, maxShift)
            progress = min(1.0, abs(float(dx)) / fullRange) if fullRange > 0 else 0.0
            step = 1 if dx < 0 else -1
            targetTab = self.getTabStepTarget(step)

            view.setTranslationX(shift)
            view.setAlpha(1.0 - 0.16 * progress)
            view.setScaleX(1.0 - 0.01 * progress)
            view.setScaleY(1.0 - 0.01 * progress)

            currentTab = getattr(self, "_tab", None)
            for tabId, indicator in self._tab_indicators.items():
                if tabId == currentTab:
                    indicator.setAlpha(1.0 - 0.55 * progress)
                    indicator.setScaleX(1.0 - 0.4 * progress)
                elif tabId == targetTab:
                    indicator.setAlpha(progress)
                    indicator.setScaleX(0.25 + 0.75 * progress)
                else:
                    indicator.setAlpha(0.0)
                    indicator.setScaleX(0.25)
        except Exception as e:
            self.log(f"WSP: previewTabSwipe error: {e}")

    def resetTabSwipe(self):
        view = getattr(self, "_tab_content", None)
        if not view:
            return
        try:
            alpha = ObjectAnimator.ofFloat(view, "alpha", float(view.getAlpha()), 1.0)
            move = ObjectAnimator.ofFloat(view, "translationX", float(view.getTranslationX()), 0.0)
            sx = ObjectAnimator.ofFloat(view, "scaleX", float(view.getScaleX()), 1.0)
            sy = ObjectAnimator.ofFloat(view, "scaleY", float(view.getScaleY()), 1.0)
            for anim in (alpha, move, sx, sy):
                anim.setDuration(150)
                anim.setInterpolator(AccelerateDecelerateInterpolator())
                anim.start()
        except Exception:
            try:
                view.setAlpha(1.0)
                view.setTranslationX(0.0)
                view.setScaleX(1.0)
                view.setScaleY(1.0)
            except Exception:
                pass

        try:
            currentTab = getattr(self, "_tab", None)
            for tabId, btn in self._tab_buttons.items():
                self._style_tab_button(btn, tabId == currentTab)
            for tabId, indicator in self._tab_indicators.items():
                self._style_tab_indicator(indicator, tabId == currentTab)
        except Exception:
            pass

    def bindTabSwipe(self, view):
        if not view:
            return
        minDist = float(AndroidUtilities.dp(Dp.S24))
        angleRatio = 1.15
        startDist = float(AndroidUtilities.dp(Dp.S8))
        owner = self

        def onTouch(v, event):
            def passTouch():
                try:
                    v.onTouchEvent(event)
                except Exception:
                    pass

            try:
                action = event.getAction()
                if action == MotionEvent.ACTION_DOWN:
                    owner.swipeStartX = float(event.getRawX())
                    owner.swipeStartY = float(event.getRawY())
                    owner.swipeActive = False
                    passTouch()
                    return True
                if action == MotionEvent.ACTION_MOVE:
                    dx = float(event.getRawX()) - owner.swipeStartX
                    dy = float(event.getRawY()) - owner.swipeStartY
                    if not owner.swipeActive:
                        if abs(dx) < startDist:
                            passTouch()
                            return True
                        if abs(dx) <= abs(dy) * angleRatio:
                            passTouch()
                            return True
                        owner.swipeActive = True
                    owner.previewTabSwipe(dx)
                    return True
                if action == MotionEvent.ACTION_UP:
                    dx = float(event.getRawX()) - owner.swipeStartX
                    dy = float(event.getRawY()) - owner.swipeStartY
                    if owner.swipeActive:
                        owner.swipeActive = False
                        if abs(dx) >= minDist and abs(dx) > abs(dy) * angleRatio:
                            if dx < 0:
                                return owner.switchTabByStep(1)
                            return owner.switchTabByStep(-1)
                        owner.resetTabSwipe()
                        return True
                    passTouch()
                    return True
                if action == MotionEvent.ACTION_CANCEL:
                    if owner.swipeActive:
                        owner.swipeActive = False
                        owner.resetTabSwipe()
                        return True
                    passTouch()
                    return True
                passTouch()
                return True
            except Exception as e:
                owner.log(f"WSP: bindTabSwipe error: {e}")
                return False

        view.setOnTouchListener(OnTouchListener(onTouch))

    def _style_tab_indicator(self, indicator, is_selected):
        target_alpha = 1.0 if is_selected else 0.0
        target_scale = 1.0 if is_selected else 0.25
        try:
            current_alpha = indicator.getAlpha()
            current_scale = indicator.getScaleX()
            if abs(current_alpha - target_alpha) < 0.05 and abs(current_scale - target_scale) < 0.05:
                indicator.setAlpha(target_alpha)
                indicator.setScaleX(target_scale)
                return
            anim = ObjectAnimator.ofFloat(indicator, "alpha", current_alpha, target_alpha)
            anim.setDuration(160)
            anim.setInterpolator(AccelerateDecelerateInterpolator())
            anim.start()
            anim_scale = ObjectAnimator.ofFloat(indicator, "scaleX", current_scale, target_scale)
            anim_scale.setDuration(160)
            anim_scale.setInterpolator(AccelerateDecelerateInterpolator())
            anim_scale.start()
        except Exception:
            indicator.setAlpha(target_alpha)
            indicator.setScaleX(target_scale)

    def _switch_tab(self, tab_id):
        if tab_id == self._tab:
            return
        prev_tab = self._tab
        self._tab = tab_id
        try:
            plugin = self.plugin
            if plugin and self.chat_id:
                plugin.setLastMenuTab(self.chat_id, tab_id)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to persist last tab: {e}")
        btn = self._tab_buttons.get(tab_id)
        if btn:
            self._animate_tab_button(btn)
        direction = 0
        if prev_tab in self._tabs_order and tab_id in self._tabs_order:
            prev_index = self._tabs_order.index(prev_tab)
            new_index = self._tabs_order.index(tab_id)
            if new_index > prev_index:
                direction = 1
            elif new_index < prev_index:
                direction = -1
        self._render_tab(direction)

    def _animate_tab_button(self, btn):
        try:
            scale_up_x = ObjectAnimator.ofFloat(btn, "scaleX", 1.0, 1.02, 1.0)
            scale_up_y = ObjectAnimator.ofFloat(btn, "scaleY", 1.0, 1.02, 1.0)
            scale_up_x.setDuration(110)
            scale_up_y.setDuration(110)
            scale_up_x.setInterpolator(AccelerateDecelerateInterpolator())
            scale_up_y.setInterpolator(AccelerateDecelerateInterpolator())
            scale_up_x.start()
            scale_up_y.start()
        except Exception as e:
            self.log(f"WSP: tab button animation error: {e}")

    def _render_tab(self, direction=0):
        if not self._tab_content:
            return
        self._tab_content.removeAllViews()

        for tab_id, btn in self._tab_buttons.items():
            self._style_tab_button(btn, tab_id == self._tab)
        for tab_id, indicator in self._tab_indicators.items():
            self._style_tab_indicator(indicator, tab_id == self._tab)

        button_container = getattr(self, "_button_container", None)
        if button_container:
            button_container.setVisibility(
                View.VISIBLE if self._tab == "streak" else View.GONE
            )

        streak_active, pet_active = self._tab_state

        if self._tab == "pet":
            self._build_pet_tab(self._tab_content, self._tab_pet, pet_active)
        elif self._tab == "rewards":
            self._build_rewards_tab(self._tab_content)
        elif self._tab == "shop":
            self.buildShopTab(self._tab_content, self._tab_pet, pet_active)
        elif streak_active and self._tab_streak:
            if self._tab_streak.is_dead:
                self._build_dead_streak_ui(self._tab_content, self._tab_streak)
            else:
                self._build_active_streak_ui(self._tab_content, self._tab_streak)
        else:
            self._build_inactive_streak_ui(self._tab_content)

        self._animate_tab_content(direction)

    def _animate_tab_content(self, direction=0):
        try:
            view = self._tab_content
            if not view:
                return
            if direction > 0:
                offset = AndroidUtilities.dp(Dp.S14)
            elif direction < 0:
                offset = -AndroidUtilities.dp(Dp.S14)
            else:
                offset = 0
            view.setAlpha(0.0)
            view.setTranslationX(float(offset))
            view.setTranslationY(float(AndroidUtilities.dp(Dp.S6)))
            view.setScaleX(0.99)
            view.setScaleY(0.99)
            alpha_anim = ObjectAnimator.ofFloat(view, "alpha", 0.0, 1.0)
            alpha_anim.setDuration(220)
            alpha_anim.setInterpolator(AccelerateDecelerateInterpolator())
            move_anim = ObjectAnimator.ofFloat(view, "translationX", float(offset), 0.0)
            move_anim.setDuration(220)
            move_anim.setInterpolator(AccelerateDecelerateInterpolator())
            move_y_anim = ObjectAnimator.ofFloat(
                view, "translationY", float(AndroidUtilities.dp(Dp.S6)), 0.0
            )
            move_y_anim.setDuration(220)
            move_y_anim.setInterpolator(AccelerateDecelerateInterpolator())
            scale_x_anim = ObjectAnimator.ofFloat(view, "scaleX", 0.99, 1.0)
            scale_y_anim = ObjectAnimator.ofFloat(view, "scaleY", 0.99, 1.0)
            scale_x_anim.setDuration(220)
            scale_y_anim.setDuration(220)
            scale_x_anim.setInterpolator(AccelerateDecelerateInterpolator())
            scale_y_anim.setInterpolator(AccelerateDecelerateInterpolator())
            alpha_anim.start()
            move_anim.start()
            move_y_anim.start()
            scale_x_anim.start()
            scale_y_anim.start()
        except Exception as e:
            self.log(f"WSP: tab content animation error: {e}")

    def _build_pet_tab(self, container, pet, is_active):
        if not is_active:
            self._build_pet_inactive_ui(container, pet)
            return
        if not pet:
            self._build_pet_inactive_ui(container, pet)
            return

        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji_tv = TextView(self.context)
        emoji_tv.setText(pet.get_emoji())
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        header.addView(emoji_tv)

        name_tv = TextView(self.context)
        name_tv.setText(pet.name)
        name_tv.setTextSize(1, 20)
        name_tv.setTextColor(UI.on_surface())
        name_tv.setTypeface(None, Typeface.BOLD)
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(name_tv, name_params)

        stage_tv = TextView(self.context)
        stage_tv.setText(f"{pet.get_stage_name()}  ‚Ä¢  {tr('–£—Ä.', 'Lv.')} {pet.level}")
        stage_tv.setTextSize(1, 12)
        stage_tv.setTextColor(UI.on_surface_variant())
        stage_tv.setGravity(Gravity.CENTER)
        header.addView(stage_tv)

        container.addView(header)

        pet.update_state()

        stats_row = LinearLayout(self.context)
        stats_row.setOrientation(LinearLayout.HORIZONTAL)
        stats_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        card_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        hunger_card = self._create_simple_stat_card(
            "üçñ",
            f"{int(pet.hunger)}%",
            tr("–°—ã—Ç–æ—Å—Ç—å", "Hunger"),
        )
        stats_row.addView(hunger_card, card_params)

        mood_card = self._create_simple_stat_card(
            "‚ù§Ô∏è",
            f"{int(pet.mood)}%",
            tr("–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "Mood"),
        )
        stats_row.addView(mood_card, card_params)

        container.addView(stats_row)

        xp_text = TextView(self.context)
        xp_text.setText(f"‚ö° {pet.xp} XP")
        xp_text.setTextSize(1, 13)
        xp_text.setTextColor(UI.on_surface())
        xp_text.setGravity(Gravity.CENTER)
        xp_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S8))
        container.addView(xp_text, xp_params)

        btn_row = LinearLayout(self.context)
        btn_row.setOrientation(LinearLayout.HORIZONTAL)
        btn_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )
        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        feed_btn = self._create_button(S.FEED, "filled")
        self._setButtonClick(feed_btn, lambda *args: self._on_pet_feed())
        btn_row.addView(feed_btn, btn_params)

        play_btn = self._create_button(S.PLAY, "tonal")
        self._setButtonClick(play_btn, lambda *args: self._on_pet_play())
        btn_row.addView(play_btn, btn_params)

        container.addView(btn_row)

        open_btn = self._create_button(tr("pet_open_menu"), "outlined")
        self._setButtonClick(open_btn, lambda *args: self._on_pet_open())
        open_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        open_params.setMargins(AndroidUtilities.dp(Dp.S16), 0, AndroidUtilities.dp(Dp.S16), 0)
        container.addView(open_btn, open_params)

    def _build_pet_inactive_ui(self, container, pet):
        wrap = LinearLayout(self.context)
        wrap.setOrientation(LinearLayout.VERTICAL)
        wrap.setGravity(Gravity.CENTER)
        wrap.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        emoji_tv = TextView(self.context)
        emoji_tv.setText(pet.get_emoji() if pet else "ü•ö")
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        wrap.addView(emoji_tv)

        title = TextView(self.context)
        title.setText(tr("pet_no_pet_title"))
        title.setTextSize(1, 18)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
        wrap.addView(title, title_params)

        desc = TextView(self.context)
        desc.setText(tr("pet_no_pet_desc"))
        desc.setTextSize(1, 13)
        desc.setTextColor(UI.on_surface_variant())
        desc.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        wrap.addView(desc, desc_params)

        start_btn = self._create_button(tr("turn_on"), "filled")
        self._setButtonClick(start_btn, lambda *args: self._on_pet_start())
        start_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        start_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        wrap.addView(start_btn, start_params)

        container.addView(wrap)

    def _build_rewards_tab(self, container):
        preview = self._create_stages_preview()
        preview_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        preview_params.setMargins(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S6),
        )
        container.addView(preview, preview_params)

        def add_card(title, lines, icon="‚Ä¢", accent=None):
            if not lines:
                return
            card = LinearLayout(self.context)
            card.setOrientation(LinearLayout.VERTICAL)
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            bg.setColor(UI.surface_variant())
            bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
            card.setBackground(bg)
            UI.elevation(card, ELEVATION_CARD)
            card_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            card_params.setMargins(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S8),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S8),
            )

            accent_view = View(self.context)
            accent_bg = GradientDrawable()
            accent_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            accent_bg.setColor(accent if accent is not None else UI.primary())
            accent_view.setBackground(accent_bg)
            accent_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(Dp.S2),
            )
            card.addView(accent_view, accent_params)

            content = LinearLayout(self.context)
            content.setOrientation(LinearLayout.VERTICAL)
            content.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
            )

            header = LinearLayout(self.context)
            header.setOrientation(LinearLayout.HORIZONTAL)
            header.setGravity(Gravity.CENTER_VERTICAL)

            icon_tv = TextView(self.context)
            icon_tv.setText(icon)
            icon_tv.setTextSize(1, 13)
            icon_tv.setTextColor(UI.primary())
            header.addView(icon_tv)

            title_tv = TextView(self.context)
            title_tv.setText(title)
            title_tv.setTextSize(1, 13)
            title_tv.setTextColor(UI.on_surface())
            title_tv.setTypeface(None, Typeface.BOLD)
            title_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            title_params.setMargins(AndroidUtilities.dp(Dp.S6), 0, 0, 0)
            header.addView(title_tv, title_params)
            content.addView(header)

            for text in lines:
                row = TextView(self.context)
                row.setText(f"‚Ä¢ {text}")
                row.setTextSize(1, 13)
                row.setTextColor(UI.on_surface())
                row.setAlpha(0.94)
                row.setPadding(0, AndroidUtilities.dp(Dp.S8), 0, 0)
                content.addView(row)

            card.addView(
                content,
                LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                ),
            )

            container.addView(card, card_params)

        bonus_lines = []
        pet = getattr(self, "_tab_pet", None)
        if pet:
            perk_text = skinPerkText(pet.getSkinStyle())
            if perk_text:
                bonus_lines.append(tr("info_buff_skin", name=perk_text))
            now = time.time()
            if pet.xp_boost_until and pet.xp_boost_until > now:
                percent = int((float(pet.xp_boost_mult or 1.0) - 1.0) * 100)
                remaining = int((pet.xp_boost_until - now) / SECONDS_PER_MINUTE)
                bonus_lines.append(
                    tr("info_buff_xp_boost", percent=percent, remaining=remaining)
                )
            if pet.hunger_block_until and pet.hunger_block_until > now:
                remaining = int((pet.hunger_block_until - now) / SECONDS_PER_MINUTE)
                bonus_lines.append(tr("info_buff_hunger_block", remaining=remaining))
            if pet.accessory:
                style = getAccessoryStyle(pet.accessory)
                if style:
                    bonus_lines.append(
                        tr("info_buff_accessory", name=style.get("name"))
                    )
        else:
            bonus_lines.append(tr("info_no_pet_buffs"))
        if not bonus_lines:
            bonus_lines.append(tr("info_no_buffs_yet"))
        add_card(tr("info_active_buffs"), bonus_lines, icon="‚ú®", accent=UI.primary())

        add_card(
            tr("info_earn_coins"),
            [
                tr("info_coin_feed", amount=COIN_REWARDS["feed"]),
                tr("info_coin_play", amount=COIN_REWARDS["play"]),
                tr("info_coin_evolve", amount=COIN_REWARDS["evolve"]),
            ],
            icon="ü™ô",
            accent=UI.secondary(),
        )

        skin_lines = []
        for skin_value in sorted(PET_STAGES_BY_STYLE.keys()):
            stages = PET_STAGES_BY_STYLE.get(skin_value, PET_STAGES_BY_STYLE[0])
            stage_name = stages[1]["name"] if 1 in stages else stages[0]["name"]
            base_label = PET_STAGE_NAME_EN.get(stage_name, stage_name) if isEn() else stage_name
            perk_text = skinPerkText(skin_value)
            if perk_text:
                skin_lines.append(f"{base_label}: {perk_text}")
            else:
                skin_lines.append(tr("info_skin_no_bonus", name=base_label))
        if skin_lines:
            add_card(tr("info_skins_effects"), skin_lines, icon="üé®", accent=UI.tertiary())
        else:
            add_card(
                tr("info_skins_effects"),
                [tr("info_no_perks_yet")],
                icon="üé®",
                accent=UI.tertiary(),
            )

        add_card(
            tr("info_shop"),
            [
                tr("info_shop_super_food", cost=SUPER_FOOD_COST),
                tr(
                    "info_shop_xp_boost",
                    min_cost=XP_BOOST_OPTIONS[0]["cost"],
                    max_cost=XP_BOOST_OPTIONS[-1]["cost"],
                ),
                tr("info_shop_skins", cost=SKIN_COST_BASE),
                tr("info_shop_accessories", cost=ACCESSORY_STYLES[0]["cost"]),
                tr("info_shop_revive", cost=REVIVE_COIN_COST),
            ],
            icon="üõí",
            accent=UI.primary(),
        )

        rewards = [
            (3, XP_REWARDS["streak_3_days"]),
            (7, XP_REWARDS["streak_7_days"]),
            (14, XP_REWARDS["streak_14_days"]),
            (30, XP_REWARDS["streak_30_days"]),
        ]
        def reward_line(days, xp):
            days_text = formatDaysEn(days) if isEn() else formatDaysRu(days)
            return tr("info_streak_reward_line", days=days_text, xp=xp)

        add_card(
            tr("info_streak_rewards"),
            [reward_line(days, xp) for days, xp in rewards],
            icon="üî•",
            accent=UI.error(),
        )

    def buildShopTab(self, container, pet, petActive):
        plugin = self.plugin
        header = TextView(self.context)
        header.setText(tr("–ú–∞–≥–∞–∑–∏–Ω", "Shop"))
        header.setTextSize(1, 18)
        header.setTextColor(UI.on_surface())
        header.setTypeface(None, Typeface.BOLD)
        header.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S6),
        )
        container.addView(header)

        def addSection(title):
            tv = TextView(self.context)
            tv.setText(title)
            tv.setTextSize(1, 12)
            tv.setTextColor(UI.on_surface_variant())
            tv.setTypeface(None, Typeface.BOLD)
            tv.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S6),
            )
            container.addView(tv)

        if not petActive or not pet:
            info = TextView(self.context)
            info.setText(
                tr(
                    "–°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ–¥–∏ –ø–∏—Ç–æ–º—Ü–∞ - —Ç–æ–≥–¥–∞ –æ—Ç–∫—Ä–æ—é—Ç—Å—è –ø–æ–∫—É–ø–∫–∏",
                    "Get a pet first to unlock the shop",
                )
            )
            info.setTextSize(1, 13)
            info.setTextColor(UI.on_surface_variant())
            info.setGravity(Gravity.CENTER)
            info.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S24),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
            )
            container.addView(info)

            start_btn = self._create_button(tr("–ó–∞–≤–µ—Å—Ç–∏ –ø–∏—Ç–æ–º—Ü–∞", "Get a pet"), "filled")
            self._setButtonClick(start_btn, lambda *args: self._on_pet_start())
            start_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            start_params.setMargins(AndroidUtilities.dp(Dp.S16), 0, AndroidUtilities.dp(Dp.S16), 0)
            container.addView(start_btn, start_params)
            return

        balance_wrap = LinearLayout(self.context)
        balance_wrap.setOrientation(LinearLayout.HORIZONTAL)
        balance_wrap.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S10),
        )
        chip = TextView(self.context)
        chip_bg = GradientDrawable()
        chip_bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
        chip_bg.setColor(UI.surface_variant())
        chip.setBackground(chip_bg)
        chip.setText(tr(f"ü™ô {pet.coins} –º–æ–Ω–µ—Ç–æ–∫", f"ü™ô {pet.coins} coins"))
        chip.setTextSize(1, 12)
        chip.setTextColor(UI.on_surface())
        chip.setPadding(
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S6),
        )
        balance_wrap.addView(chip)
        container.addView(balance_wrap)

        tile_row = {"view": None, "count": 0}
        def flushRow():
            if tile_row["view"]:
                container.addView(tile_row["view"])
            tile_row["view"] = None
            tile_row["count"] = 0

        def addTile(icon, title_text, short_text, price, enabled, on_click):
            if tile_row["view"] is None:
                row = LinearLayout(self.context)
                row.setOrientation(LinearLayout.HORIZONTAL)
                row.setPadding(
                    AndroidUtilities.dp(Dp.S16),
                    0,
                    AndroidUtilities.dp(Dp.S16),
                    AndroidUtilities.dp(Dp.S8),
                )
                tile_row["view"] = row
                tile_row["count"] = 0

            card = LinearLayout(self.context)
            card.setOrientation(LinearLayout.VERTICAL)
            card.setPadding(
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
            )
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S14))
            bg.setColor(UI.surface_variant())
            card.setBackground(bg)

            icon_tv = TextView(self.context)
            icon_tv.setText(icon)
            icon_tv.setTextSize(1, 16)
            icon_tv.setTextColor(UI.on_surface())
            title_tv = TextView(self.context)
            title_tv.setText(title_text)
            title_tv.setTextSize(1, 14)
            title_tv.setTextColor(UI.on_surface())
            title_tv.setTypeface(None, Typeface.BOLD)
            card.addView(icon_tv)
            title_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            title_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            card.addView(title_tv, title_params)

            desc_tv = TextView(self.context)
            desc_tv.setText(short_text)
            desc_tv.setTextSize(1, 10)
            desc_tv.setTextColor(UI.on_surface_variant())
            desc_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            desc_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            card.addView(desc_tv, desc_params)

            buy_btn = UI.button(self.context, tr("–ö—É–ø–∏—Ç—å", "Buy"), on_click, "filled")
            if not enabled:
                buy_btn.setEnabled(False)
                buy_btn.setAlpha(0.5)
            buy_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            buy_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
            card.addView(buy_btn, buy_params)

            price_chip = TextView(self.context)
            price_bg = GradientDrawable()
            price_bg.setCornerRadius(AndroidUtilities.dp(Dp.S10))
            price_bg.setColor(UI.primary_container())
            price_chip.setBackground(price_bg)
            price_chip.setText(tr(f"{price} ü™ô", f"{price} ü™ô"))
            price_chip.setTextSize(1, 10)
            price_chip.setTextColor(UI.on_primary_container())
            price_chip.setPadding(
                AndroidUtilities.dp(Dp.S8),
                AndroidUtilities.dp(Dp.S4),
                AndroidUtilities.dp(Dp.S8),
                AndroidUtilities.dp(Dp.S4),
            )
            price_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            price_params.setMargins(0, AndroidUtilities.dp(Dp.S6), 0, 0)
            card.addView(price_chip, price_params)

            params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
            if tile_row["count"] > 0:
                params.setMargins(AndroidUtilities.dp(Dp.S8), 0, 0, 0)
            tile_row["view"].addView(card, params)
            tile_row["count"] += 1
            if tile_row["count"] >= 2:
                flushRow()

        now = time.time()
        hungerActive = pet.hunger_block_until and pet.hunger_block_until > now
        if hungerActive:
            remaining = int((pet.hunger_block_until - now) / SECONDS_PER_MINUTE)
            hungerDesc = tr(
                f"–£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–ª–æ—Å—å ~{remaining} –º–∏–Ω",
                f"Already active, ~{remaining} min left",
            )
        else:
            hungerDesc = tr(
                f"–ü–æ–ª–Ω–∞—è —Å—ã—Ç–æ—Å—Ç—å –∏ –±–ª–æ–∫ –≥–æ–ª–æ–¥–∞ –Ω–∞ {HUNGER_BLOCK_HOURS} —á",
                f"Full satiety + hunger block for {HUNGER_BLOCK_HOURS}h",
            )

        addSection(tr("–£–ª—É—á—à–µ–Ω–∏—è", "Boosts"))
        addTile(
            "ü•£",
            tr("–°—É–ø-–µ–¥–∞", "Super food"),
            tr("–°—ã—Ç–æ—Å—Ç—å –∏ –±–ª–æ–∫ –≥–æ–ª–æ–¥–∞", "Satiety + block"),
            SUPER_FOOD_COST,
            not hungerActive,
            lambda *args: self.onShopFood(),
        )

        boostActive = pet.xp_boost_until and pet.xp_boost_until > now
        boostLeftMin = 0
        if boostActive:
            boostLeftMin = int((pet.xp_boost_until - now) / SECONDS_PER_MINUTE)
        for option in XP_BOOST_OPTIONS:
            mult = option.get("mult", 1.0)
            hours = option.get("hours", 1)
            cost = option.get("cost", 0)
            percent = int((mult - 1.0) * 100)
            if boostActive and pet.xp_boost_mult == mult:
                desc = tr(
                    f"–£–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –æ—Å—Ç–∞–ª–æ—Å—å ~{boostLeftMin} –º–∏–Ω",
                    f"Already active, ~{boostLeftMin} min left",
                )
            else:
                desc = tr(
                    f"+{percent}% XP –Ω–∞ {hours}—á",
                    f"+{percent}% XP for {hours}h",
                )
            addTile(
                "‚ö°",
                tr(f"–ë—É—Å—Ç –æ–ø—ã—Ç–∞ +{percent}%", f"XP Boost +{percent}%"),
                tr(f"{hours}—á", f"{hours}h"),
                cost,
                True,
                lambda *args, m=mult, h=hours, c=cost: self.onShopXpBoost(m, h, c),
            )

        flushRow()
        addSection(tr("–í–Ω–µ—à–Ω–∏–π –≤–∏–¥", "Style"))
        skinPrice = plugin.getSkinCost(1) if plugin else SKIN_COST_BASE
        addTile(
            "üé®",
            tr("–°–º–µ–Ω–∏—Ç—å —Å–∫–∏–Ω", "Change skin"),
            tr("–°–º–µ–Ω–∞ –≤–Ω–µ—à–Ω–æ—Å—Ç–∏", "Change look"),
            skinPrice,
            True,
            lambda *args: self.onShopSkin(),
        )

        for style in ACCESSORY_STYLES:
            acc_id = style.get("id")
            name = style.get("name")
            cost = style.get("cost", 0)
            is_active = pet.accessory == acc_id
            desc = tr("–£–∫—Ä–∞—à–µ–Ω–∏–µ –¥–ª—è –≤–∏–¥–∂–µ—Ç–∞", "Widget rim")
            if is_active:
                desc = tr("–£–∂–µ —Å—Ç–æ–∏—Ç", "Selected")
            addTile(
                "‚ú®",
                tr(f"–ê–∫—Å: {name}", f"Acc: {name}"),
                tr("–û–±–æ–¥–æ–∫", "Rim"),
                cost,
                not is_active,
                lambda *args, a=acc_id, c=cost: self.onShopAccessory(a, c),
            )

        flushRow()
        addSection(tr("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ", "Service"))
        addTile(
            "üíñ",
            tr("–í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ", "Revive"),
            tr("–í–µ—Ä–Ω—É—Ç—å –ø–∏—Ç–æ–º—Ü–∞", "Bring back"),
            REVIVE_COIN_COST,
            bool(pet.deleted),
            lambda *args: self.onShopRevive(),
        )
        flushRow()

    def onShopFood(self):
        plugin = self.plugin
        if not plugin:
            return
        plugin.applyFoodBoost(self.chat_id)
        run_on_ui_thread(lambda: self._render_tab(0), 220)

    def onShopSkin(self):
        plugin = self.plugin
        if not plugin:
            return
        ctx = self.context
        if not ctx:
            return
        plugin.showPetSkinShop(ctx, self.chat_id, lambda: self._render_tab(0))

    def onShopXpBoost(self, mult, hours, cost):
        plugin = self.plugin
        if not plugin:
            return
        plugin.applyXpBoost(self.chat_id, mult, hours, cost)
        run_on_ui_thread(lambda: self._render_tab(0), 220)

    def onShopAccessory(self, acc_id, cost):
        plugin = self.plugin
        if not plugin:
            return
        plugin.applyAccessory(self.chat_id, acc_id, cost)
        run_on_ui_thread(lambda: self._render_tab(0), 220)

    def onShopRevive(self):
        plugin = self.plugin
        if not plugin:
            return
        plugin.revivePet(self.chat_id)
        run_on_ui_thread(lambda: self._render_tab(0), 280)

    def _create_simple_stat_card(self, emoji, value, label):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.withAlpha(UI.outline(), 120))
        card.setBackground(bg)
        UI.elevation(card, ELEVATION_CARD)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 16)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(value_tv, value_params)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface_variant())
        label_tv.setGravity(Gravity.CENTER)
        card.addView(label_tv)

        self.animateIn(card, 0, 6)
        return card

    def _init_sheet(self, with_handle=True):
        self.bottom_sheet = BottomSheet(self.context, False)

        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)

        container.setBackground(UI.bg_sheet())

        if with_handle:
            handle_container = LinearLayout(self.context)
            handle_container.setOrientation(LinearLayout.VERTICAL)
            handle_container.setGravity(Gravity.CENTER)
            handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

            handle = View(self.context)
            handle_bg = GradientDrawable()
            handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
            handle_bg.setColor(UI.outline())
            handle.setBackground(handle_bg)
            handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
            handle_container.addView(handle, handle_params)
            container.addView(handle_container)

        scroll_view = ScrollView(self.context)
        scroll_view.setFillViewport(True)

        content = LinearLayout(self.context)
        content.setOrientation(LinearLayout.VERTICAL)

        self._build_content(content)

        scroll_view.addView(content)
        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        buttons = self._build_buttons()
        if buttons:
            btn_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            container.addView(buttons, btn_params)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_content(self, content):
        pass

    def _build_buttons(self):
        return None

    def dismiss(self):
        if self.bottom_sheet:
            self.bottom_sheet.dismiss()
        self.onDismiss()

    def show(self):
        if self.bottom_sheet:
            self.bottom_sheet.show()

    def do_action(self, action_fn, *args):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin and action_fn:
            try:
                action_fn(plugin, chat_id, *args)
            except Exception as e:
                self.log(f"SafeSheet action error: {e}")

    def _add_divider(self, container):
        divider = View(self.context)
        divider.setBackgroundColor(UI.outline())
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 1
        )
        container.addView(divider, divider_params)

    def _add_header(self, container, emoji, title, subtitle=None):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        emoji_text = TextView(self.context)
        emoji_text.setText(emoji)
        emoji_text.setTextSize(1, 64)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        title_text = TextView(self.context)
        title_text.setText(title)
        title_text.setTextSize(1, 28)
        title_text.setTextColor(UI.on_surface())
        title_text.setTypeface(None, Typeface.BOLD)
        title_text.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(title_text, title_params)

        if subtitle:
            sub_text = TextView(self.context)
            sub_text.setText(subtitle)
            sub_text.setTextSize(1, 14)
            sub_text.setTextColor(UI.on_surface_variant())
            sub_text.setGravity(Gravity.CENTER)
            sub_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            sub_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            header.addView(sub_text, sub_params)

        container.addView(header)

    def _add_info_row(self, container, label, value):
        container.addView(UI.info_row(self.context, label, value))

    def _create_button_row(self, *buttons):
        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setGravity(Gravity.CENTER)
        btn_container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
        )

        for i, btn in enumerate(buttons):
            if btn:
                params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.BTN_H), 1.0)
                if i > 0:
                    params.setMargins(AndroidUtilities.dp(Dp.S8), 0, 0, 0)
                btn_container.addView(btn, params)

        return btn_container


# –∫–∞–ª
class Pet:
    def __init__(self, chat_id, plugin_ref=None):
        self.chat_id = chat_id
        self.xp = 0
        self.stage = 0
        self.level = 1
        self.name = self._gen_name()
        self.skinStyle = 0
        self.mood = 100
        self.hunger = 100
        self.coins = 0
        self.hunger_block_until = 0
        self.hunger_zero_since = 0
        self.xp_boost_until = 0
        self.xp_boost_mult = 1.0
        self.accessory = 0
        self.last_feed_time = time.time()
        self.last_update_time = time.time()
        self.last_sync_timestamp = time.time()
        self.deleted = False
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def _gen_name(self):
        if isEn():
            names = [
                "Buddy",
                "Weed",
                "Pixel",
                "Ame",
                "Zhirnostb",
                "Stich",
                "Epstein",
                "Sunny",
                "Milo",
                "Pip",
            ]
        else:
            names = [
                "–ì—Ä—É—à–∞",
                "–ë–µ–ª—ã–π",
                "–ú–∞—Ä—å—è –ò–≤–∞–Ω–Ω–æ–≤–Ω–∞",
                "–õ–æ–∫—Å",
                "–ß–µ—Ä–µ—à–Ω—è",
                "–ó–∞–ª—É–ø—ã—á",
                "–ñ–∏—Ä–Ω–æ—Å—Ç—å",
                "–ö–æ—à–∞–∫",
                "–î—Ä–∞–∫–æ—à–∞",
                "–ù–∏–º–∞—Ä–∫",
                "–ê–º–µ",
                "–¢–æ–º–æ–∫–æ",
                "–ú–∏—à–∞",
                "–ù—è—à–∫–∞",
            ]
        return random.choice(names)

    def update_state(self):
        current_time = time.time()
        prev_update_time = self.last_update_time or current_time
        if current_time < prev_update_time:
            prev_update_time = current_time
        hours_passed = (current_time - prev_update_time) / SECONDS_PER_HOUR

        if self.hunger_block_until and current_time < self.hunger_block_until:
            self.last_update_time = current_time
            self.last_sync_timestamp = current_time
            return

        if hours_passed > 0:
            perk = skinPerk(self)
            hunger_rate = HUNGER_CONFIG["decrease_per_hour"] * perk.get("hunger", 1.0)
            prev_hunger = max(0.0, float(self.hunger or 0))
            hunger_drop = max(0.0, hunger_rate * hours_passed)
            self.hunger = max(0.0, prev_hunger - hunger_drop)

            if self.hunger < MOOD_CONFIG["hunger_penalty_threshold"]:
                penalty = MOOD_CONFIG["mood_decrease_per_hour"] * hours_passed * 1.5
                penalty *= perk.get("mood", 1.0)
                self.mood = max(MOOD_CONFIG["min_mood"], self.mood - penalty)

            if self.hunger <= 0:
                if not self.hunger_zero_since:
                    if hunger_rate > 0 and prev_hunger > 0:
                        zero_after_hours = prev_hunger / hunger_rate
                        zero_ts = prev_update_time + (zero_after_hours * SECONDS_PER_HOUR)
                    else:
                        zero_ts = prev_update_time
                    self.hunger_zero_since = min(max(zero_ts, prev_update_time), current_time)
                if (
                    not self.deleted
                    and current_time - self.hunger_zero_since >= PET_DEATH_HOURS * SECONDS_PER_HOUR
                ):
                    self.deleted = True
            else:
                if self.hunger_zero_since:
                    self.hunger_zero_since = 0

            self.last_update_time = current_time
            self.last_sync_timestamp = current_time

        if self.xp_boost_until and current_time >= self.xp_boost_until:
            self.xp_boost_until = 0
            self.xp_boost_mult = 1.0

    def applyReviveState(self, reviveAt=None):
        revive_ts = float(reviveAt or time.time())
        min_hunger = HUNGER_CONFIG["critical_level"] + 15
        self.deleted = False
        self.hunger_zero_since = 0
        self.hunger = min(
            HUNGER_CONFIG["max_hunger"], max(float(self.hunger or 0), float(min_hunger))
        )
        self.mood = min(MOOD_CONFIG["max_mood"], max(float(self.mood or 0), float(MOOD_LOW_THRESHOLD)))
        self.last_feed_time = revive_ts
        self.last_update_time = revive_ts
        self.last_sync_timestamp = revive_ts

    def feed(self):
        self.update_state()

        old_hunger = self.hunger
        perk = skinPerk(self)
        restore = HUNGER_CONFIG["feed_restore"] * perk.get("feedRestore", 1.0)
        self.hunger = min(HUNGER_CONFIG["max_hunger"], self.hunger + restore)
        self.last_feed_time = time.time()
        if self.hunger > 0 and self.hunger_zero_since:
            self.hunger_zero_since = 0

        mood_bonus = (
            FEED_MOOD_BONUS_HIGH
            if old_hunger < HUNGER_CONFIG["critical_level"]
            else FEED_MOOD_BONUS_LOW
        )
        self.mood = min(MOOD_CONFIG["max_mood"], self.mood + mood_bonus)

        self.last_sync_timestamp = time.time()
        coins_gain = COIN_REWARDS.get("feed", 0) + int(perk.get("feedCoins", 0) or 0)
        self.addCoins(coins_gain)

        xp_reward = XP_REWARDS.get("feed", 10)
        xp_reward = int(xp_reward * perk.get("feedXp", 1.0))
        return xp_reward

    def play(self):
        self.update_state()

        if self.hunger < HUNGER_CONFIG["critical_level"]:
            return 0

        self.mood = min(MOOD_CONFIG["max_mood"], self.mood + PLAY_MOOD_BONUS)
        self.hunger = max(0, self.hunger - PLAY_HUNGER_COST)
        if self.hunger > 0 and self.hunger_zero_since:
            self.hunger_zero_since = 0
        self.last_sync_timestamp = time.time()
        perk = skinPerk(self)
        coins_gain = COIN_REWARDS.get("play", 0) + int(perk.get("playCoins", 0) or 0)
        self.addCoins(coins_gain)

        xp_reward = XP_REWARDS.get("play", 15)
        xp_reward = int(xp_reward * perk.get("playXp", 1.0))
        return xp_reward

    def get_xp_multiplier(self):
        multiplier = 1.0

        if self.mood >= MOOD_HIGH_THRESHOLD:
            multiplier *= MULTIPLIER_MOOD_HIGH
        elif self.mood >= MOOD_MEDIUM_THRESHOLD:
            multiplier *= MULTIPLIER_MOOD_MEDIUM
        elif self.mood >= HUNGER_CONFIG["critical_level"]:
            multiplier *= MULTIPLIER_MOOD_LOW
        else:
            multiplier *= MULTIPLIER_MOOD_CRITICAL

        if self.hunger < HUNGER_CONFIG["critical_level"]:
            multiplier *= MULTIPLIER_HUNGER_CRITICAL
        elif self.hunger < HUNGER_MEDIUM_THRESHOLD:
            multiplier *= MULTIPLIER_HUNGER_LOW

        perk = skinPerk(self)
        multiplier *= perk.get("xp", 1.0)
        if perk.get("nightXp"):
            hour = time.localtime().tm_hour
            if hour < 6 or hour >= 22:
                multiplier *= perk.get("nightXp", 1.0)

        return multiplier

    def add_xp(self, amount):
        self.update_state()

        old_stage = self.stage
        old_level = self.level

        multiplier = self.get_xp_multiplier()
        boost_mult = 1.0
        try:
            if self.xp_boost_until and time.time() < self.xp_boost_until:
                boost_mult = max(1.0, float(self.xp_boost_mult or 1.0))
            else:
                if self.xp_boost_until:
                    self.xp_boost_until = 0
                    self.xp_boost_mult = 1.0
        except Exception:
            boost_mult = 1.0
        final_xp = int(amount * multiplier * boost_mult)

        self.xp = min(self.xp + final_xp, MAX_PET_XP)

        for stage_num, stage_data in sorted(PET_STAGES.items(), reverse=True):
            if self.xp >= stage_data["xp"]:
                self.stage = stage_num
                break

        if self.stage < len(PET_STAGES) - 1:
            current_stage_xp = PET_STAGES[self.stage]["xp"]
            next_stage_xp = PET_STAGES[self.stage + 1]["xp"]
            stage_xp_range = next_stage_xp - current_stage_xp
            xp_in_stage = self.xp - current_stage_xp
            self.level = min(10, int((xp_in_stage / stage_xp_range) * 10) + 1)
        else:
            self.level = 10

        evolved = self.stage > old_stage

        if evolved:
            self.mood = 100
            self.hunger = 100
            self.level = 1
            self.addCoins(COIN_REWARDS.get("evolve", 0))

        self.last_sync_timestamp = time.time()

        return evolved

    def get_status_emoji(self):
        self.update_state()
        if self.hunger < HUNGER_CONFIG["critical_level"]:
            return "üíÄ"
        return ""

    def getSkinStyle(self):
        if isinstance(self.skinStyle, int):
            return max(0, min(self.skinStyle, MAX_PET_SKIN_STYLE))
        return 0

    def get_emoji(self):
        stages = PET_STAGES_BY_STYLE.get(self.getSkinStyle(), PET_STAGES_BY_STYLE[0])
        base_emoji = stages[self.stage]["emoji"]

        status_emoji = self.get_status_emoji()
        if status_emoji:
            return f"{base_emoji}{status_emoji}"

        return base_emoji

    def getBaseEmoji(self):
        stages = PET_STAGES_BY_STYLE.get(self.getSkinStyle(), PET_STAGES_BY_STYLE[0])
        return stages[self.stage]["emoji"]

    def get_stage_name(self):
        stages = PET_STAGES_BY_STYLE.get(self.getSkinStyle(), PET_STAGES_BY_STYLE[0])
        name = stages[self.stage]["name"]
        return PET_STAGE_NAME_EN.get(name, name) if isEn() else name

    def xp_to_next_stage(self):
        current_stage = self.stage
        if current_stage >= len(PET_STAGES) - 1:
            return 0
        next_stage_xp = PET_STAGES[current_stage + 1]["xp"]
        return next_stage_xp - self.xp

    def to_dict(self):
        return {
            "chat": self.chat_id,
            "xp": self.xp,
            "stage": self.stage,
            "level": self.level,
            "name": self.name,
            "skin": self.skinStyle,
            "mood": self.mood,
            "hunger": self.hunger,
            "coins": self.coins,
            "hunger_block_until": self.hunger_block_until,
            "hunger_zero_since": self.hunger_zero_since,
            "xp_boost_until": self.xp_boost_until,
            "xp_boost_mult": self.xp_boost_mult,
            "accessory": self.accessory,
            "last_feed": self.last_feed_time,
            "last_update": self.last_update_time,
            "last_sync": self.last_sync_timestamp,
            "deleted": self.deleted,
        }

    def get_sync_data(self):
        self.update_state()
        revive_time = 0
        combo = 0
        try:
            if self.plugin_ref:
                revive_time = float(self.plugin_ref.pet_revive_times.get(self.chat_id, 0) or 0)
                combo = int(self.plugin_ref.minigame_combo.get(self.chat_id, 0) or 0)
        except Exception:
            revive_time = 0
            combo = 0
        return {
            "xp": self.xp,
            "stage": self.stage,
            "level": self.level,
            "name": self.name,
            "skin": self.getSkinStyle(),
            "mood": self.mood,
            "hunger": self.hunger,
            "coins": self.coins,
            "hunger_block_until": self.hunger_block_until,
            "hunger_zero_since": self.hunger_zero_since,
            "xp_boost_until": self.xp_boost_until,
            "xp_boost_mult": self.xp_boost_mult,
            "accessory": self.accessory,
            "last_feed": self.last_feed_time,
            "last_update": self.last_update_time,
            "timestamp": self.last_sync_timestamp,
            "deleted": self.deleted,
            "revive_time": revive_time,
            "combo": combo,
        }

    def _sanitize_sync_data(self, sync_data):
        if not isinstance(sync_data, dict):
            self.log("WSP: invalid sync_data format - rejecting sync")
            return None

        xp = sync_data.get("xp")
        if xp is None or not isinstance(xp, (int, float)) or xp < 0 or xp > MAX_PET_XP:
            self.log(f"WSP: invalid xp value: {xp} - rejecting sync")
            return None

        stage = sync_data.get("stage")
        if (
            stage is None
            or not isinstance(stage, int)
            or stage < 0
            or stage >= len(PET_STAGES)
        ):
            self.log(f"WSP: invalid stage value: {stage} - rejecting sync")
            return None

        level = sync_data.get("level")
        if level is None:
            if stage < len(PET_STAGES) - 1:
                current_stage_xp = PET_STAGES[stage]["xp"]
                next_stage_xp = PET_STAGES[stage + 1]["xp"]
                stage_xp_range = next_stage_xp - current_stage_xp
                xp_in_stage = xp - current_stage_xp
                level = min(10, max(1, int((xp_in_stage / stage_xp_range) * 10) + 1))
            else:
                level = 10
        elif not isinstance(level, int) or level < 1 or level > MAX_PET_LEVEL:
            self.log(f"WSP: invalid level value: {level}, calculating from xp")
            level = 1

        name = sync_data.get("name", self.name)
        if not isinstance(name, str) or len(name) > MAX_PET_NAME_LENGTH:
            self.log(f"WSP: invalid name, keeping current: {self.name}")
            name = self.name
        skin = V.int_range(sync_data.get("skin"), 0, MAX_PET_SKIN_STYLE, self.getSkinStyle())

        mood = sync_data.get("mood", self.mood)
        if (
            not isinstance(mood, (int, float))
            or mood < 0
            or mood > MOOD_CONFIG["max_mood"]
        ):
            self.log(f"WSP: invalid mood, keeping current: {self.mood}")
            mood = self.mood

        last_feed = V.ts(sync_data.get("last_feed"), self.last_feed_time)

        hunger = sync_data.get("hunger")
        if hunger is None:
            hours_since_feed = (time.time() - last_feed) / SECONDS_PER_HOUR
            hunger = max(
                0,
                HUNGER_CONFIG["max_hunger"]
                - (HUNGER_CONFIG["decrease_per_hour"] * hours_since_feed),
            )
        elif (
            not isinstance(hunger, (int, float))
            or hunger < 0
            or hunger > HUNGER_CONFIG["max_hunger"]
        ):
            self.log(f"WSP: invalid hunger, keeping current: {self.hunger}")
            hunger = self.hunger
        revive_time = V.ts(sync_data.get("revive_time"), 0)
        combo = V.int_range(sync_data.get("combo"), 0, 9999, 0)
        coins = V.int_range(sync_data.get("coins"), 0, MAX_PET_COINS, self.coins)
        hunger_block_until = V.ts(sync_data.get("hunger_block_until"), 0)
        hunger_zero_since = V.ts(sync_data.get("hunger_zero_since"), 0)
        xp_boost_until = V.ts(sync_data.get("xp_boost_until"), 0)
        xp_boost_mult = V.float_range(sync_data.get("xp_boost_mult"), 1.0, 1.5, 1.0)
        accessory = V.int_range(sync_data.get("accessory"), 0, MAX_PET_ACCESSORY, 0)

        return {
            "xp": int(xp),
            "stage": stage,
            "level": level,
            "name": name,
            "skin": skin,
            "mood": mood,
            "hunger": hunger,
            "coins": coins,
            "hunger_block_until": hunger_block_until,
            "hunger_zero_since": hunger_zero_since,
            "xp_boost_until": xp_boost_until,
            "xp_boost_mult": xp_boost_mult,
            "accessory": accessory,
            "last_feed": last_feed,
            "last_update": V.ts(sync_data.get("last_update"), self.last_update_time),
            "timestamp": V.ts(sync_data.get("timestamp"), self.last_sync_timestamp),
            "deleted": V.bool_or(sync_data.get("deleted", False)),
            "revive_time": revive_time,
            "combo": combo,
        }

    def apply_sync_data(self, sync_data, source="unknown"):
        sanitized = self._sanitize_sync_data(sync_data)
        if not sanitized:
            return

        self.log(
            f"WSP: applying {source} sync data for chat {self.chat_id}: xp={sanitized['xp']}, stage={sanitized['stage']}, level={sanitized['level']}"
        )
        self.xp = sanitized["xp"]
        self.stage = sanitized["stage"]
        self.level = sanitized["level"]
        self.name = sanitized["name"]
        self.skinStyle = sanitized["skin"]
        self.mood = sanitized["mood"]
        self.hunger = sanitized["hunger"]
        self.coins = sanitized.get("coins", self.coins)
        self.hunger_block_until = sanitized.get("hunger_block_until", 0) or 0
        self.hunger_zero_since = sanitized.get("hunger_zero_since", 0) or 0
        self.xp_boost_until = sanitized.get("xp_boost_until", 0) or 0
        self.xp_boost_mult = sanitized.get("xp_boost_mult", 1.0) or 1.0
        self.accessory = sanitized.get("accessory", 0) or 0
        self.last_feed_time = sanitized["last_feed"]
        self.last_update_time = sanitized["last_update"]
        self.last_sync_timestamp = sanitized["timestamp"]
        self.deleted = sanitized["deleted"]
        if self.hunger > 0 and self.hunger_zero_since:
            self.hunger_zero_since = 0
        elif self.hunger <= 0 and not self.hunger_zero_since:
            self.hunger_zero_since = min(time.time(), float(self.last_update_time or time.time()))
        if self.plugin_ref:
            try:
                revive_time = sanitized.get("revive_time", 0) or 0
                if revive_time:
                    self.plugin_ref.pet_revive_times[self.chat_id] = float(revive_time)
                else:
                    self.plugin_ref.pet_revive_times.pop(self.chat_id, None)
            except Exception as e:
                self.log(f"WSP: failed to apply revive_time sync for {self.chat_id}: {e}")
            try:
                self.plugin_ref.minigame_combo[self.chat_id] = int(sanitized.get("combo", 0) or 0)
            except Exception as e:
                self.log(f"WSP: failed to apply combo sync for {self.chat_id}: {e}")

    @staticmethod
    def from_dict(data, plugin_ref=None):
        pet = Pet(data["chat"], plugin_ref=plugin_ref)
        pet.xp = data.get("xp", 0)
        pet.stage = data.get("stage", 0)
        pet.level = data.get("level", 1)
        pet.name = data.get("name", "–ß–µ–±—É—Ä–∞—à–∫–∞")
        pet.skinStyle = V.int_range(
            data.get("skin"),
            0,
            MAX_PET_SKIN_STYLE,
            0,
        )
        pet.mood = data.get("mood", 100)
        pet.hunger = data.get("hunger", 100)
        pet.coins = data.get("coins", 0)
        pet.hunger_block_until = data.get("hunger_block_until", 0)
        pet.hunger_zero_since = data.get("hunger_zero_since", 0)
        pet.xp_boost_until = data.get("xp_boost_until", 0)
        pet.xp_boost_mult = data.get("xp_boost_mult", 1.0)
        pet.accessory = data.get("accessory", 0)
        pet.last_feed_time = data.get("last_feed", time.time())
        pet.last_update_time = data.get("last_update", time.time())
        pet.last_sync_timestamp = data.get("last_sync", 0)
        pet.deleted = data.get("deleted", False)
        if pet.hunger > 0 and pet.hunger_zero_since:
            pet.hunger_zero_since = 0
        elif pet.hunger <= 0 and not pet.hunger_zero_since:
            pet.hunger_zero_since = min(time.time(), float(pet.last_update_time or time.time()))
        return pet

    def addCoins(self, amount):
        if not isinstance(amount, (int, float)):
            return 0
        amount = int(amount)
        if amount <= 0:
            return 0
        self.coins = min(MAX_PET_COINS, int(self.coins) + amount)
        now = time.time()
        self.last_update_time = now
        self.last_sync_timestamp = now
        return amount

    def spendCoins(self, amount):
        if not isinstance(amount, (int, float)):
            return False
        amount = int(amount)
        if amount <= 0:
            return True
        if int(self.coins) < amount:
            return False
        self.coins = max(0, int(self.coins) - amount)
        now = time.time()
        self.last_update_time = now
        self.last_sync_timestamp = now
        return True

    def applyHungerBlock(self, duration_seconds):
        now = time.time()
        self.hunger = HUNGER_CONFIG["max_hunger"]
        self.last_feed_time = now
        self.hunger_block_until = max(self.hunger_block_until or 0, now + duration_seconds)
        self.hunger_zero_since = 0
        self.last_update_time = now
        self.last_sync_timestamp = now

    def cleanup(self):
        self._plugin_ref = None


# —Å–∏–Ω—Ö—Ä–∞
class StreakSyncManager:
    SYNC_MESSAGE_PREFIX = "\u200b\u200c\u200d"
    MODE_P2P = "p2p"
    MODE_SERVER = "server"
    MODE_AUTO = "auto"
    MODE_LOCAL = "local"
    SERVER_URL = "https://watamotestreakpet.win"

    def __init__(self, mode="p2p", server_url=None, enable_fallback=True):
        self.mode = mode
        self.server_url = server_url or self.SERVER_URL
        self.enable_fallback = enable_fallback
        self.server_available = True
        self.server_degraded = False
        self.last_server_check = 0
        self.server_check_interval = 60
        self.health_min_interval = 60
        self.health_max_interval = 600
        self._health_backoff = self.health_min_interval
        self._next_health_check = 0
        self.last_health_ok = 0
        self.health_grace = 120
        self.cache = {}
        self.cache_ttl = 60
        self.max_cache_size = 100
        self.cache_writes = 0
        self.last_save_times = {}
        self.saveTimeWrites = 0
        self.lastSaveTtl = SAVE_KEY_TTL_SECONDS
        self.maxSaveKeys = SAVE_KEY_MAX_SIZE
        self.save_throttle_interval = 2
        self.sync_frequency = 120
        self.min_sync_frequency = 60
        self.max_sync_frequency = 300
        self.last_activity_time = time.time()
        self.activity_threshold = 120
        self.log = log
        self.token = None
        self.tokenExp = 0
        self.installId = None
        self.installSecret = None
        self._install_secret_handler = None
        self.last_error = None
        self.retryBase = 0.5
        self.retryJitter = 0.7
        self.authWaitUntil = 0
        self.rateWaitUntil = 0
        self.maxTmp = 2000
        self.userIdHash = None
        self.devKey = None
        self.resetSecret = False
        self._reset_secret_handler = None
        self._cache_lock = threading.Lock()
        self.httpSlots = threading.BoundedSemaphore(HTTP_MAX_PARALLEL_REQUESTS)
        self._health_lock = threading.Lock()
        self._token_lock = threading.Lock()

    @staticmethod
    def syncPayloadFromData(data, includeClientTime=True):
        if not isinstance(data, dict):
            return None
        payload = {}
        for k, v in data.items():
            if k == "chat" or (isinstance(k, str) and k.startswith("_")):
                continue
            payload[k] = v
        if "timestamp" not in payload:
            fallback = payload.get("last_sync")
            if fallback is None:
                fallback = payload.get("last_update")
            if fallback is None:
                fallback = payload.get("last_feed")
            if isinstance(fallback, (int, float)):
                payload["timestamp"] = float(fallback)
            else:
                payload["timestamp"] = time.time()
        if includeClientTime and "client_time" not in payload:
            payload["client_time"] = time.time()
        return payload

    def _hash_user_id(self, user_id):
        user_id_str = str(user_id)
        return hashlib.sha256(user_id_str.encode()).hexdigest()

    def clientKey(self, user1, user2):
        hashA = self._hash_user_id(user1)
        hashB = self._hash_user_id(user2)
        ids = sorted([hashA, hashB])
        return f"{ids[0]}:{ids[1]}"

    def sortHashIds(self, user_id_a, user_id_b):
        idA, idB = self.sortIds(user_id_a, user_id_b)
        hashA = self._hash_user_id(idA)
        hashB = self._hash_user_id(idB)
        return idA, idB, hashA, hashB

    def throttleSave(self, saveKey):
        currentTime = time.time()
        with self._cache_lock:
            self.saveTimeWrites += 1
            if self.saveTimeWrites % 32 == 0:
                self.cleanSaveTimesCore(currentTime)
            lastSave = self.last_save_times.get(saveKey, 0)
            if currentTime - lastSave < self.save_throttle_interval:
                return True
            self.last_save_times[saveKey] = currentTime
            if len(self.last_save_times) > self.maxSaveKeys:
                self.cleanSaveTimesCore(currentTime)
        return False

    def setInstallId(self, installId):
        if not installId or not isinstance(installId, str):
            return False
        installId = installId.strip()
        if len(installId) < 8 or len(installId) > 64:
            return False
        self.installId = installId
        return True

    def setInstallSecretHandler(self, handler):
        self._install_secret_handler = handler

    def setResetSecretHandler(self, handler):
        self._reset_secret_handler = handler

    def setInstallSecret(self, secret):
        if not secret or not isinstance(secret, str):
            return False
        if secret != self.installSecret:
            self.installSecret = secret
            if self._install_secret_handler:
                try:
                    self._install_secret_handler(secret)
                except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                    self.log(f"WSP: install secret handler error: {e}")
        return True

    def setResetSecret(self, value):
        self.resetSecret = bool(value)
        if self._reset_secret_handler:
            try:
                self._reset_secret_handler(self.resetSecret)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: reset secret handler error: {e}")
        return True

    def setUserId(self, userId):
        try:
            if not userId:
                return False
            if isinstance(userId, str) and len(userId) >= 40:
                new_hash = userId.lower()
            else:
                new_hash = self._hash_user_id(userId)
            if new_hash != self.userIdHash:
                self.userIdHash = new_hash
                self.token = None
                self.tokenExp = 0
            return True
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: setUserId error: {e}")
            return False

    def setDevKey(self, devKey):
        if not devKey or not isinstance(devKey, str):
            return False
        if devKey != self.devKey:
            self.devKey = devKey
        return True

    def normErrKey(self, reason):
        key = str(reason or "").strip().lower()
        if not key:
            return ""
        key = key.replace("-", "_").replace(" ", "_")
        while "__" in key:
            key = key.replace("__", "_")
        if key in ("authentication_failed", "missing_authentication"):
            return "auth_failed"
        if key == "auth_backend_unavailable":
            return "server_unavailable"
        if key.startswith("http_401") or key.startswith("http_403"):
            return "auth_failed"
        if key.startswith("http_429"):
            return "rate_limited"
        return key

    def needResetSecret(self, reason):
        key = self.normErrKey(reason)
        if not key:
            return False
        if key in (
            "missing_install_secret",
            "invalid_install_secret",
            "install_reauth_required",
            "token_revoked",
            "auth_failed",
            "missing_install_id",
            "invalid_install_id",
        ):
            return True
        return "install_secret" in key and ("missing" in key or "invalid" in key)

    def tokenExpired(self):
        return not self.token or time.time() >= self.tokenExp

    def fetchToken(self):
        if not self.installId or not self.userIdHash or not self.devKey:
            self.last_error = "missing_auth_material"
            self.log("WSP: fetchToken aborted due to missing installId/userIdHash/devKey")
            return False
        url = f"{self.server_url}/api/v1/auth/guest"
        for _ in range(3):
            payload = {
                "install_id": self.installId,
                "user_id": self.userIdHash,
                "devkey": self.devKey,
            }
            auth_headers = {"X-Install-Id": self.installId}
            if self.installSecret and not self.resetSecret:
                payload["install_secret"] = self.installSecret
                auth_headers["X-Install-Secret"] = self.installSecret
            if self.resetSecret:
                payload["reset_secret"] = True

            result, error = self._make_http_request(
                url,
                method="POST",
                data=payload,
                retries=2,
                headers=auth_headers,
                useAuth=False,
            )
            if result and result.get("status") == "success":
                token = result.get("token")
                if not token or not isinstance(token, str):
                    self.last_error = "auth_failed"
                    self.log("WSP: auth success response missing token")
                    if self.resetSecret:
                        continue
                    return False
                exp = result.get("exp")
                ttl = result.get("expires_in", 0)
                new_secret = result.get("install_secret")
                if new_secret:
                    self.setInstallSecret(new_secret)
                if self.resetSecret:
                    self.setResetSecret(False)
                if not exp:
                    exp = time.time() + max(30.0, float(ttl or 3600))
                self.token = token
                self.tokenExp = float(exp) - 3
                self.last_error = None
                return True

            errKey = self.normErrKey(self.last_error or error)
            self.last_error = errKey or self.last_error
            if not self.resetSecret and self.needResetSecret(errKey):
                self.log(f"WSP: auth recovery: enabling reset_secret (reason={errKey})")
                self.setResetSecret(True)
                self.token = None
                self.tokenExp = 0
                continue
            if errKey in ("auth_wait", "rate_limited"):
                time.sleep(0.4)
                continue
            break

        return False

    def ensureToken(self, force=False):
        if not force and not self.tokenExpired():
            return True
        with self._token_lock:
            if not force and not self.tokenExpired():
                return True
            return self.fetchToken()

    def getCached(self, cacheKey):
        cached = self.cacheGet(cacheKey)
        if not cached:
            return None
        if cached.get("deleted", False):
            self.cache.pop(cacheKey, None)
            return None
        return self.attachRemoteMeta(cached)

    def fetchEntity(
        self,
        url,
        cacheKey,
        user1Id,
        user2Id,
        logFound,
        logNotFound,
        logFailed,
    ):
        result, error = self._make_http_request(
            url, method="GET", retries=2, user1_id=user1Id, user2_id=user2Id
        )

        if result and result.get("status") == "found":
            data = result.get("data")
            self.cacheSet(cacheKey, data)
            server_time = result.get("_server_time")
            logFound(data)
            return self.attachRemoteMeta(data, server_time=server_time)
        if result:
            logNotFound(result.get("status"))
            return None
        logFailed(error)
        return None

    def saveEntity(
        self,
        url,
        payloadKey,
        cacheKey,
        saveKey,
        data,
        user1Id,
        user2Id,
        logStart,
        logSuccess,
        logFailStatus,
        logFailError,
    ):
        if self.throttleSave(saveKey):
            self.last_error = "throttled"
            return False

        payload = {
            "user1_id": user1Id,
            "user2_id": user2Id,
            payloadKey: self.withClientTime(data),
        }
        logStart()

        result, error = self._make_http_request(
            url,
            method="POST",
            data=payload,
            retries=3,
            user1_id=user1Id,
            user2_id=user2Id,
        )

        if result and result.get("status") in ["saved", "kept_local"]:
            status = result.get("status")
            server_data = result.get("data")
            final_data = server_data if isinstance(server_data, dict) else data
            self.cacheSet(cacheKey, final_data)
            action = result.get("action", "unknown")
            logSuccess(status, action, final_data)
            self.last_error = None
            return True
        if result:
            self.last_error = (
                result.get("message") or result.get("status") or "server_error"
            )
            logFailStatus(result)
            return False
        logFailError(error)
        return False

    def withClientTime(self, data):
        if not isinstance(data, dict):
            return data
        payload = dict(data)
        payload["client_time"] = time.time()
        return payload

    def attachRemoteMeta(self, data, server_time=None):
        if not isinstance(data, dict):
            return data
        payload = dict(data)
        if server_time:
            payload["_server_time"] = server_time
        payload["_client_received_at"] = time.time()
        return payload

    def retryDelay(self, attempt):
        return (self.retryBase * (2 ** attempt)) + random.uniform(
            0, self.retryJitter
        )

    def _checkServerUrl(self, url):
        try:
            parsed = urllib.parse.urlparse(url or "")
            trusted = urllib.parse.urlparse(self.SERVER_URL)

            scheme = (parsed.scheme or "").lower()
            host = (parsed.hostname or "").lower()
            trusted_scheme = (trusted.scheme or "https").lower()
            trusted_host = (trusted.hostname or "").lower()

            if not scheme or not host:
                self.last_error = "malformed_url"
                self.log(f"WSP: bad server url: {url}")
                return False
            if scheme != trusted_scheme:
                self.last_error = "insecure_transport"
                self.log(f"WSP: bad server scheme: {scheme}")
                return False
            if host != trusted_host:
                self.last_error = "untrusted_host"
                self.log(f"WSP: bad server host: {host}")
                return False
            try:
                raw_port = parsed.port
            except ValueError:
                self.last_error = "malformed_url"
                self.log(f"WSP: bad server port in url: {url}")
                return False

            parsed_port = raw_port if raw_port is not None else (443 if scheme == "https" else 80)
            trusted_port = (
                trusted.port
                if trusted.port is not None
                else (443 if trusted_scheme == "https" else 80)
            )
            if parsed_port != trusted_port:
                self.last_error = "untrusted_port"
                self.log(f"WSP: bad server port: {parsed_port}")
                return False
            return True
        except Exception as e:
            self.last_error = "malformed_url"
            self.log(f"WSP: server url check error: {e}")
            return False

    def _make_http_request(
        self,
        url,
        method="GET",
        data=None,
        retries=3,
        user1_id=None,
        user2_id=None,
        headers=None,
        useAuth=True,
    ):
        last_error_msg = None
        self.last_error = None
        authRefreshed = False

        if not self._checkServerUrl(url):
            return None, (self.last_error or "malformed_url")

        def sleepRetry(attempt):
            time.sleep(self.retryDelay(attempt))

        for attempt in range(retries):
            try:
                now = time.time()
                if now < self.rateWaitUntil:
                    self.last_error = "rate_limited"
                    return None, "rate_limited"
                if useAuth and now < self.authWaitUntil:
                    self.last_error = "auth_wait"
                    return None, "auth_wait"

                req_headers = {"User-Agent": "WSP/2.0"}
                req_token = None

                if useAuth:
                    if not self.ensureToken():
                        errKey = self.normErrKey(self.last_error or "auth_failed")
                        self.last_error = errKey or "auth_failed"
                        last_error_msg = self.last_error
                        break
                    if self.token:
                        req_headers["Authorization"] = f"Bearer {self.token}"
                        req_token = self.token
                    if self.installId:
                        req_headers["X-Install-Id"] = self.installId
                    if self.installSecret:
                        req_headers["X-Install-Secret"] = self.installSecret

                if headers:
                    req_headers.update(headers)

                body = b""
                if method == "POST" and data is not None:
                    body = json.dumps(data).encode("utf-8")
                    req_headers["Content-Type"] = "application/json"

                if self.devKey:
                    try:
                        parsed = urllib.parse.urlparse(url)
                        path = parsed.path
                        query_pairs = urllib.parse.parse_qsl(
                            parsed.query, keep_blank_values=True
                        )

                        sig_query = urllib.parse.urlencode(query_pairs, doseq=True)
                        if sig_query:
                            path = f"{path}?{sig_query}"
                        reqTs = str(int(time.time()))
                        reqNonce = secrets.token_hex(8)
                        base = f"{method}|{path}|{reqTs}|{reqNonce}|".encode("utf-8")
                        sig = hmac.new(
                            self.devKey.encode(), base + body, hashlib.sha256
                        ).hexdigest()
                        req_headers["X-Req-Ts"] = reqTs
                        req_headers["X-Req-Nonce"] = reqNonce
                        req_headers["X-Req-Sig"] = sig
                    except Exception as e:
                        self.last_error = "sign_failed"
                        last_error_msg = f"request_sign_failed: {e}"
                        self.log(f"WSP: request signing failed: {e}")
                        break

                if method == "POST" and body:
                    req = urllib.request.Request(
                        url, data=body, headers=req_headers, method="POST"
                    )
                else:
                    req = urllib.request.Request(url, headers=req_headers, method=method)

                timeout = HTTP_TIMEOUT_FIRST if attempt == 0 else HTTP_TIMEOUT_RETRY

                self.httpSlots.acquire()
                try:
                    with urllib.request.urlopen(req, timeout=timeout) as response:
                        result = json.loads(response.read().decode("utf-8"))
                        if (
                            isinstance(result, list)
                            and len(result) == 2
                            and isinstance(result[0], dict)
                        ):
                            result = dict(result[0])
                            if isinstance(result[1], int):
                                result["_http_status"] = result[1]
                        try:
                            import email.utils

                            date_header = response.headers.get("Date")
                            if date_header:
                                parsed = email.utils.parsedate_to_datetime(date_header)
                                if parsed:
                                    result["_server_time"] = parsed.timestamp()
                        except Exception as e:
                            self.log(f"WSP: failed to parse Date header: {e}")
                        self.server_available = True
                        return result, None
                finally:
                    self.httpSlots.release()

            except urllib.error.HTTPError as e:
                last_error_msg = f"HTTP {e.code}: {e.reason}"
                self.log(
                    f"WSP: HTTP error on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                now = time.time()
                if useAuth and e.code in (401, 403):
                    self.token = None
                    self.tokenExp = 0
                    if not authRefreshed:
                        self.authWaitUntil = max(self.authWaitUntil, now + 10)
                        if self.ensureToken(force=True):
                            authRefreshed = True
                            continue
                if useAuth and e.code == 429:
                    self.last_error = "rate_limited"
                    delay = self.retryDelay(attempt)
                    self.rateWaitUntil = max(self.rateWaitUntil, now + delay + 10)
                    time.sleep(min(delay, 5))
                    if attempt < retries - 1:
                        continue
                error_msg = None
                try:
                    error_body = e.read().decode("utf-8")
                    self.log(f"WSP: error response body: {error_body}")
                    try:
                        parsed = json.loads(error_body)
                        error_msg = parsed.get("message") or parsed.get("status")
                    except Exception as e:
                        self.log(f"WSP: failed to parse HTTP error body json: {e}")
                except Exception as e:
                    self.log(f"WSP: failed to read HTTP error body: {e}")
                if error_msg:
                    self.last_error = error_msg
                elif e.code in (401, 403):
                    self.last_error = "auth_failed"
                elif e.code >= HTTP_SERVER_ERROR_THRESHOLD:
                    self.last_error = "server_error"
                else:
                    self.last_error = "bad_request"
                self.server_available = True
                self.server_degraded = e.code >= HTTP_SERVER_ERROR_THRESHOLD
                if e.code >= HTTP_SERVER_ERROR_THRESHOLD:
                    if attempt < retries - 1:
                        sleepRetry(attempt)
                        continue
                break

            except urllib.error.URLError as e:
                last_error_msg = f"URL Error: {e.reason}"
                self.last_error = "network"
                self.log(
                    f"WSP: URL error on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                if attempt < retries - 1:
                    sleepRetry(attempt)
                    continue

            except Exception as e:
                last_error_msg = str(e)
                self.last_error = "exception"
                self.log(
                    f"WSP: exception on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                if attempt < retries - 1:
                    sleepRetry(attempt)
                    continue

        if self.last_error in ("network", "exception"):
            self.server_available = False
            self.server_degraded = False
        elif self.last_error in ("server_error", "db_busy"):
            self.server_available = True
            self.server_degraded = True
        elif self.last_error:
            self.server_available = True
            self.server_degraded = False
        else:
            self.server_available = False
            self.server_degraded = False
        final_error = last_error_msg or self.last_error or "unknown_error"
        self.log(f"WSP server request failed after {retries} attempts: {final_error}")
        return None, final_error

    def checkServerHealth(self):
        current_time = time.time()

        if current_time < self._next_health_check:
            return self.server_available

        with self._health_lock:
            if current_time < self._next_health_check:
                return self.server_available

            self.last_server_check = current_time

            try:
                url = f"{self.server_url}/health"
                result, error = self._make_http_request(
                    url, method="GET", retries=3, useAuth=False
                )

                status = result.get("status") if result else None
                is_healthy = status in ["ok", "degraded"]
                self.server_available = bool(is_healthy)
                self.server_degraded = status == "degraded"
                if is_healthy:
                    self.last_health_ok = current_time
                    self._health_backoff = self.health_min_interval
                    self._next_health_check = current_time + self._health_backoff
                    return True
                self.log(
                    f"WSP server health check failed: error={error}, status={status}"
                )
                if (
                    self.last_health_ok
                    and (current_time - self.last_health_ok) <= self.health_grace
                ):
                    self.log("WSP: using health grace window, keeping server available")
                    self._health_backoff = min(
                        self._health_backoff * 2, self.health_max_interval
                    )
                    self._next_health_check = current_time + self._health_backoff
                    return True
                self.server_degraded = False
                self._health_backoff = min(
                    self._health_backoff * 2, self.health_max_interval
                )
                self._next_health_check = current_time + self._health_backoff
                return False

            except Exception as e:
                if (
                    self.last_health_ok
                    and (current_time - self.last_health_ok) <= self.health_grace
                ):
                    self.log(
                        f"WSP: health check error within grace window: {e}"
                    )
                    self._health_backoff = min(
                        self._health_backoff * 2, self.health_max_interval
                    )
                    self._next_health_check = current_time + self._health_backoff
                    return True
                self.server_available = False
                self.server_degraded = False
                self._health_backoff = min(
                    self._health_backoff * 2, self.health_max_interval
                )
                self._next_health_check = current_time + self._health_backoff
                self.log(f"WSP server health check error: {e}")

                self.log(f"WSP health check traceback: {traceback.format_exc()}")
                return False

    def sortIds(self, user_id_a, user_id_b):
        return sorted([int(user_id_a), int(user_id_b)])

    def cacheKey(self, user_id_a, user_id_b):
        ids = self.sortIds(user_id_a, user_id_b)
        return f"streak_{ids[0]}_{ids[1]}"

    def cacheGet(self, cacheKey):
        with self._cache_lock:
            cached = self.cache.get(cacheKey)
            if not cached:
                return None
            cached_data, cached_time = cached
            if time.time() - cached_time < self.cache_ttl:
                return cached_data
            self.cache.pop(cacheKey, None)
            return None

    def cacheSet(self, cacheKey, data):
        with self._cache_lock:
            self.cache[cacheKey] = (data, time.time())

            self.cache_writes += 1
            if self.cache_writes % 10 == 0:
                self.cleanCacheCore()

    def cleanCacheCore(self):
        now = time.time()

        expired_keys = [
            key
            for key, (data, timestamp) in self.cache.items()
            if now - timestamp > self.cache_ttl
        ]

        for key in expired_keys:
            del self.cache[key]

        if len(self.cache) > self.max_cache_size:
            sorted_items = sorted(self.cache.items(), key=lambda x: x[1][1])
            remove_count = len(self.cache) - self.max_cache_size
            for key, _ in sorted_items[:remove_count]:
                del self.cache[key]
        self.cleanSaveTimesCore(now)

    def cleanSaveTimesCore(self, now=None):
        self.trimTimedMapCore(
            self.last_save_times,
            ttlSec=self.lastSaveTtl,
            maxSize=self.maxSaveKeys,
            now=now,
        )

    def trimTimedMapCore(self, dataMap, ttlSec=0, maxSize=0, now=None):
        try:
            if now is None:
                now = time.time()
            ttl = float(ttlSec or 0)
            if ttl > 0 and dataMap:
                for key, ts in list(dataMap.items()):
                    if now - float(ts or 0) > ttl:
                        dataMap.pop(key, None)
            maxItems = int(maxSize or 0)
            if maxItems > 0 and len(dataMap) > maxItems:
                items = sorted(
                    dataMap.items(),
                    key=lambda kv: float(kv[1] or 0),
                )
                for key, _ in items[: len(dataMap) - maxItems]:
                    dataMap.pop(key, None)
        except Exception as e:
            self.log(f"WSP: trimTimedMapCore error: {e}")

    def get_streak_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: get_streak_from_server skipped, mode={self.mode}")
            return None

        cacheKey = self.cacheKey(userA, userB)
        cached = self.getCached(cacheKey)
        if cached:
            return cached

        if not self.checkServerHealth():
            self.log("WSP server unavailable, skipping get request")
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/streak/{hashA}/{hashB}"
            return self.fetchEntity(
                url,
                cacheKey,
                hashA,
                hashB,
                lambda data: self.log(f"WSP streak loaded from server: {cacheKey}"),
                lambda status: self.log(
                    f"WSP streak not found on server: status={status}"
                ),
                lambda error: self.log(f"WSP get request failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP get_streak_from_server error: {e}")

            self.log(f"WSP get_streak traceback: {traceback.format_exc()}")
            return None

    def save_streak_to_server(self, userA, userB, streak_data):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: save_streak_to_server skipped, mode={self.mode}")
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            self.log("WSP server unavailable, skipping save")
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            saveKey = f"streak_{idA}_{idB}"
            cacheKey = self.cacheKey(userA, userB)
            url = f"{self.server_url}/api/v1/streak"

            return self.saveEntity(
                url,
                "streak_data",
                cacheKey,
                saveKey,
                streak_data,
                hashA,
                hashB,
                lambda: self.log(f"WSP: saving streak for {cacheKey}"),
                lambda status, action, final_data: self.log(
                    f"WSP streak {status} (action={action}): {cacheKey}, count={final_data.get('count')}"
                ),
                lambda result: self.log(
                    f"WSP save failed with status: {result.get('status')}"
                ),
                lambda error: self.log(f"WSP save failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP save_streak_to_server error: {e}")

            self.log(f"WSP save_streak traceback: {traceback.format_exc()}")
            return False

    @staticmethod
    def create_sync_message(streak_data=None, pet_data=None, key=None, client_key=None):
        sync_payload = {"timestamp": time.time(), "v": 2}

        if streak_data:
            streak_payload = StreakSyncManager.syncPayloadFromData(streak_data)
            if streak_payload:
                sync_payload["streak"] = streak_payload

        if pet_data:
            pet_payload = StreakSyncManager.syncPayloadFromData(pet_data)
            if pet_payload:
                sync_payload["pet"] = pet_payload

        if client_key:
            sync_payload["ck"] = client_key

        if not key:
            return None
        json_data = json.dumps(sync_payload, separators=(',', ':')).encode("utf-8")
        sig_full = hmac.new(key.encode(), json_data, hashlib.sha256).hexdigest()
        sync_payload["sig"] = sig_full[:P2P_SIG_HEX_LEN]
        json_data = json.dumps(sync_payload, separators=(',', ':')).encode("utf-8")

        compressed = zlib.compress(json_data, 9)
        hidden = packZws(compressed)
        return f"{SYNC_PREFIX}{hidden}"

    @staticmethod
    def decodeSyncData(message, chatId=None, kind="message", logVersion=False):
        if not isinstance(message, str):
            return None
        if not any(c in ZW_REV for c in message):
            return None
        if chatId is None:
            return None

        try:
            raw_data = unpackZws(message)
            if not raw_data:
                return None

            if len(raw_data) > MAX_DATA_SIZE_BYTES:
                log("WSP: sync message too large (>1MB)")
                return None

            decomp = zlib.decompressobj()
            decompressed = decomp.decompress(raw_data, MAX_DATA_SIZE_BYTES + 1)
            if decomp.unconsumed_tail:
                log("WSP: decompressed sync message too large (>1MB)")
                return None
            tail = decomp.flush()
            if len(decompressed) + len(tail) > MAX_DATA_SIZE_BYTES:
                log("WSP: decompressed sync message too large (>1MB)")
                return None
            decompressed += tail

            data = json.loads(decompressed.decode("utf-8"))
            if not isinstance(data, dict):
                log("WSP: sync message data is not a dict")
                return None

            msg_version = data.get("v")
            if msg_version != 2:
                if logVersion:
                    log(f"WSP: unsupported sync message version: {msg_version}")
                return None
            return data
        except (zlib.error, json.JSONDecodeError, UnicodeDecodeError, ValueError) as e:
            if kind == "offer":
                log(f"WSP: parse sync offer error: {e}")
            else:
                log(f"WSP: parse sync message error: {e}")
            return None
        except Exception as e:
            if kind == "offer":
                log(f"WSP: unexpected offer parse error: {e}")
            else:
                log(f"WSP: unexpected parse error: {e}")
            return None

    @staticmethod
    def extract_offer_key(message, chat_id=None):
        data = StreakSyncManager.decodeSyncData(message, chatId=chat_id, kind="offer")
        if not data:
            return None
        offered_key = data.get("k")
        if not isinstance(offered_key, str):
            return None
        if not re.fullmatch(r"[0-9a-fA-F]{32}", offered_key):
            return None
        return offered_key

    @staticmethod
    def parse_sync_message(message, chat_id=None, key=None):
        data = StreakSyncManager.decodeSyncData(
            message, chatId=chat_id, kind="message", logVersion=True
        )
        if not data:
            return None
        if not key:
            log("WSP: P2P key missing, rejecting")
            return None

        try:
            received_sig = data.get("sig")
            data_for_verify = {k: v for k, v in data.items() if k != "sig"}
            json_for_verify = json.dumps(data_for_verify, separators=(',', ':')).encode("utf-8")

            if not received_sig:
                log("WSP: P2P message missing signature, rejecting")
                return None
            expected_sig_full = hmac.new(
                key.encode(), json_for_verify, hashlib.sha256
            ).hexdigest()
            if len(received_sig) != P2P_SIG_HEX_LEN:
                log("WSP: P2P signature length invalid, rejecting")
                return None
            if received_sig != expected_sig_full:
                log("WSP: P2P signature mismatch, rejecting")
                return None

            msg_ts = data.get("timestamp")
            if msg_ts is not None and not StreakSyncManager._validate_timestamp(msg_ts):
                log("WSP: sync message timestamp out of range, ignoring")
                return None

            return data
        except Exception as e:
            log(f"WSP: unexpected parse error: {e}")
            return None

    @staticmethod
    def _validate_timestamp(remote_ts, reference_time=None):
        current_time = reference_time if reference_time is not None else time.time()

        if remote_ts > current_time + TIMESTAMP_TOLERANCE_SECONDS:
            return False

        if remote_ts < current_time - ONE_DAY_SECONDS:
            return False

        return True

    @staticmethod
    def should_accept_sync(local_data, remote_data, ignore_local_priority=False):
        if not remote_data:
            return False

        remote_ts = remote_data.get("timestamp", 0)

        reference_time = remote_data.get("_server_time") or remote_data.get(
            "_client_received_at"
        )
        if not StreakSyncManager._validate_timestamp(remote_ts, reference_time):
            return False

        if not local_data:
            return True

        local_ts = local_data.get("timestamp", 0)
        if not ignore_local_priority and local_ts and reference_time:
            if reference_time - local_ts < LOCAL_PRIORITY_SECONDS:
                if remote_ts <= local_ts + LOCAL_PRIORITY_SECONDS:
                    return False

        if remote_ts > local_ts + 5:
            return True
        if local_ts > remote_ts + 5:
            return False
        if "count" in remote_data or "count" in local_data:
            remote_val = remote_data.get("count", 0)
            local_val = local_data.get("count", 0)
        elif "xp" in remote_data or "xp" in local_data:
            remote_val = remote_data.get("xp", 0)
            local_val = local_data.get("xp", 0)
        else:
            return False
        return remote_val > local_val

    def get_pet_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: get_pet_from_server skipped, mode={self.mode}")
            return None

        cacheKey = "pet_" + self.cacheKey(userA, userB)
        cached = self.getCached(cacheKey)
        if cached:
            return cached

        if not self.checkServerHealth():
            self.log("WSP server unavailable, skipping pet get request")
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/pet/{hashA}/{hashB}"
            return self.fetchEntity(
                url,
                cacheKey,
                hashA,
                hashB,
                lambda data: self.log(
                    f"WSP pet loaded from server: {cacheKey}, xp={data.get('xp')}, stage={data.get('stage')}"
                ),
                lambda status: self.log(
                    f"WSP pet not found on server: status={status}"
                ),
                lambda error: self.log(f"WSP get pet request failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP get_pet_from_server error: {e}")

            self.log(f"WSP get_pet traceback: {traceback.format_exc()}")
            return None

    def save_pet_to_server(self, userA, userB, pet_data):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: save_pet_to_server skipped, mode={self.mode}")
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            self.log("WSP server unavailable, skipping pet save")
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            saveKey = f"pet_{idA}_{idB}"
            cacheKey = "pet_" + self.cacheKey(userA, userB)
            url = f"{self.server_url}/api/v1/pet"

            return self.saveEntity(
                url,
                "pet_data",
                cacheKey,
                saveKey,
                pet_data,
                hashA,
                hashB,
                lambda: self.log(
                    f"WSP: saving pet for {cacheKey}"
                ),
                lambda status, action, final_data: self.log(
                    f"WSP pet {status} (action={action}): {cacheKey}, xp={final_data.get('xp')}, stage={final_data.get('stage')}"
                ),
                lambda result: self.log(
                    f"WSP pet save failed with status: {result.get('status')}"
                ),
                lambda error: self.log(f"WSP pet save failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP save_pet_to_server error: {e}")

            self.log(f"WSP save_pet traceback: {traceback.format_exc()}")
            return False

    def getP2pSrv(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return None

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            url = f"{self.server_url}/api/v1/p2pkey/{hashA}/{hashB}"
            result, error = self._make_http_request(
                url,
                method="GET",
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )
            if result and result.get("status") == "found":
                return result.get("key")
            return None
        except Exception as e:
            self.log(f"WSP get_p2p_key error: {e}")
            return None

    def setP2pSrv(self, userA, userB, key):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            url = f"{self.server_url}/api/v1/p2pkey"
            payload = {
                "user1_id": hashA,
                "user2_id": hashB,
                "key": key,
            }
            result, error = self._make_http_request(
                url,
                method="POST",
                data=payload,
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )
            return bool(result and result.get("status") == "saved")
        except Exception as e:
            self.log(f"WSP save_p2p_key error: {e}")
            return False

    def delete_pet_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return False

        if not self.checkServerHealth():
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/pet/{hashA}/{hashB}"
            result, error = self._make_http_request(
                url,
                method="DELETE",
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )

            if result and result.get("status") == "deleted":
                self.log(f"WSP: pet deleted from server: {idA}/{idB}")
                return True
            else:
                self.log(f"WSP: pet delete failed: {result}")
                return False

        except Exception as e:
            self.log(f"WSP delete_pet_from_server error: {e}")
            return False

    def batch_sync(self, myId, streakList, petList):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return None

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return None
        if not myId or myId <= 0:
            self.last_error = "invalid_user_id"
            return None

        try:
            url = f"{self.server_url}/api/v1/batch/sync"
            myHash = self._hash_user_id(myId)

            def addPayload(items, chat_id, data):
                otherId = int(chat_id)
                ids = self.sortIds(myId, otherId)
                hashA = self._hash_user_id(ids[0])
                hashB = self._hash_user_id(ids[1])
                items.append(
                    {
                        "user1_id": hashA,
                        "user2_id": hashB,
                        **self.withClientTime(data),
                    }
                )

            streaks_payload = []
            for chat_id, streak_data in streakList:
                addPayload(streaks_payload, chat_id, streak_data)

            pets_payload = []
            for chat_id, pet_data in petList:
                addPayload(pets_payload, chat_id, pet_data)

            payload = {
                "user1_id": myHash,
                "user2_id": myHash,
                "streaks": streaks_payload,
                "pets": pets_payload,
            }

            self.log(
                f"WSP: batch sync {len(streaks_payload)} streaks, {len(pets_payload)} pets"
            )

            result, error = self._make_http_request(
                url,
                method="POST",
                data=payload,
                retries=2,
                user1_id=myHash,
                user2_id=myHash,
            )

            if result and result.get("status") == "success":
                self.log(f"WSP: batch sync successful")
                return result.get("results")
            else:
                self.log(f"WSP: batch sync failed: {error or result}")
                return None

        except Exception as e:
            self.log(f"WSP: batch_sync error: {e}")

            self.log(f"WSP: batch_sync traceback: {traceback.format_exc()}")
            return None


def get_msk_now():
    return datetime.now(MSK_TZ)


def get_msk_date():
    return get_msk_now().date()


def get_msk_midnight_timestamp(date_obj):
    midnight_msk = datetime.combine(date_obj, datetime.min.time()).replace(
        tzinfo=MSK_TZ
    )
    return midnight_msk.timestamp()


class Streak:
    def __init__(self, chat_id, plugin_ref=None):
        self.chat_id = chat_id
        self.count = 0
        self.last_date = None
        self.first_date = None
        self.last_sync_timestamp = time.time()
        self.last_message_time = time.time()
        self.deleted = False
        self.log = plugin_ref.log if plugin_ref else log

        self.warning_since = None
        self.dead_since = None
        self.dead_count = 0
        self.restores_this_month = 0
        self.last_restore_month = None

    @property
    def is_warning(self):
        return self.warning_since is not None and not self.deleted

    @property
    def is_dead(self):
        return self.dead_since is not None

    @property
    def can_restore(self):
        if not self.is_dead or self.dead_count == 0:
            return False

        hours_since_death = max(0.0, (time.time() - float(self.dead_since or 0)) / 3600)
        if hours_since_death > STREAK_RESTORE_WINDOW_HOURS:
            return False

        self._check_restore_month_reset()
        if self.restores_this_month >= STREAK_MAX_RESTORES_PER_MONTH:
            return False

        return True

    @property
    def restore_time_left(self):
        if not self.is_dead:
            return 0
        hours_since_death = max(0.0, (time.time() - float(self.dead_since or 0)) / 3600)
        return max(0, STREAK_RESTORE_WINDOW_HOURS - hours_since_death)

    @property
    def warning_time_left(self):
        if not self.is_warning:
            return STREAK_WARNING_HOURS
        hours_since_warning = max(0.0, (time.time() - float(self.warning_since or 0)) / 3600)
        return max(0, STREAK_WARNING_HOURS - hours_since_warning)

    def _check_restore_month_reset(self):
        now = datetime.now(MSK_TZ)
        current_month = int(f"{now.year:04d}{now.month:02d}")
        if self.last_restore_month != current_month:
            self.restores_this_month = 0
            self.last_restore_month = current_month

    def calcWarnStart(self):
        if not self.last_date:
            return None
        warn_date = self.last_date + timedelta(days=1)
        return get_msk_midnight_timestamp(warn_date)

    def calcWarnDeadline(self):
        if not isinstance(self.warning_since, (int, float)):
            return None
        return float(self.warning_since) + (STREAK_WARNING_HOURS * SECONDS_PER_HOUR)

    def calcDeadTime(self):
        if not self.last_date:
            return None
        dead_date = self.last_date + timedelta(days=2)
        return get_msk_midnight_timestamp(dead_date)

    def _enter_warning(self, warningTs=None):
        if self.warning_since is None:
            if isinstance(warningTs, (int, float)):
                self.warning_since = float(warningTs)
            else:
                self.warning_since = time.time()
            self.last_sync_timestamp = time.time()
            self.log(f"WSP: streak entered WARNING state for chat {self.chat_id}, count={self.count}")
            return True
        return False

    def _exit_warning(self):
        if self.warning_since is not None:
            self.warning_since = None
            self.last_sync_timestamp = time.time()
            self.log(f"WSP: streak exited WARNING state for chat {self.chat_id}")
            return True
        return False

    def _die(self, deadTs=None):
        now = time.time()
        if isinstance(deadTs, (int, float)):
            dead_since = min(float(deadTs), now)
        else:
            dead_since = now

        if self.count > 0:
            self.dead_since = dead_since
            self.dead_count = self.count
            self.log(f"WSP: streak DIED for chat {self.chat_id}, was {self.count} days")

        self.count = 0
        self.last_date = None
        self.first_date = None
        self.warning_since = None
        self.last_sync_timestamp = now
        return True

    def restore(self):
        if not self.can_restore:
            self.log(f"WSP: cannot restore streak for chat {self.chat_id}")
            return False

        self._check_restore_month_reset()

        self.count = self.dead_count
        self.last_date = get_msk_date()
        self.first_date = self.last_date - timedelta(days=self.count - 1)
        self.last_message_time = time.time()
        self.last_sync_timestamp = time.time()

        self.dead_since = None
        self.dead_count = 0
        self.warning_since = None

        self.restores_this_month += 1

        self.log(f"WSP: streak RESTORED for chat {self.chat_id}, count={self.count}, restores this month={self.restores_this_month}")
        return True

    def check_and_reset_if_expired(self, allow_warning=True):
        if self.deleted or self.count == 0:
            return False

        current_time = time.time()
        today_msk = get_msk_date()
        if not self.last_date:
            if self.is_warning:
                self.log(f"WSP: streak warning cleared for chat {self.chat_id} (no last_date)")
                return self._exit_warning()
            return False

        days_difference = (today_msk - self.last_date).days
        if self.is_warning:
            warning_start = self.calcWarnStart()
            changed = False
            if (
                warning_start is not None
                and isinstance(self.warning_since, (int, float))
                and self.warning_since > warning_start + 1
            ):
                self.warning_since = warning_start
                self.last_sync_timestamp = current_time
                changed = True

            warning_deadline = self.calcWarnDeadline()
            if days_difference >= 2:
                dead_at = self.calcDeadTime() or warning_deadline or current_time
                self.log(f"WSP: streak missed {days_difference} days in warning for chat {self.chat_id}, dying")
                return self._die(dead_at)

            if warning_deadline is not None and current_time >= warning_deadline:
                hours_in_warning = max(0.0, (current_time - float(self.warning_since or warning_deadline)) / 3600)
                self.log(f"WSP: streak warning expired for chat {self.chat_id} after {hours_in_warning:.1f}h")
                return self._die(warning_deadline)
            return changed

        if days_difference >= 2:
            dead_at = self.calcDeadTime() or current_time
            self.log(f"WSP: streak missed {days_difference} days for chat {self.chat_id}, dying")
            return self._die(dead_at)

        if allow_warning and days_difference == 1:
            warning_start = self.calcWarnStart()
            self.log(
                f"WSP: streak entering warning for chat {self.chat_id} "
                f"(no messages today yet)"
            )
            return self._enter_warning(warning_start)

        return False

    def update_streak(self):
        current_time = time.time()
        today_msk = get_msk_date()
        expired_changed = self.check_and_reset_if_expired(allow_warning=False)

        def _start_day_one():
            self.last_date = today_msk
            self.first_date = today_msk
            self.count = 1
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time
            self.warning_since = None
            self.log(f"WSP: streak started for chat {self.chat_id} (day 1)")
            return True

        if self.deleted:
            self.log(f"WSP: streak is deleted for chat {self.chat_id}, ignoring update")
            return False

        if self.is_dead:
            self.log(f"WSP: streak is dead for chat {self.chat_id}, waiting for restore")
            return False

        if self.count == 0 and not self.is_dead:
            return _start_day_one()

        if self.is_warning:
            self._exit_warning()

        if self.last_date is None:
            return _start_day_one()

        difference = (today_msk - self.last_date).days

        if difference < 0:
            self.log(f"WSP: negative date difference detected, ignoring update")
            return False

        if difference == 0:
            self.last_message_time = current_time
            return expired_changed
        elif difference == 1:
            self.count += 1
            self.last_date = today_msk
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time

            if self.count == STREAK_UNLOCK_DAYS:
                self.log(f"WSP: üéâ streak UNLOCKED for chat {self.chat_id}!")
            else:
                self.log(f"WSP: streak continued for chat {self.chat_id}, now {self.count} days")
            return True
        else:
            self.log(f"WSP: streak broken for chat {self.chat_id} (missed {difference} days), starting fresh")
            self.count = 1
            self.last_date = today_msk
            self.first_date = today_msk
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time
            self.dead_since = None
            self.dead_count = 0
            return True

    def get_flame_emoji(self, respect_warning=True):
        if respect_warning and self.is_warning:
            return FLAME_EXTINGUISHED
        for (min_val, max_val), emoji in FLAME_COLORS.items():
            if min_val <= self.count <= max_val:
                return emoji
        return "üî•"

    def get_current_stage_index(self):
        for i, stage in enumerate(FLAME_STAGES):
            if stage["min"] <= self.count <= stage["max"]:
                return i
        return 0

    def to_dict(self):
        return {
            "chat": self.chat_id,
            "count": self.count,
            "last_date": self.last_date.isoformat() if self.last_date else None,
            "first_date": self.first_date.isoformat() if self.first_date else None,
            "timestamp": self.last_sync_timestamp,
            "last_message_time": self.last_message_time,
            "deleted": self.deleted,
            "warning_since": self.warning_since,
            "dead_since": self.dead_since,
            "dead_count": self.dead_count,
            "restores_this_month": self.restores_this_month,
            "last_restore_month": self.last_restore_month,
        }

    def get_sync_data(self):
        return {
            "count": self.count,
            "last_date": self.last_date.isoformat() if self.last_date else None,
            "first_date": self.first_date.isoformat() if self.first_date else None,
            "timestamp": self.last_sync_timestamp,
            "last_message_time": self.last_message_time,
            "deleted": self.deleted,
            "warning_since": self.warning_since,
            "dead_since": self.dead_since,
            "dead_count": self.dead_count,
            "restores_this_month": self.restores_this_month,
            "last_restore_month": self.last_restore_month,
        }

    @staticmethod
    def _ts_recent(value, default):
        if not isinstance(value, (int, float)):
            return default
        now = time.time()
        if value < 0 or value > now + 86400:
            return default
        return float(value)

    def _sanitize_sync_data(self, sync_data):
        if not isinstance(sync_data, dict):
            self.log("WSP: invalid streak sync_data format - rejecting sync")
            return None

        count = sync_data.get("count")
        if (
            count is None
            or not isinstance(count, int)
            or count < 0
            or count > MAX_STREAK_COUNT
        ):
            self.log(f"WSP: invalid streak count value: {count} - rejecting sync")
            return None

        deleted = sync_data.get("deleted", False)
        if not isinstance(deleted, bool):
            self.log(f"WSP: invalid deleted value: {deleted} - rejecting sync")
            return None

        timestamp = self._ts_recent(sync_data.get("timestamp"), time.time())

        last_str = sync_data.get("last_date")
        first_str = sync_data.get("first_date")

        try:
            last_date = datetime.fromisoformat(last_str).date() if last_str else None
        except (ValueError, AttributeError, TypeError):
            self.log(f"WSP: invalid last_date, using None")
            last_date = None

        try:
            first_date = datetime.fromisoformat(first_str).date() if first_str else None
        except (ValueError, AttributeError, TypeError):
            self.log(f"WSP: invalid first_date, using None")
            first_date = None

        last_message_time = self._ts_recent(
            sync_data.get("last_message_time"), time.time()
        )

        return {
            "count": count,
            "deleted": deleted,
            "timestamp": timestamp,
            "last_date": last_date,
            "first_date": first_date,
            "last_message_time": last_message_time,
            "warning_since": V.ts_or_none(sync_data.get("warning_since")),
            "dead_since": V.ts_or_none(sync_data.get("dead_since")),
            "dead_count": V.int_range(
                sync_data.get("dead_count"), 0, 9999, self.dead_count
            ),
            "restores_this_month": V.int_range(
                sync_data.get("restores_this_month"),
                0,
                STREAK_MAX_RESTORES_PER_MONTH,
                self.restores_this_month,
            ),
            "last_restore_month": V.month_key(
                sync_data.get("last_restore_month"), self.last_restore_month
            ),
        }

    def apply_sync_data(self, sync_data, source="unknown"):
        sanitized = self._sanitize_sync_data(sync_data)
        if not sanitized:
            return

        merged_last_message_time = max(
            self.last_message_time, sanitized["last_message_time"]
        )

        self.log(
            f"WSP: applying {source} streak sync data for chat {self.chat_id}: "
            f"count={sanitized['count']}, deleted={sanitized['deleted']}, "
            f"last_message_time: local={self.last_message_time}, remote={sanitized['last_message_time']}, merged={merged_last_message_time}"
        )

        self.count = sanitized["count"]
        self.last_date = sanitized["last_date"]
        self.first_date = sanitized["first_date"]
        self.last_sync_timestamp = sanitized["timestamp"]
        self.last_message_time = merged_last_message_time
        self.deleted = sanitized["deleted"]
        self.warning_since = sanitized["warning_since"]
        self.dead_since = sanitized["dead_since"]
        self.dead_count = sanitized["dead_count"]
        self.restores_this_month = sanitized["restores_this_month"]
        self.last_restore_month = sanitized["last_restore_month"]

    @staticmethod
    def from_dict(data, plugin_ref=None):
        streak = Streak(data["chat"], plugin_ref=plugin_ref)
        streak.count = data.get("count", 0)
        last_str = data.get("last_date")
        first_str = data.get("first_date")

        try:
            streak.last_date = (
                datetime.fromisoformat(last_str).date() if last_str else None
            )
        except (ValueError, AttributeError):
            streak.last_date = None

        try:
            streak.first_date = (
                datetime.fromisoformat(first_str).date() if first_str else None
            )
        except (ValueError, AttributeError):
            streak.first_date = None

        streak.last_sync_timestamp = data.get("timestamp", 0)
        streak.last_message_time = data.get("last_message_time", time.time())
        streak.deleted = data.get("deleted", False)
        streak.warning_since = data.get("warning_since")
        streak.dead_since = data.get("dead_since")
        streak.dead_count = data.get("dead_count", 0)
        streak.restores_this_month = data.get("restores_this_month", 0)
        streak.last_restore_month = V.month_key(data.get("last_restore_month"))
        return streak


# –≤–∏–¥–∂–µ—Ç
class FloatingPetWidget(BaseWidget):
    def __init__(self, context, plugin_ref, chat_id):
        super().__init__(context, plugin_ref, chat_id)
        self.log = plugin_ref.log if plugin_ref else log
        self.container = FrameLayout(context)
        self.content = LinearLayout(context)
        self.view = TextView(context)
        self.stats_view = TextView(context)
        self.ring_outer = None
        self.ring_inner = None
        self._ring_outer_bg = None
        self._ring_inner_bg = None
        self.accRing = None
        self.accRingBg = None
        self.animator1 = None
        self.animator2 = None
        self.animator3 = None
        self.animator4 = None
        self.offset_x = 0
        self.offset_y = 0
        self.user_has_moved = False
        self._base_alpha = 1.0
        self._smart_hidden = False
        self._scroll_hidden = False
        self._keyboard_hidden = False
        self._pre_hide_pos = None
        self.scrollRestoreAt = 0.0
        self.scrollRestorePending = False
        self._smart_hide_view = None
        self._layout_listener = None
        self._scroll_listener = None
        self._last_emoji = None
        self._last_stats_text = None
        self._last_mood = None
        self._last_hunger = None
        self._last_mode = None
        self._last_ring_colors = (None, None)
        self._last_alpha = None
        self._xp_ring_drawable = None
        self._xp_ring = None
        self._last_xp_progress = None
        self._last_accessory = None
        self._bg = None
        self._streak_info = ("üî•", 0)
        self._streak_info_at = 0.0
        self._streak_key_hint = None

        size_index = self.plugin_ref.get_setting("widget_size", 2)
        size_dp = (
            WIDGET_SIZES_DP[size_index]
            if size_index < len(WIDGET_SIZES_DP)
            else WIDGET_DEFAULT_SIZE_DP
        )
        self._size_dp = size_dp
        size_px = AndroidUtilities.dp(size_dp)

        self.container.setLayoutParams(FrameLayout.LayoutParams(size_px, size_px))

        bg = GradientDrawable()
        bg.setShape(GradientDrawable.OVAL)
        bg.setColor(UI.surface_variant())
        bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
        self.container.setBackground(bg)
        self._bg = bg
        UI.elevation(self.container, ELEVATION_WIDGET)

        try:
            outline_provider_cls = find_class("android.view.ViewOutlineProvider")
            outline_provider = getattr(outline_provider_cls, "BACKGROUND", None)
            if outline_provider is not None:
                self.container.setOutlineProvider(outline_provider)
                self.container.setClipToOutline(True)
        except Exception as e:
            self.log(f"WSP: widget outline setup error: {e}")

        self.content.setOrientation(LinearLayout.VERTICAL)
        self.content.setGravity(Gravity.CENTER)
        self.content.setPadding(
            AndroidUtilities.dp(Dp.S2),
            AndroidUtilities.dp(Dp.S2),
            AndroidUtilities.dp(Dp.S2),
            AndroidUtilities.dp(Dp.S2),
        )

        self.view.setGravity(Gravity.CENTER)
        self.view.setClickable(False)
        self.view.setTextColor(UI.on_surface())
        try:
            self.view.setIncludeFontPadding(False)
            self.view.setSingleLine(True)
        except Exception as e:
            self.log(f"WSP: widget text setup error: {e}")

        self.stats_view.setGravity(Gravity.CENTER)
        self.stats_view.setTextColor(UI.on_surface_variant())
        self.stats_view.setClickable(False)
        try:
            self.stats_view.setIncludeFontPadding(False)
            self.stats_view.setSingleLine(True)
        except Exception:
            pass
        stats_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT,
            FrameLayout.LayoutParams.WRAP_CONTENT,
        )
        stats_params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
        stats_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        self.stats_view.setLayoutParams(stats_params)

        pet_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
        )
        self.content.setLayoutParams(pet_params)

        try:
            acc_ring = View(context)
            acc_ring_bg = GradientDrawable()
            acc_ring_bg.setShape(GradientDrawable.OVAL)
            acc_ring_bg.setColor(Color.TRANSPARENT)
            acc_ring_bg.setStroke(AndroidUtilities.dp(Dp.S2), Color.TRANSPARENT)
            acc_ring.setBackground(acc_ring_bg)
            acc_ring.setClickable(False)
            acc_ring.setFocusable(False)
            acc_ring.setAlpha(0.0)
            acc_ring_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            self.container.addView(acc_ring, acc_ring_params)
            self.accRing = acc_ring
            self.accRingBg = acc_ring_bg

            ring_outer = View(context)
            ring_outer_bg = GradientDrawable()
            ring_outer_bg.setShape(GradientDrawable.OVAL)
            ring_outer_bg.setColor(Color.TRANSPARENT)
            ring_outer_bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.primary())
            ring_outer.setBackground(ring_outer_bg)
            ring_outer.setClickable(False)
            ring_outer.setFocusable(False)
            ring_outer.setAlpha(0.9)
            outer_margin = AndroidUtilities.dp(Dp.S2)
            ring_outer_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            ring_outer_params.setMargins(
                outer_margin, outer_margin, outer_margin, outer_margin
            )
            self.container.addView(ring_outer, ring_outer_params)
            self.ring_outer = ring_outer
            self._ring_outer_bg = ring_outer_bg

            ring_inner = View(context)
            ring_inner_bg = GradientDrawable()
            ring_inner_bg.setShape(GradientDrawable.OVAL)
            ring_inner_bg.setColor(Color.TRANSPARENT)
            ring_inner_bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.secondary())
            ring_inner.setBackground(ring_inner_bg)
            ring_inner.setClickable(False)
            ring_inner.setFocusable(False)
            ring_inner.setAlpha(0.75)
            inner_margin = AndroidUtilities.dp(Dp.S6)
            ring_inner_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            ring_inner_params.setMargins(inner_margin, inner_margin, inner_margin, inner_margin)
            self.container.addView(ring_inner, ring_inner_params)
            self.ring_inner = ring_inner
            self._ring_inner_bg = ring_inner_bg

            xp_ring = View(context)
            xp_ring_drawable = ShapeDrawable(ArcShape(-90.0, 0.0))
            xp_paint = xp_ring_drawable.getPaint()
            xp_paint.setStyle(Paint.Style.STROKE)
            xp_paint.setStrokeWidth(AndroidUtilities.dp(Dp.S2))
            try:
                xp_paint.setStrokeCap(Paint.Cap.ROUND)
            except Exception:
                pass
            xp_paint.setColor(UI.primary())
            xp_ring.setBackground(xp_ring_drawable)
            xp_ring.setClickable(False)
            xp_ring.setFocusable(False)
            xp_ring.setAlpha(0.9)
            xp_margin = AndroidUtilities.dp(Dp.S8)
            xp_ring_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            xp_ring_params.setMargins(xp_margin, xp_margin, xp_margin, xp_margin)
            self.container.addView(xp_ring, xp_ring_params)
            self._xp_ring = xp_ring
            self._xp_ring_drawable = xp_ring_drawable
        except Exception:
            pass

        self.content.setClickable(False)
        self.content.setFocusable(False)
        self.content.addView(self.view)
        self.container.addView(self.content)
        self.container.addView(self.stats_view)

        self.container.setClickable(True)
        self.container.setFocusable(True)

        self._apply_widget_mode()
        self._update_visual()
        self.setupTouchBase(self.container)
        try:
            self.view.setOnTouchListener(self.container.getOnTouchListener())
        except Exception:
            pass

    def _update_visual(self):
        if not self.plugin_ref:
            return

        if self.chat_id not in self.plugin_ref.pets:
            self.log(f"WSP: widget update skipped - no pet for chat {self.chat_id}")
            return

        try:
            pet = self.plugin_ref.pets.get(self.chat_id)
            if not pet:
                return

            mode = 0
            if self.plugin_ref:
                try:
                    mode = self.plugin_ref.get_setting("widget_mode", 0)
                except Exception:
                    mode = 0

            emoji = pet.getBaseEmoji()
            if self.view and emoji != self._last_emoji:
                self.view.setText(emoji)
                self._last_emoji = emoji

            if self.stats_view:
                mood_val = int(pet.mood)
                hunger_val = int(pet.hunger)
                streak_emoji, streak_count = self._get_widget_streak_info()

                if mode == 1:
                    parts = [f"{streak_emoji}{streak_count}"]
                    parts.append(f"‚ù§{mood_val}%")
                    parts.append(f"üçñ{hunger_val}%")
                    stats_text = " ‚Ä¢ ".join(parts)
                else:
                    stats_text = f"{streak_emoji}{streak_count}"
                if stats_text != self._last_stats_text:
                    self.stats_view.setText(stats_text)
                    self._last_stats_text = stats_text

            self._update_xp_ring(pet)
            self._update_ring_colors(pet)
            self._update_accessory(pet)
            self._apply_widget_mode(mode)
        except Exception as e:
            self.log(f"WSP: widget visual update error: {e}")
            return

        if self.plugin_ref and self.container:
            try:
                alpha_index = self.plugin_ref.get_setting("widget_alpha", 4)
                alpha_procent = (
                    ALPHA_VALUES_PERCENT[alpha_index]
                    if alpha_index < len(ALPHA_VALUES_PERCENT)
                    else 100
                )
                alpha_value = alpha_procent / 100.0
                if self._last_alpha != alpha_value:
                    self._base_alpha = alpha_value
                    self._last_alpha = alpha_value
                self._apply_smart_hide_alpha()
            except Exception as e:
                self.log(f"WSP: alpha update error: {e}")

    def _get_widget_streak_info(self):
        now = time.time()
        if (now - self._streak_info_at) < 2.5:
            return self._streak_info

        streak_emoji = "üî•"
        streak_count = 0
        try:
            plugin = self.plugin_ref
            if plugin:
                chat_key = self.chat_id
                streak = None

                hint_key = self._streak_key_hint
                if hint_key:
                    candidate = plugin.streaks.get(hint_key)
                    if candidate and str(getattr(candidate, "chat_id", "")) == chat_key:
                        streak = candidate
                    else:
                        self._streak_key_hint = None

                if not streak:
                    pending_key = f"pending:{chat_key}"
                    candidate = plugin.streaks.get(pending_key)
                    if candidate and str(getattr(candidate, "chat_id", "")) == chat_key:
                        streak = candidate
                        self._streak_key_hint = pending_key

                if not streak:
                    for key, candidate in plugin.streaks.items():
                        if not candidate or getattr(candidate, "deleted", False):
                            continue
                        if str(getattr(candidate, "chat_id", "")) == chat_key:
                            streak = candidate
                            self._streak_key_hint = key
                            break

                if streak and not getattr(streak, "deleted", False):
                    streak_count = max(0, int(getattr(streak, "count", 0) or 0))
                    streak_emoji = (
                        streak.get_flame_emoji() if hasattr(streak, "get_flame_emoji") else "üî•"
                    )
        except Exception:
            streak_emoji = "üî•"
            streak_count = 0

        self._streak_info = (streak_emoji, streak_count)
        self._streak_info_at = now
        return self._streak_info

    def _apply_widget_mode(self, mode=None):
        try:
            if mode is None:
                mode = 0
                if self.plugin_ref:
                    mode = self.plugin_ref.get_setting("widget_mode", 0)
            if mode == self._last_mode:
                return
            self._last_mode = mode
            is_expanded = mode == 1
            emoji_size = self._size_dp * (0.48 if is_expanded else 0.56)
            stats_size = max(10, int(self._size_dp * (0.15 if is_expanded else 0.22)))
            if self.view:
                self.view.setTextSize(1, float(emoji_size))
            if self.stats_view:
                self.stats_view.setVisibility(View.VISIBLE)
                self.stats_view.setTextSize(1, float(stats_size))
        except Exception:
            pass

    def _stat_color(self, value, medium_threshold, critical_threshold):
        try:
            if value < critical_threshold:
                return UI.error()
            if value < medium_threshold:
                return UI.tertiary()
            return UI.primary()
        except Exception:
            return UI.primary()

    def _update_ring_colors(self, pet):
        try:
            hunger_color = self._stat_color(
                pet.hunger, HUNGER_MEDIUM_THRESHOLD, HUNGER_CONFIG["critical_level"]
            )
            mood_color = self._stat_color(
                pet.mood, MOOD_MEDIUM_THRESHOLD, MOOD_LOW_THRESHOLD
            )
            if (hunger_color, mood_color) == self._last_ring_colors:
                return
            self._last_ring_colors = (hunger_color, mood_color)
            if self._ring_outer_bg:
                self._ring_outer_bg.setStroke(AndroidUtilities.dp(Dp.S1), hunger_color)
            if self._ring_inner_bg:
                self._ring_inner_bg.setStroke(AndroidUtilities.dp(Dp.S1), mood_color)
        except Exception:
            pass

    def _update_accessory(self, pet):
        try:
            acc_id = int(getattr(pet, "accessory", 0) or 0)
            if acc_id == self._last_accessory:
                return
            self._last_accessory = acc_id
            color = UI.outline()
            if acc_id:
                style = getAccessoryStyle(acc_id)
                if style:
                    color = style.get("color", color)
            if self._bg:
                self._bg.setStroke(AndroidUtilities.dp(Dp.S1), color)
            if self.accRingBg:
                if acc_id:
                    self.accRingBg.setStroke(AndroidUtilities.dp(Dp.S2), color)
                    if self.accRing:
                        self.accRing.setAlpha(0.92)
                else:
                    self.accRingBg.setStroke(AndroidUtilities.dp(Dp.S2), Color.TRANSPARENT)
                    if self.accRing:
                        self.accRing.setAlpha(0.0)
            if self.accRing:
                self.accRing.invalidate()
        except Exception:
            pass

    def _update_xp_ring(self, pet):
        try:
            if not self._xp_ring_drawable or not self._xp_ring:
                return
            if pet.stage >= len(PET_STAGES) - 1:
                progress = 1.0
            else:
                current_xp = PET_STAGES[pet.stage]["xp"]
                next_xp = PET_STAGES[pet.stage + 1]["xp"]
                total = max(1, next_xp - current_xp)
                progress = (pet.xp - current_xp) / float(total)
                progress = max(0.0, min(1.0, progress))
            prev = self._last_xp_progress
            if self._last_xp_progress is not None and abs(progress - self._last_xp_progress) < 0.01:
                return
            self._last_xp_progress = progress
            sweep = float(360.0 * progress)
            self._xp_ring_drawable.setShape(ArcShape(-90.0, sweep))
            self._xp_ring.invalidate()
            if prev is not None and progress > (prev + 0.015):
                self._pulse_xp_ring()
        except Exception:
            pass

    def _pulse_xp_ring(self):
        if not self._xp_ring:
            return
        try:
            sx = ObjectAnimator.ofFloat(self._xp_ring, "scaleX", 1.0, 1.06, 1.0)
            sy = ObjectAnimator.ofFloat(self._xp_ring, "scaleY", 1.0, 1.06, 1.0)
            for anim in (sx, sy):
                anim.setDuration(220)
                anim.setInterpolator(AccelerateDecelerateInterpolator())
                anim.start()
        except Exception:
            pass

    def _apply_smart_hide_alpha(self):
        if not self.container:
            return
        try:
            target_alpha = self._base_alpha * (0.45 if self._smart_hidden else 1.0)
            self.container.setAlpha(float(target_alpha))
        except Exception:
            pass

    def _update_smart_hide_state(self):
        self._set_smart_hidden(self._keyboard_hidden or self._scroll_hidden)

    def scheduleScrollRestore(self, delayMs=650):
        try:
            delaySec = max(0.05, float(delayMs) / 1000.0)
            dueAt = time.time() + delaySec
            if dueAt > self.scrollRestoreAt:
                self.scrollRestoreAt = dueAt
            if self.scrollRestorePending:
                return
            self.scrollRestorePending = True

            def restoreScroll():
                try:
                    if not self.container:
                        self.scrollRestorePending = False
                        return
                    remainMs = int(max(0.0, (self.scrollRestoreAt - time.time()) * 1000.0))
                    if remainMs > 25:
                        queued = self.runUi(restoreScroll, remainMs)
                        if not queued:
                            self.scrollRestorePending = False
                        return
                    self._scroll_hidden = False
                    self._update_smart_hide_state()
                    self.scrollRestorePending = False
                except Exception:
                    self.scrollRestorePending = False

            queued = self.runUi(restoreScroll, int(delaySec * 1000))
            if not queued:
                self.scrollRestorePending = False
        except Exception:
            self.scrollRestorePending = False

    def _set_smart_hidden(self, hidden):
        if not self.container:
            return
        if hidden == self._smart_hidden:
            self._apply_smart_hide_alpha()
            return

        self._smart_hidden = hidden
        if hidden:
            if not self.is_dragging:
                self._pre_hide_pos = (
                    float(self.container.getTranslationX()),
                    float(self.container.getTranslationY()),
                )
                target = self._get_nearest_corner_target()
                if target:
                    self._animate_to(target[0], target[1], self._base_alpha * 0.45)
                else:
                    self._apply_smart_hide_alpha()
        else:
            if self._pre_hide_pos and not self.is_dragging:
                x, y = self._pre_hide_pos
                self._animate_to(x, y, self._base_alpha)
            else:
                self._apply_smart_hide_alpha()
            self._pre_hide_pos = None

    def _get_nearest_corner_target(self):
        try:
            parent = self.container.getParent()
            if not parent:
                return None
            parent_width = parent.getWidth()
            parent_height = parent.getHeight()
            if parent_width <= 0 or parent_height <= 0:
                return None
            width = self.container.getWidth()
            height = self.container.getHeight()
            if width <= 0 or height <= 0:
                return None
            margin = AndroidUtilities.dp(Dp.S12)
            center_x = self.container.getTranslationX() + width / 2.0
            center_y = self.container.getTranslationY() + height / 2.0
            target_x = margin if center_x < parent_width / 2.0 else parent_width - width - margin
            target_y = margin if center_y < parent_height / 2.0 else parent_height - height - margin
            return (float(target_x), float(target_y))
        except Exception:
            return None

    def _animate_to(self, target_x, target_y, target_alpha):
        try:
            anim_x = ObjectAnimator.ofFloat(
                self.container, "translationX", self.container.getTranslationX(), target_x
            )
            anim_y = ObjectAnimator.ofFloat(
                self.container, "translationY", self.container.getTranslationY(), target_y
            )
            anim_a = ObjectAnimator.ofFloat(
                self.container, "alpha", self.container.getAlpha(), float(target_alpha)
            )
            anim_x.setDuration(180)
            anim_y.setDuration(180)
            anim_a.setDuration(160)
            anim_x.setInterpolator(AccelerateDecelerateInterpolator())
            anim_y.setInterpolator(AccelerateDecelerateInterpolator())
            anim_a.setInterpolator(AccelerateDecelerateInterpolator())
            anim_x.start()
            anim_y.start()
            anim_a.start()
        except Exception:
            try:
                self.container.setTranslationX(float(target_x))
                self.container.setTranslationY(float(target_y))
                self.container.setAlpha(float(target_alpha))
            except Exception:
                pass

    def _attach_smart_hide(self, decor_view):
        if not decor_view:
            return
        if self._smart_hide_view is decor_view:
            return
        if self._smart_hide_view and self._smart_hide_view is not decor_view:
            self._detach_smart_hide()
        self._smart_hide_view = decor_view
        try:
            from java import dynamic_proxy

            def on_global_layout():
                try:
                    if not self.container:
                        return
                    root = decor_view.getRootView() or decor_view
                    rect = Rect()
                    root.getWindowVisibleDisplayFrame(rect)
                    visible_height = rect.height()
                    root_height = root.getHeight()
                    if root_height <= 0:
                        return
                    keyboard_height = max(0, root_height - visible_height)
                    is_keyboard = keyboard_height > AndroidUtilities.dp(Dp.S120)
                    if is_keyboard != self._keyboard_hidden:
                        self._keyboard_hidden = is_keyboard
                        self._update_smart_hide_state()
                except Exception:
                    pass

            def on_scroll_changed():
                try:
                    if not self._keyboard_hidden:
                        self._scroll_hidden = True
                        self._update_smart_hide_state()
                    self.scheduleScrollRestore(650)
                except Exception:
                    pass

            self._layout_listener = dynamic_proxy(ViewTreeObserver.OnGlobalLayoutListener)(
                on_global_layout
            )
            decor_view.getViewTreeObserver().addOnGlobalLayoutListener(
                self._layout_listener
            )
            self._scroll_listener = dynamic_proxy(ViewTreeObserver.OnScrollChangedListener)(
                on_scroll_changed
            )
            decor_view.getViewTreeObserver().addOnScrollChangedListener(
                self._scroll_listener
            )
        except Exception:
            self._layout_listener = None
            self._scroll_listener = None

    def _detach_smart_hide(self):
        if not self._smart_hide_view:
            return
        try:
            observer = self._smart_hide_view.getViewTreeObserver()
            if self._layout_listener:
                try:
                    observer.removeOnGlobalLayoutListener(self._layout_listener)
                except Exception:
                    pass
            if self._scroll_listener:
                try:
                    observer.removeOnScrollChangedListener(self._scroll_listener)
                except Exception:
                    pass
        except Exception:
            pass
        self._layout_listener = None
        self._scroll_listener = None
        self._smart_hide_view = None
        self.scrollRestorePending = False
        self.scrollRestoreAt = 0.0

    def _start_animation(self):
        if not self.plugin_ref or not self.container:
            return
        try:
            if self.animator1:
                self.animator1.cancel()
            if self.animator2:
                self.animator2.cancel()
            if self.animator3:
                self.animator3.cancel()
            if self.animator4:
                self.animator4.cancel()
        except Exception:
            pass

        current_trans_y = self.container.getTranslationY()
        self.container.setRotation(0)
        self.container.setScaleX(1.0)
        self.container.setScaleY(1.0)
        bounce_offset = float(AndroidUtilities.dp(Dp.S2))
        self.animator1 = ObjectAnimator.ofFloat(
            self.container,
            "translationY",
            current_trans_y,
            current_trans_y - bounce_offset,
            current_trans_y + bounce_offset * 0.35,
            current_trans_y,
        )
        self.animator1.setDuration(3400)
        self.animator1.setRepeatCount(ValueAnimator.INFINITE)
        self.animator1.setInterpolator(AccelerateDecelerateInterpolator())
        self.animator1.start()

        if self._xp_ring:
            self.animator4 = ObjectAnimator.ofFloat(self._xp_ring, "alpha", 0.72, 0.96, 0.72)
            self.animator4.setDuration(2800)
            self.animator4.setRepeatCount(ValueAnimator.INFINITE)
            self.animator4.setInterpolator(AccelerateDecelerateInterpolator())
            self.animator4.start()

    def play_entry_animation(self):
        if not self.container:
            return
        try:
            self.container.setScaleX(0.92)
            self.container.setScaleY(0.92)
            self.container.setAlpha(0.0)
            scale_x = ObjectAnimator.ofFloat(self.container, "scaleX", 0.92, 1.0)
            scale_y = ObjectAnimator.ofFloat(self.container, "scaleY", 0.92, 1.0)
            alpha = ObjectAnimator.ofFloat(
                self.container, "alpha", 0.0, float(self._base_alpha)
            )
            scale_x.setDuration(180)
            scale_y.setDuration(180)
            alpha.setDuration(200)
            scale_x.setInterpolator(AccelerateDecelerateInterpolator())
            scale_y.setInterpolator(AccelerateDecelerateInterpolator())
            alpha.setInterpolator(AccelerateDecelerateInterpolator())
            scale_x.start()
            scale_y.start()
            alpha.start()
        except Exception:
            self._apply_smart_hide_alpha()

    def cleanup(self):
        self.log(f"WSP: FloatingPetWidget.cleanup() called for chat {self.chat_id}")
        try:
            if hasattr(self, "animator1") and self.animator1:
                self.animator1.cancel()
                self.animator1 = None
                self.log("WSP: animator1 cancelled")
            if hasattr(self, "animator2") and self.animator2:
                self.animator2.cancel()
                self.animator2 = None
                self.log("WSP: animator2 cancelled")
            if hasattr(self, "animator3") and self.animator3:
                self.animator3.cancel()
                self.animator3 = None
                self.log("WSP: animator3 cancelled")
            if hasattr(self, "animator4") and self.animator4:
                self.animator4.cancel()
                self.animator4 = None
                self.log("WSP: animator4 cancelled")

            if self.view:
                self.view.setOnTouchListener(None)
                self.log("WSP: OnTouchListener removed from view")

            if self.container:
                self.container.setOnTouchListener(None)
                self.container.setRotation(0)
                self.container.setScaleX(1.0)
                self.container.setScaleY(1.0)
                parent = self.container.getParent()
                if parent:
                    self.log(f"WSP: removing widget from parent view")
                    parent.removeView(self.container)
                    self.log(
                        f"WSP: widget view removed from parent for chat {self.chat_id}"
                    )
                else:
                    self.log("WSP: container has no parent, cannot remove")

            self._detach_smart_hide()
            self._plugin_ref = None
            self.view = None
            self.stats_view = None
            self.content = None
            self.ring_outer = None
            self.ring_inner = None
            self._ring_outer_bg = None
            self._ring_inner_bg = None
            self.accRing = None
            self.accRingBg = None
            self.container = None
            self.context = None

            self.log(f"WSP: cleanup completed for widget {self.chat_id}")
        except Exception as e:
            self.log(f"WSP: cleanup error for {self.chat_id}: {e}")

    def onTouchDown(self, view, event):
        if hasattr(self, "animator1") and self.animator1:
            self.animator1.cancel()
        if hasattr(self, "animator2") and self.animator2:
            self.animator2.cancel()
        if hasattr(self, "animator3") and self.animator3:
            self.animator3.cancel()
        if hasattr(self, "animator4") and self.animator4:
            self.animator4.cancel()

        self.offset_x = self.container.getTranslationX()
        self.offset_y = self.container.getTranslationY()

        layout_params = self.container.getLayoutParams()
        if layout_params and hasattr(layout_params, "gravity"):
            layout_params.gravity = Gravity.NO_GRAVITY
            self.container.setLayoutParams(layout_params)

        try:
            animator = ObjectAnimator.ofFloat(self.container, "scaleX", 1.0, 1.045)
            animator.setDuration(90)
            animator.setInterpolator(AccelerateDecelerateInterpolator())
            animator.start()
            animator2 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.0, 1.045)
            animator2.setDuration(90)
            animator2.setInterpolator(AccelerateDecelerateInterpolator())
            animator2.start()
        except Exception:
            pass

    def onDrag(self, view, event, dx, dy):
        if not self.user_has_moved:
            self.user_has_moved = True
            self.log(f"WSP: user started dragging widget")

        new_x = self.offset_x + dx
        new_y = self.offset_y + dy
        self.container.setTranslationX(new_x)
        self.container.setTranslationY(new_y)

    def onClick(self, view, event):
        UI.bump(self.container, 1.035, 140)

        def show_pet_menu():
            try:
                context = get_last_fragment()
                if context:
                    activity = context.getParentActivity()
                    if activity:
                        menu = PetStatsBottomSheet(
                            activity, self.plugin_ref, self.chat_id
                        )
                        menu.show()
            except Exception as e:
                self.log(f"WSP: failed to show pet menu: {e}")

                self.log(f"WSP: traceback: {traceback.format_exc()}")
                bulletin_safe(
                    "error",
                    tr(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é: {e}", f"Failed to open menu: {e}"),
                )

        self.runUiOnce("petMenu", 0, show_pet_menu)

    def onTouchUp(self, view, event):
        if self.is_dragging:
            self.offset_x = self.container.getTranslationX()
            self.offset_y = self.container.getTranslationY()
            if self.plugin_ref and self.chat_id:
                self.plugin_ref.widget_positions[self.chat_id] = {
                    "x": float(self.offset_x),
                    "y": float(self.offset_y),
                }
                self.plugin_ref.saveSoon()

        self._start_animation()
        self._update_smart_hide_state()

    def get_view(self):
        return self.container


class FlyingXPParticle:
    def __init__(self, context, start_x, start_y, end_x, end_y, xp_amount, callback):
        self.container = FrameLayout(context)
        self.flame_view = TextView(context)
        self.xp_view = TextView(context)
        self.callback = callback
        self.animators = []
        self.log = log

        container_size = AndroidUtilities.dp(Dp.S40)
        self.container.setLayoutParams(
            FrameLayout.LayoutParams(container_size, container_size)
        )

        self.flame_view.setText("üî•")
        self.flame_view.setTextSize(1, 24)
        self.flame_view.setGravity(Gravity.CENTER)
        flame_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
        )
        self.flame_view.setLayoutParams(flame_params)

        self.xp_view.setText(f"+{xp_amount}")
        self.xp_view.setTextSize(1, 10)
        self.xp_view.setTextColor(Color.parseColor("#FFD700"))
        self.xp_view.setGravity(Gravity.CENTER)
        self.xp_view.setTypeface(None, Typeface.BOLD)
        xp_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT
        )
        xp_params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL
        self.xp_view.setLayoutParams(xp_params)

        self.container.addView(self.flame_view)
        self.container.addView(self.xp_view)

        self.container.setX(start_x)
        self.container.setY(start_y)
        self.container.setAlpha(0.0)
        self.container.setScaleX(0.3)
        self.container.setScaleY(0.3)

        self._zapustit_polet(start_x, start_y, end_x, end_y)

    def _zapustit_polet(self, start_x, start_y, end_x, end_y):
        alpha_in = ObjectAnimator.ofFloat(self.container, "alpha", 0.0, 0.95)
        alpha_in.setDuration(120)
        alpha_in.start()
        self.animators.append(alpha_in)

        scale_in = ObjectAnimator.ofFloat(self.container, "scaleX", 0.3, 1.0)
        scale_in.setDuration(120)
        scale_in.start()
        self.animators.append(scale_in)

        scale_in2 = ObjectAnimator.ofFloat(self.container, "scaleY", 0.3, 1.0)
        scale_in2.setDuration(120)
        scale_in2.start()
        self.animators.append(scale_in2)

        def _start_movement():
            duration = 520
            anim_x = ObjectAnimator.ofFloat(self.container, "x", start_x, end_x)
            anim_x.setDuration(duration)
            anim_x.setInterpolator(AccelerateDecelerateInterpolator())
            anim_x.start()
            self.animators.append(anim_x)

            anim_y = ObjectAnimator.ofFloat(self.container, "y", start_y, end_y)
            anim_y.setDuration(duration)
            anim_y.setInterpolator(AccelerateDecelerateInterpolator())
            anim_y.start()
            self.animators.append(anim_y)

            def _finish():
                self._explosion_animation()

            run_on_ui_thread(_finish, duration)

        run_on_ui_thread(_start_movement, 120)

    def _explosion_animation(self):
        scale_up = ObjectAnimator.ofFloat(self.container, "scaleX", 1.0, 1.45)
        scale_up.setDuration(130)
        scale_up.start()
        self.animators.append(scale_up)

        scale_up2 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.0, 1.45)
        scale_up2.setDuration(130)
        scale_up2.start()
        self.animators.append(scale_up2)

        alpha_out = ObjectAnimator.ofFloat(self.container, "alpha", 0.95, 0.0)
        alpha_out.setDuration(130)
        alpha_out.start()
        self.animators.append(alpha_out)

        def _cleanup():
            if self.callback:
                self.callback()

        run_on_ui_thread(_cleanup, 130)

    def get_view(self):
        return self.container

    def cleanup(self):
        try:
            for animator in self.animators:
                if animator:
                    animator.cancel()
            self.animators.clear()
            self.callback = None
            self.flame_view = None
            self.xp_view = None
            self.container = None
        except Exception as e:
            self.log(f"WSP: FloatingFlameParticle cleanup error: {e}")


# –µ–±–ª—è
class ChatActivityHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin) if plugin else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref
            if not plugin:
                return
            activity = param.thisObject
            dialog_id = activity.getDialogId()
            chat_id_str = str(dialog_id)
            is_private_dialog = plugin.isPrivateDialog(activity, chat_id_str)
            if not is_private_dialog:
                return
            if plugin.guardAction(f"hook:{chat_id_str}", 0.4):
                return

            if is_private_dialog:
                existing_widget = None
                with plugin.data_lock:
                    existing_widget = plugin.active_widgets.get(chat_id_str)
                if existing_widget:
                    try:
                        existing_view = existing_widget.get_view()
                    except Exception:
                        existing_view = None
                    if existing_view and existing_view.getParent():
                        try:
                            existing_widget._update_visual()
                        except Exception:
                            pass
                        return
                sync_mode = plugin.getSyncMode()
                if sync_mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    current_time = time.time()
                    last_sync_time = 0
                    with plugin.data_lock:
                        last_sync_time = plugin.last_auto_sync.get(chat_id_str, 0)
                    sync_interval_index = plugin.get_setting(
                        "auto_sync_interval", 1
                    )
                    sync_interval_map = [30, 60, 120, 300, 999999]
                    sync_interval = (
                        sync_interval_map[sync_interval_index]
                        if sync_interval_index < len(sync_interval_map)
                        else 60
                    )

                    if current_time - last_sync_time >= sync_interval:
                        if not plugin.shouldCheckServerFast(
                            chat_id_str, sync_interval
                        ):
                            self.log(
                                f"WSP: skipping auto-sync for {chat_id_str}, shared cooldown"
                            )
                        else:
                            def do_auto_sync():
                                try:
                                    sync_manager = plugin.getSyncMgr(chat_id=chat_id_str)
                                    if not sync_manager:
                                        return
                                    if sync_manager.mode not in [
                                        StreakSyncManager.MODE_SERVER,
                                        StreakSyncManager.MODE_AUTO,
                                    ]:
                                        return
                                    if not sync_manager.checkServerHealth():
                                        plugin.recordSyncStatus(
                                            chat_id_str,
                                            "auto:server",
                                            False,
                                            "server_unavailable",
                                        )
                                        return
                                    my_user_id = plugin.getMyId()
                                    self.log(
                                        f"WSP: auto-sync got my_user_id={my_user_id}"
                                    )

                                    if my_user_id and my_user_id > 0:
                                        self.log(
                                            f"WSP: checking server for streak with chat {chat_id_str}"
                                        )
                                        server_data = (
                                            sync_manager.get_streak_from_server(
                                                my_user_id, chat_id_str
                                            )
                                        )

                                        if server_data:
                                            if server_data.get("deleted", False):
                                                local_streak = None
                                                apply_delete = True
                                                did_reset = False
                                                with self.plugin_ref.data_lock:
                                                    if (
                                                        chat_id_str
                                                        in self.plugin_ref.streak_enabled_chats
                                                    ):
                                                        streak_key = (
                                                            self.plugin_ref.getStreakKey(
                                                                chat_id_str
                                                            )
                                                        )
                                                        local_streak = (
                                                            self.plugin_ref.streaks.get(
                                                                streak_key
                                                            )
                                                        )
                                                        if (
                                                            local_streak
                                                            and not local_streak.deleted
                                                        ):
                                                            apply_delete = (
                                                                self.plugin_ref.shouldApplyRemoteDelete(
                                                                    local_streak,
                                                                    server_data,
                                                                    "server",
                                                                )
                                                            )

                                                    if not apply_delete:
                                                        self.log(
                                                            f"WSP: server streak deleted, keeping local for {chat_id_str}"
                                                        )
                                                    elif (
                                                        chat_id_str
                                                        in self.plugin_ref.streak_enabled_chats
                                                    ):
                                                        self.plugin_ref.streak_enabled_chats.discard(
                                                            chat_id_str
                                                        )
                                                        if local_streak:
                                                            self.plugin_ref.markStreakDeleted(
                                                                local_streak
                                                            )
                                                        did_reset = True

                                                if not apply_delete and local_streak:
                                                    self.plugin_ref.logSyncDecision(
                                                        "streak",
                                                        chat_id_str,
                                                        "server",
                                                        "keep_local",
                                                        reason="remote_deleted",
                                                        local_ts=local_streak.get_sync_data().get("timestamp"),
                                                        remote_ts=server_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.runAsync(
                                                        self.plugin_ref.syncStreak,
                                                        chat_id_str,
                                                        local_streak,
                                                        True,
                                                    )
                                                elif did_reset:
                                                    self.plugin_ref.logSyncDecision(
                                                        "streak",
                                                        chat_id_str,
                                                        "server",
                                                        "accept_delete",
                                                        reason="remote_deleted",
                                                        local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                                                        remote_ts=server_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.saveSoon()
                                                    self.log(
                                                        f"WSP: streak deleted by sync for {chat_id_str}, reset to 0"
                                                    )
                                            elif server_data.get("count", 0) > 0:
                                                if (
                                                    chat_id_str
                                                    in self.plugin_ref.streak_enabled_chats
                                                ):
                                                    streak_key = (
                                                        self.plugin_ref.getStreakKey(
                                                            chat_id_str
                                                        )
                                                    )
                                                    streak = (
                                                        self.plugin_ref.streaks.get(
                                                            streak_key
                                                        )
                                                    )
                                                if streak:
                                                    result = (
                                                        self.plugin_ref.mergeRemoteSync(
                                                            "streak",
                                                            chat_id_str,
                                                            streak,
                                                            server_data,
                                                            "server",
                                                            update_hash=True,
                                                        )
                                                    )
                                                    if result["applied"]:
                                                        self.plugin_ref.saveSoon()
                                                        self.log(
                                                            f"WSP: merged streak from server for {chat_id_str}, count={server_data.get('count', 0)}"
                                                        )
                                                    else:
                                                        self.log(
                                                            f"WSP: local streak is newer, keeping it"
                                                        )
                                                else:
                                                    with self.plugin_ref.data_lock:
                                                        self.plugin_ref.streak_enabled_chats.add(
                                                            chat_id_str
                                                        )
                                                    streak = (
                                                        self.plugin_ref.getOrCreateStreak(
                                                            chat_id_str
                                                        )
                                                    )
                                                    if streak:
                                                        streak.apply_sync_data(
                                                            server_data,
                                                            source="server",
                                                        )
                                                        self.plugin_ref.setSyncedHash(
                                                            chat_id_str,
                                                            streak_data=streak.get_sync_data(),
                                                        )
                                                        self.plugin_ref.saveSoon()
                                                        self.log(
                                                            f"WSP: auto-enabled streak from server for {chat_id_str}, count={server_data.get('count', 0)}"
                                                        )
                                            else:
                                                self.log(
                                                    f"WSP: streak on server has 0 count"
                                                )
                                        else:
                                            self.log(
                                                f"WSP: no streak found on server for chat {chat_id_str}"
                                            )

                                        self.log(
                                            f"WSP: checking server for pet with chat {chat_id_str}"
                                        )
                                        user1_id, user2_id = (
                                            self.plugin_ref.getSortedIds(
                                                chat_id_str
                                            )
                                        )
                                        if not user1_id:
                                            self.log(
                                                f"WSP: invalid ids for pet server check: {chat_id_str}"
                                            )
                                            return
                                        pet_data = sync_manager.get_pet_from_server(
                                            user1_id, user2_id
                                        )
                                        if pet_data:
                                            if pet_data.get("deleted", False):
                                                local_pet = None
                                                apply_delete = True
                                                did_reset = False
                                                with self.plugin_ref.data_lock:
                                                    if (
                                                        chat_id_str
                                                        in self.plugin_ref.pet_enabled_chats
                                                    ):
                                                        local_pet = self.plugin_ref.pets.get(
                                                            chat_id_str
                                                        )
                                                        if (
                                                            local_pet
                                                            and not local_pet.deleted
                                                        ):
                                                            apply_delete = (
                                                                self.plugin_ref.shouldApplyRemoteDelete(
                                                                    local_pet,
                                                                    pet_data,
                                                                    "server",
                                                                )
                                                            )

                                                    if not apply_delete:
                                                        self.log(
                                                            f"WSP: server pet deleted, keeping local for {chat_id_str}"
                                                        )
                                                    elif (
                                                        chat_id_str
                                                        in self.plugin_ref.pet_enabled_chats
                                                    ):
                                                        self.plugin_ref.pet_enabled_chats.discard(
                                                            chat_id_str
                                                        )
                                                        if local_pet:
                                                            self.plugin_ref.markPetDeleted(
                                                                local_pet
                                                            )
                                                        did_reset = True

                                                if not apply_delete and local_pet:
                                                    self.plugin_ref.logSyncDecision(
                                                        "pet",
                                                        chat_id_str,
                                                        "server",
                                                        "keep_local",
                                                        reason="remote_deleted",
                                                        local_ts=local_pet.get_sync_data().get("timestamp"),
                                                        remote_ts=pet_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.runAsync(
                                                        self.plugin_ref.syncPet,
                                                        chat_id_str,
                                                        local_pet,
                                                        True,
                                                    )
                                                elif did_reset:
                                                    self.plugin_ref.logSyncDecision(
                                                        "pet",
                                                        chat_id_str,
                                                        "server",
                                                        "accept_delete",
                                                        reason="remote_deleted",
                                                        local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                                                        remote_ts=pet_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.saveSoon()
                                                    self.log(
                                                        f"WSP: pet deleted by sync for {chat_id_str}"
                                                    )
                                            elif not pet_data.get("deleted", False):
                                                with self.plugin_ref.data_lock:
                                                    self.plugin_ref.pet_enabled_chats.add(
                                                        chat_id_str
                                                    )
                                                pet = (
                                                    self.plugin_ref.getOrCreatePet(
                                                        chat_id_str
                                                    )
                                                )
                                                result = (
                                                    self.plugin_ref.mergeRemoteSync(
                                                        "pet",
                                                        chat_id_str,
                                                        pet,
                                                        pet_data,
                                                        "server",
                                                        update_hash=True,
                                                    )
                                                )
                                                if result["applied"]:
                                                    self.plugin_ref.saveSoon()
                                                    self.log(
                                                        f"WSP: pet auto-enabled and merged from server for {chat_id_str}, xp={pet_data.get('xp')}, stage={pet_data.get('stage')}"
                                                    )
                                                else:
                                                    self.log(
                                                        f"WSP: local pet is newer, keeping it"
                                                    )
                                            else:
                                                self.log(
                                                    f"WSP: pet on server is deleted, skipping"
                                                )
                                        else:
                                            self.log(
                                                f"WSP: no pet found on server for chat {chat_id_str}"
                                            )
                                    else:
                                        self.log(
                                            f"WSP: cannot auto-sync, my_user_id is invalid ({my_user_id})"
                                        )

                                    with self.plugin_ref.data_lock:
                                        self.plugin_ref.last_auto_sync[chat_id_str] = (
                                            time.time()
                                        )

                                except Exception as e:
                                    self.log(f"WSP: failed to auto-sync: {e}")

                                    self.log(
                                        f"WSP: auto-sync traceback: {traceback.format_exc()}"
                                    )

                            self.plugin_ref.runAsync(do_auto_sync)
                    else:
                        self.log(
                            f"WSP: skipping auto-sync for {chat_id_str}, synced {int(current_time - last_sync_time)}s ago"
                        )

            show_widget = plugin.get_setting("show_widget", True)

            if not show_widget:
                return

            pet_enabled = False
            pet_exists = False
            with plugin.data_lock:
                pet_enabled = chat_id_str in plugin.pet_enabled_chats
                pet_exists = chat_id_str in plugin.pets
            if not pet_enabled:
                self.log(
                    f"WSP: skipping widget for {chat_id_str} - pet not enabled by user"
                )
                return

            if not pet_exists:
                self.log(f"WSP: skipping widget for {chat_id_str} - pet not found")
                return

            try:
                LaunchActivity = getattr(plugin, "_launch_activity_class", None)
                if not LaunchActivity:
                    LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                    plugin._launch_activity_class = LaunchActivity
                launch_activity = None

                for fname in ("instance", "Instance", "INSTANCE", "lastInstance"):
                    try:
                        launch_activity = getattr(LaunchActivity, fname, None)
                        if launch_activity:
                            break
                    except Exception:
                        pass

                if not launch_activity:
                    self.log("WSP: LaunchActivity not found!")
                    return

                window = launch_activity.getWindow()
                if not window:
                    self.log("WSP: window is None!")
                    return

                decor_view = window.getDecorView()
                if not decor_view:
                    self.log("WSP: decor_view is None!")
                    return
            except Exception as e:
                self.log(f"WSP: failed to get DecorView: {e}")
                return

            if plugin.widget_manager:
                existing_widget = None
                old_chat_ids = []
                with plugin.data_lock:
                    existing_widget = plugin.active_widgets.get(chat_id_str)
                    old_chat_ids = [
                        cid for cid in list(plugin.active_widgets.keys()) if cid != chat_id_str
                    ]

                if existing_widget:
                    try:
                        existing_view = existing_widget.get_view()
                    except Exception:
                        existing_view = None
                    if existing_view and existing_view.getParent() is decor_view:
                        try:
                            existing_widget._update_visual()
                        except Exception:
                            pass
                        return

                for old_chat_id in old_chat_ids:
                    try:
                        plugin.widget_manager.remove_widgets_for_chat(old_chat_id)
                    except Exception as e:
                        self.log(f"WSP: failed to cleanup previous widget {old_chat_id}: {e}")

                widget = plugin.widget_manager.create_pet_widget(chat_id_str, decor_view)
                if widget:
                    with plugin.data_lock:
                        plugin.active_widgets[chat_id_str] = widget
                    self.log(
                        f"WSP: floating widget added successfully! chat={chat_id_str}"
                    )
            else:
                self.log("WSP: widget_manager is None, cannot create widget")

        except Exception as e:
            self.log(f"WSP floating widget fail: {e}")

            self.log(f"WSP traceback: {traceback.format_exc()}")


class WidgetManager:
    def __init__(self, plugin_ref):
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None
        self.active_pet_widgets = {}

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def runUiOnce(self, key, delayMs, func):
        p = self.plugin
        if p and hasattr(p, "runUiOnce"):
            return p.runUiOnce(key, delayMs, func)
        try:
            return bool(run_on_ui_thread(func, delayMs))
        except Exception:
            return False

    def create_pet_widget(self, chat_id, decor_view):
        try:
            old_widget = None
            canScanStale = bool(self.active_pet_widgets)
            plugin = self.plugin
            if not canScanStale and plugin:
                with plugin.data_lock:
                    canScanStale = bool(plugin.active_widgets)
            if canScanStale:
                old_widget = decor_view.findViewWithTag("telepet_floating")
            if old_widget:
                cleaned_widgets = set()
                stale_chat_ids = []
                for stale_chat_id, stale_widget in list(self.active_pet_widgets.items()):
                    same_view = False
                    try:
                        same_view = (
                            stale_widget
                            and hasattr(stale_widget, "get_view")
                            and stale_widget.get_view() is old_widget
                        )
                    except Exception:
                        same_view = False
                    if same_view:
                        stale_chat_ids.append(stale_chat_id)
                        try:
                            wid = id(stale_widget)
                            if wid not in cleaned_widgets and hasattr(stale_widget, "cleanup"):
                                stale_widget.cleanup()
                                cleaned_widgets.add(wid)
                        except Exception as e:
                            self.log(f"WSP: failed to cleanup stale widget {stale_chat_id}: {e}")
                for stale_chat_id in stale_chat_ids:
                    self.active_pet_widgets.pop(stale_chat_id, None)

                if plugin:
                    stale_active = []
                    with plugin.data_lock:
                        for stale_chat_id, stale_widget in list(plugin.active_widgets.items()):
                            same_view = False
                            try:
                                same_view = (
                                    stale_widget
                                    and hasattr(stale_widget, "get_view")
                                    and stale_widget.get_view() is old_widget
                                )
                            except Exception:
                                same_view = False
                            if same_view:
                                stale_active.append((stale_chat_id, stale_widget))
                                plugin.active_widgets.pop(stale_chat_id, None)
                    for stale_chat_id, stale_widget in stale_active:
                        try:
                            wid = id(stale_widget)
                            if wid not in cleaned_widgets and hasattr(stale_widget, "cleanup"):
                                stale_widget.cleanup()
                                cleaned_widgets.add(wid)
                        except Exception as e:
                            self.log(f"WSP: failed to cleanup stale active widget {stale_chat_id}: {e}")

                try:
                    decor_view.removeView(old_widget)
                except Exception:
                    pass

            if chat_id in self.active_pet_widgets:
                old = self.active_pet_widgets[chat_id]
                if hasattr(old, "cleanup"):
                    old.cleanup()
                del self.active_pet_widgets[chat_id]

            context = decor_view.getContext()
            widget = FloatingPetWidget(context, self.plugin, chat_id)
            widget_view = widget.get_view()
            widget_view.setTag("telepet_floating")
            widget._attach_smart_hide(decor_view)

            layout_params = widget_view.getLayoutParams()
            if not layout_params:
                size_px = AndroidUtilities.dp(Dp.S160)
                layout_params = FrameLayout.LayoutParams(size_px, size_px)

            decor_view.addView(widget_view, layout_params)
            self.active_pet_widgets[chat_id] = widget

            position = self.plugin.get_setting("widget_position", 0)
            margin_dp = 16

            def set_initial_position():
                try:
                    if hasattr(widget, "user_has_moved") and widget.user_has_moved:
                        return

                    if chat_id in self.plugin.widget_positions:
                        saved_pos = self.plugin.widget_positions[chat_id]
                        saved_x = saved_pos.get("x", 0)
                        saved_y = saved_pos.get("y", 0)

                        parent_width = decor_view.getWidth()
                        parent_height = decor_view.getHeight()
                        widget_size = AndroidUtilities.dp(Dp.S80)
                        margin = AndroidUtilities.dp(Dp.S8)

                        max_x = parent_width - widget_size - margin
                        max_y = parent_height - widget_size - margin

                        widget.offset_x = max(margin, min(saved_x, max_x))
                        widget.offset_y = max(margin, min(saved_y, max_y))
                    else:
                        margin_px = AndroidUtilities.dp(margin_dp)
                        widget_width = widget_view.getWidth()
                        widget_height = widget_view.getHeight()

                        if position == 0:
                            widget.offset_x = margin_px
                            widget.offset_y = margin_px
                        elif position == 1:
                            parent_width = decor_view.getWidth()
                            widget.offset_x = parent_width - widget_width - margin_px
                            widget.offset_y = margin_px
                        elif position == 2:
                            parent_height = decor_view.getHeight()
                            widget.offset_x = margin_px
                            widget.offset_y = parent_height - widget_height - margin_px
                        else:
                            parent_width = decor_view.getWidth()
                            parent_height = decor_view.getHeight()
                            widget.offset_x = parent_width - widget_width - margin_px
                            widget.offset_y = parent_height - widget_height - margin_px

                    widget_view.setTranslationX(widget.offset_x)
                    widget_view.setTranslationY(widget.offset_y)
                    widget._start_animation()
                    widget.play_entry_animation()
                except Exception as e:
                    self.log(f"WSP: error setting widget position: {e}")

            self.runUiOnce(f"widgetPos:{chat_id}", 16, set_initial_position)

            pet = self.plugin.pets.get(chat_id)

            return widget
        except Exception as e:
            self.log(f"WSP: failed to create pet widget: {e}")
            return None

    def remove_widgets_for_chat(self, chat_id):
        removed = False
        cleaned_widgets = set()
        if chat_id in self.active_pet_widgets:
            try:
                widget = self.active_pet_widgets.pop(chat_id, None)
                if widget and hasattr(widget, "cleanup"):
                    widget.cleanup()
                    cleaned_widgets.add(id(widget))
                removed = True
            except Exception as e:
                self.log(f"WSP: error removing pet widget: {e}")
        plugin = self.plugin
        if plugin:
            try:
                widget = None
                with plugin.data_lock:
                    widget = plugin.active_widgets.pop(chat_id, None)
                if widget and id(widget) not in cleaned_widgets and hasattr(widget, "cleanup"):
                    widget.cleanup()
                    cleaned_widgets.add(id(widget))
                if widget is not None:
                    removed = True
            except Exception as e:
                self.log(f"WSP: error removing active widget ref: {e}")
        if removed:
            self.log(f"WSP: removed pet widget for {chat_id}")


class WidgetCleanupHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin) if plugin else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref
            if not plugin:
                return
            activity = param.thisObject
            dialog_id = activity.getDialogId()
            chat_id_str = str(dialog_id)
            if not plugin.isPrivateDialog(activity, chat_id_str):
                return
            if plugin.guardAction(f"pause:{chat_id_str}", 0.25):
                return

            if plugin.widget_manager:
                plugin.widget_manager.remove_widgets_for_chat(chat_id_str)

        except Exception as e:
            self.log(f"WSP cleanup hook fail: {e}")

            self.log(f"WSP cleanup traceback: {traceback.format_exc()}")


# —à–∏—Ç—ã
class PetMenuBottomSheet(SafeSheet):
    def __init__(self, context, plugin, chat_id):
        super().__init__(context, plugin, chat_id)
        self.pet = plugin.pets.get(chat_id) if plugin else None
        if self.pet:
            self._init_sheet(with_handle=False)

    def _build_content(self, content):
        if not self.pet:
            return

        self._add_header(content, self.pet.get_emoji(), self.pet.name, self.pet.get_stage_name())
        self._add_divider(content)

        stats = LinearLayout(self.context)
        stats.setOrientation(LinearLayout.VERTICAL)
        stats.setPadding(AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S16),
                         AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S16))

        self._add_info_row(stats, S.XP, f"{self.pet.xp} XP")
        self._add_info_row(stats, S.MOOD, f"{self.pet.mood}%")

        xp_to_next = self.pet.xp_to_next_stage()
        if xp_to_next > 0:
            self._add_info_row(stats, S.NEXT_STAGE, f"{xp_to_next} XP")
        else:
            self._add_info_row(stats, S.MAX_LEVEL, tr("–ú–∞–∫—Å–∏–º—É–º", "Max"))

        self._add_progress_bar(stats)
        content.addView(stats)

    def _add_progress_bar(self, container):
        progress_wrap = LinearLayout(self.context)
        progress_wrap.setOrientation(LinearLayout.VERTICAL)
        progress_wrap.setPadding(AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S8),
                                  AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S8))

        label = TextView(self.context)
        label.setText(tr("–ü—Ä–æ–≥—Ä–µ—Å—Å", "Progress"))
        label.setTextSize(1, 14)
        label.setTextColor(UI.on_surface())
        progress_wrap.addView(label)

        current_xp = PET_STAGES[self.pet.stage]["xp"]
        if self.pet.stage >= len(PET_STAGES) - 1:
            fill = 100
        else:
            next_xp = PET_STAGES[self.pet.stage + 1]["xp"]
            xp_range = next_xp - current_xp
            fill = int((self.pet.xp - current_xp) / xp_range * 100) if xp_range > 0 else 100

        bar = LinearLayout(self.context)
        bar.setOrientation(LinearLayout.HORIZONTAL)
        bar.setBackgroundColor(UI.outline())
        bar_params = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(Dp.S8))
        bar_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

        fg = View(self.context)
        fg.setBackgroundColor(Color.parseColor("#FFD700"))
        bar.addView(fg, LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), fill))

        bg = View(self.context)
        bg.setBackgroundColor(Color.TRANSPARENT)
        bar.addView(bg, LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), 100 - fill))

        progress_wrap.addView(bar, bar_params)
        container.addView(progress_wrap)

    def _build_buttons(self):
        feed_btn = UI.button(self.context, S.FEED_SHORT,
                             lambda v: self.do_action(lambda p, c: p.feed_pet({"chat_id": c})), "filled")
        close_btn = UI.button(self.context, S.CLOSE, lambda v: self.dismiss(), "text")
        return self._create_button_row(feed_btn, close_btn)


class EvolutionBottomSheet:
    def __init__(self, context, pet):
        self.context = context
        self.pet = pet
        self.log = log
        self._dismissed = False
        self._dismiss_listener = None

        self.bottom_sheet = BottomSheet(context, False)

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(UI.surface())
        UI.elevation(container, ELEVATION_SHEET)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setBackgroundColor(UI.surface())

        header = LinearLayout(context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.BTN_H),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.BTN_H),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(0)
        try:
            bg.setGradientType(GradientDrawable.LINEAR_GRADIENT)
            color1 = jint32(0xFFFF6B9D)
            color2 = jint32(0xFFC06FBB)
            bg.setColors([color1, color2])
            bg.setOrientation(GradientDrawable.Orientation.TL_BR)
        except Exception:
            bg.setColor(jint32(0xFFFF6B9D))
        header.setBackground(bg)

        sparkle = TextView(context)
        sparkle.setText("‚ú®")
        sparkle.setTextSize(1, 48)
        sparkle.setGravity(Gravity.CENTER)
        header.addView(sparkle)

        title_tv = TextView(context)
        title_tv.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è", "Evolution"))
        title_tv.setTextSize(1, 28)
        title_tv.setTextColor(jint32(0xFFFFFFFF))
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        header.addView(title_tv, title_params)

        emoji = pet.get_emoji()
        emoji_tv = TextView(context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 96)
        emoji_tv.setGravity(Gravity.CENTER)
        emoji_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        emoji_params.setMargins(0, AndroidUtilities.dp(Dp.S24), 0, 0)
        header.addView(emoji_tv, emoji_params)

        stage_name = pet.get_stage_name()
        name_tv = TextView(context)
        name_tv.setText(
            tr(
                f"{pet.name} —Å—Ç–∞–ª {stage_name}",
                f"{pet.name} became {stage_name}",
            )
        )
        name_tv.setTextSize(1, 18)
        name_tv.setTextColor(jint32(0xFFFFFFFF))
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        header.addView(name_tv, name_params)

        level_tv = TextView(context)
        level_tv.setText(tr(f"–£—Ä–æ–≤–µ–Ω—å {pet.stage}", f"Level {pet.stage}"))
        level_tv.setTextSize(1, 16)
        level_tv.setTextColor(jint32(0xFFFFFFFF))
        level_tv.setGravity(Gravity.CENTER)
        level_tv.setAlpha(0.9)
        level_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        level_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(level_tv, level_params)

        content.addView(header)

        button_container = LinearLayout(context)
        button_container.setOrientation(LinearLayout.VERTICAL)
        button_container.setBackgroundColor(UI.surface())

        divider = View(context)
        divider.setBackgroundColor(Theme.getColor(Theme.key_divider))
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 1
        )
        button_container.addView(divider, divider_params)

        button_row = LinearLayout(context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)
        button_row.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        close_btn = TextView(context)
        close_btn.setText(tr("–ì–æ—Ç–æ–≤–æ", "Done"))
        close_btn.setTextSize(1, 15)
        close_btn.setTextColor(Theme.getColor(Theme.key_featuredStickers_buttonText))
        close_btn.setGravity(Gravity.CENTER)
        close_btn.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
        )
        close_btn.setTypeface(None, Typeface.BOLD)

        bg_btn = UI.bg_ripple(Dp.CORNER_LG, UI.primary(), UI.on_primary())
        close_btn.setBackground(bg_btn)
        close_btn.setTextColor(UI.on_primary())
        UI.elevation(close_btn, ELEVATION_BUTTON)

        close_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))

        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        button_row.addView(close_btn, button_params)

        button_container.addView(button_row)

        container.addView(content)
        container.addView(button_container)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        try:
            if self.bottom_sheet and self._dismiss_listener:
                self.bottom_sheet.setOnDismissListener(None)
        except Exception:
            pass
        self.pet = None
        self.context = None
        self.bottom_sheet = None
        self._dismiss_listener = None

    def show(self):
        try:
            self.bottom_sheet.show()
        except Exception as e:
            self.log(f"WSP: error showing evolution: {e}")

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing evolution: {e}")
        finally:
            self.onDismiss()


class PetStatsBottomSheet:
    def __init__(self, context, plugin, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin) if plugin else None
        self.chat_id = chat_id
        self.bottom_sheet = BottomSheet(context, False)
        self._dismissed = False
        self._dismiss_listener = None

        if not plugin:
            self.log("WSP ERROR: plugin is None in PetStatsBottomSheet.__init__")
            self._build_error_screen()
            return

        pet = plugin.pets.get(chat_id)
        streak = plugin.getOrCreateStreak(chat_id)
        is_active = chat_id in plugin.pet_enabled_chats

        if not pet and not is_active:
            self._build_invite_screen()
            return

        if not is_active:
            self._build_activation_screen(pet)
            return

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackground(UI.bg_sheet())

        handle_container = LinearLayout(context)
        handle_container.setOrientation(LinearLayout.VERTICAL)
        handle_container.setGravity(Gravity.CENTER)
        handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

        handle = View(context)
        handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
        handle_bg = GradientDrawable()
        handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        handle_bg.setColor(UI.outline())
        handle.setBackground(handle_bg)
        handle_container.addView(handle, handle_params)
        container.addView(handle_container)

        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)

        self._build_header(content, pet)
        self._build_status_cards(content, pet, streak)
        self._build_evolution_section(content, pet)

        scroll_view.addView(content)

        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        button_container = self._create_buttons(is_active, pet)
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        container.addView(button_container, button_params)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def animateIn(self, view, delayMs=0, shiftDp=8):
        if not view:
            return
        try:
            shift = float(AndroidUtilities.dp(int(shiftDp)))
            view.setAlpha(0.0)
            view.setTranslationY(shift)
            view.setScaleX(0.985)
            view.setScaleY(0.985)
        except Exception:
            return

        def run():
            try:
                alpha = ObjectAnimator.ofFloat(view, "alpha", 0.0, 1.0)
                move = ObjectAnimator.ofFloat(view, "translationY", view.getTranslationY(), 0.0)
                sx = ObjectAnimator.ofFloat(view, "scaleX", view.getScaleX(), 1.0)
                sy = ObjectAnimator.ofFloat(view, "scaleY", view.getScaleY(), 1.0)
                for anim in (alpha, move, sx, sy):
                    anim.setDuration(220)
                    anim.setInterpolator(AccelerateDecelerateInterpolator())
                    anim.start()
            except Exception:
                try:
                    view.setAlpha(1.0)
                    view.setTranslationY(0.0)
                    view.setScaleX(1.0)
                    view.setScaleY(1.0)
                except Exception:
                    pass

        if delayMs and delayMs > 0:
            run_on_ui_thread(run, int(delayMs))
        else:
            run_on_ui_thread(run)

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        try:
            if self.bottom_sheet and self._dismiss_listener:
                self.bottom_sheet.setOnDismissListener(None)
        except Exception:
            pass
        self._plugin_ref = None
        self.context = None
        self.chat_id = None
        self.bottom_sheet = None
        self._dismiss_listener = None

    def _build_error_screen(self):
        error_tv = TextView(self.context)
        error_tv.setText(
            tr("–ü–ª–∞–≥–∏–Ω –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω", "Plugin not initialized")
        )
        error_tv.setTextSize(1, 16)
        error_tv.setTextColor(UI.error())
        error_tv.setGravity(Gravity.CENTER)
        error_tv.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )
        self.bottom_sheet.setCustomView(error_tv)
        self.attachDismissListener()

    def _build_invite_screen(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setGravity(Gravity.CENTER)
        container.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )

        container.setBackground(UI.bg_sheet())

        emoji_tv = TextView(self.context)
        emoji_tv.setText("ü•ö")
        emoji_tv.setTextSize(1, 72)
        emoji_tv.setGravity(Gravity.CENTER)
        container.addView(emoji_tv)

        title_tv = TextView(self.context)
        title_tv.setText(tr("–ü–∏—Ç–æ–º–µ—Ü", "Pet"))
        title_tv.setTextSize(1, 24)
        title_tv.setTextColor(UI.on_surface())
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        container.addView(title_tv, title_params)

        desc_tv = TextView(self.context)
        desc_tv.setText(
            tr(
                "–ü–∏—à–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å XP\n–∏ —Ä–∞—Å—Ç–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞",
                "Write to earn XP\nand grow your pet",
            )
        )
        desc_tv.setTextSize(1, 14)
        desc_tv.setTextColor(UI.on_surface())
        desc_tv.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        container.addView(desc_tv, desc_params)

        selected_skin = {"value": 0}

        stages_preview = self._create_stages_preview(selected_skin["value"])
        stages_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        stages_params.setMargins(0, AndroidUtilities.dp(Dp.S24), 0, 0)
        container.addView(stages_preview, stages_params)

        selector_title = TextView(self.context)
        selector_title.setText(tr("–°–∫–∏–Ω –ø–∏—Ç–æ–º—Ü–∞", "Pet skin"))
        selector_title.setTextSize(1, 13)
        selector_title.setTextColor(UI.on_surface())
        selector_title.setTypeface(None, Typeface.BOLD)
        selector_title.setGravity(Gravity.START)
        selector_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        selector_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        container.addView(selector_title, selector_params)

        skin_scroll = HorizontalScrollView(self.context)
        skin_scroll.setHorizontalScrollBarEnabled(False)
        skin_row = LinearLayout(self.context)
        skin_row.setOrientation(LinearLayout.HORIZONTAL)
        skin_row.setGravity(Gravity.CENTER_VERTICAL)
        skin_scroll.addView(
            skin_row,
            LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            ),
        )

        skin_items = []

        def applySkinSelection(selected_value):
            for item in skin_items:
                view = item["view"]
                label = item["label"]
                emoji = item["emoji"]
                is_selected = item["value"] == selected_value
                bg = GradientDrawable()
                bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
                bg.setColor(UI.primary_container() if is_selected else UI.surface_variant())
                view.setBackground(bg)
                label.setTextColor(UI.on_primary_container() if is_selected else UI.on_surface_variant())
                emoji.setAlpha(1.0 if is_selected else 0.7)

        for skin_value in sorted(PET_STAGES_BY_STYLE.keys()):
            stages = PET_STAGES_BY_STYLE.get(skin_value, PET_STAGES_BY_STYLE[0])
            stage_emoji = stages[0]["emoji"]
            stage_name = stages[1]["name"] if 1 in stages else stages[0]["name"]
            label_text = PET_STAGE_NAME_EN.get(stage_name, stage_name) if isEn() else stage_name
            perk_text = skinPerkText(skin_value)
            if perk_text:
                label_text = f"{label_text}\n{perk_text}"

            item = LinearLayout(self.context)
            item.setOrientation(LinearLayout.VERTICAL)
            item.setGravity(Gravity.CENTER)
            item.setPadding(
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
            )
            item_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            item_params.setMargins(
                0,
                0,
                AndroidUtilities.dp(Dp.S8),
                0,
            )

            emoji_tv = TextView(self.context)
            emoji_tv.setText(stage_emoji)
            emoji_tv.setTextSize(1, 20)
            emoji_tv.setGravity(Gravity.CENTER)
            item.addView(emoji_tv)

            name_tv = TextView(self.context)
            name_tv.setText(label_text)
            name_tv.setTextSize(1, 10)
            name_tv.setGravity(Gravity.CENTER)
            item.addView(name_tv)

            def onSkinClick(v, sv=skin_value):
                selected_skin["value"] = sv
                applySkinSelection(sv)
                self.updateStagesPreview(stages_preview, sv)

            item.setOnClickListener(OnClickListener(onSkinClick))
            skin_row.addView(item, item_params)
            skin_items.append(
                {"value": skin_value, "view": item, "label": name_tv, "emoji": emoji_tv}
            )

        applySkinSelection(selected_skin["value"])
        container.addView(
            skin_scroll,
            LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            ),
        )

        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setPadding(0, AndroidUtilities.dp(Dp.S24), 0, 0)

        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        close_btn = UI.button(self.context, tr("–û—Ç–º–µ–Ω–∞", "Cancel"), lambda *args: self.dismiss(), "tonal")
        btn_container.addView(close_btn, btn_params)

        start_btn = UI.button(
            self.context,
            tr("–°–æ–∑–¥–∞—Ç—å", "Create"),
            lambda *args: self._onstartPet(selected_skin["value"]),
            "filled",
        )
        btn_container.addView(start_btn, btn_params)

        container.addView(btn_container)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_activation_screen(self, pet):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setGravity(Gravity.CENTER)
        container.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )

        container.setBackground(UI.bg_sheet())

        emoji = pet.get_emoji() if pet else "ü•ö"
        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 72)
        emoji_tv.setGravity(Gravity.CENTER)
        container.addView(emoji_tv)

        title_tv = TextView(self.context)
        title_tv.setText(tr("–ü–∏—Ç–æ–º—Ü–∞ –µ—â–µ –Ω–µ—Ç", "No pet yet"))
        title_tv.setTextSize(1, 24)
        title_tv.setTextColor(UI.on_surface())
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        container.addView(title_tv, title_params)

        desc_tv = TextView(self.context)
        desc_tv.setText(
            tr(
                "–ó–∞–≤–µ–¥–∏ –ø–∏—Ç–æ–º—Ü–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å XP\n–∑–∞ —Å–æ–æ–±—â–µ–Ω–∏—è",
                "Get a pet to earn XP\nfrom messages",
            )
        )
        desc_tv.setTextSize(1, 14)
        desc_tv.setTextColor(UI.on_surface())
        desc_tv.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        container.addView(desc_tv, desc_params)

        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setPadding(0, AndroidUtilities.dp(Dp.S24), 0, 0)

        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        close_btn = UI.button(self.context, tr("–û—Ç–º–µ–Ω–∞", "Cancel"), lambda *args: self.dismiss(), "tonal")
        btn_container.addView(close_btn, btn_params)

        start_btn = UI.button(self.context, tr("–ó–∞–≤–µ—Å—Ç–∏ –ø–∏—Ç–æ–º—Ü–∞", "Get a pet"), lambda *args: self._onstartPet(), "filled")
        btn_container.addView(start_btn, btn_params)

        container.addView(btn_container)
        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_header(self, container, pet):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji = pet.get_emoji()
        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        header.addView(emoji_tv)

        name_tv = TextView(self.context)
        name_tv.setText(pet.name)
        name_tv.setTextSize(1, 22)
        name_tv.setTextColor(UI.on_surface())
        name_tv.setTypeface(None, Typeface.BOLD)
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(name_tv, name_params)

        stage_chip = TextView(self.context)
        stage_chip.setText(pet.get_stage_name())
        stage_chip.setTextSize(1, 12)
        stage_chip.setTextColor(get_on_primary_container())
        stage_chip.setGravity(Gravity.CENTER)
        stage_chip.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S4),
        )
        chip_bg = GradientDrawable()
        chip_bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
        chip_bg.setColor(UI.primary_container())
        stage_chip.setBackground(chip_bg)
        chip_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        chip_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(stage_chip, chip_params)

        xp_tv = TextView(self.context)
        xp_tv.setText(
            f"‚ö° {pet.xp} XP  ‚Ä¢  {tr('–£—Ä.', 'Lv.')} {pet.level}"
        )
        xp_tv.setTextSize(1, 13)
        xp_tv.setTextColor(UI.on_surface())
        xp_tv.setGravity(Gravity.CENTER)
        xp_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(xp_tv, xp_params)

        coins_tv = TextView(self.context)
        coins_tv.setText(tr(f"ü™ô –ú–æ–Ω–µ—Ç—ã: {pet.coins}", f"ü™ô Coins: {pet.coins}"))
        coins_tv.setTextSize(1, 12)
        coins_tv.setTextColor(UI.on_surface_variant())
        coins_tv.setGravity(Gravity.CENTER)
        coins_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        coins_params.setMargins(0, AndroidUtilities.dp(Dp.S6), 0, 0)
        header.addView(coins_tv, coins_params)

        container.addView(header)

    def _build_status_cards(self, container, pet, streak):
        pet.update_state()

        if pet.deleted:
            dead_card = LinearLayout(self.context)
            dead_card.setOrientation(LinearLayout.VERTICAL)
            dead_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
            )
            dead_bg = GradientDrawable()
            dead_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            dead_bg.setColor(UI.error_container())
            dead_card.setBackground(dead_bg)

            dead_title = TextView(self.context)
            dead_title.setText(tr("üí§ –ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω", "üí§ Pet inactive"))
            dead_title.setTextSize(1, 14)
            dead_title.setTextColor(get_on_error_container())
            dead_title.setTypeface(None, Typeface.BOLD)
            dead_card.addView(dead_title)

            dead_desc = TextView(self.context)
            dead_desc.setText(
                tr(
                    f"–ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª: {REVIVE_COIN_COST} –º–æ–Ω–µ—Ç, —Ä–∞–∑ –≤ {int(REVIVE_COOLDOWN_SECONDS/3600)}—á",
                    f"Tap ‚ÄúRevive‚Äù: {REVIVE_COIN_COST} coins, every {int(REVIVE_COOLDOWN_SECONDS/3600)}h",
                )
            )
            dead_desc.setTextSize(1, 11)
            dead_desc.setTextColor(get_on_error_container())
            dead_desc.setAlpha(0.8)
            dead_desc_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            dead_desc_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            dead_card.addView(dead_desc, dead_desc_params)

            dead_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            dead_params.setMargins(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S8),
                AndroidUtilities.dp(Dp.S16),
                0,
            )
            container.addView(dead_card, dead_params)

        cards_container = LinearLayout(self.context)
        cards_container.setOrientation(LinearLayout.HORIZONTAL)
        cards_container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        card_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        hunger_color = UI.primary() if pet.hunger >= HUNGER_MEDIUM_THRESHOLD else UI.error()
        hunger_card = self._create_status_card(
            "üçñ",
            f"{int(pet.hunger)}%",
            tr("–°—ã—Ç–æ—Å—Ç—å", "Hunger"),
            hunger_color,
            pet.hunger / 100.0,
        )
        cards_container.addView(hunger_card, card_params)

        mood_color = UI.primary() if pet.mood >= MOOD_MEDIUM_THRESHOLD else UI.error()
        mood_card = self._create_status_card(
            "‚ù§Ô∏è",
            f"{int(pet.mood)}%",
            tr("–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "Mood"),
            mood_color,
            pet.mood / 100.0,
        )
        cards_container.addView(mood_card, card_params)

        if streak:
            flame = streak.get_flame_emoji()
            streak_card = self._create_status_card(
                flame,
                f"{streak.count}",
                tr("–î–Ω–µ–π", "Days"),
                UI.primary(),
                min(streak.count / 30.0, 1.0),
            )
            cards_container.addView(streak_card, card_params)

        container.addView(cards_container)

    def _create_status_card(self, emoji, value, label, color, progress):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.withAlpha(UI.outline(), 120))
        card.setBackground(bg)
        UI.elevation(card, ELEVATION_CARD)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 24)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 18)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(value_tv, value_params)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface())
        label_tv.setGravity(Gravity.CENTER)
        card.addView(label_tv)

        bar_container = LinearLayout(self.context)
        bar_container.setOrientation(LinearLayout.HORIZONTAL)
        bar_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(Dp.S4)
        )
        bar_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        bar_container.setLayoutParams(bar_params)

        bar_bg_drawable = GradientDrawable()
        bar_bg_drawable.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        bar_bg_drawable.setColor(UI.withAlpha(UI.outline(), 170))
        bar_container.setBackground(bar_bg_drawable)

        bar_fill = View(self.context)
        bar_fill_drawable = GradientDrawable()
        bar_fill_drawable.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        bar_fill_drawable.setColor(color)
        bar_fill.setBackground(bar_fill_drawable)
        fill = max(0.05, min(1.0, progress))
        bar_fill_params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S4), fill)
        bar_container.addView(bar_fill, bar_fill_params)

        bar_rest = View(self.context)
        bar_rest.setBackgroundColor(Color.TRANSPARENT)
        bar_rest_params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S4), 1.0 - fill)
        bar_container.addView(bar_rest, bar_rest_params)

        card.addView(bar_container, bar_params)

        self.animateIn(card, 0, 6)
        return card

    def _build_evolution_section(self, container, pet):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è", "Evolution"))
        title.setTextSize(1, 14)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S12))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        skin_style = pet.getSkinStyle() if pet else 0
        stages = PET_STAGES_BY_STYLE.get(skin_style, PET_STAGES_BY_STYLE[0])

        for stage_num, stage_data in stages.items():
            is_current = stage_num == pet.stage
            is_achieved = stage_num <= pet.stage
            stage_item = self._create_evolution_item(
                stage_data["emoji"],
                str(stage_num),
                is_current,
                is_achieved
            )
            stage_params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            stages_row.addView(stage_item, stage_params)

        section.addView(stages_row)

        xp_to_next = pet.xp_to_next_stage()
        xp_card = self._build_xp_progress_card(pet, xp_to_next)
        xp_card_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_card_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        section.addView(xp_card, xp_card_params)

        container.addView(section)

    def _build_xp_progress_card(self, pet, xp_to_next):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S14),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S14),
        )

        card_bg = GradientDrawable()
        card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        card_bg.setColor(UI.surface_variant())
        card.setBackground(card_bg)

        header_row = LinearLayout(self.context)
        header_row.setOrientation(LinearLayout.HORIZONTAL)
        header_row.setGravity(Gravity.CENTER_VERTICAL)

        skin_style = pet.getSkinStyle() if pet else 0
        stages = PET_STAGES_BY_STYLE.get(skin_style, PET_STAGES_BY_STYLE[0])

        current_emoji = stages[pet.stage - 1]["emoji"] if pet.stage > 0 else "ü•ö"
        current_stage_tv = TextView(self.context)
        current_stage_tv.setText(current_emoji)
        current_stage_tv.setTextSize(1, 28)
        header_row.addView(current_stage_tv)

        if xp_to_next > 0 and pet.stage < len(stages):
            arrow_tv = TextView(self.context)
            arrow_tv.setText("  ‚Üí  ")
            arrow_tv.setTextSize(1, 16)
            arrow_tv.setTextColor(UI.on_surface_variant())
            header_row.addView(arrow_tv)

            next_emoji = stages[pet.stage]["emoji"] if pet.stage < len(stages) else "üëë"
            next_stage_tv = TextView(self.context)
            next_stage_tv.setText(next_emoji)
            next_stage_tv.setTextSize(1, 28)
            next_stage_tv.setAlpha(0.5)
            header_row.addView(next_stage_tv)

            spacer = View(self.context)
            spacer_params = LinearLayout.LayoutParams(0, 1, 1.0)
            header_row.addView(spacer, spacer_params)

            stage_num_tv = TextView(self.context)
            stage_num_tv.setText(
                tr(
                    f"–°—Ç–∞–¥–∏—è {pet.stage}/{len(stages)}",
                    f"Stage {pet.stage}/{len(stages)}",
                )
            )
            stage_num_tv.setTextSize(1, 12)
            stage_num_tv.setTextColor(UI.on_surface_variant())
            header_row.addView(stage_num_tv)
        else:
            spacer = View(self.context)
            spacer_params = LinearLayout.LayoutParams(0, 1, 1.0)
            header_row.addView(spacer, spacer_params)

            max_tv = TextView(self.context)
            max_tv.setText("‚ú® MAX")
            max_tv.setTextSize(1, 14)
            max_tv.setTextColor(UI.primary())
            max_tv.setTypeface(None, Typeface.BOLD)
            header_row.addView(max_tv)

        card.addView(header_row)

        if xp_to_next > 0:
            current_stage_xp = PET_STAGES[pet.stage]["xp"] if pet.stage < len(PET_STAGES) else 0
            next_stage_xp = PET_STAGES[pet.stage + 1]["xp"] if pet.stage + 1 < len(PET_STAGES) else pet.xp
            xp_in_stage = pet.xp - current_stage_xp
            total_xp_needed = next_stage_xp - current_stage_xp
            progress = xp_in_stage / total_xp_needed if total_xp_needed > 0 else 1.0
            progress = max(0.0, min(1.0, progress))

            xp_row = LinearLayout(self.context)
            xp_row.setOrientation(LinearLayout.HORIZONTAL)
            xp_row.setGravity(Gravity.CENTER_VERTICAL)
            xp_row_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            xp_row_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

            current_xp_tv = TextView(self.context)
            current_xp_tv.setText(f"{xp_in_stage}")
            current_xp_tv.setTextSize(1, 16)
            current_xp_tv.setTextColor(UI.primary())
            current_xp_tv.setTypeface(None, Typeface.BOLD)
            xp_row.addView(current_xp_tv)

            slash_tv = TextView(self.context)
            slash_tv.setText(f" / {total_xp_needed} XP")
            slash_tv.setTextSize(1, 14)
            slash_tv.setTextColor(UI.on_surface_variant())
            xp_row.addView(slash_tv)

            spacer2 = View(self.context)
            spacer2_params = LinearLayout.LayoutParams(0, 1, 1.0)
            xp_row.addView(spacer2, spacer2_params)

            percent_tv = TextView(self.context)
            percent_tv.setText(f"{int(progress * 100)}%")
            percent_tv.setTextSize(1, 14)
            percent_tv.setTextColor(UI.on_surface())
            percent_tv.setTypeface(None, Typeface.BOLD)
            xp_row.addView(percent_tv)

            card.addView(xp_row, xp_row_params)

            bar_container = LinearLayout(self.context)
            bar_container.setOrientation(LinearLayout.HORIZONTAL)
            bar_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(Dp.S8)
            )

            bar_bg_drawable = GradientDrawable()
            bar_bg_drawable.setCornerRadius(AndroidUtilities.dp(Dp.HANDLE_H))
            bar_bg_drawable.setColor(UI.withAlpha(UI.outline(), 170))
            bar_container.setBackground(bar_bg_drawable)

            bar_fill = View(self.context)
            bar_fill_drawable = GradientDrawable()
            bar_fill_drawable.setCornerRadius(AndroidUtilities.dp(Dp.HANDLE_H))
            bar_fill_drawable.setColor(UI.primary())
            bar_fill.setBackground(bar_fill_drawable)
            fill = max(0.05, min(1.0, progress))
            bar_fill_params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), fill)
            bar_container.addView(bar_fill, bar_fill_params)

            bar_rest = View(self.context)
            bar_rest.setBackgroundColor(Color.TRANSPARENT)
            bar_rest_params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), 1.0 - fill)
            bar_container.addView(bar_rest, bar_rest_params)

            card.addView(bar_container, bar_params)

            remaining_tv = TextView(self.context)
            remaining_tv.setText(
                tr(f"–û—Å—Ç–∞–ª–æ—Å—å {xp_to_next} XP", f"Remaining {xp_to_next} XP")
            )
            remaining_tv.setTextSize(1, 11)
            remaining_tv.setTextColor(UI.on_surface())
            remaining_tv.setGravity(Gravity.CENTER)
            remaining_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            remaining_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
            card.addView(remaining_tv, remaining_params)

        return card

    def _create_evolution_item(self, emoji, level, is_current, is_achieved):
        item = LinearLayout(self.context)
        item.setOrientation(LinearLayout.VERTICAL)
        item.setGravity(Gravity.CENTER)
        item.setPadding(
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
        )

        if is_current:
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
            bg.setColor(UI.primary_container())
            item.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        if not is_achieved:
            emoji_tv.setAlpha(0.3)
        item.addView(emoji_tv)

        level_tv = TextView(self.context)
        level_tv.setText(level)
        level_tv.setTextSize(1, 10)
        level_tv.setTextColor(get_on_surface_variant() if is_achieved else Color.argb(80, 128, 128, 128))
        level_tv.setGravity(Gravity.CENTER)
        item.addView(level_tv)

        return item

    def updateStagesPreview(self, row, skinStyle):
        if not row:
            return
        row.removeAllViews()
        stages = PET_STAGES_BY_STYLE.get(skinStyle, PET_STAGES_BY_STYLE[0])
        for stage_num, stage_data in list(stages.items())[:5]:
            item = self._create_evolution_item(stage_data["emoji"], str(stage_num), False, False)
            params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            row.addView(item, params)

    def _create_stages_preview(self, skinStyle=0):
        row = LinearLayout(self.context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER)
        self.updateStagesPreview(row, skinStyle)

        return row

    def _create_buttons(self, is_active, pet=None):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        if is_active:
            row1 = LinearLayout(self.context)
            row1.setOrientation(LinearLayout.HORIZONTAL)

            btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
            btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

            feed_btn = UI.button(self.context, S.FEED, lambda *args: self._on_feed_click(), "filled")
            row1.addView(feed_btn, btn_params)

            play_btn = UI.button(self.context, S.PLAY, lambda *args: self._on_play_click(), "tonal")
            row1.addView(play_btn, btn_params)

            container.addView(row1)

            play_locked_reason = None
            if pet and pet.deleted:
                play_locked_reason = tr("–ü–∏—Ç–æ–º–µ—Ü —É–¥–∞–ª—ë–Ω. –ù—É–∂–Ω–æ –≤–æ—Å–∫—Ä–µ—Å–∏—Ç—å.", "Pet is deleted. Revive to play.")
            elif pet and pet.hunger < HUNGER_CONFIG["critical_level"]:
                play_locked_reason = tr(
                    "–°–ª–∏—à–∫–æ–º –≥–æ–ª–æ–¥–Ω—ã–π. –ü–æ–∫–æ—Ä–º–∏, —á—Ç–æ–±—ã –∏–≥—Ä–∞—Ç—å.",
                    "Too hungry. Feed to play.",
                )
            if play_locked_reason:
                try:
                    play_btn.setEnabled(False)
                    play_btn.setClickable(False)
                    play_btn.setAlpha(0.45)
                except Exception:
                    pass
                info = TextView(self.context)
                info.setText(play_locked_reason)
                info.setTextSize(1, 12)
                info.setTextColor(UI.on_surface_variant())
                info.setPadding(
                    AndroidUtilities.dp(Dp.S4),
                    AndroidUtilities.dp(Dp.S6),
                    AndroidUtilities.dp(Dp.S4),
                    0,
                )
                container.addView(info)

            row2 = LinearLayout(self.context)
            row2.setOrientation(LinearLayout.HORIZONTAL)
            row2_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            row2_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

            rename_btn = UI.button(self.context, S.RENAME, lambda *args: self._on_rename_click(), "outlined")
            row2.addView(rename_btn, btn_params)

            skin_btn = UI.button(
                self.context,
                tr("–°–º–µ–Ω–∏—Ç—å —Å–∫–∏–Ω", "Change skin"),
                lambda *args: self.onChangeSkinClick(),
                "outlined",
            )
            row2.addView(skin_btn, btn_params)

            container.addView(row2, row2_params)

            row3 = LinearLayout(self.context)
            row3.setOrientation(LinearLayout.VERTICAL)
            row3_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            row3_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

            kick_btn = UI.button(self.context, S.KICK, lambda *args: self._onkickPet_click(), "outlined")
            row3.addView(kick_btn)
            container.addView(row3, row3_params)

            if pet and pet.deleted:
                try:
                    feed_btn.setEnabled(False)
                    feed_btn.setClickable(False)
                    feed_btn.setAlpha(0.45)
                    rename_btn.setEnabled(False)
                    rename_btn.setClickable(False)
                    rename_btn.setAlpha(0.45)
                    skin_btn.setEnabled(False)
                    skin_btn.setClickable(False)
                    skin_btn.setAlpha(0.45)
                    kick_btn.setEnabled(False)
                    kick_btn.setClickable(False)
                    kick_btn.setAlpha(0.45)
                except Exception:
                    pass
                row4 = LinearLayout(self.context)
                row4.setOrientation(LinearLayout.VERTICAL)
                row4_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                row4_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

                revive_btn = UI.button(
                    self.context,
                    tr(
                        f"–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞ (-{REVIVE_COIN_COST} ü™ô)",
                        f"Revive pet (-{REVIVE_COIN_COST} ü™ô)",
                    ),
                    lambda *args: self._on_revive_click(),
                    "filled",
                )
                row4.addView(revive_btn)
                container.addView(row4, row4_params)
        else:
            close_btn = UI.button(self.context, S.CLOSE, lambda *args: self.dismiss(), "tonal")
            container.addView(close_btn)

        return container

    def _on_feed_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.feed_pet({"chat_id": chat_id})

    def _reopen_menu(self, plugin_ref, chat_id_ref, error_label):
        def show_updated_menu():
            try:
                fragment = get_last_fragment()
                if not fragment:
                    return
                activity = fragment.getParentActivity()
                if not activity:
                    return
                new_sheet = PetStatsBottomSheet(activity, plugin_ref, chat_id_ref)
                new_sheet.show()
            except Exception as e:
                if plugin_ref:
                    suffix = f" ({error_label})" if error_label else ""
                    plugin_ref.log(f"WSP: error reopening pet menu{suffix}: {e}")
        run_on_ui_thread(show_updated_menu)

    def _on_play_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.showPetMinigame(chat_id)

    def _on_revive_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            def reviveAndReopen():
                plugin.revivePet(chat_id)
                run_on_ui_thread(
                    lambda: self._reopen_menu(plugin, chat_id, "after revive"),
                    260,
                )

            plugin.runAsync(reviveAndReopen)

    def _onstartPet(self, skinStyle=None):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startPet(chat_id, skinStyle=skinStyle)

    def _on_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.forceSyncNow(chat_id)

    def _on_stop_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.stopPet(chat_id)

    def _on_rename_click(self):
        try:
            from android.text import InputType
            from android.widget import EditText
            from org.telegram.ui.ActionBar import AlertDialog

            pet = self.plugin.pets.get(self.chat_id)
            if not pet:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet not found"))
                return

            edit_text = EditText(self.context)
            edit_text.setText(pet.name)
            edit_text.setHint(tr("–ù–æ–≤–æ–µ –∏–º—è", "New name"))
            edit_text.setInputType(
                InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_CAP_WORDS
            )
            edit_text.setSingleLine(True)
            edit_text.setPadding(
                AndroidUtilities.dp(Dp.S20),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S20),
                AndroidUtilities.dp(Dp.S12),
            )

            edit_bg = GradientDrawable()
            edit_bg.setCornerRadius(AndroidUtilities.dp(Dp.CORNER_SM))
            edit_bg.setColor(UI.surface_variant())
            edit_bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
            edit_text.setBackground(edit_bg)
            edit_text.setTextColor(UI.on_surface())
            edit_text.setHintTextColor(UI.on_surface_variant())

            builder = AlertDialog.Builder(self.context)
            builder.setTitle(tr("–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–∏—Ç–æ–º—Ü–∞", "Rename pet"))
            builder.setView(edit_text)
            refs = {"dialog": None, "edit": edit_text}

            def cleanup_dialog():
                refs["dialog"] = None
                refs["edit"] = None

            def on_positive(dialog, which):
                et = refs.get("edit")
                new_name = str(et.getText()).strip() if et else ""
                if new_name and len(new_name) <= 100:
                    plugin_ref = self.plugin
                    chat_id_ref = self.chat_id

                    plugin_ref.renamePet(chat_id_ref, new_name)
                    self.dismiss()
                    self._reopen_menu(plugin_ref, chat_id_ref, None)
                    cleanup_dialog()
                elif len(new_name) > 100:
                    bulletin_safe("error",
                        tr(
                            "–ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–º–∞–∫—Å. 100 —Å–∏–º–≤–æ–ª–æ–≤)",
                            "Name is too long (max 100 characters)",
                        )
                    )
                else:
                    bulletin_safe("error", tr("–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º", "Name can't be empty"))

            from java import dynamic_proxy

            ButtonClickListener = dynamic_proxy(AlertDialog.OnButtonClickListener)

            class PositiveListener(ButtonClickListener):
                def onClick(self, dialog, which):
                    on_positive(dialog, which)

            builder.setPositiveButton(tr("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", "Save"), PositiveListener())
            builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

            dialog = safeShowDialog(builder, cleanup_dialog)
            refs["dialog"] = dialog

        except Exception as e:
            self.log(f"WSP: error showing rename dialog: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def onChangeSkinClick(self):
        plugin_ref = self.plugin
        chat_id_ref = self.chat_id
        if not plugin_ref:
            return
        plugin_ref.showPetSkinShop(
            self.context,
            chat_id_ref,
            lambda: self._reopen_menu(plugin_ref, chat_id_ref, "skin updated"),
        )

    def _onkickPet_click(self):
        try:
            from org.telegram.ui.ActionBar import AlertDialog

            builder = AlertDialog.Builder(self.context)
            builder.setTitle(tr("–í—ã–≥–Ω–∞—Ç—å –ø–∏—Ç–æ–º—Ü–∞?", "Kick the pet?"))
            builder.setMessage(
                tr(
                    "–í—ã–≥–Ω–∞—Ç—å –ø–∏—Ç–æ–º—Ü–∞? –î–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ, –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω.",
                    "Kick the pet? This can't be undone and all progress will be lost.",
                )
            )
            refs = {"dialog": None}

            def cleanup_dialog():
                refs["dialog"] = None

            def on_confirm(dialog, which):
                plugin_ref = self.plugin
                chat_id_ref = self.chat_id
                self.dismiss()
                if plugin_ref:
                    plugin_ref.kickPet(chat_id_ref)
                cleanup_dialog()

            from java import dynamic_proxy

            ButtonClickListener = dynamic_proxy(AlertDialog.OnButtonClickListener)

            class ConfirmListener(ButtonClickListener):
                def onClick(self, dialog, which):
                    on_confirm(dialog, which)

            builder.setPositiveButton(tr("–í—ã–≥–Ω–∞—Ç—å", "Kick"), ConfirmListener())
            builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

            dialog = safeShowDialog(builder, cleanup_dialog)
            refs["dialog"] = dialog

        except Exception as e:
            self.log(f"WSP: error showing kick pet dialog: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def show(self):
        try:
            self.bottom_sheet.show()
        except Exception as e:
            self.log(f"WSP: error showing pet stats: {e}")

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing pet stats: {e}")
        finally:
            self.onDismiss()


class StreakMenuBottomSheet(SafeSheet):
    def __init__(self, context, plugin, chat_id):
        super().__init__(context, plugin, chat_id)
        self.bottom_sheet = BottomSheet(context, False)

        streak = plugin.getOrCreateStreak(chat_id)
        is_active = chat_id in plugin.streak_enabled_chats
        pet_active = chat_id in plugin.pet_enabled_chats
        pet = plugin.pets.get(chat_id)
        if not pet and pet_active:
            pet = plugin.getOrCreatePet(chat_id)

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackground(UI.bg_sheet())

        handle_container = LinearLayout(context)
        handle_container.setOrientation(LinearLayout.VERTICAL)
        handle_container.setGravity(Gravity.CENTER)
        handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

        handle = View(context)
        handle.setBackgroundColor(UI.outline())
        handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
        handle_bg = GradientDrawable()
        handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        handle_bg.setColor(UI.outline())
        handle.setBackground(handle_bg)
        handle_container.addView(handle, handle_params)
        container.addView(handle_container)

        tabs_row = self._create_tabs_row()
        container.addView(tabs_row)

        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)
        self._tab_scroll = scroll_view
        self.bindTabSwipe(scroll_view)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        self._tab_content = content
        self._tab_streak = streak
        self._tab_pet = pet
        self._tab_state = (is_active, pet_active)
        default_tab = "streak" if is_active or not pet_active else "pet"
        last_tab = None
        try:
            last_tab = plugin.getLastMenuTab(chat_id)
        except Exception:
            last_tab = None
        allowed_tabs = {"streak", "pet", "rewards", "shop"}
        self._tab = last_tab if last_tab in allowed_tabs else default_tab

        scroll_view.addView(content)

        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        button_container = self._create_buttons(is_active, streak)
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        container.addView(button_container, button_params)
        self._button_container = button_container

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()
        self._render_tab()

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def formatSyncStatus(self, chat_id):
        plugin = self.plugin
        if not plugin:
            return ""
        try:
            return plugin.formatSyncStatus(chat_id)
        except Exception as e:
            self.log(f"WSP: format_last_sync_status error: {e}")
            return ""

    def _build_active_streak_ui(self, container, streak):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        flame = streak.get_flame_emoji()
        emoji_text = TextView(self.context)
        emoji_text.setText(flame)
        emoji_text.setTextSize(1, 64)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        count_text = TextView(self.context)
        count_text.setText(f"{streak.count}")
        count_text.setTextSize(1, 48)
        count_text.setTextColor(UI.on_surface())
        count_text.setTypeface(None, Typeface.BOLD)
        count_text.setGravity(Gravity.CENTER)
        count_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        count_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(count_text, count_params)

        days_label = TextView(self.context)
        days_label.setText(formatDaysInRow(streak.count))
        days_label.setTextSize(1, 14)
        days_label.setTextColor(UI.on_surface())
        days_label.setGravity(Gravity.CENTER)
        header.addView(days_label)

        sync_status = self.formatSyncStatus(getattr(streak, "chat_id", None))
        if sync_status:
            sync_tv = TextView(self.context)
            sync_tv.setText(sync_status)
            sync_tv.setTextSize(1, 12)
            sync_tv.setTextColor(UI.on_surface_variant())
            sync_tv.setGravity(Gravity.CENTER)
            sync_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            sync_params.setMargins(0, AndroidUtilities.dp(Dp.S6), 0, 0)
            header.addView(sync_tv, sync_params)

        if streak.is_warning:
            warning_badge = self._create_status_chip(
                tr(
                    f"–û–≥–æ–Ω–µ–∫ —Å–∫–æ—Ä–æ –ø–æ—Ç—É—Ö–Ω–µ—Ç, –æ—Å—Ç–∞–ª–æ—Å—å {int(streak.warning_time_left)}—á",
                    "WARNING",
                ),
                Color.argb(255, 255, 152, 0),
                Color.argb(30, 255, 152, 0)
            )
            warning_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            warning_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
            header.addView(warning_badge, warning_params)
        else:
            status_badge = self._create_status_chip(
                tr("‚úì –ê–∫—Ç–∏–≤–µ–Ω", "‚úì Active"), UI.on_primary_container(), UI.primary_container()
            )
            status_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            status_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
            header.addView(status_badge, status_params)

        container.addView(header)

        stages_section = self._create_stages_section(streak)
        container.addView(stages_section)

        stats_section = self._create_stats_section(streak)
        container.addView(stats_section)

    def _create_status_chip(self, text, text_color, bg_color):
        chip = TextView(self.context)
        chip.setText(text)
        chip.setTextSize(1, 12)
        chip.setTextColor(text_color)
        chip.setTypeface(None, Typeface.BOLD)
        chip.setGravity(Gravity.CENTER)
        chip.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S6),
        )
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(bg_color)
        chip.setBackground(bg)
        return chip

    def _create_stages_section(self, streak):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è –æ–≥–Ω—è", "Flame evolution"))
        title.setTextSize(1, 14)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S12))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        current_stage = streak.get_current_stage_index()

        for i, stage in enumerate(FLAME_STAGES):
            stage_name = stage["name"]
            if isEn():
                stage_name = FLAME_STAGE_NAME_EN.get(stage_name, stage_name)
            stage_item = self._create_stage_item(
                stage["emoji"],
                stage_name,
                stage["days"],
                is_current=(i == current_stage),
                is_achieved=(streak.count >= stage["min"]),
            )
            stage_params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            stage_params.setMargins(AndroidUtilities.dp(Dp.S2), 0, AndroidUtilities.dp(Dp.S2), 0)
            stages_row.addView(stage_item, stage_params)

        section.addView(stages_row)
        return section

    def _create_stage_item(self, emoji, name, days, is_current, is_achieved):
        item = LinearLayout(self.context)
        item.setOrientation(LinearLayout.VERTICAL)
        item.setGravity(Gravity.CENTER)
        item.setPadding(
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
        )

        if is_current:
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
            bg.setColor(UI.primary_container())
            item.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 24)
        emoji_tv.setGravity(Gravity.CENTER)
        if not is_achieved:
            emoji_tv.setAlpha(0.4)
        item.addView(emoji_tv)

        days_tv = TextView(self.context)
        days_tv.setText(days)
        days_tv.setTextSize(1, 10)
        days_tv.setTextColor(get_on_surface_variant() if is_achieved else Color.argb(100, 128, 128, 128))
        days_tv.setGravity(Gravity.CENTER)
        days_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        days_params.setMargins(0, AndroidUtilities.dp(Dp.S2), 0, 0)
        item.addView(days_tv, days_params)

        return item

    def _create_stats_section(self, streak):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        stats_row = LinearLayout(self.context)
        stats_row.setOrientation(LinearLayout.HORIZONTAL)

        last_msg = self._create_stat_card(
            "üìÖ",
            tr("–ü–æ—Å–ª–µ–¥–Ω–µ–µ", "Last"),
            str(streak.last_date) if streak.last_date else "-"
        )
        start_date = self._create_stat_card(
            "üéØ",
            tr("–ù–∞—á–∞–ª–æ", "Start"),
            str(streak.first_date) if streak.first_date else "-"
        )

        card_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        stats_row.addView(last_msg, card_params)
        stats_row.addView(start_date, card_params)
        section.addView(stats_row)

        return section

    def _create_stat_card(self, emoji, label, value):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        card.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface())
        label_tv.setGravity(Gravity.CENTER)
        label_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        label_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(label_tv, label_params)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 12)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_tv.setSingleLine(True)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S2), 0, 0)
        card.addView(value_tv, value_params)

        return card

    def _build_inactive_streak_ui(self, container):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji_text = TextView(self.context)
        emoji_text.setText("üî•")
        emoji_text.setTextSize(1, 56)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        title = TextView(self.context)
        title.setText(tr("–°—Ç—Ä–∏–∫", "Streak"))
        title.setTextSize(1, 24)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
        header.addView(title, title_params)

        desc = TextView(self.context)
        desc.setText(
            tr(
                "–ü–∏—à–∏—Ç–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å,\n—á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–µ—Ä–∏—é",
                "Write every day\nto keep the streak",
            )
        )
        desc.setTextSize(1, 14)
        desc.setTextColor(UI.on_surface())
        desc.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(desc, desc_params)

        container.addView(header)

        stages_section = self._create_stages_preview()
        container.addView(stages_section)

    def _create_stages_preview(self):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–ù–∞–≥—Ä–∞–¥—ã –ø–æ –¥–Ω—è–º:", "Rewards by day:"))
        title.setTextSize(1, 13)
        title.setTextColor(UI.on_surface())
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S8))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        for stage in FLAME_STAGES:
            stage_name = stage["name"]
            if isEn():
                stage_name = FLAME_STAGE_NAME_EN.get(stage_name, stage_name)
            item = self._create_stage_item(stage["emoji"], stage_name, stage["days"], False, False)
            params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            params.setMargins(AndroidUtilities.dp(Dp.S2), 0, AndroidUtilities.dp(Dp.S2), 0)
            stages_row.addView(item, params)

        section.addView(stages_row)
        return section

    def _build_dead_streak_ui(self, container, streak):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(0)
        bg.setColor(UI.error_container())
        header.setBackground(bg)

        emoji_text = TextView(self.context)
        emoji_text.setText("üíÄ")
        emoji_text.setTextSize(1, 56)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        dead_count = TextView(self.context)
        dead_count.setText(
            tr(
                formatDaysRu(streak.dead_count),
                formatDaysEn(streak.dead_count),
            )
        )
        dead_count.setTextSize(1, 32)
        dead_count.setTextColor(get_on_error_container())
        dead_count.setTypeface(None, Typeface.BOLD)
        dead_count.setGravity(Gravity.CENTER)
        count_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        count_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(dead_count, count_params)

        subtitle = TextView(self.context)
        subtitle.setText(tr("–°—Ç—Ä–∏–∫ –ø–æ—Ç–µ—Ä—è–Ω", "Streak lost"))
        subtitle.setTextSize(1, 14)
        subtitle.setTextColor(get_on_error_container())
        subtitle.setAlpha(0.7)
        subtitle.setGravity(Gravity.CENTER)
        header.addView(subtitle)

        container.addView(header)

        info_section = LinearLayout(self.context)
        info_section.setOrientation(LinearLayout.VERTICAL)
        info_section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        if streak.can_restore:
            time_left = streak.restore_time_left
            hours_left = int(time_left)
            mins_left = int((time_left - hours_left) * 60)
            restores_left = STREAK_MAX_RESTORES_PER_MONTH - streak.restores_this_month

            restore_card = LinearLayout(self.context)
            restore_card.setOrientation(LinearLayout.VERTICAL)
            restore_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
            )
            card_bg = GradientDrawable()
            card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            card_bg.setColor(UI.primary_container())
            restore_card.setBackground(card_bg)

            restore_title = TextView(self.context)
            restore_title.setText(tr("üîÑ –ú–æ–∂–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "üîÑ Can be restored"))
            restore_title.setTextSize(1, 16)
            restore_title.setTextColor(get_on_primary_container())
            restore_title.setTypeface(None, Typeface.BOLD)
            restore_card.addView(restore_title)

            time_info = TextView(self.context)
            time_info.setText(
                tr(
                    f"‚è∞ –û—Å—Ç–∞–ª–æ—Å—å {hours_left}—á {mins_left}–º",
                    f"‚è∞ {hours_left}h {mins_left}m left",
                )
            )
            time_info.setTextSize(1, 13)
            time_info.setTextColor(get_on_primary_container())
            time_info.setAlpha(0.8)
            time_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            time_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
            restore_card.addView(time_info, time_params)

            restores_info = TextView(self.context)
            restores_info.setText(
                tr(
                    f"–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ: {restores_left}/{STREAK_MAX_RESTORES_PER_MONTH}",
                    f"This month: {restores_left}/{STREAK_MAX_RESTORES_PER_MONTH}",
                )
            )
            restores_info.setTextSize(1, 12)
            restores_info.setTextColor(get_on_primary_container())
            restores_info.setAlpha(0.7)
            restores_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            restores_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            restore_card.addView(restores_info, restores_params)

            info_section.addView(restore_card)
        else:
            no_restore_card = LinearLayout(self.context)
            no_restore_card.setOrientation(LinearLayout.VERTICAL)
            no_restore_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
            )
            card_bg = GradientDrawable()
            card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            card_bg.setColor(UI.surface_variant())
            no_restore_card.setBackground(card_bg)

            if streak.restore_time_left <= 0:
                reason = tr("‚è∞ –í—Ä–µ–º—è –Ω–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ", "‚è∞ Restore window expired")
            else:
                reason = tr("–õ–∏–º–∏—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω", "Restore limit reached")

            no_restore_text = TextView(self.context)
            no_restore_text.setText(reason)
            no_restore_text.setTextSize(1, 14)
            no_restore_text.setTextColor(UI.on_surface())
            no_restore_text.setGravity(Gravity.CENTER)
            no_restore_card.addView(no_restore_text)

            info_section.addView(no_restore_card)

        container.addView(info_section)

    def _create_buttons(self, is_active, streak=None):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        button_row = LinearLayout(self.context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)

        button_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        button_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        if is_active and streak and streak.is_dead:
            close_btn = self._create_button(S.CLOSE, "tonal")
            self._setButtonClick(close_btn, lambda *args: self.dismiss())
            button_row.addView(close_btn, button_params)

            if streak.can_restore:
                restore_btn = self._create_button(tr("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Restore"), "filled")
                self._setButtonClick(restore_btn, lambda *args: self._on_restore_click())
                button_row.addView(restore_btn, button_params)
            else:
                start_btn = self._create_button(tr("–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", "Start over"), "filled")
                self._setButtonClick(start_btn, lambda *args: self._on_restart_click())
                button_row.addView(start_btn, button_params)
        elif is_active:
            stop_btn = self._create_button(tr("–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Stop"), "outlined")
            self._setButtonClick(stop_btn, lambda *args: self._on_stop_click())
            button_row.addView(stop_btn, button_params)

            close_btn = self._create_button(S.CLOSE, "filled")
            self._setButtonClick(close_btn, lambda *args: self.dismiss())
            button_row.addView(close_btn, button_params)
        else:
            cancel_btn = self._create_button(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), "tonal")
            self._setButtonClick(cancel_btn, lambda *args: self.dismiss())
            button_row.addView(cancel_btn, button_params)

            start_btn = self._create_button(tr("–ù–∞—á–∞—Ç—å", "Start"), "filled")
            self._setButtonClick(start_btn, lambda *args: self._on_start_click())
            button_row.addView(start_btn, button_params)

        container.addView(button_row)

        plugin = self.plugin
        if plugin:
            try:
                sync_manager = plugin.getSyncMgr()
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    force_row = LinearLayout(self.context)
                    force_row.setOrientation(LinearLayout.HORIZONTAL)

                    force_btn = self._create_button(
                        tr("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "Force sync (override)"),
                        "outlined",
                    )
                    self._setButtonClick(force_btn, lambda *args: self._on_force_sync_click())
                    force_btn_params = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                    )
                    force_btn_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
                    force_row.addView(force_btn, force_btn_params)
                    container.addView(force_row)

            except Exception:
                pass
        return container

    def _create_button(self, text, style="filled"):
        button = TextView(self.context)
        button.setText(text)
        button.setTextSize(1, 14)
        button.setTypeface(None, Typeface.BOLD)
        button.setGravity(Gravity.CENTER)
        button.setSingleLine(True)
        button.setClickable(True)
        button.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S12),
        )

        if style == "filled":
            button.setTextColor(UI.on_primary())
            button.setBackground(UI.bg_ripple(Dp.S20, UI.primary(), UI.on_primary()))
        elif style == "tonal":
            button.setTextColor(UI.secondary())
            button.setBackground(UI.bg_ripple(Dp.S20, UI.secondary_container(), UI.secondary()))
        elif style == "outlined":
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S20))
            bg.setColor(Color.TRANSPARENT)
            bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
            button.setTextColor(UI.primary())
            button.setBackground(bg)
        return button

    def _on_start_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startStreak(chat_id)

    def _on_stop_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.stopStreak(chat_id)

    def _on_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.forceSyncNow(chat_id)

    def _on_force_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if not plugin:
            return

        activity = plugin.getActivity()
        if not activity:
            plugin.forceSyncNow(chat_id)
            return

        title = tr("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "Force sync")
        message = tr(
            "–ú–æ–∂–µ—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä–Ω—ã–º–∏.\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
            "May override local data with server data.\nContinue?",
        )

        def on_confirm(b, w):
            try:
                b.dismiss()
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                pass
            plugin.forceSyncNow(chat_id)

        plugin.showAlert(
            activity,
            title,
            message,
            tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å", "Sync"),
            on_confirm,
            tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
            lambda b, w: b.dismiss(),
        )

    def _on_restore_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.restoreStreak(chat_id)

    def _on_restart_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.restartDeadStreak(chat_id)

    def _on_pet_start(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startPet(chat_id)

    def _on_pet_feed(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.feed_pet({"chat_id": chat_id})

    def _on_pet_play(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.showPetMinigame(chat_id)

    def _on_pet_open(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.show_pet_stats({"chat_id": chat_id})

    def show(self):
        self.bottom_sheet.show()

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing streak menu: {e}")
        finally:
            self.onDismiss()


# –±–µ–π–∑
class WatamoteStreakPetPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.data_lock = threading.RLock()
        self.shutdown_event = threading.Event()
        self._executor = ThreadPoolExecutor(max_workers=4, thread_name_prefix="WSP")
        self._sync_worker_count = 4
        self._sync_executors = [
            ThreadPoolExecutor(
                max_workers=1, thread_name_prefix=f"WSP-SYNC-{i}"
            )
            for i in range(self._sync_worker_count)
        ]
        self._sync_batch_executor = ThreadPoolExecutor(
            max_workers=1, thread_name_prefix="WSP-SYNC-BATCH"
        )
        self.pets = {}
        self.streaks = {}
        self.streak_enabled_chats = set()
        self.pet_enabled_chats = set()
        self.last_messages = {}
        self.header_hook = None
        self.cleanup_hook = None
        self.active_widgets = {}
        self.widget_manager = None
        self.sync_manager = None
        self.last_auto_sync = {}
        self.last_server_check = {}
        self.last_global_server_check = 0
        self.autoSrvPause = {}
        self.autoSrvFail = {}
        self.lastAuthHealTs = 0.0
        self.authHealFails = 0
        self.background_sync_thread = None
        self.sync_backoff_seconds = 1
        self.sync_backoff_max = SYNC_BACKOFF_MAX_SECONDS
        self.sync_consecutive_errors = 0
        self.last_xp_time = {}
        self.xp_history = {}
        self.recent_messages = {}
        self.widget_positions = {}
        self.last_p2p_sync = {}
        self.P2P_MIN_INTERVAL = P2P_THROTTLE_SECONDS
        self._save_pending = False
        self.last_pet_sync = {}
        self.PET_SYNC_MIN_INTERVAL = 5
        self._pending_pet_syncs = {}
        self.last_streak_sync = {}
        self.STREAK_SYNC_MIN_INTERVAL = 5
        self._pending_streak_syncs = {}
        self.pet_revive_times = {}
        self.minigame_combo = {}
        self._last_synced_streak_hash = {}
        self._last_synced_pet_hash = {}
        self._p2p_offer_last = {}
        self.last_sync_status = {}
        self.lastSyncOk = {}
        self.actionGuard = {}
        self.actionGuardOps = 0
        self.lastSentStreak = {}
        self.lastSentPet = {}
        self.chatAccts = {}
        self.lastAcct = 0
        self.chatAllow = {}
        self.chatAllowOps = 0
        self.chatAllowTtl = 900
        self.maxChatAllow = 512
        self.p2pKeys = {}
        self.last_flame_time = {}
        self._flame_retry = {}
        self.flamePending = {}
        self._pending_chat_tasks = set()
        self.uiPending = {}
        self.uiLock = threading.Lock()
        self.taskLock = threading.Lock()
        self.taskFutures = set()
        self.maxTmp = TMP_STATE_MAX_SIZE
        self.maxUiPending = UI_PENDING_MAX_SIZE
        self.uiPendingTtl = UI_PENDING_TTL_SECONDS
        self.maxChatAccts = CHAT_ACCOUNT_MAX_SIZE
        self.maxP2pKeys = P2P_KEY_MAX_SIZE
        self.maxWidgetPos = WIDGET_POS_MAX_SIZE
        self._secretStoreUnavailableLogged = False
        self._launch_activity_class = None

    def saveSoon(self):
        if self.shutdown_event.is_set():
            return
        with self.data_lock:
            if self._save_pending:
                return
            self._save_pending = True
        def do_save():
            time.sleep(SAVE_DEBOUNCE_SECONDS)
            with self.data_lock:
                self._save_pending = False
            self.saveData()
        self.runSyncAsync(do_save)

    def runAsync(self, func, *args, **kwargs):
        try:
            if self.shutdown_event.is_set():
                return
            future = self._executor.submit(self.wrapTask(func, *args, **kwargs))
            self.trackFuture(future)
        except RuntimeError as e:
            self.log(f"WSP: runAsync executor unavailable, dropping task: {e}")

    def ensureAsync(self, fn, *args, **kwargs):
        tname = threading.current_thread().name or ""
        if tname.startswith("WSP"):
            return False
        self.runAsync(fn, *args, **kwargs)
        return True

    def trackFuture(self, future):
        try:
            if not future:
                return
            with self.taskLock:
                self.taskFutures.add(future)
            def onDone(_done):
                try:
                    with self.taskLock:
                        self.taskFutures.discard(future)
                except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                    self.log(f"WSP: failed to untrack future: {e}")
            future.add_done_callback(onDone)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: trackFuture error: {e}")

    def cancelPendingFutures(self):
        try:
            with self.taskLock:
                futures = list(self.taskFutures)
                self.taskFutures.clear()
            for future in futures:
                try:
                    future.cancel()
                except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                    self.log(f"WSP: failed to cancel future: {e}")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: cancelPendingFutures error: {e}")

    def runSyncAsync(self, func, *args, **kwargs):
        try:
            if threading.current_thread().name.startswith("WSP-SYNC-BATCH"):
                func(*args, **kwargs)
                return
            if self.shutdown_event.is_set():
                return
            future = self._sync_batch_executor.submit(self.wrapTask(func, *args, **kwargs))
            self.trackFuture(future)
        except RuntimeError as e:
            self.log(f"WSP: runSyncAsync executor unavailable, dropping task: {e}")

    def runSyncBlocking(self, func, *args, **kwargs):
        try:
            if threading.current_thread().name.startswith("WSP-SYNC-BATCH"):
                return func(*args, **kwargs)
            if self.shutdown_event.is_set():
                return None
            future = self._sync_batch_executor.submit(self.wrapTask(func, *args, **kwargs))
            self.trackFuture(future)
            return future.result()
        except RuntimeError:
            return func(*args, **kwargs)

    def _sync_index(self, chat_id):
        key = self.normChat(chat_id) or str(chat_id)
        return abs(hash(key)) % self._sync_worker_count

    def runChatSyncAsync(self, chat_id, func, *args, **kwargs):
        try:
            idx = self._sync_index(chat_id)
            prefix = f"WSP-SYNC-{idx}"
            if threading.current_thread().name.startswith(prefix):
                func(*args, **kwargs)
                return True
            if self.shutdown_event.is_set():
                return False
            future = self._sync_executors[idx].submit(self.wrapTask(func, *args, **kwargs))
            self.trackFuture(future)
            return True
        except RuntimeError as e:
            self.log(f"WSP: runChatSyncAsync executor unavailable, dropping task: {e}")
            return False

    def wrapTask(self, func, *args, **kwargs):
        def runFn():
            if self.shutdown_event.is_set():
                return
            return func(*args, **kwargs)
        return runFn

    def pruneUiPendingLocked(self, nowTs):
        if not self.uiPending:
            return
        staleBefore = nowTs - float(self.uiPendingTtl or 0)
        for pendingKey, pendingTs in list(self.uiPending.items()):
            if V.toFloat(pendingTs, 0.0) < staleBefore:
                self.uiPending.pop(pendingKey, None)
        maxPending = int(self.maxUiPending or 0)
        if maxPending <= 0 or len(self.uiPending) <= maxPending:
            return
        items = sorted(
            self.uiPending.items(),
            key=lambda kv: float(kv[1] or 0),
        )
        for oldKey, _ in items[: len(self.uiPending) - maxPending]:
            self.uiPending.pop(oldKey, None)

    def trimLruMap(self, dataMap, maxSize):
        limit = int(maxSize or 0)
        if limit <= 0 or len(dataMap) <= limit:
            return
        dropCount = len(dataMap) - limit
        for oldKey in list(dataMap.keys())[:dropCount]:
            dataMap.pop(oldKey, None)

    def runUiOnce(self, key, delayMs, func):
        try:
            with self.uiLock:
                nowTs = time.time()
                self.pruneUiPendingLocked(nowTs)
                if key in self.uiPending:
                    return False
                self.uiPending[key] = nowTs

            def runFn():
                try:
                    if self.shutdown_event.is_set():
                        return
                    func()
                finally:
                    with self.uiLock:
                        self.uiPending.pop(key, None)

            if not run_on_ui_thread(runFn, delayMs):
                with self.uiLock:
                    self.uiPending.pop(key, None)
                return False
            return True
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            try:
                with self.uiLock:
                    self.uiPending.pop(key, None)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: runUiOnce cleanup error for key={key}: {e}")
            return False

    def enqueueChatTask(self, chat_id, task_key, func, *args, **kwargs):
        if self.shutdown_event.is_set():
            return False
        chat_key = self.normChat(chat_id)
        pending_key = f"{chat_key}:{task_key}"
        with self.data_lock:
            if pending_key in self._pending_chat_tasks:
                return False
            self._pending_chat_tasks.add(pending_key)

        def _wrapped():
            try:
                if self.shutdown_event.is_set():
                    return
                func(*args, **kwargs)
            finally:
                with self.data_lock:
                    self._pending_chat_tasks.discard(pending_key)

        submitted = self.runChatSyncAsync(chat_key, _wrapped)
        if not submitted:
            with self.data_lock:
                self._pending_chat_tasks.discard(pending_key)
            return False
        return True

    def queueDelayedSync(self, chatId, lastSync, minInterval, pendingMap, sendFn):
        with self.data_lock:
            if chatId in pendingMap:
                return False
            pendingMap[chatId] = True

        def delayedSync():
            try:
                waitSec = minInterval - (time.time() - lastSync) + 0.1
                if self.shutdown_event.wait(max(0.1, waitSec)):
                    return
                if self.shutdown_event.is_set():
                    return
                sendFn()
            finally:
                with self.data_lock:
                    pendingMap.pop(chatId, None)

        queued = self.enqueueChatTask(chatId, "delayedSync", delayedSync)
        if not queued:
            with self.data_lock:
                pendingMap.pop(chatId, None)
            return False
        return True

    def guardAction(self, key, gap=0.8):
        try:
            now = time.time()
            if not self.data_lock.acquire(timeout=0.02):
                return True
            try:
                last = self.actionGuard.get(key, 0)
                if now - last < gap:
                    return True
                self.actionGuard[key] = now
                self.actionGuardOps += 1
                if self.actionGuardOps >= 1000000:
                    self.actionGuardOps = 0
                if self.actionGuardOps % 64 == 0:
                    self.trimActionGuardLocked(now)
            finally:
                self.data_lock.release()
            return False
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return False

    def trimActionGuardLocked(self, nowTs=None):
        if not self.actionGuard:
            return
        nowTs = float(nowTs if nowTs is not None else time.time())
        ttlSec = 600
        for key, ts in list(self.actionGuard.items()):
            if nowTs - float(ts or 0) > ttlSec:
                self.actionGuard.pop(key, None)
        limit = int(self.maxTmp or 0)
        if limit > 0 and len(self.actionGuard) > limit:
            items = sorted(self.actionGuard.items(), key=lambda x: float(x[1] or 0))
            remove_count = len(self.actionGuard) - limit
            for key, _ in items[:remove_count]:
                self.actionGuard.pop(key, None)

    def guardSyncStreak(self, chat_id, data):
        if not V.is_dict(data):
            return False
        chat_id = self.normChat(chat_id)
        if not chat_id:
            return False

        now = time.time()
        client_time = V.toFloat(data.get("client_time"), None)
        if client_time is not None and abs(client_time - now) > SYNC_GUARD_MAX_SKEW:
            return False

        key = chat_id
        with self.data_lock:
            last = self.lastSentStreak.get(key)
        if last:
            prev = last.get("data", {})
            prev_ts = V.toFloat(prev.get("timestamp"), 0.0)
            curr_ts = V.toFloat(data.get("timestamp"), 0.0)
            if curr_ts < prev_ts - 5:
                return False

            prev_count = V.toInt(prev.get("count"), 0)
            curr_count = V.toInt(data.get("count"), 0)
            prev_last = prev.get("last_date")
            curr_last = data.get("last_date")
            if prev_count <= 0 or not prev_last or not curr_last:
                with self.data_lock:
                    self.lastSentStreak[key] = {"data": data, "ts": now}
                return True

            delta = curr_count - prev_count
            day_diff = 0
            try:
                prev_date = datetime.fromisoformat(prev_last).date()
                curr_date = datetime.fromisoformat(curr_last).date()
                day_diff = (curr_date - prev_date).days
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                day_diff = 0

            if day_diff < 0:
                return False

            limit = max(SYNC_GUARD_MAX_STREAK_STEP, day_diff)
            if delta > limit:
                last_ts = V.toFloat(last.get("ts"), 0.0)
                if now - last_ts < SYNC_GUARD_STREAK_WINDOW:
                    return False

        with self.data_lock:
            self.lastSentStreak[key] = {"data": data, "ts": now}
        return True

    def guardSyncPet(self, chat_id, data):
        if not V.is_dict(data):
            return False
        chat_id = self.normChat(chat_id)
        if not chat_id:
            return False

        now = time.time()
        client_time = V.toFloat(data.get("client_time"), None)
        if client_time is not None and abs(client_time - now) > SYNC_GUARD_MAX_SKEW:
            return False

        key = chat_id
        with self.data_lock:
            last = self.lastSentPet.get(key)
        if last:
            prev = last.get("data", {})
            prev_ts = V.toFloat(prev.get("timestamp"), 0.0)
            curr_ts = V.toFloat(data.get("timestamp"), 0.0)
            if curr_ts < prev_ts - 5:
                return False

            curr_xp = V.toFloat(data.get("xp"), 0.0)
            prev_xp = V.toFloat(prev.get("xp"), 0.0)
            xp_delta = curr_xp - prev_xp
            if xp_delta > SYNC_GUARD_MAX_XP_STEP:
                return False

            curr_stage = V.toInt(data.get("stage"), 0)
            prev_stage = V.toInt(prev.get("stage"), 0)
            stage_delta = curr_stage - prev_stage
            if stage_delta > SYNC_GUARD_MAX_STAGE_STEP:
                return False

        with self.data_lock:
            self.lastSentPet[key] = {"data": data, "ts": now}
        return True

    def hashSync(self, data):
        try:
            payload = json.dumps(data, sort_keys=True, separators=(",", ":"))
        except (TypeError, ValueError, OverflowError, RecursionError):
            payload = repr(data)
        return hashlib.sha256(payload.encode("utf-8")).hexdigest()

    def setSyncedHash(self, chat_id, streak_data=None, pet_data=None):
        chat_key = self.normChat(chat_id)
        if streak_data is not None:
            self._last_synced_streak_hash[chat_key] = self.hashSync(streak_data)
        if pet_data is not None:
            self._last_synced_pet_hash[chat_key] = self.hashSync(pet_data)

    def markStreakDeleted(self, streak, update_sync_ts=False):
        if not streak:
            return
        streak.count = 0
        streak.last_date = None
        streak.first_date = None
        streak.deleted = True
        if update_sync_ts:
            streak.last_sync_timestamp = time.time()

    def markPetDeleted(self, pet, update_sync_ts=False):
        if not pet:
            return
        pet.deleted = True
        if update_sync_ts:
            pet.last_sync_timestamp = time.time()

    def mergeRemoteSync(
        self,
        kind,
        chat_id,
        local_obj,
        remote_data,
        source,
        update_hash=False,
        ignore_local_priority=False,
    ):
        result = {
            "action": "no_remote",
            "applied": False,
            "kind": kind,
            "source": source,
        }
        if not remote_data or not local_obj:
            return result

        local_data = local_obj.get_sync_data()
        if StreakSyncManager.should_accept_sync(
            local_data, remote_data, ignore_local_priority=ignore_local_priority
        ):
            local_obj.apply_sync_data(remote_data, source=source)
            result["action"] = "accept_remote"
            result["applied"] = True
            if update_hash:
                if kind == "streak":
                    self.setSyncedHash(
                        chat_id, streak_data=local_obj.get_sync_data()
                    )
                else:
                    self.setSyncedHash(chat_id, pet_data=local_obj.get_sync_data())
            try:
                self.recordSyncStatus(chat_id, f"remote:{source}", True)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: failed to record sync status (accept_remote): {e}")
        else:
            result["action"] = "keep_local"
            try:
                self.recordSyncStatus(chat_id, f"remote:{source}", False)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: failed to record sync status (keep_local): {e}")
        try:
            local_ts = None
            remote_ts = None
            if isinstance(local_data, dict):
                local_ts = local_data.get("timestamp")
            if isinstance(remote_data, dict):
                remote_ts = remote_data.get("timestamp")
            self.logSyncDecision(
                kind,
                chat_id,
                source,
                result["action"],
                local_ts=local_ts,
                remote_ts=remote_ts,
            )
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to log sync decision for chat {chat_id}: {e}")
        return result

    def logSyncDecision(
        self,
        kind,
        chat_id,
        source,
        action,
        local_ts=None,
        remote_ts=None,
        reason=None,
    ):
        try:
            parts = [
                f"WSP: sync {kind} chat={chat_id} source={source} action={action}"
            ]
            if reason:
                parts.append(f"reason={reason}")
            if local_ts is not None:
                parts.append(f"local_ts={int(local_ts)}")
            if remote_ts is not None:
                parts.append(f"remote_ts={int(remote_ts)}")
            self.log(" ".join(parts))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: logSyncDecision error: {e}")

    def shouldApplyRemoteDelete(
        self, local_obj, remote_data, source, ignore_local_priority=False
    ):
        if not local_obj:
            return True
        if getattr(local_obj, "deleted", False):
            return True
        local_data = local_obj.get_sync_data()
        return StreakSyncManager.should_accept_sync(
            local_data, remote_data, ignore_local_priority=ignore_local_priority
        )

    def offerP2pSwitch(self, chat_id, offer_key=None):
        if not self.get_setting("p2p_switch_offer", True):
            return

        sync_manager = self.getSyncMgr()
        if sync_manager.mode in [
            StreakSyncManager.MODE_P2P,
            StreakSyncManager.MODE_LOCAL,
        ]:
            return
        if not offer_key and not self.getP2pKey(chat_id):
            return

        now = time.time()
        chat_key = self.normChat(chat_id)
        last_offer = self._p2p_offer_last.get(chat_key, 0)
        if now - last_offer < P2P_SWITCH_OFFER_COOLDOWN_SECONDS:
            return

        def show_prompt():
            activity = self.getActivity()
            if not activity:
                self.log(f"WSP: skip P2P switch prompt for {chat_id}: no activity")
                return
            self._p2p_offer_last[chat_key] = time.time()

            title = tr("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ P2P-—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "P2P sync detected")
            message = tr(
                "–ü–æ—Ö–æ–∂–µ, —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç P2P. –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ P2P –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏?",
                "Looks like your peer uses P2P. Switch to P2P for stable syncing?",
            )

            def on_switch(b, w):
                try:
                    b.dismiss()
                except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                    self.log(f"WSP: failed to dismiss P2P switch dialog: {e}")
                if offer_key:
                    self.setP2pKey(chat_id, offer_key)
                    self.saveSoon()
                self.set_setting("streak_sync_mode", 0)
                self._sync_manager_cache_time = 0
                self.getSyncMgr()
                bulletin_safe(
                    "success",
                    tr("–†–µ–∂–∏–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: P2P", "Sync mode: P2P"),
                )

            self.showAlert(
                activity,
                title,
                message,
                tr("–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è", "Switch"),
                on_switch,
                tr("–ù–µ —Å–µ–π—á–∞—Å", "Not now"),
                lambda b, w: b.dismiss(),
            )

        run_on_ui_thread(show_prompt)

    def log(self, message):
        log(message)

    def bulletin(self, kind, message, ui_thread=False):
        bulletin_safe(kind, message, ui_thread)

    def showAlert(
        self,
        activity,
        title,
        message,
        positive_text="OK",
        on_positive=None,
        negative_text=None,
        on_negative=None,
    ):
        from ui.alert import AlertDialogBuilder

        builder = AlertDialogBuilder(activity)
        builder.set_title(title)
        builder.set_message(message)
        if positive_text:
            builder.set_positive_button(
                positive_text, on_positive or (lambda b, w: b.dismiss())
            )
        if negative_text:
            builder.set_negative_button(
                negative_text, on_negative or (lambda b, w: b.dismiss())
            )

        refs = {"dialog": None}

        def on_dismiss():
            refs["dialog"] = None

        dialog = safeShowDialog(builder, on_dismiss)
        refs["dialog"] = dialog

    def isPrivateChat(self, chat_id):
        chat_id_int = V.toInt(self.normChat(chat_id), 0)
        return chat_id_int > 0

    def isPrivateDialog(self, activity, chat_id):
        if not self.isPrivateChat(chat_id):
            return False
        if not activity:
            return True
        try:
            get_chat = getattr(activity, "getCurrentChat", None)
            current_chat = get_chat() if callable(get_chat) else getattr(activity, "currentChat", None)
            if current_chat:
                return False
        except Exception:
            pass
        try:
            get_user = getattr(activity, "getCurrentUser", None)
            current_user = get_user() if callable(get_user) else getattr(activity, "currentUser", None)
            if current_user:
                uid = getattr(current_user, "id", None)
                if uid is None:
                    uid = getattr(current_user, "user_id", None)
                if uid:
                    chat_key = self.normChat(chat_id)
                    user_key = self.normChat(uid)
                    if chat_key and user_key and chat_key != user_key:
                        return False
                return True
        except Exception:
            pass
        return True

    def chatAllowKey(self, chat_id, acct=None):
        chat_key = self.normChat(chat_id)
        acct_key = (
            V.toInt(acct, 0) if acct is not None else V.toInt(self.lastAcct or 0, 0)
        )
        return f"{acct_key}:{chat_key}"

    def trimChatAllowLocked(self, nowTs=None):
        if not self.chatAllow:
            return
        nowTs = float(nowTs if nowTs is not None else time.time())
        ttlSec = float(self.chatAllowTtl or 0)
        if ttlSec > 0:
            for key, data in list(self.chatAllow.items()):
                ts = V.toFloat((data or {}).get("ts", 0), 0.0)
                if nowTs - ts > ttlSec:
                    self.chatAllow.pop(key, None)
        limit = int(self.maxChatAllow or 0)
        if limit > 0 and len(self.chatAllow) > limit:
            items = sorted(
                self.chatAllow.items(),
                key=lambda kv: float((kv[1] or {}).get("ts", 0)),
            )
            for key, _ in items[: len(self.chatAllow) - limit]:
                self.chatAllow.pop(key, None)

    def getChatAllowCached(self, chat_id, acct=None):
        key = self.chatAllowKey(chat_id, acct=acct)
        now = time.time()
        with self.data_lock:
            data = self.chatAllow.get(key)
            if not data:
                return None
            ts = float(data.get("ts", 0) or 0)
            if now - ts > float(self.chatAllowTtl or 0):
                self.chatAllow.pop(key, None)
                return None
            data["ts"] = now
            self.chatAllow[key] = data
            return bool(data.get("ok", False))

    def setChatAllowCached(self, chat_id, acct, allowed):
        key = self.chatAllowKey(chat_id, acct=acct)
        now = time.time()
        with self.data_lock:
            self.chatAllow[key] = {"ok": bool(allowed), "ts": now}
            self.chatAllowOps += 1
            if self.chatAllowOps >= 1000000:
                self.chatAllowOps = 0
            if self.chatAllowOps % 32 == 0:
                self.trimChatAllowLocked(now)

    def isChatAllowed(self, chat_id, acct=None):
        try:
            chat_id = self.normChat(chat_id)
            chat_id_int = int(chat_id)
            if chat_id_int <= 0:
                self.log(f"WSP: chat {chat_id} rejected - group/channel (chat_id <= 0)")
                self.setChatAllowCached(chat_id, acct, False)
                return False

            acct = self.getAcct(chat_id=chat_id, acct=acct)
            cached = self.getChatAllowCached(chat_id, acct=acct)
            if cached is not None:
                return bool(cached)
            my_user_id = self.getMyId(acct=acct)

            if chat_id_int == my_user_id:
                self.log(
                    f"WSP: chat {chat_id} rejected - Saved Messages (chat with self)"
                )
                self.setChatAllowCached(chat_id, acct, False)
                return False

            try:
                MessagesController = find_class(
                    "org.telegram.messenger.MessagesController"
                )
                if MessagesController:
                    controller = MessagesController.getInstance(int(acct))
                    user = controller.getUser(chat_id_int)
                    if user:
                        is_bot = getattr(user, "bot", False)
                        if is_bot:
                            self.log(f"WSP: chat {chat_id} rejected - bot user")
                            self.setChatAllowCached(chat_id, acct, False)
                            return False
            except Exception as e:
                self.log(f"WSP: error checking if user is bot: {e}")
            self.setChatAllowCached(chat_id, acct, True)
            return True
        except Exception as e:
            self.log(f"WSP: isChatAllowed exception for {chat_id}: {e}")
            try:
                self.setChatAllowCached(chat_id, acct, False)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                pass
            return False

    def needPetChat(self, chat_id):
        if not self.isChatAllowed(chat_id):
            bulletin_safe("error", tr("–ü–∏—Ç–æ–º—Ü—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Pets aren't available in this chat"))
            return False
        return True

    def getEnabledPet(self, chat_id, dead_message):
        chat_id = self.normChat(chat_id)
        if chat_id not in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü –≤ —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ –∑–∞–≤–µ–¥–µ–Ω", "No pet yet in this chat"))
            return None
        pet = self.pets.get(chat_id)
        if not pet:
            bulletin_safe("info", tr("–°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ–¥–∏ –ø–∏—Ç–æ–º—Ü–∞", "Get a pet first"))
            return None
        if pet.deleted:
            bulletin_safe("error", dead_message)
            return None
        return pet

    def getActivity(self, log_prefix=""):
        fragment = get_last_fragment()
        if not fragment:
            if log_prefix:
                self.log(f"{log_prefix} context is None!")
            return None
        activity = fragment.getParentActivity()
        if not activity:
            if log_prefix:
                self.log(f"{log_prefix} activity is None!")
            return None
        return activity

    def extractChatId(self, data):
        if not data:
            return ""
        chat_id = data.get("chat_id") or data.get("dialog_id")
        return self.normChat(chat_id) if chat_id else ""

    def normChat(self, chat_id):
        if chat_id is None:
            return ""
        try:
            return str(chat_id)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return ""

    def setChatAccount(self, chat_id, acct):
        if chat_id is None or acct is None:
            return
        chatKey = self.normChat(chat_id)
        acctInt = V.toInt(acct, None)
        if acctInt is None:
            self.log(f"WSP: setChatAccount invalid acct for chat={chat_id}")
            return
        try:
            self.lastAcct = acctInt
            with self.data_lock:
                if chatKey in self.chatAccts:
                    self.chatAccts.pop(chatKey, None)
                self.chatAccts[chatKey] = acctInt
                self.trimLruMap(self.chatAccts, self.maxChatAccts)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: setChatAccount error for chat={chat_id}: {e}")

    def getAcct(self, chat_id=None, acct=None):
        if acct is not None:
            acct_int = V.toInt(acct, None)
            if acct_int is not None:
                return acct_int
            self.log("WSP: getAcct direct cast error: invalid acct value")
        if chat_id is not None:
            mapped = self.chatAccts.get(self.normChat(chat_id))
            if mapped is not None:
                mapped_int = V.toInt(mapped, None)
                if mapped_int is not None:
                    return mapped_int
                self.log("WSP: getAcct mapped account read error: invalid mapped value")
        return V.toInt(self.lastAcct or 0, 0)

    def getMyId(self, acct=None):
        try:
            UserConfig = find_class("org.telegram.messenger.UserConfig")
            if UserConfig:
                acct = self.getAcct(acct=acct)
                user_config = UserConfig.getInstance(int(acct))
                return user_config.getClientUserId()
            else:
                self.log("WSP: UserConfig class not found")
        except Exception as e:
            self.log(f"WSP: failed to get my_user_id: {e}")
        return 0

    def getInstallId(self):
        try:
            install_id = self.get_setting("install_id", None)
            if install_id and isinstance(install_id, str):
                return install_id
            install_id = secrets.token_hex(16)
            self.set_setting("install_id", install_id)
            saved = self.get_setting("install_id", None)
            if saved == install_id:
                return install_id
            self.log("WSP: failed to persist install_id")
            return None
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: getInstallId error: {e}")
            return None

    def _secretStoreKey(self):
        install_id = ""
        try:
            install_id = self.get_setting("install_id", "") or ""
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            install_id = ""
        if not install_id:
            try:
                install_id = self.getInstallId()
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                install_id = ""
        if not install_id:
            if not self._secretStoreUnavailableLogged:
                self._secretStoreUnavailableLogged = True
                self.log("WSP: secure secret storage unavailable (install_id missing)")
            return None
        self._secretStoreUnavailableLogged = False
        seed = f"{__id__}|{install_id}|local-sec".encode("utf-8")
        return hashlib.sha256(seed).digest()

    def _sealSecretText(self, value):
        try:
            if value is None:
                return ""
            if isinstance(value, (dict, list)):
                plain_text = json.dumps(value, separators=(",", ":"), ensure_ascii=False)
            else:
                plain_text = str(value)
            sealed = self._sealSecretTextKeystore(plain_text)
            if sealed:
                return sealed
            return self._sealSecretTextLegacy(plain_text)
        except Exception:
            return None

    def _isSealedSecret(self, value):
        return (
            isinstance(value, str)
            and (
                value.startswith(SEC_STORE_PREFIX_KS)
                or value.startswith(SEC_STORE_PREFIX)
            )
        )

    def _keystoreAlias(self):
        return f"{__id__}.secrets.v1"

    def _getOrCreateKeystoreSecretKey(self):
        try:
            from java.security import KeyStore
            from javax.crypto import KeyGenerator
            from android.security.keystore import KeyGenParameterSpec, KeyProperties
        except Exception:
            return None
        try:
            key_store = KeyStore.getInstance("AndroidKeyStore")
            key_store.load(None)
            alias = self._keystoreAlias()
            if not key_store.containsAlias(alias):
                purposes = int(KeyProperties.PURPOSE_ENCRYPT) | int(
                    KeyProperties.PURPOSE_DECRYPT
                )
                builder = KeyGenParameterSpec.Builder(alias, purposes)
                try:
                    builder.setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                    builder.setEncryptionPaddings(
                        KeyProperties.ENCRYPTION_PADDING_NONE
                    )
                except Exception:
                    builder.setBlockModes([KeyProperties.BLOCK_MODE_GCM])
                    builder.setEncryptionPaddings(
                        [KeyProperties.ENCRYPTION_PADDING_NONE]
                    )
                try:
                    builder.setUserAuthenticationRequired(False)
                except Exception as e:
                    self.log(f"WSP: keystore auth requirement setup skipped: {e}")
                key_generator = KeyGenerator.getInstance(
                    KeyProperties.KEY_ALGORITHM_AES,
                    "AndroidKeyStore",
                )
                key_generator.init(builder.build())
                key_generator.generateKey()
            return key_store.getKey(alias, None)
        except Exception:
            return None

    def _sealSecretTextKeystore(self, plain_text):
        try:
            from javax.crypto import Cipher
        except Exception:
            return None
        try:
            key = self._getOrCreateKeystoreSecretKey()
            if not key:
                return None
            cipher = Cipher.getInstance("AES/GCM/NoPadding")
            cipher.init(Cipher.ENCRYPT_MODE, key)
            iv = bytes(bytearray(cipher.getIV()))
            encrypted = bytes(bytearray(cipher.doFinal(plain_text.encode("utf-8"))))
            packed = base64.urlsafe_b64encode(iv + encrypted).decode("ascii").rstrip("=")
            return f"{SEC_STORE_PREFIX_KS}{packed}"
        except Exception:
            return None

    def _openSecretTextKeystore(self, value):
        try:
            from javax.crypto import Cipher
            from javax.crypto.spec import GCMParameterSpec
        except Exception:
            return None
        try:
            if not value.startswith(SEC_STORE_PREFIX_KS):
                return None
            packed = value[len(SEC_STORE_PREFIX_KS) :]
            packed += "=" * (-len(packed) % 4)
            raw = base64.urlsafe_b64decode(packed.encode("ascii"))
            if len(raw) <= 12:
                return None
            iv = raw[:12]
            encrypted = raw[12:]
            key = self._getOrCreateKeystoreSecretKey()
            if not key:
                return None
            cipher = Cipher.getInstance("AES/GCM/NoPadding")
            spec = GCMParameterSpec(128, iv)
            cipher.init(Cipher.DECRYPT_MODE, key, spec)
            plain = bytes(bytearray(cipher.doFinal(encrypted)))
            return plain.decode("utf-8")
        except Exception:
            return None

    def _sealSecretTextLegacy(self, plain_text):
        try:
            plain = plain_text.encode("utf-8")
            nonce = secrets.token_bytes(12)
            key = self._secretStoreKey()
            if not key:
                return None
            stream = bytearray()
            counter = 0
            while len(stream) < len(plain):
                block = hmac.new(
                    key,
                    nonce + counter.to_bytes(4, "big"),
                    hashlib.sha256,
                ).digest()
                stream.extend(block)
                counter += 1
            cipher = bytes(plain[i] ^ stream[i] for i in range(len(plain)))
            tag = hmac.new(key, nonce + cipher, hashlib.sha256).digest()[:16]
            packed = base64.urlsafe_b64encode(nonce + tag + cipher).decode("ascii").rstrip("=")
            return f"{SEC_STORE_PREFIX}{packed}"
        except Exception:
            return None

    def _openSecretTextLegacy(self, value):
        try:
            if not value.startswith(SEC_STORE_PREFIX):
                return None
            packed = value[len(SEC_STORE_PREFIX):]
            packed += "=" * (-len(packed) % 4)
            raw = base64.urlsafe_b64decode(packed.encode("ascii"))
            if len(raw) < 28:
                return None
            nonce = raw[:12]
            tag = raw[12:28]
            cipher = raw[28:]
            key = self._secretStoreKey()
            if not key:
                return None
            expected = hmac.new(key, nonce + cipher, hashlib.sha256).digest()[:16]
            if not hmac.compare_digest(tag, expected):
                return None
            stream = bytearray()
            counter = 0
            while len(stream) < len(cipher):
                block = hmac.new(
                    key,
                    nonce + counter.to_bytes(4, "big"),
                    hashlib.sha256,
                ).digest()
                stream.extend(block)
                counter += 1
            plain = bytes(cipher[i] ^ stream[i] for i in range(len(cipher)))
            return plain.decode("utf-8")
        except Exception:
            return None

    def _openSecretText(self, value):
        try:
            if not value or not isinstance(value, str):
                return None
            if value.startswith(SEC_STORE_PREFIX_KS):
                return self._openSecretTextKeystore(value)
            if value.startswith(SEC_STORE_PREFIX):
                return self._openSecretTextLegacy(value)
            return None
        except Exception:
            return None

    def _getSecretSettingStr(self, key):
        try:
            raw = self.get_setting(key, None)
            if not raw or not isinstance(raw, str):
                return None
            decoded = self._openSecretText(raw)
            if decoded is not None:
                return decoded
            if self._isSealedSecret(raw):
                return None
            sealed = self._sealSecretText(raw)
            if not sealed:
                self.log(f"WSP: failed to seal secret setting for key={key}")
                return None
            try:
                self.set_setting(key, sealed)
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: failed to persist sealed secret for key={key}: {e}")
                return None
            return raw
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: _getSecretSettingStr error for key={key}: {e}")
            return None

    def _setSecretSettingStr(self, key, value):
        try:
            if value is None or not isinstance(value, str):
                return False
            sealed = self._sealSecretText(value)
            if not sealed:
                return False
            self.set_setting(key, sealed)
            return True
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return False

    def _getSecretSettingDict(self, key):
        try:
            raw = self.get_setting(key, {})
            if isinstance(raw, dict):
                sealed = self._sealSecretText(raw)
                if sealed:
                    try:
                        self.set_setting(key, sealed)
                    except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                        self.log(f"WSP: failed to migrate secret dict key={key}: {e}")
                return raw
            if not isinstance(raw, str) or not raw:
                return {}
            decoded = self._openSecretText(raw)
            if decoded is None:
                return {}
            data = json.loads(decoded)
            return data if isinstance(data, dict) else {}
        except (
            TypeError,
            ValueError,
            AttributeError,
            RuntimeError,
            OSError,
            json.JSONDecodeError,
        ):
            return {}

    def _setSecretSettingDict(self, key, value):
        try:
            if not isinstance(value, dict):
                return False
            sealed = self._sealSecretText(value)
            if not sealed:
                return False
            self.set_setting(key, sealed)
            return True
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return False

    def getServerUrl(self):
        return StreakSyncManager.SERVER_URL

    def getDevKey(self):
        try:
            key = self._getSecretSettingStr("devkey")
            if key and isinstance(key, str):
                return key
            key = secrets.token_hex(16)
            if self._setSecretSettingStr("devkey", key):
                return key
            self.log("WSP: secure storage unavailable, devkey not persisted")
            return None
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: getDevKey error: {e}")
            return None

    def getInstallSecret(self):
        try:
            secret = self._getSecretSettingStr("install_secret")
            if secret and isinstance(secret, str):
                return secret
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: getInstallSecret error: {e}")
        return None

    def setInstallSecret(self, secret):
        if not secret or not isinstance(secret, str):
            return False
        return self._setSecretSettingStr("install_secret", secret)

    def setResetSecretFlag(self, value):
        try:
            self.set_setting("reset_secret", bool(value))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: setResetSecretFlag error: {e}")

    def getLastMenuTab(self, chat_id):
        try:
            data = self.get_setting("last_tab", {})
            data = data if V.is_dict(data) else {}
            return data.get(self.normChat(chat_id))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return None

    def setLastMenuTab(self, chat_id, tab_id):
        try:
            data = self.get_setting("last_tab", {})
            data = data if V.is_dict(data) else {}
            data[self.normChat(chat_id)] = str(tab_id)
            self.set_setting("last_tab", data)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: setLastMenuTab error for chat={chat_id}: {e}")

    def getP2pKey(self, chat_id):
        with self.data_lock:
            return self.p2pKeys.get(self.normChat(chat_id))

    def setP2pKey(self, chat_id, key):
        if not key or not isinstance(key, str):
            return
        if not P2P_KEY_RE.fullmatch(key):
            return
        with self.data_lock:
            self.p2pKeys[self.normChat(chat_id)] = key

    def newP2pKey(self, chat_id):
        key = secrets.token_hex(16)
        with self.data_lock:
            self.p2pKeys[self.normChat(chat_id)] = key
        self.saveSoon()
        return key

    def getStreakKey(self, chat_id):
        chat_id = self.normChat(chat_id)
        my_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
        other_id = chat_id

        my_id_int = V.toInt(my_id, 0)
        if my_id_int <= 0:
            return f"pending:{other_id}"

        other_id_int = V.toInt(other_id, None)
        if other_id_int is not None:
            user_ids = sorted([my_id_int, other_id_int])
        else:
            user_ids = sorted([str(my_id), str(other_id)])
        streak_key = f"{user_ids[0]}:{user_ids[1]}"
        self.migratePendingStreakKey(other_id, streak_key)
        return streak_key

    def getSortedIds(self, chat_id):
        chat_id = self.normChat(chat_id)
        my_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
        my_id_int = V.toInt(my_id, 0)
        if my_id_int <= 0:
            return None, None
        other_id = V.toInt(chat_id, None)
        if other_id is None:
            return None, None
        ids = sorted([my_id_int, other_id])
        return ids[0], ids[1]

    def sortedIdsFast(self, chat_id, my_user_id=None):
        chat_key = self.normChat(chat_id)
        other_id = V.toInt(chat_key, None)
        my_id_int = V.toInt(my_user_id, 0)
        if my_id_int <= 0:
            my_id = self.getMyId(acct=self.getAcct(chat_id=chat_key))
            my_id_int = V.toInt(my_id, 0)
        if my_id_int <= 0 or other_id is None:
            return self.getSortedIds(chat_key)
        ids = sorted([my_id_int, other_id])
        return ids[0], ids[1]

    def migrateAllPendingStreaks(self):
        my_id = self.getMyId()
        if not my_id or my_id <= 0:
            return
        my_id_str = str(my_id)
        with self.data_lock:
            pending_keys = [
                k for k in self.streaks.keys()
                if isinstance(k, str) and k.startswith("pending:")
            ]

        for pending_key in pending_keys:
            chat_id = pending_key.split(":", 1)[1]
            other_id = str(chat_id)
            user_ids = sorted([my_id_str, other_id])
            target_key = f"{user_ids[0]}:{user_ids[1]}"
            self.migratePendingStreakKey(chat_id, target_key)

    def cleanupPendingStreaks(self):
        with self.data_lock:
            pending_keys = [
                k for k, v in self.streaks.items()
                if isinstance(k, str)
                and k.startswith("pending:")
                and v
                and getattr(v, "count", 0) == 0
                and getattr(v, "deleted", False)
            ]
            for key in pending_keys:
                del self.streaks[key]
                self.log(f"WSP: removed inactive pending streak {key}")

    def migratePendingStreakKey(self, chat_id, target_key):
        pending_key = f"pending:{chat_id}"
        if pending_key == target_key:
            return

        with self.data_lock:
            pending = self.streaks.get(pending_key)
            if not pending:
                return

            existing = self.streaks.get(target_key)
            if not existing:
                self.streaks[target_key] = pending
                del self.streaks[pending_key]
                self.log(
                    f"WSP: migrated pending streak key {pending_key} -> {target_key}"
                )
                return

            keep_pending = (
                getattr(pending, "last_sync_timestamp", 0)
                > getattr(existing, "last_sync_timestamp", 0)
            )
            if keep_pending:
                self.streaks[target_key] = pending
            del self.streaks[pending_key]
            self.log(
                f"WSP: merged pending streak key {pending_key} into {target_key} (kept_pending={keep_pending})"
            )
    def getStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if not self.isPrivateChat(chat_id):
            return None

        streak_key = self.getStreakKey(chat_id)
        return self.streaks.get(streak_key)

    def onStreakDied(self, chat_id):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            pet = self.pets.get(chat_id)
            if pet and not pet.deleted:
                self.markPetDeleted(pet)
                self.pet_enabled_chats.discard(chat_id)
                self.log(f"WSP: pet also died with streak for chat {chat_id}")
                self.saveSoon()
                self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)

    def shouldRunSync(self):
        if not self.get_setting("background_sync", True):
            return False

        sync_manager = self.getSyncMgr()
        if sync_manager.mode not in [
            StreakSyncManager.MODE_SERVER,
            StreakSyncManager.MODE_AUTO,
        ]:
            return False

        my_user_id = self.getMyId()
        return my_user_id and my_user_id > 0

    def shouldCheckServer(self, chat_id, min_interval):
        now = time.time()
        if now - self.last_global_server_check < 2:
            return False

        sync_manager = self.getSyncMgr()
        cooldown = min_interval
        if getattr(sync_manager, "server_degraded", False):
            cooldown = cooldown * 3

        last_check = self.last_server_check.get(chat_id, 0)
        if now - last_check < cooldown:
            return False

        self.last_server_check[chat_id] = now
        self.last_global_server_check = now
        return True

    def shouldCheckServerFast(self, chat_id, min_interval):
        now = time.time()
        if now - self.last_global_server_check < 2:
            return False
        last_check = self.last_server_check.get(chat_id, 0)
        if now - last_check < min_interval:
            return False
        self.last_server_check[chat_id] = now
        self.last_global_server_check = now
        return True

    def getSyncInterval(self):
        sync_interval_index = self.get_setting("auto_sync_interval", 1)
        sync_interval = (
            SYNC_INTERVAL_OPTIONS[sync_interval_index]
            if sync_interval_index < len(SYNC_INTERVAL_OPTIONS)
            else SYNC_INTERVAL_OPTIONS[SYNC_INTERVAL_DEFAULT_INDEX]
        )
        sync_manager = self.getSyncMgr()
        if getattr(sync_manager, "server_degraded", False):
            sync_interval = min(sync_interval * 2, SYNC_INTERVAL_DISABLED)
        return sync_interval

    def getSyncMode(self):
        sync_mode_index = self.get_setting(
            "streak_sync_mode", SYNC_MODE_DEFAULT_INDEX
        )
        return SYNC_MODE_BY_INDEX.get(sync_mode_index, SYNC_MODE_DEFAULT)

    def checkExpiredStreaks(self):
        with self.data_lock:
            for streak_key, streak in list(self.streaks.items()):
                if streak and not streak.deleted:
                    try:
                        if streak.check_and_reset_if_expired():
                            chat_id = streak.chat_id
                            self.log(f"WSP: streak expired and reset for {chat_id}")
                            if streak.is_dead:
                                self.onStreakDied(chat_id)
                            self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, True)
                    except Exception as e:
                        self.log(
                            f"WSP: error checking streak expiration for {streak_key}: {e}"
                        )

    def collectChatsForSync(self):
        with self.data_lock:
            chats_with_streaks = list(self.streak_enabled_chats.copy())
            chats_with_pets = list(self.pet_enabled_chats.copy())
            chats_to_sync = list(set(chats_with_streaks + chats_with_pets))

        self.log(
            f"WSP: background sync starting for {len(chats_to_sync)} chats "
            f"(streaks: {len(chats_with_streaks)}, pets: {len(chats_with_pets)})"
        )

        return chats_with_streaks, chats_with_pets

    def collectSyncData(self, chats_with_streaks, chats_with_pets):
        streak_data_list = []
        pet_data_list = []

        with self.data_lock:
            for chat_id in chats_with_streaks:
                chat_key = self.normChat(chat_id)
                streak_key = self.getStreakKey(chat_key)
                streak = self.streaks.get(streak_key)
                if not streak:
                    for candidate in self.streaks.values():
                        if getattr(candidate, "chat_id", None) == chat_key:
                            streak = candidate
                            break
                if streak and not streak.deleted:
                    streak_data = streak.get_sync_data()
                    if (
                        self._last_synced_streak_hash.get(chat_key)
                        != self.hashSync(streak_data)
                    ):
                        if not self.guardSyncStreak(chat_key, streak_data):
                            self.recordSyncStatus(chat_key, "send:server", False, "client_guard")
                            continue
                        streak_data_list.append((chat_key, streak_data))

            for chat_id in chats_with_pets:
                chat_key = self.normChat(chat_id)
                pet = self.pets.get(chat_key)
                if pet and not pet.deleted:
                    pet_data = pet.get_sync_data()
                    if (
                        self._last_synced_pet_hash.get(chat_key)
                        != self.hashSync(pet_data)
                    ):
                        if not self.guardSyncPet(chat_key, pet_data):
                            self.recordSyncStatus(chat_key, "send:server", False, "client_guard")
                            continue
                        pet_data_list.append((chat_key, pet_data))

        return streak_data_list, pet_data_list

    def buildServerChatKeyMaps(self, sync_manager):
        streak_map = {}
        for streak_key, streak in self.streaks.items():
            chat_id = getattr(streak, "chat_id", None)
            if chat_id is None:
                continue
            chat_id_str = self.normChat(chat_id)
            if not chat_id_str.isdigit():
                continue
            acct = self.getAcct(chat_id=chat_id_str)
            my_user_id = V.toInt(self.getMyId(acct=acct), 0)
            if my_user_id <= 0:
                continue
            client_key = sync_manager.clientKey(my_user_id, chat_id_str)
            if client_key:
                streak_map[client_key] = streak_key

        pet_map = {}
        for chat_id in self.pets.keys():
            chat_id_str = self.normChat(chat_id)
            if not chat_id_str.isdigit():
                continue
            acct = self.getAcct(chat_id=chat_id_str)
            my_user_id = V.toInt(self.getMyId(acct=acct), 0)
            if my_user_id <= 0:
                continue
            client_key = sync_manager.clientKey(my_user_id, chat_id_str)
            if client_key:
                pet_map[client_key] = chat_id

        return streak_map, pet_map

    def applySyncResults(self, results):
        if not results:
            return

        sync_manager = self.getSyncMgr()
        if not sync_manager:
            return
        streak_map, pet_map = self.buildServerChatKeyMaps(sync_manager)

        with self.data_lock:
            for streak_result in results.get("streaks", []):
                server_data = streak_result.get("data")
                action = streak_result.get("action")

                client_key = streak_result.get("client_key") or streak_result.get("chat_key")
                local_key = client_key if client_key in self.streaks else streak_map.get(
                    client_key
                )
                if local_key and local_key in self.streaks:
                    if server_data:
                        self.streaks[local_key].apply_sync_data(
                            server_data, source="server"
                        )
                        self.log(
                            f"WSP: batch-sync merged streak {local_key}, action={action}"
                        )
                    self.setSyncedHash(
                        self.streaks[local_key].chat_id,
                        streak_data=self.streaks[local_key].get_sync_data(),
                    )

            for pet_result in results.get("pets", []):
                server_data = pet_result.get("data")
                action = pet_result.get("action")

                client_key = pet_result.get("client_key") or pet_result.get("chat_key")
                chat_key = pet_result.get("chat_key")
                chat_id = pet_map.get(client_key)
                if not chat_id and chat_key in self.pets:
                    chat_id = chat_key
                if not chat_id:
                    for cid in self.pets.keys():
                        if self.getStreakKey(cid) == chat_key:
                            chat_id = cid
                            break
                if chat_id and chat_id in self.pets:
                    if server_data:
                        self.pets[chat_id].apply_sync_data(
                            server_data, source="server"
                        )
                        self.log(
                            f"WSP: batch-sync merged pet for {chat_id}, action={action}"
                        )
                    self.setSyncedHash(
                        chat_id, pet_data=self.pets[chat_id].get_sync_data()
                    )

            self.saveSoon()

    def resetSyncBackoff(self):
        self.sync_consecutive_errors = 0
        self.sync_backoff_seconds = 1

    def handleSyncErr(self, error):
        self.log(f"WSP: background sync loop error: {error}")
        self.log(f"WSP: bg-sync traceback: {traceback.format_exc()}")
        self.sync_consecutive_errors += 1
        self.sync_backoff_seconds = min(
            self.sync_backoff_seconds * 2, self.sync_backoff_max
        )
        self.log(
            f"WSP: backoff increased to {self.sync_backoff_seconds}s "
            f"(errors: {self.sync_consecutive_errors})"
        )

    def runBgSync(self):
        self.checkExpiredStreaks()
        streakChats, petChats = self.collectChatsForSync()
        streakList, petList = self.collectSyncData(streakChats, petChats)

        if not streakList and not petList:
            return

        sync_manager = self.getSyncMgr()
        if not sync_manager:
            return
        if not sync_manager.checkServerHealth():
            for chat_id, _ in streakList:
                self.recordSyncStatus(chat_id, "send:server", False, "server_unavailable")
                if sync_manager.mode == StreakSyncManager.MODE_AUTO:
                    self.markAutoSrvFail(chat_id, "server_unavailable")
            for chat_id, _ in petList:
                self.recordSyncStatus(chat_id, "send:server", False, "server_unavailable")
                if sync_manager.mode == StreakSyncManager.MODE_AUTO:
                    self.markAutoSrvFail(chat_id, "server_unavailable")
            raise RuntimeError("server_unavailable")
        now = time.time()
        if now < getattr(sync_manager, "rateWaitUntil", 0):
            raise RuntimeError("rate_limited")
        if now < getattr(sync_manager, "authWaitUntil", 0):
            raise RuntimeError("auth_wait")
        myId = self.getMyId()
        results = sync_manager.batch_sync(myId, streakList, petList)
        if results is None:
            reason = sync_manager.last_error or "batch_failed"
            for chat_id, _ in streakList:
                self.recordSyncStatus(chat_id, "send:server", False, reason)
                if sync_manager.mode == StreakSyncManager.MODE_AUTO:
                    self.markAutoSrvFail(chat_id, reason)
            for chat_id, _ in petList:
                self.recordSyncStatus(chat_id, "send:server", False, reason)
                if sync_manager.mode == StreakSyncManager.MODE_AUTO:
                    self.markAutoSrvFail(chat_id, reason)
            raise RuntimeError(reason)
        self.applySyncResults(results)
        if sync_manager.mode == StreakSyncManager.MODE_AUTO:
            for chat_id, _ in streakList:
                self.markAutoSrvOk(chat_id)
            for chat_id, _ in petList:
                self.markAutoSrvOk(chat_id)

    def bgSyncLoop(self):
        self.log("WSP: background sync thread started")

        while not self.shutdown_event.is_set():
            try:
                self.pruneTmpState()
                if not self.shouldRunSync():
                    self.shutdown_event.wait(SYNC_DEFAULT_WAIT_SECONDS)
                    continue

                sync_interval = self.getSyncInterval()
                if sync_interval >= SYNC_INTERVAL_DISABLED:
                    self.shutdown_event.wait(SYNC_DEFAULT_WAIT_SECONDS)
                    continue

                self.runSyncBlocking(self.runBgSync)

                self.resetSyncBackoff()
                self.shutdown_event.wait(sync_interval)

            except Exception as e:
                self.handleSyncErr(e)
                self.shutdown_event.wait(self.sync_backoff_seconds)

        self.log("WSP: background sync thread stopped")

    def setupHooks(self):
        self.add_on_send_message_hook()
        self.log("WSP: send hook added")

        self.add_hook("UpdateNewMessage", match_substring=True)
        self.log("WSP: update hook added")

    def loadSavedData(self):
        self.loadData()
        self.log(f"WSP: loaded {len(self.pets)} pets")

    def initSyncMgr(self):
        sync_mode = self.getSyncMode()
        self.sync_manager = StreakSyncManager(
            mode=sync_mode, server_url=self.getServerUrl(), enable_fallback=True
        )
        try:
            install_id = self.getInstallId()
            if not self.sync_manager.setInstallId(install_id):
                self.log("WSP: sync manager init failed: missing install_id")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to set install id in sync manager: {e}")
        try:
            if not self.sync_manager.setUserId(self.getMyId(acct=0)):
                self.log("WSP: sync manager init warning: missing user_id")
            self.lastAcct = 0
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to set user id in sync manager: {e}")
        try:
            if not self.sync_manager.setDevKey(self.getDevKey()):
                self.log("WSP: sync manager init failed: missing devkey")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to set dev key in sync manager: {e}")
        try:
            self.sync_manager.setInstallSecretHandler(self.setInstallSecret)
            self.sync_manager.setResetSecretHandler(self.setResetSecretFlag)
            secret = self.getInstallSecret()
            if secret:
                self.sync_manager.setInstallSecret(secret)
            self.sync_manager.setResetSecret(bool(self.get_setting("reset_secret", False)))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to configure sync manager secret handlers: {e}")
        self.log(
            f"WSP: sync_manager initialized in {sync_mode} mode, server=default"
        )

    def startBgSync(self):
        if self.get_setting("background_sync", True):
            self.background_sync_thread = threading.Thread(
                target=self.bgSyncLoop, daemon=True
            )
            self.background_sync_thread.start()
            self.log("WSP: background sync thread started")

    def initWidgetMgr(self):
        self.widget_manager = WidgetManager(self)
        self.log("WSP: widget manager initialized")

    def findNoArgMethod(self, klass, name):
        try:
            method = klass.getClass().getDeclaredMethod(name)
            method.setAccessible(True)
            return method
        except Exception:
            try:
                methods = klass.getClass().getDeclaredMethods()
                for m in methods:
                    try:
                        if m.getName() == name and len(m.getParameterTypes()) == 0:
                            m.setAccessible(True)
                            return m
                    except Exception:
                        continue
            except Exception:
                return None
        return None

    def findNoArgMethodAny(self, klass, names):
        for name in names:
            method = self.findNoArgMethod(klass, name)
            if method:
                return method, name
        return None, None

    def setupChatHooks(self):
        try:
            self.log("WSP: trying to hook ChatActivity.onResume")
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            self.log(f"WSP: ChatActivity class = {ChatActivity}")
            if ChatActivity:
                resumeMethod, resumeName = self.findNoArgMethodAny(
                    ChatActivity,
                    ["onResume", "onFragmentResume"],
                )
                self.log(f"WSP: got resume method = {resumeMethod} ({resumeName})")
                if not resumeMethod:
                    self.log("WSP: resume hook method not found")
                    resumeMethod = None
                hook_instance = ChatActivityHook(self)
                self.log(f"WSP: created hook instance = {hook_instance}")
                if resumeMethod:
                    self.header_hook = self.hook_method(resumeMethod, hook_instance)
                    self.log(f"WSP: hook_method returned = {self.header_hook}")
                    self.log("WSP: header hook OK!")
            else:
                self.log("WSP: ChatActivity class is None!")
        except Exception as e:
            self.log(f"WSP: header hook fail {e}")
            self.log(f"WSP: hook traceback: {traceback.format_exc()}")

        try:
            self.log("WSP: trying to hook ChatActivity.onPause")
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if ChatActivity:
                pauseMethod, pauseName = self.findNoArgMethodAny(
                    ChatActivity,
                    ["onPause", "onFragmentPause", "onFragmentDestroy"],
                )
                self.log(f"WSP: got pause method = {pauseMethod} ({pauseName})")
                if not pauseMethod:
                    self.log("WSP: pause hook method not found")
                    pauseMethod = None
                cleanup_hook_instance = WidgetCleanupHook(self)
                self.log(
                    f"WSP: created cleanup hook instance = {cleanup_hook_instance}"
                )
                if pauseMethod:
                    self.cleanup_hook = self.hook_method(
                        pauseMethod, cleanup_hook_instance
                    )
                    self.log(f"WSP: cleanup hook_method returned = {self.cleanup_hook}")
                    self.log("WSP: cleanup hook OK!")
            else:
                self.log("WSP: ChatActivity class is None!")
        except Exception as e:
            self.log(f"WSP: cleanup hook fail {e}")
            self.log(f"WSP: cleanup hook traceback: {traceback.format_exc()}")

    def registerMenuItems(self):
        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                item_id="wsp_menu",
                text="WSP",
                icon="msg_fave",
                on_click=self.showWspMenu,
            )
        )

    def on_plugin_load(self):
        setLogDebug(self.get_setting("debug_mode", False))
        bindUiGuard(self)
        self.log("WSP: starting load")

        self.setupHooks()
        self.loadSavedData()
        self.migrateAllPendingStreaks()
        self.initSyncMgr()
        self.startBgSync()
        self.initWidgetMgr()
        self.setupChatHooks()
        self.registerMenuItems()

        if not self.get_setting("_first_run_done", False):
            self.set_setting("_first_run_done", True)

        self.log("WSP: plugin loaded!")

    def on_plugin_unload(self):
        self.log("WSP: starting graceful shutdown...")

        self.shutdown_event.set()
        self.cancelPendingFutures()

        if self.background_sync_thread and self.background_sync_thread.is_alive():
            self.log("WSP: waiting for background sync thread...")
            self.background_sync_thread.join(timeout=10.0)
            if self.background_sync_thread.is_alive():
                self.log("WSP: background sync thread did not finish in time")

        self.log("WSP: shutting down thread pool...")
        try:
            self._executor.shutdown(wait=True, cancel_futures=True)
        except TypeError:
            self._executor.shutdown(wait=True)
        try:
            try:
                self._sync_batch_executor.shutdown(wait=True, cancel_futures=True)
            except TypeError:
                self._sync_batch_executor.shutdown(wait=True)
            for execu in self._sync_executors:
                try:
                    execu.shutdown(wait=True, cancel_futures=True)
                except TypeError:
                    execu.shutdown(wait=True)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: executor shutdown error: {e}")

        with self.data_lock:
            for widget in list(self.active_widgets.values()):
                try:
                    if hasattr(widget, "cleanup"):
                        widget.cleanup()
                except Exception as e:
                    self.log(f"WSP: error cleaning up widget: {e}")
            self.active_widgets.clear()
            try:
                if self.widget_manager and hasattr(self.widget_manager, "active_pet_widgets"):
                    for widget in list(self.widget_manager.active_pet_widgets.values()):
                        try:
                            if hasattr(widget, "cleanup"):
                                widget.cleanup()
                        except Exception as e:
                            self.log(f"WSP: active_pet_widget cleanup error: {e}")
                    self.widget_manager.active_pet_widgets.clear()
            except Exception as e:
                self.log(f"WSP: widget manager cleanup error: {e}")
            self._pending_pet_syncs.clear()
            self.last_pet_sync.clear()
            self._pending_streak_syncs.clear()
            self.last_streak_sync.clear()
            self.autoSrvPause.clear()
            self.autoSrvFail.clear()
            self.last_p2p_sync.clear()
            self._pending_chat_tasks.clear()
            self.flamePending.clear()
            try:
                with self.uiLock:
                    self.uiPending.clear()
            except Exception as e:
                self.log(f"WSP: uiPending cleanup error: {e}")

        if self.header_hook:
            self.unhook_method(self.header_hook)
        if self.cleanup_hook:
            self.unhook_method(self.cleanup_hook)
        self.header_hook = None
        self.cleanup_hook = None

        with self.data_lock:
            for pet in list(self.pets.values()):
                try:
                    if hasattr(pet, "cleanup"):
                        pet.cleanup()
                except Exception as e:
                    self.log(f"WSP: error cleaning up pet: {e}")

        sync_manager = self.getSyncMgr()
        if sync_manager and hasattr(sync_manager, "cache"):
            sync_manager.cache.clear()

        self.last_auto_sync.clear()
        self.last_messages.clear()
        with self.data_lock:
            self.chatAllow.clear()
        if isinstance(bulletin_last, dict):
            bulletin_last.clear()
        ui_cache = getattr(UI, "_cache", None)
        if ui_cache is not None and hasattr(ui_cache, "clear"):
            ui_cache.clear()
        self.widget_manager = None
        self.sync_manager = None
        self.background_sync_thread = None
        self._executor = None
        self._sync_batch_executor = None
        self._sync_executors = []

        self.saveData()
        bindUiGuard(None)
        self.log("WSP: plugin unloaded successfully")

    def create_settings(self):
        try:
            self.log("WSP: building settings list...")
            sync_mode_items = [
                tr("P2P (—á–µ—Ä–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏—è)", "P2P (via messages)"),
                tr("–°–µ—Ä–≤–µ—Ä (–æ–±–ª–∞–∫–æ)", "Server (cloud)"),
                tr("–ê–≤—Ç–æ (–≥–∏–±—Ä–∏–¥)", "Auto (hybrid)"),
                tr("–õ–æ–∫–∞–ª—å–Ω–æ (–±–µ–∑ —Å–∏–Ω–∫–∞)", "Local (no sync)"),
            ]
            sync_interval_items = [
                tr("30 —Å–µ–∫—É–Ω–¥", "30 seconds"),
                tr("60 —Å–µ–∫—É–Ω–¥", "60 seconds"),
                tr("120 —Å–µ–∫—É–Ω–¥", "120 seconds"),
                tr("300 —Å–µ–∫—É–Ω–¥", "300 seconds"),
                tr("–û—Ç–∫–ª—é—á–µ–Ω–æ", "Disabled"),
            ]
            settings_list = [
                Header(text=tr("settings_appearance")),
                Switch(
                    key="show_widget",
                    text=tr("settings_show_widget"),
                    default=DEFAULTS["show_widget"],
                    subtext=tr("settings_show_widget_sub"),
                    icon="msg_fave",
                ),
                Selector(
                    key="widget_size",
                    text=tr("settings_widget_size"),
                    default=2,
                    items=["60dp", "70dp", "80dp", "90dp", "100dp", "110dp", "120dp"],
                ),
                Selector(
                    key="widget_mode",
                    text=tr("settings_widget_mode"),
                    default=0,
                    items=[
                        tr("settings_widget_mode_compact"),
                        tr("settings_widget_mode_expanded"),
                    ],
                ),
                Selector(
                    key="widget_alpha",
                    text=tr("settings_widget_opacity"),
                    default=4,
                    items=["30%", "50%", "70%", "90%", "100%"],
                ),
                Switch(
                    key="show_notifications",
                    text=tr("settings_evolution_notifications"),
                    default=True,
                    subtext=tr("settings_evolution_notifications_sub"),
                    icon="msg_notify",
                ),
                Divider(),
                Header(text=tr("settings_sync")),
                Selector(
                    key="streak_sync_mode",
                    text=tr("settings_sync_mode"),
                    default=DEFAULTS["streak_sync_mode"],
                    items=sync_mode_items,
                ),
                Switch(
                    key="p2p_switch_offer",
                    text=tr("settings_p2p_offer"),
                    default=True,
                    subtext=tr("settings_p2p_offer_sub"),
                    icon="msg_info",
                ),
                Selector(
                    key="auto_sync_interval",
                    text=tr("settings_sync_interval"),
                    default=1,
                    items=sync_interval_items,
                ),
                Switch(
                    key="show_last_sync_status",
                    text=tr("settings_sync_status"),
                    default=True,
                    subtext=tr("settings_sync_status_sub"),
                    icon="msg_info",
                ),
                Switch(
                    key="background_sync",
                    text=tr("settings_bg_sync"),
                    default=True,
                    subtext=tr("settings_bg_sync_sub"),
                    icon="msg_autodelete",
                ),
                Divider(),
                Header(text=tr("settings_debug")),
                Switch(
                    key="debug_mode",
                    text=tr("settings_debug_mode"),
                    default=False,
                    subtext=tr("settings_debug_mode_sub"),
                    icon="msg_log",
                    on_change=lambda v: setLogDebug(v),
                ),
                Text(
                    text=tr("settings_check_server"),
                    icon="msg_satellite",
                    on_click=self.checkServerStatus,
                ),
                Text(
                    text=tr("settings_reset_auth"),
                    icon="msg_retry",
                    on_click=self.resetAuth,
                ),
                Text(
                    text=tr("settingsclearCache"),
                    icon="msg_clear_recent",
                    on_click=self.clearCache,
                ),
                Divider(),
                Header(text=tr("settings_danger_zone")),
                Text(
                    text=tr("settings_reset_data"),
                    icon="msg_delete",
                    red=True,
                    on_click=self.resetAllData,
                ),
                Text(
                    text=tr("settingsResetP2p"),
                    icon="msg_clear_recent",
                    red=True,
                    on_click=self.resetP2pKeys,
                ),
            ]

            self.log(f"WSP: settings list created with {len(settings_list)} items")
            return settings_list
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: ERROR creating settings: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")
            return []

    def on_send_message_hook(self, account, params):
        try:
            chat_id = self.normChat(params.peer)
            message = params.message
            if not isinstance(message, str):
                return HookResult()
            if not chat_id or not self.isPrivateChat(chat_id):
                return HookResult()
            self.setChatAccount(chat_id, account)
            if looksSyncMsg(message):
                return HookResult()
            with self.data_lock:
                shouldProcess = (
                    chat_id in self.streak_enabled_chats
                    or chat_id in self.pet_enabled_chats
                )
            if shouldProcess is False:
                return HookResult()

            queued = self.enqueueChatTask(
                chat_id,
                "sendMsg",
                self._handle_outgoing_message,
                account,
                chat_id,
                message,
            )
            if not queued:
                return HookResult()
        except Exception as err:
            self.log(f"WSP send hook error: {err}")

        return HookResult()

    def _handle_outgoing_message(self, account, chat_id, message):
        chat_id = self.normChat(chat_id)
        if not chat_id:
            return

        chat_allowed = self.isChatAllowed(chat_id, acct=account)
        streak = None
        updated = False
        changed = False
        with self.data_lock:
            streak_on = chat_id in self.streak_enabled_chats
            pet_on = chat_id in self.pet_enabled_chats
        if not chat_allowed:
            return
        if not streak_on and not pet_on:
            return
        if chat_allowed:
            if streak_on:
                streak = self.getOrCreateStreak(chat_id)
                if streak:
                    with self.data_lock:
                        updated = streak.update_streak()
                    if updated:
                        changed = True
                        self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, False)

        if chat_allowed and pet_on:
            pet = self.getOrCreatePet(chat_id)

            xp_for_msg = self.calcXp(chat_id, message)
            total_xp_effect = int(xp_for_msg or 0)

            evolution = pet.add_xp(xp_for_msg)

            if evolution:
                show_notification = self.get_setting("show_notifications", True)
                if show_notification:
                    run_on_ui_thread(lambda: self.showEvolution(pet))
                else:
                    run_on_ui_thread(
                        lambda: bulletin_safe("success",
                            tr(
                                "–≠–≤–æ–ª—é—Ü–∏—è",
                                "Evolution",
                            )
                        )
                    )

            if streak and updated:
                bonus_xp = 0
                count = streak.count
                if count > 0:
                    if count % 30 == 0:
                        bonus_xp = XP_REWARDS["streak_30_days"]
                    elif count % 14 == 0:
                        bonus_xp = XP_REWARDS["streak_14_days"]
                    elif count % 7 == 0:
                        bonus_xp = XP_REWARDS["streak_7_days"]
                    elif count % 3 == 0:
                        bonus_xp = XP_REWARDS["streak_3_days"]

                if bonus_xp > 0:
                    pet.add_xp(bonus_xp)
                    total_xp_effect += int(bonus_xp or 0)

            with self.data_lock:
                self.last_messages[chat_id] = time.time()
            changed = True

            self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, False)

            if (
                total_xp_effect > 0
                and self.get_setting("show_widget", True)
                and chat_id in self.active_widgets
            ):
                if not self.guardAction(f"flameUi:{chat_id}", 1.8):
                    self.queueFlame(chat_id, total_xp_effect)
        if changed:
            self.saveSoon()

    def on_update_hook(self, update_name, account, update):
        try:
            if "UpdateNewMessage" not in update_name:
                return HookResult()

            message = getattr(update, "message", None)
            if not message:
                return HookResult()

            message_text = getattr(message, "message", None)
            if not message_text or not isinstance(message_text, str):
                return HookResult()

            try:
                if getattr(message, "out", False):
                    return HookResult()
            except (AttributeError, TypeError, ValueError) as e:
                self.log(f"WSP: failed to inspect incoming message direction: {e}")

            peer = getattr(message, "peerId", None) or getattr(message, "peer_id", None)
            if not peer:
                return HookResult()

            from_id = getattr(peer, "userId", None) or getattr(peer, "user_id", None)
            if not from_id:
                return HookResult()

            chat_id = self.normChat(from_id)
            self.setChatAccount(chat_id, account)

            if not self.isPrivateChat(chat_id):
                return HookResult()

            with self.data_lock:
                streak_on = chat_id in self.streak_enabled_chats
                pet_on = chat_id in self.pet_enabled_chats
            needServerCheck = streak_on or pet_on
            myUserId = 0

            def queueServerCheck():
                if needServerCheck:
                    self.runAsync(self.checkServerDataFast, chat_id)

            def cancelSync(checkServer=False):
                self.deleteMsg(message, acct=account)
                if checkServer:
                    queueServerCheck()
                return HookResult(strategy=HookStrategy.CANCEL)

            try:
                myUserId = self.getMyId(acct=account)
                from_obj = getattr(message, "fromId", None) or getattr(message, "from_id", None)
                sender_id = (
                    getattr(from_obj, "userId", None)
                    or getattr(from_obj, "user_id", None)
                )
                if sender_id and myUserId:
                    if int(sender_id) == int(myUserId):
                        return HookResult()
            except (TypeError, ValueError) as e:
                self.log(f"WSP: failed to verify sender id for sync message: {e}")
            except (AttributeError, RuntimeError) as e:
                self.log(f"WSP: sender direction check error: {e}")

            if not looksSyncMsg(message_text):
                queueServerCheck()
                return HookResult()

            p2pKey = self.getP2pKey(chat_id)
            if not p2pKey:
                offer_key = StreakSyncManager.extract_offer_key(
                    message_text, chat_id=chat_id
                )
                if offer_key:
                    self.offerP2pSwitch(chat_id, offer_key)
                return cancelSync(checkServer=True)

            sync_data = StreakSyncManager.parse_sync_message(
                message_text, chat_id, key=p2pKey
            )
            if not sync_data:
                return cancelSync(checkServer=True)

            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                return HookResult()
            try:
                if "ck" in sync_data:
                    if not myUserId:
                        myUserId = self.getMyId(acct=account)
                    if myUserId and int(myUserId) > 0:
                        expected_ck = sync_manager.clientKey(myUserId, chat_id)
                        if sync_data.get("ck") != expected_ck:
                            self.log(
                                f"WSP: P2P client key mismatch for chat {chat_id}, rejecting"
                            )
                            return cancelSync()
            except (TypeError, ValueError) as e:
                self.log(f"WSP: invalid sender/client key id for chat {chat_id}: {e}")
            except (AttributeError, RuntimeError) as e:
                self.log(f"WSP: failed to validate P2P client key for chat {chat_id}: {e}")
            syncMode = sync_manager.mode
            if syncMode in (
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ):
                self.offerP2pSwitch(chat_id)

            if syncMode == StreakSyncManager.MODE_SERVER:
                self.log(f"WSP: ignoring P2P message in SERVER mode for chat {chat_id}")
                return cancelSync()
            if syncMode == StreakSyncManager.MODE_LOCAL:
                self.log(f"WSP: ignoring sync message in LOCAL mode for chat {chat_id}")
                return cancelSync()

            streak_payload = sync_data.get("streak")
            if streak_payload:
                is_deleted = streak_payload.get("deleted", False)

                if is_deleted:
                    local_streak = None
                    apply_delete = True
                    with self.data_lock:
                        streak_key = self.getStreakKey(chat_id)
                        local_streak = self.streaks.get(streak_key)
                        if local_streak and not local_streak.deleted:
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_streak, streak_payload, "p2p"
                            )

                        if apply_delete:
                            self.streak_enabled_chats.discard(chat_id)
                            if local_streak:
                                self.markStreakDeleted(
                                    local_streak, update_sync_ts=True
                                )

                    if apply_delete:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "p2p",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                            remote_ts=streak_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P sync received deleted=True for streak {chat_id}, resetting streak"
                        )
                        self.log(f"WSP: streak deactivated from P2P sync for {chat_id}")
                    else:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "p2p",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                            remote_ts=streak_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P deleted ignored for {chat_id}, keeping local"
                        )
                else:
                    if chat_id not in self.streak_enabled_chats:
                        self.log(
                            f"WSP: auto-enabling streak for chat {chat_id} from P2P sync"
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)

                    with self.data_lock:
                        streak_key = self.getStreakKey(chat_id)
                        streak = self.streaks.get(streak_key)
                        if not streak:
                            streak = self.getOrCreateStreak(chat_id)

                        if streak:
                            result = self.mergeRemoteSync(
                                "streak",
                                chat_id,
                                streak,
                                streak_payload,
                                "p2p",
                                update_hash=False,
                            )
                            if result["applied"]:
                                self.log(
                                    f"WSP: P2P streak synced for chat {chat_id}, count={streak_payload.get('count', 0)}"
                                )

            pet_payload = sync_data.get("pet")
            if pet_payload:
                is_deleted = pet_payload.get("deleted", False)

                if is_deleted:
                    local_pet = None
                    apply_delete = True
                    with self.data_lock:
                        local_pet = self.pets.get(chat_id)
                        if local_pet and not local_pet.deleted:
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_pet, pet_payload, "p2p"
                            )

                        if apply_delete:
                            self.pet_enabled_chats.discard(chat_id)
                            if local_pet:
                                self.markPetDeleted(
                                    local_pet, update_sync_ts=True
                                )

                    if apply_delete:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "p2p",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                            remote_ts=pet_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P sync received deleted=True for pet {chat_id}"
                        )
                        self.log(f"WSP: pet deactivated from P2P sync for {chat_id}")
                    else:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "p2p",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                            remote_ts=pet_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P deleted ignored for {chat_id}, keeping local"
                        )
                else:
                    if chat_id not in self.pet_enabled_chats:
                        self.log(
                            f"WSP: auto-enabling pet for chat {chat_id} from P2P sync"
                        )
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)

                    with self.data_lock:
                        pet = self.pets.get(chat_id)
                        if not pet:
                            pet = self.getOrCreatePet(chat_id)

                        if pet:
                            result = self.mergeRemoteSync(
                                "pet",
                                chat_id,
                                pet,
                                pet_payload,
                                "p2p",
                                update_hash=False,
                            )
                            if result["applied"]:
                                self.log(
                                    f"WSP: P2P pet synced for chat {chat_id}, xp={pet_payload.get('xp', 0)}, stage={pet_payload.get('stage', 0)}, name={pet_payload.get('name', 'unknown')}"
                                )

            if streak_payload or pet_payload:
                self.saveSoon()

            return cancelSync()

        except Exception as e:
            self.log(f"WSP update hook error: {e}")

        return HookResult()

    def hasRepeatedChars(self, text, threshold=None):
        if threshold is None:
            threshold = SPAM_REPEATED_CHARS_THRESHOLD

        if len(text) < 10:
            return False

        from collections import Counter

        char_counts = Counter(text.replace(" ", ""))
        if not char_counts:
            return False

        most_common_char, count = char_counts.most_common(1)[0]
        ratio = count / len(text.replace(" ", ""))

        return ratio > threshold

    def calcSimilarity(self, text1, text2):
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())

        if not words1 or not words2:
            return 0.0

        intersection = len(words1 & words2)
        union = len(words1 | words2)

        return intersection / union if union > 0 else 0.0

    def isSpamMessage(self, chat_id, message):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            recent = self.recent_messages.get(chat_id, [])

        if len(recent) >= SPAM_IDENTICAL_THRESHOLD:
            last_messages = recent[-SPAM_IDENTICAL_THRESHOLD:]
            if len(set(last_messages)) == 1:
                return True

        if len(recent) >= 2:
            similarity = self.calcSimilarity(message, recent[-1])
            if similarity > SPAM_SIMILARITY_THRESHOLD:
                return True

        return False

    def calcXp(self, chat_id, message):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        msg = message if len(message) <= 640 else message[:640]

        with self.data_lock:
            last_xp = self.last_xp_time.get(chat_id, 0)
        if current_time - last_xp < XP_COOLDOWN_SECONDS:
            return 0

        hour_ago = current_time - SECONDS_PER_HOUR
        with self.data_lock:
            xp_history = self.xp_history.get(chat_id, [])
        xp_history = [t for t in xp_history if t > hour_ago]
        with self.data_lock:
            self.xp_history[chat_id] = xp_history
        xp_per_hour_limit = XP_MAX_PER_HOUR // XP_REWARDS["msg"]
        max_hist = max(xp_per_hour_limit * 2, 20)
        if len(xp_history) >= xp_per_hour_limit:
            return 0

        message_stripped = msg.strip()
        if len(message_stripped) < SPAM_MIN_MESSAGE_LENGTH:
            return 0

        if self.hasRepeatedChars(msg):
            return 0

        with self.data_lock:
            recent_messages = self.recent_messages.get(chat_id, [])
        recent_messages.append(msg)
        with self.data_lock:
            self.recent_messages[chat_id] = recent_messages[-SPAM_CHECK_WINDOW_MESSAGES:]

        if self.isSpamMessage(chat_id, msg):
            return 0

        xp = XP_REWARDS["msg"]
        last_message_date = self.last_messages.get(chat_id)
        today_msk = get_msk_date()
        now_msk = get_msk_now()

        try:
            if (
                last_message_date is None
                or datetime.fromtimestamp(last_message_date, MSK_TZ).date() < today_msk
            ):
                xp += XP_REWARDS["first_of_day"]
        except (ValueError, OSError):
            xp += XP_REWARDS["first_of_day"]

        current_hour_msk = now_msk.hour
        if NIGHT_HOURS_START <= current_hour_msk < NIGHT_HOURS_END:
            xp += XP_REWARDS["night"]

        current_weekday_msk = now_msk.weekday()
        if current_weekday_msk >= 5:
            xp += XP_REWARDS["weekend"]

        with self.data_lock:
            self.last_xp_time[chat_id] = current_time
            self.xp_history[chat_id].append(current_time)
            if len(self.xp_history[chat_id]) > max_hist:
                self.xp_history[chat_id] = self.xp_history[chat_id][-max_hist:]

        return xp

    def getOrCreatePet(self, chat_id):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            if chat_id not in self.pets:
                self.pets[chat_id] = Pet(chat_id, plugin_ref=self)
            else:
                pet = self.pets[chat_id]
                if not hasattr(pet, "plugin_ref") or pet.plugin_ref is None:
                    pet._plugin_ref = weakref.ref(self)
            return self.pets[chat_id]

    def getOrCreateStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if not self.isPrivateChat(chat_id):
            return None

        with self.data_lock:
            if chat_id not in self.streak_enabled_chats:
                return None

            streak_key = self.getStreakKey(chat_id)

            if streak_key not in self.streaks:
                self.streaks[streak_key] = Streak(chat_id, plugin_ref=self)
            return self.streaks[streak_key]

    def getSyncMgr(self, chat_id=None, acct=None):
        current_time = time.time()
        if not hasattr(self, "_sync_manager_cache_time"):
            self._sync_manager_cache_time = 0
        if not self.sync_manager:
            return None

        if current_time - self._sync_manager_cache_time > 5:
            try:
                sync_mode = self.getSyncMode()
                self.sync_manager.mode = sync_mode
                self.sync_manager.server_url = self.getServerUrl()
                install_id = self.getInstallId()
                if not self.sync_manager.setInstallId(install_id):
                    self.sync_manager.last_error = "missing_install_id"
                    self.log("WSP: sync manager refresh failed: install_id missing")
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.sync_manager.last_error = "sync_manager_refresh_error"
                self.log(f"WSP: sync manager refresh error: {e}")
            self._sync_manager_cache_time = current_time
        try:
            acct = self.getAcct(chat_id=chat_id, acct=acct)
            my_id = self.getMyId(acct=acct)
            if not self.sync_manager.setUserId(my_id):
                self.log("WSP: sync manager refresh warning: user_id unavailable")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: sync manager user_id refresh error: {e}")
        try:
            if not self.sync_manager.setDevKey(self.getDevKey()):
                self.sync_manager.last_error = "missing_devkey"
                self.log("WSP: sync manager refresh failed: devkey missing")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.sync_manager.last_error = "devkey_refresh_error"
            self.log(f"WSP: sync manager devkey refresh error: {e}")
        try:
            secret = self.getInstallSecret()
            if secret and not self.sync_manager.setInstallSecret(secret):
                self.log("WSP: sync manager refresh warning: install_secret not applied")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: sync manager install_secret refresh error: {e}")
        try:
            self.sync_manager.setResetSecret(bool(self.get_setting("reset_secret", False)))
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: sync manager reset_secret refresh error: {e}")

        return self.sync_manager

    def syncStreak(self, chat_id, streak, force=False):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        with self.data_lock:
            last_sync = self.last_streak_sync.get(chat_id, 0)

        if not force and current_time - last_sync < self.STREAK_SYNC_MIN_INTERVAL:
            def sendDelayed():
                with self.data_lock:
                    streakKey = self.getStreakKey(chat_id)
                    delayedStreak = self.streaks.get(streakKey)
                if delayedStreak:
                    self.sendSyncMsg(chat_id, delayedStreak)
            self.queueDelayedSync(
                chat_id,
                last_sync,
                self.STREAK_SYNC_MIN_INTERVAL,
                self._pending_streak_syncs,
                sendDelayed,
            )
            return

        with self.data_lock:
            self.last_streak_sync[chat_id] = current_time
            self._pending_streak_syncs.pop(chat_id, None)
        self.sendSyncMsg(chat_id, streak)

    def sendP2pSyncMsg(self, chat_id, sync_message, throttle_key, log_prefix):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        with self.data_lock:
            last_sync = self.last_p2p_sync.get(throttle_key, 0)
            if current_time - last_sync < self.P2P_MIN_INTERVAL:
                self.log(f"WSP: {log_prefix}P2P throttled for {chat_id}, skip")
                return False
            self.last_p2p_sync[throttle_key] = current_time
        send_text(int(chat_id), sync_message, silent=True)
        return True

 
    def autoSrvErr(self, reason):
        key = str(reason or "").strip().lower().replace("-", "_").replace(" ", "_")
        if not key:
            return False
        if key.startswith("http_"):
            return True
        return key in {
            "server_unavailable",
            "server_error",
            "server_exception",
            "network",
            "db_busy",
            "rate_limited",
            "auth_wait",
            "auth_failed",
            "token_revoked",
            "install_revoked",
            "install_reauth_required",
            "missing_install_secret",
            "invalid_install_secret",
            "missing_install_id",
            "invalid_install_id",
            "missing_dev_key",
            "invalid_dev_key",
            "project_mismatch",
            "invalid_user_id",
            "streak_save_failed",
            "pet_save_failed",
            "batch_failed",
        }

    def isAuthErr(self, reason):
        key = str(reason or "").strip().lower().replace("-", "_").replace(" ", "_")
        if not key:
            return False
        return key in (
            "auth_failed",
            "auth_wait",
            "token_revoked",
            "install_revoked",
            "install_reauth_required",
            "missing_install_secret",
            "invalid_install_secret",
            "missing_install_id",
            "invalid_install_id",
            "missing_dev_key",
            "invalid_dev_key",
            "project_mismatch",
            "invalid_user_id",
        )

    def tryAuthHeal(self, chatId, reason, syncManager=None):
        key = str(reason or "").strip().lower().replace("-", "_").replace(" ", "_")
        if not self.isAuthErr(key):
            return False
        now = time.time()
        with self.data_lock:
            if now - float(self.lastAuthHealTs or 0.0) < 90.0:
                return False
            self.lastAuthHealTs = now
            self.authHealFails = int(self.authHealFails or 0) + 1
            failCount = self.authHealFails

        try:
            if not syncManager:
                syncManager = self.getSyncMgr(chat_id=chatId)
            if syncManager:
                syncManager.token = None
                syncManager.tokenExp = 0
                if hasattr(syncManager, "needResetSecret") and syncManager.needResetSecret(
                    key
                ):
                    syncManager.setResetSecret(True)

            hard = key in (
                "install_reauth_required",
                "token_revoked",
                "missing_install_id",
                "invalid_install_id",
                "missing_dev_key",
                "invalid_dev_key",
                "project_mismatch",
                "invalid_user_id",
            ) or failCount >= 3
            if not hard:
                self.log(f"WSP: auth auto-heal soft reset (reason={key})")
                return True

            self.log(f"WSP: auth auto-heal hard reset start (reason={key})")
            self.set_setting("install_id", "")
            self._setSecretSettingStr("devkey", "")
            self._setSecretSettingStr("install_secret", "")
            self.setResetSecretFlag(True)

            install_id = self.getInstallId()
            dev_key = self.getDevKey()
            install_secret = self.getInstallSecret()
            if syncManager:
                syncManager.setInstallId(install_id)
                syncManager.setUserId(self.getMyId(acct=self.getAcct(chat_id=chatId)))
                syncManager.setDevKey(dev_key)
                if install_secret:
                    syncManager.setInstallSecret(install_secret)
                syncManager.setResetSecret(True)
                syncManager.token = None
                syncManager.tokenExp = 0
            self.log("WSP: auth auto-heal hard reset completed")
            return True
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: auth auto-heal failed: {e}")
            return False

    def canAutoSrv(self, chatId, syncManager):
        if not syncManager or syncManager.mode != StreakSyncManager.MODE_AUTO:
            return True
        chatKey = self.normChat(chatId)
        now = time.time()
        with self.data_lock:
            pauseUntil = V.toFloat(self.autoSrvPause.get(chatKey, 0), 0.0)
        return pauseUntil <= now

    def markAutoSrvFail(self, chatId, reason=None):
        if not self.autoSrvErr(reason):
            return
        chatKey = self.normChat(chatId)
        now = time.time()
        with self.data_lock:
            failCount = V.toInt(self.autoSrvFail.get(chatKey, 0), 0) + 1
            self.autoSrvFail[chatKey] = failCount
            delay = min(
                AUTO_SRV_RETRY_BASE_SECONDS * (2 ** max(0, failCount - 1)),
                AUTO_SRV_RETRY_MAX_SECONDS,
            )
            self.autoSrvPause[chatKey] = now + delay
        self.log(
            f"WSP: auto mode server pause for {chatKey} ({int(delay)}s, reason={reason})"
        )
        self.tryAuthHeal(chatId, reason)

    def markAutoSrvOk(self, chatId):
        chatKey = self.normChat(chatId)
        with self.data_lock:
            self.autoSrvFail.pop(chatKey, None)
            self.autoSrvPause.pop(chatKey, None)
            self.authHealFails = 0

    def getSyncFlags(self, syncManager):
        mode = syncManager.mode
        fallbackOk = mode == StreakSyncManager.MODE_AUTO and syncManager.enable_fallback
        degradedFallback = (
            mode == StreakSyncManager.MODE_AUTO
            and syncManager.enable_fallback
            and getattr(syncManager, "server_degraded", False)
        )
        return mode, fallbackOk, degradedFallback
 
    def getClientKey(self, syncManager, chatId, myUserId=None):
        try:
            my_id_int = V.toInt(myUserId, 0)
            if my_id_int <= 0:
                my_id = self.getMyId(acct=self.getAcct(chat_id=chatId))
                my_id_int = V.toInt(my_id, 0)
            if my_id_int > 0:
                return syncManager.clientKey(my_id_int, chatId)
        except Exception as e:
            self.log(f"WSP: getClientKey error for chat={chatId}: {e}")
        return None
 
    def getStreakData(self, chatId, streak):
        with self.data_lock:
            streakData = streak.get_sync_data() if streak else None
            petData = None
            if chatId in self.pets:
                petData = self.pets[chatId].get_sync_data()
        return streakData, petData
 
    def getPetData(self, chatId, pet):
        with self.data_lock:
            return pet.get_sync_data() if pet else None

    def applyServerAckStreak(self, chatId, syncManager, myUserId, streakObj):
        try:
            if not syncManager or not myUserId or not streakObj:
                return
            cacheKey = syncManager.cacheKey(myUserId, chatId)
            serverData = syncManager.getCached(cacheKey)
            if not isinstance(serverData, dict):
                return

            changed = False
            canonical = None
            with self.data_lock:
                beforeHash = self.hashSync(streakObj.get_sync_data())
                streakObj.apply_sync_data(serverData, source="server_ack")
                canonical = streakObj.get_sync_data()
                afterHash = self.hashSync(canonical)
                changed = beforeHash != afterHash

            self.setSyncedHash(chatId, streak_data=canonical)
            if changed:
                self.saveSoon()
        except Exception as e:
            self.log(f"WSP: applyServerAckStreak error for chat={chatId}: {e}")

    def applyServerAckPet(self, chatId, syncManager, user1Id, user2Id, petObj):
        try:
            if not syncManager or not user1Id or not user2Id or not petObj:
                return
            cacheKey = "pet_" + syncManager.cacheKey(user1Id, user2Id)
            serverData = syncManager.getCached(cacheKey)
            if not isinstance(serverData, dict):
                return

            changed = False
            canonical = None
            with self.data_lock:
                beforeHash = self.hashSync(petObj.get_sync_data())
                petObj.apply_sync_data(serverData, source="server_ack")
                canonical = petObj.get_sync_data()
                afterHash = self.hashSync(canonical)
                changed = beforeHash != afterHash

            self.setSyncedHash(chatId, pet_data=canonical)
            if changed:
                self.saveSoon()
        except Exception as e:
            self.log(f"WSP: applyServerAckPet error for chat={chatId}: {e}")
 
    def ensureP2pKey(self, chatId, syncManager, user1Id=None, user2Id=None):
        p2pKey = self.getP2pKey(chatId)
        if p2pKey:
            return p2pKey
        if (
            syncManager.mode == StreakSyncManager.MODE_AUTO
            and not self.canAutoSrv(chatId, syncManager)
        ):
            return None
        if syncManager.mode in (
            StreakSyncManager.MODE_SERVER,
            StreakSyncManager.MODE_AUTO,
        ) and syncManager.checkServerHealth():
            try:
                if not user1Id:
                    user1Id, user2Id = self.sortedIdsFast(chatId)
                if user1Id:
                    p2pKey = syncManager.getP2pSrv(user1Id, user2Id)
                if not p2pKey and user1Id:
                    p2pKey = self.newP2pKey(chatId)
                    if p2pKey:
                        ok = syncManager.setP2pSrv(user1Id, user2Id, p2pKey)
                        if not ok:
                            p2pKey = None
            except (
                urllib.error.HTTPError,
                urllib.error.URLError,
                TimeoutError,
                OSError,
                ValueError,
                TypeError,
                AttributeError,
                RuntimeError,
            ) as e:
                self.log(f"WSP: ensureP2pKey error for {chatId}: {e}")
                p2pKey = None
        return p2pKey
 
    def sendP2pPayload(
        self,
        chatId,
        syncManager,
        streakData=None,
        petData=None,
        throttleKey=None,
        logPrefix="",
        myUserId=None,
        user1Id=None,
        user2Id=None,
        clientKey=None,
        p2pKey=None,
    ):
        if clientKey is None:
            clientKey = self.getClientKey(syncManager, chatId, myUserId=myUserId)
        if p2pKey is None:
            p2pKey = self.ensureP2pKey(
                chatId,
                syncManager,
                user1Id=user1Id,
                user2Id=user2Id,
            )
        if not p2pKey:
            self.recordSyncStatus(chatId, "send:p2p", False, "p2p_no_key")
            self.log(f"WSP: P2P key missing for {chatId}, skip")
            return False
 
        syncMsg = StreakSyncManager.create_sync_message(
            streak_data=streakData,
            pet_data=petData,
            key=p2pKey,
            client_key=clientKey,
        )
        if not syncMsg:
            self.log(f"WSP: P2P sync skipped for {chatId}, missing key")
            return False
        key = throttleKey or chatId
        p2pOk = self.sendP2pSyncMsg(chatId, syncMsg, key, logPrefix)
        self.recordSyncStatus(
            chatId,
            "send:p2p",
            bool(p2pOk),
            None if p2pOk else "p2p_throttled",
        )
        return p2pOk

    def sendSyncMsg(self, chat_id, streak):
        """Send streak (and pet snapshot if available) via selected sync mode."""
        try:
            if self.shutdown_event.is_set():
                return
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                return
            mode, fallbackOk, degradedFallback = self.getSyncFlags(sync_manager)
            if mode == StreakSyncManager.MODE_LOCAL:
                self.log(f"WSP: local mode, streak sync skipped for {chat_id}")
                return
            serverReason = None
            serverAttempted = False
            autoCanSrv = self.canAutoSrv(chat_id, sync_manager)
            useP2pFallback = (
                mode == StreakSyncManager.MODE_AUTO and not autoCanSrv
            )
            serverOk = False
            statusMode = "send:server"
            myUserId = 0
            user1Id = None
            user2Id = None

            def recordServer(success, reason=None):
                self.recordSyncStatus(
                    chat_id,
                    statusMode,
                    bool(success),
                    reason if not success else None,
                )

            if mode == StreakSyncManager.MODE_SERVER or (
                mode == StreakSyncManager.MODE_AUTO and autoCanSrv
            ):
                serverAttempted = True
                myUserId = V.toInt(
                    self.getMyId(acct=self.getAcct(chat_id=chat_id)),
                    0,
                )

                if myUserId > 0:
                    try:
                        streakData, petData = self.getStreakData(chat_id, streak)

                        if not self.guardSyncStreak(chat_id, streakData):
                            recordServer(False, "client_guard")
                            return

                        streakOk = sync_manager.save_streak_to_server(
                            myUserId, chat_id, streakData
                        )
                        streakReason = None if streakOk else (
                            sync_manager.last_error or "streak_save_failed"
                        )
                        if not streakOk:
                            serverReason = streakReason
                        recordServer(streakOk, streakReason)
                        if streakOk:
                            self.applyServerAckStreak(
                                chat_id,
                                sync_manager,
                                myUserId,
                                streak,
                            )

                        if petData:
                            user1Id, user2Id = self.sortedIdsFast(chat_id, myUserId)
                            if not user1Id:
                                recordServer(False, "invalid_user_id")
                                if fallbackOk:
                                    useP2pFallback = True
                                serverOk = streakOk
                            else:
                                if not self.guardSyncPet(chat_id, petData):
                                    recordServer(False, "client_guard")
                                    return
                                petOk = sync_manager.save_pet_to_server(
                                    user1Id, user2Id, petData
                                )
                                petReason = None if petOk else (
                                    sync_manager.last_error or "pet_save_failed"
                                )
                                if not petOk:
                                    serverReason = petReason
                                recordServer(petOk, petReason)
                                if petOk:
                                    petObj = None
                                    with self.data_lock:
                                        petObj = self.pets.get(chat_id)
                                    self.applyServerAckPet(
                                        chat_id,
                                        sync_manager,
                                        user1Id,
                                        user2Id,
                                        petObj,
                                    )
                                serverOk = streakOk and petOk
                        else:
                            serverOk = streakOk

                        if (
                            not serverOk
                            and mode == StreakSyncManager.MODE_AUTO
                        ):
                            if fallbackOk:
                                useP2pFallback = True
                    except (
                        urllib.error.HTTPError,
                        urllib.error.URLError,
                        TimeoutError,
                        OSError,
                        ValueError,
                        TypeError,
                        AttributeError,
                        RuntimeError,
                    ) as e:
                        self.log(f"WSP: server sync error: {e}")
                        serverReason = "server_exception"
                        recordServer(False, "server_exception")
                        if fallbackOk:
                            useP2pFallback = True
                else:
                    if fallbackOk:
                        useP2pFallback = True
                    recordServer(False, "invalid_user_id")
            elif mode == StreakSyncManager.MODE_AUTO and not autoCanSrv:
                self.log(f"WSP: auto mode server cooldown active for {chat_id}")

            if serverReason:
                self.tryAuthHeal(chat_id, serverReason, syncManager=sync_manager)

            if degradedFallback:
                useP2pFallback = True
                if mode == StreakSyncManager.MODE_AUTO:
                    self.log(f"WSP: auto mode degraded fallback enabled for {chat_id}")

            if mode == StreakSyncManager.MODE_AUTO and serverAttempted:
                if serverOk:
                    self.markAutoSrvOk(chat_id)
                else:
                    self.markAutoSrvFail(chat_id, serverReason)

            if mode == StreakSyncManager.MODE_P2P or useP2pFallback:
                streakData, petData = self.getStreakData(chat_id, streak)
                self.sendP2pPayload(
                    chat_id,
                    sync_manager,
                    streakData=streakData,
                    petData=petData,
                    throttleKey=chat_id,
                    logPrefix="",
                    myUserId=myUserId,
                    user1Id=user1Id,
                    user2Id=user2Id,
                )

        except Exception as e:

            self.log(f"WSP: sync send error: {e}")
            self.log(f"WSP: sync send traceback: {traceback.format_exc()}")

    def syncPet(self, chat_id, pet, force=False):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        with self.data_lock:
            last_sync = self.last_pet_sync.get(chat_id, 0)

        if not force and current_time - last_sync < self.PET_SYNC_MIN_INTERVAL:
            def sendDelayed():
                with self.data_lock:
                    delayedPet = self.pets.get(chat_id)
                if delayedPet:
                    self.sendPetSync(chat_id, delayedPet)
            self.queueDelayedSync(
                chat_id,
                last_sync,
                self.PET_SYNC_MIN_INTERVAL,
                self._pending_pet_syncs,
                sendDelayed,
            )
            return

        with self.data_lock:
            self.last_pet_sync[chat_id] = current_time
            self._pending_pet_syncs.pop(chat_id, None)
        self.sendPetSync(chat_id, pet)

    def sendPetSync(self, chat_id, pet):
        """Send pet snapshot via selected sync mode."""
        try:
            if self.shutdown_event.is_set():
                return
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                return
            mode, fallbackOk, degradedFallback = self.getSyncFlags(sync_manager)
            if mode == StreakSyncManager.MODE_LOCAL:
                self.log(f"WSP: local mode, pet sync skipped for {chat_id}")
                return
            serverReason = None
            serverAttempted = False
            autoCanSrv = self.canAutoSrv(chat_id, sync_manager)
            useP2pFallback = (
                mode == StreakSyncManager.MODE_AUTO and not autoCanSrv
            )
            serverOk = False
            statusMode = "send:server"
            myUserId = 0
            user1Id = None
            user2Id = None

            def recordServer(success, reason=None):
                self.recordSyncStatus(
                    chat_id,
                    statusMode,
                    bool(success),
                    reason if not success else None,
                )

            if mode == StreakSyncManager.MODE_SERVER or (
                mode == StreakSyncManager.MODE_AUTO and autoCanSrv
            ):
                serverAttempted = True
                myUserId = V.toInt(
                    self.getMyId(acct=self.getAcct(chat_id=chat_id)),
                    0,
                )
                self.log(f"WSP pet sync: got my_user_id={myUserId}")

                if myUserId > 0:
                    try:
                        self.log(
                            f"WSP: attempting pet sync to server for chat {chat_id}"
                        )
                        user1Id, user2Id = self.sortedIdsFast(chat_id, myUserId)
                        if not user1Id:
                            recordServer(False, "invalid_user_id")
                            if fallbackOk:
                                useP2pFallback = True
                            raise RuntimeError("invalid_user_id")

                        petData = self.getPetData(chat_id, pet)

                        if not self.guardSyncPet(chat_id, petData):
                            recordServer(False, "client_guard")
                            return

                        serverOk = sync_manager.save_pet_to_server(
                            user1Id, user2Id, petData
                        )
                        petReason = None if serverOk else (sync_manager.last_error or "pet_save_failed")
                        if not serverOk:
                            serverReason = petReason
                        recordServer(serverOk, petReason)

                        if serverOk:
                            self.applyServerAckPet(
                                chat_id,
                                sync_manager,
                                user1Id,
                                user2Id,
                                pet,
                            )
                            self.log(
                                f"WSP: pet saved to server for {chat_id}, xp={pet.xp}, stage={pet.stage}"
                            )
                        else:
                            self.log(f"WSP: failed to save pet to server for {chat_id}")
                            if petReason == "throttled":
                                retry_delay = max(
                                    1.0,
                                    float(
                                        getattr(
                                            sync_manager,
                                            "save_throttle_interval",
                                            2,
                                        )
                                    )
                                    + 0.2,
                                )
                                if not self.guardAction(
                                    f"syncPetThrottleRetry:{chat_id}",
                                    retry_delay * 0.8,
                                ):
                                    def retry_after_throttle():
                                        if self.shutdown_event.wait(retry_delay):
                                            return
                                        with self.data_lock:
                                            retry_pet = self.pets.get(chat_id)
                                        if retry_pet:
                                            self.enqueueChatTask(
                                                chat_id,
                                                "syncPetThrottleRetry",
                                                self.syncPet,
                                                chat_id,
                                                retry_pet,
                                                True,
                                            )

                                    self.runAsync(retry_after_throttle)
                                    self.log(
                                        f"WSP: scheduled pet sync retry for {chat_id} in {retry_delay:.1f}s (throttled)"
                                    )
                            if fallbackOk:
                                useP2pFallback = True
                                self.log(
                                    f"WSP: falling back to P2P sync for pet due to server failure"
                                )
                    except (
                        urllib.error.HTTPError,
                        urllib.error.URLError,
                        TimeoutError,
                        OSError,
                        ValueError,
                        TypeError,
                        AttributeError,
                        RuntimeError,
                    ) as e:
                        self.log(f"WSP: pet save error: {e}")
                        serverReason = "server_exception"
                        if not (
                            isinstance(e, RuntimeError)
                            and str(e) == "invalid_user_id"
                        ):
                            recordServer(False, "server_exception")
                        if fallbackOk:
                            useP2pFallback = True
                            self.log(
                                f"WSP: falling back to P2P sync for pet due to exception: {e}"
                            )
                else:
                    self.log(
                        f"WSP: my_user_id is invalid ({myUserId}), cannot sync pet"
                    )
                    recordServer(False, "invalid_user_id")
                    if fallbackOk:
                        useP2pFallback = True
                        self.log(
                            f"WSP: falling back to P2P sync for pet due to invalid user_id"
                        )
            elif mode == StreakSyncManager.MODE_AUTO and not autoCanSrv:
                self.log(f"WSP: auto mode server cooldown active for pet {chat_id}")

            if serverReason:
                self.tryAuthHeal(chat_id, serverReason, syncManager=sync_manager)

            if degradedFallback:
                useP2pFallback = True
                if mode == StreakSyncManager.MODE_AUTO:
                    self.log(f"WSP: auto mode degraded fallback enabled for pet {chat_id}")

            if mode == StreakSyncManager.MODE_AUTO and serverAttempted:
                if serverOk:
                    self.markAutoSrvOk(chat_id)
                else:
                    self.markAutoSrvFail(chat_id, serverReason)

            if mode == StreakSyncManager.MODE_P2P or useP2pFallback:
                petThrottleKey = f"pet_{chat_id}"
                petData = self.getPetData(chat_id, pet)
                p2pOk = self.sendP2pPayload(
                    chat_id,
                    sync_manager,
                    petData=petData,
                    throttleKey=petThrottleKey,
                    logPrefix="pet ",
                    myUserId=myUserId,
                    user1Id=user1Id,
                    user2Id=user2Id,
                )
                if p2pOk:
                    self.log(f"WSP: pet sync message sent via P2P to {chat_id}")

        except Exception as e:

            self.log(f"WSP: pet sync error: {e}")
            self.log(f"WSP: pet sync traceback: {traceback.format_exc()}")

    def deleteMsg(self, message, acct=None):
        try:
            MessagesController = find_class("org.telegram.messenger.MessagesController")
            if not MessagesController:
                self.log(f"WSP: MessagesController not found, cannot delete message")
                return

            message_id = getattr(message, "id", None)
            if not message_id:
                self.log(f"WSP: message has no id, cannot delete")
                return

            peer = getattr(message, "peerId", None) or getattr(message, "peer_id", None)
            if not peer:
                self.log(f"WSP: message has no peer, cannot delete")
                return

            dialog_id = (
                getattr(peer, "userId", None)
                or getattr(peer, "user_id", None)
                or getattr(peer, "channelId", None)
                or getattr(peer, "channel_id", None)
                or getattr(peer, "chatId", None)
                or getattr(peer, "chat_id", None)
            )
            if not dialog_id:
                self.log(f"WSP: cannot determine dialog_id, cannot delete")
                return
            dialog_id = self.normChat(dialog_id)
            if not self.isPrivateChat(dialog_id):
                self.log(f"WSP: not a private chat, skipping message deletion")
                return

            acct = self.getAcct(chat_id=dialog_id, acct=acct)
            controller = MessagesController.getInstance(int(acct))
            if controller:
                from java.util import ArrayList

                ids = ArrayList()
                ids.add(int(message_id))

                run_on_ui_thread(
                    lambda: self.delMsgCore(controller, ids, int(dialog_id))
                )
                self.log(
                    f"WSP: P2P sync message deleted (id={message_id}, dialog={dialog_id})"
                )
            else:
                self.log(f"WSP: MessagesController instance not available")
        except Exception as e:
            self.log(f"WSP: delete message error (non-critical): {e}")

    def delMsgCore(self, controller, ids, dialog_id):
        try:
            controller.deleteMessages(ids, None, None, int(dialog_id), 0, True, 0)
        except TypeError:
            try:
                controller.deleteMessages(ids, None, None, int(dialog_id), True, 0)
            except Exception:
                controller.deleteMessages(ids, None, None, int(dialog_id), True, False)

    def show_pet_stats(self, data):
        chat_id = self.extractChatId(data)
        chat_id = self.normChat(chat_id)

        if not chat_id:
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–∞—Ç", "Couldn't determine chat"))
            return

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            streak_key = self.getStreakKey(chat_id)
            streak = self.streaks.get(streak_key)
            if streak and not streak.deleted:
                try:
                    if streak.check_and_reset_if_expired():
                        self.log(f"WSP: streak expired when opening menu for {chat_id}")
                        if streak.is_dead:
                            self.onStreakDied(chat_id)
                        bulletin_safe(
                            "error",
                            tr(
                                "–°—Ç—Ä–∏–∫ —Å–±—Ä–æ—à–µ–Ω. –ü—Ä–æ—à–ª–æ –±–æ–ª–µ–µ 24 —á–∞—Å–æ–≤ –±–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏–π.",
                                "Streak reset. More than 24 hours without messages.",
                            ),
                        )
                        self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, True)
                except Exception as e:
                    self.log(f"WSP: error checking streak expiration: {e}")

        activity = self.getActivity()
        if not activity:
            return

        try:
            sheet = PetStatsBottomSheet(activity, self, chat_id)
            sheet.show()
            self.enqueueChatTask(chat_id, "syncFromServer", self.syncFromServer, chat_id, False)
        except Exception as e:
            self.log(f"WSP: show_pet_stats error: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")

    def getSkinCost(self, skin_style):
        if not isinstance(skin_style, int) or skin_style <= 0:
            return 0
        return SKIN_COST_BASE + (skin_style - 1) * SKIN_COST_STEP

    def showPetSkinShop(self, context, chat_id, on_done=None):
        try:
            from org.telegram.ui.ActionBar import AlertDialog

            chat_id = self.normChat(chat_id)
            pet = self.pets.get(chat_id) if self else None
            if not pet:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet not found"))
                return

            container = LinearLayout(context)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S8),
            )

            def updateStagesPreview(row, skinStyle):
                if not row:
                    return
                row.removeAllViews()
                stages = PET_STAGES_BY_STYLE.get(skinStyle, PET_STAGES_BY_STYLE[0])
                for stage_num, stage_data in list(stages.items())[:5]:
                    item = LinearLayout(context)
                    item.setOrientation(LinearLayout.VERTICAL)
                    item.setGravity(Gravity.CENTER)
                    item.setPadding(
                        AndroidUtilities.dp(Dp.S4),
                        AndroidUtilities.dp(Dp.S8),
                        AndroidUtilities.dp(Dp.S4),
                        AndroidUtilities.dp(Dp.S8),
                    )
                    emoji_tv = TextView(context)
                    emoji_tv.setText(stage_data["emoji"])
                    emoji_tv.setTextSize(1, 20)
                    emoji_tv.setGravity(Gravity.CENTER)
                    item.addView(emoji_tv)
                    level_tv = TextView(context)
                    level_tv.setText(str(stage_num))
                    level_tv.setTextSize(1, 10)
                    level_tv.setTextColor(get_on_surface_variant())
                    level_tv.setGravity(Gravity.CENTER)
                    item.addView(level_tv)
                    params = LinearLayout.LayoutParams(
                        0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
                    )
                    row.addView(item, params)

            preview = LinearLayout(context)
            preview.setOrientation(LinearLayout.HORIZONTAL)
            preview.setGravity(Gravity.CENTER)
            updateStagesPreview(preview, pet.getSkinStyle())
            preview_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            container.addView(preview, preview_params)

            skin_scroll = HorizontalScrollView(context)
            skin_scroll.setHorizontalScrollBarEnabled(False)
            skin_row = LinearLayout(context)
            skin_row.setOrientation(LinearLayout.HORIZONTAL)
            skin_row.setGravity(Gravity.CENTER_VERTICAL)
            skin_scroll.addView(
                skin_row,
                LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                ),
            )

            selected_skin = {"value": pet.getSkinStyle()}
            skin_items = []

            def applySkinSelection(selected_value):
                for item in skin_items:
                    view = item["view"]
                    label = item["label"]
                    emoji = item["emoji"]
                    is_selected = item["value"] == selected_value
                    bg = GradientDrawable()
                    bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
                    bg.setColor(UI.primary_container() if is_selected else UI.surface_variant())
                    view.setBackground(bg)
                    label.setTextColor(UI.on_primary_container() if is_selected else UI.on_surface_variant())
                    emoji.setAlpha(1.0 if is_selected else 0.7)

            for skin_value in sorted(PET_STAGES_BY_STYLE.keys()):
                stages = PET_STAGES_BY_STYLE.get(skin_value, PET_STAGES_BY_STYLE[0])
                stage_emoji = stages[0]["emoji"]
                stage_name = stages[1]["name"] if 1 in stages else stages[0]["name"]
                base_label = PET_STAGE_NAME_EN.get(stage_name, stage_name) if isEn() else stage_name
                cost = self.getSkinCost(skin_value)
                perk_text = skinPerkText(skin_value)
                if cost > 0:
                    label_text = f"{base_label} ‚Ä¢ {cost} ü™ô"
                else:
                    label_text = base_label
                if perk_text:
                    label_text = f"{label_text}\n{perk_text}"

                item = LinearLayout(context)
                item.setOrientation(LinearLayout.VERTICAL)
                item.setGravity(Gravity.CENTER)
                item.setPadding(
                    AndroidUtilities.dp(Dp.S12),
                    AndroidUtilities.dp(Dp.S10),
                    AndroidUtilities.dp(Dp.S12),
                    AndroidUtilities.dp(Dp.S10),
                )
                item_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                item_params.setMargins(
                    0,
                    0,
                    AndroidUtilities.dp(Dp.S8),
                    0,
                )

                emoji_tv = TextView(context)
                emoji_tv.setText(stage_emoji)
                emoji_tv.setTextSize(1, 20)
                emoji_tv.setGravity(Gravity.CENTER)
                item.addView(emoji_tv)

                name_tv = TextView(context)
                name_tv.setText(label_text)
                name_tv.setTextSize(1, 10)
                name_tv.setGravity(Gravity.CENTER)
                item.addView(name_tv)

                def onSkinClick(v, sv=skin_value):
                    selected_skin["value"] = sv
                    applySkinSelection(sv)
                    updateStagesPreview(preview, sv)

                item.setOnClickListener(OnClickListener(onSkinClick))
                skin_row.addView(item, item_params)
                skin_items.append(
                    {"value": skin_value, "view": item, "label": name_tv, "emoji": emoji_tv}
                )

            applySkinSelection(selected_skin["value"])
            container.addView(
                skin_scroll,
                LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                ),
            )

            builder = AlertDialog.Builder(context)
            builder.setTitle(tr("–°–º–µ–Ω–∏—Ç—å —Å–∫–∏–Ω", "Change skin"))
            builder.setView(container)

            def on_positive(dialog, which):
                try:
                    changed = False
                    not_enough = None
                    with self.data_lock:
                        current_skin = pet.getSkinStyle()
                        new_skin = V.int_range(
                            selected_skin["value"],
                            0,
                            MAX_PET_SKIN_STYLE,
                            current_skin,
                        )
                        if new_skin != current_skin:
                            cost = self.getSkinCost(new_skin)
                            if cost > 0 and int(pet.coins) < int(cost):
                                not_enough = (int(pet.coins), int(cost))
                            else:
                                if cost > 0 and not pet.spendCoins(cost):
                                    not_enough = (int(pet.coins), int(cost))
                                else:
                                    pet.skinStyle = new_skin
                                    now = time.time()
                                    pet.last_update_time = now
                                    pet.last_sync_timestamp = now
                                    changed = True

                    if not_enough:
                        have, need = not_enough
                        bulletin_safe(
                            "error",
                            tr(
                                f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç–æ–∫ ({have}/{need})",
                                f"Not enough coins ({have}/{need})",
                            ),
                        )
                        return

                    if changed:
                        self.saveSoon()
                        self.refreshPetWidget(chat_id)
                        self.enqueueChatTask(
                            chat_id, "syncPet", self.syncPet, chat_id, pet, True
                        )
                        bulletin_safe("success", tr("–°–∫–∏–Ω —É—Å–ø–µ—à–Ω–æ —Å–º–µ–Ω—ë–Ω", "Skin updated"))
                    if on_done:
                        on_done()
                except Exception:
                    bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–∫–∏–Ω", "Failed to save skin"))

            from java import dynamic_proxy

            ButtonClickListener = dynamic_proxy(AlertDialog.OnButtonClickListener)

            class PositiveListener(ButtonClickListener):
                def onClick(self, dialog, which):
                    on_positive(dialog, which)

            builder.setPositiveButton(tr("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", "Save"), PositiveListener())
            builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)
            safeShowDialog(builder, lambda: None)

        except Exception as e:
            self.log(f"WSP: error showing skin dialog: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def feed_pet(self, data):
        if self.ensureAsync(self.feed_pet, data):
            return
        chat_id = self.extractChatId(data)
        if self.guardAction(f"feedPet:{chat_id}", 0.6):
            return

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é –ø–∏—Ç–æ–º—Ü–∞.",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the pet menu.",
                ),
            )
            if not pet:
                return

            current_time = time.time()
            time_diff = current_time - pet.last_feed_time

            if time_diff < FEED_COOLDOWN_SECONDS:
                remaining_minutes = int(
                    (FEED_COOLDOWN_SECONDS - time_diff) / SECONDS_PER_MINUTE
                )
                bulletin_safe(
                    "info",
                    tr(
                        f"–ü–∏—Ç–æ–º–µ—Ü —Å—ã—Ç. –ü–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ {remaining_minutes} –º–∏–Ω",
                        f"Pet is full. Try again in {remaining_minutes} min",
                    ),
                )
                return

            xp_reward = pet.feed()
            evolved = pet.add_xp(xp_reward)

        if evolved:
            bulletin_safe(
                "success",
                tr(
                    f"–ü–æ–∫–æ—Ä–º–∏–ª–∏. –≠–≤–æ–ª—é—Ü–∏—è: +{xp_reward} XP",
                    f"Fed. Evolution: +{xp_reward} XP",
                ),
            )
        else:
            bulletin_safe(
                "success",
                tr(
                    f"–ü–æ–∫–æ—Ä–º–∏–ª–∏. +{xp_reward} XP | –ì–æ–ª–æ–¥: {int(pet.hunger)}%",
                    f"Fed. +{xp_reward} XP | Hunger: {int(pet.hunger)}%",
                ),
            )

        self.saveSoon()
        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)

    def applyFoodBoost(self, chat_id):
        if self.ensureAsync(self.applyFoodBoost, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"foodBoost:{chat_id}", 0.6):
            return
        if not self.needPetChat(chat_id):
            return
        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the menu",
                ),
            )
            if not pet:
                return
            now = time.time()
            if pet.hunger_block_until and pet.hunger_block_until > now:
                remaining = int((pet.hunger_block_until - now) / SECONDS_PER_MINUTE)
                bulletin_safe(
                    "info",
                    tr(
                        f"–£–∂–µ –∞–∫—Ç–∏–≤–Ω–æ, –æ—Å—Ç–∞–ª–æ—Å—å ~{remaining} –º–∏–Ω",
                        f"Already active, ~{remaining} min left",
                    ),
                )
                return
            if pet.coins < SUPER_FOOD_COST:
                bulletin_safe(
                    "error",
                    tr(
                        f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç–æ–∫ ({pet.coins}/{SUPER_FOOD_COST})",
                        f"Not enough coins ({pet.coins}/{SUPER_FOOD_COST})",
                    ),
                )
                return
            pet.spendCoins(SUPER_FOOD_COST)
            pet.applyHungerBlock(HUNGER_BLOCK_SECONDS)

        self.saveSoon()
        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)
        bulletin_safe(
            "success",
            tr(
                f"–°—ã—Ç–æ—Å—Ç—å + –±–ª–æ–∫ –≥–æ–ª–æ–¥–∞ –Ω–∞ {HUNGER_BLOCK_HOURS}—á",
                f"Satiety + hunger block for {HUNGER_BLOCK_HOURS}h",
            ),
        )

    def applyXpBoost(self, chat_id, mult, hours, cost):
        if self.ensureAsync(self.applyXpBoost, chat_id, mult, hours, cost):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"xpBoost:{chat_id}", 0.6):
            return
        if not self.needPetChat(chat_id):
            return
        try:
            mult = float(mult)
            hours = int(hours)
            cost = int(cost)
        except Exception:
            return
        if mult <= 1.0 or hours <= 0:
            return
        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the menu",
                ),
            )
            if not pet:
                return
            if cost > 0 and pet.coins < cost:
                bulletin_safe(
                    "error",
                    tr(
                        f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç–æ–∫ ({pet.coins}/{cost})",
                        f"Not enough coins ({pet.coins}/{cost})",
                    ),
                )
                return
            if cost > 0:
                pet.spendCoins(cost)
            now = time.time()
            if pet.xp_boost_until and pet.xp_boost_mult == mult:
                base = max(now, pet.xp_boost_until)
            else:
                base = now
            pet.xp_boost_until = base + (hours * SECONDS_PER_HOUR)
            pet.xp_boost_mult = mult
            pet.last_update_time = now
            pet.last_sync_timestamp = now

        self.saveSoon()
        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)
        percent = int((mult - 1.0) * 100)
        bulletin_safe(
            "success",
            tr(
                f"–ë—É—Å—Ç XP +{percent}% –Ω–∞ {hours}—á",
                f"XP boost +{percent}% for {hours}h",
            ),
        )

    def applyAccessory(self, chat_id, acc_id, cost):
        if self.ensureAsync(self.applyAccessory, chat_id, acc_id, cost):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"acc:{chat_id}", 0.6):
            return
        if not self.needPetChat(chat_id):
            return
        try:
            acc_id = int(acc_id)
            cost = int(cost)
        except Exception:
            return
        if acc_id < 0 or acc_id > MAX_PET_ACCESSORY:
            return
        if acc_id and not getAccessoryStyle(acc_id):
            return
        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the menu",
                ),
            )
            if not pet:
                return
            if pet.accessory == acc_id:
                bulletin_safe(
                    "info",
                    tr("–£–∂–µ –≤—ã–±—Ä–∞–Ω–æ", "Already selected"),
                )
                return
            if cost > 0 and pet.coins < cost:
                bulletin_safe(
                    "error",
                    tr(
                        f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç–æ–∫ ({pet.coins}/{cost})",
                        f"Not enough coins ({pet.coins}/{cost})",
                    ),
                )
                return
            if cost > 0:
                pet.spendCoins(cost)
            pet.accessory = acc_id
            pet.last_update_time = time.time()
            pet.last_sync_timestamp = pet.last_update_time

        self.saveSoon()
        self.refreshPetWidget(chat_id)
        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)
        bulletin_safe("success", tr("–ê–∫—Å–µ—Å—Å—É–∞—Ä –ø—Ä–∏–º–µ–Ω—ë–Ω", "Accessory applied"))

    def showPetMinigame(self, chat_id):
        chat_id = self.normChat(chat_id)

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the menu",
                ),
            )
            if not pet:
                return
            hunger = pet.hunger

        if hunger < HUNGER_CONFIG["critical_level"]:
            bulletin_safe(
                "error",
                tr(
                    f"–°–ª–∏—à–∫–æ–º –≥–æ–ª–æ–¥–Ω—ã–π - —Å–Ω–∞—á–∞–ª–∞ –ø–æ–∫–æ—Ä–º–∏ (–≥–æ–ª–æ–¥: {int(hunger)}%)",
                    f"Pet is too hungry. Feed it first (hunger: {int(hunger)}%)",
                ),
            )
            return

        def show_game():
            try:
                from org.telegram.ui.ActionBar import AlertDialog

                activity = self.getActivity()
                if not activity:
                    self.play_with_pet({"chat_id": chat_id})
                    return

                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(
                    AndroidUtilities.dp(Dp.S20),
                    AndroidUtilities.dp(Dp.S16),
                    AndroidUtilities.dp(Dp.S20),
                    AndroidUtilities.dp(Dp.S16),
                )

                title_tv = TextView(activity)
                title_tv.setText(tr("–ú–∏–Ω–∏-–∏–≥—Ä–∞: –ø–æ–π–º–∞–π –ª–∞–∫–æ–º—Å—Ç–≤–æ", "Mini-game: catch the treat"))
                title_tv.setTextSize(1, 16)
                title_tv.setTextColor(UI.on_surface())
                title_tv.setTypeface(None, Typeface.BOLD)
                container.addView(title_tv)

                desc_tv = TextView(activity)
                desc_tv.setText(
                    tr(
                        f"–õ–æ–≤–∏ –ª–∞–∫–æ–º—Å—Ç–≤–æ –∑–∞ {MINIGAME_TIME_LIMIT_SECONDS}—Å. ",
                        f"Catch the treat in {MINIGAME_TIME_LIMIT_SECONDS}s. ",
                    )
                )
                desc_tv.setTextSize(1, 12)
                desc_tv.setTextColor(UI.on_surface())
                desc_tv.setAlpha(0.8)
                desc_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, AndroidUtilities.dp(Dp.S12))
                container.addView(desc_tv, desc_params)

                timer_tv = TextView(activity)
                timer_tv.setText(
                    tr(
                        f"‚è≥ {MINIGAME_TIME_LIMIT_SECONDS}—Å",
                        f"‚è≥ {MINIGAME_TIME_LIMIT_SECONDS}s",
                    )
                )
                timer_tv.setTextSize(1, 12)
                timer_tv.setTextColor(UI.on_surface())
                timer_tv.setAlpha(0.8)
                timer_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                timer_params.setMargins(0, 0, 0, AndroidUtilities.dp(Dp.S12))
                container.addView(timer_tv, timer_params)

                grid = LinearLayout(activity)
                grid.setOrientation(LinearLayout.VERTICAL)
                grid.setGravity(Gravity.CENTER)

                btns = []
                refs = {"dialog": None, "container": container, "timer": timer_tv}
                state = {"done": False, "cancelled": False, "cleaned": False}
                perk = skinPerk(pet)
                rare_chance = MINIGAME_RARE_BONUS_CHANCE + float(perk.get("rareChance", 0) or 0)
                if rare_chance > 0.35:
                    rare_chance = 0.35
                rare_hit = random.random() < rare_chance
                order = list(range(9))
                random.shuffle(order)
                round_state = {"index": 0, "hits": 0, "misses": 0}

                def render_target():
                    target = order[round_state["index"]]
                    for i, btn in enumerate(btns):
                        if i == target:
                            btn.setText("üç™")
                            btn.setAlpha(1.0)
                        else:
                            btn.setText("¬∑")
                            btn.setAlpha(0.7)

                def cleanup_minigame():
                    if state.get("cleaned"):
                        return
                    state["cleaned"] = True
                    try:
                        dlg = refs.get("dialog")
                        if dlg:
                            try:
                                dlg.dismiss()
                            except Exception:
                                pass
                    except Exception:
                        pass
                    try:
                        cont = refs.get("container")
                        if cont:
                            cont.removeAllViews()
                    except Exception:
                        pass
                    for key in list(refs.keys()):
                        refs[key] = None

                def finalize_result(is_win, result_label):
                    if state["done"] or state["cancelled"]:
                        return
                    state["done"] = True
                    try:
                        dlg = refs.get("dialog")
                        if dlg:
                            dlg.dismiss()
                    except Exception:
                        pass

                    bonus = 0
                    result = result_label
                    hits = round_state.get("hits", 0)
                    bonus = hits * MINIGAME_HIT_XP
                    bonus_coins = hits // MINIGAME_HIT_COIN_STEP
                    if hits >= 9:
                        bonus += MINIGAME_CLEAR_BONUS_XP
                        bonus_coins += MINIGAME_CLEAR_BONUS_COINS
                    if is_win:
                        combo = self.minigame_combo.get(chat_id, 0) + 1
                        self.minigame_combo[chat_id] = combo
                        combo_bonus = min(
                            combo * MINIGAME_COMBO_BONUS_XP, MINIGAME_MAX_COMBO_BONUS
                        )
                        bonus = MINIGAME_WIN_BONUS_XP + combo_bonus
                        if rare_hit:
                            bonus += MINIGAME_RARE_BONUS_XP
                            result = tr(f"{result} ‚ú® –î–∂–µ–∫–ø–æ—Ç", f"{result} ‚ú® Jackpot")
                        result = tr(f"{result} –ö–æ–º–±–æ x{combo}", f"{result} Combo x{combo}")
                    else:
                        self.minigame_combo[chat_id] = 0

                    self.play_with_pet(
                        {
                            "chat_id": chat_id,
                            "bonus_xp": bonus,
                            "bonus_coins": bonus_coins,
                            "minigame_result": result,
                        }
                    )
                    cleanup_minigame()

                def on_pick(index):
                    if state["done"] or state["cancelled"]:
                        return
                    target = order[round_state["index"]]
                    if index == target:
                        round_state["hits"] += 1
                        if round_state["index"] + 1 >= len(order):
                            finalize_result(True, tr("üéØ –£—Å–ø–µ—Ö", "üéØ Success"))
                            return
                        round_state["index"] += 1
                        render_target()
                    else:
                        round_state["misses"] += 1

                for r in range(3):
                    row = LinearLayout(activity)
                    row.setOrientation(LinearLayout.HORIZONTAL)
                    row.setGravity(Gravity.CENTER)
                    row_params = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                    )
                    if r > 0:
                        row_params.setMargins(0, AndroidUtilities.dp(Dp.S6), 0, 0)
                    for c in range(3):
                        idx = r * 3 + c
                        btn = UI.button(activity, "¬∑", lambda *args, i=idx: on_pick(i), "tonal")
                        btns.append(btn)
                        btn_params = LinearLayout.LayoutParams(
                            AndroidUtilities.dp(Dp.S56),
                            AndroidUtilities.dp(Dp.S56),
                        )
                        if c > 0:
                            btn_params.setMargins(AndroidUtilities.dp(Dp.S6), 0, 0, 0)
                        row.addView(btn, btn_params)
                    grid.addView(row, row_params)

                render_target()
                container.addView(grid)

                builder = AlertDialog.Builder(activity)
                builder.setTitle(tr("–ò–≥—Ä–∞—Ç—å", "Play"))
                builder.setView(container)
                builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

                def on_dismiss():
                    if not state["done"]:
                        state["cancelled"] = True
                    cleanup_minigame()

                dialog = safeShowDialog(builder, on_dismiss)
                refs["dialog"] = dialog

                timer_state = {"remaining": int(MINIGAME_TIME_LIMIT_SECONDS)}

                def tick_timer():
                    try:
                        if state["done"] or state["cancelled"]:
                            return
                        remaining = int(timer_state.get("remaining", 0))
                        tv = refs.get("timer")
                        if tv:
                            tv.setText(f"‚è≥ {remaining}—Å")
                        if remaining <= 1:
                            hits = round_state.get("hits", 0)
                            result = tr(f"‚åõ –í—Ä–µ–º—è –≤—ã—à–ª–æ ‚Ä¢ {hits}/9", f"‚åõ Time's up ‚Ä¢ {hits}/9")
                            is_win = hits >= 5
                            finalize_result(is_win, result)
                            return
                        timer_state["remaining"] = remaining - 1
                        run_on_ui_thread(tick_timer, 1000)
                    except Exception:
                        return

                run_on_ui_thread(tick_timer, 0)
            except Exception as e:
                self.log(f"WSP: mini-game error: {e}")
                self.play_with_pet({"chat_id": chat_id})

        run_on_ui_thread(show_game)

    def play_with_pet(self, data):
        chat_id = self.extractChatId(data)
        if self.guardAction(f"playPet:{chat_id}", 0.6):
            return
        bonus_xp = 0
        bonus_coins = 0
        minigame_result = ""
        try:
            bonus_xp = int(data.get("bonus_xp", 0))
        except Exception:
            bonus_xp = 0
        try:
            bonus_coins = int(data.get("bonus_coins", 0))
        except Exception:
            bonus_coins = 0
        minigame_result = V.str_or(data.get("minigame_result", "")).strip()

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é –ø–∏—Ç–æ–º—Ü–∞",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the pet menu",
                ),
            )
            if not pet:
                return

            if pet.hunger < HUNGER_CONFIG["critical_level"]:
                bulletin_safe(
                    "error",
                    tr(
                        f"–°–ª–∏—à–∫–æ–º –≥–æ–ª–æ–¥–Ω—ã–π - —Å–Ω–∞—á–∞–ª–∞ –ø–æ–∫–æ—Ä–º–∏ (–≥–æ–ª–æ–¥: {int(pet.hunger)}%)",
                        f"Pet is too hungry. Feed it first (hunger: {int(pet.hunger)}%)",
                    ),
                )
                return

            xp_reward = pet.play()

            if xp_reward > 0:
                total_reward = max(0, xp_reward + max(0, bonus_xp))
                evolved = pet.add_xp(total_reward)
                if bonus_coins > 0:
                    pet.addCoins(bonus_coins)
                emoji = pet.get_emoji()
                prefix = f"{minigame_result} " if minigame_result else ""
                bonus_msg = tr(
                    f" (+{bonus_xp} –±–æ–Ω—É—Å)",
                    f" (+{bonus_xp} bonus)",
                ) if bonus_xp > 0 else ""
                coin_msg = tr(
                    f" (+{bonus_coins} –º–æ–Ω.)",
                    f" (+{bonus_coins} coins)",
                ) if bonus_coins > 0 else ""

                if evolved:
                    bulletin_safe(
                        "success",
                        tr(
                            f"{prefix}–ü–æ–∏–≥—Ä–∞–ª–∏. –≠–≤–æ–ª—é—Ü–∏—è: +{total_reward} XP{bonus_msg}{coin_msg}",
                            f"{prefix}Played. Evolution: +{total_reward} XP{bonus_msg}{coin_msg}",
                        ),
                    )
                else:
                    bulletin_safe(
                        "success",
                        tr(
                            f"{prefix}–ü–æ–∏–≥—Ä–∞–ª–∏. +{total_reward} XP{bonus_msg}{coin_msg} | –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {int(pet.mood)}%",
                            f"{prefix}Played. +{total_reward} XP{bonus_msg}{coin_msg} | Mood: {int(pet.mood)}%",
                        ),
                    )

                self.saveSoon()
                self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)
            else:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü —Å–µ–π—á–∞—Å –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏–≥—Ä–∞—Ç—å", "Pet doesn't want to play"))

    def startStreak(self, chat_id):
        if self.ensureAsync(self.startStreak, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"startStreak:{chat_id}", 1.0):
            return
        if not self.isChatAllowed(chat_id):
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Streak isn't available in this chat"))
            return

        if chat_id in self.streak_enabled_chats:
            bulletin_safe("info", tr("–°—Ç—Ä–∏–∫ —É–∂–µ –≤–∫–ª—é—á—ë–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Streak is already on in this chat"))
            return

        existing = self.getStreak(chat_id)
        if existing and existing.is_dead:
            bulletin_safe(
                "info",
                tr(
                    "–°—Ç—Ä–∏–∫ —É–º–µ—Ä - –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ –∏–ª–∏ —Å–±—Ä–æ—Å—å –µ–≥–æ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ",
                    "Streak is dead - restore it or reset to start over",
                ),
            )
            return

        sync_manager = self.getSyncMgr()

        def dostartStreak():
            try:
                server_data = None
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
                    if my_user_id and my_user_id > 0:
                        try:
                            server_data = sync_manager.get_streak_from_server(
                                my_user_id, chat_id
                            )
                        except Exception as e:
                            self.log(f"WSP: failed to check server for streak: {e}")

                def finish_on_ui():
                    if (
                        server_data
                        and not server_data.get("deleted", False)
                        and server_data.get("count", 0) > 0
                    ):
                        self.log(
                            f"WSP: found existing streak on server for {chat_id}, loading..."
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)
                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            streak.apply_sync_data(server_data, source="server")
                            self.setSyncedHash(
                                chat_id, streak_data=streak.get_sync_data()
                            )
                            self.saveSoon()
                            bulletin_safe(
                                "success",
                                tr(
                                    f"–°—Ç—Ä–∏–∫ –∑–∞–≥—Ä—É–∂–µ–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞: {formatDaysRu(server_data.get('count', 0))}",
                                    f"Streak loaded from server: {formatDaysEn(server_data.get('count', 0))}",
                                ),
                            )
                            self.log(
                                f"WSP: streak loaded from server for {chat_id}, count={server_data.get('count')}"
                            )
                    else:
                        self.log(f"WSP: creating new streak for {chat_id}")
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)
                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            self.resetStreakForStart(streak)
                        self.saveSoon()
                        self.log(f"WSP: streak created and enabled for chat {chat_id}")
                        bulletin_safe(
                            "success",
                            tr(
                                "–°—Ç—Ä–∏–∫ –≤–∫–ª—é—á–µ–Ω. –ü–∏—à–∏ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Å–µ—Ä–∏—é",
                                "Streak is on. Write every day to keep it going",
                            ),
                        )
                        if streak:
                            self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, True)

                run_on_ui_thread(finish_on_ui)
            except Exception as e:
                self.log(f"WSP: error starting streak: {e}")

        self.runAsync(dostartStreak)

    def resetStreakForStart(self, streak):
        streak.count = 0
        streak.last_date = None
        streak.first_date = None
        streak.deleted = False
        streak.warning_since = None
        streak.dead_since = None
        streak.dead_count = 0
        streak.last_message_time = time.time()
        streak.last_sync_timestamp = time.time()

    def stopStreak(self, chat_id):
        if self.ensureAsync(self.stopStreak, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"stopStreak:{chat_id}", 1.0):
            return
        if chat_id not in self.streak_enabled_chats:
            bulletin_safe("info", tr("–í —ç—Ç–æ–º —á–∞—Ç–µ —Å—Ç—Ä–∏–∫ –≤—ã–∫–ª—é—á–µ–Ω", "Streak is off in this chat"))
            return

        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        with self.data_lock:
            self.streak_enabled_chats.discard(chat_id)
            if streak:
                self.markStreakDeleted(streak, update_sync_ts=True)
        self.saveSoon()

        if streak:
            self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, True)

        bulletin_safe("success", tr("–°—Ç—Ä–∏–∫ –≤—ã–∫–ª—é—á–µ–Ω –∏ —Å–±—Ä–æ—à–µ–Ω", "Streak disabled and reset"))

    def restoreStreak(self, chat_id):
        if self.ensureAsync(self.restoreStreak, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"restoreStreak:{chat_id}", 1.0):
            return
        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        if not streak:
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", "Streak not found"))
            return

        if not streak.is_dead:
            bulletin_safe("info", tr("–°—Ç—Ä–∏–∫ –∂–∏–≤, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ", "Streak is active; no restore needed"))
            return

        if not streak.can_restore:
            if streak.restore_time_left <= 0:
                bulletin_safe("error", tr("–û–∫–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —É–∂–µ –ø—Ä–æ—à–ª–æ", "Restore window expired"))
            else:
                bulletin_safe("error", tr("–õ–∏–º–∏—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π –∑–∞ –º–µ—Å—è—Ü –∏—Å—á–µ—Ä–ø–∞–Ω", "Monthly restore limit reached"))
            return

        pet_to_sync = None
        with self.data_lock:
            if streak.restore():
                self.log(f"WSP: streak restored for {chat_id}, count={streak.count}")
                pet = self.pets.get(chat_id)
                if not pet:
                    pet = Pet(chat_id, plugin_ref=self)
                    self.pets[chat_id] = pet
                    self.log(f"WSP: created new pet for {chat_id} after streak restore")
                now = time.time()
                if pet.deleted:
                    pet.applyReviveState(now)
                    self.log(f"WSP: pet also restored for {chat_id}")
                else:
                    pet.last_sync_timestamp = now
                self.pet_enabled_chats.add(chat_id)
                pet_to_sync = pet
            else:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∏–∫", "Couldn't restore streak"))
                return

        self.saveSoon()
        queued_streak = self.enqueueChatTask(
            chat_id,
            "syncStreak",
            self.syncStreak,
            chat_id,
            streak,
            True,
        )
        if not queued_streak:
            self.log(f"WSP: restore syncStreak pending for {chat_id}, queueing restore override")
            self.enqueueChatTask(
                chat_id,
                "syncStreakRestore",
                self.syncStreak,
                chat_id,
                streak,
                True,
            )
        if pet_to_sync:
            queued_pet = self.enqueueChatTask(
                chat_id,
                "syncPet",
                self.syncPet,
                chat_id,
                pet_to_sync,
                True,
            )
            if not queued_pet:
                self.log(f"WSP: restore syncPet pending for {chat_id}, queueing restore override")
                self.enqueueChatTask(
                    chat_id,
                    "syncPetRestore",
                    self.syncPet,
                    chat_id,
                    pet_to_sync,
                    True,
                )

        bulletin_safe(
            "success",
            tr(
                f"–°—Ç—Ä–∏–∫ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º: {formatDaysRu(streak.count)}",
                f"Streak restored. Continue: {formatDaysEn(streak.count)}",
            ),
        )

    def restartDeadStreak(self, chat_id):
        if self.ensureAsync(self.restartDeadStreak, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"resetStreak:{chat_id}", 1.0):
            return
        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        if not streak:
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", "Streak not found"))
            return

        with self.data_lock:
            streak.count = 0
            streak.last_date = None
            streak.first_date = None
            streak.deleted = False
            streak.dead_since = None
            streak.dead_count = 0
            streak.warning_since = None
            streak.last_sync_timestamp = time.time()
            self.log(f"WSP: dead streak reset for {chat_id}, ready for fresh start")

        self.saveSoon()
        self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, streak, True)

        bulletin_safe(
            "success",
            tr(
                "–°—Ç—Ä–∏–∫ —Å–±—Ä–æ—à–µ–Ω. –û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ",
                "Streak reset. Send a message to start again",
            ),
        )

    def startPet(self, chat_id, skinStyle=None):
        if self.ensureAsync(self.startPet, chat_id, skinStyle):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"startPet:{chat_id}", 1.0):
            return
        if not self.needPetChat(chat_id):
            return

        if chat_id in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü —É–∂–µ –≤–∫–ª—é—á—ë–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Pet is already on in this chat"))
            return

        sync_manager = self.getSyncMgr()

        def dostartPet():
            try:
                server_data = None
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
                    if my_user_id and my_user_id > 0:
                        try:
                            user1_id, user2_id = self.getSortedIds(chat_id)
                            if not user1_id:
                                user1_id = None
                                user2_id = None
                                raise RuntimeError("invalid_user_id")
                            server_data = sync_manager.get_pet_from_server(user1_id, user2_id)
                        except Exception as e:
                            self.log(f"WSP: failed to check server for pet: {e}")

                def finish_on_ui():
                    if server_data and not server_data.get("deleted", False):
                        self.log("WSP: found existing pet on server, loading...")
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)
                        pet = self.getOrCreatePet(chat_id)
                        pet.apply_sync_data(server_data, source="server")
                        self.setSyncedHash(
                            chat_id, pet_data=pet.get_sync_data()
                        )
                        self.saveSoon()

                        stage = server_data.get("stage", 1)
                        bulletin_safe(
                            "success",
                            tr(
                                f"–ü–∏—Ç–æ–º–µ—Ü –∑–∞–≥—Ä—É–∂–µ–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞: —É—Ä.{stage} (XP: {server_data.get('xp')})",
                                f"Pet loaded from server: Lv.{stage} (XP: {server_data.get('xp')})",
                            ),
                        )
                        self.log(
                            f"WSP: pet loaded from server for {chat_id}, xp={server_data.get('xp')}, stage={server_data.get('stage')}"
                        )
                    else:
                        self.log(f"WSP: creating new pet for {chat_id}")
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)
                            if chat_id in self.pets:
                                old_pet = self.pets[chat_id]
                                if hasattr(old_pet, "cleanup"):
                                    try:
                                        old_pet.cleanup()
                                    except Exception:
                                        pass
                                del self.pets[chat_id]
                        pet = self.getOrCreatePet(chat_id)
                        selected_skin = 0 if skinStyle is None else skinStyle
                        pet.skinStyle = V.int_range(
                            selected_skin, 0, MAX_PET_SKIN_STYLE, pet.skinStyle
                        )
                        now = time.time()
                        pet.last_update_time = now
                        pet.last_sync_timestamp = now
                        self.saveSoon()
                        self.log(f"WSP: pet created and enabled for chat {chat_id}")
                        bulletin_safe(
                            "success",
                            tr(
                                "–ü–∏—Ç–æ–º–µ—Ü —Å–æ–∑–¥–∞–Ω. –û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –æ–Ω –Ω–∞—á–∞–ª —Ä–∞—Å—Ç–∏",
                                "Pet created. Send a message to start growing",
                            ),
                        )
                        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)

                run_on_ui_thread(finish_on_ui)
            except Exception as e:
                self.log(f"WSP: error starting pet: {e}")

        self.runAsync(dostartPet)

    def revivePet(self, chat_id):
        if self.ensureAsync(self.revivePet, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"revivePet:{chat_id}", 1.0):
            return
        if not self.needPetChat(chat_id):
            return

        streak = self.getStreak(chat_id)
        if streak and streak.is_dead:
            bulletin_safe("error", tr("–°–Ω–∞—á–∞–ª–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ —Å—Ç—Ä–∏–∫", "Restore the streak first"))
            return

        with self.data_lock:
            now = time.time()
            last_revive = self.pet_revive_times.get(chat_id, 0)
            if last_revive and now - last_revive < REVIVE_COOLDOWN_SECONDS:
                remaining = int((REVIVE_COOLDOWN_SECONDS - (now - last_revive)) / SECONDS_PER_MINUTE)
                bulletin_safe(
                    "info",
                    tr(
                        f"‚è≥ –í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ —á–µ—Ä–µ–∑ {remaining} –º–∏–Ω",
                        f"‚è≥ Revive available in {remaining} min",
                    ),
                )
                return

            pet = self.pets.get(chat_id)
            if not pet:
                pet = Pet(chat_id, plugin_ref=self)
                self.pets[chat_id] = pet
            elif not pet.deleted:
                bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü —É–∂–µ –∂–∏–≤", "Pet is already alive"))
                return
            if pet.deleted:
                if pet.coins < REVIVE_COIN_COST:
                    bulletin_safe(
                        "error",
                        tr(
                            f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–æ–Ω–µ—Ç–æ–∫ ({pet.coins}/{REVIVE_COIN_COST})",
                            f"Not enough coins ({pet.coins}/{REVIVE_COIN_COST})",
                        ),
                    )
                    return
                pet.spendCoins(REVIVE_COIN_COST)
            pet.applyReviveState(now)
            self.pet_enabled_chats.add(chat_id)
            self.pet_revive_times[chat_id] = now

        self.saveSoon()
        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)
        bulletin_safe("success", tr("–ü–∏—Ç–æ–º–µ—Ü —Å–Ω–æ–≤–∞ —Å —Ç–æ–±–æ–π", "Pet revived"))

    def stopPet(self, chat_id):
        if self.ensureAsync(self.stopPet, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"stopPet:{chat_id}", 1.0):
            return
        if chat_id not in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü –≤ —ç—Ç–æ–º —á–∞—Ç–µ –Ω–µ –∑–∞–≤–µ–¥–µ–Ω", "No pet yet in this chat"))
            return

        with self.data_lock:
            self.pet_enabled_chats.discard(chat_id)
            if chat_id in self.pets:
                old_pet = self.pets[chat_id]
                if hasattr(old_pet, "cleanup"):
                    try:
                        old_pet.cleanup()
                    except Exception:
                        pass
                del self.pets[chat_id]
        self.saveSoon()

        bulletin_safe("success", tr("–ü–∏—Ç–æ–º–µ—Ü –æ—Ç–∫–ª—é—á–µ–Ω", "Pet disabled"))

    def renamePet(self, chat_id, new_name):
        if self.ensureAsync(self.renamePet, chat_id, new_name):
            return
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            pet = self.pets.get(chat_id)
            if not pet:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet not found"))
                return

            old_name = pet.name
            pet.name = new_name
            pet.last_sync_timestamp = time.time()

        self.saveSoon()

        bulletin_safe(
            "success",
            tr(
                f"–ü–∏—Ç–æ–º–µ—Ü –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: {old_name} ‚Üí {new_name}",
                f"Pet renamed: {old_name} ‚Üí {new_name}",
            ),
        )

        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)

    def kickPet(self, chat_id):
        if self.ensureAsync(self.kickPet, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"kickPet:{chat_id}", 1.0):
            return
        with self.data_lock:
            pet = self.pets.get(chat_id)
            self.pet_enabled_chats.discard(chat_id)
            if pet:
                self.markPetDeleted(pet, update_sync_ts=True)
        self.saveSoon()

        if pet:
            self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, pet, True)

        bulletin_safe("success", tr("–ü–∏—Ç–æ–º–µ—Ü —É–¥–∞–ª—ë–Ω", "Pet deleted"))

    def checkServerStatus(self, view=None):

        def check_in_thread():
            try:
                sync_manager = self.getSyncMgr()
                if not sync_manager:
                    run_on_ui_thread(
                        lambda: bulletin_safe(
                            "error",
                            tr(
                                "–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω",
                                "Sync manager unavailable",
                            ),
                        )
                    )
                    return
                current_mode = SYNC_MODE_NAMES.get(
                    sync_manager.mode, str(sync_manager.mode)
                )
                start_time = time.time()
                is_healthy = sync_manager.checkServerHealth()
                response_time = int((time.time() - start_time) * 1000)
                def show_result():
                    try:
                        activity = self.getActivity()
                        if not activity:
                            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                            return

                        if is_healthy:
                            title = tr("–°–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω", "Server is online")
                            message = (
                                tr("–°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ–Ω–ª–∞–π–Ω\n", "Status: online\n")
                                + f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {current_mode}\n"
                                + f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {response_time}ms"
                            )
                        else:
                            title = tr("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Server unavailable")
                            message = (
                                tr("–°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ—Ñ–ª–∞–π–Ω\n", "Status: offline\n")
                                + f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {current_mode}\n"
                                + f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {response_time}ms"
                            )
                            message += "\n" + tr(
                                "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å VPN/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                                "Tip: check VPN/proxy or try later",
                            )

                        self.showAlert(
                            activity,
                            title,
                            message,
                            "OK",
                            lambda b, w: b.dismiss(),
                        )
                    except (AttributeError, RuntimeError, TypeError, ValueError, OSError) as e:
                        self.log(f"WSP: error showing server status: {e}")
                        bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", "Couldn't show result"))

                run_on_ui_thread(show_result)

            except (
                urllib.error.HTTPError,
                urllib.error.URLError,
                TimeoutError,
                OSError,
                ValueError,
                TypeError,
                AttributeError,
                RuntimeError,
            ) as e:
                self.log(f"WSP: error checking server: {e}")
                run_on_ui_thread(
                    lambda: bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}", f"Check failed: {e}"))
                )

        self.runAsync(check_in_thread)

    def resetAuth(self, view=None):
        try:
            activity = self.getActivity()
            if not activity:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                return

            title = tr("–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é", "Reset auth")
            message = tr(
                "–°–±—Ä–æ—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –≤—Ö–æ–¥–∞?\n\n"
                "–ü–æ–º–æ–≥–∞–µ—Ç, –µ—Å–ª–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç.\n"
                "–ù–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –±—É–¥—É—Ç –ø–æ–ª—É—á–µ–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –º–∏–Ω—É—Ç—É).",
                "Reset sign-in data?\n\n"
                "Helps if sync won‚Äôt go through.\n"
                "New data will be fetched automatically (may take a minute).",
            )
            self.showAlert(
                activity,
                title,
                message,
                tr("–°–±—Ä–æ—Å–∏—Ç—å", "Reset"),
                lambda b, w: self.doResetAuth(b),
                tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
                lambda b, w: b.dismiss(),
            )
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: error showing auth reset: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))

    def doResetAuth(self, builder=None):
        try:
            if builder:
                builder.dismiss()
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: auth reset dismiss error: {e}")

        try:
            self.set_setting("install_id", "")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to clear install_id: {e}")

        try:
            if not self._setSecretSettingStr("devkey", ""):
                raise RuntimeError("secure_store_failed")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to clear devkey: {e}")
        try:
            if not self._setSecretSettingStr("install_secret", ""):
                raise RuntimeError("secure_store_failed")
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to clear install_secret: {e}")
        self.setResetSecretFlag(True)

        try:
            new_id = self.getInstallId()
            sync_manager = self.getSyncMgr()
            if sync_manager:
                reset_ok = True
                if not sync_manager.setInstallId(new_id):
                    sync_manager.last_error = "missing_install_id"
                    reset_ok = False
                if not sync_manager.setDevKey(self.getDevKey()):
                    sync_manager.last_error = "missing_devkey"
                    reset_ok = False
                sync_manager.setResetSecret(True)
                secret = self.getInstallSecret()
                if secret:
                    sync_manager.setInstallSecret(secret)
                sync_manager.token = None
                sync_manager.tokenExp = 0
                if reset_ok:
                    sync_manager.last_error = None
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to reset auth state: {e}")

        bulletin_safe(
            "success",
            tr(
                "–ì–æ—Ç–æ–≤–æ. –û—Ç–∫—Ä–æ–π —á–∞—Ç, —á—Ç–æ–±—ã —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è –∑–∞–Ω–æ–≤–æ.",
                "Done. Open a chat to sync again.",
            ),
        )

    def resetP2pKeys(self, view=None):
        try:
            activity = self.getActivity()
            if not activity:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                return
            title = tr("–°–±—Ä–æ—Å–∏—Ç—å P2P –∫–ª—é—á–∏", "Reset P2P keys")
            message = tr("p2pResetConfirm")
            self.showAlert(
                activity,
                title,
                message,
                tr("–°–±—Ä–æ—Å–∏—Ç—å", "Reset"),
                lambda b, w: self.doResetP2pKeys(b),
                tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
                lambda b, w: b.dismiss(),
            )
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: error showing p2p reset: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))

    def doResetP2pKeys(self, builder=None):
        try:
            if builder:
                builder.dismiss()
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: p2p reset dismiss error: {e}")
        try:
            with self.data_lock:
                self.p2pKeys.clear()
            self._setSecretSettingDict("p2pkeys", {})
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: failed to clear p2pkeys: {e}")
        self.saveSoon()
        bulletin_safe("success", tr("p2pResetDone"))

    def showResetConfirm(self):
        try:
            activity = self.getActivity()
            if not activity:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                return

            title = tr("–°–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö", "Data reset")
            message = tr(
                "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ?\n\n"
                "‚Ä¢ –ü–∏—Ç–æ–º—Ü—ã –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã\n"
                "‚Ä¢ –°—Ç—Ä–∏–∫–∏ –±—É–¥—É—Ç —Å–±—Ä–æ—à–µ–Ω—ã\n"
                "‚Ä¢ –î–∞–Ω–Ω—ã–µ —É–¥–∞–ª—è—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ\n\n"
                "–î–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
                "Delete all data?\n\n"
                "‚Ä¢ Pets will be removed\n"
                "‚Ä¢ Streaks will be reset\n"
                "‚Ä¢ Data will be removed locally and on the server\n\n"
                "This action can't be undone.",
            )
            self.showAlert(
                activity,
                title,
                message,
                tr("–£–¥–∞–ª–∏—Ç—å", "Delete"),
                lambda b, w: self.doReset(b),
                tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
                lambda b, w: b.dismiss(),
            )
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: error showing reset confirmation: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))

    def doReset(self, builder):
        try:
            builder.dismiss()
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: builder dismiss error: {e}")

        self.resetAllData_internal()

    def resetAllData(self, view=None):
        self.showResetConfirm()

    def clearCache(self, view=None):
        if self.ensureAsync(self.clearCache, view):
            return
        try:
            cleared = 0
            sync_manager = self.getSyncMgr()
            if sync_manager and hasattr(sync_manager, "cache"):
                try:
                    lock = getattr(sync_manager, "_cache_lock", None)
                    if lock:
                        with lock:
                            cleared = len(sync_manager.cache)
                            sync_manager.cache.clear()
                    else:
                        cleared = len(sync_manager.cache)
                        sync_manager.cache.clear()
                except Exception as e:
                    self.log(f"WSP: cache clear error: {e}")

            try:
                UI._cache.clear()
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: UI cache clear error: {e}")

            self._sync_manager_cache_time = 0

            try:
                self.last_auto_sync.clear()
                self.last_messages.clear()
                with self.data_lock:
                    self.chatAllow.clear()
            except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                self.log(f"WSP: failed to clear local sync caches: {e}")

            bulletin_safe(
                "success",
                tr(
                    f"–ö—ç—à –æ—á–∏—â–µ–Ω ({cleared} –∑–∞–ø–∏—Å–µ–π)",
                    f"Cache cleared ({cleared} entries)",
                ),
            )
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: error clearing cache: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –∫—ç—à", "Couldn't clear cache"))

    def resetAllData_internal(self):
        if self.ensureAsync(self.resetAllData_internal):
            return
        try:
            self.log("WSP: resetAllData_internal called!")
            bulletin_safe("info", tr("–°–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö...", "Resetting data..."))

            sync_manager = self.getSyncMgr()
            my_user_id = self.getMyId()

            with self.data_lock:
                pet_count = len(self.pets)
                streak_count = len(self.streaks)

                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    if my_user_id and my_user_id > 0:
                        for chat_id, pet in self.pets.items():
                            try:
                                self.markPetDeleted(pet, update_sync_ts=True)
                                self.sendPetSync(chat_id, pet)
                            except (
                                TypeError,
                                ValueError,
                                AttributeError,
                                RuntimeError,
                                OSError,
                                urllib.error.HTTPError,
                                urllib.error.URLError,
                                TimeoutError,
                            ) as e:
                                self.log(
                                    f"WSP: failed to delete pet {chat_id} on server: {e}"
                                )

                        for chat_id, streak in self.streaks.items():
                            try:
                                self.markStreakDeleted(
                                    streak, update_sync_ts=True
                                )
                                self.sendSyncMsg(chat_id, streak)
                            except (
                                TypeError,
                                ValueError,
                                AttributeError,
                                RuntimeError,
                                OSError,
                                urllib.error.HTTPError,
                                urllib.error.URLError,
                                TimeoutError,
                            ) as e:
                                self.log(
                                    f"WSP: failed to delete streak {chat_id} on server: {e}"
                                )

                        self.log(
                            "WSP: sent delete sync to server for all pets and streaks"
                        )

                for pet in self.pets.values():
                    if hasattr(pet, "cleanup"):
                        try:
                            pet.cleanup()
                        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
                            pass
                self.pets.clear()
                self.streaks.clear()
                self.last_messages.clear()
                self.streak_enabled_chats.clear()
                self.pet_enabled_chats.clear()
                self.chatAllow.clear()
                self.p2pKeys.clear()

            self.saveData()

            self.log(
                f"WSP: reset completed - removed {pet_count} pets, {streak_count} streaks"
            )
            bulletin_safe("success", 
                tr(
                    f"–í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã: {pet_count} –ø–∏—Ç–æ–º—Ü–µ–≤, {streak_count} —Å—Ç—Ä–∏–∫–æ–≤",
                    f"All data removed: {pet_count} pets, {streak_count} streaks",
                )
            )

        except (
            TypeError,
            ValueError,
            AttributeError,
            RuntimeError,
            OSError,
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
        ) as e:
            self.log(f"WSP: error resetting data: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –¥–∞–Ω–Ω—ã—Ö: {e}", f"Reset error: {e}"))

    def showStreakMenu(self, data):
        chat_id = None
        try:
            chat_id = self.extractChatId(data)
            chat_id = self.normChat(chat_id)

            if not self.isPrivateChat(chat_id):
                self.log("WSP: not a private chat")
                bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–∞—Ö", "Streak works only in private chats"))
                return

            streak_key = self.getStreakKey(chat_id)
            streak = None
            with self.data_lock:
                streak = self.streaks.get(streak_key)
                if streak and not streak.deleted:
                    try:
                        changed = streak.check_and_reset_if_expired(allow_warning=True)
                        if changed:
                            if streak.is_dead:
                                self.onStreakDied(chat_id)
                            self.saveSoon()
                            self.enqueueChatTask(
                                chat_id, "syncStreak", self.syncStreak, chat_id, streak, True
                            )
                    except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
                        self.log(f"WSP: error updating streak state before menu: {e}")

            activity = self.getActivity("WSP:")
            if not activity:
                return

            sheet = StreakMenuBottomSheet(activity, self, chat_id)
            sheet.show()
        except (
            TypeError,
            ValueError,
            AttributeError,
            RuntimeError,
            OSError,
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
        ) as e:
            self.log(f"WSP: showStreakMenu ERROR: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")

    def showWspMenu(self, data):
        self.showStreakMenu(data)

    def showEvolution(self, pet):
        try:
            def show_fallback():
                stage_name = pet.get_stage_name()
                bulletin_safe(
                    "success",
                    tr(
                        f"–≠–≤–æ–ª—é—Ü–∏—è: {pet.name} —Å—Ç–∞–ª {stage_name} (—É—Ä. {pet.stage})",
                        f"Evolution: {pet.name} became {stage_name} (Lv. {pet.stage})",
                    ),
                )

            activity = self.getActivity()
            if not activity:
                show_fallback()
                return

            sheet = EvolutionBottomSheet(activity, pet)
            sheet.show()
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: showEvolution error: {e}")
            show_fallback()

    def syncFromServer(self, chat_id, skip_throttling=True):
        self.checkServerDataFast(chat_id, skip_throttling=skip_throttling)

    def checkServerDataFast(self, chat_id, skip_throttling=False):
        fetch_key = None
        try:
            chat_id = self.normChat(chat_id)
            fetch_key = f"{chat_id}:fetchServerData"
            with self.data_lock:
                if fetch_key in self._pending_chat_tasks:
                    return
                self._pending_chat_tasks.add(fetch_key)
            if not skip_throttling:
                if not self.shouldCheckServer(chat_id, SYNC_SERVER_CHECK_COOLDOWN):
                    return

            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                return

            syncMode = sync_manager.mode
            if syncMode not in (
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ):
                return
            if (
                syncMode == StreakSyncManager.MODE_AUTO
                and not self.canAutoSrv(chat_id, sync_manager)
            ):
                return

            my_user_id = V.toInt(
                self.getMyId(acct=self.getAcct(chat_id=chat_id)),
                0,
            )
            if my_user_id <= 0:
                return

            user1_id, user2_id = self.sortedIdsFast(chat_id, my_user_id)
            if not user1_id:
                return

            p2p_key = None
            if not self.getP2pKey(chat_id):
                try:
                    key = sync_manager.getP2pSrv(user1_id, user2_id)
                    if key:
                        p2p_key = key
                except (
                    urllib.error.HTTPError,
                    urllib.error.URLError,
                    TimeoutError,
                    OSError,
                    ValueError,
                    TypeError,
                    AttributeError,
                    RuntimeError,
                ) as e:
                    self.log(f"WSP: failed to load P2P key from server for {chat_id}: {e}")

            server_pet = None
            server_streak = None
            try:
                server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)
            except (
                urllib.error.HTTPError,
                urllib.error.URLError,
                TimeoutError,
                OSError,
                ValueError,
                TypeError,
                AttributeError,
                RuntimeError,
            ) as e:
                self.log(f"WSP: error checking pet on server: {e}")
            try:
                server_streak = sync_manager.get_streak_from_server(my_user_id, chat_id)
            except (
                urllib.error.HTTPError,
                urllib.error.URLError,
                TimeoutError,
                OSError,
                ValueError,
                TypeError,
                AttributeError,
                RuntimeError,
            ) as e:
                self.log(f"WSP: error checking streak on server: {e}")

            now = time.time()
            self.enqueueChatTask(
                chat_id,
                "applyServerData",
                self._applyServerData,
                chat_id,
                server_pet,
                server_streak,
                p2p_key,
                now,
            )
        except (
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            RuntimeError,
        ) as e:
            self.log(f"WSP: checkServerDataFast error: {e}")
        finally:
            if fetch_key:
                with self.data_lock:
                    self._pending_chat_tasks.discard(fetch_key)

    def _applyServerData(self, chat_id, server_pet, server_streak, p2p_key, now):
        try:
            chat_id = self.normChat(chat_id)
            updated_any = False
            dirty = False
            chat_id_str = str(chat_id)

            def markUpdated():
                nonlocal updated_any
                updated_any = True

            if p2p_key and not self.getP2pKey(chat_id):
                self.setP2pKey(chat_id, p2p_key)
                self.saveSoon()

            if server_pet:
                with self.data_lock:
                    petEnabled = chat_id in self.pet_enabled_chats
                if server_pet.get("deleted", False):
                    local_pet = None
                    apply_delete = True
                    with self.data_lock:
                        petEnabledNow = chat_id in self.pet_enabled_chats
                        local_pet = self.pets.get(chat_id)
                        if (
                            petEnabledNow
                            and local_pet
                            and not local_pet.deleted
                        ):
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_pet, server_pet, "server"
                            )

                    if not apply_delete and local_pet:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "server",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=local_pet.get_sync_data().get("timestamp"),
                            remote_ts=server_pet.get("timestamp"),
                        )
                        self.log(
                            f"WSP: server pet deleted for chat {chat_id}, keeping local and pushing"
                        )
                        self.enqueueChatTask(chat_id, "syncPet", self.syncPet, chat_id, local_pet, True)
                        markUpdated()
                    else:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "server",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                            remote_ts=server_pet.get("timestamp"),
                        )
                        self.log(
                            f"WSP: server pet has deleted=True for chat {chat_id}, deactivating"
                        )
                        with self.data_lock:
                            self.pet_enabled_chats.discard(chat_id)
                            if chat_id in self.pets:
                                self.markPetDeleted(
                                    self.pets[chat_id],
                                    update_sync_ts=True,
                                )
                                dirty = True
                        markUpdated()
                elif not petEnabled:
                    self.log(
                        f"WSP: found pet on server for inactive chat {chat_id}, auto-enabling"
                    )
                    with self.data_lock:
                        self.pet_enabled_chats.add(chat_id)
                        pet = self.getOrCreatePet(chat_id)
                        pet.apply_sync_data(server_pet, source="server")
                        self.setSyncedHash(
                            chat_id, pet_data=pet.get_sync_data()
                        )
                        dirty = True
                        self.log(
                            f"WSP: pet auto-enabled from server for {chat_id}, xp={server_pet.get('xp')}, stage={server_pet.get('stage')}, name={server_pet.get('name', 'unknown')}"
                        )
                    markUpdated()
                else:
                    with self.data_lock:
                        pet = self.pets.get(chat_id)
                        if not pet:
                            pet = self.getOrCreatePet(chat_id)

                        result = self.mergeRemoteSync(
                            "pet",
                            chat_id,
                            pet,
                            server_pet,
                            "server",
                            update_hash=True,
                        )
                        if result["applied"]:
                            dirty = True
                            self.log(
                                f"WSP: synced pet from server for {chat_id}, xp={server_pet.get('xp')}, stage={server_pet.get('stage')}, name={server_pet.get('name', 'unknown')}"
                            )
                            markUpdated()

            if server_streak:
                with self.data_lock:
                    streakEnabled = chat_id in self.streak_enabled_chats
                if server_streak.get("deleted", False):
                    local_streak = None
                    apply_delete = True
                    with self.data_lock:
                        streakEnabledNow = chat_id in self.streak_enabled_chats
                        streak_key = self.getStreakKey(chat_id)
                        local_streak = self.streaks.get(streak_key)
                        if (
                            streakEnabledNow
                            and local_streak
                            and not local_streak.deleted
                        ):
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_streak, server_streak, "server"
                            )

                    if not apply_delete and local_streak:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "server",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=local_streak.get_sync_data().get("timestamp"),
                            remote_ts=server_streak.get("timestamp"),
                        )
                        self.log(
                            f"WSP: server streak deleted for chat {chat_id}, keeping local and pushing"
                        )
                        self.enqueueChatTask(chat_id, "syncStreak", self.syncStreak, chat_id, local_streak, True)
                        markUpdated()
                    else:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "server",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                            remote_ts=server_streak.get("timestamp"),
                        )
                        self.log(
                            f"WSP: server streak has deleted=True for chat {chat_id}, resetting streak to 0"
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.discard(chat_id)
                            if local_streak:
                                self.markStreakDeleted(
                                    local_streak, update_sync_ts=True
                                )
                                dirty = True
                        markUpdated()
                elif server_streak.get("count", 0) > 0:
                    if not streakEnabled:
                        self.log(
                            f"WSP: found streak on server for inactive chat {chat_id}, auto-enabling"
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)

                    with self.data_lock:
                        streak_key = self.getStreakKey(chat_id)
                        streak = self.streaks.get(streak_key)
                        if not streak:
                            streak = self.getOrCreateStreak(chat_id)

                        if streak:
                            result = self.mergeRemoteSync(
                                "streak",
                                chat_id,
                                streak,
                                server_streak,
                                "server",
                                update_hash=True,
                            )
                            if result["applied"]:
                                dirty = True
                                self.log(
                                    f"WSP: synced streak from server for {chat_id}, count={server_streak.get('count')}"
                                )
                                markUpdated()

            if updated_any:
                with self.data_lock:
                    self.last_auto_sync[chat_id_str] = now
                    self.last_server_check[chat_id] = now
                    self.last_global_server_check = now
            if dirty:
                self.saveSoon()
        except (
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            RuntimeError,
        ) as e:
            self.log(f"WSP: applyServerData error: {e}")

    def checkSyncStatus(self, chat_id):
        try:
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                bulletin_safe("error", tr("–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Sync manager unavailable"))
                return
            my_user_id = V.toInt(
                self.getMyId(acct=self.getAcct(chat_id=chat_id)),
                0,
            )

            lines = [tr("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:", "Sync status:"), ""]
            def add_blank():
                lines.append("")

            syncMode = sync_manager.mode
            mode_name = SYNC_MODE_NAMES.get(syncMode, syncMode)
            lines.append(tr(f"–†–µ–∂–∏–º: {mode_name}", f"Mode: {mode_name}"))

            if my_user_id > 0:
                lines.append(tr(f"ID: {my_user_id}", f"ID: {my_user_id}"))
            else:
                lines.append(
                    tr(
                        f"ID –Ω–µ –ø–æ–ª—É—á–∏–ª–∏ ({my_user_id})",
                        f"ID not available ({my_user_id})",
                    )
                )
                bulletin_safe("error", "\n".join(lines))
                return

            if syncMode in (
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ):
                add_blank()
                lines.append(tr("–°–µ—Ä–≤–µ—Ä: –æ—Å–Ω–æ–≤–Ω–æ–π", "Server: default"))

                is_healthy = sync_manager.checkServerHealth()
                if is_healthy:
                    lines.append(tr("–°–µ—Ä–≤–µ—Ä –æ—Ç–≤–µ—á–∞–µ—Ç", "Server available"))
                else:
                    lines.append(tr("–°–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç", "Server unavailable"))

                add_blank()
                server_streak = None
                try:
                    server_streak = sync_manager.get_streak_from_server(my_user_id, chat_id)
                except (
                    urllib.error.HTTPError,
                    urllib.error.URLError,
                    TimeoutError,
                    OSError,
                    ValueError,
                    TypeError,
                    AttributeError,
                    RuntimeError,
                ) as e:
                    self.log(f"WSP: checkSyncStatus streak fetch error: {e}")
                if server_streak:
                    count = server_streak.get("count", 0)
                    lines.append(
                        tr(
                            f"–°—Ç—Ä–∏–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: {formatDaysRu(count)}",
                            f"Streak on server: {formatDaysEn(count)}",
                        )
                    )
                else:
                    lines.append(tr("–°—Ç—Ä–∏–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: –Ω–µ –Ω–∞–π–¥–µ–Ω", "Streak on server: not found"))

                user1_id, user2_id = self.sortedIdsFast(chat_id, my_user_id)
                server_pet = None
                if user1_id:
                    try:
                        server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)
                    except (
                        urllib.error.HTTPError,
                        urllib.error.URLError,
                        TimeoutError,
                        OSError,
                        ValueError,
                        TypeError,
                        AttributeError,
                        RuntimeError,
                    ) as e:
                        self.log(f"WSP: checkSyncStatus pet fetch error: {e}")
                if server_pet:
                    xp = server_pet.get("xp", 0)
                    stage = server_pet.get("stage", 1)
                    lines.append(tr(f"–ü–∏—Ç–æ–º–µ—Ü –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: —Å—Ç–∞–¥–∏—è {stage}, XP {xp}", f"Pet on server: stage {stage}, XP {xp}"))
                else:
                    lines.append(tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet on server: not found"))

            add_blank()
            lines.append(tr("–õ–æ–∫–∞–ª—å–Ω–æ:", "Local:"))
            with self.data_lock:
                streakEnabled = chat_id in self.streak_enabled_chats
                streak = self.streaks.get(self.getStreakKey(chat_id)) if streakEnabled else None
                pet = self.pets.get(chat_id)

            if streakEnabled:
                if streak:
                    lines.append(
                        tr(
                            f"–°—Ç—Ä–∏–∫: {formatDaysRu(streak.count)}",
                            f"Streak: {formatDaysEn(streak.count)}",
                        )
                    )
                else:
                    lines.append(tr("–°—Ç—Ä–∏–∫ –≤–∫–ª—é—á—ë–Ω, –Ω–æ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç", "Streak: enabled but data missing"))
            else:
                lines.append(tr("–°—Ç—Ä–∏–∫ –≤—ã–∫–ª—é—á–µ–Ω", "Streak: not enabled"))

            if pet:
                lines.append(tr(f"–ü–∏—Ç–æ–º–µ—Ü: —Å—Ç–∞–¥–∏—è {pet.stage}, XP {pet.xp}", f"Pet: stage {pet.stage}, XP {pet.xp}"))
            else:
                lines.append(tr("–ü–∏—Ç–æ–º–µ—Ü –µ—â—ë –Ω–µ —Å–æ–∑–¥–∞–Ω", "Pet: not created"))

            bulletin_safe("info", "\n".join(lines))

        except (
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            RuntimeError,
        ) as e:
            self.log(f"WSP: checkSyncStatus error: {e}")

            self.log(f"WSP: check_sync_status traceback: {traceback.format_exc()}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}", f"Check failed: {e}"))

    def forceSyncNow(self, chat_id):
        if self.ensureAsync(self.forceSyncNow, chat_id):
            return
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"syncNow:{chat_id}", 1.0):
            return
        try:
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if not sync_manager:
                bulletin_safe("error", tr("–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Sync manager unavailable"))
                return
            syncMode = sync_manager.mode

            if syncMode == StreakSyncManager.MODE_P2P:
                bulletin_safe(
                    "info",
                    tr(
                        "–í P2P –Ω–µ—Ç –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
                        "P2P mode doesn't support forced sync",
                    ),
                )
                return
            if syncMode == StreakSyncManager.MODE_LOCAL:
                bulletin_safe(
                    "info",
                    tr(
                        "–í –ª–æ–∫–∞–ª—å–Ω–æ–º —Ä–µ–∂–∏–º–µ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –æ—Ç–∫–ª—é—á–µ–Ω–∞",
                        "Sync is disabled in local mode",
                    ),
                )
                return

            my_user_id = V.toInt(
                self.getMyId(acct=self.getAcct(chat_id=chat_id)),
                0,
            )
            if my_user_id <= 0:
                bulletin_safe("error", tr(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID: {my_user_id}", f"Failed to get ID: {my_user_id}"))
                return

            def do_sync():
                if not sync_manager.checkServerHealth():
                    self.recordSyncStatus(chat_id, "force:server", False, "server_unavailable")
                    run_on_ui_thread(
                        lambda: bulletin_safe("error", tr("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Server unavailable"))
                    )
                    return
                try:
                    synced_items = []
                    statusMode = "force:server"

                    def _append(item):
                        if item:
                            synced_items.append(item)

                    def recordForce(success, reason=None):
                        self.recordSyncStatus(
                            chat_id,
                            statusMode,
                            bool(success),
                            reason if not success else None,
                        )

                    def saveStreakLocal(data, ok_msg_ru, ok_msg_en):
                        success = sync_manager.save_streak_to_server(
                            my_user_id, chat_id, data
                        )
                        recordForce(success, "streak_save_failed")
                        if success:
                            self.setSyncedHash(chat_id, streak_data=data)
                            _append(tr(ok_msg_ru, ok_msg_en))
                        return bool(success)

                    def savePetLocal(user1_id, user2_id, data, ok_msg_ru, ok_msg_en):
                        success = sync_manager.save_pet_to_server(
                            user1_id, user2_id, data
                        )
                        recordForce(success, "pet_save_failed")
                        if success:
                            self.setSyncedHash(chat_id, pet_data=data)
                            _append(tr(ok_msg_ru, ok_msg_en))
                        return bool(success)

                    server_streak = None
                    try:
                        server_streak = sync_manager.get_streak_from_server(
                            my_user_id, chat_id
                        )
                    except (
                        urllib.error.HTTPError,
                        urllib.error.URLError,
                        TimeoutError,
                        OSError,
                        ValueError,
                        TypeError,
                    ) as e:
                        self.log(f"WSP: force sync streak fetch error for {chat_id}: {e}")
                    if server_streak and server_streak.get("count", 0) > 0:
                        with self.data_lock:
                            if chat_id not in self.streak_enabled_chats:
                                self.streak_enabled_chats.add(chat_id)

                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            local_data = streak.get_sync_data()
                            result = self.mergeRemoteSync(
                                "streak",
                                chat_id,
                                streak,
                                server_streak,
                                "server",
                                update_hash=True,
                                ignore_local_priority=True,
                            )
                            if result["applied"]:
                                recordForce(True)
                                _append(
                                    tr(
                                        f"–°—Ç—Ä–∏–∫: {formatDaysRu(server_streak.get('count'))}",
                                        f"Streak: {formatDaysEn(server_streak.get('count'))}",
                                    )
                                )
                            else:
                                saveStreakLocal(
                                    local_data,
                                    f"–°—Ç—Ä–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {formatDaysRu(local_data.get('count'))}",
                                    f"Streak sent to server: {formatDaysEn(local_data.get('count'))}",
                                )
                    else:
                        with self.data_lock:
                            streakEnabled = chat_id in self.streak_enabled_chats
                            streak = self.streaks.get(self.getStreakKey(chat_id))
                        if streakEnabled and streak:
                            local_streak_data = streak.get_sync_data()
                            saveStreakLocal(
                                local_streak_data,
                                f"–°—Ç—Ä–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {formatDaysRu(streak.count)}",
                                f"Streak sent: {formatDaysEn(streak.count)}",
                            )

                    user1_id, user2_id = self.sortedIdsFast(chat_id, my_user_id)
                    if not user1_id:
                        _append(tr("–ü–∏—Ç–æ–º–µ—Ü: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ID", "Pet: failed to resolve ID"))
                    else:
                        server_pet = None
                        try:
                            server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)
                        except (
                            urllib.error.HTTPError,
                            urllib.error.URLError,
                            TimeoutError,
                            OSError,
                            ValueError,
                            TypeError,
                        ) as e:
                            self.log(f"WSP: force sync pet fetch error for {chat_id}: {e}")
                        pet = self.getOrCreatePet(chat_id)
                        if not pet:
                            _append(tr("–ü–∏—Ç–æ–º–µ—Ü: –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã", "Pet: local data unavailable"))
                        elif server_pet:
                            local_pet_data = pet.get_sync_data()
                            result = self.mergeRemoteSync(
                                "pet",
                                chat_id,
                                pet,
                                server_pet,
                                "server",
                                update_hash=True,
                                ignore_local_priority=True,
                            )
                            if result["applied"]:
                                recordForce(True)
                                _append(
                                    tr(
                                        f"–ü–∏—Ç–æ–º–µ—Ü –∑–∞–≥—Ä—É–∂–µ–Ω: —Å—Ç–∞–¥–∏—è {server_pet.get('stage')}, XP {server_pet.get('xp')}",
                                        f"Pet loaded: stage {server_pet.get('stage')}, XP {server_pet.get('xp')}",
                                    )
                                )
                            else:
                                savePetLocal(
                                    user1_id,
                                    user2_id,
                                    local_pet_data,
                                    f"–ü–∏—Ç–æ–º–µ—Ü –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: —Å—Ç–∞–¥–∏—è {local_pet_data.get('stage')}, XP {local_pet_data.get('xp')}",
                                    f"Pet sent: stage {local_pet_data.get('stage')}, XP {local_pet_data.get('xp')}",
                                )
                        else:
                            pet_data = pet.get_sync_data()
                            savePetLocal(
                                user1_id,
                                user2_id,
                                pet_data,
                                f"–ü–∏—Ç–æ–º–µ—Ü –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: —Å—Ç–∞–¥–∏—è {pet.stage}, XP {pet.xp}",
                                f"Pet sent: stage {pet.stage}, XP {pet.xp}",
                            )

                    self.saveData()

                    if synced_items:
                        run_on_ui_thread(
                            lambda: bulletin_safe("success",
                                tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n", "Sync complete.\n")
                                + "\n".join(synced_items)
                            )
                        )
                    else:
                        self.log(f"WSP: force sync finished with no changes for chat {chat_id}")

                except (
                    urllib.error.HTTPError,
                    urllib.error.URLError,
                    TimeoutError,
                    OSError,
                    ValueError,
                    TypeError,
                    AttributeError,
                    RuntimeError,
                ) as e:
                    self.log(f"WSP: force_sync error: {e}")

                    self.log(f"WSP: force_sync traceback: {traceback.format_exc()}")
                    error_msg = str(e)
                    run_on_ui_thread(
                        lambda: bulletin_safe("error",
                            tr(f"–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {error_msg}", f"Sync error: {error_msg}")
                        )
                    )

            self.runAsync(do_sync)

        except (
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            RuntimeError,
        ) as e:
            self.log(f"WSP: forceSyncNow error: {e}")

            self.log(f"WSP: force_sync_now traceback: {traceback.format_exc()}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def checkServer(self):
        try:
            sync_manager = self.getSyncMgr()
            if not sync_manager:
                self.bulletin(
                    "error",
                    tr(
                        "–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω",
                        "Sync manager unavailable",
                    ),
                    ui_thread=True,
                )
                return

            def do_check():
                try:
                    t0 = time.time()
                    mode = SYNC_MODE_NAMES.get(
                        sync_manager.mode, sync_manager.mode
                    )
                    is_healthy = sync_manager.checkServerHealth()
                    rt = time.time() - t0

                    if is_healthy:
                        status = tr("–û–Ω–ª–∞–π–Ω", "Online")
                    else:
                        status = tr("–ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Unavailable")

                    message = (
                        f"{tr('–°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞:', 'Server status:')} {status}\n\n"
                        f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {mode}\n"
                        f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {int(rt * 1000)}ms\n\n"
                        f"{tr('–ö—ç—à:', 'Cache:')} {len(sync_manager.cache)} {tr('–∑–∞–ø–∏—Å–µ–π', 'entries')}"
                    )

                    message += tr("\n–ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —Ç–æ–ª—å–∫–æ —á—Ç–æ", "\nLast check: just now")

                    self.bulletin(
                        "success" if is_healthy else "error",
                        message,
                        ui_thread=True,
                    )

                except (
                    urllib.error.HTTPError,
                    urllib.error.URLError,
                    TimeoutError,
                    OSError,
                    ValueError,
                    TypeError,
                    AttributeError,
                    RuntimeError,
                ) as e:
                    self.log(f"WSP: server health check error: {e}")

                    self.log(f"WSP: health check traceback: {traceback.format_exc()}")
                    self.bulletin(
                        "error",
                        tr(
                            f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞:\n{str(e)}",
                            f"Server check error:\n{str(e)}",
                        ),
                        ui_thread=True,
                    )

            self.runAsync(do_check)

        except (
            urllib.error.HTTPError,
            urllib.error.URLError,
            TimeoutError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            RuntimeError,
        ) as e:
            self.log(f"WSP: checkServer error: {e}")

            self.log(f"WSP: check_server_health traceback: {traceback.format_exc()}")
            self.bulletin("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def saveDataUnsafe(self):
        self.migrateAllPendingStreaks()
        self.cleanupPendingStreaks()
        self.pruneTmpState()
        pets_data = {cid: pet.to_dict() for cid, pet in self.pets.items()}
        streaks_data = {cid: ser.to_dict() for cid, ser in self.streaks.items()}

        errors = []
        saveExc = (OSError, ValueError, TypeError, AttributeError, RuntimeError, KeyError)

        def saveField(key, value=None, action=None, trace=False):
            try:
                if action:
                    action()
                else:
                    self.set_setting(key, value)
            except saveExc as e:
                errors.append(f"{key}: {e}")
                self.log(f"WSP: ERROR saving {key}: {e}")
                if trace:
                    self.log(f"WSP: save {key} traceback: {traceback.format_exc()}")

        saveField("pets", pets_data, trace=True)
        saveField("streaks", streaks_data, trace=True)
        saveField("last_msgs", self.last_messages)
        saveField("streak_enabled", list(self.streak_enabled_chats))
        saveField("pet_enabled", list(self.pet_enabled_chats))
        saveField("pet_revive_times", self.pet_revive_times)
        saveField("minigame_combo", self.minigame_combo)

        positions_to_remove = []
        for pos_key in self.widget_positions.keys():
            if pos_key.startswith("streak_") or pos_key not in self.pets:
                positions_to_remove.append(pos_key)

        for pos_key in positions_to_remove:
            del self.widget_positions[pos_key]
            self.log(f"WSP: removed widget position for inactive chat {pos_key}")

        saveField("widget_positions", self.widget_positions)
        def saveP2p():
            if not self._setSecretSettingDict("p2pkeys", self.p2pKeys):
                raise RuntimeError("secure_store_failed")
        saveField("p2pkeys", action=saveP2p)

        if errors:
            self.log(f"WSP: data save FAILED with {len(errors)} errors: {errors}")
            return False
        else:
            return True

    def collectKnownIds(self):
        known = set()
        try:
            known.update(str(cid) for cid in self.pets.keys())
            known.update(str(cid) for cid in self.pet_enabled_chats)
            known.update(str(cid) for cid in self.streak_enabled_chats)
            known.update(str(cid) for cid in self.active_widgets.keys())
        except (TypeError, ValueError, AttributeError, RuntimeError) as e:
            self.log(f"WSP: collectKnownIds primary scan error: {e}")
        try:
            for streak in self.streaks.values():
                cid = getattr(streak, "chat_id", None)
                if cid is not None:
                    known.add(str(cid))
        except (TypeError, ValueError, AttributeError, RuntimeError) as e:
            self.log(f"WSP: collectKnownIds streak scan error: {e}")
        return known

    def pruneTmpMap(self, dataMap, knownIds=None, maxSize=None):
        try:
            if knownIds:
                for key in list(dataMap.keys()):
                    normKey = self.normTmpKey(key)
                    if normKey not in knownIds:
                        dataMap.pop(key, None)
            limit = self.maxTmp if maxSize is None else maxSize
            if limit and len(dataMap) > limit:
                items = list(dataMap.items())
                items.sort(key=lambda kv: self.transientTs(kv[1]))
                for key, _ in items[: len(items) - limit]:
                    dataMap.pop(key, None)
        except (TypeError, ValueError, AttributeError, RuntimeError) as e:
            self.log(f"WSP: pruneTmpMap error: {e}")

    def transientTs(self, value):
        try:
            if isinstance(value, dict):
                ts = value.get("ts")
                if ts is None:
                    ts = value.get("timestamp")
                return float(ts or 0)
            if isinstance(value, (int, float)):
                return float(value)
            if isinstance(value, list) and value:
                last = value[-1]
                if isinstance(last, (int, float)):
                    return float(last)
            return 0
        except (TypeError, ValueError):
            return 0

    def normTmpKey(self, key):
        try:
            s = str(key)
            if s.startswith("pet_"):
                return s[4:]
            if s.startswith("streak_"):
                return s[7:]
            return s
        except (TypeError, ValueError):
            return str(key)

    def iterTmpMaps(self):
        return (
            self.last_messages,
            self.recent_messages,
            self.xp_history,
            self.last_xp_time,
            self.last_auto_sync,
            self.last_server_check,
            self.autoSrvPause,
            self.autoSrvFail,
            self.last_p2p_sync,
            self.last_pet_sync,
            self.last_streak_sync,
            self.minigame_combo,
            self.pet_revive_times,
            self._p2p_offer_last,
            self._last_synced_streak_hash,
            self._last_synced_pet_hash,
            self.last_sync_status,
            self.lastSyncOk,
            self.lastSentStreak,
            self.lastSentPet,
            self.last_flame_time,
            self._flame_retry,
            self.flamePending,
        )

    def pruneTmpState(self):
        knownIds = self.collectKnownIds()
        for dataMap in self.iterTmpMaps():
            self.pruneTmpMap(dataMap, knownIds)
        self.pruneTmpMap(self.chatAccts, knownIds, maxSize=self.maxChatAccts)
        self.pruneTmpMap(self.p2pKeys, knownIds, maxSize=self.maxP2pKeys)
        self.pruneTmpMap(self.widget_positions, knownIds, maxSize=self.maxWidgetPos)
        try:
            with self.data_lock:
                self.trimActionGuardLocked(time.time())
                self.trimChatAllowLocked(time.time())
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: pruneTmpState actionGuard cleanup error: {e}")

    def recordSyncStatus(self, chat_id, mode, success, reason=None):
        try:
            if not chat_id:
                return
            chat_key = self.normChat(chat_id)
            reasonKey = (
                str(reason or "")
                .strip()
                .lower()
                .replace("-", "_")
                .replace(" ", "_")
            )
            status = {
                "ts": time.time(),
                "mode": mode,
                "ok": bool(success),
                "reason": reasonKey,
            }
            with self.data_lock:
                self.last_sync_status[chat_key] = status
                if success:
                    self.lastSyncOk[chat_key] = status["ts"]
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError) as e:
            self.log(f"WSP: recordSyncStatus error for chat={chat_id}: {e}")

    def formatSyncStatus(self, chat_id):
        try:
            if not self.get_setting("show_last_sync_status", True):
                return ""
            chat_id = self.normChat(chat_id)
            with self.data_lock:
                data = self.last_sync_status.get(chat_id)
            if not data:
                return tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –µ—â—ë –Ω–µ –±—ã–ª–æ", "No sync yet")
            ts = data.get("ts", 0)
            if not ts:
                return tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –µ—â—ë –Ω–µ –±—ã–ª–æ", "No sync yet")
            minutes = int(max(0, time.time() - ts) // 60)
            if minutes < 1:
                when = tr("—Ç–æ–ª—å–∫–æ —á—Ç–æ", "just now")
            elif minutes < 60:
                when = tr(f"{minutes} –º–∏–Ω –Ω–∞–∑–∞–¥", f"{minutes}m ago")
            else:
                hours = minutes // 60
                when = tr(f"{hours} —á –Ω–∞–∑–∞–¥", f"{hours}h ago")
            mode = data.get("mode", "")
            ok = data.get("ok", False)
            reason = data.get("reason", "")
            reasons = {
                "server_unavailable": tr("–°–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç", "Server unavailable"),
                "network": tr("–ü—Ä–æ–±–ª–µ–º—ã —Å —Å–µ—Ç—å—é", "Network error"),
                "auth_failed": tr("–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å –≤–æ–π—Ç–∏", "Sign-in failed"),
                "auth_wait": tr("–ù–µ–º–Ω–æ–≥–æ –ø–æ–¥–æ–∂–¥–∏", "Please wait"),
                "db_busy": tr("–°–µ—Ä–≤–µ—Ä –∑–∞–Ω—è—Ç", "Server busy"),
                "server_error": tr("–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É", "Server error"),
                "bad_request": tr("–ù–µ–≤–µ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å", "Bad request"),
                "auth_backend_unavailable": tr("–°–µ—Ä–≤–∏—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Auth service unavailable"),
                "missing install id": tr("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ", "Device not recognized"),
                "missing_install_id": tr("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–æ", "Device not recognized"),
                "invalid install id": tr("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "Device not verified"),
                "invalid_install_id": tr("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ", "Device not verified"),
                "missing dev key": tr("–ù–µ—Ç –∫–ª—é—á–∞ –¥–æ—Å—Ç—É–ø–∞", "Missing access key"),
                "missing_dev_key": tr("–ù–µ—Ç –∫–ª—é—á–∞ –¥–æ—Å—Ç—É–ø–∞", "Missing access key"),
                "invalid dev key": tr("–ö–ª—é—á –¥–æ—Å—Ç—É–ø–∞ —É—Å—Ç–∞—Ä–µ–ª", "Access key is outdated"),
                "invalid_dev_key": tr("–ö–ª—é—á –¥–æ—Å—Ç—É–ø–∞ —É—Å—Ç–∞—Ä–µ–ª", "Access key is outdated"),
                "missing_devkey": tr("–ù–µ—Ç –∫–ª—é—á–∞ –¥–æ—Å—Ç—É–ø–∞", "Missing access key"),
                "missing_install_secret": tr("–ù—É–∂–Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è", "Re-auth required"),
                "invalid_install_secret": tr("–ù—É–∂–Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è", "Re-auth required"),
                "missing req sig": tr("–ó–∞–ø—Ä–æ—Å –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω", "Request not verified"),
                "bad sig": tr("–ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω—ë–Ω", "Request rejected"),
                "bad ts": tr("–ù–µ–≤–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ", "Device time is wrong"),
                "p2p_no_key": tr("–ù–µ—Ç –∫–ª—é—á–∞ –¥–ª—è P2P", "No key for P2P"),
                "throttled": tr("–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ", "Throttled"),
                "rate_limited": tr("–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤", "Too many requests"),
                "token_revoked": tr("–¢–æ–∫–µ–Ω –±–æ–ª—å—à–µ –Ω–µ –¥–µ–π—Å—Ç–≤—É–µ—Ç", "Token revoked"),
                "install_revoked": tr("–î–æ—Å—Ç—É–ø –æ—Ç–∫–ª—é—á—ë–Ω", "Access revoked"),
                "install_reauth_required": tr("–ù—É–∂–Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è", "Re-auth required"),
                "project_mismatch": tr("–ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–µ–∫—Ç —Å–µ—Ä–≤–µ—Ä–∞", "Wrong server project"),
                "insecure_transport": tr("–ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ", "Insecure connection"),
                "untrusted_host": tr("–ù–µ–¥–æ–≤–µ—Ä–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–µ—Ä", "Untrusted server"),
                "untrusted_port": tr("–ù–µ–¥–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –ø–æ—Ä—Ç", "Untrusted port"),
                "malformed_url": tr("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞", "Bad server URL"),
                "streak_save_failed": tr("–°—Ç—Ä–∏–∫ –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª—Å—è", "Streak save failed"),
                "pet_save_failed": tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏–ª—Å—è", "Pet save failed"),
                "batch_failed": tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–æ—Ä–≤–∞–ª–∞—Å—å", "Sync failed"),
                "invalid_user_id": tr("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID", "Couldn‚Äôt get ID"),
                "client_guard": tr("–ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å", "Suspicious activity"),
            }
            hints = {
                "server_unavailable": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å —Å–µ—Ç—å/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: check network/proxy or try later",
                ),
                "network": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å —Å–µ—Ç—å/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: check network/proxy or try later",
                ),
                "auth_backend_unavailable": tr(
                    "–°–æ–≤–µ—Ç: —Å–µ—Ä–≤–∏—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.",
                    "Tip: auth service is temporarily unavailable, try later.",
                ),
                "missing install id": tr(
                    "–°–æ–≤–µ—Ç: –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å VPN/–ø—Ä–æ–∫—Å–∏, –ø–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏ –µ–≥–æ.",
                    "Tip: if you use VPN/proxy, try another mode or turn it off.",
                ),
                "missing_install_id": tr(
                    "–°–æ–≤–µ—Ç: –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å VPN/–ø—Ä–æ–∫—Å–∏, –ø–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏ –µ–≥–æ.",
                    "Tip: if you use VPN/proxy, try another mode or turn it off.",
                ),
                "invalid install id": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–ø—Ä–æ–±—É–π –æ—Ç–∫–ª—é—á–∏—Ç—å VPN/–ø—Ä–æ–∫—Å–∏ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å.",
                    "Tip: try without VPN/proxy and retry.",
                ),
                "invalid_install_id": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–ø—Ä–æ–±—É–π –æ—Ç–∫–ª—é—á–∏—Ç—å VPN/–ø—Ä–æ–∫—Å–∏ –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å.",
                    "Tip: try without VPN/proxy and retry.",
                ),
                "missing dev key": tr(
                    "–°–æ–≤–µ—Ç: –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–æ–≤–∏ –ø–ª–∞–≥–∏–Ω –∏–ª–∏ —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é.",
                    "Tip: reinstall the plugin or reset auth.",
                ),
                "missing_dev_key": tr(
                    "–°–æ–≤–µ—Ç: –ø–ª–∞–≥–∏–Ω —Å–æ–∑–¥–∞—Å—Ç –Ω–æ–≤—ã–π –∫–ª—é—á –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏. –ï—Å–ª–∏ –Ω–µ –ø–æ–º–æ–∂–µ—Ç, —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é.",
                    "Tip: plugin will recreate key automatically. If it fails, reset auth.",
                ),
                "invalid dev key": tr(
                    "–°–æ–≤–µ—Ç: –∫–ª—é—á —É—Å—Ç–∞—Ä–µ–ª. –ü–ª–∞–≥–∏–Ω –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
                    "Tip: key is outdated. Plugin will auto re-auth.",
                ),
                "invalid_dev_key": tr(
                    "–°–æ–≤–µ—Ç: –∫–ª—é—á —É—Å—Ç–∞—Ä–µ–ª. –ü–ª–∞–≥–∏–Ω –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
                    "Tip: key is outdated. Plugin will auto re-auth.",
                ),
                "missing_devkey": tr(
                    "–°–æ–≤–µ—Ç: –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–æ–≤–∏ –ø–ª–∞–≥–∏–Ω –∏–ª–∏ —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é.",
                    "Tip: reinstall the plugin or reset auth.",
                ),
                "missing_install_secret": tr(
                    "–°–æ–≤–µ—Ç: –ø–ª–∞–≥–∏–Ω —Å–∞–º –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é. –ï—Å–ª–∏ –Ω–µ –ø–æ–º–æ–∂–µ—Ç, –Ω–∞–∂–º–∏ ¬´–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é¬ª.",
                    "Tip: plugin will try auto re-auth. If it still fails, tap ‚ÄúReset auth‚Äù.",
                ),
                "invalid_install_secret": tr(
                    "–°–æ–≤–µ—Ç: –ø–ª–∞–≥–∏–Ω —Å–∞–º –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é. –ï—Å–ª–∏ –Ω–µ –ø–æ–º–æ–∂–µ—Ç, –Ω–∞–∂–º–∏ ¬´–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é¬ª.",
                    "Tip: plugin will try auto re-auth. If it still fails, tap ‚ÄúReset auth‚Äù.",
                ),
                "missing req sig": tr(
                    "–°–æ–≤–µ—Ç: VPN/–ø—Ä–æ–∫—Å–∏ –º–æ–∂–µ—Ç –ª–æ–º–∞—Ç—å –∑–∞–ø—Ä–æ—Å—ã. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.",
                    "Tip: VPN/proxy may break requests. Try another mode.",
                ),
                "bad sig": tr(
                    "–°–æ–≤–µ—Ç: VPN/–ø—Ä–æ–∫—Å–∏ –º–æ–≥ –∏—Å–∫–∞–∑–∏—Ç—å –∑–∞–ø—Ä–æ—Å. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.",
                    "Tip: VPN/proxy may have altered the request. Try another mode.",
                ),
                "bad ts": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å –≤—Ä–µ–º—è –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ.",
                    "Tip: check your device time.",
                ),
                "p2p_no_key": tr(
                    "–°–æ–≤–µ—Ç: —Å–Ω–∞—á–∞–ª–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–π—Å—è —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä.",
                    "Tip: sync via server first.",
                ),
                "rate_limited": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–¥–æ–∂–¥–∏ 30-60 —Å–µ–∫",
                    "Tip: wait 30-60s",
                ),
                "auth_wait": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É –º–∏–Ω—É—Ç",
                    "Tip: wait a couple minutes",
                ),
                "auth_failed": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–ø—Ä–æ–±—É–π —Å–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö.",
                    "Tip: try resetting auth in settings.",
                ),
                "token_revoked": tr(
                    "–°–æ–≤–µ—Ç: —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∏ –ø–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.",
                    "Tip: reset auth and try again.",
                ),
                "install_revoked": tr(
                    "–°–æ–≤–µ—Ç: –¥–æ—Å—Ç—É–ø –æ—Ç–∫–ª—é—á—ë–Ω. –ù–∞–ø–∏—à–∏ –∞–≤—Ç–æ—Ä—É.",
                    "Tip: access revoked. Contact the author.",
                ),
                "install_reauth_required": tr(
                    "–°–æ–≤–µ—Ç: —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ø–ª–∞–≥–∏–Ω–∞ –∏ –≤–æ–π–¥–∏ –∑–∞–Ω–æ–≤–æ.",
                    "Tip: reset plugin auth and sign in again.",
                ),
                "project_mismatch": tr(
                    "–°–æ–≤–µ—Ç: —É —Å–µ—Ä–≤–µ—Ä–∞ –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –ø—Ä–∏–≤—è–∑–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞. –ü–ª–∞–≥–∏–Ω –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞.",
                    "Tip: server project binding changed. Plugin will recreate install identity.",
                ),
                "insecure_transport": tr(
                    "–°–æ–≤–µ—Ç: –ø–ª–∞–≥–∏–Ω –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–æ–ª—å–∫–æ HTTPS –∏ –¥–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –¥–æ–º–µ–Ω.",
                    "Tip: plugin accepts only HTTPS and trusted host.",
                ),
                "untrusted_host": tr(
                    "–°–æ–≤–µ—Ç: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–¥–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –¥–æ–º–µ–Ω —Å–µ—Ä–≤–µ—Ä–∞.",
                    "Tip: an untrusted server host was used.",
                ),
                "untrusted_port": tr(
                    "–°–æ–≤–µ—Ç: –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–¥–æ–≤–µ—Ä–µ–Ω–Ω—ã–π –ø–æ—Ä—Ç —Å–µ—Ä–≤–µ—Ä–∞.",
                    "Tip: an untrusted server port was used.",
                ),
                "malformed_url": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ –≤ –ø–ª–∞–≥–∏–Ω–µ.",
                    "Tip: check the server URL built into the plugin.",
                ),
                "server_error": tr(
                    "–°–æ–≤–µ—Ç: —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω, –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: server busy, try later",
                ),
                "db_busy": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ –ø–∞—Ä—É –º–∏–Ω—É—Ç",
                    "Tip: try again in a few minutes",
                ),
                "bad_request": tr(
                    "–°–æ–≤–µ—Ç: –æ–±–Ω–æ–≤–∏ –ø–ª–∞–≥–∏–Ω –¥–æ —Å–≤–µ–∂–µ–π –≤–µ—Ä—Å–∏–∏",
                    "Tip: update the plugin",
                ),
                "client_guard": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å –≤—Ä–µ–º—è –∏ –∏–∑–±–µ–≥–∞–π —Ä–µ–∑–∫–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π",
                    "Tip: check time and avoid big jumps",
                ),
            }
            label = tr("–£—Å–ø–µ—à–Ω–æ", "OK") if ok else tr("–û—à–∏–±–∫–∞", "Failed")
            modeTag = ""
            if mode.startswith("remote:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            elif mode.startswith("send:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            elif mode.startswith("force:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            lines = [
                f"{tr('–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è:', 'Last sync:')} {when} - {label} {modeTag}".strip()
            ]
            if not ok and reason:
                why = reasons.get(reason, reason)
                lines.append(tr(f"–ü—Ä–∏—á–∏–Ω–∞: {why}", f"Reason: {why}"))
                hint = hints.get(reason)
                if hint:
                    lines.append(hint)
            if not ok:
                ok_ts = self.lastSyncOk.get(chat_id)
                if ok_ts:
                    ok_min = int(max(0, time.time() - ok_ts) // 60)
                    if ok_min < 1:
                        ok_part = tr("—Ç–æ–ª—å–∫–æ —á—Ç–æ", "just now")
                    elif ok_min < 60:
                        ok_part = tr(f"{ok_min} –º–∏–Ω –Ω–∞–∑–∞–¥", f"{ok_min}m ago")
                    else:
                        ok_hours = ok_min // 60
                        ok_part = tr(f"{ok_hours} —á –Ω–∞–∑–∞–¥", f"{ok_hours}h ago")
                    lines.append(
                        tr(f"–ü–æ—Å–ª–µ–¥–Ω—è—è —É—Å–ø–µ—à–Ω–∞—è: {ok_part}", f"Last OK: {ok_part}")
                    )
            return "\n".join(lines)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return ""

    def saveData(self):
        with self.data_lock:
            self.saveDataUnsafe()

    def refreshPetWidget(self, chat_id):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            widget = self.active_widgets.get(chat_id)
        if not widget:
            return False

        def doRefresh():
            try:
                widget._last_accessory = None
                widget._update_visual()
            except (AttributeError, RuntimeError, TypeError, ValueError, OSError) as e:
                self.log(f"WSP: refreshPetWidget error for {chat_id}: {e}")

        self.runUiOnce(f"widgetRefresh:{chat_id}", 90, doRefresh)
        return True

    def queueFlame(self, chatId, xpAmount):
        try:
            chatId = self.normChat(chatId)
            xp = int(xpAmount or 0)
            if xp <= 0:
                return
            with self.data_lock:
                self.flamePending[chatId] = self.flamePending.get(chatId, 0) + xp

            def fire():
                with self.data_lock:
                    totalXp = int(self.flamePending.pop(chatId, 0) or 0)
                if totalXp > 0:
                    self.createFlameParticle(chatId, totalXp)

            self.runUiOnce(f"flame:{chatId}", 80, fire)
        except (TypeError, ValueError, AttributeError, RuntimeError, OSError):
            return

    def createFlameParticle(self, chat_id, xp_amount):
        try:
            try:
                if xp_amount is None or int(xp_amount) <= 0:
                    return
            except (TypeError, ValueError):
                return
            chat_id = self.normChat(chat_id)
            now = time.time()
            with self.data_lock:
                last = self.last_flame_time.get(chat_id, 0)
                if now - last < 2.2:
                    return
                self.last_flame_time[chat_id] = now
            with self.data_lock:
                if chat_id not in self.active_widgets:
                    return
                widget = self.active_widgets[chat_id]

            widget_view = widget.get_view()

            parent = widget_view.getParent()
            if not parent:
                return
            parent_width = parent.getWidth() if parent else 0
            parent_height = parent.getHeight() if parent else 0
            if parent_width <= 0 or parent_height <= 0:
                try:
                    parent_width = parent.getMeasuredWidth()
                    parent_height = parent.getMeasuredHeight()
                except (AttributeError, TypeError, ValueError, RuntimeError):
                    parent_width = 0
                    parent_height = 0
            if parent_width <= 0 or parent_height <= 0:
                retries = int(self._flame_retry.get(chat_id, 0) or 0)
                if retries < 2:
                    self._flame_retry[chat_id] = retries + 1
                    run_on_ui_thread(
                        lambda: self.createFlameParticle(chat_id, xp_amount),
                        80,
                    )
                return
            self._flame_retry.pop(chat_id, None)

            widget_x = widget_view.getX() + widget_view.getWidth() / 2
            widget_y = widget_view.getY() + widget_view.getHeight() / 2

            start_x = AndroidUtilities.dp(Dp.S20)
            start_y = parent_height - AndroidUtilities.dp(Dp.S100)
            if start_y < 0:
                start_y = max(0, parent_height - AndroidUtilities.dp(Dp.S40))

            flame = FlyingXPParticle(
                widget_view.getContext(),
                start_x,
                start_y,
                widget_x,
                widget_y,
                xp_amount,
                lambda: self.removeFlameParticle(parent, flame),
            )

            flame_view = flame.get_view()
            parent.addView(flame_view)

        except (AttributeError, RuntimeError, TypeError, ValueError, OSError) as e:
            self.log(f"WSP flame error: {e}")

    def removeFlameParticle(self, parent, flame):
        try:
            view = None
            try:
                view = flame.get_view()
            except (AttributeError, RuntimeError, TypeError, ValueError):
                view = None
            if view:
                parent.removeView(view)
            if hasattr(flame, "cleanup"):
                flame.cleanup()
        except (AttributeError, RuntimeError, TypeError, ValueError, OSError):
            pass

    def loadData(self):
        self.log("WSP: loading data from settings...")

        pets_raw = self.get_setting("pets", {})
        streaks_raw = self.get_setting("streaks", {})
        pets_data = pets_raw if V.is_dict(pets_raw) else {}
        streaks_data = streaks_raw if V.is_dict(streaks_raw) else {}

        last_msgs_raw = self.get_setting("last_msgs", {})
        self.last_messages = last_msgs_raw if V.is_dict(last_msgs_raw) else {}

        streak_enabled_raw = self.get_setting("streak_enabled", [])
        streak_enabled_list = streak_enabled_raw if V.is_list(streak_enabled_raw) else []
        if not streak_enabled_list and streaks_data:
            streak_enabled_list = [
                k for k, v in streaks_data.items()
                if V.is_dict(v) and not v.get("deleted")
            ]
        self.streak_enabled_chats = set(str(x) for x in streak_enabled_list if x)

        pet_enabled_raw = self.get_setting("pet_enabled", [])
        pet_enabled_list = pet_enabled_raw if V.is_list(pet_enabled_raw) else []
        if not pet_enabled_list and pets_data:
            pet_enabled_list = [
                k for k, v in pets_data.items()
                if V.is_dict(v) and not v.get("deleted")
            ]
        self.pet_enabled_chats = set(str(x) for x in pet_enabled_list if x)

        revive_raw = self.get_setting("pet_revive_times", {})
        revive_data = revive_raw if V.is_dict(revive_raw) else {}
        self.pet_revive_times = {
            str(k): V.ts(v, 0) for k, v in revive_data.items() if k
        }
        combo_raw = self.get_setting("minigame_combo", {})
        combo_data = combo_raw if V.is_dict(combo_raw) else {}
        try:
            self.minigame_combo = {
                str(k): V.int_range(v, 0, 9999, 0) for k, v in combo_data.items() if k
            }
        except (TypeError, ValueError, AttributeError):
            self.minigame_combo = {}

        self.log(f"WSP: raw {len(pets_data)} pets, {len(streaks_data)} streaks")

        skipped_pets = 0
        for chat_id, data in pets_data.items():
            try:
                validated = V.pet_data(data)
                if not validated:
                    self.log(f"WSP: invalid pet data for {chat_id}, skipping")
                    skipped_pets += 1
                    continue
                if validated.get("deleted", False):
                    continue
                self.pets[chat_id] = Pet.from_dict(validated, plugin_ref=self)
            except (TypeError, ValueError, KeyError, AttributeError, RuntimeError) as e:
                self.log(f"WSP: ERROR loading pet {chat_id}: {e}")
                skipped_pets += 1

        skipped_streaks = 0
        for chat_id, data in streaks_data.items():
            try:
                validated = V.streak_data(data)
                if not validated:
                    self.log(f"WSP: invalid streak data for {chat_id}, skipping")
                    skipped_streaks += 1
                    continue
                if validated.get("deleted", False):
                    continue
                self.streaks[chat_id] = Streak.from_dict(validated, plugin_ref=self)
            except (TypeError, ValueError, KeyError, AttributeError, RuntimeError) as e:
                self.log(f"WSP: ERROR loading streak {chat_id}: {e}")
                skipped_streaks += 1

        if skipped_pets > 0 or skipped_streaks > 0:
            self.log(f"WSP: skipped {skipped_pets} pets, {skipped_streaks} streaks due to validation")

        positions_raw = self.get_setting("widget_positions", {})
        self.widget_positions = positions_raw if V.is_dict(positions_raw) else {}

        self.p2pKeys = self._getSecretSettingDict("p2pkeys")

        self.pruneTmpState()

        self.log(f"WSP: loaded {len(self.pets)} pets, {len(self.streaks)} streaks, {len(self.widget_positions)} positions")
