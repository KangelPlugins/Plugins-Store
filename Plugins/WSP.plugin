"""‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚£§‚£∂‚£æ‚£ø‚£Ω‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£Ä‚£¥‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¢‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚£Ä‚£Ä‚†Ä‚£Ä‚£Ä‚°¥‚£Ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£µ‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£û‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ω‚£§‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†ë‚£¶‚£§‚¢§‚°§‚£§‚¢∂‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ª‚°í‚†í‚†í‚†à‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ª‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†â‚¢õ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Å‚£¥
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£§‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚°ü‚£ø‚£õ‚£ø‚£Ω‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚°∑‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚£†
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£æ‚°ø‚£ø‚£õ‚°ü‚£ø‚£ª‚¢ª‚£ü‚°ª‚£ü‚£ª‚£õ‚£ü‚£ª‚£õ‚£ü‚£ª‚£õ‚¢Ø‚¢ø‚°π‚£è‚¢ø‚°π‚¢Ø‚£Ω‚¢ø‚£ø‚££‚¢ü‚°º‚£ü‚£Æ‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ω‚£≤‚£§‚£§‚†î‚°†‚†Ç‚£¨
‚†Ä‚††‚†§‚†¥‚†∂‚†ü‚†ã‚£Ω‚£≥‚†ø‚£º‚£π‚£Ø‚¢≥‚¢Ø‚£ú‚°≥‚£ù‚¢∂‚°π‚¢Æ‚°µ‚£´‚°ú‚£ß‚£õ‚¢Æ‚°≥‚£ù‚£Æ‚£≥‚£Ω‚£ß‚£ø‚¢á‚£ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£è‚†â‚†â‚†Å‚†Ä‚†Ä‚†£‚°ò‚£Å
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£æ‚£ø‚£ø‚£ø‚£∑‚£æ‚£∑‚£ø‚£æ‚£æ‚£∑‚£ø‚£æ‚£ø‚£∑‚£ø‚£∑‚£ø‚£∂‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†¥‚†¨‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£§‚°Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä
‚†Ä‚†Ä‚¢Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†°‚°â‚†Ü‚£Ø‚¢ª‚£ø‚£ø‚¢©‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚°∂‚†ñ‚†Å
‚†à‚†ö‚†õ‚†õ‚†õ‚†õ‚†ã‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†è‚††‚¢Å‚†Ç‚£Ω‚†à‚¢ø‚£ø‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†õ‚†õ‚†õ‚†õ‚†ã‚†â‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ø‚†Ω‚†ü‚†í‚†ö‚°ó‚£Ä‚£∏‚£è‚£Ä‚£Ñ‚£ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ü‚£∂‚†∂‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°è‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†ê‚¢©
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†â‚¢†‚†Ñ‚†∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ß‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ü‚†Ä‚†Ä‚†Ä‚¢®‚†∞‚†∂‚¢æ
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚¢º‚£ø‚†Å‚†Ä‚†ò‚°Ü‚†Ä‚¢ø‚°ü‚£ø‚£ø‚£ø‚°Ø‚¢ô‚°É‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ω‚°ï‚¢Ñ‚†Ä‚°∞‚¢Ä‚£¥‚¢ü
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†±‚†Ä‚†à‚¢ø‚£ç‚†õ‚†â‚£≥‚°ü‚¢Å‚£û‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ñ‚†ò‚¢ß‚°ª‚¢∑‚£ª
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ø‚£ø‚£ø‚°è‚†Ä‚¢∏‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£Å‚°Ä‚†Ä‚†â‚†ø‚†ø‚¢â‚£∞‚°é‚¢á‚£∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚£ø‚£ø‚£ø‚¢∑‚°Ä‚†π‚†á‚†Ü
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ü‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°è‚†ò‚£ø‚£ø‚£∑‚†Ä‚†Ä‚†É‚†Ä‚†Ä‚†Ä‚†í‚¢Ñ‚£∫‚†ç‚£â‚£ä‚£ô‚£õ‚°≠‚†ã‚†â‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†ô‚†ª‚†ø‚¢Ø‚£∑‚£§‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢á‚°¥‚¢ª‚°ü‚†â‚†Ä‚£¶‚†Ä‚†Ä‚†Ä‚††‚†î‚¢ì‚¢ë‚¢Ω‚¢õ‚¢≠‚¢è‚¢ù‚†∂‚†Å‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£å‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†à‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ü‚£¶‚£§‚£Ä‚†Ä‚¢†‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ª‚†Ä‚†Ä‚†Ä‚°§‚¢¶‚†§‚£§‚°§‚¢Ñ‚†§‚£§‚°¥‚†û‚†©‚¢∂‚†è‚†Ä‚†Ä‚£†‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ç‚†Å‚†ò‚†Å
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°ê‚†Å‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£Ü‚£Ä‚†Ä‚†ô‚†•‚¢å‚£Ä‚£â‚£â‚£â‚£Å‚°†‚†§‚†ö‚†Å‚£†‚°∂‚°û‚°ü‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£¶‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†Å‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†ø‚†õ‚†í‚°¢‚†§‚¢Ñ‚£Ä‚°Ä‚†Ä‚¢Ä‚£†‚†§‚†í‚†ã‚†Å‚£†‚†è‚†Ä‚°ø‚¢∏‚£ø‚£ø‚£ø‚°ü‚¢Å‚†á‚†Ä‚†Ä‚†â‚†à‚†ô‚¢ø‚£ø‚£ø‚£ø‚£ø‚°â‚†õ‚†ø‚¢ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚°æ‚†ü‚†Å‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†§‚°Ä‚†Ä‚¢á‚†Ä‚†Ä‚£≥‚†à‚†â‚†Å‚†Ä‚†Ä‚£Ä‚†¥‚†Æ‚£Ä‚°Ä‚¢Ä‚°á‚¢∏‚†è‚†Ä‚¢π‚†ñ‚¢Å‚£†‚†§‚†Ç‚†Ä‚†Ä‚†Ä‚†à‚¢ª‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚£Ä‚†î‚†ö‚†â‚†Ä‚†Ä‚¢Ä‚£ø‚£ø‚£ø‚£ø‚†ü‚°ü‚¢ª‚£ø‚£ø‚°á‚†Ä‚†Ä‚°á‚¢£‚†Ä‚†ò‚£Ü‚†ú‚¢π‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£∑‚¢≤‚°Ñ‚†Ä‚†à‚¢π‚†ã‚°ç‚¢Ä‚£Ä‚†Ä‚°∑‚†õ‚†Ä‚£Ä‚£Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£Ω‚°Ä‚†Ä
‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢à‚£ø‚£ø‚£ø‚†É‚¢∞‚°á‚†ò‚£ø‚£ø‚£ß‚°∏‚°º‚¢Ä‚£®‚£ß‚£†‚†ã‚†Ä‚†ë‚†¶‚†¥‚†ä‚¢â‚£Ä‚¢ª‚†ò‚£∑‚†Ä‚†Ä‚¢∏‚¢ò‚¢†‚†É‚†Ä‚°á‚°ó‚¢à‚£Å‚††‚†§‚†§‚¢Ñ‚°Å‚†¢‚°Ä‚†∏‚£ø‚°ø‚£ø‚£ø‚¢ß‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£è‚†É‚†Ä‚°å‚°á‚†Ä‚†π‚£ø‚£ø‚£ß‚†¥‚†ã‚£ø‚°ø‚°è‚†â‚†ì‚†Ü‚†Ä‚†Ä‚†ñ‚†â‚¢†‚†∫‚£º‚£ø‚£Ü‚†Ä‚¢†‚†á‚¢ú‚†Ä‚†Ä‚°á‚°Ø‚†ï‚†Ç‚†â‚†â‚†â‚†¢‚°ú‚¢¢‚°ú‚†Ü‚£ø‚£ø‚†à‚£ø‚£ø‚°Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ø‚†ã‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚¢Ä‚†π‚£ø‚°∑‚°Ä‚†Ä‚£ø‚†Å‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚††‚¢É‚°æ‚£ø‚¢ü‚°ø‚¢¶‚†É‚†Ä‚†∏‚†Ä‚°∏‚¢Ä‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚¢Ü‚£ø‚°ê‚£ø‚£ø‚†Ä‚†ò‚£∑‚°á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚†î‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚¢°‚£†‚°é‚†Ä‚†ô‚£∑‚†ë‚†Ñ‚¢£‚°Ä‚¢á‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†Å‚£†‚£ø‚°ø‚¢ã‚†û‚†Å‚†Ä‚†Ä‚¢∏‚†Ä‚†ì‚†É‚¢∏‚†Ä‚°†‚†î‚†í‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢ò‚¢æ‚†π‚£π‚£ø‚†Ä‚†Ä‚†∏‚°á
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†é‚†Ä‚¢∞‚†Ä‚†Ä‚†Ä‚†Ä‚£∏‚¢±‚†Ä‚†Ä‚†Ä‚†à‚¢ß‚†Ä‚¢π‚£∑‚°∏‚£Ü‚†Ä‚¢∞‚†Å‚¢Ä‚£æ‚£Ω‚†ü‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†á‚†Ä‚†Ä‚†∏‚£Ö‚°Ä‚†Ä‚†Ä‚†Ä‚°ë‚†í‚¢Ñ‚†å‚£∏‚†Ä‚£ø‚°á‚†Ä‚†Ä‚†Ä‚£ø
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°†‚†ã‚†Ä‚†Ä‚†Ä‚£∑‚°Ä‚†Ä‚¢†‚†õ‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†°‚†Ä‚¢ø‚£ø‚£Ø‚£ë‚£Ü‚£∞‚£ø‚°ø‚¢É‚°†‚†§‚†§‚†§‚¢Ñ‚°Ä‚†Ä‚†Ä‚°í‚†Ä‚¢Ä‚°ú‚¢ª‚†Ä‚†Ä‚†Ä‚¢∞‚†Å‚†Ä‚†Ä‚†≥‚£á‚£†‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†ç
‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚°î‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚¢≥‚¢£‚†Ä‚°ò‚¢∏‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ø‚£≠‚†∑‚£Ø‚£ø‚£ø‚†ã‚†Ä‚†â‚¢Ñ‚¢†‚°Ç‚†Å‚†Å‚†¢‚°ë‚¢¶‚¢É‚°†‚†ä‚†Ä‚°Ω‚†Ä‚†Ä‚†Ä‚†∏‚°Ñ‚†Ä‚¢†‚†Å‚†Ä‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚°é‚†ò‚°Ñ‚†Ä‚†Ä‚†Ä‚†ê‚°Ä‚¢ß‚†Ç‚†á‚¢∏‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£≥‚¢≠‚£õ‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†´‚¢ñ‚†í‚†¥‚†É‚†Ä‚†±‚°Ñ‚†Ä‚¢Ä‚°è‚†í‚†Ç‚†§‚£∏‚†Å‚†Ä‚¢∏‚†Ü‚†Ä‚†è‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†Ä‚†ò‚¢Ñ‚†Ä‚†Ä‚†Ä‚¢ü‚°å‚¢Ü‚†Ä‚°û‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚†ã‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†≥‚£Ñ‚°Ä‚†Ä‚°á‚†Ä‚†ò‚°á‚†Ä‚†Ä‚£†‚†è‚†à‚†±‚°º‚°Ä‚†Ä‚°ñ‚†ò‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†ú‚†Ä‚†∑‚°Ä‚†Ä‚†∞‚¢Ñ‚†Ä‚†à‚¢Æ‚¢å‚¢£‚†á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°ø‚£è‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ë‚¢å‚°í‚†Å‚†Ä‚†Ä‚†ô‚†í‚†ö‚†•‚¢§‚†ñ‚†ä‚†Ä‚£à‚†ñ‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚¢Ä‚†é‚†Ä‚†Ä‚†∏‚†å‚†¢‚£Ñ‚°Ä‚£ë‚¢∂‚£Å‚£Ä‚£π‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚°Ω‚£π‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£©‚†í‚†í‚†í‚£∂‚£§‚°Ä‚†Ä‚£â‚£ª‚†ù‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
–ò —á–µ–≥–æ —Ç—ã —Ç—É—Ç –∏—â–µ—à—å-—Ç–æ?
–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å –∫–∞–∫—É—é —Ç–æ —á–∞—Å—Ç—å –∫–æ–¥–∞ –ø—Ä–æ—à—É —É–∫–∞–∑–∞—Ç—å
@TomokoPlugins
"""
import hashlib
import hmac
import json
import math
import random
import re
import secrets
import threading
import time
import traceback
import urllib.error
import urllib.request
import urllib.parse
import weakref
import zlib
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta, timezone

from android.animation import ObjectAnimator, ValueAnimator
from android.content.res import ColorStateList
from android.graphics import Color, Rect, Typeface
from android.graphics.drawable import GradientDrawable, RippleDrawable
from android.view import Gravity, MotionEvent, View, ViewTreeObserver
from android.view.animation import (
    AccelerateDecelerateInterpolator,
    OvershootInterpolator,
)
from android.widget import FrameLayout, LinearLayout, ScrollView, TextView
from android_utils import OnClickListener, log as android_log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult, HookStrategy, MenuItemData, MenuItemType
from client_utils import get_last_fragment, send_text
from hook_utils import find_class
from java import dynamic_proxy
from org.telegram.messenger import AndroidUtilities
from org.telegram.ui.ActionBar import BottomSheet, Theme
from org.telegram.ui.Components import BackupImageView
from ui.bulletin import BulletinHelper

logDebug = False
hexMask = re.compile(r"\b[0-9a-fA-F]{16,}\b")
bearerMask = re.compile(r"(Bearer\s+)([A-Za-z0-9._-]{8,})")
kvMask = re.compile(
    r"(?i)\b(install[_-]?id|x-install-id|token|secret|server_secret)\b\s*[:=]\s*([A-Za-z0-9._-]{4,})"
)

def scrubLogText(text):
    if not text:
        return text
    text = bearerMask.sub(r"\1***", text)
    text = kvMask.sub(lambda m: f"{m.group(1)}=***", text)
    def maskHex(match):
        value = match.group(0)
        if len(value) <= 8:
            return value
        return f"{value[:4]}...{value[-4:]}"
    return hexMask.sub(maskHex, text)

def setLogDebug(enabled):
    global logDebug
    logDebug = bool(enabled)

def log(msg, data=None):
    try:
        if not logDebug:
            return
        try:
            text = str(msg)
        except Exception:
            text = repr(msg)
        text = scrubLogText(text)
        dataText = None
        if data is not None:
            try:
                dataText = str(data)
            except Exception:
                dataText = repr(data)
            dataText = scrubLogText(dataText)
        if dataText is None:
            android_log(f"[WatamoteStreakPet] {text}")
        else:
            android_log(text, dataText)
    except TypeError:
        try:
            if data is None:
                android_log(f"[WatamoteStreakPet] {text}")
            else:
                android_log(f"[WatamoteStreakPet] {text}: {data}")
        except Exception:
            pass

__id__ = "WatamoteStreakPet"
__name__ = "WatamoteStreakPet"
__description__ = "–û–≥–æ–Ω–µ–∫ –∏ –ø–∏—Ç–æ–º–µ—Ü –¥–ª—è –≤–∞—à–∏—Ö –ª–∏—á–Ω—ã—Ö —á–∞—Ç–æ–≤: –ø–∏—à–∏—Ç–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å, –∫–æ—Ä–º–∏—Ç–µ, –∏–≥—Ä–∞–π—Ç–µ –∏ —Ä–∞—Å—Ç–∏—Ç–µ –≤–º–µ—Å—Ç–µ "
__author__ = "@nokirby || @TomokoPlugins"
__version__ = "PRE-RELEASE"
__icon__ = "tomocracy/6"
__min_version__ = "11.12.0"


DEFAULTS = {
    "show_widget": True,
    "widget_position": 3,
    "widget_size": 2,
    "widget_alpha": 4,
    "widget_mode": 0,

    "show_notifications": True,
    "pet_emoji_style": 0,
    "streak_sync_mode": 2,
    "p2p_switch_offer": True,
    "auto_sync_interval": 1,
    "background_sync": True,
    "debug_mode": False,
    "show_last_sync_status": True,
}

# —Ö–µ–ª–ø–µ—Ä—ã
class S:
    CLOSE = "–ó–∞–∫—Ä—ã—Ç—å"
    CANCEL = "–û—Ç–º–µ–Ω–∞"
    OK = "OK"
    SAVE = "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å"

    FEED = "üçñ –ö–æ—Ä–º–∏—Ç—å"
    FEED_SHORT = "üçñ –ü–æ–∫–æ—Ä–º–∏—Ç—å"
    PLAY = "üéÆ –ò–≥—Ä–∞—Ç—å"
    RENAME = "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å"
    KICK = "–í—ã–≥–Ω–∞—Ç—å"
    START_PET = "–ó–∞–≤–µ—Å—Ç–∏"
    ACTIVATE = "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å"

    ENABLE_STREAK = "–í–∫–ª—é—á–∏—Ç—å —Å—Ç—Ä–∏–∫"
    DISABLE_STREAK = "–í—ã–∫–ª—é—á–∏—Ç—å"
    RESTORE = "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å"

    XP = "‚≠ê –û–ø—ã—Ç"
    MOOD = "‚ù§Ô∏è –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ"
    DAYS = "–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥"
    NEXT_STAGE = "üìà –î–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç–∞–¥–∏–∏"
    MAX_LEVEL = "üéâ –£—Ä–æ–≤–µ–Ω—å"

SAVE_DEBOUNCE_SECONDS = 2
P2P_THROTTLE_SECONDS = 60
P2P_SWITCH_OFFER_COOLDOWN_SECONDS = 6 * 3600
HTTP_TIMEOUT_FIRST = 2
HTTP_TIMEOUT_RETRY = 3

class V:
    MIN_TS = 1600000000
    MAX_TS = 2000000000

    @staticmethod
    def is_dict(v):
        return isinstance(v, dict)

    @staticmethod
    def is_list(v):
        return isinstance(v, list)

    @staticmethod
    def int_range(v, min_v=0, max_v=999999, default=0):
        if not isinstance(v, (int, float)):
            return default
        v = int(v)
        return max(min_v, min(v, max_v))

    @staticmethod
    def ts(v, default=None):
        if default is None:
            default = time.time()
        if not isinstance(v, (int, float)):
            return default
        if v < V.MIN_TS or v > V.MAX_TS:
            return default
        return float(v)

    @staticmethod
    def str_or(v, default=""):
        return v if isinstance(v, str) else default

    @staticmethod
    def bool_or(v, default=False):
        return v if isinstance(v, bool) else default

    @staticmethod
    def ts_or_none(v):
        if v is None:
            return None
        if not isinstance(v, (int, float)):
            return None
        if v < V.MIN_TS or v > V.MAX_TS:
            return None
        return float(v)

    @staticmethod
    def month_key(v, default=None):
        if v == 0 or v == "0":
            return None
        if isinstance(v, int):
            if v < 200001 or v > 299912:
                return default
            return v
        if not isinstance(v, str):
            return default
        if len(v) != 7 or v[4] != "-":
            return default
        year, month = v[:4], v[5:]
        if not (year.isdigit() and month.isdigit()):
            return default
        month_i = int(month)
        if month_i < 1 or month_i > 12:
            return default
        return int(f"{year}{month}")

    @staticmethod
    def pet_data(data):
        if not V.is_dict(data):
            return None
        if "chat" not in data:
            return None
        return {
            "chat": str(data["chat"]),
            "xp": V.int_range(data.get("xp"), 0, MAX_PET_XP),
            "stage": V.int_range(data.get("stage"), 0, len(PET_STAGES) - 1),
            "level": V.int_range(data.get("level"), 1, MAX_PET_LEVEL, 1),
            "name": V.str_or(data.get("name"), defaultPetName())[:MAX_PET_NAME_LENGTH],
            "mood": V.int_range(data.get("mood"), 0, 100, 100),
            "hunger": V.int_range(data.get("hunger"), 0, 100, 100),
            "last_feed": V.ts(data.get("last_feed")),
            "last_update": V.ts(data.get("last_update")),
            "last_sync": V.ts(data.get("last_sync"), 0),
            "deleted": V.bool_or(data.get("deleted"))
        }

    @staticmethod
    def streak_data(data):
        if not V.is_dict(data):
            return None
        if "chat" not in data:
            return None
        return {
            "chat": str(data["chat"]),
            "count": V.int_range(data.get("count"), 0, MAX_STREAK_COUNT),
            "last_date": V.str_or(data.get("last_date")),
            "first_date": V.str_or(data.get("first_date")),
            "timestamp": V.ts(data.get("timestamp"), 0),
            "last_message_time": V.ts(data.get("last_message_time")),
            "deleted": V.bool_or(data.get("deleted")),
            "warning_since": V.ts_or_none(data.get("warning_since")),
            "dead_since": V.ts_or_none(data.get("dead_since")),
            "dead_count": V.int_range(data.get("dead_count"), 0, 9999),
            "restores_this_month": V.int_range(
                data.get("restores_this_month"), 0, STREAK_MAX_RESTORES_PER_MONTH
            ),
            "last_restore_month": V.month_key(data.get("last_restore_month"))
        }


class Dp:
    S1 = 1
    S2 = 2
    S4 = 4
    S6 = 6
    S8 = 8
    S10 = 10
    S12 = 12
    S14 = 14
    S16 = 16
    S20 = 20
    S24 = 24
    S28 = 28
    S32 = 32
    S40 = 40
    S48 = 48
    S80 = 80
    S100 = 100
    S120 = 120
    S160 = 160

    PAD_XS = 4
    PAD_SM = 8
    PAD_MD = 12
    PAD_LG = 16
    PAD_XL = 24
    PAD_XXL = 48

    MARGIN_SM = 8
    MARGIN_MD = 12
    MARGIN_LG = 16

    CORNER_XS = 4
    CORNER_SM = 8
    CORNER_MD = 12
    CORNER_LG = 16
    CORNER_XL = 28
    CORNER_SHEET = 28

    BADGE_SIZE = 48
    WIDGET_SM = 40
    WIDGET_MD = 80
    WIDGET_LG = 160

    HANDLE_W = 32
    HANDLE_H = 4

    STROKE = 2

    BAR_H = 8

    BTN_H = 48


langCache = {"code": None, "ts": 0}

def getLang():
    try:
        if langCache["code"] and time.time() - langCache["ts"] < 5:
            return langCache["code"]
        LocaleController = find_class("org.telegram.messenger.LocaleController")
        if LocaleController:
            inst = LocaleController.getInstance()
            try:
                locale = inst.getCurrentLocale()
                if locale:
                    code = locale.getLanguage()
                    if code:
                        langCache["code"] = str(code).lower()
                        langCache["ts"] = time.time()
                        return langCache["code"]
            except Exception:
                pass
            try:
                info = inst.getCurrentLocaleInfo()
                if info:
                    code = getattr(info, "shortName", None) or getattr(info, "baseLangCode", None)
                    if code:
                        langCache["code"] = str(code).lower()
                        langCache["ts"] = time.time()
                        return langCache["code"]
            except Exception:
                pass
        from java.util import Locale
        code = Locale.getDefault().getLanguage()
        langCache["code"] = str(code).lower() if code else "ru"
        langCache["ts"] = time.time()
        return langCache["code"]
    except Exception:
        return "ru"

def isEn():
    return getLang().startswith("en")

strings = {
    "ru": {
        "close": "–ó–∞–∫—Ä—ã—Ç—å",
        "cancel": "–û—Ç–º–µ–Ω–∞",
        "save": "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å",
        "feed": "üçñ –ö–æ—Ä–º–∏—Ç—å",
        "feed_short": "üçñ –ü–æ–∫–æ—Ä–º–∏—Ç—å",
        "play": "üéÆ –ò–≥—Ä–∞—Ç—å",
        "rename": "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å",
        "delete": "–£–¥–∞–ª–∏—Ç—å",
        "create": "–°–æ–∑–¥–∞—Ç—å",
        "turn_on": "–í–∫–ª—é—á–∏—Ç—å",
        "settings_gameplay": "–ì–µ–π–º–ø–ª–µ–π",
        "settings_pet_style": "–°—Ç–∏–ª—å –ø–∏—Ç–æ–º—Ü–∞",
        "settings_evolution_notifications": "–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± —ç–≤–æ–ª—é—Ü–∏–∏",
        "settings_evolution_notifications_sub": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ–∫–Ω–æ –ø—Ä–∏ —ç–≤–æ–ª—é—Ü–∏–∏",
        "settings_sync": "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "settings_sync_mode": "–†–µ–∂–∏–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_p2p_offer": "–ü—Ä–µ–¥–ª–∞–≥–∞—Ç—å P2P –ø—Ä–∏ –≤—Ö–æ–¥—è—â–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_p2p_offer_sub": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ P2P –æ—Ç —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞",
        "settings_sync_interval": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏",
        "settings_sync_status": "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å—Ç–∞—Ç—É—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
        "settings_sync_status_sub": "–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –≤ –º–µ–Ω—é WSP",
        "settings_bg_sync": "–§–æ–Ω–æ–≤–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è",
        "settings_bg_sync_sub": "–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤ —Ñ–æ–Ω–µ",
        "settings_debug": "–û—Ç–ª–∞–¥–∫–∞ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞",
        "settings_debug_mode": "–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏",
        "settings_debug_mode_sub": "–õ–æ–≥–∏ –ø–ª–∞–≥–∏–Ω–∞ –≤ –∫–æ–Ω—Å–æ–ª–∏",
        "settings_check_server": "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–µ—Ä–≤–µ—Ä",
        "settingsclearCache": "–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à",
        "settings_danger_zone": "–û–ø–∞—Å–Ω–∞—è –∑–æ–Ω–∞",
        "settings_reset_data": "–°–±—Ä–æ—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ",
    },
    "en": {
        "close": "Close",
        "cancel": "Cancel",
        "save": "Save",
        "feed": "üçñ Feed",
        "feed_short": "üçñ Feed",
        "play": "üéÆ Play",
        "rename": "Rename",
        "delete": "Delete",
        "create": "Create",
        "turn_on": "Turn on",
        "settings_gameplay": "Gameplay",
        "settings_pet_style": "Pet style",
        "settings_evolution_notifications": "Evolution notifications",
        "settings_evolution_notifications_sub": "Show a popup on evolution",
        "settings_sync": "Sync",
        "settings_sync_mode": "Sync mode",
        "settings_p2p_offer": "Suggest P2P on incoming sync",
        "settings_p2p_offer_sub": "Show a prompt when a peer uses P2P",
        "settings_sync_interval": "Check interval",
        "settings_sync_status": "Show sync status",
        "settings_sync_status_sub": "Show last sync time in WSP menu",
        "settings_bg_sync": "Background sync",
        "settings_bg_sync_sub": "Sync in background",
        "settings_debug": "Debug & diagnostics",
        "settings_debug_mode": "Debug mode",
        "settings_debug_mode_sub": "Plugin logs in console",
        "settings_check_server": "Check server",
        "settingsclearCache": "Clear cache",
        "settings_danger_zone": "Danger zone",
        "settings_reset_data": "Reset data",
    },
}

def tr(key, en=None, **kwargs):
    if en is not None:
        text = en if isEn() else key
        if kwargs:
            try:
                return text.format(**kwargs)
            except Exception:
                return text
        return text

    lang = "en" if isEn() else "ru"
    text = strings.get(lang, {}).get(key)
    if text is None:
        text = strings.get("en", {}).get(key, key)
    if kwargs:
        try:
            return text.format(**kwargs)
        except Exception:
            return text
    return text

def ruPlural(n, one, few, many):
    try:
        n = abs(int(n))
    except Exception:
        return many
    if n % 10 == 1 and n % 100 != 11:
        return one
    if 2 <= n % 10 <= 4 and not 12 <= n % 100 <= 14:
        return few
    return many

def formatDaysRu(n):
    return f"{n} {ruPlural(n, '–¥–µ–Ω—å', '–¥–Ω—è', '–¥–Ω–µ–π')}"

def formatDaysEn(n):
    try:
        n_int = int(n)
    except Exception:
        n_int = n
    word = "day" if n_int == 1 else "days"
    return f"{n} {word}"

def formatDays(n):
    return formatDaysEn(n) if isEn() else formatDaysRu(n)

def daysInRowRu(n):
    return ruPlural(n, "–¥–µ–Ω—å –ø–æ–¥—Ä—è–¥", "–¥–Ω—è –ø–æ–¥—Ä—è–¥", "–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥")

def daysInRowEn(n):
    try:
        n_int = int(n)
    except Exception:
        n_int = n
    return "day in a row" if n_int == 1 else "days in a row"

def formatDaysInRow(n):
    return daysInRowEn(n) if isEn() else daysInRowRu(n)

def defaultPetName():
    return tr("–ß–µ–±—É—Ä–∞—à–∫–∞", "Cheburashka")

bulletin_last = {}

def bulletin_safe(kind, message, ui_thread=False):
    try:
        now = time.time()
        key = f"{kind}:{message}"
        last = bulletin_last.get(key, 0)
        if now - last < 0.8:
            return
        bulletin_last[key] = now
    except Exception:
        pass
    def do_show():
        try:
            fn = getattr(BulletinHelper, f"show_{kind}", None)
            if fn:
                fn(message)
        except Exception:
            pass
    if ui_thread:
        run_on_ui_thread(do_show)
    else:
        do_show()


S.CLOSE = tr("close")
S.CANCEL = tr("cancel")
S.OK = "OK"
S.SAVE = tr("save")
S.FEED = tr("feed")
S.FEED_SHORT = tr("feed_short")
S.PLAY = tr("play")
S.RENAME = tr("rename")
S.KICK = tr("delete")
S.START_PET = tr("create")
S.ACTIVATE = tr("turn_on")
S.ENABLE_STREAK = tr("–í–∫–ª—é—á–∏—Ç—å —Å—Ç—Ä–∏–∫", "Enable streak")
S.DISABLE_STREAK = tr("–í—ã–∫–ª—é—á–∏—Ç—å", "Disable")
S.RESTORE = tr("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Restore")
S.XP = tr("‚≠ê –û–ø—ã—Ç", "‚≠ê XP")
S.MOOD = tr("‚ù§Ô∏è –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "‚ù§Ô∏è Mood")
S.DAYS = tr("–¥–Ω–µ–π –ø–æ–¥—Ä—è–¥", "days in a row")
S.NEXT_STAGE = tr("üìà –î–æ —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç–∞–¥–∏–∏", "üìà To next stage")
S.MAX_LEVEL = tr("üéâ –£—Ä–æ–≤–µ–Ω—å", "üéâ Level")

from ui.settings import Divider, Header, Input, Selector, Switch, Text


def OnTouchListener(callback):
    from java import dynamic_proxy

    class TouchListenerProxy(dynamic_proxy(View.OnTouchListener)):
        def __init__(self):
            super().__init__()

        def onTouch(self, v, event):
            try:
                return callback(v, event)
            except Exception as e:
                log(f"OnTouchListener error: {e}")
                return False

    return TouchListenerProxy()


def clamp(v, a, b):
    return a if v < a else b if v > b else v


def jint32(v):
    v = int(v) & 0xFFFFFFFF
    if v >= 0x80000000:
        v -= 0x100000000
    return int(v)


ZW_MAP = {"00": "\u200b", "01": "\u200c", "10": "\u200d", "11": "\ufeff"}
ZW_REV = {v: k for k, v in ZW_MAP.items()}
SYNC_PREFIX = "\u2060"
SYNC_PREFIXES = (SYNC_PREFIX, "\u00ad")


def packZws(data):
    return "".join(ZW_MAP[f"{b:08b}"[i : i + 2]] for b in data for i in (0, 2, 4, 6))


def unpackZws(text):
    if not (bits := "".join(ZW_REV.get(c, "") for c in text)):
        return None
    if len(bits) % 8 != 0:
        bits = bits[2:] if len(bits) > 2 and (len(bits) - 2) % 8 == 0 else bits
    return (
        bytes(int(bits[i : i + 8], 2) for i in range(0, len(bits), 8))
        if len(bits) % 8 == 0
        else None
    )


def looksSyncMsg(text):
    if not isinstance(text, str):
        return False
    has_zw = False
    for ch in text:
        if ch in ZW_REV:
            has_zw = True
            continue
        if ch in SYNC_PREFIXES:
            continue
        return False
    return has_zw


# —Ç–∞–ø–∞–ª–∫–∏ –∏ –≤–∏–±—Ä–æ
class Haptics:
    def __init__(self, ctx, view):
        self.ctx = ctx
        self.view = view
        self.Build_VERSION = find_class("android.os.Build$VERSION")
        self.VibrationEffect = find_class("android.os.VibrationEffect")
        self.Context = find_class("android.content.Context")
        self.HFC = find_class("android.view.HapticFeedbackConstants")
        self.vib = None
        try:
            if self.Context and hasattr(self.Context, "VIBRATOR_SERVICE"):
                self.vib = ctx.getSystemService(self.Context.VIBRATOR_SERVICE)
        except Exception:
            try:
                self.vib = ctx.getSystemService("vibrator")
            except Exception:
                pass

    def kind(self, name, default_val):
        try:
            if self.HFC and hasattr(self.HFC, name):
                return int(getattr(self.HFC, name))
        except Exception:
            pass
        return int(default_val)

    def haptic(self, kind_name="KEYBOARD_TAP", fallback_int=3):
        try:
            k = self.kind(kind_name, fallback_int)
            self.view.performHapticFeedback(int(k), 3)
            return True
        except Exception:
            try:
                AU = find_class("org.telegram.messenger.AndroidUtilities")
                if AU:
                    AU.vibrate(self.view)
                    return True
            except Exception:
                pass
        return False

    def oneshot(self, ms, amp):
        if not self.vib:
            return False
        try:
            if (
                self.Build_VERSION
                and getattr(self.Build_VERSION, "SDK_INT", 0) >= 26
                and self.VibrationEffect
            ):
                try:
                    self.vib.vibrate(
                        self.VibrationEffect.createOneShot(
                            int(ms), int(clamp(amp, 1, 255))
                        )
                    )
                    return True
                except Exception:
                    try:
                        self.vib.vibrate(
                            self.VibrationEffect.createOneShot(int(ms), -1)
                        )
                        return True
                    except Exception:
                        pass
            self.vib.vibrate(int(ms))
            return True
        except Exception:
            return False

    def texture(self, a):
        if not self.vib:
            return False
        try:
            if (
                self.Build_VERSION
                and getattr(self.Build_VERSION, "SDK_INT", 0) >= 26
                and self.VibrationEffect
            ):
                a = int(clamp(a, 1, 255))
                timings = [0, 6, 10, 6, 12, 6, 10, 6, 12]
                a1 = int(clamp(a * 0.50, 1, 255))
                a2 = int(clamp(a * 0.82, 1, 255))
                a3 = int(clamp(a * 0.62, 1, 255))
                a4 = int(clamp(a * 0.90, 1, 255))
                amps = [0, a1, a2, a3, a2, a1, a4, a2, 0]
                self.vib.vibrate(self.VibrationEffect.createWaveform(timings, amps, -1))
                return True
            return self.oneshot(18, int(clamp(a, 1, 255)))
        except Exception:
            return False


# –±–∞–∑–æ–≤—ã–π –≤–∏–¥–∂–µ—Ç
class BaseWidget:
    def __init__(self, context, plugin_ref, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None
        self.chat_id = chat_id
        self.container = None
        self.is_dragging = False
        self.start_x = 0
        self.start_y = 0
        self.drag_threshold = AndroidUtilities.dp(DRAG_THRESHOLD_PX)
        self.haptics = None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def setupTouchBase(self, view):
        widget_ref = self

        def onTouch(v, event):
            try:
                action = event.getAction()

                if action == MotionEvent.ACTION_DOWN:
                    widget_ref.start_x = event.getRawX()
                    widget_ref.start_y = event.getRawY()
                    widget_ref.is_dragging = False
                    widget_ref.onTouchDown(v, event)
                    return True

                elif action == MotionEvent.ACTION_MOVE:
                    dx = event.getRawX() - widget_ref.start_x
                    dy = event.getRawY() - widget_ref.start_y
                    distance = math.sqrt(dx * dx + dy * dy)

                    if distance > widget_ref.drag_threshold:
                        widget_ref.is_dragging = True
                        widget_ref.onDrag(v, event, dx, dy)
                    return True

                elif action == MotionEvent.ACTION_UP:
                    if not widget_ref.is_dragging:
                        widget_ref.onClick(v, event)
                    widget_ref.onTouchUp(v, event)
                    return True

                return False
            except Exception as e:
                widget_ref.log(f"WSP: onTouch error: {e}")
                return False

        listener = OnTouchListener(onTouch)
        view.setOnTouchListener(listener)
        self.haptics = Haptics(self.context, view)

    def onTouchDown(self, view, event):
        pass

    def onDrag(self, view, event, dx, dy):
        pass

    def onClick(self, view, event):
        pass

    def onTouchUp(self, view, event):
        pass

    def get_view(self):
        raise NotImplementedError

    def cleanup(self):
        pass


PET_STAGES = {
    0: {"emoji": "ü•ö", "name": "–Ø–π—Ü–æ", "xp": 0},
    1: {"emoji": "üê£", "name": "–ü—Ç–µ–Ω–µ—Ü", "xp": 250},
    2: {"emoji": "üê•", "name": "–¶—ã–ø–∞", "xp": 1500},
    3: {"emoji": "üêì", "name": "–ü–µ—Ç—É—Ö", "xp": 6000},
    4: {"emoji": "ü¶Ö", "name": "–û—Ä—ë–ª", "xp": 25000},
}

PET_STAGES_BY_STYLE = {
    0: PET_STAGES,
    1: {
        0: {"emoji": "ü•ö", "name": "–Ø–π—Ü–æ", "xp": 0},
        1: {"emoji": "üëæ", "name": "–°–ª–∏–∑–µ–Ω—å", "xp": 250},
        2: {"emoji": "üëπ", "name": "–ì–æ–±–ª–∏–Ω", "xp": 1500},
        3: {"emoji": "üë∫", "name": "–î–µ–º–æ–Ω", "xp": 6000},
        4: {"emoji": "üêâ", "name": "–î—Ä–∞–∫–æ–Ω", "xp": 25000},
    },
    2: {
        0: {"emoji": "üå±", "name": "–†–æ—Å—Ç–æ–∫", "xp": 0},
        1: {"emoji": "üåø", "name": "–ü–æ–±–µ–≥", "xp": 250},
        2: {"emoji": "üçÄ", "name": "–ö–ª–µ–≤–µ—Ä", "xp": 1500},
        3: {"emoji": "üå≥", "name": "–î–µ—Ä–µ–≤–æ", "xp": 6000},
        4: {"emoji": "üå∫", "name": "–°–∞–∫—É—Ä–∞", "xp": 25000},
    },
    3: {
        0: {"emoji": "‚≠ê", "name": "–ó–≤–µ–∑–¥–∞", "xp": 0},
        1: {"emoji": "üåü", "name": "–ò—Å–∫—Ä–∞", "xp": 250},
        2: {"emoji": "‚ú®", "name": "–ë–ª–µ—Å–∫", "xp": 1500},
        3: {"emoji": "üí´", "name": "–ö–æ–º–µ—Ç–∞", "xp": 6000},
        4: {"emoji": "üåå", "name": "–ì–∞–ª–∞–∫—Ç–∏–∫–∞", "xp": 25000},
    },
    4: {
        0: {"emoji": "‚öôÔ∏è", "name": "–î–µ—Ç–∞–ª—å", "xp": 0},
        1: {"emoji": "üî©", "name": "–ë–æ–ª—Ç", "xp": 100},
        2: {"emoji": "ü§ñ", "name": "–†–æ–±–æ—Ç", "xp": 500},
        3: {"emoji": "üöÄ", "name": "–†–∞–∫–µ—Ç–∞", "xp": 2000},
        4: {"emoji": "üõ∏", "name": "–ù–õ–û", "xp": 10000},
    },
    5: {
        0: {"emoji": "ü•ö", "name": "–ñ–∏—Ä–Ω–æ—Å—Ç—å", "xp": 0},
        1: {"emoji": "ü•ê", "name": "–ñ–∏—Ä–æ–∫", "xp": 250},
        2: {"emoji": "üç©", "name": "–ü–æ–Ω—á–∏–∫", "xp": 1500},
        3: {"emoji": "üçî", "name": "–ë—É—Ä–≥–µ—Ä", "xp": 6000},
        4: {"emoji": "üê∑", "name": "–°–≤–∏–Ω—Ç—É—Å", "xp": 25000},
    },
}

PET_STAGE_NAME_EN = {
    "–Ø–π—Ü–æ": "Egg",
    "–ü—Ç–µ–Ω–µ—Ü": "Chick",
    "–¶—ã–ø–∞": "Baby chick",
    "–ü–µ—Ç—É—Ö": "Rooster",
    "–û—Ä—ë–ª": "Eagle",
    "–°–ª–∏–∑–µ–Ω—å": "Slime",
    "–ì–æ–±–ª–∏–Ω": "Goblin",
    "–î–µ–º–æ–Ω": "Demon",
    "–î—Ä–∞–∫–æ–Ω": "Dragon",
    "–†–æ—Å—Ç–æ–∫": "Sprout",
    "–ü–æ–±–µ–≥": "Shoot",
    "–ö–ª–µ–≤–µ—Ä": "Clover",
    "–î–µ—Ä–µ–≤–æ": "Tree",
    "–°–∞–∫—É—Ä–∞": "Sakura",
    "–ó–≤–µ–∑–¥–∞": "Star",
    "–ò—Å–∫—Ä–∞": "Spark",
    "–ë–ª–µ—Å–∫": "Glow",
    "–ö–æ–º–µ—Ç–∞": "Comet",
    "–ì–∞–ª–∞–∫—Ç–∏–∫–∞": "Galaxy",
    "–î–µ—Ç–∞–ª—å": "Part",
    "–ë–æ–ª—Ç": "Bolt",
    "–†–æ–±–æ—Ç": "Robot",
    "–†–∞–∫–µ—Ç–∞": "Rocket",
    "–ù–õ–û": "UFO",
    "–ë—É–ª–æ—á–∫–∞": "Bun",
    "–ü–æ–Ω—á–∏–∫": "Donut",
    "–ë—É—Ä–≥–µ—Ä": "Burger",
    "–ü–æ—Ä–æ—Å—ë–Ω–æ–∫": "Piglet",
}

FLAME_COLORS = {
    (0, 6): "üî•",
    (7, 13): "üíô",
    (14, 29): "üíö",
    (30, 99): "üíú",
    (100, 999): "‚≠ê",
}
FLAME_EXTINGUISHED = "üïØÔ∏è"

FLAME_STAGES = [
    {"emoji": "üî•", "name": "–ù–æ–≤—ã–π –æ–≥–æ–Ω—å", "days": "0-6", "min": 0, "max": 6},
    {"emoji": "üíô", "name": "–°–∏–Ω–µ–µ –ø–ª–∞–º—è", "days": "7-13", "min": 7, "max": 13},
    {"emoji": "üíö", "name": "–ó–µ–ª—ë–Ω—ã–π –∂–∞—Ä", "days": "14-29", "min": 14, "max": 29},
    {"emoji": "üíú", "name": "–§–∏–æ–ª–µ—Ç–æ–≤—ã–π –æ–≥–æ–Ω—å", "days": "30-99", "min": 30, "max": 99},
    {"emoji": "‚≠ê", "name": "–ó–≤–µ–∑–¥–∞", "days": "100+", "min": 100, "max": 999},
]
FLAME_STAGE_NAME_EN = {
    "–ù–æ–≤—ã–π –æ–≥–æ–Ω—å": "Fresh flame",
    "–°–∏–Ω–µ–µ –ø–ª–∞–º—è": "Blue flame",
    "–ó–µ–ª—ë–Ω—ã–π –∂–∞—Ä": "Green glow",
    "–§–∏–æ–ª–µ—Ç–æ–≤—ã–π –æ–≥–æ–Ω—å": "Purple flame",
    "–ó–≤–µ–∑–¥–∞": "Star",
}

XP_REWARDS = {
    "msg": 5,
    "first_of_day": 30,
    "night": 8,
    "weekend": 15,
    "streak_3_days": 20,
    "streak_7_days": 50,
    "streak_14_days": 100,
    "streak_30_days": 250,
    "feed": 15,
    "play": 12,
}
MINIGAME_WIN_BONUS_XP = 8
MINIGAME_COMBO_BONUS_XP = 2
MINIGAME_MAX_COMBO_BONUS = 12
MINIGAME_TIME_LIMIT_SECONDS = 5
MINIGAME_RARE_BONUS_CHANCE = 0.08
MINIGAME_RARE_BONUS_XP = 15

HUNGER_CONFIG = {
    "decrease_per_hour": 5,
    "critical_level": 20,
    "max_hunger": 100,
    "feed_restore": 40,
}

MOOD_CONFIG = {
    "max_mood": 100,
    "min_mood": 0,
    "hunger_penalty_threshold": 30,
    "mood_decrease_per_hour": 2,
}

MAX_PET_XP = 1_000_000
MAX_PET_NAME_LENGTH = 100
MAX_PET_LEVEL = 10
MAX_STREAK_COUNT = 10_000

STREAK_UNLOCK_DAYS = 3
STREAK_WARNING_HOURS = 24
STREAK_RESTORE_WINDOW_HOURS = 48
STREAK_MAX_RESTORES_PER_MONTH = 3

TIMESTAMP_TOLERANCE_SECONDS = 300
ONE_DAY_SECONDS = 86400
LOCAL_PRIORITY_SECONDS = 300

MSK_TZ = timezone(timedelta(hours=3))

MAX_DATA_SIZE_BYTES = 1_048_576

HTTP_SERVER_ERROR_THRESHOLD = 500

WIDGET_SIZES_DP = [60, 70, 80, 90, 100, 110, 120]
WIDGET_DEFAULT_SIZE_DP = 80
ALPHA_VALUES_PERCENT = [30, 50, 70, 90, 100]
DRAG_THRESHOLD_PX = 10

MOOD_HIGH_THRESHOLD = 80
MOOD_MEDIUM_THRESHOLD = 50
MOOD_LOW_THRESHOLD = 30
HUNGER_MEDIUM_THRESHOLD = 50

ELEVATION_CARD = 1
ELEVATION_BUTTON = 3
ELEVATION_DIALOG = 6
ELEVATION_SHEET = 8
ELEVATION_WIDGET = 12

SECONDS_PER_HOUR = 3600
SECONDS_PER_MINUTE = 60
NIGHT_HOURS_START = 0
NIGHT_HOURS_END = 6

XP_COOLDOWN_SECONDS = 20
XP_MAX_PER_HOUR = 150

FEED_COOLDOWN_SECONDS = 3600
FEED_MOOD_BONUS_HIGH = 10
FEED_MOOD_BONUS_LOW = 5
PLAY_MOOD_BONUS = 15
PLAY_HUNGER_COST = 5

REVIVE_XP_COST = 50
REVIVE_COOLDOWN_SECONDS = 6 * 3600

SERVER_PET_STAGE_EMOJIS = [
    "ü•ö", "üê£", "üê•", "ü¶Ü", "ü¶Ö",
    "ü¶â", "ü¶ö", "üêâ", "üåü", "üëë",
]

MULTIPLIER_MOOD_HIGH = 1.5
MULTIPLIER_MOOD_MEDIUM = 1.0
MULTIPLIER_MOOD_LOW = 0.7
MULTIPLIER_MOOD_CRITICAL = 0.5
MULTIPLIER_HUNGER_LOW = 0.8
MULTIPLIER_HUNGER_CRITICAL = 0.5

SPAM_CHECK_WINDOW_MESSAGES = 5
SPAM_IDENTICAL_THRESHOLD = 3
SPAM_MIN_MESSAGE_LENGTH = 3
SPAM_REPEATED_CHARS_THRESHOLD = 0.7
SPAM_SIMILARITY_THRESHOLD = 0.9

SYNC_INTERVAL_OPTIONS = [30, 60, 120, 300, 999999]
SYNC_INTERVAL_DEFAULT_INDEX = 1
SYNC_MODE_BY_INDEX = {0: "p2p", 1: "server", 2: "auto"}
SYNC_MODE_DEFAULT_INDEX = 2
SYNC_MODE_DEFAULT = "auto"
SYNC_MODE_NAMES = {
    "p2p": tr("P2P (–ª–æ–∫–∞–ª—å–Ω–æ)", "P2P (local)"),
    "server": tr("–°–µ—Ä–≤–µ—Ä (–æ–±–ª–∞–∫–æ)", "Server (cloud)"),
    "auto": tr("–ê–≤—Ç–æ (–≥–∏–±—Ä–∏–¥)", "Auto (hybrid)"),
}
SYNC_INTERVAL_DISABLED = 999999
SYNC_SERVER_CHECK_COOLDOWN = 15
SYNC_BACKOFF_MAX_SECONDS = 60
SYNC_DEFAULT_WAIT_SECONDS = 60
SYNC_GUARD_MAX_SKEW = 7200
SYNC_GUARD_MAX_STREAK_STEP = 1
SYNC_GUARD_STREAK_WINDOW = 72000
SYNC_GUARD_MAX_XP_STEP = 80
SYNC_GUARD_XP_WINDOW = 600
SYNC_GUARD_MAX_STAGE_STEP = 1


# —Ü–≤–µ—Ç–∞ –∏ —Ç–µ–º–∞
class UI:
    """—Ü–≤–µ—Ç–∞ —Ñ–æ–Ω—ã –∫–Ω–æ–ø–∫–∏"""
    _cache = {}

    @classmethod
    def getClass(cls, name):
        if name not in cls._cache:
            cls._cache[name] = find_class(name)
        return cls._cache[name]


    @staticmethod
    def primary():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader)

    @staticmethod
    def on_primary():
        return Color.WHITE

    @staticmethod
    def primary_container():
        p = UI.primary()
        return Color.argb(int(Color.alpha(p) * 0.12), Color.red(p), Color.green(p), Color.blue(p))

    @staticmethod
    def on_primary_container():
        return UI.primary()

    @staticmethod
    def surface():
        return Theme.getColor(Theme.key_windowBackgroundWhite)

    @staticmethod
    def on_surface():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlackText)

    @staticmethod
    def surface_variant():
        return Theme.getColor(Theme.key_windowBackgroundGray)

    @staticmethod
    def on_surface_variant():
        return Theme.getColor(Theme.key_windowBackgroundWhiteGrayText)

    @staticmethod
    def outline():
        return Theme.getColor(Theme.key_divider)

    @staticmethod
    def secondary():
        return Theme.getColor(Theme.key_windowBackgroundWhiteBlueText)

    @staticmethod
    def secondary_container():
        s = UI.secondary()
        return Color.argb(31, Color.red(s), Color.green(s), Color.blue(s))

    @staticmethod
    def tertiary():
        return Theme.getColor(Theme.key_avatar_backgroundViolet)

    @staticmethod
    def error():
        return Theme.getColor(Theme.key_text_RedBold)

    @staticmethod
    def error_container():
        e = UI.error()
        return Color.argb(40, Color.red(e), Color.green(e), Color.blue(e))

    @staticmethod
    def on_error_container():
        return UI.error()


    @staticmethod
    def bg_filled(radius, color):
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(radius))
        bg.setColor(color)
        return bg

    @staticmethod
    def bg_outlined(radius, stroke_color, stroke_width=1):
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(radius))
        bg.setColor(Color.TRANSPARENT)
        bg.setStroke(AndroidUtilities.dp(stroke_width), stroke_color)
        return bg

    @classmethod
    def bg_ripple(cls, radius, bg_color, ripple_color):
        RippleDrawable = cls.getClass("android.graphics.drawable.RippleDrawable")
        if not RippleDrawable:
            return UI.bg_filled(radius, bg_color)
        mask = UI.bg_filled(radius, Color.WHITE)
        bg = UI.bg_filled(radius, bg_color)
        ColorStateList = cls.getClass("android.content.res.ColorStateList")
        return RippleDrawable(ColorStateList.valueOf(ripple_color), bg, mask)

    @staticmethod
    def bg_sheet(color=None):
        bg = GradientDrawable()
        radii = [AndroidUtilities.dp(Dp.S28)] * 4 + [0] * 4
        bg.setCornerRadii([float(r) for r in radii])
        bg.setColor(color if color else UI.surface())
        return bg


    @staticmethod
    def button(context, text, on_click, style="filled"):
        btn = TextView(context)
        btn.setText(text)
        btn.setTextSize(1, 14)
        btn.setTypeface(None, Typeface.BOLD)
        btn.setGravity(Gravity.CENTER)
        btn.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S10),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S10)
        )
        btn.setClickable(True)
        btn.setOnClickListener(OnClickListener(on_click))

        if style == "filled":
            btn.setBackground(UI.bg_ripple(Dp.CORNER_XL, UI.primary(), UI.on_primary()))
            btn.setTextColor(UI.on_primary())
        elif style == "tonal":
            btn.setBackground(UI.bg_ripple(Dp.CORNER_XL, UI.secondary_container(), UI.secondary()))
            btn.setTextColor(UI.secondary())
        elif style == "outlined":
            btn.setBackground(UI.bg_outlined(Dp.CORNER_XL, UI.outline()))
            btn.setTextColor(UI.primary())
        elif style == "text":
            btn.setBackgroundColor(Color.TRANSPARENT)
            btn.setTextColor(UI.primary())
            btn.setPadding(
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S10)
            )

        return btn

    @staticmethod
    def elevation(view, dp):
        if hasattr(view, "setElevation"):
            view.setElevation(AndroidUtilities.dp(dp))

    @staticmethod
    def info_row(context, label, value, padding=16):
        row = LinearLayout(context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(
            AndroidUtilities.dp(padding),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(padding),
            AndroidUtilities.dp(Dp.S8),
        )

        label_tv = TextView(context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 14)
        label_tv.setTextColor(UI.on_surface_variant())
        label_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        row.addView(label_tv, label_params)

        value_tv = TextView(context)
        value_tv.setText(str(value))
        value_tv.setTextSize(1, 14)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        row.addView(value_tv)

        return row


def get_on_primary_container():
    return UI.on_primary_container()


def get_on_surface_variant():
    return UI.on_surface_variant()


def get_on_error_container():
    return UI.on_error_container()


def attachDialogDismiss(dialog, on_dismiss=None):
    if not dialog:
        return False
    try:
        from java import dynamic_proxy
        from android.content import DialogInterface

        DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)

        class _DismissListener(DismissListener):
            def onDismiss(self, dialog):
                try:
                    if on_dismiss:
                        on_dismiss()
                except Exception:
                    pass

        dialog.setOnDismissListener(_DismissListener())
        return True
    except Exception:
        return False


def safeShowDialog(builder, on_dismiss=None):
    try:
        dialog = builder.show()
    except Exception:
        return None
    if dialog and on_dismiss:
        attachDialogDismiss(dialog, on_dismiss)
    return dialog


# –±–∞–∑–æ–≤—ã–π —à–∏—Ç
class SafeSheet:
    def __init__(self, context, plugin, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin) if plugin else None
        self.chat_id = chat_id
        self.bottom_sheet = None
        self._dismissed = False
        self._dismiss_listener = None

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        try:
            if hasattr(self, "_tab_buttons"):
                self._tab_buttons.clear()
            if hasattr(self, "_tab_button_state"):
                self._tab_button_state.clear()
            if hasattr(self, "_tab_indicators"):
                self._tab_indicators.clear()
        except Exception:
            pass
        for name in (
            "_tab_content",
            "_tab_streak",
            "_tab_pet",
            "_tab_state",
            "_button_container",
            "_dismiss_listener",
        ):
            try:
                if hasattr(self, name):
                    setattr(self, name, None)
            except Exception:
                pass
        self._plugin_ref = None
        self.context = None
        self.chat_id = None
        self.bottom_sheet = None

    def _create_tabs_row(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)

        row = LinearLayout(self.context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        self._tab_buttons = {}
        self._tab_button_state = {}
        self._tab_indicators = {}
        tabs = [
            ("streak", tr("–°—Ç—Ä–∏–∫", "Streak")),
            ("pet", tr("–ü–∏—Ç–æ–º–µ—Ü", "Pet")),
            ("rewards", tr("–ù–∞–≥—Ä–∞–¥—ã", "Rewards")),
        ]
        self._tabs_order = [tab_id for tab_id, _ in tabs]

        for tab_id, title in tabs:
            btn = self._create_tab_button(title, tab_id)
            params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
            params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)
            row.addView(btn, params)
            self._tab_buttons[tab_id] = btn

        indicator_row = LinearLayout(self.context)
        indicator_row.setOrientation(LinearLayout.HORIZONTAL)
        indicator_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            0,
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S4),
        )

        for tab_id, _ in tabs:
            indicator = View(self.context)
            indicator_bg = GradientDrawable()
            indicator_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
            indicator_bg.setColor(UI.primary())
            indicator.setBackground(indicator_bg)
            indicator.setAlpha(0.0)
            params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S2), 1.0)
            params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)
            indicator_row.addView(indicator, params)
            self._tab_indicators[tab_id] = indicator

        container.addView(row)
        container.addView(indicator_row)
        return container

    def _create_tab_button(self, text, tab_id):
        btn = TextView(self.context)
        btn.setText(text)
        btn.setTextSize(1, 12)
        btn.setTypeface(None, Typeface.BOLD)
        btn.setGravity(Gravity.CENTER)
        btn.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S8),
        )
        btn.setOnClickListener(
            OnClickListener(lambda *args, t=tab_id: self._switch_tab(t))
        )
        return btn

    def _style_tab_button(self, btn, is_selected):
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        target_bg = UI.primary_container() if is_selected else UI.surface_variant()
        target_text = UI.on_primary_container() if is_selected else UI.on_surface_variant()

        btn_id = id(btn)
        state = self._tab_button_state.get(btn_id, {})
        try:
            current_bg = state.get("bg")
            current_color = target_bg
            if isinstance(current_bg, GradientDrawable):
                try:
                    current_color = current_bg.getColor().getDefaultColor()
                except Exception:
                    current_color = target_bg
            animator = ValueAnimator.ofArgb(int(current_color), int(target_bg))
            animator.setDuration(180)
            animator.setInterpolator(AccelerateDecelerateInterpolator())

            def on_update(anim):
                try:
                    bg.setColor(anim.getAnimatedValue())
                    btn.setBackground(bg)
                except Exception:
                    pass

            animator.addUpdateListener(dynamic_proxy(ValueAnimator.AnimatorUpdateListener, on_update))
            animator.start()
        except Exception:
            bg.setColor(target_bg)
            btn.setBackground(bg)

        try:
            current_text = state.get("text", btn.getCurrentTextColor())
            text_anim = ValueAnimator.ofArgb(int(current_text), int(target_text))
            text_anim.setDuration(180)
            text_anim.setInterpolator(AccelerateDecelerateInterpolator())

            def on_text_update(anim):
                try:
                    btn.setTextColor(anim.getAnimatedValue())
                except Exception:
                    pass

            text_anim.addUpdateListener(
                dynamic_proxy(ValueAnimator.AnimatorUpdateListener, on_text_update)
            )
            text_anim.start()
        except Exception:
            btn.setTextColor(target_text)

        self._tab_button_state[btn_id] = {"bg": bg, "text": target_text}

    def _style_tab_indicator(self, indicator, is_selected):
        target_alpha = 1.0 if is_selected else 0.0
        try:
            current_alpha = indicator.getAlpha()
            if abs(current_alpha - target_alpha) < 0.05:
                indicator.setAlpha(target_alpha)
                return
            anim = ObjectAnimator.ofFloat(indicator, "alpha", current_alpha, target_alpha)
            anim.setDuration(160)
            anim.setInterpolator(AccelerateDecelerateInterpolator())
            anim.start()
        except Exception:
            indicator.setAlpha(target_alpha)

    def _switch_tab(self, tab_id):
        if tab_id == self._tab:
            return
        prev_tab = self._tab
        self._tab = tab_id
        btn = self._tab_buttons.get(tab_id)
        if btn:
            self._animate_tab_button(btn)
        direction = 0
        try:
            if prev_tab in self._tabs_order and tab_id in self._tabs_order:
                prev_index = self._tabs_order.index(prev_tab)
                new_index = self._tabs_order.index(tab_id)
                if new_index > prev_index:
                    direction = 1
                elif new_index < prev_index:
                    direction = -1
        except Exception:
            direction = 0
        self._render_tab(direction)

    def _animate_tab_button(self, btn):
        try:
            scale_up_x = ObjectAnimator.ofFloat(btn, "scaleX", 1.0, 1.06, 1.0)
            scale_up_y = ObjectAnimator.ofFloat(btn, "scaleY", 1.0, 1.06, 1.0)
            scale_up_x.setDuration(140)
            scale_up_y.setDuration(140)
            scale_up_x.setInterpolator(OvershootInterpolator(1.0))
            scale_up_y.setInterpolator(OvershootInterpolator(1.0))
            scale_up_x.start()
            scale_up_y.start()
        except Exception:
            pass

    def _render_tab(self, direction=0):
        if not self._tab_content:
            return
        self._tab_content.removeAllViews()

        for tab_id, btn in self._tab_buttons.items():
            self._style_tab_button(btn, tab_id == self._tab)
        for tab_id, indicator in self._tab_indicators.items():
            self._style_tab_indicator(indicator, tab_id == self._tab)

        button_container = getattr(self, "_button_container", None)
        if button_container:
            button_container.setVisibility(
                View.VISIBLE if self._tab == "streak" else View.GONE
            )

        streak_active, pet_active = self._tab_state

        if self._tab == "pet":
            self._build_pet_tab(self._tab_content, self._tab_pet, pet_active)
        elif self._tab == "rewards":
            self._build_rewards_tab(self._tab_content)
        elif streak_active and self._tab_streak:
            if self._tab_streak.is_dead:
                self._build_dead_streak_ui(self._tab_content, self._tab_streak)
            else:
                self._build_active_streak_ui(self._tab_content, self._tab_streak)
        else:
            self._build_inactive_streak_ui(self._tab_content)

        self._animate_tab_content(direction)

    def _animate_tab_content(self, direction=0):
        try:
            view = self._tab_content
            if not view:
                return
            if direction > 0:
                offset = AndroidUtilities.dp(Dp.S14)
            elif direction < 0:
                offset = -AndroidUtilities.dp(Dp.S14)
            else:
                offset = 0
            view.setAlpha(0.0)
            view.setTranslationX(float(offset))
            alpha_anim = ObjectAnimator.ofFloat(view, "alpha", 0.0, 1.0)
            alpha_anim.setDuration(180)
            alpha_anim.setInterpolator(AccelerateDecelerateInterpolator())
            move_anim = ObjectAnimator.ofFloat(view, "translationX", float(offset), 0.0)
            move_anim.setDuration(180)
            move_anim.setInterpolator(AccelerateDecelerateInterpolator())
            alpha_anim.start()
            move_anim.start()
        except Exception:
            pass

    def _build_pet_tab(self, container, pet, is_active):
        if not is_active:
            self._build_pet_inactive_ui(container, pet)
            return
        if not pet:
            self._build_pet_inactive_ui(container, pet)
            return

        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji_tv = TextView(self.context)
        emoji_tv.setText(pet.get_emoji())
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        header.addView(emoji_tv)

        name_tv = TextView(self.context)
        name_tv.setText(pet.name)
        name_tv.setTextSize(1, 20)
        name_tv.setTextColor(UI.on_surface())
        name_tv.setTypeface(None, Typeface.BOLD)
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(name_tv, name_params)

        stage_tv = TextView(self.context)
        stage_tv.setText(f"{pet.get_stage_name()}  ‚Ä¢  {tr('–£—Ä.', 'Lv.')} {pet.level}")
        stage_tv.setTextSize(1, 12)
        stage_tv.setTextColor(UI.on_surface_variant())
        stage_tv.setGravity(Gravity.CENTER)
        header.addView(stage_tv)

        container.addView(header)

        pet.update_state()

        stats_row = LinearLayout(self.context)
        stats_row.setOrientation(LinearLayout.HORIZONTAL)
        stats_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        card_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        hunger_card = self._create_simple_stat_card(
            "üçñ",
            f"{int(pet.hunger)}%",
            tr("–°—ã—Ç–æ—Å—Ç—å", "Hunger"),
        )
        stats_row.addView(hunger_card, card_params)

        mood_card = self._create_simple_stat_card(
            "‚ù§Ô∏è",
            f"{int(pet.mood)}%",
            tr("–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "Mood"),
        )
        stats_row.addView(mood_card, card_params)

        container.addView(stats_row)

        xp_text = TextView(self.context)
        xp_text.setText(f"‚ö° {pet.xp} XP")
        xp_text.setTextSize(1, 13)
        xp_text.setTextColor(UI.on_surface())
        xp_text.setGravity(Gravity.CENTER)
        xp_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S8))
        container.addView(xp_text, xp_params)

        btn_row = LinearLayout(self.context)
        btn_row.setOrientation(LinearLayout.HORIZONTAL)
        btn_row.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )
        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        feed_btn = self._create_button(S.FEED, "filled")
        feed_btn.setOnClickListener(OnClickListener(lambda *args: self._on_pet_feed()))
        btn_row.addView(feed_btn, btn_params)

        play_btn = self._create_button(S.PLAY, "tonal")
        play_btn.setOnClickListener(OnClickListener(lambda *args: self._on_pet_play()))
        btn_row.addView(play_btn, btn_params)

        container.addView(btn_row)

        open_btn = self._create_button(tr("–û—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é", "Open menu"), "outlined")
        open_btn.setOnClickListener(OnClickListener(lambda *args: self._on_pet_open()))
        open_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        open_params.setMargins(AndroidUtilities.dp(Dp.S16), 0, AndroidUtilities.dp(Dp.S16), 0)
        container.addView(open_btn, open_params)

    def _build_pet_inactive_ui(self, container, pet):
        wrap = LinearLayout(self.context)
        wrap.setOrientation(LinearLayout.VERTICAL)
        wrap.setGravity(Gravity.CENTER)
        wrap.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        emoji_tv = TextView(self.context)
        emoji_tv.setText(pet.get_emoji() if pet else "ü•ö")
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        wrap.addView(emoji_tv)

        title = TextView(self.context)
        title.setText(tr("–ü–∏—Ç–æ–º–µ—Ü –≤—ã–∫–ª—é—á–µ–Ω", "Pet is off"))
        title.setTextSize(1, 18)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
        wrap.addView(title, title_params)

        desc = TextView(self.context)
        desc.setText(
            tr(
                "–í–∫–ª—é—á–∏ –ø–∏—Ç–æ–º—Ü–∞, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å XP",
                "Turn the pet on to earn XP",
            )
        )
        desc.setTextSize(1, 13)
        desc.setTextColor(UI.on_surface_variant())
        desc.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        wrap.addView(desc, desc_params)

        start_btn = self._create_button(tr("–í–∫–ª—é—á–∏—Ç—å", "Turn on"), "filled")
        start_btn.setOnClickListener(OnClickListener(lambda *args: self._on_pet_start()))
        start_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        start_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        wrap.addView(start_btn, start_params)

        container.addView(wrap)

    def _build_rewards_tab(self, container):
        header = TextView(self.context)
        header.setText(tr("–ù–∞–≥—Ä–∞–¥—ã", "Rewards"))
        header.setTextSize(1, 16)
        header.setTextColor(UI.on_surface())
        header.setTypeface(None, Typeface.BOLD)
        header.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )
        container.addView(header)

        preview = self._create_stages_preview()
        container.addView(preview)

        rewards = [
            (3, XP_REWARDS["streak_3_days"]),
            (7, XP_REWARDS["streak_7_days"]),
            (14, XP_REWARDS["streak_14_days"]),
            (30, XP_REWARDS["streak_30_days"]),
        ]

        list_container = LinearLayout(self.context)
        list_container.setOrientation(LinearLayout.VERTICAL)
        list_container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        for days, xp in rewards:
            row = TextView(self.context)
            row.setText(
                tr(
                    f"{formatDaysRu(days)} ‚Üí +{xp} XP",
                    f"{formatDaysEn(days)} ‚Üí +{xp} XP",
                )
            )
            row.setTextSize(1, 13)
            row.setTextColor(UI.on_surface())
            row.setPadding(0, AndroidUtilities.dp(Dp.S6), 0, AndroidUtilities.dp(Dp.S6))
            list_container.addView(row)

        container.addView(list_container)

    def _create_simple_stat_card(self, emoji, value, label):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        card.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 16)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(value_tv, value_params)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface_variant())
        label_tv.setGravity(Gravity.CENTER)
        card.addView(label_tv)

        return card

    def _init_sheet(self, with_handle=True):
        self.bottom_sheet = BottomSheet(self.context, False)

        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)

        container.setBackground(UI.bg_sheet())

        if with_handle:
            handle_container = LinearLayout(self.context)
            handle_container.setOrientation(LinearLayout.VERTICAL)
            handle_container.setGravity(Gravity.CENTER)
            handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

            handle = View(self.context)
            handle_bg = GradientDrawable()
            handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
            handle_bg.setColor(UI.outline())
            handle.setBackground(handle_bg)
            handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
            handle_container.addView(handle, handle_params)
            container.addView(handle_container)

        scroll_view = ScrollView(self.context)
        scroll_view.setFillViewport(True)

        content = LinearLayout(self.context)
        content.setOrientation(LinearLayout.VERTICAL)

        self._build_content(content)

        scroll_view.addView(content)
        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        buttons = self._build_buttons()
        if buttons:
            btn_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            container.addView(buttons, btn_params)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_content(self, content):
        pass

    def _build_buttons(self):
        return None

    def dismiss(self):
        if self.bottom_sheet:
            self.bottom_sheet.dismiss()
        self.onDismiss()

    def show(self):
        if self.bottom_sheet:
            self.bottom_sheet.show()

    def do_action(self, action_fn, *args):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin and action_fn:
            try:
                action_fn(plugin, chat_id, *args)
            except Exception as e:
                self.log(f"SafeSheet action error: {e}")

    def _add_divider(self, container):
        divider = View(self.context)
        divider.setBackgroundColor(UI.outline())
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 1
        )
        container.addView(divider, divider_params)

    def _add_header(self, container, emoji, title, subtitle=None):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        emoji_text = TextView(self.context)
        emoji_text.setText(emoji)
        emoji_text.setTextSize(1, 64)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        title_text = TextView(self.context)
        title_text.setText(title)
        title_text.setTextSize(1, 28)
        title_text.setTextColor(UI.on_surface())
        title_text.setTypeface(None, Typeface.BOLD)
        title_text.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(title_text, title_params)

        if subtitle:
            sub_text = TextView(self.context)
            sub_text.setText(subtitle)
            sub_text.setTextSize(1, 14)
            sub_text.setTextColor(UI.on_surface_variant())
            sub_text.setGravity(Gravity.CENTER)
            sub_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            sub_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            header.addView(sub_text, sub_params)

        container.addView(header)

    def _add_info_row(self, container, label, value):
        container.addView(UI.info_row(self.context, label, value))

    def _create_button_row(self, *buttons):
        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setGravity(Gravity.CENTER)
        btn_container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
        )

        for i, btn in enumerate(buttons):
            if btn:
                params = LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.BTN_H), 1.0)
                if i > 0:
                    params.setMargins(AndroidUtilities.dp(Dp.S8), 0, 0, 0)
                btn_container.addView(btn, params)

        return btn_container


# –º–æ–¥–µ–ª—å–∫–∏
class Pet:
    def __init__(self, chat_id, plugin_ref=None):
        self.chat_id = chat_id
        self.xp = 0
        self.stage = 0
        self.level = 1
        self.name = self._gen_name()
        self.mood = 100
        self.hunger = 100
        self.last_feed_time = time.time()
        self.last_update_time = time.time()
        self.last_sync_timestamp = time.time()
        self.deleted = False
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def _gen_name(self):
        if isEn():
            names = [
                "Buddy",
                "Weed",
                "Pixel",
                "Ame",
                "Zhirnostb",
                "Stich",
                "Epstein",
                "Sunny",
                "Milo",
                "Pip",
            ]
        else:
            names = [
                "–ì—Ä—É—à–∞",
                "–ë–µ–ª—ã–π",
                "–ú–∞—Ä—å—è –ò–≤–∞–Ω–Ω–æ–≤–Ω–∞",
                "–õ–æ–∫—Å",
                "–ß–µ—Ä–µ—à–Ω—è",
                "–ó–∞–ª—É–ø—ã—á",
                "–ñ–∏—Ä–Ω–æ—Å—Ç—å",
                "–ö–æ—à–∞–∫",
                "–î—Ä–∞–∫–æ—à–∞",
                "–ù–∏–º–∞—Ä–∫",
                "–ê–º–µ",
                "–¢–æ–º–æ–∫–æ",
                "–ú–∏—à–∞",
                "–ù—è—à–∫–∞",
            ]
        return random.choice(names)

    def update_state(self):
        current_time = time.time()
        hours_passed = (current_time - self.last_update_time) / SECONDS_PER_HOUR

        if hours_passed > 0:
            self.hunger = max(
                0, self.hunger - (HUNGER_CONFIG["decrease_per_hour"] * hours_passed)
            )

            if self.hunger < MOOD_CONFIG["hunger_penalty_threshold"]:
                penalty = MOOD_CONFIG["mood_decrease_per_hour"] * hours_passed * 1.5
                self.mood = max(MOOD_CONFIG["min_mood"], self.mood - penalty)

            self.last_update_time = current_time
            self.last_sync_timestamp = current_time

    def feed(self):
        self.update_state()

        old_hunger = self.hunger
        self.hunger = min(
            HUNGER_CONFIG["max_hunger"], self.hunger + HUNGER_CONFIG["feed_restore"]
        )
        self.last_feed_time = time.time()

        mood_bonus = (
            FEED_MOOD_BONUS_HIGH
            if old_hunger < HUNGER_CONFIG["critical_level"]
            else FEED_MOOD_BONUS_LOW
        )
        self.mood = min(MOOD_CONFIG["max_mood"], self.mood + mood_bonus)

        self.last_sync_timestamp = time.time()

        return XP_REWARDS.get("feed", 10)

    def play(self):
        self.update_state()

        if self.hunger < HUNGER_CONFIG["critical_level"]:
            return 0

        self.mood = min(MOOD_CONFIG["max_mood"], self.mood + PLAY_MOOD_BONUS)
        self.hunger = max(0, self.hunger - PLAY_HUNGER_COST)
        self.last_sync_timestamp = time.time()

        return XP_REWARDS.get("play", 15)

    def get_xp_multiplier(self):
        multiplier = 1.0

        if self.mood >= MOOD_HIGH_THRESHOLD:
            multiplier *= MULTIPLIER_MOOD_HIGH
        elif self.mood >= MOOD_MEDIUM_THRESHOLD:
            multiplier *= MULTIPLIER_MOOD_MEDIUM
        elif self.mood >= HUNGER_CONFIG["critical_level"]:
            multiplier *= MULTIPLIER_MOOD_LOW
        else:
            multiplier *= MULTIPLIER_MOOD_CRITICAL

        if self.hunger < HUNGER_CONFIG["critical_level"]:
            multiplier *= MULTIPLIER_HUNGER_CRITICAL
        elif self.hunger < HUNGER_MEDIUM_THRESHOLD:
            multiplier *= MULTIPLIER_HUNGER_LOW

        return multiplier

    def add_xp(self, amount):
        self.update_state()

        old_stage = self.stage
        old_level = self.level

        multiplier = self.get_xp_multiplier()
        final_xp = int(amount * multiplier)

        self.xp = min(self.xp + final_xp, MAX_PET_XP)

        for stage_num, stage_data in sorted(PET_STAGES.items(), reverse=True):
            if self.xp >= stage_data["xp"]:
                self.stage = stage_num
                break

        if self.stage < len(PET_STAGES) - 1:
            current_stage_xp = PET_STAGES[self.stage]["xp"]
            next_stage_xp = PET_STAGES[self.stage + 1]["xp"]
            stage_xp_range = next_stage_xp - current_stage_xp
            xp_in_stage = self.xp - current_stage_xp
            self.level = min(10, int((xp_in_stage / stage_xp_range) * 10) + 1)
        else:
            self.level = 10

        evolved = self.stage > old_stage

        if evolved:
            self.mood = 100
            self.hunger = 100
            self.level = 1

        self.last_sync_timestamp = time.time()

        return evolved

    def get_status_emoji(self):
        self.update_state()
        if self.hunger < HUNGER_CONFIG["critical_level"]:
            return "üíÄ"
        return ""

    def get_emoji(self):
        emoji_style = 0
        if self.plugin_ref:
            emoji_style = self.plugin_ref.get_setting("pet_emoji_style", 0)

        stages = PET_STAGES_BY_STYLE.get(emoji_style, PET_STAGES_BY_STYLE[0])
        base_emoji = stages[self.stage]["emoji"]

        status_emoji = self.get_status_emoji()
        if status_emoji:
            return f"{base_emoji}{status_emoji}"

        return base_emoji

    def get_stage_name(self):
        emoji_style = 0
        if self.plugin_ref:
            emoji_style = self.plugin_ref.get_setting("pet_emoji_style", 0)

        stages = PET_STAGES_BY_STYLE.get(emoji_style, PET_STAGES_BY_STYLE[0])
        name = stages[self.stage]["name"]
        return PET_STAGE_NAME_EN.get(name, name) if isEn() else name

    def xp_to_next_stage(self):
        current_stage = self.stage
        if current_stage >= len(PET_STAGES) - 1:
            return 0
        next_stage_xp = PET_STAGES[current_stage + 1]["xp"]
        return next_stage_xp - self.xp

    def to_dict(self):
        return {
            "chat": self.chat_id,
            "xp": self.xp,
            "stage": self.stage,
            "level": self.level,
            "name": self.name,
            "mood": self.mood,
            "hunger": self.hunger,
            "last_feed": self.last_feed_time,
            "last_update": self.last_update_time,
            "last_sync": self.last_sync_timestamp,
            "deleted": self.deleted,
        }

    def get_sync_data(self):
        self.update_state()
        return {
            "xp": self.xp,
            "stage": self.stage,
            "level": self.level,
            "name": self.name,
            "mood": self.mood,
            "hunger": self.hunger,
            "last_feed": self.last_feed_time,
            "last_update": self.last_update_time,
            "timestamp": self.last_sync_timestamp,
            "deleted": self.deleted,
        }

    def _sanitize_sync_data(self, sync_data):
        if not isinstance(sync_data, dict):
            self.log("WSP: invalid sync_data format - rejecting sync")
            return None

        xp = sync_data.get("xp")
        if xp is None or not isinstance(xp, (int, float)) or xp < 0 or xp > MAX_PET_XP:
            self.log(f"WSP: invalid xp value: {xp} - rejecting sync")
            return None

        stage = sync_data.get("stage")
        if (
            stage is None
            or not isinstance(stage, int)
            or stage < 0
            or stage >= len(PET_STAGES)
        ):
            self.log(f"WSP: invalid stage value: {stage} - rejecting sync")
            return None

        level = sync_data.get("level")
        if level is None:
            if stage < len(PET_STAGES) - 1:
                current_stage_xp = PET_STAGES[stage]["xp"]
                next_stage_xp = PET_STAGES[stage + 1]["xp"]
                stage_xp_range = next_stage_xp - current_stage_xp
                xp_in_stage = xp - current_stage_xp
                level = min(10, max(1, int((xp_in_stage / stage_xp_range) * 10) + 1))
            else:
                level = 10
        elif not isinstance(level, int) or level < 1 or level > MAX_PET_LEVEL:
            self.log(f"WSP: invalid level value: {level}, calculating from xp")
            level = 1

        name = sync_data.get("name", self.name)
        if not isinstance(name, str) or len(name) > MAX_PET_NAME_LENGTH:
            self.log(f"WSP: invalid name, keeping current: {self.name}")
            name = self.name

        mood = sync_data.get("mood", self.mood)
        if (
            not isinstance(mood, (int, float))
            or mood < 0
            or mood > MOOD_CONFIG["max_mood"]
        ):
            self.log(f"WSP: invalid mood, keeping current: {self.mood}")
            mood = self.mood

        last_feed = V.ts(sync_data.get("last_feed"), self.last_feed_time)

        hunger = sync_data.get("hunger")
        if hunger is None:
            hours_since_feed = (time.time() - last_feed) / SECONDS_PER_HOUR
            hunger = max(
                0,
                HUNGER_CONFIG["max_hunger"]
                - (HUNGER_CONFIG["decrease_per_hour"] * hours_since_feed),
            )
        elif (
            not isinstance(hunger, (int, float))
            or hunger < 0
            or hunger > HUNGER_CONFIG["max_hunger"]
        ):
            self.log(f"WSP: invalid hunger, keeping current: {self.hunger}")
            hunger = self.hunger

        return {
            "xp": int(xp),
            "stage": stage,
            "level": level,
            "name": name,
            "mood": mood,
            "hunger": hunger,
            "last_feed": last_feed,
            "last_update": V.ts(sync_data.get("last_update"), self.last_update_time),
            "timestamp": V.ts(sync_data.get("timestamp"), self.last_sync_timestamp),
            "deleted": V.bool_or(sync_data.get("deleted", False)),
        }

    def apply_sync_data(self, sync_data, source="unknown"):
        sanitized = self._sanitize_sync_data(sync_data)
        if not sanitized:
            return

        self.log(
            f"WSP: applying {source} sync data for chat {self.chat_id}: xp={sanitized['xp']}, stage={sanitized['stage']}, level={sanitized['level']}"
        )
        self.xp = sanitized["xp"]
        self.stage = sanitized["stage"]
        self.level = sanitized["level"]
        self.name = sanitized["name"]
        self.mood = sanitized["mood"]
        self.hunger = sanitized["hunger"]
        self.last_feed_time = sanitized["last_feed"]
        self.last_update_time = sanitized["last_update"]
        self.last_sync_timestamp = sanitized["timestamp"]
        self.deleted = sanitized["deleted"]

    @staticmethod
    def from_dict(data, plugin_ref=None):
        pet = Pet(data["chat"], plugin_ref=plugin_ref)
        pet.xp = data.get("xp", 0)
        pet.stage = data.get("stage", 0)
        pet.level = data.get("level", 1)
        pet.name = data.get("name", "–ß–µ–±—É—Ä–∞—à–∫–∞")
        pet.mood = data.get("mood", 100)
        pet.hunger = data.get("hunger", 100)
        pet.last_feed_time = data.get("last_feed", time.time())
        pet.last_update_time = data.get("last_update", time.time())
        pet.last_sync_timestamp = data.get("last_sync", 0)
        pet.deleted = data.get("deleted", False)
        return pet

    def cleanup(self):
        self._plugin_ref = None


# —Å–∏–Ω—Ö—Ä–∞
class StreakSyncManager:
    SYNC_MESSAGE_PREFIX = "\u200b\u200c\u200d"
    MODE_P2P = "p2p"
    MODE_SERVER = "server"
    MODE_AUTO = "auto"
    SERVER_URL = "https://api.watamotestreakpet.win"

    def __init__(self, mode="p2p", server_url=None, enable_fallback=True):
        self.mode = mode
        self.server_url = server_url or self.SERVER_URL
        self.enable_fallback = enable_fallback
        self.server_available = True
        self.server_degraded = False
        self.last_server_check = 0
        self.server_check_interval = 60
        self.health_min_interval = 60
        self.health_max_interval = 600
        self._health_backoff = self.health_min_interval
        self._next_health_check = 0
        self.last_health_ok = 0
        self.health_grace = 120
        self.cache = {}
        self.cache_ttl = 60
        self.max_cache_size = 100
        self.cache_writes = 0
        self.last_save_times = {}
        self.save_throttle_interval = 2
        self.sync_frequency = 120
        self.min_sync_frequency = 60
        self.max_sync_frequency = 300
        self.last_activity_time = time.time()
        self.activity_threshold = 120
        self.log = log
        self.token = None
        self.tokenExp = 0
        self.installId = None
        self.last_error = None
        self.retryBase = 0.5
        self.retryJitter = 0.7
        self.authWaitUntil = 0
        self.rateWaitUntil = 0
        self.maxTmp = 2000
        self.userIdHash = None
        self.devKey = None
        self._cache_lock = threading.Lock()
        self._http_lock = threading.Lock()
        self._health_lock = threading.Lock()
        self._token_lock = threading.Lock()

    def _hash_user_id(self, user_id):
        user_id_str = str(user_id)
        return hashlib.sha256(user_id_str.encode()).hexdigest()

    def clientKey(self, user1, user2):
        hashA = self._hash_user_id(user1)
        hashB = self._hash_user_id(user2)
        ids = sorted([hashA, hashB])
        return f"{ids[0]}:{ids[1]}"

    def sortHashIds(self, user_id_a, user_id_b):
        idA, idB = self.sortIds(user_id_a, user_id_b)
        hashA = self._hash_user_id(idA)
        hashB = self._hash_user_id(idB)
        return idA, idB, hashA, hashB

    def throttleSave(self, saveKey):
        current_time = time.time()
        last_save = self.last_save_times.get(saveKey, 0)
        if current_time - last_save < self.save_throttle_interval:
            self.log(
                f"WSP: save throttled for {saveKey}, last save {current_time - last_save:.1f}s ago"
            )
            return True
        self.last_save_times[saveKey] = current_time
        return False

    def setInstallId(self, installId):
        self.installId = installId

    def setUserId(self, userId):
        try:
            if not userId:
                return
            if isinstance(userId, str) and len(userId) >= 40:
                new_hash = userId
            else:
                new_hash = self._hash_user_id(userId)
            if new_hash != self.userIdHash:
                self.userIdHash = new_hash
                self.token = None
                self.tokenExp = 0
        except Exception:
            pass

    def setDevKey(self, devKey):
        try:
            if not devKey or not isinstance(devKey, str):
                return
            if devKey != self.devKey:
                self.devKey = devKey
        except Exception:
            pass

    def tokenExpired(self):
        return not self.token or time.time() >= self.tokenExp

    def fetchToken(self):
        if not self.installId or not self.userIdHash or not self.devKey:
            return False
        url = f"{self.server_url}/api/v1/auth/guest"
        payload = {
            "install_id": self.installId,
            "user_id": self.userIdHash,
            "devkey": self.devKey,
        }
        result, error = self._make_http_request(
            url,
            method="POST",
            data=payload,
            retries=2,
            useAuth=False,
        )
        if result and result.get("status") == "success":
            token = result.get("token")
            exp = result.get("exp")
            ttl = result.get("expires_in", 0)
            if not exp:
                exp = time.time() + float(ttl or 0)
            self.token = token
            self.tokenExp = float(exp) - 3
            return True
        return False

    def ensureToken(self, force=False):
        if not force and not self.tokenExpired():
            return True
        with self._token_lock:
            if not force and not self.tokenExpired():
                return True
            return self.fetchToken()

    def getCached(self, cacheKey):
        cached = self.cacheGet(cacheKey)
        if not cached:
            return None
        if cached.get("deleted", False):
            self.cache.pop(cacheKey, None)
            return None
        return self.attachRemoteMeta(cached)

    def fetchEntity(
        self,
        url,
        cacheKey,
        user1Id,
        user2Id,
        logFound,
        logNotFound,
        logFailed,
    ):
        result, error = self._make_http_request(
            url, method="GET", retries=2, user1_id=user1Id, user2_id=user2Id
        )

        if result and result.get("status") == "found":
            data = result.get("data")
            self.cacheSet(cacheKey, data)
            server_time = result.get("_server_time")
            logFound(data)
            return self.attachRemoteMeta(data, server_time=server_time)
        if result:
            logNotFound(result.get("status"))
            return None
        logFailed(error)
        return None

    def saveEntity(
        self,
        url,
        payloadKey,
        cacheKey,
        saveKey,
        data,
        user1Id,
        user2Id,
        logStart,
        logSuccess,
        logFailStatus,
        logFailError,
    ):
        if self.throttleSave(saveKey):
            self.last_error = "throttled"
            return False

        payload = {
            "user1_id": user1Id,
            "user2_id": user2Id,
            payloadKey: self.withClientTime(data),
        }
        logStart()

        result, error = self._make_http_request(
            url,
            method="POST",
            data=payload,
            retries=3,
            user1_id=user1Id,
            user2_id=user2Id,
        )

        if result and result.get("status") in ["saved", "kept_local"]:
            status = result.get("status")
            final_data = data if status == "kept_local" else result.get("data", data)
            self.cacheSet(cacheKey, final_data)
            action = result.get("action", "unknown")
            logSuccess(status, action, final_data)
            self.last_error = None
            return True
        if result:
            self.last_error = (
                result.get("message") or result.get("status") or "server_error"
            )
            logFailStatus(result)
            return False
        logFailError(error)
        return False

    def withClientTime(self, data):
        if not isinstance(data, dict):
            return data
        payload = dict(data)
        payload["client_time"] = time.time()
        return payload

    def attachRemoteMeta(self, data, server_time=None):
        if not isinstance(data, dict):
            return data
        payload = dict(data)
        if server_time:
            payload["_server_time"] = server_time
        payload["_client_received_at"] = time.time()
        return payload

    def retryDelay(self, attempt):
        return (self.retryBase * (2 ** attempt)) + random.uniform(
            0, self.retryJitter
        )

    def _make_http_request(
        self,
        url,
        method="GET",
        data=None,
        retries=3,
        user1_id=None,
        user2_id=None,
        headers=None,
        useAuth=True,
    ):
        last_error_msg = None
        self.last_error = None
        authRefreshed = False

        def sleepRetry(attempt):
            time.sleep(self.retryDelay(attempt))

        for attempt in range(retries):
            try:
                now = time.time()
                if now < self.rateWaitUntil:
                    self.last_error = "rate_limited"
                    return None, "rate_limited"
                if useAuth and now < self.authWaitUntil:
                    self.last_error = "auth_wait"
                    return None, "auth_wait"

                req_headers = {"User-Agent": "WSP/2.0"}

                if useAuth:
                    if not self.ensureToken():
                        self.last_error = "auth_failed"
                        last_error_msg = "auth_failed"
                        break
                    if self.token:
                        req_headers["Authorization"] = f"Bearer {self.token}"
                    if self.installId:
                        req_headers["X-Install-Id"] = self.installId

                if headers:
                    req_headers.update(headers)

                body = b""
                if method == "POST" and data:
                    body = json.dumps(data).encode("utf-8")
                    req_headers["Content-Type"] = "application/json"

                if self.devKey:
                    try:
                        parsed = urllib.parse.urlparse(url)
                        path = parsed.path
                        if parsed.query:
                            path = f"{path}?{parsed.query}"
                        reqTs = str(int(time.time()))
                        reqNonce = secrets.token_hex(8)
                        base = f"{method}|{path}|{reqTs}|{reqNonce}|".encode("utf-8")
                        sig = hmac.new(
                            self.devKey.encode(), base + body, hashlib.sha256
                        ).hexdigest()
                        req_headers["X-Req-Ts"] = reqTs
                        req_headers["X-Req-Nonce"] = reqNonce
                        req_headers["X-Req-Sig"] = sig
                    except Exception:
                        pass

                if method == "POST" and body:
                    req = urllib.request.Request(
                        url, data=body, headers=req_headers, method="POST"
                    )
                else:
                    req = urllib.request.Request(url, headers=req_headers, method=method)

                timeout = HTTP_TIMEOUT_FIRST if attempt == 0 else HTTP_TIMEOUT_RETRY

                with self._http_lock:
                    with urllib.request.urlopen(req, timeout=timeout) as response:
                        result = json.loads(response.read().decode("utf-8"))
                        if (
                            isinstance(result, list)
                            and len(result) == 2
                            and isinstance(result[0], dict)
                        ):
                            result = dict(result[0])
                            if isinstance(result[1], int):
                                result["_http_status"] = result[1]
                        try:
                            import email.utils

                            date_header = response.headers.get("Date")
                            if date_header:
                                parsed = email.utils.parsedate_to_datetime(date_header)
                                if parsed:
                                    result["_server_time"] = parsed.timestamp()
                        except Exception:
                            pass
                        self.server_available = True
                        return result, None

            except urllib.error.HTTPError as e:
                last_error_msg = f"HTTP {e.code}: {e.reason}"
                self.log(
                    f"WSP: HTTP error on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                now = time.time()
                if useAuth and e.code in (401, 403):
                    self.token = None
                    self.tokenExp = 0
                    if not authRefreshed:
                        self.authWaitUntil = max(self.authWaitUntil, now + 10)
                        if self.ensureToken(force=True):
                            authRefreshed = True
                            continue
                if useAuth and e.code == 429:
                    self.last_error = "rate_limited"
                    delay = self.retryDelay(attempt)
                    self.rateWaitUntil = max(self.rateWaitUntil, now + delay + 10)
                    time.sleep(min(delay, 5))
                    if attempt < retries - 1:
                        continue
                error_msg = None
                try:
                    error_body = e.read().decode("utf-8")
                    self.log(f"WSP: error response body: {error_body}")
                    try:
                        parsed = json.loads(error_body)
                        error_msg = parsed.get("message") or parsed.get("status")
                    except Exception:
                        pass
                except Exception:
                    pass
                if error_msg:
                    self.last_error = error_msg
                elif e.code in (401, 403):
                    self.last_error = "auth_failed"
                elif e.code >= HTTP_SERVER_ERROR_THRESHOLD:
                    self.last_error = "server_error"
                else:
                    self.last_error = "bad_request"
                self.server_available = True
                self.server_degraded = e.code >= HTTP_SERVER_ERROR_THRESHOLD
                if e.code >= HTTP_SERVER_ERROR_THRESHOLD:
                    if attempt < retries - 1:
                        sleepRetry(attempt)
                        continue
                break

            except urllib.error.URLError as e:
                last_error_msg = f"URL Error: {e.reason}"
                self.last_error = "network"
                self.log(
                    f"WSP: URL error on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                if attempt < retries - 1:
                    sleepRetry(attempt)
                    continue

            except Exception as e:
                last_error_msg = str(e)
                self.last_error = "exception"
                self.log(
                    f"WSP: exception on attempt {attempt + 1}/{retries}: {last_error_msg}"
                )
                if attempt < retries - 1:
                    sleepRetry(attempt)
                    continue

        if self.last_error in ("network", "exception"):
            self.server_available = False
            self.server_degraded = False
        elif self.last_error in ("server_error", "db_busy"):
            self.server_available = True
            self.server_degraded = True
        elif self.last_error:
            self.server_available = True
            self.server_degraded = False
        else:
            self.server_available = False
            self.server_degraded = False
        final_error = last_error_msg or self.last_error or "unknown_error"
        self.log(f"WSP server request failed after {retries} attempts: {final_error}")
        return None, final_error

    def checkServerHealth(self):
        current_time = time.time()

        if current_time < self._next_health_check:
            return self.server_available

        with self._health_lock:
            if current_time < self._next_health_check:
                return self.server_available

            self.last_server_check = current_time

            try:
                url = f"{self.server_url}/health"
                self.log("WSP: checking server health")
                result, error = self._make_http_request(
                    url, method="GET", retries=3, useAuth=False
                )

                status = result.get("status") if result else None
                is_healthy = status in ["ok", "degraded"]
                self.server_available = bool(is_healthy)
                self.server_degraded = status == "degraded"
                if is_healthy:
                    self.last_health_ok = current_time
                    self._health_backoff = self.health_min_interval
                    self._next_health_check = current_time + self._health_backoff
                    self.log(f"WSP server health check: OK (result={result})")
                    return True
                self.log(
                    f"WSP server health check failed: error={error}, result={result}"
                )
                if (
                    self.last_health_ok
                    and (current_time - self.last_health_ok) <= self.health_grace
                ):
                    self.log("WSP: using health grace window, keeping server available")
                    self._health_backoff = min(
                        self._health_backoff * 2, self.health_max_interval
                    )
                    self._next_health_check = current_time + self._health_backoff
                    return True
                self.server_degraded = False
                self._health_backoff = min(
                    self._health_backoff * 2, self.health_max_interval
                )
                self._next_health_check = current_time + self._health_backoff
                return False

            except Exception as e:
                if (
                    self.last_health_ok
                    and (current_time - self.last_health_ok) <= self.health_grace
                ):
                    self.log(
                        f"WSP: health check error within grace window: {e}"
                    )
                    self._health_backoff = min(
                        self._health_backoff * 2, self.health_max_interval
                    )
                    self._next_health_check = current_time + self._health_backoff
                    return True
                self.server_available = False
                self.server_degraded = False
                self._health_backoff = min(
                    self._health_backoff * 2, self.health_max_interval
                )
                self._next_health_check = current_time + self._health_backoff
                self.log(f"WSP server health check error: {e}")

                self.log(f"WSP health check traceback: {traceback.format_exc()}")
                return False

    def sortIds(self, user_id_a, user_id_b):
        return sorted([int(user_id_a), int(user_id_b)])

    def cacheKey(self, user_id_a, user_id_b):
        ids = self.sortIds(user_id_a, user_id_b)
        return f"streak_{ids[0]}_{ids[1]}"

    def cacheGet(self, cacheKey):
        with self._cache_lock:
            cached = self.cache.get(cacheKey)
            if not cached:
                return None
            cached_data, cached_time = cached
            if time.time() - cached_time < self.cache_ttl:
                return cached_data
            self.cache.pop(cacheKey, None)
            return None

    def cacheSet(self, cacheKey, data):
        with self._cache_lock:
            self.cache[cacheKey] = (data, time.time())

            self.cache_writes += 1
            if self.cache_writes % 10 == 0:
                self.cleanCacheCore()

    def cleanCacheCore(self):
        now = time.time()

        expired_keys = [
            key
            for key, (data, timestamp) in self.cache.items()
            if now - timestamp > self.cache_ttl
        ]

        for key in expired_keys:
            del self.cache[key]

        if len(self.cache) > self.max_cache_size:
            sorted_items = sorted(self.cache.items(), key=lambda x: x[1][1])
            remove_count = len(self.cache) - self.max_cache_size
            for key, _ in sorted_items[:remove_count]:
                del self.cache[key]

    def cleanCache(self):
        try:
            with self._cache_lock:
                self.cleanCacheCore()
        except Exception as e:
            self.log(f"WSP: cache cleanup error: {e}")

    def get_streak_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: get_streak_from_server skipped, mode={self.mode}")
            return None

        cacheKey = self.cacheKey(userA, userB)
        cached = self.getCached(cacheKey)
        if cached:
            return cached

        if not self.checkServerHealth():
            self.log("WSP server unavailable, skipping get request")
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/streak/{hashA}/{hashB}"
            return self.fetchEntity(
                url,
                cacheKey,
                hashA,
                hashB,
                lambda data: self.log(
                    f"WSP streak loaded from server: {cacheKey}, data={data}"
                ),
                lambda status: self.log(
                    f"WSP streak not found on server: status={status}"
                ),
                lambda error: self.log(f"WSP get request failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP get_streak_from_server error: {e}")

            self.log(f"WSP get_streak traceback: {traceback.format_exc()}")
            return None

    def save_streak_to_server(self, userA, userB, streak_data):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: save_streak_to_server skipped, mode={self.mode}")
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            self.log("WSP server unavailable, skipping save")
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            saveKey = f"streak_{idA}_{idB}"
            cacheKey = self.cacheKey(userA, userB)
            url = f"{self.server_url}/api/v1/streak"

            return self.saveEntity(
                url,
                "streak_data",
                cacheKey,
                saveKey,
                streak_data,
                hashA,
                hashB,
                lambda: self.log(
                    f"WSP: saving streak (original: {userA}/{userB}, sorted: {idA}/{idB})"
                ),
                lambda status, action, final_data: self.log(
                    f"WSP streak {status} (action={action}): {cacheKey}, count={final_data.get('count')}"
                ),
                lambda result: self.log(
                    f"WSP save failed with status: {result.get('status')}, result={result}"
                ),
                lambda error: self.log(f"WSP save failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP save_streak_to_server error: {e}")

            self.log(f"WSP save_streak traceback: {traceback.format_exc()}")
            return False

    @staticmethod
    @staticmethod
    def create_sync_message(streak_data=None, pet_data=None, chat_id=None, key=None, offer=False):
        sync_payload = {"timestamp": time.time(), "v": 2}

        if streak_data:
            sync_payload["streak"] = {
                "count": streak_data.get("count", 0),
                "last_date": streak_data.get("last_date"),
                "first_date": streak_data.get("first_date"),
                "deleted": streak_data.get("deleted", False),
                "timestamp": streak_data.get("timestamp", time.time()),
                "last_message_time": streak_data.get("last_message_time", time.time()),
                "warning_since": streak_data.get("warning_since"),
                "dead_since": streak_data.get("dead_since"),
                "dead_count": streak_data.get("dead_count", 0),
                "restores_this_month": streak_data.get("restores_this_month", 0),
                "last_restore_month": streak_data.get("last_restore_month"),
            }

        if pet_data:
            sync_payload["pet"] = {
                "xp": pet_data.get("xp", 0),
                "stage": pet_data.get("stage", 0),
                "level": pet_data.get("level", 1),
                "name": pet_data.get("name", ""),
                "mood": pet_data.get("mood", 100),
                "hunger": pet_data.get("hunger", 100),
                "last_feed": pet_data.get("last_feed", time.time()),
                "last_update": pet_data.get("last_update", time.time()),
                "timestamp": pet_data.get("timestamp", time.time()),
                "deleted": pet_data.get("deleted", False),
            }

        json_data = json.dumps(sync_payload, separators=(',', ':')).encode("utf-8")
        sig = None
        if key:
            if offer:
                sync_payload["k"] = key
            sig = hmac.new(key.encode(), json_data, hashlib.sha256).hexdigest()[:16]
        else:
            return None

        if sig:
            sync_payload["sig"] = sig
            json_data = json.dumps(sync_payload, separators=(',', ':')).encode("utf-8")

        compressed = zlib.compress(json_data, 9)
        hidden = packZws(compressed)
        return f"{SYNC_PREFIX}{hidden}"

    @staticmethod
    def parse_sync_message(message, chat_id=None, key=None):
        if not isinstance(message, str):
            return None

        if not any(c in ZW_REV for c in message):
            return None

        if chat_id is None:
            return None

        try:
            raw_data = unpackZws(message)
            if not raw_data:
                return None

            if len(raw_data) > MAX_DATA_SIZE_BYTES:
                log("WSP: sync message too large (>1MB)")
                return None

            decomp = zlib.decompressobj()
            decompressed = decomp.decompress(raw_data, MAX_DATA_SIZE_BYTES + 1)
            if decomp.unconsumed_tail:
                log("WSP: decompressed sync message too large (>1MB)")
                return None
            tail = decomp.flush()
            if len(decompressed) + len(tail) > MAX_DATA_SIZE_BYTES:
                log("WSP: decompressed sync message too large (>1MB)")
                return None
            decompressed += tail

            data = json.loads(decompressed.decode("utf-8"))

            if not isinstance(data, dict):
                log("WSP: sync message data is not a dict")
                return None

            msg_version = data.get("v")
            if msg_version != 2:
                log(f"WSP: unsupported sync message version: {msg_version}")
                return None

            if not key:
                log("WSP: P2P key missing, rejecting")
                return None

            received_sig = data.get("sig")
            data_for_verify = {k: v for k, v in data.items() if k != "sig"}
            json_for_verify = json.dumps(data_for_verify, separators=(',', ':')).encode("utf-8")

            if not received_sig:
                log("WSP: P2P message missing signature, rejecting")
                return None
            expected_sig = hmac.new(
                key.encode(), json_for_verify, hashlib.sha256
            ).hexdigest()[:16]
            if received_sig != expected_sig:
                log("WSP: P2P signature mismatch, rejecting")
                return None

            msg_ts = data.get("timestamp")
            if msg_ts is not None and not StreakSyncManager._validate_timestamp(msg_ts):
                log("WSP: sync message timestamp out of range, ignoring")
                return None

            return data
        except (zlib.error, json.JSONDecodeError, UnicodeDecodeError, ValueError) as e:
            log(f"WSP: parse sync message error: {e}")
            return None
        except Exception as e:
            log(f"WSP: unexpected parse error: {e}")
            return None

    @staticmethod
    def _validate_timestamp(remote_ts, reference_time=None):
        current_time = reference_time if reference_time is not None else time.time()

        if remote_ts > current_time + TIMESTAMP_TOLERANCE_SECONDS:
            return False

        if remote_ts < current_time - ONE_DAY_SECONDS:
            return False

        return True

    @staticmethod
    def should_accept_sync(local_data, remote_data, ignore_local_priority=False):
        if not remote_data:
            return False

        remote_ts = remote_data.get("timestamp", 0)

        reference_time = remote_data.get("_server_time") or remote_data.get(
            "_client_received_at"
        )
        if not StreakSyncManager._validate_timestamp(remote_ts, reference_time):
            return False

        if not local_data:
            return True

        local_ts = local_data.get("timestamp", 0)
        if not ignore_local_priority and local_ts and reference_time:
            if reference_time - local_ts < LOCAL_PRIORITY_SECONDS:
                if remote_ts <= local_ts + LOCAL_PRIORITY_SECONDS:
                    return False

        if remote_ts > local_ts + 5:
            return True
        if local_ts > remote_ts + 5:
            return False
        if "count" in remote_data or "count" in local_data:
            remote_val = remote_data.get("count", 0)
            local_val = local_data.get("count", 0)
        elif "xp" in remote_data or "xp" in local_data:
            remote_val = remote_data.get("xp", 0)
            local_val = local_data.get("xp", 0)
        else:
            return False
        return remote_val > local_val

    def get_pet_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: get_pet_from_server skipped, mode={self.mode}")
            return None

        cacheKey = "pet_" + self.cacheKey(userA, userB)
        cached = self.getCached(cacheKey)
        if cached:
            return cached

        if not self.checkServerHealth():
            self.log("WSP server unavailable, skipping pet get request")
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/pet/{hashA}/{hashB}"
            return self.fetchEntity(
                url,
                cacheKey,
                hashA,
                hashB,
                lambda data: self.log(
                    f"WSP pet loaded from server: {cacheKey}, xp={data.get('xp')}, stage={data.get('stage')}"
                ),
                lambda status: self.log(
                    f"WSP pet not found on server: status={status}"
                ),
                lambda error: self.log(f"WSP get pet request failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP get_pet_from_server error: {e}")

            self.log(f"WSP get_pet traceback: {traceback.format_exc()}")
            return None

    def save_pet_to_server(self, userA, userB, pet_data):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            self.log(f"WSP: save_pet_to_server skipped, mode={self.mode}")
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            self.log("WSP server unavailable, skipping pet save")
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            saveKey = f"pet_{idA}_{idB}"
            cacheKey = "pet_" + self.cacheKey(userA, userB)
            url = f"{self.server_url}/api/v1/pet"

            return self.saveEntity(
                url,
                "pet_data",
                cacheKey,
                saveKey,
                pet_data,
                hashA,
                hashB,
                lambda: self.log(
                    f"WSP: saving pet (original: {userA}/{userB}, sorted: {idA}/{idB}), xp={pet_data.get('xp')}, stage={pet_data.get('stage')}"
                ),
                lambda status, action, final_data: self.log(
                    f"WSP pet {status} (action={action}): {cacheKey}, xp={final_data.get('xp')}, stage={final_data.get('stage')}"
                ),
                lambda result: self.log(
                    f"WSP pet save failed with status: {result.get('status')}, result={result}"
                ),
                lambda error: self.log(f"WSP pet save failed: {error}"),
            )

        except Exception as e:
            self.log(f"WSP save_pet_to_server error: {e}")

            self.log(f"WSP save_pet traceback: {traceback.format_exc()}")
            return False

    def getP2pSrv(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return None

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return None

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            url = f"{self.server_url}/api/v1/p2pkey/{hashA}/{hashB}"
            result, error = self._make_http_request(
                url,
                method="GET",
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )
            if result and result.get("status") == "found":
                return result.get("key")
            return None
        except Exception as e:
            self.log(f"WSP get_p2p_key error: {e}")
            return None

    def setP2pSrv(self, userA, userB, key):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return False

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)
            url = f"{self.server_url}/api/v1/p2pkey"
            payload = {
                "user1_id": hashA,
                "user2_id": hashB,
                "key": key,
            }
            result, error = self._make_http_request(
                url,
                method="POST",
                data=payload,
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )
            return bool(result and result.get("status") == "saved")
        except Exception as e:
            self.log(f"WSP save_p2p_key error: {e}")
            return False

    def delete_pet_from_server(self, userA, userB):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return False

        if not self.checkServerHealth():
            return False

        try:
            idA, idB, hashA, hashB = self.sortHashIds(userA, userB)

            url = f"{self.server_url}/api/v1/pet/{hashA}/{hashB}"
            result, error = self._make_http_request(
                url,
                method="DELETE",
                retries=2,
                user1_id=hashA,
                user2_id=hashB,
            )

            if result and result.get("status") == "deleted":
                self.log(f"WSP: pet deleted from server: {idA}/{idB}")
                return True
            else:
                self.log(f"WSP: pet delete failed: {result}")
                return False

        except Exception as e:
            self.log(f"WSP delete_pet_from_server error: {e}")
            return False

    def update_activity(self):
        now = time.time()
        elapsed = now - self.last_activity_time
        self.last_activity_time = now
        current_frequency = self.sync_frequency
        if elapsed < self.activity_threshold:
            self.sync_frequency = max(self.min_sync_frequency, self.sync_frequency - 10)
        else:
            self.sync_frequency = min(self.max_sync_frequency, self.sync_frequency + 20)

        if current_frequency != self.sync_frequency:
            self.log(
                f"WSP: sync frequency adjusted to {self.sync_frequency}s (was {current_frequency}s)"
            )

    def get_sync_interval(self):
        return self.sync_frequency

    def batch_sync(self, myId, streakList, petList):
        if self.mode not in [self.MODE_SERVER, self.MODE_AUTO]:
            return None

        if not self.checkServerHealth():
            self.last_error = "server_unavailable"
            return None
        if not myId or myId <= 0:
            self.last_error = "invalid_user_id"
            return None

        try:
            url = f"{self.server_url}/api/v1/batch/sync"
            myHash = self._hash_user_id(myId)

            def addPayload(items, chat_id, data):
                otherId = int(chat_id)
                ids = self.sortIds(myId, otherId)
                hashA = self._hash_user_id(ids[0])
                hashB = self._hash_user_id(ids[1])
                items.append(
                    {
                        "user1_id": hashA,
                        "user2_id": hashB,
                        **self.withClientTime(data),
                    }
                )

            streaks_payload = []
            for chat_id, streak_data in streakList:
                addPayload(streaks_payload, chat_id, streak_data)

            pets_payload = []
            for chat_id, pet_data in petList:
                addPayload(pets_payload, chat_id, pet_data)

            payload = {
                "user1_id": myHash,
                "user2_id": myHash,
                "streaks": streaks_payload,
                "pets": pets_payload,
            }

            self.log(
                f"WSP: batch sync {len(streaks_payload)} streaks, {len(pets_payload)} pets"
            )

            result, error = self._make_http_request(
                url,
                method="POST",
                data=payload,
                retries=2,
                user1_id=myHash,
                user2_id=myHash,
            )

            if result and result.get("status") == "success":
                self.log(f"WSP: batch sync successful")
                return result.get("results")
            else:
                self.log(f"WSP: batch sync failed: {error or result}")
                return None

        except Exception as e:
            self.log(f"WSP: batch_sync error: {e}")

            self.log(f"WSP: batch_sync traceback: {traceback.format_exc()}")
            return None


def get_msk_now():
    return datetime.now(MSK_TZ)


def get_msk_date():
    return get_msk_now().date()


def get_msk_midnight_timestamp(date_obj):
    midnight_msk = datetime.combine(date_obj, datetime.min.time()).replace(
        tzinfo=MSK_TZ
    )
    return midnight_msk.timestamp()


# –º–æ–¥–µ–ª—å —Å—Ç—Ä–∏–∫–∞
class Streak:
    def __init__(self, chat_id, plugin_ref=None):
        self.chat_id = chat_id
        self.count = 0
        self.last_date = None
        self.first_date = None
        self.last_sync_timestamp = time.time()
        self.last_message_time = time.time()
        self.deleted = False
        self.log = plugin_ref.log if plugin_ref else log

        self.warning_since = None
        self.dead_since = None
        self.dead_count = 0
        self.restores_this_month = 0
        self.last_restore_month = None

    @property
    def is_unlocked(self):
        return self.count >= 1 and not self.deleted

    @property
    def is_warning(self):
        return self.warning_since is not None and not self.deleted

    @property
    def is_dead(self):
        return self.dead_since is not None

    @property
    def can_restore(self):
        if not self.is_dead or self.dead_count == 0:
            return False

        hours_since_death = (time.time() - self.dead_since) / 3600
        if hours_since_death > STREAK_RESTORE_WINDOW_HOURS:
            return False

        self._check_restore_month_reset()
        if self.restores_this_month >= STREAK_MAX_RESTORES_PER_MONTH:
            return False

        return True

    @property
    def restore_time_left(self):
        if not self.is_dead:
            return 0
        hours_since_death = (time.time() - self.dead_since) / 3600
        return max(0, STREAK_RESTORE_WINDOW_HOURS - hours_since_death)

    @property
    def warning_time_left(self):
        if not self.is_warning:
            return STREAK_WARNING_HOURS
        hours_since_warning = (time.time() - self.warning_since) / 3600
        return max(0, STREAK_WARNING_HOURS - hours_since_warning)

    def _check_restore_month_reset(self):
        now = datetime.now(MSK_TZ)
        current_month = int(f"{now.year:04d}{now.month:02d}")
        if self.last_restore_month != current_month:
            self.restores_this_month = 0
            self.last_restore_month = current_month

    def _enter_warning(self):
        if self.warning_since is None:
            self.warning_since = time.time()
            self.last_sync_timestamp = time.time()
            self.log(f"WSP: streak entered WARNING state for chat {self.chat_id}, count={self.count}")
            return True
        return False

    def _exit_warning(self):
        if self.warning_since is not None:
            self.warning_since = None
            self.last_sync_timestamp = time.time()
            self.log(f"WSP: streak exited WARNING state for chat {self.chat_id}")
            return True
        return False

    def _die(self):
        if self.count > 0:
            self.dead_since = time.time()
            self.dead_count = self.count
            self.log(f"WSP: streak DIED for chat {self.chat_id}, was {self.count} days")

        self.count = 0
        self.last_date = None
        self.first_date = None
        self.warning_since = None
        self.last_sync_timestamp = time.time()
        return True

    def restore(self):
        if not self.can_restore:
            self.log(f"WSP: cannot restore streak for chat {self.chat_id}")
            return False

        self._check_restore_month_reset()

        self.count = self.dead_count
        self.last_date = get_msk_date()
        self.first_date = self.last_date - timedelta(days=self.count - 1)
        self.last_message_time = time.time()
        self.last_sync_timestamp = time.time()

        self.dead_since = None
        self.dead_count = 0
        self.warning_since = None

        self.restores_this_month += 1

        self.log(f"WSP: streak RESTORED for chat {self.chat_id}, count={self.count}, restores this month={self.restores_this_month}")
        return True

    def check_and_reset_if_expired(self, allow_warning=True):
        if self.deleted or self.count == 0:
            return False

        current_time = time.time()
        today_msk = get_msk_date()
        # –≤–∞—Ä–Ω–∏–Ω–≥/—Å–º–µ—Ä—Ç—å
        if self.is_warning:
            hours_in_warning = (current_time - self.warning_since) / 3600
            if hours_in_warning >= STREAK_WARNING_HOURS:
                self.log(f"WSP: streak warning expired for chat {self.chat_id} after {hours_in_warning:.1f}h")
                return self._die()
            return False

        if not self.last_date:
            return False

        days_difference = (today_msk - self.last_date).days
        if days_difference >= 2:
            self.log(f"WSP: streak missed {days_difference} days for chat {self.chat_id}, dying")
            return self._die()

        if allow_warning and days_difference == 1:
            self.log(
                f"WSP: streak entering warning for chat {self.chat_id} "
                f"(no messages today yet)"
            )
            return self._enter_warning()

        return False

    def update_streak(self):
        current_time = time.time()
        today_msk = get_msk_date()
        expired_changed = self.check_and_reset_if_expired(allow_warning=False)

        def _start_day_one():
            self.last_date = today_msk
            self.first_date = today_msk
            self.count = 1
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time
            self.warning_since = None
            self.log(f"WSP: streak started for chat {self.chat_id} (day 1)")
            return True

        if self.deleted:
            self.log(f"WSP: streak is deleted for chat {self.chat_id}, ignoring update")
            return False

        if self.is_dead:
            self.log(f"WSP: streak is dead for chat {self.chat_id}, waiting for restore")
            return False

        if self.count == 0 and not self.is_dead:
            return _start_day_one()

        if self.is_warning:
            self._exit_warning()

        if self.last_date is None:
            return _start_day_one()

        difference = (today_msk - self.last_date).days

        if difference < 0:
            self.log(f"WSP: negative date difference detected, ignoring update")
            return False

        if difference == 0:
            self.last_message_time = current_time
            self.log(f"WSP: streak same day for chat {self.chat_id}, count={self.count}")
            return expired_changed
        elif difference == 1:
            self.count += 1
            self.last_date = today_msk
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time

            if self.count == STREAK_UNLOCK_DAYS:
                self.log(f"WSP: üéâ streak UNLOCKED for chat {self.chat_id}! Badge now visible!")
            else:
                self.log(f"WSP: streak continued for chat {self.chat_id}, now {self.count} days")
            return True
        else:
            self.log(f"WSP: streak broken for chat {self.chat_id} (missed {difference} days), starting fresh")
            self.count = 1
            self.last_date = today_msk
            self.first_date = today_msk
            self.last_sync_timestamp = current_time
            self.last_message_time = current_time
            self.dead_since = None
            self.dead_count = 0
            return True

    def get_flame_emoji(self, respect_warning=True):
        if respect_warning and self.is_warning:
            return FLAME_EXTINGUISHED
        for (min_val, max_val), emoji in FLAME_COLORS.items():
            if min_val <= self.count <= max_val:
                return emoji
        return "üî•"

    def get_current_stage_index(self):
        for i, stage in enumerate(FLAME_STAGES):
            if stage["min"] <= self.count <= stage["max"]:
                return i
        return 0

    def to_dict(self):
        return {
            "chat": self.chat_id,
            "count": self.count,
            "last_date": self.last_date.isoformat() if self.last_date else None,
            "first_date": self.first_date.isoformat() if self.first_date else None,
            "timestamp": self.last_sync_timestamp,
            "last_message_time": self.last_message_time,
            "deleted": self.deleted,
            "warning_since": self.warning_since,
            "dead_since": self.dead_since,
            "dead_count": self.dead_count,
            "restores_this_month": self.restores_this_month,
            "last_restore_month": self.last_restore_month,
        }

    def get_sync_data(self):
        return {
            "count": self.count,
            "last_date": self.last_date.isoformat() if self.last_date else None,
            "first_date": self.first_date.isoformat() if self.first_date else None,
            "timestamp": self.last_sync_timestamp,
            "last_message_time": self.last_message_time,
            "deleted": self.deleted,
            "warning_since": self.warning_since,
            "dead_since": self.dead_since,
            "dead_count": self.dead_count,
            "restores_this_month": self.restores_this_month,
            "last_restore_month": self.last_restore_month,
        }

    @staticmethod
    def _ts_recent(value, default):
        if not isinstance(value, (int, float)):
            return default
        now = time.time()
        if value < 0 or value > now + 86400:
            return default
        return float(value)

    def _sanitize_sync_data(self, sync_data):
        if not isinstance(sync_data, dict):
            self.log("WSP: invalid streak sync_data format - rejecting sync")
            return None

        count = sync_data.get("count")
        if (
            count is None
            or not isinstance(count, int)
            or count < 0
            or count > MAX_STREAK_COUNT
        ):
            self.log(f"WSP: invalid streak count value: {count} - rejecting sync")
            return None

        deleted = sync_data.get("deleted", False)
        if not isinstance(deleted, bool):
            self.log(f"WSP: invalid deleted value: {deleted} - rejecting sync")
            return None

        timestamp = self._ts_recent(sync_data.get("timestamp"), time.time())

        last_str = sync_data.get("last_date")
        first_str = sync_data.get("first_date")

        try:
            last_date = datetime.fromisoformat(last_str).date() if last_str else None
        except (ValueError, AttributeError, TypeError):
            self.log(f"WSP: invalid last_date, using None")
            last_date = None

        try:
            first_date = datetime.fromisoformat(first_str).date() if first_str else None
        except (ValueError, AttributeError, TypeError):
            self.log(f"WSP: invalid first_date, using None")
            first_date = None

        last_message_time = self._ts_recent(
            sync_data.get("last_message_time"), time.time()
        )

        return {
            "count": count,
            "deleted": deleted,
            "timestamp": timestamp,
            "last_date": last_date,
            "first_date": first_date,
            "last_message_time": last_message_time,
            "warning_since": V.ts_or_none(sync_data.get("warning_since")),
            "dead_since": V.ts_or_none(sync_data.get("dead_since")),
            "dead_count": V.int_range(
                sync_data.get("dead_count"), 0, 9999, self.dead_count
            ),
            "restores_this_month": V.int_range(
                sync_data.get("restores_this_month"),
                0,
                STREAK_MAX_RESTORES_PER_MONTH,
                self.restores_this_month,
            ),
            "last_restore_month": V.month_key(
                sync_data.get("last_restore_month"), self.last_restore_month
            ),
        }

    def apply_sync_data(self, sync_data, source="unknown"):
        sanitized = self._sanitize_sync_data(sync_data)
        if not sanitized:
            return

        merged_last_message_time = max(
            self.last_message_time, sanitized["last_message_time"]
        )

        self.log(
            f"WSP: applying {source} streak sync data for chat {self.chat_id}: "
            f"count={sanitized['count']}, deleted={sanitized['deleted']}, "
            f"last_message_time: local={self.last_message_time}, remote={sanitized['last_message_time']}, merged={merged_last_message_time}"
        )

        self.count = sanitized["count"]
        self.last_date = sanitized["last_date"]
        self.first_date = sanitized["first_date"]
        self.last_sync_timestamp = sanitized["timestamp"]
        self.last_message_time = merged_last_message_time
        self.deleted = sanitized["deleted"]
        self.warning_since = sanitized["warning_since"]
        self.dead_since = sanitized["dead_since"]
        self.dead_count = sanitized["dead_count"]
        self.restores_this_month = sanitized["restores_this_month"]
        self.last_restore_month = sanitized["last_restore_month"]

    @staticmethod
    def from_dict(data, plugin_ref=None):
        streak = Streak(data["chat"], plugin_ref=plugin_ref)
        streak.count = data.get("count", 0)
        last_str = data.get("last_date")
        first_str = data.get("first_date")

        try:
            streak.last_date = (
                datetime.fromisoformat(last_str).date() if last_str else None
            )
        except (ValueError, AttributeError):
            streak.last_date = None

        try:
            streak.first_date = (
                datetime.fromisoformat(first_str).date() if first_str else None
            )
        except (ValueError, AttributeError):
            streak.first_date = None

        streak.last_sync_timestamp = data.get("timestamp", 0)
        streak.last_message_time = data.get("last_message_time", time.time())
        streak.deleted = data.get("deleted", False)
        streak.warning_since = data.get("warning_since")
        streak.dead_since = data.get("dead_since")
        streak.dead_count = data.get("dead_count", 0)
        streak.restores_this_month = data.get("restores_this_month", 0)
        streak.last_restore_month = V.month_key(data.get("last_restore_month"))
        return streak


# –≤–∏–¥–∂–µ—Ç—ã
class FloatingPetWidget(BaseWidget):
    def __init__(self, context, plugin_ref, chat_id):
        super().__init__(context, plugin_ref, chat_id)
        self.log = plugin_ref.log if plugin_ref else log
        self.container = FrameLayout(context)
        self.content = LinearLayout(context)
        self.view = TextView(context)
        self.stats_view = TextView(context)
        self.ring_outer = None
        self.ring_inner = None
        self._ring_outer_bg = None
        self._ring_inner_bg = None
        self.animator1 = None
        self.animator2 = None
        self.animator3 = None
        self.animator4 = None
        self.offset_x = 0
        self.offset_y = 0
        self.user_has_moved = False
        self._base_alpha = 1.0
        self._smart_hidden = False
        self._scroll_hidden = False
        self._keyboard_hidden = False
        self._pre_hide_pos = None
        self._scroll_token = 0
        self._smart_hide_view = None
        self._layout_listener = None
        self._scroll_listener = None
        self._last_emoji = None
        self._last_stats_text = None
        self._last_mood = None
        self._last_hunger = None
        self._last_mode = None
        self._last_ring_colors = (None, None)
        self._last_alpha = None

        size_index = self.plugin_ref.get_setting("widget_size", 2)
        size_dp = (
            WIDGET_SIZES_DP[size_index]
            if size_index < len(WIDGET_SIZES_DP)
            else WIDGET_DEFAULT_SIZE_DP
        )
        self._size_dp = size_dp
        size_px = AndroidUtilities.dp(size_dp)

        self.container.setLayoutParams(FrameLayout.LayoutParams(size_px, size_px))

        bg = GradientDrawable()
        bg.setShape(GradientDrawable.OVAL)
        bg.setColor(UI.primary_container())
        bg.setStroke(AndroidUtilities.dp(Dp.S2), UI.outline())
        self.container.setBackground(bg)
        UI.elevation(self.container, ELEVATION_WIDGET)

        try:
            self.container.setOutlineProvider(
                find_class("android.view.ViewOutlineProvider").OVAL
            )
            self.container.setClipToOutline(True)
        except Exception:
            pass

        self.content.setOrientation(LinearLayout.VERTICAL)
        self.content.setGravity(Gravity.CENTER)

        self.view.setGravity(Gravity.CENTER)
        self.view.setClickable(False)
        self.view.setTextColor(UI.on_primary_container())

        self.stats_view.setGravity(Gravity.CENTER)
        self.stats_view.setTextColor(UI.on_primary_container())
        self.stats_view.setClickable(False)
        stats_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        stats_params.setMargins(0, AndroidUtilities.dp(Dp.S2), 0, 0)
        self.stats_view.setLayoutParams(stats_params)

        pet_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
        )
        self.content.setLayoutParams(pet_params)

        try:
            ring_outer = View(context)
            ring_outer_bg = GradientDrawable()
            ring_outer_bg.setShape(GradientDrawable.OVAL)
            ring_outer_bg.setColor(Color.TRANSPARENT)
            ring_outer_bg.setStroke(AndroidUtilities.dp(Dp.S2), UI.primary())
            ring_outer.setBackground(ring_outer_bg)
            ring_outer.setClickable(False)
            ring_outer.setFocusable(False)
            ring_outer.setAlpha(0.9)
            ring_outer_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            self.container.addView(ring_outer, ring_outer_params)
            self.ring_outer = ring_outer
            self._ring_outer_bg = ring_outer_bg

            ring_inner = View(context)
            ring_inner_bg = GradientDrawable()
            ring_inner_bg.setShape(GradientDrawable.OVAL)
            ring_inner_bg.setColor(Color.TRANSPARENT)
            ring_inner_bg.setStroke(AndroidUtilities.dp(Dp.S2), UI.secondary())
            ring_inner.setBackground(ring_inner_bg)
            ring_inner.setClickable(False)
            ring_inner.setFocusable(False)
            ring_inner.setAlpha(0.75)
            inner_margin = AndroidUtilities.dp(Dp.S4)
            ring_inner_params = FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
            )
            ring_inner_params.setMargins(inner_margin, inner_margin, inner_margin, inner_margin)
            self.container.addView(ring_inner, ring_inner_params)
            self.ring_inner = ring_inner
            self._ring_inner_bg = ring_inner_bg
        except Exception:
            pass

        self.content.setClickable(False)
        self.content.setFocusable(False)
        self.content.addView(self.view)
        self.content.addView(self.stats_view)
        self.container.addView(self.content)

        self.container.setClickable(True)
        self.container.setFocusable(True)
        self.log("WSP: container set as clickable and focusable")

        self._apply_widget_mode()
        self._update_visual()
        self.setupTouchBase(self.container)
        try:
            self.view.setOnTouchListener(self.container.getOnTouchListener())
        except Exception:
            pass

    def _update_visual(self):
        if not self.plugin_ref:
            return

        if self.chat_id not in self.plugin_ref.pets:
            self.log(f"WSP: widget update skipped - no pet for chat {self.chat_id}")
            return

        try:
            pet = self.plugin_ref.pets.get(self.chat_id)
            if not pet:
                return

            emoji = pet.get_emoji()
            if self.view and emoji != self._last_emoji:
                self.view.setText(emoji)
                self._last_emoji = emoji

            if self.stats_view:
                mood_val = int(pet.mood)
                hunger_val = int(pet.hunger)
                stats_text = f"‚ù§{mood_val}%  üçñ{hunger_val}%"
                if stats_text != self._last_stats_text:
                    self.stats_view.setText(stats_text)
                    self._last_stats_text = stats_text

            self._update_ring_colors(pet)
            mode = None
            if self.plugin_ref:
                try:
                    mode = self.plugin_ref.get_setting("widget_mode", 0)
                except Exception:
                    mode = None
            self._apply_widget_mode(mode)
        except Exception as e:
            self.log(f"WSP: widget visual update error: {e}")
            return

        if self.plugin_ref and self.container:
            try:
                alpha_index = self.plugin_ref.get_setting("widget_alpha", 4)
                alpha_procent = (
                    ALPHA_VALUES_PERCENT[alpha_index]
                    if alpha_index < len(ALPHA_VALUES_PERCENT)
                    else 100
                )
                alpha_value = alpha_procent / 100.0
                if self._last_alpha != alpha_value:
                    self._base_alpha = alpha_value
                    self._last_alpha = alpha_value
                self._apply_smart_hide_alpha()
                self.log(f"WSP: alpha set to {alpha_procent}% (value={alpha_value})")
            except Exception as e:
                self.log(f"WSP: alpha update error: {e}")

    def _apply_widget_mode(self, mode=None):
        try:
            if mode is None:
                mode = 0
                if self.plugin_ref:
                    mode = self.plugin_ref.get_setting("widget_mode", 0)
            if mode == self._last_mode:
                return
            self._last_mode = mode
            is_expanded = mode == 1
            emoji_size = self._size_dp * (0.46 if is_expanded else 0.58)
            stats_size = max(9, int(self._size_dp * 0.16))
            if self.view:
                self.view.setTextSize(1, float(emoji_size))
            if self.stats_view:
                if is_expanded:
                    self.stats_view.setVisibility(View.VISIBLE)
                    self.stats_view.setTextSize(1, float(stats_size))
                else:
                    self.stats_view.setVisibility(View.GONE)
        except Exception:
            pass

    def _stat_color(self, value, medium_threshold, critical_threshold):
        try:
            if value < critical_threshold:
                return UI.error()
            if value < medium_threshold:
                return UI.tertiary()
            return UI.primary()
        except Exception:
            return UI.primary()

    def _update_ring_colors(self, pet):
        try:
            hunger_color = self._stat_color(
                pet.hunger, HUNGER_MEDIUM_THRESHOLD, HUNGER_CONFIG["critical_level"]
            )
            mood_color = self._stat_color(
                pet.mood, MOOD_MEDIUM_THRESHOLD, MOOD_LOW_THRESHOLD
            )
            if (hunger_color, mood_color) == self._last_ring_colors:
                return
            self._last_ring_colors = (hunger_color, mood_color)
            if self._ring_outer_bg:
                self._ring_outer_bg.setStroke(AndroidUtilities.dp(Dp.S2), hunger_color)
            if self._ring_inner_bg:
                self._ring_inner_bg.setStroke(AndroidUtilities.dp(Dp.S2), mood_color)
        except Exception:
            pass

    def _apply_smart_hide_alpha(self):
        if not self.container:
            return
        try:
            target_alpha = self._base_alpha * (0.45 if self._smart_hidden else 1.0)
            self.container.setAlpha(float(target_alpha))
        except Exception:
            pass

    def _update_smart_hide_state(self):
        self._set_smart_hidden(self._keyboard_hidden or self._scroll_hidden)

    def _set_smart_hidden(self, hidden):
        if not self.container:
            return
        if hidden == self._smart_hidden:
            self._apply_smart_hide_alpha()
            return

        self._smart_hidden = hidden
        if hidden:
            if not self.is_dragging:
                self._pre_hide_pos = (
                    float(self.container.getTranslationX()),
                    float(self.container.getTranslationY()),
                )
                target = self._get_nearest_corner_target()
                if target:
                    self._animate_to(target[0], target[1], self._base_alpha * 0.45)
                else:
                    self._apply_smart_hide_alpha()
        else:
            if self._pre_hide_pos and not self.is_dragging:
                x, y = self._pre_hide_pos
                self._animate_to(x, y, self._base_alpha)
            else:
                self._apply_smart_hide_alpha()
            self._pre_hide_pos = None

    def _get_nearest_corner_target(self):
        try:
            parent = self.container.getParent()
            if not parent:
                return None
            parent_width = parent.getWidth()
            parent_height = parent.getHeight()
            if parent_width <= 0 or parent_height <= 0:
                return None
            width = self.container.getWidth()
            height = self.container.getHeight()
            if width <= 0 or height <= 0:
                return None
            margin = AndroidUtilities.dp(Dp.S12)
            center_x = self.container.getTranslationX() + width / 2.0
            center_y = self.container.getTranslationY() + height / 2.0
            target_x = margin if center_x < parent_width / 2.0 else parent_width - width - margin
            target_y = margin if center_y < parent_height / 2.0 else parent_height - height - margin
            return (float(target_x), float(target_y))
        except Exception:
            return None

    def _animate_to(self, target_x, target_y, target_alpha):
        try:
            anim_x = ObjectAnimator.ofFloat(
                self.container, "translationX", self.container.getTranslationX(), target_x
            )
            anim_y = ObjectAnimator.ofFloat(
                self.container, "translationY", self.container.getTranslationY(), target_y
            )
            anim_a = ObjectAnimator.ofFloat(
                self.container, "alpha", self.container.getAlpha(), float(target_alpha)
            )
            anim_x.setDuration(180)
            anim_y.setDuration(180)
            anim_a.setDuration(160)
            anim_x.setInterpolator(AccelerateDecelerateInterpolator())
            anim_y.setInterpolator(AccelerateDecelerateInterpolator())
            anim_a.setInterpolator(AccelerateDecelerateInterpolator())
            anim_x.start()
            anim_y.start()
            anim_a.start()
        except Exception:
            try:
                self.container.setTranslationX(float(target_x))
                self.container.setTranslationY(float(target_y))
                self.container.setAlpha(float(target_alpha))
            except Exception:
                pass

    def _attach_smart_hide(self, decor_view):
        if not decor_view:
            return
        if self._smart_hide_view is decor_view:
            return
        if self._smart_hide_view and self._smart_hide_view is not decor_view:
            self._detach_smart_hide()
        self._smart_hide_view = decor_view
        try:
            from java import dynamic_proxy

            def on_global_layout():
                try:
                    if not self.container:
                        return
                    root = decor_view.getRootView() or decor_view
                    rect = Rect()
                    root.getWindowVisibleDisplayFrame(rect)
                    visible_height = rect.height()
                    root_height = root.getHeight()
                    if root_height <= 0:
                        return
                    keyboard_height = max(0, root_height - visible_height)
                    is_keyboard = keyboard_height > AndroidUtilities.dp(Dp.S120)
                    if is_keyboard != self._keyboard_hidden:
                        self._keyboard_hidden = is_keyboard
                        self._update_smart_hide_state()
                except Exception:
                    pass

            def on_scroll_changed():
                try:
                    self._scroll_token += 1
                    token = self._scroll_token
                    if not self._keyboard_hidden:
                        self._scroll_hidden = True
                        self._update_smart_hide_state()

                    def restore():
                        if self._scroll_token != token:
                            return
                        self._scroll_hidden = False
                        self._update_smart_hide_state()

                    run_on_ui_thread(restore, 650)
                except Exception:
                    pass

            self._layout_listener = dynamic_proxy(ViewTreeObserver.OnGlobalLayoutListener)(
                on_global_layout
            )
            decor_view.getViewTreeObserver().addOnGlobalLayoutListener(
                self._layout_listener
            )
            self._scroll_listener = dynamic_proxy(ViewTreeObserver.OnScrollChangedListener)(
                on_scroll_changed
            )
            decor_view.getViewTreeObserver().addOnScrollChangedListener(
                self._scroll_listener
            )
        except Exception:
            self._layout_listener = None
            self._scroll_listener = None

    def _detach_smart_hide(self):
        if not self._smart_hide_view:
            return
        try:
            observer = self._smart_hide_view.getViewTreeObserver()
            if self._layout_listener:
                try:
                    observer.removeOnGlobalLayoutListener(self._layout_listener)
                except Exception:
                    pass
            if self._scroll_listener:
                try:
                    observer.removeOnScrollChangedListener(self._scroll_listener)
                except Exception:
                    pass
        except Exception:
            pass
        self._layout_listener = None
        self._scroll_listener = None
        self._smart_hide_view = None

    def _start_animation(self):
        if not self.plugin_ref or not self.container:
            return
        try:
            if self.animator1:
                self.animator1.cancel()
            if self.animator2:
                self.animator2.cancel()
            if self.animator3:
                self.animator3.cancel()
            if self.animator4:
                self.animator4.cancel()
        except Exception:
            pass

        duration1 = 2500
        duration2 = 3000
        current_trans_y = self.container.getTranslationY()
        bounce_offset = AndroidUtilities.dp(Dp.S8)
        self.animator1 = ObjectAnimator.ofFloat(
            self.container,
            "translationY",
            current_trans_y,
            current_trans_y - bounce_offset,
            current_trans_y,
        )
        self.animator1.setDuration(duration1)
        self.animator1.setRepeatCount(ValueAnimator.INFINITE)
        self.animator1.setInterpolator(AccelerateDecelerateInterpolator())
        self.animator1.start()

        self.animator2 = ObjectAnimator.ofFloat(self.container, "rotation", -3, 3, -3)
        self.animator2.setDuration(duration2)
        self.animator2.setRepeatCount(ValueAnimator.INFINITE)
        self.animator2.setInterpolator(AccelerateDecelerateInterpolator())
        self.animator2.start()

        self.animator3 = ObjectAnimator.ofFloat(self.container, "scaleX", 1.0, 1.03, 1.0)
        self.animator3.setDuration(2600)
        self.animator3.setRepeatCount(ValueAnimator.INFINITE)
        self.animator3.setInterpolator(AccelerateDecelerateInterpolator())
        self.animator3.start()

        self.animator4 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.0, 1.03, 1.0)
        self.animator4.setDuration(2600)
        self.animator4.setRepeatCount(ValueAnimator.INFINITE)
        self.animator4.setInterpolator(AccelerateDecelerateInterpolator())
        self.animator4.start()

    def play_entry_animation(self):
        if not self.container:
            return
        try:
            self.container.setScaleX(0.92)
            self.container.setScaleY(0.92)
            self.container.setAlpha(0.0)
            scale_x = ObjectAnimator.ofFloat(self.container, "scaleX", 0.92, 1.0)
            scale_y = ObjectAnimator.ofFloat(self.container, "scaleY", 0.92, 1.0)
            alpha = ObjectAnimator.ofFloat(
                self.container, "alpha", 0.0, float(self._base_alpha)
            )
            scale_x.setDuration(180)
            scale_y.setDuration(180)
            alpha.setDuration(200)
            scale_x.setInterpolator(AccelerateDecelerateInterpolator())
            scale_y.setInterpolator(AccelerateDecelerateInterpolator())
            alpha.setInterpolator(AccelerateDecelerateInterpolator())
            scale_x.start()
            scale_y.start()
            alpha.start()
        except Exception:
            self._apply_smart_hide_alpha()

    def cleanup(self):
        self.log(f"WSP: FloatingPetWidget.cleanup() called for chat {self.chat_id}")
        try:
            if hasattr(self, "animator1") and self.animator1:
                self.animator1.cancel()
                self.animator1 = None
                self.log("WSP: animator1 cancelled")
            if hasattr(self, "animator2") and self.animator2:
                self.animator2.cancel()
                self.animator2 = None
                self.log("WSP: animator2 cancelled")
            if hasattr(self, "animator3") and self.animator3:
                self.animator3.cancel()
                self.animator3 = None
                self.log("WSP: animator3 cancelled")
            if hasattr(self, "animator4") and self.animator4:
                self.animator4.cancel()
                self.animator4 = None
                self.log("WSP: animator4 cancelled")

            if self.view:
                self.view.setOnTouchListener(None)
                self.log("WSP: OnTouchListener removed from view")

            if self.container:
                self.container.setOnTouchListener(None)
                self.container.setRotation(0)
                self.container.setScaleX(1.0)
                self.container.setScaleY(1.0)
                parent = self.container.getParent()
                if parent:
                    self.log(f"WSP: removing widget from parent view")
                    parent.removeView(self.container)
                    self.log(
                        f"WSP: widget view removed from parent for chat {self.chat_id}"
                    )
                else:
                    self.log("WSP: container has no parent, cannot remove")

            self._detach_smart_hide()
            self._plugin_ref = None
            self.view = None
            self.stats_view = None
            self.content = None
            self.ring_outer = None
            self.ring_inner = None
            self._ring_outer_bg = None
            self._ring_inner_bg = None
            self.container = None
            self.context = None
            self.haptics = None

            self.log(f"WSP: cleanup completed for widget {self.chat_id}")
        except Exception as e:
            self.log(f"WSP: cleanup error for {self.chat_id}: {e}")

    def onTouchDown(self, view, event):
        if hasattr(self, "animator1") and self.animator1:
            self.animator1.cancel()
        if hasattr(self, "animator2") and self.animator2:
            self.animator2.cancel()
        if hasattr(self, "animator3") and self.animator3:
            self.animator3.cancel()
        if hasattr(self, "animator4") and self.animator4:
            self.animator4.cancel()

        self.offset_x = self.container.getTranslationX()
        self.offset_y = self.container.getTranslationY()
        self.log(
            f"WSP: onTouchDown offset_x={self.offset_x}, offset_y={self.offset_y}"
        )

        layout_params = self.container.getLayoutParams()
        if layout_params and hasattr(layout_params, "gravity"):
            layout_params.gravity = Gravity.NO_GRAVITY
            self.container.setLayoutParams(layout_params)

        if self.haptics:
            try:
                self.haptics.haptic("KEYBOARD_TAP", 3)
            except Exception as e:
                self.log(f"WSP: haptics error: {e}")

        animator = ObjectAnimator.ofFloat(self.container, "scaleX", 1.0, 1.15, 1.0)
        animator.setDuration(200)
        animator.start()
        animator2 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.0, 1.15, 1.0)
        animator2.setDuration(200)
        animator2.start()

    def onDrag(self, view, event, dx, dy):
        if not self.user_has_moved:
            self.user_has_moved = True
            self.log(f"WSP: user started dragging widget")

        new_x = self.offset_x + dx
        new_y = self.offset_y + dy
        self.container.setTranslationX(new_x)
        self.container.setTranslationY(new_y)

    def onClick(self, view, event):
        def show_pet_menu():
            try:
                context = get_last_fragment()
                if context:
                    activity = context.getParentActivity()
                    if activity:
                        menu = PetStatsBottomSheet(
                            activity, self.plugin_ref, self.chat_id
                        )
                        menu.show()
                        self.log(f"WSP: pet menu shown for chat {self.chat_id}")
            except Exception as e:
                self.log(f"WSP: failed to show pet menu: {e}")

                self.log(f"WSP: traceback: {traceback.format_exc()}")
                bulletin_safe(
                    "error",
                    tr(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –º–µ–Ω—é: {e}", f"Failed to open menu: {e}"),
                )

        run_on_ui_thread(show_pet_menu)

    def onTouchUp(self, view, event):
        if self.is_dragging:
            self.offset_x = self.container.getTranslationX()
            self.offset_y = self.container.getTranslationY()
            self.log(
                f"WSP: widget position saved: x={self.offset_x}, y={self.offset_y}"
            )
            if self.plugin_ref and self.chat_id:
                self.plugin_ref.widget_positions[self.chat_id] = {
                    "x": float(self.offset_x),
                    "y": float(self.offset_y),
                }
                self.plugin_ref.saveSoon()
                self.log(f"WSP: widget position persisted for chat {self.chat_id}")

        self._start_animation()
        self._update_smart_hide_state()

    def get_view(self):
        return self.container


class StreakBadgeWidget(BaseWidget):
    def __init__(
        self, context, plugin_ref, chat_id, days, flame_emoji, is_warning=False
    ):
        super().__init__(context, plugin_ref, chat_id)
        self.days = days
        self.flame_emoji = flame_emoji
        self.is_warning = is_warning
        self.log = plugin_ref.log if plugin_ref else log
        self.offset_x = 0
        self.offset_y = 0

        self._build_ui()
        self.setupTouchBase(self.container)

    def _build_ui(self):
        self.container = FrameLayout(self.context)
        size = AndroidUtilities.dp(Dp.BTN_H)
        self.container.setLayoutParams(FrameLayout.LayoutParams(size, size))

        bg = GradientDrawable()
        bg.setShape(GradientDrawable.OVAL)

        hue = self._get_flame_hue_from_count(self.days)
        if self.is_warning:
            base_color = self._hsv_to_argb(hue, 0.2, 0.5, 0.6)
        else:
            base_color = self._hsv_to_argb(hue, 0.7, 0.9, 1.0)

        primary = UI.primary()
        blended = Color.argb(
            255 if not self.is_warning else 150,
            (Color.red(base_color) + Color.red(primary)) // 2,
            (Color.green(base_color) + Color.green(primary)) // 2,
            (Color.blue(base_color) + Color.blue(primary)) // 2,
        )
        bg.setColor(blended)
        bg.setStroke(AndroidUtilities.dp(Dp.S2), UI.outline() if not self.is_warning else Color.GRAY)

        self.container.setBackground(bg)
        UI.elevation(self.container, ELEVATION_WIDGET)
        self.container.setClickable(True)
        self.container.setFocusable(True)

        layout = LinearLayout(self.context)
        layout.setOrientation(LinearLayout.VERTICAL)
        layout.setGravity(Gravity.CENTER)

        self.emoji_view = TextView(self.context)
        if self.is_warning:
            self.emoji_view.setText("üí®")
            self.emoji_view.setAlpha(0.5)
        else:
            self.emoji_view.setText(self.flame_emoji)
        self.emoji_view.setTextSize(1, 16)
        self.emoji_view.setGravity(Gravity.CENTER)

        self.counter_view = TextView(self.context)
        self.counter_view.setText(str(self.days))
        if self.is_warning:
            self.counter_view.setTextColor(Color.GRAY)
            self.counter_view.setAlpha(0.6)
        else:
            self.counter_view.setTextColor(UI.on_primary())
        self.counter_view.setTextSize(1, 10)
        self.counter_view.setTypeface(Typeface.DEFAULT_BOLD)
        self.counter_view.setGravity(Gravity.CENTER)

        layout.addView(self.emoji_view)
        layout.addView(self.counter_view)

        params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
        )
        layout.setLayoutParams(params)

        self.container.addView(layout)

    def _get_flame_hue_from_count(self, count):
        if count < 7:
            return 0.05
        elif count < 14:
            return 0.55
        elif count < 30:
            return 0.33
        elif count < 100:
            return 0.75
        else:
            return 0.15

    def _hsv_to_argb(self, h, s, v, a=1.0):
        hsv = [h * 360, s, v]
        color_int = Color.HSVToColor(hsv)
        alpha = int(a * 255)
        return Color.argb(
            alpha, Color.red(color_int), Color.green(color_int), Color.blue(color_int)
        )

    def onTouchDown(self, view, event):
        self.offset_x = self.container.getTranslationX()
        self.offset_y = self.container.getTranslationY()
        self.log(
            f"WSP: streak badge touch down at offset_x={self.offset_x}, offset_y={self.offset_y}"
        )

        if self.haptics:
            try:
                self.haptics.haptic("KEYBOARD_TAP", 3)
            except Exception as e:
                self.log(f"WSP: haptics error: {e}")

        animator = ObjectAnimator.ofFloat(self.container, "scaleX", 1.0, 1.2, 1.0)
        animator.setDuration(150)
        animator.start()
        animator2 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.0, 1.2, 1.0)
        animator2.setDuration(150)
        animator2.start()

    def onDrag(self, view, event, dx, dy):
        if not hasattr(self, "user_has_moved"):
            self.user_has_moved = True
            self.log(f"WSP: user started dragging streak badge")

        new_x = self.offset_x + dx
        new_y = self.offset_y + dy
        self.container.setTranslationX(new_x)
        self.container.setTranslationY(new_y)

    def onClick(self, view, event):
        if self.haptics:
            self.haptics.oneshot(15, 80)

        animator = ObjectAnimator.ofFloat(
            self.container, "rotation", 0, -10, 10, -10, 10, 0
        )
        animator.setDuration(400)
        animator.start()

        def show_streak_menu():
            try:
                self.log(f"WSP: streak badge clicked for chat {self.chat_id}")
                bulletin_safe("success", 
                    tr(
                        f"–°—Ç—Ä–∏–∫: {formatDaysRu(self.days)} {self.flame_emoji}",
                        f"Streak: {formatDaysEn(self.days)} {self.flame_emoji}",
                    )
                )
            except Exception as e:
                self.log(f"WSP: failed to show streak menu: {e}")

                self.log(f"WSP: traceback: {traceback.format_exc()}")

        run_on_ui_thread(show_streak_menu)

    def onTouchUp(self, view, event):
        if self.is_dragging:
            self.offset_x = self.container.getTranslationX()
            self.offset_y = self.container.getTranslationY()
            self.log(
                f"WSP: streak badge position saved: x={self.offset_x}, y={self.offset_y}"
            )
            if self.plugin_ref and self.chat_id:
                badge_key = f"streak_{self.chat_id}"
                self.plugin_ref.widget_positions[badge_key] = {
                    "x": float(self.offset_x),
                    "y": float(self.offset_y),
                }
                self.plugin_ref.saveSoon()
                self.log(
                    f"WSP: streak badge position persisted for chat {self.chat_id}"
                )

    def update_streak(self, days, flame_emoji):
        self.days = days
        self.flame_emoji = flame_emoji

        if self.emoji_view:
            self.emoji_view.setText(flame_emoji)
        if self.counter_view:
            self.counter_view.setText(str(days))

        bg = GradientDrawable()
        bg.setShape(GradientDrawable.OVAL)
        hue = self._get_flame_hue_from_count(days)
        base_color = self._hsv_to_argb(hue, 0.7, 0.9, 1.0)
        primary = UI.primary()
        blended = Color.argb(
            255,
            (Color.red(base_color) + Color.red(primary)) // 2,
            (Color.green(base_color) + Color.green(primary)) // 2,
            (Color.blue(base_color) + Color.blue(primary)) // 2,
        )
        bg.setColor(blended)
        bg.setStroke(AndroidUtilities.dp(Dp.S2), UI.outline())
        self.container.setBackground(bg)

    def cleanup(self):
        try:
            if self.container:
                self.container.setScaleX(1.0)
                self.container.setScaleY(1.0)
                self.container.setOnTouchListener(None)
                parent = self.container.getParent()
                if parent:
                    parent.removeView(self.container)
            self._plugin_ref = None
            self.context = None
            self.container = None
            self.emoji_view = None
            self.counter_view = None
            self.haptics = None
        except Exception as e:
            self.log(f"WSP: StreakBadgeWidget cleanup error: {e}")

    def get_view(self):
        return self.container


# —Ñ—Ö –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã
class FlyingXPParticle:
    def __init__(self, context, start_x, start_y, end_x, end_y, xp_amount, callback):
        self.container = FrameLayout(context)
        self.flame_view = TextView(context)
        self.xp_view = TextView(context)
        self.callback = callback
        self.animators = []
        self.log = log

        container_size = AndroidUtilities.dp(Dp.S40)
        self.container.setLayoutParams(
            FrameLayout.LayoutParams(container_size, container_size)
        )

        self.flame_view.setText("üî•")
        self.flame_view.setTextSize(1, 24)
        self.flame_view.setGravity(Gravity.CENTER)
        flame_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT
        )
        self.flame_view.setLayoutParams(flame_params)

        self.xp_view.setText(f"+{xp_amount}")
        self.xp_view.setTextSize(1, 10)
        self.xp_view.setTextColor(Color.parseColor("#FFD700"))
        self.xp_view.setGravity(Gravity.CENTER)
        self.xp_view.setTypeface(None, Typeface.BOLD)
        xp_params = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT
        )
        xp_params.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL
        self.xp_view.setLayoutParams(xp_params)

        self.container.addView(self.flame_view)
        self.container.addView(self.xp_view)

        self.container.setX(start_x)
        self.container.setY(start_y)
        self.container.setAlpha(0.0)
        self.container.setScaleX(0.3)
        self.container.setScaleY(0.3)

        self._zapustit_polet(start_x, start_y, end_x, end_y)

    def _zapustit_polet(self, start_x, start_y, end_x, end_y):
        alpha_in = ObjectAnimator.ofFloat(self.container, "alpha", 0.0, 1.0)
        alpha_in.setDuration(150)
        alpha_in.start()
        self.animators.append(alpha_in)

        scale_in = ObjectAnimator.ofFloat(self.container, "scaleX", 0.3, 1.2)
        scale_in.setDuration(150)
        scale_in.start()
        self.animators.append(scale_in)

        scale_in2 = ObjectAnimator.ofFloat(self.container, "scaleY", 0.3, 1.2)
        scale_in2.setDuration(150)
        scale_in2.start()
        self.animators.append(scale_in2)

        def _start_movement():
            duration = 800
            anim_x = ObjectAnimator.ofFloat(self.container, "x", start_x, end_x)
            anim_x.setDuration(duration)
            anim_x.setInterpolator(AccelerateDecelerateInterpolator())
            anim_x.start()
            self.animators.append(anim_x)

            anim_y = ObjectAnimator.ofFloat(self.container, "y", start_y, end_y)
            anim_y.setDuration(duration)
            anim_y.setInterpolator(AccelerateDecelerateInterpolator())
            anim_y.start()
            self.animators.append(anim_y)

            rotation = ObjectAnimator.ofFloat(self.container, "rotation", 0, 720)
            rotation.setDuration(duration)
            rotation.start()
            self.animators.append(rotation)

            scale_pulse = ObjectAnimator.ofFloat(
                self.container, "scaleX", 1.2, 0.8, 1.2
            )
            scale_pulse.setDuration(duration)
            scale_pulse.setRepeatCount(2)
            scale_pulse.start()
            self.animators.append(scale_pulse)

            def _finish():
                self._explosion_animation()

            run_on_ui_thread(_finish, duration)

        run_on_ui_thread(_start_movement, 150)

    def _explosion_animation(self):
        scale_up = ObjectAnimator.ofFloat(self.container, "scaleX", 1.2, 2.0)
        scale_up.setDuration(200)
        scale_up.start()
        self.animators.append(scale_up)

        scale_up2 = ObjectAnimator.ofFloat(self.container, "scaleY", 1.2, 2.0)
        scale_up2.setDuration(200)
        scale_up2.start()
        self.animators.append(scale_up2)

        alpha_out = ObjectAnimator.ofFloat(self.container, "alpha", 1.0, 0.0)
        alpha_out.setDuration(200)
        alpha_out.start()
        self.animators.append(alpha_out)

        def _cleanup():
            if self.callback:
                self.callback()

        run_on_ui_thread(_cleanup, 200)

    def get_view(self):
        return self.container

    def cleanup(self):
        try:
            for animator in self.animators:
                if animator:
                    animator.cancel()
            self.animators.clear()
            self.callback = None
            self.flame_view = None
            self.xp_view = None
            self.container = None
        except Exception as e:
            self.log(f"WSP: FloatingFlameParticle cleanup error: {e}")


# —Ö—É–∫–∏
class ChatActivityHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin) if plugin else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref
            if not plugin:
                return
            self.log("WSP: hook triggered")
            activity = param.thisObject
            dialog_id = activity.getDialogId()
            chat_id_str = str(dialog_id)
            self.log(f"WSP: chat_id={chat_id_str}")
            if plugin.guardAction(f"hook:{chat_id_str}", 0.4):
                return

            if plugin.isPrivateChat(chat_id_str):
                sync_manager = plugin.getSyncMgr()
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    current_time = time.time()
                    last_sync_time = plugin.last_auto_sync.get(chat_id_str, 0)
                    sync_interval_index = plugin.get_setting(
                        "auto_sync_interval", 1
                    )
                    sync_interval_map = [30, 60, 120, 300, 999999]
                    sync_interval = (
                        sync_interval_map[sync_interval_index]
                        if sync_interval_index < len(sync_interval_map)
                        else 60
                    )

                    if current_time - last_sync_time >= sync_interval:
                        if not plugin.shouldCheckServer(
                            chat_id_str, sync_interval
                        ):
                            self.log(
                                f"WSP: skipping auto-sync for {chat_id_str}, shared cooldown"
                            )
                        else:
                            def do_auto_sync():
                                try:
                                    if not sync_manager.checkServerHealth():
                                        plugin.recordSyncStatus(
                                            chat_id_str,
                                            "auto:server",
                                            False,
                                            "server_unavailable",
                                        )
                                        return
                                    my_user_id = plugin.getMyId()
                                    self.log(
                                        f"WSP: auto-sync got my_user_id={my_user_id}"
                                    )

                                    if my_user_id and my_user_id > 0:
                                        self.log(
                                            f"WSP: checking server for streak with chat {chat_id_str}"
                                        )
                                        server_data = (
                                            sync_manager.get_streak_from_server(
                                                my_user_id, chat_id_str
                                            )
                                        )

                                        if server_data:
                                            if server_data.get("deleted", False):
                                                local_streak = None
                                                apply_delete = True
                                                did_reset = False
                                                with self.plugin_ref.data_lock:
                                                    if (
                                                        chat_id_str
                                                        in self.plugin_ref.streak_enabled_chats
                                                    ):
                                                        streak_key = (
                                                            self.plugin_ref.getStreakKey(
                                                                chat_id_str
                                                            )
                                                        )
                                                        local_streak = (
                                                            self.plugin_ref.streaks.get(
                                                                streak_key
                                                            )
                                                        )
                                                        if (
                                                            local_streak
                                                            and not local_streak.deleted
                                                        ):
                                                            apply_delete = (
                                                                self.plugin_ref.shouldApplyRemoteDelete(
                                                                    local_streak,
                                                                    server_data,
                                                                    "server",
                                                                )
                                                            )

                                                    if not apply_delete:
                                                        self.log(
                                                            f"WSP: server streak deleted, keeping local for {chat_id_str}"
                                                        )
                                                    elif (
                                                        chat_id_str
                                                        in self.plugin_ref.streak_enabled_chats
                                                    ):
                                                        self.plugin_ref.streak_enabled_chats.discard(
                                                            chat_id_str
                                                        )
                                                        if local_streak:
                                                            self.plugin_ref.markStreakDeleted(
                                                                local_streak
                                                            )
                                                        did_reset = True

                                                if not apply_delete and local_streak:
                                                    self.plugin_ref.logSyncDecision(
                                                        "streak",
                                                        chat_id_str,
                                                        "server",
                                                        "keep_local",
                                                        reason="remote_deleted",
                                                        local_ts=local_streak.get_sync_data().get("timestamp"),
                                                        remote_ts=server_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.runAsync(
                                                        self.plugin_ref.syncStreak,
                                                        chat_id_str,
                                                        local_streak,
                                                        True,
                                                    )
                                                elif did_reset:
                                                    self.plugin_ref.logSyncDecision(
                                                        "streak",
                                                        chat_id_str,
                                                        "server",
                                                        "accept_delete",
                                                        reason="remote_deleted",
                                                        local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                                                        remote_ts=server_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.saveData()
                                                    self.log(
                                                        f"WSP: streak deleted by sync for {chat_id_str}, reset to 0"
                                                    )
                                            elif server_data.get("count", 0) > 0:
                                                if (
                                                    chat_id_str
                                                    in self.plugin_ref.streak_enabled_chats
                                                ):
                                                    streak_key = (
                                                        self.plugin_ref.getStreakKey(
                                                            chat_id_str
                                                        )
                                                    )
                                                    streak = (
                                                        self.plugin_ref.streaks.get(
                                                            streak_key
                                                        )
                                                    )
                                                if streak:
                                                    result = (
                                                        self.plugin_ref.mergeRemoteSync(
                                                            "streak",
                                                            chat_id_str,
                                                            streak,
                                                            server_data,
                                                            "server",
                                                            update_hash=True,
                                                        )
                                                    )
                                                    if result["applied"]:
                                                        self.plugin_ref.saveData()
                                                        self.log(
                                                            f"WSP: merged streak from server for {chat_id_str}, count={server_data.get('count', 0)}"
                                                        )
                                                    else:
                                                        self.log(
                                                            f"WSP: local streak is newer, keeping it"
                                                        )
                                                else:
                                                    with self.plugin_ref.data_lock:
                                                        self.plugin_ref.streak_enabled_chats.add(
                                                            chat_id_str
                                                        )
                                                    streak = (
                                                        self.plugin_ref.getOrCreateStreak(
                                                            chat_id_str
                                                        )
                                                    )
                                                    if streak:
                                                        streak.apply_sync_data(
                                                            server_data,
                                                            source="server",
                                                        )
                                                        self.plugin_ref.setSyncedHash(
                                                            chat_id_str,
                                                            streak_data=streak.get_sync_data(),
                                                        )
                                                        self.plugin_ref.saveData()
                                                        self.log(
                                                            f"WSP: auto-enabled streak from server for {chat_id_str}, count={server_data.get('count', 0)}"
                                                        )
                                            else:
                                                self.log(
                                                    f"WSP: streak on server has 0 count"
                                                )
                                        else:
                                            self.log(
                                                f"WSP: no streak found on server for chat {chat_id_str}"
                                            )

                                        self.log(
                                            f"WSP: checking server for pet with chat {chat_id_str}"
                                        )
                                        user1_id, user2_id = (
                                            self.plugin_ref.getSortedIds(
                                                chat_id_str
                                            )
                                        )
                                        pet_data = sync_manager.get_pet_from_server(
                                            user1_id, user2_id
                                        )
                                        if pet_data:
                                            if pet_data.get("deleted", False):
                                                local_pet = None
                                                apply_delete = True
                                                did_reset = False
                                                with self.plugin_ref.data_lock:
                                                    if (
                                                        chat_id_str
                                                        in self.plugin_ref.pet_enabled_chats
                                                    ):
                                                        local_pet = self.plugin_ref.pets.get(
                                                            chat_id_str
                                                        )
                                                        if (
                                                            local_pet
                                                            and not local_pet.deleted
                                                        ):
                                                            apply_delete = (
                                                                self.plugin_ref.shouldApplyRemoteDelete(
                                                                    local_pet,
                                                                    pet_data,
                                                                    "server",
                                                                )
                                                            )

                                                    if not apply_delete:
                                                        self.log(
                                                            f"WSP: server pet deleted, keeping local for {chat_id_str}"
                                                        )
                                                    elif (
                                                        chat_id_str
                                                        in self.plugin_ref.pet_enabled_chats
                                                    ):
                                                        self.plugin_ref.pet_enabled_chats.discard(
                                                            chat_id_str
                                                        )
                                                        if local_pet:
                                                            self.plugin_ref.markPetDeleted(
                                                                local_pet
                                                            )
                                                        did_reset = True

                                                if not apply_delete and local_pet:
                                                    self.plugin_ref.logSyncDecision(
                                                        "pet",
                                                        chat_id_str,
                                                        "server",
                                                        "keep_local",
                                                        reason="remote_deleted",
                                                        local_ts=local_pet.get_sync_data().get("timestamp"),
                                                        remote_ts=pet_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.runAsync(
                                                        self.plugin_ref.syncPet,
                                                        chat_id_str,
                                                        local_pet,
                                                        True,
                                                    )
                                                elif did_reset:
                                                    self.plugin_ref.logSyncDecision(
                                                        "pet",
                                                        chat_id_str,
                                                        "server",
                                                        "accept_delete",
                                                        reason="remote_deleted",
                                                        local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                                                        remote_ts=pet_data.get("timestamp"),
                                                    )
                                                    self.plugin_ref.saveData()
                                                    self.log(
                                                        f"WSP: pet deleted by sync for {chat_id_str}"
                                                    )
                                            elif not pet_data.get("deleted", False):
                                                with self.plugin_ref.data_lock:
                                                    self.plugin_ref.pet_enabled_chats.add(
                                                        chat_id_str
                                                    )
                                                pet = (
                                                    self.plugin_ref.getOrCreatePet(
                                                        chat_id_str
                                                    )
                                                )
                                                result = (
                                                    self.plugin_ref.mergeRemoteSync(
                                                        "pet",
                                                        chat_id_str,
                                                        pet,
                                                        pet_data,
                                                        "server",
                                                        update_hash=True,
                                                    )
                                                )
                                                if result["applied"]:
                                                    self.plugin_ref.saveData()
                                                    self.log(
                                                        f"WSP: pet auto-enabled and merged from server for {chat_id_str}, xp={pet_data.get('xp')}, stage={pet_data.get('stage')}"
                                                    )
                                                else:
                                                    self.log(
                                                        f"WSP: local pet is newer, keeping it"
                                                    )
                                            else:
                                                self.log(
                                                    f"WSP: pet on server is deleted, skipping"
                                                )
                                        else:
                                            self.log(
                                                f"WSP: no pet found on server for chat {chat_id_str}"
                                            )
                                    else:
                                        self.log(
                                            f"WSP: cannot auto-sync, my_user_id is invalid ({my_user_id})"
                                        )

                                    with self.plugin_ref.data_lock:
                                        self.plugin_ref.last_auto_sync[chat_id_str] = (
                                            time.time()
                                        )

                                except Exception as e:
                                    self.log(f"WSP: failed to auto-sync: {e}")

                                    self.log(
                                        f"WSP: auto-sync traceback: {traceback.format_exc()}"
                                    )

                            self.plugin_ref.runAsync(do_auto_sync)
                    else:
                        self.log(
                            f"WSP: skipping auto-sync for {chat_id_str}, synced {int(current_time - last_sync_time)}s ago"
                        )

            show_widget = self.plugin_ref.get_setting("show_widget", True)
            self.log(
                f"WSP: show_widget={show_widget}, is_private={self.plugin_ref.isPrivateChat(chat_id_str)}"
            )

            if not show_widget:
                return

            if not self.plugin_ref.isPrivateChat(chat_id_str):
                self.log(f"WSP: skipping widget for non-private chat {chat_id_str}")
                return

            if chat_id_str not in self.plugin_ref.pet_enabled_chats:
                self.log(
                    f"WSP: skipping widget for {chat_id_str} - pet not enabled by user"
                )
                return

            if chat_id_str not in self.plugin_ref.pets:
                self.log(f"WSP: skipping widget for {chat_id_str} - pet not found")
                return

            try:
                LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                launch_activity = None

                for fname in ("instance", "Instance", "INSTANCE", "lastInstance"):
                    try:
                        launch_activity = getattr(LaunchActivity, fname, None)
                        if launch_activity:
                            break
                    except Exception:
                        pass

                if not launch_activity:
                    self.log("WSP: LaunchActivity not found!")
                    return

                window = launch_activity.getWindow()
                if not window:
                    self.log("WSP: window is None!")
                    return

                decor_view = window.getDecorView()
                if not decor_view:
                    self.log("WSP: decor_view is None!")
                    return
            except Exception as e:
                self.log(f"WSP: failed to get DecorView: {e}")
                return

            if self.plugin_ref.widget_manager:
                with self.plugin_ref.data_lock:
                    for old_chat_id in list(self.plugin_ref.active_widgets.keys()):
                        if old_chat_id != chat_id_str:
                            self.plugin_ref.widget_manager.remove_widgets_for_chat(
                                old_chat_id
                            )
                            if old_chat_id in self.plugin_ref.active_widgets:
                                del self.plugin_ref.active_widgets[old_chat_id]

                widget = self.plugin_ref.widget_manager.create_pet_widget(
                    chat_id_str, decor_view
                )
                if widget:
                    self.plugin_ref.active_widgets[chat_id_str] = widget
                    self.log(
                        f"WSP: floating widget added successfully! chat={chat_id_str}"
                    )
            else:
                self.log("WSP: widget_manager is None, cannot create widget")

            if (
                self.plugin_ref.isPrivateChat(chat_id_str)
                and chat_id_str in self.plugin_ref.streak_enabled_chats
                and self.plugin_ref.widget_manager
            ):
                try:
                    action_bar = activity.getActionBar()
                    if action_bar:
                        badge = self.plugin_ref.widget_manager.create_streak_badge(
                            chat_id_str, action_bar
                        )
                        if badge:
                            if not hasattr(self.plugin_ref, "active_streak_badges"):
                                self.plugin_ref.active_streak_badges = {}
                            self.plugin_ref.active_streak_badges[chat_id_str] = badge
                        else:
                            self.log(f"WSP: streak badge not created for {chat_id_str}")
                    else:
                        self.log("WSP: action_bar is None")
                except Exception as e:
                    self.log(f"WSP: streak badge fail: {e}")

                    self.log(f"WSP: traceback: {traceback.format_exc()}")

        except Exception as e:
            self.log(f"WSP floating widget fail: {e}")

            self.log(f"WSP traceback: {traceback.format_exc()}")


# –º–µ–Ω–µ–¥–∂–µ—Ä –≤–∏–¥–∂–µ—Ç–æ–≤
class WidgetManager:
    def __init__(self, plugin_ref):
        self._plugin_ref = weakref.ref(plugin_ref) if plugin_ref else None
        self.active_pet_widgets = {}
        self.active_streak_badges = {}

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def create_pet_widget(self, chat_id, decor_view):
        try:
            old_widget = decor_view.findViewWithTag("telepet_floating")
            if old_widget:
                decor_view.removeView(old_widget)

            if chat_id in self.active_pet_widgets:
                old = self.active_pet_widgets[chat_id]
                if hasattr(old, "cleanup"):
                    old.cleanup()
                del self.active_pet_widgets[chat_id]

            context = decor_view.getContext()
            widget = FloatingPetWidget(context, self.plugin, chat_id)
            widget_view = widget.get_view()
            widget_view.setTag("telepet_floating")
            widget._attach_smart_hide(decor_view)

            layout_params = widget_view.getLayoutParams()
            if not layout_params:
                size_px = AndroidUtilities.dp(Dp.S160)
                layout_params = FrameLayout.LayoutParams(size_px, size_px)
                self.log("WSP: created fallback layout_params")
            else:
                self.log(
                    f"WSP: using existing layout_params: width={layout_params.width}, height={layout_params.height}"
                )

            decor_view.addView(widget_view, layout_params)
            self.log(f"WSP: widget_view added to decor_view")
            self.active_pet_widgets[chat_id] = widget
            self.log(f"WSP: widget registered in active_pet_widgets for chat {chat_id}")

            position = self.plugin.get_setting("widget_position", 0)
            margin_dp = 16

            def set_initial_position():
                try:
                    self.log(f"WSP: set_initial_position called for chat {chat_id}")
                    if hasattr(widget, "user_has_moved") and widget.user_has_moved:
                        self.log(
                            f"WSP: skipping set_initial_position - user has already moved widget"
                        )
                        return

                    if chat_id in self.plugin.widget_positions:
                        saved_pos = self.plugin.widget_positions[chat_id]
                        saved_x = saved_pos.get("x", 0)
                        saved_y = saved_pos.get("y", 0)

                        parent_width = decor_view.getWidth()
                        parent_height = decor_view.getHeight()
                        widget_size = AndroidUtilities.dp(Dp.S80)
                        margin = AndroidUtilities.dp(Dp.S8)

                        max_x = parent_width - widget_size - margin
                        max_y = parent_height - widget_size - margin

                        widget.offset_x = max(margin, min(saved_x, max_x))
                        widget.offset_y = max(margin, min(saved_y, max_y))
                        self.log(
                            f"WSP: restored saved position for chat {chat_id}: x={widget.offset_x}, y={widget.offset_y}"
                        )
                    else:
                        margin_px = AndroidUtilities.dp(margin_dp)
                        widget_width = widget_view.getWidth()
                        widget_height = widget_view.getHeight()

                        if position == 0:
                            widget.offset_x = margin_px
                            widget.offset_y = margin_px
                        elif position == 1:
                            parent_width = decor_view.getWidth()
                            widget.offset_x = parent_width - widget_width - margin_px
                            widget.offset_y = margin_px
                        elif position == 2:
                            parent_height = decor_view.getHeight()
                            widget.offset_x = margin_px
                            widget.offset_y = parent_height - widget_height - margin_px
                        else:
                            parent_width = decor_view.getWidth()
                            parent_height = decor_view.getHeight()
                            widget.offset_x = parent_width - widget_width - margin_px
                            widget.offset_y = parent_height - widget_height - margin_px

                    widget_view.setTranslationX(widget.offset_x)
                    widget_view.setTranslationY(widget.offset_y)
                    actual_trans_x = widget_view.getTranslationX()
                    actual_trans_y = widget_view.getTranslationY()
                    self.log(
                        f"WSP: widget positioned at translationX={widget.offset_x}, translationY={widget.offset_y}"
                    )
                    self.log(
                        f"WSP: widget actual translation: x={actual_trans_x}, y={actual_trans_y}"
                    )
                    self.log(
                        f"WSP: widget dimensions: width={widget_view.getWidth()}, height={widget_view.getHeight()}"
                    )
                    self.log(
                        f"WSP: parent dimensions: width={decor_view.getWidth()}, height={decor_view.getHeight()}"
                    )

                    widget._start_animation()
                    widget.play_entry_animation()
                    self.log(f"WSP: animation started for widget at correct position")
                except Exception as e:
                    self.log(f"WSP: error setting widget position: {e}")

            run_on_ui_thread(set_initial_position)

            pet = self.plugin.pets.get(chat_id)
            if pet:
                self.log(
                    f"WSP: pet widget created for {chat_id}: {pet.get_emoji()} stage={pet.stage}"
                )

            return widget
        except Exception as e:
            self.log(f"WSP: failed to create pet widget: {e}")
            return None

    def create_streak_badge(self, chat_id, action_bar):
        self.log(f"WSP: create_streak_badge called for chat {chat_id}")
        try:
            action_bar_view = None
            try:
                if hasattr(action_bar, "getView"):
                    action_bar_view = action_bar.getView()
                    self.log("WSP: got action_bar_view via getView()")
                elif hasattr(action_bar, "container"):
                    action_bar_view = action_bar.container
                    self.log("WSP: got action_bar_view via container")
                else:
                    action_bar_view = action_bar
                    self.log("WSP: using action_bar directly as view")
            except Exception as e:
                self.log(f"WSP: error getting action_bar_view: {e}")
                pass

            if not action_bar_view:
                self.log("WSP: action_bar_view is None, cannot create streak badge")
                return None

            old_badge = action_bar_view.findViewWithTag("wsp_streak_badge")
            if old_badge:
                action_bar_view.removeView(old_badge)

            if chat_id in self.active_streak_badges:
                old = self.active_streak_badges[chat_id]
                if hasattr(old, "cleanup"):
                    old.cleanup()
                del self.active_streak_badges[chat_id]

            streak_key = self.plugin.getStreakKey(chat_id)
            self.log(f"WSP: looking for streak with key: {streak_key}")

            streak = self.plugin.streaks.get(streak_key)
            if not streak:
                self.log(
                    f"WSP: no streak found for key {streak_key} (chat_id={chat_id})"
                )
                self.log(
                    f"WSP: available streak keys: {list(self.plugin.streaks.keys())}"
                )
                return None

            if streak.check_and_reset_if_expired():
                self.log(
                    f"WSP: streak state updated for chat {chat_id}, syncing"
                )
                try:
                    if streak.is_dead:
                        self.plugin.onStreakDied(chat_id)
                        self.plugin.runAsync(
                            self.plugin.syncStreak, chat_id, streak, True
                        )
                        self.plugin.saveData()
                        return None
                    self.plugin.runAsync(
                        self.plugin.syncStreak, chat_id, streak, True
                    )
                    self.plugin.saveData()
                except Exception as e:
                    self.log(f"WSP: failed to sync streak update: {e}")

            if not streak.is_unlocked:
                if streak.count > 0:
                    self.log(
                        f"WSP: streak count is {streak.count} for chat {chat_id}, but not unlocked (deleted or count=0)"
                    )
                else:
                    self.log(
                        f"WSP: streak count is {streak.count} for chat {chat_id}, not creating badge"
                    )
                return None

            self.log(f"WSP: streak found: count={streak.count}, warning={streak.is_warning}")

            context = action_bar_view.getContext()
            flame_emoji = self.plugin.get_setting("streak_emoji", "üî•")

            badge = StreakBadgeWidget(
                context,
                self.plugin,
                chat_id,
                streak.count,
                flame_emoji,
                is_warning=streak.is_warning,
            )
            badge_view = badge.get_view()
            badge_view.setTag("wsp_streak_badge")
            badge_params = FrameLayout.LayoutParams(
                AndroidUtilities.dp(Dp.BTN_H), AndroidUtilities.dp(Dp.BTN_H)
            )

            action_bar_view.addView(badge_view, badge_params)
            self.active_streak_badges[chat_id] = badge

            def set_badge_position():
                try:
                    badge_key = f"streak_{chat_id}"
                    parent_width = action_bar_view.getWidth()
                    parent_height = action_bar_view.getHeight()
                    badge_size = AndroidUtilities.dp(Dp.BTN_H)
                    margin = AndroidUtilities.dp(Dp.S8)

                    if badge_key in self.plugin.widget_positions:
                        saved_pos = self.plugin.widget_positions[badge_key]
                        saved_x = saved_pos.get("x", 0)
                        saved_y = saved_pos.get("y", 0)

                        max_x = parent_width - badge_size - margin
                        max_y = parent_height - badge_size - margin
                        trans_x = max(margin, min(saved_x, max_x))
                        trans_y = max(margin, min(saved_y, max_y))

                        self.log(
                            f"WSP: restored streak badge position: saved=({saved_x},{saved_y}) -> validated=({trans_x},{trans_y})"
                        )
                    else:
                        trans_x = parent_width - badge_size - margin
                        trans_y = margin
                        self.log(
                            f"WSP: using default streak badge position: x={trans_x}, y={trans_y}"
                        )

                    badge_view.setTranslationX(trans_x)
                    badge_view.setTranslationY(trans_y)
                    badge.offset_x = trans_x
                    badge.offset_y = trans_y
                except Exception as e:
                    self.log(f"WSP: error setting streak badge position: {e}")

            run_on_ui_thread(set_badge_position)

            badge_x = badge_view.getX()
            badge_y = badge_view.getY()
            badge_visible = badge_view.getVisibility()
            self.log(
                f"WSP: streak badge created for {chat_id}: {flame_emoji} {streak.count}"
            )
            self.log(
                f"WSP: streak badge position: x={badge_x}, y={badge_y}, visibility={badge_visible}"
            )
            return badge
        except Exception as e:
            self.log(f"WSP: failed to create streak badge: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")
            return None

    def remove_widgets_for_chat(self, chat_id):
        if chat_id in self.active_pet_widgets:
            try:
                widget = self.active_pet_widgets[chat_id]
                if hasattr(widget, "cleanup"):
                    widget.cleanup()
                del self.active_pet_widgets[chat_id]
                self.log(f"WSP: removed pet widget for {chat_id}")
            except Exception as e:
                self.log(f"WSP: error removing pet widget: {e}")

        if chat_id in self.active_streak_badges:
            try:
                badge = self.active_streak_badges[chat_id]
                if hasattr(badge, "cleanup"):
                    badge.cleanup()
                del self.active_streak_badges[chat_id]
                self.log(f"WSP: removed streak badge for {chat_id}")
            except Exception as e:
                self.log(f"WSP: error removing streak badge: {e}")


class WidgetCleanupHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin) if plugin else None

    @property
    def plugin_ref(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin_ref
        if p:
            p.log(msg)
        else:
            log(msg)

    def after_hooked_method(self, param):
        try:
            self.log("WSP: cleanup hook triggered")
            activity = param.thisObject
            dialog_id = activity.getDialogId()
            chat_id_str = str(dialog_id)
            self.log(f"WSP: cleaning up for chat_id={chat_id_str}")

            if self.plugin_ref.widget_manager:
                self.plugin_ref.widget_manager.remove_widgets_for_chat(chat_id_str)

            with self.plugin_ref.data_lock:
                if chat_id_str in self.plugin_ref.active_widgets:
                    del self.plugin_ref.active_widgets[chat_id_str]
                if (
                    hasattr(self.plugin_ref, "active_streak_badges")
                    and chat_id_str in self.plugin_ref.active_streak_badges
                ):
                    del self.plugin_ref.active_streak_badges[chat_id_str]

        except Exception as e:
            self.log(f"WSP cleanup hook fail: {e}")

            self.log(f"WSP cleanup traceback: {traceback.format_exc()}")


# —à–∏—Ç—ã
class PetMenuBottomSheet(SafeSheet):
    def __init__(self, context, plugin, chat_id):
        super().__init__(context, plugin, chat_id)
        self.pet = plugin.pets.get(chat_id) if plugin else None
        if self.pet:
            self._init_sheet(with_handle=False)

    def _build_content(self, content):
        if not self.pet:
            return

        self._add_header(content, self.pet.get_emoji(), self.pet.name, self.pet.get_stage_name())
        self._add_divider(content)

        stats = LinearLayout(self.context)
        stats.setOrientation(LinearLayout.VERTICAL)
        stats.setPadding(AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S16),
                         AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S16))

        self._add_info_row(stats, S.XP, f"{self.pet.xp} XP")
        self._add_info_row(stats, S.MOOD, f"{self.pet.mood}%")

        xp_to_next = self.pet.xp_to_next_stage()
        if xp_to_next > 0:
            self._add_info_row(stats, S.NEXT_STAGE, f"{xp_to_next} XP")
        else:
            self._add_info_row(stats, S.MAX_LEVEL, tr("–ú–∞–∫—Å–∏–º—É–º", "Max"))

        self._add_progress_bar(stats)
        content.addView(stats)

    def _add_progress_bar(self, container):
        progress_wrap = LinearLayout(self.context)
        progress_wrap.setOrientation(LinearLayout.VERTICAL)
        progress_wrap.setPadding(AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S8),
                                  AndroidUtilities.dp(Dp.S16), AndroidUtilities.dp(Dp.S8))

        label = TextView(self.context)
        label.setText(tr("–ü—Ä–æ–≥—Ä–µ—Å—Å", "Progress"))
        label.setTextSize(1, 14)
        label.setTextColor(UI.on_surface())
        progress_wrap.addView(label)

        current_xp = PET_STAGES[self.pet.stage]["xp"]
        if self.pet.stage >= len(PET_STAGES) - 1:
            fill = 100
        else:
            next_xp = PET_STAGES[self.pet.stage + 1]["xp"]
            xp_range = next_xp - current_xp
            fill = int((self.pet.xp - current_xp) / xp_range * 100) if xp_range > 0 else 100

        bar = LinearLayout(self.context)
        bar.setOrientation(LinearLayout.HORIZONTAL)
        bar.setBackgroundColor(UI.outline())
        bar_params = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(Dp.S8))
        bar_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

        fg = View(self.context)
        fg.setBackgroundColor(Color.parseColor("#FFD700"))
        bar.addView(fg, LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), fill))

        bg = View(self.context)
        bg.setBackgroundColor(Color.TRANSPARENT)
        bar.addView(bg, LinearLayout.LayoutParams(0, AndroidUtilities.dp(Dp.S8), 100 - fill))

        progress_wrap.addView(bar, bar_params)
        container.addView(progress_wrap)

    def _build_buttons(self):
        feed_btn = UI.button(self.context, S.FEED_SHORT,
                             lambda v: self.do_action(lambda p, c: p.feed_pet({"chat_id": c})), "filled")
        close_btn = UI.button(self.context, S.CLOSE, lambda v: self.dismiss(), "text")
        return self._create_button_row(feed_btn, close_btn)


class EvolutionBottomSheet:
    def __init__(self, context, pet):
        self.context = context
        self.pet = pet
        self.log = log
        self._dismissed = False
        self._dismiss_listener = None

        self.bottom_sheet = BottomSheet(context, False)

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(UI.surface())
        UI.elevation(container, ELEVATION_SHEET)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setBackgroundColor(UI.surface())

        header = LinearLayout(context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.BTN_H),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.BTN_H),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(0)
        try:
            bg.setGradientType(GradientDrawable.LINEAR_GRADIENT)
            color1 = jint32(0xFFFF6B9D)
            color2 = jint32(0xFFC06FBB)
            bg.setColors([color1, color2])
            bg.setOrientation(GradientDrawable.Orientation.TL_BR)
        except Exception:
            bg.setColor(jint32(0xFFFF6B9D))
        header.setBackground(bg)

        sparkle = TextView(context)
        sparkle.setText("‚ú®")
        sparkle.setTextSize(1, 48)
        sparkle.setGravity(Gravity.CENTER)
        header.addView(sparkle)

        title_tv = TextView(context)
        title_tv.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è", "Evolution"))
        title_tv.setTextSize(1, 28)
        title_tv.setTextColor(jint32(0xFFFFFFFF))
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        header.addView(title_tv, title_params)

        emoji = pet.get_emoji()
        emoji_tv = TextView(context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 96)
        emoji_tv.setGravity(Gravity.CENTER)
        emoji_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        emoji_params.setMargins(0, AndroidUtilities.dp(Dp.S24), 0, 0)
        header.addView(emoji_tv, emoji_params)

        stage_name = pet.get_stage_name()
        name_tv = TextView(context)
        name_tv.setText(
            tr(
                f"{pet.name} —Å—Ç–∞–ª {stage_name}",
                f"{pet.name} became {stage_name}",
            )
        )
        name_tv.setTextSize(1, 18)
        name_tv.setTextColor(jint32(0xFFFFFFFF))
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        header.addView(name_tv, name_params)

        level_tv = TextView(context)
        level_tv.setText(tr(f"–£—Ä–æ–≤–µ–Ω—å {pet.stage}", f"Level {pet.stage}"))
        level_tv.setTextSize(1, 16)
        level_tv.setTextColor(jint32(0xFFFFFFFF))
        level_tv.setGravity(Gravity.CENTER)
        level_tv.setAlpha(0.9)
        level_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        level_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(level_tv, level_params)

        content.addView(header)

        button_container = LinearLayout(context)
        button_container.setOrientation(LinearLayout.VERTICAL)
        button_container.setBackgroundColor(UI.surface())

        divider = View(context)
        divider.setBackgroundColor(Theme.getColor(Theme.key_divider))
        divider_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 1
        )
        button_container.addView(divider, divider_params)

        button_row = LinearLayout(context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)
        button_row.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        close_btn = TextView(context)
        close_btn.setText(tr("–ì–æ—Ç–æ–≤–æ", "Done"))
        close_btn.setTextSize(1, 15)
        close_btn.setTextColor(Theme.getColor(Theme.key_featuredStickers_buttonText))
        close_btn.setGravity(Gravity.CENTER)
        close_btn.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
        )
        close_btn.setTypeface(None, Typeface.BOLD)

        bg_btn = UI.bg_ripple(Dp.CORNER_LG, UI.primary(), UI.on_primary())
        close_btn.setBackground(bg_btn)
        close_btn.setTextColor(UI.on_primary())
        UI.elevation(close_btn, ELEVATION_BUTTON)

        close_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))

        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        button_row.addView(close_btn, button_params)

        button_container.addView(button_row)

        container.addView(content)
        container.addView(button_container)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        self.pet = None
        self.context = None
        self.bottom_sheet = None
        self._dismiss_listener = None

    def show(self):
        try:
            self.bottom_sheet.show()
        except Exception as e:
            self.log(f"WSP: error showing evolution: {e}")

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing evolution: {e}")
        finally:
            self.onDismiss()


class PetStatsBottomSheet:
    def __init__(self, context, plugin, chat_id):
        self.context = context
        self._plugin_ref = weakref.ref(plugin) if plugin else None
        self.chat_id = chat_id
        self.bottom_sheet = BottomSheet(context, False)
        self._dismissed = False
        self._dismiss_listener = None

        if plugin:
            self.log(f"WSP: PetStatsBottomSheet.__init__ called with chat_id={chat_id}")

        if not plugin:
            self.log("WSP ERROR: plugin is None in PetStatsBottomSheet.__init__")
            self._build_error_screen()
            return

        pet = plugin.pets.get(chat_id)
        streak = plugin.getOrCreateStreak(chat_id)
        is_active = chat_id in plugin.pet_enabled_chats

        if not pet and not is_active:
            self._build_invite_screen()
            return

        if not is_active:
            self._build_activation_screen(pet)
            return

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackground(UI.bg_sheet())

        handle_container = LinearLayout(context)
        handle_container.setOrientation(LinearLayout.VERTICAL)
        handle_container.setGravity(Gravity.CENTER)
        handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

        handle = View(context)
        handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
        handle_bg = GradientDrawable()
        handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        handle_bg.setColor(UI.outline())
        handle.setBackground(handle_bg)
        handle_container.addView(handle, handle_params)
        container.addView(handle_container)

        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)

        self._build_header(content, pet)
        self._build_status_cards(content, pet, streak)
        self._build_evolution_section(content, pet)

        scroll_view.addView(content)

        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        button_container = self._create_buttons(is_active, pet)
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        container.addView(button_container, button_params)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def attachDismissListener(self):
        if not self.bottom_sheet:
            return
        try:
            from java import dynamic_proxy
            from android.content import DialogInterface

            DismissListener = dynamic_proxy(DialogInterface.OnDismissListener)
            owner = self

            class _DismissListener(DismissListener):
                def onDismiss(self, dialog):
                    try:
                        owner.onDismiss()
                    except Exception:
                        pass

            self._dismiss_listener = _DismissListener()
            self.bottom_sheet.setOnDismissListener(self._dismiss_listener)
        except Exception:
            self._dismiss_listener = None

    def onDismiss(self):
        if self._dismissed:
            return
        self._dismissed = True
        self._plugin_ref = None
        self.context = None
        self.chat_id = None
        self.bottom_sheet = None
        self._dismiss_listener = None

    def _build_error_screen(self):
        error_tv = TextView(self.context)
        error_tv.setText(
            tr("–ü–ª–∞–≥–∏–Ω –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω", "Plugin not initialized")
        )
        error_tv.setTextSize(1, 16)
        error_tv.setTextColor(UI.error())
        error_tv.setGravity(Gravity.CENTER)
        error_tv.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )
        self.bottom_sheet.setCustomView(error_tv)
        self.attachDismissListener()

    def _build_invite_screen(self):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setGravity(Gravity.CENTER)
        container.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )

        container.setBackground(UI.bg_sheet())

        emoji_tv = TextView(self.context)
        emoji_tv.setText("ü•ö")
        emoji_tv.setTextSize(1, 72)
        emoji_tv.setGravity(Gravity.CENTER)
        container.addView(emoji_tv)

        title_tv = TextView(self.context)
        title_tv.setText(tr("–ü–∏—Ç–æ–º–µ—Ü", "Pet"))
        title_tv.setTextSize(1, 24)
        title_tv.setTextColor(UI.on_surface())
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        container.addView(title_tv, title_params)

        desc_tv = TextView(self.context)
        desc_tv.setText(
            tr(
                "–ü–∏—à–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å XP\n–∏ —Ä–∞—Å—Ç–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞",
                "Write to earn XP\nand grow your pet",
            )
        )
        desc_tv.setTextSize(1, 14)
        desc_tv.setTextColor(UI.on_surface())
        desc_tv.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        container.addView(desc_tv, desc_params)

        stages_preview = self._create_stages_preview()
        stages_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        stages_params.setMargins(0, AndroidUtilities.dp(Dp.S24), 0, 0)
        container.addView(stages_preview, stages_params)

        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setPadding(0, AndroidUtilities.dp(Dp.S24), 0, 0)

        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        close_btn = UI.button(self.context, tr("–û—Ç–º–µ–Ω–∞", "Cancel"), lambda *args: self.dismiss(), "tonal")
        btn_container.addView(close_btn, btn_params)

        start_btn = UI.button(self.context, tr("–°–æ–∑–¥–∞—Ç—å", "Create"), lambda *args: self._onstartPet(), "filled")
        btn_container.addView(start_btn, btn_params)

        container.addView(btn_container)

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_activation_screen(self, pet):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setGravity(Gravity.CENTER)
        container.setPadding(
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
            AndroidUtilities.dp(Dp.S32),
        )

        container.setBackground(UI.bg_sheet())

        emoji = pet.get_emoji() if pet else "ü•ö"
        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 72)
        emoji_tv.setGravity(Gravity.CENTER)
        container.addView(emoji_tv)

        title_tv = TextView(self.context)
        title_tv.setText(tr("–ü–∏—Ç–æ–º–µ—Ü –≤—ã–∫–ª—é—á–µ–Ω", "Pet is off"))
        title_tv.setTextSize(1, 24)
        title_tv.setTextColor(UI.on_surface())
        title_tv.setTypeface(None, Typeface.BOLD)
        title_tv.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        container.addView(title_tv, title_params)

        desc_tv = TextView(self.context)
        desc_tv.setText(
            tr(
                "–í–∫–ª—é—á–∏, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å XP\n–∑–∞ —Å–æ–æ–±—â–µ–Ω–∏—è",
                "Turn on to earn XP\nfrom messages",
            )
        )
        desc_tv.setTextSize(1, 14)
        desc_tv.setTextColor(UI.on_surface())
        desc_tv.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        container.addView(desc_tv, desc_params)

        btn_container = LinearLayout(self.context)
        btn_container.setOrientation(LinearLayout.HORIZONTAL)
        btn_container.setPadding(0, AndroidUtilities.dp(Dp.S24), 0, 0)

        btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        close_btn = UI.button(self.context, tr("–û—Ç–º–µ–Ω–∞", "Cancel"), lambda *args: self.dismiss(), "tonal")
        btn_container.addView(close_btn, btn_params)

        start_btn = UI.button(self.context, tr("–í–∫–ª—é—á–∏—Ç—å", "Turn on"), lambda *args: self._onstartPet(), "filled")
        btn_container.addView(start_btn, btn_params)

        container.addView(btn_container)
        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()

    def _build_header(self, container, pet):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji = pet.get_emoji()
        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 56)
        emoji_tv.setGravity(Gravity.CENTER)
        header.addView(emoji_tv)

        name_tv = TextView(self.context)
        name_tv.setText(pet.name)
        name_tv.setTextSize(1, 22)
        name_tv.setTextColor(UI.on_surface())
        name_tv.setTypeface(None, Typeface.BOLD)
        name_tv.setGravity(Gravity.CENTER)
        name_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        name_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(name_tv, name_params)

        stage_chip = TextView(self.context)
        stage_chip.setText(pet.get_stage_name())
        stage_chip.setTextSize(1, 12)
        stage_chip.setTextColor(get_on_primary_container())
        stage_chip.setGravity(Gravity.CENTER)
        stage_chip.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S4),
        )
        chip_bg = GradientDrawable()
        chip_bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
        chip_bg.setColor(UI.primary_container())
        stage_chip.setBackground(chip_bg)
        chip_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        chip_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(stage_chip, chip_params)

        xp_tv = TextView(self.context)
        xp_tv.setText(
            f"‚ö° {pet.xp} XP  ‚Ä¢  {tr('–£—Ä.', 'Lv.')} {pet.level}"
        )
        xp_tv.setTextSize(1, 13)
        xp_tv.setTextColor(UI.on_surface())
        xp_tv.setGravity(Gravity.CENTER)
        xp_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(xp_tv, xp_params)

        container.addView(header)

    def _build_status_cards(self, container, pet, streak):
        pet.update_state()

        if pet.deleted:
            dead_card = LinearLayout(self.context)
            dead_card.setOrientation(LinearLayout.VERTICAL)
            dead_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S12),
            )
            dead_bg = GradientDrawable()
            dead_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            dead_bg.setColor(UI.error_container())
            dead_card.setBackground(dead_bg)

            dead_title = TextView(self.context)
            dead_title.setText(tr("üí§ –ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω", "üí§ Pet inactive"))
            dead_title.setTextSize(1, 14)
            dead_title.setTextColor(get_on_error_container())
            dead_title.setTypeface(None, Typeface.BOLD)
            dead_card.addView(dead_title)

            dead_desc = TextView(self.context)
            dead_desc.setText(
                tr(
                    f"–ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª: {REVIVE_XP_COST} XP, —Ä–∞–∑ –≤ {int(REVIVE_COOLDOWN_SECONDS/3600)}—á",
                    f"Tap ‚ÄúRevive‚Äù: {REVIVE_XP_COST} XP, every {int(REVIVE_COOLDOWN_SECONDS/3600)}h",
                )
            )
            dead_desc.setTextSize(1, 11)
            dead_desc.setTextColor(get_on_error_container())
            dead_desc.setAlpha(0.8)
            dead_desc_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            dead_desc_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            dead_card.addView(dead_desc, dead_desc_params)

            dead_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            dead_params.setMargins(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S8),
                AndroidUtilities.dp(Dp.S16),
                0,
            )
            container.addView(dead_card, dead_params)

        cards_container = LinearLayout(self.context)
        cards_container.setOrientation(LinearLayout.HORIZONTAL)
        cards_container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        card_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        hunger_color = UI.primary() if pet.hunger >= HUNGER_MEDIUM_THRESHOLD else UI.error()
        hunger_card = self._create_status_card(
            "üçñ",
            f"{int(pet.hunger)}%",
            tr("–°—ã—Ç–æ—Å—Ç—å", "Hunger"),
            hunger_color,
            pet.hunger / 100.0,
        )
        cards_container.addView(hunger_card, card_params)

        mood_color = UI.primary() if pet.mood >= MOOD_MEDIUM_THRESHOLD else UI.error()
        mood_card = self._create_status_card(
            "‚ù§Ô∏è",
            f"{int(pet.mood)}%",
            tr("–ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ", "Mood"),
            mood_color,
            pet.mood / 100.0,
        )
        cards_container.addView(mood_card, card_params)

        if streak:
            flame = streak.get_flame_emoji()
            streak_card = self._create_status_card(
                flame,
                f"{streak.count}",
                tr("–î–Ω–µ–π", "Days"),
                UI.primary(),
                min(streak.count / 30.0, 1.0),
            )
            cards_container.addView(streak_card, card_params)

        container.addView(cards_container)

    def _create_status_card(self, emoji, value, label, color, progress):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        card.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 24)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 18)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(value_tv, value_params)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface())
        label_tv.setGravity(Gravity.CENTER)
        card.addView(label_tv)

        bar_container = FrameLayout(self.context)
        bar_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(Dp.S4)
        )
        bar_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        bar_container.setLayoutParams(bar_params)

        bar_bg = View(self.context)
        bar_bg_drawable = GradientDrawable()
        bar_bg_drawable.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        bar_bg_drawable.setColor(UI.outline())
        bar_bg.setBackground(bar_bg_drawable)
        bar_bg.setLayoutParams(FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(Dp.S4)
        ))
        bar_container.addView(bar_bg)

        bar_fill = View(self.context)
        bar_fill_drawable = GradientDrawable()
        bar_fill_drawable.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        bar_fill_drawable.setColor(color)
        bar_fill.setBackground(bar_fill_drawable)
        bar_fill.setLayoutParams(FrameLayout.LayoutParams(
            int(FrameLayout.LayoutParams.MATCH_PARENT * max(0.05, min(1.0, progress))),
            AndroidUtilities.dp(Dp.S4)
        ))
        bar_container.addView(bar_fill)

        card.addView(bar_container, bar_params)

        return card

    def _build_evolution_section(self, container, pet):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è", "Evolution"))
        title.setTextSize(1, 14)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S12))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        emoji_style = self.plugin.get_setting("pet_emoji_style", 0) if self.plugin else 0
        stages = PET_STAGES_BY_STYLE.get(emoji_style, PET_STAGES_BY_STYLE[0])

        for stage_num, stage_data in stages.items():
            is_current = stage_num == pet.stage
            is_achieved = stage_num <= pet.stage
            stage_item = self._create_evolution_item(
                stage_data["emoji"],
                str(stage_num),
                is_current,
                is_achieved
            )
            stage_params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            stages_row.addView(stage_item, stage_params)

        section.addView(stages_row)

        xp_to_next = pet.xp_to_next_stage()
        xp_card = self._build_xp_progress_card(pet, xp_to_next)
        xp_card_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        xp_card_params.setMargins(0, AndroidUtilities.dp(Dp.S16), 0, 0)
        section.addView(xp_card, xp_card_params)

        container.addView(section)

    def _build_xp_progress_card(self, pet, xp_to_next):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S14),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S14),
        )

        card_bg = GradientDrawable()
        card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        card_bg.setColor(UI.surface_variant())
        card.setBackground(card_bg)

        header_row = LinearLayout(self.context)
        header_row.setOrientation(LinearLayout.HORIZONTAL)
        header_row.setGravity(Gravity.CENTER_VERTICAL)

        emoji_style = self.plugin.get_setting("pet_emoji_style", 0) if self.plugin else 0
        stages = PET_STAGES_BY_STYLE.get(emoji_style, PET_STAGES_BY_STYLE[0])

        current_emoji = stages[pet.stage - 1]["emoji"] if pet.stage > 0 else "ü•ö"
        current_stage_tv = TextView(self.context)
        current_stage_tv.setText(current_emoji)
        current_stage_tv.setTextSize(1, 28)
        header_row.addView(current_stage_tv)

        if xp_to_next > 0 and pet.stage < len(stages):
            arrow_tv = TextView(self.context)
            arrow_tv.setText("  ‚Üí  ")
            arrow_tv.setTextSize(1, 16)
            arrow_tv.setTextColor(UI.on_surface_variant())
            header_row.addView(arrow_tv)

            next_emoji = stages[pet.stage]["emoji"] if pet.stage < len(stages) else "üëë"
            next_stage_tv = TextView(self.context)
            next_stage_tv.setText(next_emoji)
            next_stage_tv.setTextSize(1, 28)
            next_stage_tv.setAlpha(0.5)
            header_row.addView(next_stage_tv)

            spacer = View(self.context)
            spacer_params = LinearLayout.LayoutParams(0, 1, 1.0)
            header_row.addView(spacer, spacer_params)

            stage_num_tv = TextView(self.context)
            stage_num_tv.setText(
                tr(
                    f"–°—Ç–∞–¥–∏—è {pet.stage}/{len(stages)}",
                    f"Stage {pet.stage}/{len(stages)}",
                )
            )
            stage_num_tv.setTextSize(1, 12)
            stage_num_tv.setTextColor(UI.on_surface_variant())
            header_row.addView(stage_num_tv)
        else:
            spacer = View(self.context)
            spacer_params = LinearLayout.LayoutParams(0, 1, 1.0)
            header_row.addView(spacer, spacer_params)

            max_tv = TextView(self.context)
            max_tv.setText("‚ú® MAX")
            max_tv.setTextSize(1, 14)
            max_tv.setTextColor(UI.primary())
            max_tv.setTypeface(None, Typeface.BOLD)
            header_row.addView(max_tv)

        card.addView(header_row)

        if xp_to_next > 0:
            current_stage_xp = PET_STAGES[pet.stage]["xp"] if pet.stage < len(PET_STAGES) else 0
            next_stage_xp = PET_STAGES[pet.stage + 1]["xp"] if pet.stage + 1 < len(PET_STAGES) else pet.xp
            xp_in_stage = pet.xp - current_stage_xp
            total_xp_needed = next_stage_xp - current_stage_xp
            progress = xp_in_stage / total_xp_needed if total_xp_needed > 0 else 1.0
            progress = max(0.0, min(1.0, progress))

            xp_row = LinearLayout(self.context)
            xp_row.setOrientation(LinearLayout.HORIZONTAL)
            xp_row.setGravity(Gravity.CENTER_VERTICAL)
            xp_row_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            xp_row_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

            current_xp_tv = TextView(self.context)
            current_xp_tv.setText(f"{xp_in_stage}")
            current_xp_tv.setTextSize(1, 16)
            current_xp_tv.setTextColor(UI.primary())
            current_xp_tv.setTypeface(None, Typeface.BOLD)
            xp_row.addView(current_xp_tv)

            slash_tv = TextView(self.context)
            slash_tv.setText(f" / {total_xp_needed} XP")
            slash_tv.setTextSize(1, 14)
            slash_tv.setTextColor(UI.on_surface_variant())
            xp_row.addView(slash_tv)

            spacer2 = View(self.context)
            spacer2_params = LinearLayout.LayoutParams(0, 1, 1.0)
            xp_row.addView(spacer2, spacer2_params)

            percent_tv = TextView(self.context)
            percent_tv.setText(f"{int(progress * 100)}%")
            percent_tv.setTextSize(1, 14)
            percent_tv.setTextColor(UI.on_surface())
            percent_tv.setTypeface(None, Typeface.BOLD)
            xp_row.addView(percent_tv)

            card.addView(xp_row, xp_row_params)

            bar_container = FrameLayout(self.context)
            bar_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(Dp.S8)
            )

            bar_bg = View(self.context)
            bar_bg_drawable = GradientDrawable()
            bar_bg_drawable.setCornerRadius(AndroidUtilities.dp(Dp.HANDLE_H))
            bar_bg_drawable.setColor(UI.outline())
            bar_bg.setBackground(bar_bg_drawable)
            bar_bg.setLayoutParams(FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(Dp.S8)
            ))
            bar_container.addView(bar_bg)

            bar_fill = View(self.context)
            bar_fill_drawable = GradientDrawable()
            bar_fill_drawable.setCornerRadius(AndroidUtilities.dp(Dp.HANDLE_H))
            bar_fill_drawable.setColor(UI.primary())
            bar_fill.setBackground(bar_fill_drawable)
            fill_width = max(AndroidUtilities.dp(Dp.S8), int(FrameLayout.LayoutParams.MATCH_PARENT * progress))
            bar_fill.setLayoutParams(FrameLayout.LayoutParams(
                fill_width,
                AndroidUtilities.dp(Dp.S8)
            ))
            bar_container.addView(bar_fill)

            card.addView(bar_container, bar_params)

            remaining_tv = TextView(self.context)
            remaining_tv.setText(
                tr(f"–û—Å—Ç–∞–ª–æ—Å—å {xp_to_next} XP", f"Remaining {xp_to_next} XP")
            )
            remaining_tv.setTextSize(1, 11)
            remaining_tv.setTextColor(UI.on_surface())
            remaining_tv.setGravity(Gravity.CENTER)
            remaining_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            remaining_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
            card.addView(remaining_tv, remaining_params)

        return card

    def _create_evolution_item(self, emoji, level, is_current, is_achieved):
        item = LinearLayout(self.context)
        item.setOrientation(LinearLayout.VERTICAL)
        item.setGravity(Gravity.CENTER)
        item.setPadding(
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
        )

        if is_current:
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
            bg.setColor(UI.primary_container())
            item.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        if not is_achieved:
            emoji_tv.setAlpha(0.3)
        item.addView(emoji_tv)

        level_tv = TextView(self.context)
        level_tv.setText(level)
        level_tv.setTextSize(1, 10)
        level_tv.setTextColor(get_on_surface_variant() if is_achieved else Color.argb(80, 128, 128, 128))
        level_tv.setGravity(Gravity.CENTER)
        item.addView(level_tv)

        return item

    def _create_stages_preview(self):
        row = LinearLayout(self.context)
        row.setOrientation(LinearLayout.HORIZONTAL)
        row.setGravity(Gravity.CENTER)

        emoji_style = self.plugin.get_setting("pet_emoji_style", 0) if self.plugin else 0
        stages = PET_STAGES_BY_STYLE.get(emoji_style, PET_STAGES_BY_STYLE[0])

        for stage_num, stage_data in list(stages.items())[:5]:
            item = self._create_evolution_item(stage_data["emoji"], str(stage_num), False, False)
            params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            row.addView(item, params)

        return row

    def _create_buttons(self, is_active, pet=None):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        if is_active:
            row1 = LinearLayout(self.context)
            row1.setOrientation(LinearLayout.HORIZONTAL)

            btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
            btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

            feed_btn = UI.button(self.context, S.FEED, lambda *args: self._on_feed_click(), "filled")
            row1.addView(feed_btn, btn_params)

            play_btn = UI.button(self.context, S.PLAY, lambda *args: self._on_play_click(), "tonal")
            row1.addView(play_btn, btn_params)

            container.addView(row1)

            row2 = LinearLayout(self.context)
            row2.setOrientation(LinearLayout.HORIZONTAL)
            row2_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            row2_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

            rename_btn = UI.button(self.context, S.RENAME, lambda *args: self._on_rename_click(), "outlined")
            row2.addView(rename_btn, btn_params)

            kick_btn = UI.button(self.context, S.KICK, lambda *args: self._onkickPet_click(), "outlined")
            row2.addView(kick_btn, btn_params)

            container.addView(row2, row2_params)

            if pet and pet.deleted:
                row3 = LinearLayout(self.context)
                row3.setOrientation(LinearLayout.VERTICAL)
                row3_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                row3_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)

                revive_btn = UI.button(
                    self.context,
                    tr(
                        f"‚ú® –í–æ—Å–∫—Ä–µ—Å–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞ (-{REVIVE_XP_COST} XP)",
                        f"‚ú® Revive pet (-{REVIVE_XP_COST} XP)",
                    ),
                    lambda *args: self._on_revive_click(),
                    "filled",
                )
                row3.addView(revive_btn)
                container.addView(row3, row3_params)
        else:
            close_btn = UI.button(self.context, S.CLOSE, lambda *args: self.dismiss(), "tonal")
            container.addView(close_btn)

        return container

    def _on_feed_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.feed_pet({"chat_id": chat_id})

    def _reopen_menu(self, plugin_ref, chat_id_ref, error_label):
        def show_updated_menu():
            try:
                fragment = get_last_fragment()
                if not fragment:
                    return
                activity = fragment.getParentActivity()
                if not activity:
                    return
                new_sheet = PetStatsBottomSheet(activity, plugin_ref, chat_id_ref)
                new_sheet.show()
            except Exception as e:
                if plugin_ref:
                    suffix = f" ({error_label})" if error_label else ""
                    plugin_ref.log(f"WSP: error reopening pet menu{suffix}: {e}")
        run_on_ui_thread(show_updated_menu)

    def _on_play_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.showPetMinigame(chat_id)

    def _on_revive_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.revivePet(chat_id)
            self._reopen_menu(plugin, chat_id, "after revive")

    def _onstartPet(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startPet(chat_id)

    def _on_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.forceSyncNow(chat_id)

    def _on_stop_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.stopPet(chat_id)

    def _on_toggle_widget(self):
        plugin_ref = self.plugin
        chat_id_ref = self.chat_id

        current_state = plugin_ref.get_setting("show_widget", True)
        new_state = not current_state
        plugin_ref.set_setting("show_widget", new_state)

        if new_state:
            bulletin_safe("success", tr("–í–∏–¥–∂–µ—Ç –ø–∏—Ç–æ–º—Ü–∞ –≤–∫–ª—é—á–µ–Ω", "Pet widget on"))
        else:
            bulletin_safe("success", tr("–í–∏–¥–∂–µ—Ç –ø–∏—Ç–æ–º—Ü–∞ –≤—ã–∫–ª—é—á–µ–Ω", "Pet widget off"))
            with plugin_ref.data_lock:
                if chat_id_ref in plugin_ref.active_widgets:
                    try:
                        widget = plugin_ref.active_widgets[chat_id_ref]
                        if hasattr(widget, "cleanup"):
                            widget.cleanup()
                    except Exception as e:
                        self.log(f"WSP: error hiding widget: {e}")

        self.dismiss()

        self._reopen_menu(plugin_ref, chat_id_ref, None)

    def _on_rename_click(self):
        try:
            from android.text import InputType
            from android.widget import EditText
            from org.telegram.ui.ActionBar import AlertDialog

            pet = self.plugin.pets.get(self.chat_id)
            if not pet:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet not found"))
                return

            edit_text = EditText(self.context)
            edit_text.setText(pet.name)
            edit_text.setHint(tr("–ù–æ–≤–æ–µ –∏–º—è", "New name"))
            edit_text.setInputType(
                InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_CAP_WORDS
            )
            edit_text.setSingleLine(True)
            edit_text.setPadding(
                AndroidUtilities.dp(Dp.S20),
                AndroidUtilities.dp(Dp.S12),
                AndroidUtilities.dp(Dp.S20),
                AndroidUtilities.dp(Dp.S12),
            )

            edit_bg = GradientDrawable()
            edit_bg.setCornerRadius(AndroidUtilities.dp(Dp.CORNER_SM))
            edit_bg.setColor(UI.surface_variant())
            edit_bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
            edit_text.setBackground(edit_bg)

            builder = AlertDialog.Builder(self.context)
            builder.setTitle(tr("–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å –ø–∏—Ç–æ–º—Ü–∞", "Rename pet"))
            builder.setView(edit_text)
            refs = {"dialog": None, "edit": edit_text}

            def cleanup_dialog():
                refs["dialog"] = None
                refs["edit"] = None

            def on_positive(dialog, which):
                et = refs.get("edit")
                new_name = str(et.getText()).strip() if et else ""
                if new_name and len(new_name) <= 100:
                    plugin_ref = self.plugin
                    chat_id_ref = self.chat_id

                    plugin_ref.renamePet(chat_id_ref, new_name)
                    self.dismiss()
                    self._reopen_menu(plugin_ref, chat_id_ref, None)
                    cleanup_dialog()
                elif len(new_name) > 100:
                    bulletin_safe("error",
                        tr(
                            "–ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (–º–∞–∫—Å. 100 —Å–∏–º–≤–æ–ª–æ–≤)",
                            "Name is too long (max 100 characters)",
                        )
                    )
                else:
                    bulletin_safe("error", tr("–ò–º—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º", "Name can't be empty"))

            from java import dynamic_proxy

            ButtonClickListener = dynamic_proxy(AlertDialog.OnButtonClickListener)

            class PositiveListener(ButtonClickListener):
                def onClick(self, dialog, which):
                    on_positive(dialog, which)

            builder.setPositiveButton(tr("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", "Save"), PositiveListener())
            builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

            dialog = safeShowDialog(builder, cleanup_dialog)
            refs["dialog"] = dialog

        except Exception as e:
            self.log(f"WSP: error showing rename dialog: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def _onkickPet_click(self):
        try:
            from org.telegram.ui.ActionBar import AlertDialog

            builder = AlertDialog.Builder(self.context)
            builder.setTitle(tr("–£–¥–∞–ª–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞?", "Delete the pet?"))
            builder.setMessage(
                tr(
                    "–£–¥–∞–ª–∏—Ç—å –ø–∏—Ç–æ–º—Ü–∞? –î–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ, –ø—Ä–æ–≥—Ä–µ—Å—Å –±—É–¥–µ—Ç –ø–æ—Ç–µ—Ä—è–Ω.",
                    "Delete the pet? This can't be undone and all progress will be lost.",
                )
            )
            refs = {"dialog": None}

            def cleanup_dialog():
                refs["dialog"] = None

            def on_confirm(dialog, which):
                plugin_ref = self.plugin
                chat_id_ref = self.chat_id
                self.dismiss()
                if plugin_ref:
                    plugin_ref.kickPet(chat_id_ref)
                cleanup_dialog()

            from java import dynamic_proxy

            ButtonClickListener = dynamic_proxy(AlertDialog.OnButtonClickListener)

            class ConfirmListener(ButtonClickListener):
                def onClick(self, dialog, which):
                    on_confirm(dialog, which)

            builder.setPositiveButton(tr("–£–¥–∞–ª–∏—Ç—å", "Delete"), ConfirmListener())
            builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

            dialog = safeShowDialog(builder, cleanup_dialog)
            refs["dialog"] = dialog

        except Exception as e:
            self.log(f"WSP: error showing kick pet dialog: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def show(self):
        try:
            self.bottom_sheet.show()
        except Exception as e:
            self.log(f"WSP: error showing pet stats: {e}")

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing pet stats: {e}")
        finally:
            self.onDismiss()


class StreakMenuBottomSheet(SafeSheet):
    def __init__(self, context, plugin, chat_id):
        super().__init__(context, plugin, chat_id)
        self.bottom_sheet = BottomSheet(context, False)

        streak = plugin.getOrCreateStreak(chat_id)
        is_active = chat_id in plugin.streak_enabled_chats
        pet_active = chat_id in plugin.pet_enabled_chats
        pet = plugin.pets.get(chat_id)
        if not pet and pet_active:
            pet = plugin.getOrCreatePet(chat_id)

        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackground(UI.bg_sheet())

        handle_container = LinearLayout(context)
        handle_container.setOrientation(LinearLayout.VERTICAL)
        handle_container.setGravity(Gravity.CENTER)
        handle_container.setPadding(0, AndroidUtilities.dp(Dp.S12), 0, AndroidUtilities.dp(Dp.S8))

        handle = View(context)
        handle.setBackgroundColor(UI.outline())
        handle_params = LinearLayout.LayoutParams(AndroidUtilities.dp(Dp.S32), AndroidUtilities.dp(Dp.HANDLE_H))
        handle_bg = GradientDrawable()
        handle_bg.setCornerRadius(AndroidUtilities.dp(Dp.S2))
        handle_bg.setColor(UI.outline())
        handle.setBackground(handle_bg)
        handle_container.addView(handle, handle_params)
        container.addView(handle_container)

        tabs_row = self._create_tabs_row()
        container.addView(tabs_row)

        scroll_view = ScrollView(context)
        scroll_view.setFillViewport(True)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        self._tab_content = content
        self._tab_streak = streak
        self._tab_pet = pet
        self._tab_state = (is_active, pet_active)
        self._tab = "streak" if is_active or not pet_active else "pet"

        scroll_view.addView(content)

        scroll_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT, 0, 1.0
        )
        container.addView(scroll_view, scroll_params)

        button_container = self._create_buttons(is_active, streak)
        button_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        container.addView(button_container, button_params)
        self._button_container = button_container

        self.bottom_sheet.setCustomView(container)
        self.attachDismissListener()
        self._render_tab()

    @property
    def plugin(self):
        return self._plugin_ref() if self._plugin_ref else None

    def log(self, msg):
        p = self.plugin
        if p:
            p.log(msg)
        else:
            log(msg)

    def formatSyncStatus(self, chat_id):
        plugin = self.plugin
        if not plugin:
            return ""
        try:
            return plugin.formatSyncStatus(chat_id)
        except Exception as e:
            self.log(f"WSP: format_last_sync_status error: {e}")
            return ""

    def _build_active_streak_ui(self, container, streak):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        flame = streak.get_flame_emoji()
        emoji_text = TextView(self.context)
        emoji_text.setText(flame)
        emoji_text.setTextSize(1, 64)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        count_text = TextView(self.context)
        count_text.setText(f"{streak.count}")
        count_text.setTextSize(1, 48)
        count_text.setTextColor(UI.on_surface())
        count_text.setTypeface(None, Typeface.BOLD)
        count_text.setGravity(Gravity.CENTER)
        count_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        count_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(count_text, count_params)

        days_label = TextView(self.context)
        days_label.setText(formatDaysInRow(streak.count))
        days_label.setTextSize(1, 14)
        days_label.setTextColor(UI.on_surface())
        days_label.setGravity(Gravity.CENTER)
        header.addView(days_label)

        sync_status = self.formatSyncStatus(getattr(streak, "chat_id", None))
        if sync_status:
            sync_tv = TextView(self.context)
            sync_tv.setText(sync_status)
            sync_tv.setTextSize(1, 12)
            sync_tv.setTextColor(UI.on_surface_variant())
            sync_tv.setGravity(Gravity.CENTER)
            sync_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            sync_params.setMargins(0, AndroidUtilities.dp(Dp.S6), 0, 0)
            header.addView(sync_tv, sync_params)

        if streak.is_warning:
            warning_badge = self._create_status_chip(
                tr(
                    f"‚ö†Ô∏è –ù—É–∂–Ω—ã —Å–æ–æ–±—â–µ–Ω–∏—è ({int(streak.warning_time_left)}—á –æ—Å—Ç–∞–ª–æ—Å—å)",
                    f"‚ö†Ô∏è Send a message ({int(streak.warning_time_left)}h left)",
                ),
                Color.argb(255, 255, 152, 0),
                Color.argb(30, 255, 152, 0)
            )
            warning_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            warning_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
            header.addView(warning_badge, warning_params)
        else:
            status_badge = self._create_status_chip(
                tr("‚úì –ê–∫—Ç–∏–≤–µ–Ω", "‚úì Active"), UI.on_primary_container(), UI.primary_container()
            )
            status_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            status_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
            header.addView(status_badge, status_params)

        container.addView(header)

        stages_section = self._create_stages_section(streak)
        container.addView(stages_section)

        stats_section = self._create_stats_section(streak)
        container.addView(stats_section)

    def _create_status_chip(self, text, text_color, bg_color):
        chip = TextView(self.context)
        chip.setText(text)
        chip.setTextSize(1, 12)
        chip.setTextColor(text_color)
        chip.setTypeface(None, Typeface.BOLD)
        chip.setGravity(Gravity.CENTER)
        chip.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S6),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S6),
        )
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(bg_color)
        chip.setBackground(bg)
        return chip

    def _create_stages_section(self, streak):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–≠–≤–æ–ª—é—Ü–∏—è –æ–≥–Ω—è", "Flame evolution"))
        title.setTextSize(1, 14)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S12))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        current_stage = streak.get_current_stage_index()

        for i, stage in enumerate(FLAME_STAGES):
            stage_name = stage["name"]
            if isEn():
                stage_name = FLAME_STAGE_NAME_EN.get(stage_name, stage_name)
            stage_item = self._create_stage_item(
                stage["emoji"],
                stage_name,
                stage["days"],
                is_current=(i == current_stage),
                is_achieved=(streak.count >= stage["min"]),
            )
            stage_params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            stage_params.setMargins(AndroidUtilities.dp(Dp.S2), 0, AndroidUtilities.dp(Dp.S2), 0)
            stages_row.addView(stage_item, stage_params)

        section.addView(stages_row)
        return section

    def _create_stage_item(self, emoji, name, days, is_current, is_achieved):
        item = LinearLayout(self.context)
        item.setOrientation(LinearLayout.VERTICAL)
        item.setGravity(Gravity.CENTER)
        item.setPadding(
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S4),
            AndroidUtilities.dp(Dp.S8),
        )

        if is_current:
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(Dp.S12))
            bg.setColor(UI.primary_container())
            item.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 24)
        emoji_tv.setGravity(Gravity.CENTER)
        if not is_achieved:
            emoji_tv.setAlpha(0.4)
        item.addView(emoji_tv)

        days_tv = TextView(self.context)
        days_tv.setText(days)
        days_tv.setTextSize(1, 10)
        days_tv.setTextColor(get_on_surface_variant() if is_achieved else Color.argb(100, 128, 128, 128))
        days_tv.setGravity(Gravity.CENTER)
        days_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        days_params.setMargins(0, AndroidUtilities.dp(Dp.S2), 0, 0)
        item.addView(days_tv, days_params)

        return item

    def _create_stats_section(self, streak):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
        )

        stats_row = LinearLayout(self.context)
        stats_row.setOrientation(LinearLayout.HORIZONTAL)

        last_msg = self._create_stat_card(
            "üìÖ",
            tr("–ü–æ—Å–ª–µ–¥–Ω–µ–µ", "Last"),
            str(streak.last_date) if streak.last_date else "‚Äî"
        )
        start_date = self._create_stat_card(
            "üéØ",
            tr("–ù–∞—á–∞–ª–æ", "Start"),
            str(streak.first_date) if streak.first_date else "‚Äî"
        )

        card_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        card_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        stats_row.addView(last_msg, card_params)
        stats_row.addView(start_date, card_params)
        section.addView(stats_row)

        return section

    def _create_stat_card(self, emoji, label, value):
        card = LinearLayout(self.context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setGravity(Gravity.CENTER)
        card.setPadding(
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
        bg.setColor(UI.surface_variant())
        card.setBackground(bg)

        emoji_tv = TextView(self.context)
        emoji_tv.setText(emoji)
        emoji_tv.setTextSize(1, 20)
        emoji_tv.setGravity(Gravity.CENTER)
        card.addView(emoji_tv)

        label_tv = TextView(self.context)
        label_tv.setText(label)
        label_tv.setTextSize(1, 11)
        label_tv.setTextColor(UI.on_surface())
        label_tv.setGravity(Gravity.CENTER)
        label_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        label_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
        card.addView(label_tv, label_params)

        value_tv = TextView(self.context)
        value_tv.setText(value)
        value_tv.setTextSize(1, 12)
        value_tv.setTextColor(UI.on_surface())
        value_tv.setTypeface(None, Typeface.BOLD)
        value_tv.setGravity(Gravity.CENTER)
        value_tv.setSingleLine(True)
        value_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        value_params.setMargins(0, AndroidUtilities.dp(Dp.S2), 0, 0)
        card.addView(value_tv, value_params)

        return card

    def _build_inactive_streak_ui(self, container):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S16),
        )

        emoji_text = TextView(self.context)
        emoji_text.setText("üî•")
        emoji_text.setTextSize(1, 56)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        title = TextView(self.context)
        title.setText(tr("–°—Ç—Ä–∏–∫", "Streak"))
        title.setTextSize(1, 24)
        title.setTextColor(UI.on_surface())
        title.setTypeface(None, Typeface.BOLD)
        title.setGravity(Gravity.CENTER)
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(0, AndroidUtilities.dp(Dp.S12), 0, 0)
        header.addView(title, title_params)

        desc = TextView(self.context)
        desc.setText(
            tr(
                "–ü–∏—à–∏—Ç–µ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å,\n—á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å–µ—Ä–∏—é",
                "Write every day\nto keep the streak",
            )
        )
        desc.setTextSize(1, 14)
        desc.setTextColor(UI.on_surface())
        desc.setGravity(Gravity.CENTER)
        desc_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(desc, desc_params)

        container.addView(header)

        stages_section = self._create_stages_preview()
        container.addView(stages_section)

    def _create_stages_preview(self):
        section = LinearLayout(self.context)
        section.setOrientation(LinearLayout.VERTICAL)
        section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        title = TextView(self.context)
        title.setText(tr("–ù–∞–≥—Ä–∞–¥—ã –ø–æ –¥–Ω—è–º:", "Rewards by day:"))
        title.setTextSize(1, 13)
        title.setTextColor(UI.on_surface())
        title_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        title_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, 0, AndroidUtilities.dp(Dp.S8))
        section.addView(title, title_params)

        stages_row = LinearLayout(self.context)
        stages_row.setOrientation(LinearLayout.HORIZONTAL)
        stages_row.setGravity(Gravity.CENTER)

        for stage in FLAME_STAGES:
            stage_name = stage["name"]
            if isEn():
                stage_name = FLAME_STAGE_NAME_EN.get(stage_name, stage_name)
            item = self._create_stage_item(stage["emoji"], stage_name, stage["days"], False, False)
            params = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
            )
            params.setMargins(AndroidUtilities.dp(Dp.S2), 0, AndroidUtilities.dp(Dp.S2), 0)
            stages_row.addView(item, params)

        section.addView(stages_row)
        return section

    def _build_dead_streak_ui(self, container, streak):
        header = LinearLayout(self.context)
        header.setOrientation(LinearLayout.VERTICAL)
        header.setGravity(Gravity.CENTER)
        header.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S24),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(0)
        bg.setColor(UI.error_container())
        header.setBackground(bg)

        emoji_text = TextView(self.context)
        emoji_text.setText("üíÄ")
        emoji_text.setTextSize(1, 56)
        emoji_text.setGravity(Gravity.CENTER)
        header.addView(emoji_text)

        dead_count = TextView(self.context)
        dead_count.setText(
            tr(
                formatDaysRu(streak.dead_count),
                formatDaysEn(streak.dead_count),
            )
        )
        dead_count.setTextSize(1, 32)
        dead_count.setTextColor(get_on_error_container())
        dead_count.setTypeface(None, Typeface.BOLD)
        dead_count.setGravity(Gravity.CENTER)
        count_params = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.WRAP_CONTENT,
            LinearLayout.LayoutParams.WRAP_CONTENT,
        )
        count_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
        header.addView(dead_count, count_params)

        subtitle = TextView(self.context)
        subtitle.setText(tr("–°—Ç—Ä–∏–∫ –ø–æ—Ç–µ—Ä—è–Ω", "Streak lost"))
        subtitle.setTextSize(1, 14)
        subtitle.setTextColor(get_on_error_container())
        subtitle.setAlpha(0.7)
        subtitle.setGravity(Gravity.CENTER)
        header.addView(subtitle)

        container.addView(header)

        info_section = LinearLayout(self.context)
        info_section.setOrientation(LinearLayout.VERTICAL)
        info_section.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        if streak.can_restore:
            time_left = streak.restore_time_left
            hours_left = int(time_left)
            mins_left = int((time_left - hours_left) * 60)
            restores_left = STREAK_MAX_RESTORES_PER_MONTH - streak.restores_this_month

            restore_card = LinearLayout(self.context)
            restore_card.setOrientation(LinearLayout.VERTICAL)
            restore_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
            )
            card_bg = GradientDrawable()
            card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            card_bg.setColor(UI.primary_container())
            restore_card.setBackground(card_bg)

            restore_title = TextView(self.context)
            restore_title.setText(tr("üîÑ –ú–æ–∂–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "üîÑ Can be restored"))
            restore_title.setTextSize(1, 16)
            restore_title.setTextColor(get_on_primary_container())
            restore_title.setTypeface(None, Typeface.BOLD)
            restore_card.addView(restore_title)

            time_info = TextView(self.context)
            time_info.setText(
                tr(
                    f"‚è∞ –û—Å—Ç–∞–ª–æ—Å—å {hours_left}—á {mins_left}–º",
                    f"‚è∞ {hours_left}h {mins_left}m left",
                )
            )
            time_info.setTextSize(1, 13)
            time_info.setTextColor(get_on_primary_container())
            time_info.setAlpha(0.8)
            time_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            time_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
            restore_card.addView(time_info, time_params)

            restores_info = TextView(self.context)
            restores_info.setText(
                tr(
                    f"–í —ç—Ç–æ–º –º–µ—Å—è—Ü–µ: {restores_left}/{STREAK_MAX_RESTORES_PER_MONTH}",
                    f"This month: {restores_left}/{STREAK_MAX_RESTORES_PER_MONTH}",
                )
            )
            restores_info.setTextSize(1, 12)
            restores_info.setTextColor(get_on_primary_container())
            restores_info.setAlpha(0.7)
            restores_params = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT,
            )
            restores_params.setMargins(0, AndroidUtilities.dp(Dp.S4), 0, 0)
            restore_card.addView(restores_info, restores_params)

            info_section.addView(restore_card)
        else:
            no_restore_card = LinearLayout(self.context)
            no_restore_card.setOrientation(LinearLayout.VERTICAL)
            no_restore_card.setPadding(
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
                AndroidUtilities.dp(Dp.S16),
            )
            card_bg = GradientDrawable()
            card_bg.setCornerRadius(AndroidUtilities.dp(Dp.S16))
            card_bg.setColor(UI.surface_variant())
            no_restore_card.setBackground(card_bg)

            if streak.restore_time_left <= 0:
                reason = tr("‚è∞ –í—Ä–µ–º—è –Ω–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ", "‚è∞ Restore window expired")
            else:
                reason = tr("üîÑ –õ–∏–º–∏—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π –∏—Å—á–µ—Ä–ø–∞–Ω", "üîÑ Restore limit reached")

            no_restore_text = TextView(self.context)
            no_restore_text.setText(reason)
            no_restore_text.setTextSize(1, 14)
            no_restore_text.setTextColor(UI.on_surface())
            no_restore_text.setGravity(Gravity.CENTER)
            no_restore_card.addView(no_restore_text)

            info_section.addView(no_restore_card)

        container.addView(info_section)

    def _create_buttons(self, is_active, streak=None):
        container = LinearLayout(self.context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setPadding(
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S8),
            AndroidUtilities.dp(Dp.S16),
            AndroidUtilities.dp(Dp.S16),
        )

        button_row = LinearLayout(self.context)
        button_row.setOrientation(LinearLayout.HORIZONTAL)

        button_params = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0
        )
        button_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

        if is_active and streak and streak.is_dead:
            close_btn = self._create_button(S.CLOSE, "tonal")
            close_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))
            button_row.addView(close_btn, button_params)

            if streak.can_restore:
                restore_btn = self._create_button(tr("–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Restore"), "filled")
                restore_btn.setOnClickListener(
                    OnClickListener(lambda *args: self._on_restore_click())
                )
                button_row.addView(restore_btn, button_params)
            else:
                start_btn = self._create_button(tr("–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ", "Start over"), "filled")
                start_btn.setOnClickListener(
                    OnClickListener(lambda *args: self._on_restart_click())
                )
                button_row.addView(start_btn, button_params)
        elif is_active:
            stop_btn = self._create_button(tr("–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å", "Stop"), "outlined")
            stop_btn.setOnClickListener(
                OnClickListener(lambda *args: self._on_stop_click())
            )
            button_row.addView(stop_btn, button_params)

            close_btn = self._create_button(S.CLOSE, "filled")
            close_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))
            button_row.addView(close_btn, button_params)
        else:
            cancel_btn = self._create_button(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), "tonal")
            cancel_btn.setOnClickListener(OnClickListener(lambda *args: self.dismiss()))
            button_row.addView(cancel_btn, button_params)

            start_btn = self._create_button(tr("–ù–∞—á–∞—Ç—å", "Start"), "filled")
            start_btn.setOnClickListener(
                OnClickListener(lambda *args: self._on_start_click())
            )
            button_row.addView(start_btn, button_params)

        container.addView(button_row)

        plugin = self.plugin
        if plugin:
            try:
                sync_manager = plugin.getSyncMgr()
                if sync_manager.mode != StreakSyncManager.MODE_P2P:
                    force_row = LinearLayout(self.context)
                    force_row.setOrientation(LinearLayout.HORIZONTAL)

                    force_btn = self._create_button(
                        tr("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "Force sync (override)"),
                        "outlined",
                    )
                    force_btn.setOnClickListener(
                        OnClickListener(lambda *args: self._on_force_sync_click())
                    )
                    force_btn_params = LinearLayout.LayoutParams(
                        LinearLayout.LayoutParams.MATCH_PARENT,
                        LinearLayout.LayoutParams.WRAP_CONTENT,
                    )
                    force_btn_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, 0)
                    force_row.addView(force_btn, force_btn_params)
                    container.addView(force_row)

            except Exception:
                pass
        return container

    def _create_button(self, text, style="filled"):
        button = TextView(self.context)
        button.setText(text)
        button.setTextSize(1, 14)
        button.setTypeface(None, Typeface.BOLD)
        button.setGravity(Gravity.CENTER)
        button.setSingleLine(True)
        button.setPadding(
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S12),
            AndroidUtilities.dp(Dp.S24),
            AndroidUtilities.dp(Dp.S12),
        )

        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(Dp.S20))

        if style == "filled":
            bg.setColor(UI.primary())
            button.setTextColor(UI.on_primary())
        elif style == "tonal":
            bg.setColor(UI.secondary_container())
            button.setTextColor(UI.secondary())
        elif style == "outlined":
            bg.setColor(Color.TRANSPARENT)
            bg.setStroke(AndroidUtilities.dp(Dp.S1), UI.outline())
            button.setTextColor(UI.primary())

        button.setBackground(bg)
        return button

    def _on_start_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startStreak(chat_id)

    def _on_stop_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.stopStreak(chat_id)

    def _on_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.forceSyncNow(chat_id)

    def _on_force_sync_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if not plugin:
            return

        activity = plugin.getActivity()
        if not activity:
            plugin.forceSyncNow(chat_id)
            return

        title = tr("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "Force sync")
        message = tr(
            "–ú–æ–∂–µ—Ç –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–µ—Ä–≤–µ—Ä–Ω—ã–º–∏.\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?",
            "May override local data with server data.\nContinue?",
        )

        def on_confirm(b, w):
            try:
                b.dismiss()
            except Exception:
                pass
            plugin.forceSyncNow(chat_id)

        plugin.showAlert(
            activity,
            title,
            message,
            tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å", "Sync"),
            on_confirm,
            tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
            lambda b, w: b.dismiss(),
        )

    def _on_restore_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.restoreStreak(chat_id)

    def _on_restart_click(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.restartDeadStreak(chat_id)

    def _on_pet_start(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.startPet(chat_id)

    def _on_pet_feed(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.feed_pet({"chat_id": chat_id})

    def _on_pet_play(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.showPetMinigame(chat_id)

    def _on_pet_open(self):
        plugin = self.plugin
        chat_id = self.chat_id
        self.dismiss()
        if plugin:
            plugin.show_pet_stats({"chat_id": chat_id})

    def show(self):
        self.bottom_sheet.show()

    def dismiss(self):
        try:
            self.bottom_sheet.dismiss()
        except Exception as e:
            self.log(f"WSP: error dismissing streak menu: {e}")
        finally:
            self.onDismiss()


# —Å–∞–º –ø–ª–∞–≥–∏–Ω
class WatamoteStreakPetPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.data_lock = threading.RLock()
        self.shutdown_event = threading.Event()
        self._executor = ThreadPoolExecutor(max_workers=4, thread_name_prefix="WSP")
        self.pets = {}
        self.streaks = {}
        self.streak_enabled_chats = set()
        self.pet_enabled_chats = set()
        self.last_messages = {}
        self.header_hook = None
        self.cleanup_hook = None
        self.active_widgets = {}
        self.active_streak_badges = {}
        self.widget_manager = None
        self.sync_manager = None
        self.last_auto_sync = {}
        self.last_server_check = {}
        self.last_global_server_check = 0
        self.background_sync_thread = None
        self.sync_backoff_seconds = 1
        self.sync_backoff_max = SYNC_BACKOFF_MAX_SECONDS
        self.sync_consecutive_errors = 0
        self.last_xp_time = {}
        self.xp_history = {}
        self.recent_messages = {}
        self.widget_positions = {}
        self.last_p2p_sync = {}
        self.P2P_MIN_INTERVAL = P2P_THROTTLE_SECONDS
        self._save_pending = False
        self.last_pet_sync = {}
        self.PET_SYNC_MIN_INTERVAL = 5
        self._pending_pet_syncs = {}
        self.last_streak_sync = {}
        self.STREAK_SYNC_MIN_INTERVAL = 5
        self._pending_streak_syncs = {}
        self.pet_revive_times = {}
        self.minigame_combo = {}
        self._last_synced_streak_hash = {}
        self._last_synced_pet_hash = {}
        self._p2p_offer_last = {}
        self.last_sync_status = {}
        self.lastSyncOk = {}
        self.actionGuard = {}
        self.lastSentStreak = {}
        self.lastSentPet = {}
        self.chatAccts = {}
        self.lastAcct = 0
        self.p2pKeys = {}
        self.last_flame_time = {}

    def saveSoon(self):
        with self.data_lock:
            if self._save_pending:
                return
            self._save_pending = True
        def do_save():
            time.sleep(SAVE_DEBOUNCE_SECONDS)
            with self.data_lock:
                self._save_pending = False
            self.saveData()
        self.runAsync(do_save)

    def runAsync(self, func, *args, **kwargs):
        try:
            self._executor.submit(func, *args, **kwargs)
        except RuntimeError:
            threading.Thread(
                target=func,
                args=args,
                kwargs=kwargs,
                daemon=True,
            ).start()

    def guardAction(self, key, gap=0.8):
        try:
            now = time.time()
            with self.data_lock:
                last = self.actionGuard.get(key, 0)
            if now - last < gap:
                return True
            with self.data_lock:
                self.actionGuard[key] = now
            return False
        except Exception:
            return False

    def guardSyncStreak(self, chat_id, data):
        try:
            chat_id = self.normChat(chat_id)
            now = time.time()
            client_time = data.get("client_time")
            if client_time and abs(float(client_time) - now) > SYNC_GUARD_MAX_SKEW:
                return False
            key = chat_id
            with self.data_lock:
                last = self.lastSentStreak.get(key)
            if last:
                prev = last.get("data", {})
                prev_ts = float(prev.get("timestamp", 0) or 0)
                curr_ts = float(data.get("timestamp", 0) or 0)
                if curr_ts < prev_ts - 5:
                    return False
                prev_count = int(prev.get("count", 0) or 0)
                curr_count = int(data.get("count", 0) or 0)
                prev_last = prev.get("last_date")
                curr_last = data.get("last_date")
                if prev_count <= 0 or not prev_last or not curr_last:
                    with self.data_lock:
                        self.lastSentStreak[key] = {"data": data, "ts": now}
                    return True
                delta = curr_count - prev_count
                day_diff = 0
                try:
                    prev_date = datetime.fromisoformat(prev_last).date()
                    curr_date = datetime.fromisoformat(curr_last).date()
                    day_diff = (curr_date - prev_date).days
                except Exception:
                    day_diff = 0
                if day_diff < 0:
                    return False
                limit = max(SYNC_GUARD_MAX_STREAK_STEP, day_diff)
                if delta > limit:
                    if now - float(last.get("ts", 0) or 0) < SYNC_GUARD_STREAK_WINDOW:
                        return False
            with self.data_lock:
                self.lastSentStreak[key] = {"data": data, "ts": now}
            return True
        except Exception:
            return True

    def guardSyncPet(self, chat_id, data):
        try:
            chat_id = self.normChat(chat_id)
            now = time.time()
            client_time = data.get("client_time")
            if client_time and abs(float(client_time) - now) > SYNC_GUARD_MAX_SKEW:
                return False
            key = chat_id
            with self.data_lock:
                last = self.lastSentPet.get(key)
            if last:
                prev = last.get("data", {})
                prev_ts = float(prev.get("timestamp", 0) or 0)
                curr_ts = float(data.get("timestamp", 0) or 0)
                if curr_ts < prev_ts - 5:
                    return False
                xp_delta = float(data.get("xp", 0) or 0) - float(prev.get("xp", 0) or 0)
                if xp_delta > SYNC_GUARD_MAX_XP_STEP:
                    if now - float(last.get("ts", 0) or 0) < SYNC_GUARD_XP_WINDOW:
                        return False
                stage_delta = int(data.get("stage", 0) or 0) - int(prev.get("stage", 0) or 0)
                if stage_delta > SYNC_GUARD_MAX_STAGE_STEP:
                    return False
            with self.data_lock:
                self.lastSentPet[key] = {"data": data, "ts": now}
            return True
        except Exception:
            return True

    def hashSync(self, data):
        try:
            payload = json.dumps(data, sort_keys=True, separators=(",", ":"))
        except Exception:
            payload = repr(data)
        return hashlib.sha256(payload.encode("utf-8")).hexdigest()

    def setSyncedHash(self, chat_id, streak_data=None, pet_data=None):
        chat_key = self.normChat(chat_id)
        if streak_data is not None:
            self._last_synced_streak_hash[chat_key] = self.hashSync(streak_data)
        if pet_data is not None:
            self._last_synced_pet_hash[chat_key] = self.hashSync(pet_data)

    def markStreakDeleted(self, streak, update_sync_ts=False):
        if not streak:
            return
        streak.count = 0
        streak.last_date = None
        streak.first_date = None
        streak.deleted = True
        if update_sync_ts:
            streak.last_sync_timestamp = time.time()

    def markPetDeleted(self, pet, update_sync_ts=False):
        if not pet:
            return
        pet.deleted = True
        if update_sync_ts:
            pet.last_sync_timestamp = time.time()

    def mergeRemoteSync(
        self,
        kind,
        chat_id,
        local_obj,
        remote_data,
        source,
        update_hash=False,
        ignore_local_priority=False,
    ):
        result = {
            "action": "no_remote",
            "applied": False,
            "kind": kind,
            "source": source,
        }
        if not remote_data or not local_obj:
            return result

        local_data = local_obj.get_sync_data()
        if StreakSyncManager.should_accept_sync(
            local_data, remote_data, ignore_local_priority=ignore_local_priority
        ):
            local_obj.apply_sync_data(remote_data, source=source)
            result["action"] = "accept_remote"
            result["applied"] = True
            if update_hash:
                if kind == "streak":
                    self.setSyncedHash(
                        chat_id, streak_data=local_obj.get_sync_data()
                    )
                else:
                    self.setSyncedHash(chat_id, pet_data=local_obj.get_sync_data())
            try:
                self.recordSyncStatus(chat_id, f"remote:{source}", True)
            except Exception:
                pass
        else:
            result["action"] = "keep_local"
            try:
                self.recordSyncStatus(chat_id, f"remote:{source}", False)
            except Exception:
                pass
        try:
            local_ts = None
            remote_ts = None
            if isinstance(local_data, dict):
                local_ts = local_data.get("timestamp")
            if isinstance(remote_data, dict):
                remote_ts = remote_data.get("timestamp")
            self.logSyncDecision(
                kind,
                chat_id,
                source,
                result["action"],
                local_ts=local_ts,
                remote_ts=remote_ts,
            )
        except Exception:
            pass
        return result

    def logSyncDecision(
        self,
        kind,
        chat_id,
        source,
        action,
        local_ts=None,
        remote_ts=None,
        reason=None,
    ):
        try:
            parts = [
                f"WSP: sync {kind} chat={chat_id} source={source} action={action}"
            ]
            if reason:
                parts.append(f"reason={reason}")
            if local_ts is not None:
                parts.append(f"local_ts={int(local_ts)}")
            if remote_ts is not None:
                parts.append(f"remote_ts={int(remote_ts)}")
            self.log(" ".join(parts))
        except Exception:
            pass

    def shouldApplyRemoteDelete(
        self, local_obj, remote_data, source, ignore_local_priority=False
    ):
        if not local_obj:
            return True
        if getattr(local_obj, "deleted", False):
            return True
        local_data = local_obj.get_sync_data()
        return StreakSyncManager.should_accept_sync(
            local_data, remote_data, ignore_local_priority=ignore_local_priority
        )

    def offerP2pSwitch(self, chat_id):
        if not self.get_setting("p2p_switch_offer", True):
            return

        sync_manager = self.getSyncMgr()
        if sync_manager.mode == StreakSyncManager.MODE_P2P:
            return

        now = time.time()
        chat_key = self.normChat(chat_id)
        last_offer = self._p2p_offer_last.get(chat_key, 0)
        if now - last_offer < P2P_SWITCH_OFFER_COOLDOWN_SECONDS:
            return

        self._p2p_offer_last[chat_key] = now

        def show_prompt():
            activity = self.getActivity()
            if not activity:
                bulletin_safe(
                    "info",
                    tr(
                        "–ü–æ–ª—É—á–µ–Ω–∞ P2P‚Äë—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è. –ú–æ–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å P2P –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏.",
                        "P2P sync received. You can enable P2P for stable syncing.",
                    ),
                )
                return

            title = tr("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ P2P‚Äë—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è", "P2P sync detected")
            message = tr(
                "–ü–æ—Ö–æ–∂–µ, —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç P2P. –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ P2P –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏?",
                "Looks like your peer uses P2P. Switch to P2P for stable syncing?",
            )

            def on_switch(b, w):
                try:
                    b.dismiss()
                except Exception:
                    pass
                self.set_setting("streak_sync_mode", 0)
                self._sync_manager_cache_time = 0
                self.getSyncMgr()
                bulletin_safe(
                    "success",
                    tr("–†–µ–∂–∏–º —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: P2P", "Sync mode: P2P"),
                )

            self.showAlert(
                activity,
                title,
                message,
                tr("–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è", "Switch"),
                on_switch,
                tr("–ù–µ —Å–µ–π—á–∞—Å", "Not now"),
                lambda b, w: b.dismiss(),
            )

        run_on_ui_thread(show_prompt)

    def log(self, message):
        log(message)

    def bulletin(self, kind, message, ui_thread=False):
        bulletin_safe(kind, message, ui_thread)

    def showAlert(
        self,
        activity,
        title,
        message,
        positive_text="OK",
        on_positive=None,
        negative_text=None,
        on_negative=None,
    ):
        from ui.alert import AlertDialogBuilder

        builder = AlertDialogBuilder(activity)
        builder.set_title(title)
        builder.set_message(message)
        if positive_text:
            builder.set_positive_button(
                positive_text, on_positive or (lambda b, w: b.dismiss())
            )
        if negative_text:
            builder.set_negative_button(
                negative_text, on_negative or (lambda b, w: b.dismiss())
            )

        refs = {"dialog": None}

        def on_dismiss():
            refs["dialog"] = None

        dialog = safeShowDialog(builder, on_dismiss)
        refs["dialog"] = dialog

    def isPrivateChat(self, chat_id):
        try:
            chat_id = self.normChat(chat_id)
            chat_id_int = int(chat_id)
            return chat_id_int > 0
        except Exception:
            return False

    def isChatAllowed(self, chat_id, acct=None):
        try:
            chat_id = self.normChat(chat_id)
            chat_id_int = int(chat_id)
            if chat_id_int <= 0:
                self.log(f"WSP: chat {chat_id} rejected - group/channel (chat_id <= 0)")
                return False

            acct = self.getAcct(chat_id=chat_id, acct=acct)
            my_user_id = self.getMyId(acct=acct)

            if chat_id_int == my_user_id:
                self.log(
                    f"WSP: chat {chat_id} rejected - Saved Messages (chat with self)"
                )
                return False

            try:
                MessagesController = find_class(
                    "org.telegram.messenger.MessagesController"
                )
                if MessagesController:
                    controller = MessagesController.getInstance(int(acct))
                    user = controller.getUser(chat_id_int)
                    if user:
                        is_bot = getattr(user, "bot", False)
                        if is_bot:
                            self.log(f"WSP: chat {chat_id} rejected - bot user")
                            return False
            except Exception as e:
                self.log(f"WSP: error checking if user is bot: {e}")
            return True
        except Exception as e:
            self.log(f"WSP: isChatAllowed exception for {chat_id}: {e}")
            return False

    def needPetChat(self, chat_id):
        if not self.isChatAllowed(chat_id):
            bulletin_safe("error", tr("–ü–∏—Ç–æ–º—Ü—ã –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Pets aren't available in this chat"))
            return False
        return True

    def getEnabledPet(self, chat_id, dead_message):
        chat_id = self.normChat(chat_id)
        if chat_id not in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü –≤ —ç—Ç–æ–º —á–∞—Ç–µ –≤—ã–∫–ª—é—á–µ–Ω", "Pet is off in this chat"))
            return None
        pet = self.pets.get(chat_id)
        if not pet:
            bulletin_safe("info", tr("–°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ–¥–∏ –ø–∏—Ç–æ–º—Ü–∞", "Get a pet first"))
            return None
        if pet.deleted:
            bulletin_safe("error", dead_message)
            return None
        return pet

    def getActivity(self, log_prefix=""):
        fragment = get_last_fragment()
        if not fragment:
            if log_prefix:
                self.log(f"{log_prefix} context is None!")
            return None
        activity = fragment.getParentActivity()
        if not activity:
            if log_prefix:
                self.log(f"{log_prefix} activity is None!")
            return None
        return activity

    def extractChatId(self, data):
        if not data:
            return ""
        chat_id = data.get("chat_id") or data.get("dialog_id")
        return self.normChat(chat_id) if chat_id else ""

    def normChat(self, chat_id):
        if chat_id is None:
            return ""
        try:
            return str(chat_id)
        except Exception:
            return ""

    def setChatAccount(self, chat_id, acct):
        try:
            if chat_id is None or acct is None:
                return
            self.chatAccts[self.normChat(chat_id)] = int(acct)
            self.lastAcct = int(acct)
        except Exception:
            pass

    def getAcct(self, chat_id=None, acct=None):
        try:
            if acct is not None:
                return int(acct)
        except Exception:
            pass
        if chat_id is not None:
            try:
                mapped = self.chatAccts.get(self.normChat(chat_id))
                if mapped is not None:
                    return int(mapped)
            except Exception:
                pass
        try:
            return int(self.lastAcct or 0)
        except Exception:
            return 0

    def getMyId(self, acct=None):
        try:
            UserConfig = find_class("org.telegram.messenger.UserConfig")
            if UserConfig:
                acct = self.getAcct(acct=acct)
                user_config = UserConfig.getInstance(int(acct))
                return user_config.getClientUserId()
            else:
                self.log("WSP: UserConfig class not found")
        except Exception as e:
            self.log(f"WSP: failed to get my_user_id: {e}")
        return 0

    def getInstallId(self):
        try:
            install_id = self.get_setting("install_id", None)
            if install_id and isinstance(install_id, str):
                return install_id
            install_id = secrets.token_hex(16)
            self.set_setting("install_id", install_id)
            return install_id
        except Exception:
            return secrets.token_hex(16)

    def getDevKey(self):
        try:
            key = self.get_setting("devkey", None)
            if key and isinstance(key, str):
                return key
            key = secrets.token_hex(16)
            self.set_setting("devkey", key)
            return key
        except Exception:
            return secrets.token_hex(16)

    def getP2pKey(self, chat_id):
        try:
            return self.p2pKeys.get(self.normChat(chat_id))
        except Exception:
            return None

    def setP2pKey(self, chat_id, key):
        try:
            if not key or not isinstance(key, str):
                return
            self.p2pKeys[self.normChat(chat_id)] = key
        except Exception:
            pass

    def newP2pKey(self, chat_id):
        try:
            key = secrets.token_hex(16)
            self.p2pKeys[self.normChat(chat_id)] = key
            self.saveSoon()
            return key
        except Exception:
            return None

    def getStreakKey(self, chat_id):
        chat_id = self.normChat(chat_id)
        my_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
        other_id = chat_id

        try:
            if not my_id or int(my_id) <= 0:
                return f"pending:{other_id}"
        except Exception:
            return f"pending:{other_id}"

        try:
            user_ids = sorted([int(my_id), int(other_id)])
        except Exception:
            user_ids = sorted([str(my_id), str(other_id)])
        streak_key = f"{user_ids[0]}:{user_ids[1]}"
        self.migratePendingStreakKey(other_id, streak_key)
        return streak_key

    def getSortedIds(self, chat_id):
        chat_id = self.normChat(chat_id)
        my_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
        other_id = int(chat_id)

        ids = sorted([int(my_id), other_id])

        return ids[0], ids[1]

    def migrateAllPendingStreaks(self):
        my_id = self.getMyId()
        if not my_id or my_id <= 0:
            return
        my_id_str = str(my_id)
        with self.data_lock:
            pending_keys = [
                k for k in self.streaks.keys()
                if isinstance(k, str) and k.startswith("pending:")
            ]

        for pending_key in pending_keys:
            chat_id = pending_key.split(":", 1)[1]
            other_id = str(chat_id)
            user_ids = sorted([my_id_str, other_id])
            target_key = f"{user_ids[0]}:{user_ids[1]}"
            self.migratePendingStreakKey(chat_id, target_key)

    def cleanupPendingStreaks(self):
        with self.data_lock:
            pending_keys = [
                k for k, v in self.streaks.items()
                if isinstance(k, str)
                and k.startswith("pending:")
                and v
                and getattr(v, "count", 0) == 0
                and getattr(v, "deleted", False)
            ]
            for key in pending_keys:
                del self.streaks[key]
                self.log(f"WSP: removed inactive pending streak {key}")

    def migratePendingStreakKey(self, chat_id, target_key):
        pending_key = f"pending:{chat_id}"
        if pending_key == target_key:
            return

        with self.data_lock:
            pending = self.streaks.get(pending_key)
            if not pending:
                return

            existing = self.streaks.get(target_key)
            if not existing:
                self.streaks[target_key] = pending
                del self.streaks[pending_key]
                self.log(
                    f"WSP: migrated pending streak key {pending_key} -> {target_key}"
                )
                return

            keep_pending = (
                getattr(pending, "last_sync_timestamp", 0)
                > getattr(existing, "last_sync_timestamp", 0)
            )
            if keep_pending:
                self.streaks[target_key] = pending
            del self.streaks[pending_key]
            self.log(
                f"WSP: merged pending streak key {pending_key} into {target_key} (kept_pending={keep_pending})"
            )
    def getStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if not self.isPrivateChat(chat_id):
            return None

        streak_key = self.getStreakKey(chat_id)
        return self.streaks.get(streak_key)

    def onStreakDied(self, chat_id):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            pet = self.pets.get(chat_id)
            if pet and not pet.deleted:
                self.markPetDeleted(pet)
                self.pet_enabled_chats.discard(chat_id)
                self.log(f"WSP: pet also died with streak for chat {chat_id}")
                self.saveSoon()
                self.runAsync(self.syncPet, chat_id, pet, True)

    def shouldRunSync(self):
        if not self.get_setting("background_sync", True):
            return False

        sync_manager = self.getSyncMgr()
        if sync_manager.mode not in [
            StreakSyncManager.MODE_SERVER,
            StreakSyncManager.MODE_AUTO,
        ]:
            return False

        my_user_id = self.getMyId()
        return my_user_id and my_user_id > 0

    def shouldCheckServer(self, chat_id, min_interval):
        now = time.time()
        if now - self.last_global_server_check < 2:
            return False

        sync_manager = self.getSyncMgr()
        cooldown = min_interval
        if getattr(sync_manager, "server_degraded", False):
            cooldown = cooldown * 3

        last_check = self.last_server_check.get(chat_id, 0)
        if now - last_check < cooldown:
            return False

        self.last_server_check[chat_id] = now
        self.last_global_server_check = now
        return True

    def getSyncInterval(self):
        sync_interval_index = self.get_setting("auto_sync_interval", 1)
        sync_interval = (
            SYNC_INTERVAL_OPTIONS[sync_interval_index]
            if sync_interval_index < len(SYNC_INTERVAL_OPTIONS)
            else SYNC_INTERVAL_OPTIONS[SYNC_INTERVAL_DEFAULT_INDEX]
        )
        sync_manager = self.getSyncMgr()
        if getattr(sync_manager, "server_degraded", False):
            sync_interval = min(sync_interval * 2, SYNC_INTERVAL_DISABLED)
        return sync_interval

    def getSyncMode(self):
        sync_mode_index = self.get_setting(
            "streak_sync_mode", SYNC_MODE_DEFAULT_INDEX
        )
        return SYNC_MODE_BY_INDEX.get(sync_mode_index, SYNC_MODE_DEFAULT)

    def checkExpiredStreaks(self):
        with self.data_lock:
            for streak_key, streak in list(self.streaks.items()):
                if streak and not streak.deleted:
                    try:
                        if streak.check_and_reset_if_expired():
                            chat_id = streak.chat_id
                            self.log(f"WSP: streak expired and reset for {chat_id}")
                            if streak.is_dead:
                                self.onStreakDied(chat_id)
                            self.runAsync(self.syncStreak, chat_id, streak, True)
                    except Exception as e:
                        self.log(
                            f"WSP: error checking streak expiration for {streak_key}: {e}"
                        )

    def collectChatsForSync(self):
        with self.data_lock:
            chats_with_streaks = list(self.streak_enabled_chats.copy())
            chats_with_pets = list(self.pet_enabled_chats.copy())
            chats_to_sync = list(set(chats_with_streaks + chats_with_pets))

        self.log(
            f"WSP: background sync starting for {len(chats_to_sync)} chats "
            f"(streaks: {len(chats_with_streaks)}, pets: {len(chats_with_pets)})"
        )

        return chats_with_streaks, chats_with_pets

    def collectSyncData(self, chats_with_streaks, chats_with_pets):
        streak_data_list = []
        pet_data_list = []

        with self.data_lock:
            for chat_id in chats_with_streaks:
                chat_key = self.normChat(chat_id)
                streak_key = self.getStreakKey(chat_key)
                streak = self.streaks.get(streak_key)
                if not streak:
                    for candidate in self.streaks.values():
                        if getattr(candidate, "chat_id", None) == chat_key:
                            streak = candidate
                            break
                if streak and not streak.deleted:
                    streak_data = streak.get_sync_data()
                    if (
                        self._last_synced_streak_hash.get(chat_key)
                        != self.hashSync(streak_data)
                    ):
                        if not self.guardSyncStreak(chat_key, streak_data):
                            self.recordSyncStatus(chat_key, "send:server", False, "client_guard")
                            continue
                        streak_data_list.append((chat_key, streak_data))

            for chat_id in chats_with_pets:
                chat_key = self.normChat(chat_id)
                pet = self.pets.get(chat_key)
                if pet and not pet.deleted:
                    pet_data = pet.get_sync_data()
                    if (
                        self._last_synced_pet_hash.get(chat_key)
                        != self.hashSync(pet_data)
                    ):
                        if not self.guardSyncPet(chat_key, pet_data):
                            self.recordSyncStatus(chat_key, "send:server", False, "client_guard")
                            continue
                        pet_data_list.append((chat_key, pet_data))

        return streak_data_list, pet_data_list

    def buildServerChatKeyMaps(self, sync_manager):
        my_user_id = self.getMyId(acct=self.lastAcct)
        if not my_user_id or my_user_id <= 0:
            return {}, {}

        streak_map = {}
        for streak_key, streak in self.streaks.items():
            try:
                client_key = sync_manager.clientKey(my_user_id, streak.chat_id)
                streak_map[client_key] = streak_key
            except Exception:
                continue

        pet_map = {}
        for chat_id in self.pets.keys():
            try:
                client_key = sync_manager.clientKey(my_user_id, chat_id)
                pet_map[client_key] = chat_id
            except Exception:
                continue

        return streak_map, pet_map

    def applySyncResults(self, results):
        if not results:
            return

        sync_manager = self.getSyncMgr()
        streak_map, pet_map = self.buildServerChatKeyMaps(sync_manager)

        with self.data_lock:
            for streak_result in results.get("streaks", []):
                server_data = streak_result.get("data")
                action = streak_result.get("action")

                client_key = streak_result.get("client_key") or streak_result.get("chat_key")
                local_key = client_key if client_key in self.streaks else streak_map.get(
                    client_key
                )
                if local_key and local_key in self.streaks:
                    if server_data and action not in ("keep_local", "kept_local"):
                        self.streaks[local_key].apply_sync_data(
                            server_data, source="server"
                        )
                        self.log(
                            f"WSP: batch-sync merged streak {local_key}, action={action}"
                        )
                    self.setSyncedHash(
                        self.streaks[local_key].chat_id,
                        streak_data=self.streaks[local_key].get_sync_data(),
                    )

            for pet_result in results.get("pets", []):
                server_data = pet_result.get("data")
                action = pet_result.get("action")

                client_key = pet_result.get("client_key") or pet_result.get("chat_key")
                chat_key = pet_result.get("chat_key")
                chat_id = pet_map.get(client_key)
                if not chat_id and chat_key in self.pets:
                    chat_id = chat_key
                if not chat_id:
                    for cid in self.pets.keys():
                        if self.getStreakKey(cid) == chat_key:
                            chat_id = cid
                            break
                if chat_id and chat_id in self.pets:
                    if server_data and action not in ("keep_local", "kept_local"):
                        self.pets[chat_id].apply_sync_data(
                            server_data, source="server"
                        )
                        self.log(
                            f"WSP: batch-sync merged pet for {chat_id}, action={action}"
                        )
                    self.setSyncedHash(
                        chat_id, pet_data=self.pets[chat_id].get_sync_data()
                    )

            self.saveDataUnsafe()

    def resetSyncBackoff(self):
        self.sync_consecutive_errors = 0
        self.sync_backoff_seconds = 1

    def handleSyncErr(self, error):
        self.log(f"WSP: background sync loop error: {error}")
        self.log(f"WSP: bg-sync traceback: {traceback.format_exc()}")
        self.sync_consecutive_errors += 1
        self.sync_backoff_seconds = min(
            self.sync_backoff_seconds * 2, self.sync_backoff_max
        )
        self.log(
            f"WSP: backoff increased to {self.sync_backoff_seconds}s "
            f"(errors: {self.sync_consecutive_errors})"
        )

    def runBgSync(self):
        self.checkExpiredStreaks()
        streakChats, petChats = self.collectChatsForSync()
        streakList, petList = self.collectSyncData(streakChats, petChats)

        if not streakList and not petList:
            self.log("WSP: no data to sync, skipping")
            return

        sync_manager = self.getSyncMgr()
        if not sync_manager.checkServerHealth():
            for chat_id, _ in streakList:
                self.recordSyncStatus(chat_id, "send:server", False, "server_unavailable")
            for chat_id, _ in petList:
                self.recordSyncStatus(chat_id, "send:server", False, "server_unavailable")
            raise RuntimeError("server_unavailable")
        now = time.time()
        if now < getattr(sync_manager, "rateWaitUntil", 0):
            raise RuntimeError("rate_limited")
        if now < getattr(sync_manager, "authWaitUntil", 0):
            raise RuntimeError("auth_wait")
        myId = self.getMyId()
        results = sync_manager.batch_sync(myId, streakList, petList)
        if results is None:
            reason = sync_manager.last_error or "batch_failed"
            for chat_id, _ in streakList:
                self.recordSyncStatus(chat_id, "send:server", False, reason)
            for chat_id, _ in petList:
                self.recordSyncStatus(chat_id, "send:server", False, reason)
            raise RuntimeError(reason)
        self.applySyncResults(results)

    def bgSyncLoop(self):
        self.log("WSP: background sync thread started")

        while not self.shutdown_event.is_set():
            try:
                if not self.shouldRunSync():
                    self.shutdown_event.wait(SYNC_DEFAULT_WAIT_SECONDS)
                    continue

                sync_interval = self.getSyncInterval()
                if sync_interval >= SYNC_INTERVAL_DISABLED:
                    self.shutdown_event.wait(SYNC_DEFAULT_WAIT_SECONDS)
                    continue

                self.runBgSync()

                self.log("WSP: background sync cycle completed")
                self.resetSyncBackoff()
                self.shutdown_event.wait(sync_interval)

            except Exception as e:
                self.handleSyncErr(e)
                self.shutdown_event.wait(self.sync_backoff_seconds)

        self.log("WSP: background sync thread stopped")

    def setupHooks(self):
        self.add_on_send_message_hook()
        self.log("WSP: send hook added")

        self.add_hook("UpdateNewMessage", match_substring=True)
        self.log("WSP: update hook added")

    def loadSavedData(self):
        self.loadData()
        self.log(f"WSP: loaded {len(self.pets)} pets")

    def initSyncMgr(self):
        sync_mode = self.getSyncMode()
        self.sync_manager = StreakSyncManager(
            mode=sync_mode, server_url=None, enable_fallback=True
        )
        try:
            self.sync_manager.setInstallId(self.getInstallId())
        except Exception:
            pass
        try:
            self.sync_manager.setUserId(self.getMyId(acct=0))
            self.lastAcct = 0
        except Exception:
            pass
        try:
            self.sync_manager.setDevKey(self.getDevKey())
        except Exception:
            pass
        self.log(
            f"WSP: sync_manager initialized in {sync_mode} mode, server=default"
        )

    def startBgSync(self):
        if self.get_setting("background_sync", True):
            self.background_sync_thread = threading.Thread(
                target=self.bgSyncLoop, daemon=False
            )
            self.background_sync_thread.start()
            self.log("WSP: background sync thread started")

    def initWidgetMgr(self):
        self.widget_manager = WidgetManager(self)
        self.log("WSP: widget manager initialized")

    def setupChatHooks(self):
        try:
            self.log("WSP: trying to hook ChatActivity.onResume")
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            self.log(f"WSP: ChatActivity class = {ChatActivity}")
            if ChatActivity:
                method_onresume = ChatActivity.getClass().getDeclaredMethod("onResume")
                self.log(f"WSP: got onResume method = {method_onresume}")
                method_onresume.setAccessible(True)
                hook_instance = ChatActivityHook(self)
                self.log(f"WSP: created hook instance = {hook_instance}")
                self.header_hook = self.hook_method(method_onresume, hook_instance)
                self.log(f"WSP: hook_method returned = {self.header_hook}")
                self.log("WSP: header hook OK!")
            else:
                self.log("WSP: ChatActivity class is None!")
        except Exception as e:
            self.log(f"WSP: header hook fail {e}")
            self.log(f"WSP: hook traceback: {traceback.format_exc()}")

        try:
            self.log("WSP: trying to hook ChatActivity.onPause")
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if ChatActivity:
                method_onpause = ChatActivity.getClass().getDeclaredMethod("onPause")
                self.log(f"WSP: got onPause method = {method_onpause}")
                method_onpause.setAccessible(True)
                cleanup_hook_instance = WidgetCleanupHook(self)
                self.log(
                    f"WSP: created cleanup hook instance = {cleanup_hook_instance}"
                )
                self.cleanup_hook = self.hook_method(
                    method_onpause, cleanup_hook_instance
                )
                self.log(f"WSP: cleanup hook_method returned = {self.cleanup_hook}")
                self.log("WSP: cleanup hook OK!")
            else:
                self.log("WSP: ChatActivity class is None!")
        except Exception as e:
            self.log(f"WSP: cleanup hook fail {e}")
            self.log(f"WSP: cleanup hook traceback: {traceback.format_exc()}")

    def registerMenuItems(self):
        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                item_id="wsp_menu",
                text="WSP",
                icon="msg_fave",
                on_click=self.showWspMenu,
            )
        )

    def on_plugin_load(self):
        setLogDebug(self.get_setting("debug_mode", False))
        self.log("WSP: starting load")

        self.setupHooks()
        self.loadSavedData()
        self.migrateAllPendingStreaks()
        self.initSyncMgr()
        self.startBgSync()
        self.initWidgetMgr()
        self.setupChatHooks()
        self.registerMenuItems()

        if not self.get_setting("_first_run_done", False):
            self.showFirstRunWelcome()
            self.set_setting("_first_run_done", True)

        self.log("WSP: plugin loaded!")

    def showFirstRunWelcome(self):
        def delayed_show():
            time.sleep(1.5)
            self.bulletin(
                "success",
                tr(
                    "WSP –≤–∫–ª—é—á–µ–Ω. –û—Ç–∫—Ä–æ–π –º–µ–Ω—é —á–∞—Ç–∞ ‚Üí WSP, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å",
                    "WSP is on. Open the chat menu ‚Üí WSP to start",
                ),
                ui_thread=True,
            )
        self.runAsync(delayed_show)

    def on_plugin_unload(self):
        self.log("WSP: starting graceful shutdown...")

        self.shutdown_event.set()

        if self.background_sync_thread and self.background_sync_thread.is_alive():
            self.log("WSP: waiting for background sync thread...")
            self.background_sync_thread.join(timeout=10.0)
            if self.background_sync_thread.is_alive():
                self.log("WSP: background sync thread did not finish in time")

        self.log("WSP: shutting down thread pool...")
        self._executor.shutdown(wait=True, cancel_futures=False)

        with self.data_lock:
            for widget in list(self.active_widgets.values()):
                try:
                    if hasattr(widget, "cleanup"):
                        widget.cleanup()
                except Exception as e:
                    self.log(f"WSP: error cleaning up widget: {e}")
            self.active_widgets.clear()
            try:
                if self.active_streak_badges:
                    for badge in list(self.active_streak_badges.values()):
                        try:
                            if hasattr(badge, "cleanup"):
                                badge.cleanup()
                        except Exception:
                            pass
                    self.active_streak_badges.clear()
            except Exception:
                pass
            try:
                if self.widget_manager and hasattr(self.widget_manager, "active_pet_widgets"):
                    for widget in list(self.widget_manager.active_pet_widgets.values()):
                        try:
                            if hasattr(widget, "cleanup"):
                                widget.cleanup()
                        except Exception:
                            pass
                    self.widget_manager.active_pet_widgets.clear()
                    if hasattr(self.widget_manager, "active_streak_badges"):
                        for badge in list(self.widget_manager.active_streak_badges.values()):
                            try:
                                if hasattr(badge, "cleanup"):
                                    badge.cleanup()
                            except Exception:
                                pass
                        self.widget_manager.active_streak_badges.clear()
            except Exception:
                pass
            self._pending_pet_syncs.clear()
            self.last_pet_sync.clear()
            self._pending_streak_syncs.clear()
            self.last_streak_sync.clear()
            self.last_p2p_sync.clear()

        if self.header_hook:
            self.unhook_method(self.header_hook)
        if self.cleanup_hook:
            self.unhook_method(self.cleanup_hook)
        self.header_hook = None
        self.cleanup_hook = None

        with self.data_lock:
            for pet in list(self.pets.values()):
                try:
                    if hasattr(pet, "cleanup"):
                        pet.cleanup()
                except Exception as e:
                    self.log(f"WSP: error cleaning up pet: {e}")

        sync_manager = self.getSyncMgr()
        if sync_manager and hasattr(sync_manager, "cache"):
            sync_manager.cache.clear()

        self.last_auto_sync.clear()
        self.last_messages.clear()
        try:
            UI._cache.clear()
        except Exception:
            pass
        self.widget_manager = None
        self.sync_manager = None
        self.background_sync_thread = None
        try:
            self._executor = None
        except Exception:
            pass

        self.saveData()
        self.log("WSP: plugin unloaded successfully")

    def create_settings(self):
        try:
            self.log("WSP: building settings list...")
            pet_style_items = [
                tr(
                    "ü¶Ö –ü—Ç–∏—Ü–∞ (—è–π—Ü–æ ‚Üí –ø—Ç–µ–Ω–µ—Ü ‚Üí —Ü—ã–ø–∞ ‚Üí –ø–µ—Ç—É—Ö ‚Üí –æ—Ä—ë–ª)",
                    "ü¶Ö Bird (egg ‚Üí chick ‚Üí baby ‚Üí rooster ‚Üí eagle)",
                ),
                tr(
                    "üëæ –ú–æ–Ω—Å—Ç—Ä (—è–π—Ü–æ ‚Üí —Å–ª–∏–∑–µ–Ω—å ‚Üí –≥–æ–±–ª–∏–Ω ‚Üí –¥–µ–º–æ–Ω ‚Üí –¥—Ä–∞–∫–æ–Ω)",
                    "üëæ Monster (egg ‚Üí slime ‚Üí goblin ‚Üí demon ‚Üí dragon)",
                ),
                tr(
                    "üå± –†–∞—Å—Ç–µ–Ω–∏–µ (—Ä–æ—Å—Ç–æ–∫ ‚Üí –ø–æ–±–µ–≥ ‚Üí –∫–ª–µ–≤–µ—Ä ‚Üí –¥–µ—Ä–µ–≤–æ ‚Üí —Å–∞–∫—É—Ä–∞)",
                    "üå± Plant (sprout ‚Üí shoot ‚Üí clover ‚Üí tree ‚Üí sakura)",
                ),
                tr(
                    "‚≠ê –ö–æ—Å–º–æ—Å (–∑–≤–µ–∑–¥–∞ ‚Üí –∏—Å–∫—Ä–∞ ‚Üí –±–ª–µ—Å–∫ ‚Üí –∫–æ–º–µ—Ç–∞ ‚Üí –≥–∞–ª–∞–∫—Ç–∏–∫–∞)",
                    "‚≠ê Space (star ‚Üí spark ‚Üí glow ‚Üí comet ‚Üí galaxy)",
                ),
                tr(
                    "‚öôÔ∏è –¢–µ—Ö–Ω–æ (–¥–µ—Ç–∞–ª—å ‚Üí –±–æ–ª—Ç ‚Üí —Ä–æ–±–æ—Ç ‚Üí —Ä–∞–∫–µ—Ç–∞ ‚Üí –ù–õ–û)",
                    "‚öôÔ∏è Tech (part ‚Üí bolt ‚Üí robot ‚Üí rocket ‚Üí UFO)",
                ),
                tr(
                    "üê∑ –ñ–∏—Ä–Ω–æ—Å—Ç—å (–ñ–∏—Ä–Ω–æ—Å—Ç—å ‚Üí –ñ–∏—Ä–æ–∫ ‚Üí –ø–æ–Ω—á–∏–∫ ‚Üí –±—É—Ä–≥–µ—Ä ‚Üí –°–≤–∏–Ω—Ç—É—Å)",
                    "üê∑ Chonk (egg ‚Üí bun ‚Üí donut ‚Üí burger ‚Üí Pigga)",
                ),
            ]
            sync_mode_items = [
                tr("P2P (—á–µ—Ä–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏—è)", "P2P (via messages)"),
                tr("–°–µ—Ä–≤–µ—Ä (–æ–±–ª–∞–∫–æ)", "Server (cloud)"),
                tr("–ê–≤—Ç–æ (–≥–∏–±—Ä–∏–¥)", "Auto (hybrid)"),
            ]
            sync_interval_items = [
                tr("30 —Å–µ–∫—É–Ω–¥", "30 seconds"),
                tr("60 —Å–µ–∫—É–Ω–¥", "60 seconds"),
                tr("120 —Å–µ–∫—É–Ω–¥", "120 seconds"),
                tr("300 —Å–µ–∫—É–Ω–¥", "300 seconds"),
                tr("–û—Ç–∫–ª—é—á–µ–Ω–æ", "Disabled"),
            ]
            settings_list = [
                Header(text=tr("–í–Ω–µ—à–Ω–∏–π –≤–∏–¥", "Appearance")),
                Switch(
                    key="show_widget",
                    text=tr("–ü–ª–∞–≤–∞—é—â–∏–π –ø–∏—Ç–æ–º–µ—Ü", "Floating pet"),
                    default=DEFAULTS["show_widget"],
                    subtext=tr(
                        "–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤–∏–¥–∂–µ—Ç –Ω–∞ —ç–∫—Ä–∞–Ω–µ",
                        "Show the widget on screen",
                    ),
                    icon="msg_fave",
                ),
                Selector(
                    key="widget_size",
                    text=tr("–†–∞–∑–º–µ—Ä", "Size"),
                    default=2,
                    items=["60dp", "70dp", "80dp", "90dp", "100dp", "110dp", "120dp"],
                ),
                Selector(
                    key="widget_mode",
                    text=tr("–†–µ–∂–∏–º –≤–∏–¥–∂–µ—Ç–∞", "Widget mode"),
                    default=0,
                    items=[
                        tr("–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π", "Compact"),
                        tr("–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π", "Expanded"),
                    ],
                ),
                Selector(
                    key="widget_alpha",
                    text=tr("–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –≤–∏–¥–∂–µ—Ç–∞", "Widget opacity"),
                    default=4,
                    items=["30%", "50%", "70%", "90%", "100%"],
                ),
                Selector(
                    key="pet_emoji_style",
                    text=tr("–°—Ç–∏–ª—å –ø–∏—Ç–æ–º—Ü–∞", "Pet style"),
                    default=0,
                    items=pet_style_items,
                ),
                Divider(),
                Header(text=tr("settings_gameplay")),
                Switch(
                    key="show_notifications",
                    text=tr("settings_evolution_notifications"),
                    default=True,
                    subtext=tr("settings_evolution_notifications_sub"),
                    icon="msg_notify",
                ),
                Divider(),
                Header(text=tr("settings_sync")),
                Selector(
                    key="streak_sync_mode",
                    text=tr("settings_sync_mode"),
                    default=2,
                    items=sync_mode_items,
                ),
                Switch(
                    key="p2p_switch_offer",
                    text=tr("settings_p2p_offer"),
                    default=True,
                    subtext=tr("settings_p2p_offer_sub"),
                    icon="msg_info",
                ),
                Selector(
                    key="auto_sync_interval",
                    text=tr("settings_sync_interval"),
                    default=1,
                    items=sync_interval_items,
                ),
                Switch(
                    key="show_last_sync_status",
                    text=tr("settings_sync_status"),
                    default=True,
                    subtext=tr("settings_sync_status_sub"),
                    icon="msg_info",
                ),
                Switch(
                    key="background_sync",
                    text=tr("settings_bg_sync"),
                    default=True,
                    subtext=tr("settings_bg_sync_sub"),
                    icon="msg_autodelete",
                ),
                Divider(),
                Header(text=tr("settings_debug")),
                Switch(
                    key="debug_mode",
                    text=tr("settings_debug_mode"),
                    default=False,
                    subtext=tr("settings_debug_mode_sub"),
                    icon="msg_log",
                    on_change=lambda v: setLogDebug(v),
                ),
                Text(
                    text=tr("settings_check_server"),
                    icon="msg_satellite",
                    on_click=self.checkServer,
                ),
                Text(
                    text=tr("–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é", "Reset auth"),
                    icon="msg_retry",
                    on_click=self.resetAuth,
                ),
                Text(
                    text=tr("settingsclearCache"),
                    icon="msg_clear_recent",
                    on_click=self.clearCache,
                ),
                Divider(),
                Header(text=tr("settings_danger_zone")),
                Text(
                    text=tr("settings_reset_data"),
                    icon="msg_delete",
                    red=True,
                    on_click=self.resetAllData,
                ),
            ]

            self.log(f"WSP: settings list created with {len(settings_list)} items")
            return settings_list
        except Exception as e:
            self.log(f"WSP: ERROR creating settings: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")
            return []

    def on_send_message_hook(self, account, params):
        try:
            chat_id = self.normChat(params.peer)
            message = params.message
            self.setChatAccount(chat_id, account)

            self.log(f"WSP: msg from chat {chat_id}")

            if not isinstance(message, str):
                return HookResult()

            chat_allowed = self.isChatAllowed(chat_id, acct=account)
            streak = None
            updated = False
            with self.data_lock:
                streak_on = chat_id in self.streak_enabled_chats
                pet_on = chat_id in self.pet_enabled_chats
            if chat_allowed:
                if streak_on:
                    streak = self.getOrCreateStreak(chat_id)
                    if streak:
                        updated = streak.update_streak()
                        if updated:
                            self.log(f"WSP: streak updated for {chat_id}, sending sync")
                            self.runAsync(self.syncStreak, chat_id, streak, False)
                        else:
                            self.log(
                                f"WSP: streak not updated (same day or earlier) for {chat_id}"
                            )
                else:
                    self.log(
                        f"WSP: streak NOT enabled for chat {chat_id}. Use menu to enable."
                    )

            if chat_allowed and pet_on:
                pet = self.getOrCreatePet(chat_id)

                streak_count = streak.count if streak else 0
                self.log(f"WSP: pet {pet.get_emoji()} streak {streak_count}")

                xp_for_msg = self.calcXp(chat_id, message)

                evolution = pet.add_xp(xp_for_msg)

                if evolution:
                    show_notification = self.get_setting("show_notifications", True)
                    if show_notification:
                        run_on_ui_thread(lambda: self.showEvolution(pet))
                    else:
                        run_on_ui_thread(
                            lambda: bulletin_safe("success",
                                tr(
                                    f"üéâ {pet.get_emoji()} –≠–≤–æ–ª—é—Ü–∏—è",
                                    f"üéâ {pet.get_emoji()} Evolution",
                                )
                            )
                        )

                if streak and updated:
                    bonus_xp = 0
                    bonus_msg = ""
                    count = streak.count
                    if count > 0:
                        if count % 30 == 0:
                            bonus_xp = XP_REWARDS["streak_30_days"]
                            bonus_msg = tr(
                                f"{streak.get_flame_emoji()} {formatDaysRu(count)}: +{bonus_xp} XP üéä",
                                f"{streak.get_flame_emoji()} {formatDaysEn(count)}: +{bonus_xp} XP üéä",
                            )
                        elif count % 14 == 0:
                            bonus_xp = XP_REWARDS["streak_14_days"]
                            bonus_msg = tr(
                                f"{streak.get_flame_emoji()} {formatDaysRu(count)}: +{bonus_xp} XP üéâ",
                                f"{streak.get_flame_emoji()} {formatDaysEn(count)}: +{bonus_xp} XP üéâ",
                            )
                        elif count % 7 == 0:
                            bonus_xp = XP_REWARDS["streak_7_days"]
                            bonus_msg = tr(
                                f"{streak.get_flame_emoji()} {formatDaysRu(count)}: +{bonus_xp} XP –±–æ–Ω—É—Å",
                                f"{streak.get_flame_emoji()} {formatDaysEn(count)}: +{bonus_xp} XP bonus",
                            )
                        elif count % 3 == 0:
                            bonus_xp = XP_REWARDS["streak_3_days"]
                            bonus_msg = tr(
                                f"{streak.get_flame_emoji()} {formatDaysRu(count)}: +{bonus_xp} XP üî•",
                                f"{streak.get_flame_emoji()} {formatDaysEn(count)}: +{bonus_xp} XP üî•",
                            )

                    if bonus_xp > 0:
                        pet.add_xp(bonus_xp)
                        run_on_ui_thread(
                            lambda msg=bonus_msg: bulletin_safe("success", msg)
                        )

                with self.data_lock:
                    self.last_messages[chat_id] = time.time()
                self.saveSoon()

                self.runAsync(self.syncPet, chat_id, pet, False)

                if (
                    self.get_setting("show_widget", True)
                    and chat_id in self.active_widgets
                ):
                    run_on_ui_thread(
                        lambda: self.createFlameParticle(chat_id, xp_for_msg)
                    )
            else:
                self.log(
                    f"WSP: pet NOT enabled for chat {chat_id}. Use menu to enable."
                )
                self.saveSoon()

        except Exception as err:
            self.log(f"WSP send hook error: {err}")

        return HookResult()

    def on_update_hook(self, update_name, account, update):
        try:
            if "UpdateNewMessage" not in update_name:
                return HookResult()

            message = getattr(update, "message", None)
            if not message:
                return HookResult()

            message_text = getattr(message, "message", None)
            if not message_text or not isinstance(message_text, str):
                return HookResult()

            peer = getattr(message, "peerId", None) or getattr(message, "peer_id", None)
            if not peer:
                return HookResult()

            from_id = getattr(peer, "userId", None) or getattr(peer, "user_id", None)
            if not from_id:
                return HookResult()

            chat_id = self.normChat(from_id)
            self.setChatAccount(chat_id, account)

            if not self.isPrivateChat(chat_id):
                return HookResult()

            with self.data_lock:
                streak_on = chat_id in self.streak_enabled_chats
                pet_on = chat_id in self.pet_enabled_chats

            p2pKey = self.getP2pKey(chat_id)
            sync_data = StreakSyncManager.parse_sync_message(message_text, chat_id, key=p2pKey)
            if not sync_data:
                if looksSyncMsg(message_text):
                    self.deleteMsg(message, acct=account)
                    if streak_on or pet_on:
                        self.checkServerData(chat_id)
                    return HookResult(strategy=HookStrategy.CANCEL)
                if streak_on or pet_on:
                    self.checkServerData(chat_id)
                return HookResult()

            sync_manager = self.getSyncMgr(chat_id=chat_id)
            if sync_manager.mode in [
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ]:
                self.offerP2pSwitch(chat_id)

            if sync_manager.mode == StreakSyncManager.MODE_SERVER:
                self.log(f"WSP: ignoring P2P message in SERVER mode for chat {chat_id}")
                self.deleteMsg(message, acct=account)
                return HookResult(strategy=HookStrategy.CANCEL)

            streak_payload = sync_data.get("streak")
            if streak_payload:
                is_deleted = streak_payload.get("deleted", False)

                if is_deleted:
                    local_streak = None
                    apply_delete = True
                    with self.data_lock:
                        streak_key = self.getStreakKey(chat_id)
                        local_streak = self.streaks.get(streak_key)
                        if local_streak and not local_streak.deleted:
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_streak, streak_payload, "p2p"
                            )

                        if apply_delete:
                            self.streak_enabled_chats.discard(chat_id)
                            if local_streak:
                                self.markStreakDeleted(
                                    local_streak, update_sync_ts=True
                                )

                    if apply_delete:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "p2p",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                            remote_ts=streak_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P sync received deleted=True for streak {chat_id}, resetting streak"
                        )
                        self.log(f"WSP: streak deactivated from P2P sync for {chat_id}")
                    else:
                        self.logSyncDecision(
                            "streak",
                            chat_id,
                            "p2p",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                            remote_ts=streak_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P deleted ignored for {chat_id}, keeping local"
                        )
                else:
                    if chat_id not in self.streak_enabled_chats:
                        self.log(
                            f"WSP: auto-enabling streak for chat {chat_id} from P2P sync"
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)

                    with self.data_lock:
                        streak_key = self.getStreakKey(chat_id)
                        streak = self.streaks.get(streak_key)
                        if not streak:
                            streak = self.getOrCreateStreak(chat_id)

                        if streak:
                            result = self.mergeRemoteSync(
                                "streak",
                                chat_id,
                                streak,
                                streak_payload,
                                "p2p",
                                update_hash=False,
                            )
                            if result["applied"]:
                                self.log(
                                    f"WSP: P2P streak synced for chat {chat_id}, count={streak_payload.get('count', 0)}"
                                )

            pet_payload = sync_data.get("pet")
            if pet_payload:
                is_deleted = pet_payload.get("deleted", False)

                if is_deleted:
                    local_pet = None
                    apply_delete = True
                    with self.data_lock:
                        local_pet = self.pets.get(chat_id)
                        if local_pet and not local_pet.deleted:
                            apply_delete = self.shouldApplyRemoteDelete(
                                local_pet, pet_payload, "p2p"
                            )

                        if apply_delete:
                            self.pet_enabled_chats.discard(chat_id)
                            if local_pet:
                                self.markPetDeleted(
                                    local_pet, update_sync_ts=True
                                )

                    if apply_delete:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "p2p",
                            "accept_delete",
                            reason="remote_deleted",
                            local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                            remote_ts=pet_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P sync received deleted=True for pet {chat_id}"
                        )
                        self.log(f"WSP: pet deactivated from P2P sync for {chat_id}")
                    else:
                        self.logSyncDecision(
                            "pet",
                            chat_id,
                            "p2p",
                            "keep_local",
                            reason="remote_deleted",
                            local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                            remote_ts=pet_payload.get("timestamp"),
                        )
                        self.log(
                            f"WSP: P2P deleted ignored for {chat_id}, keeping local"
                        )
                else:
                    if chat_id not in self.pet_enabled_chats:
                        self.log(
                            f"WSP: auto-enabling pet for chat {chat_id} from P2P sync"
                        )
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)

                    with self.data_lock:
                        pet = self.pets.get(chat_id)
                        if not pet:
                            pet = self.getOrCreatePet(chat_id)

                        if pet:
                            result = self.mergeRemoteSync(
                                "pet",
                                chat_id,
                                pet,
                                pet_payload,
                                "p2p",
                                update_hash=False,
                            )
                            if result["applied"]:
                                self.log(
                                    f"WSP: P2P pet synced for chat {chat_id}, xp={pet_payload.get('xp', 0)}, stage={pet_payload.get('stage', 0)}, name={pet_payload.get('name', 'unknown')}"
                                )

            if streak_payload or pet_payload:
                self.saveSoon()

            self.deleteMsg(message, acct=account)

            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            self.log(f"WSP update hook error: {e}")

        return HookResult()

    def hasRepeatedChars(self, text, threshold=None):
        if threshold is None:
            threshold = SPAM_REPEATED_CHARS_THRESHOLD

        if len(text) < 10:
            return False

        from collections import Counter

        char_counts = Counter(text.replace(" ", ""))
        if not char_counts:
            return False

        most_common_char, count = char_counts.most_common(1)[0]
        ratio = count / len(text.replace(" ", ""))

        return ratio > threshold

    def calcSimilarity(self, text1, text2):
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())

        if not words1 or not words2:
            return 0.0

        intersection = len(words1 & words2)
        union = len(words1 | words2)

        return intersection / union if union > 0 else 0.0

    def isSpamMessage(self, chat_id, message):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            recent = self.recent_messages.get(chat_id, [])

        if len(recent) >= SPAM_IDENTICAL_THRESHOLD:
            last_messages = recent[-SPAM_IDENTICAL_THRESHOLD:]
            if len(set(last_messages)) == 1:
                return True

        if len(recent) >= 2:
            similarity = self.calcSimilarity(message, recent[-1])
            if similarity > SPAM_SIMILARITY_THRESHOLD:
                self.log(
                    f"WSP: similar messages detected for {chat_id} (similarity: {similarity:.2f})"
                )
                return True

        return False

    def calcXp(self, chat_id, message):
        chat_id = self.normChat(chat_id)
        current_time = time.time()

        with self.data_lock:
            last_xp = self.last_xp_time.get(chat_id, 0)
        if current_time - last_xp < XP_COOLDOWN_SECONDS:
            self.log(
                f"WSP: XP cooldown active for {chat_id} ({current_time - last_xp:.1f}s < {XP_COOLDOWN_SECONDS}s)"
            )
            return 0

        hour_ago = current_time - SECONDS_PER_HOUR
        with self.data_lock:
            xp_history = self.xp_history.get(chat_id, [])
        xp_history = [t for t in xp_history if t > hour_ago]
        with self.data_lock:
            self.xp_history[chat_id] = xp_history
        xp_per_hour_limit = XP_MAX_PER_HOUR // XP_REWARDS["msg"]
        max_hist = max(xp_per_hour_limit * 2, 20)
        if len(xp_history) >= xp_per_hour_limit:
            self.log(
                f"WSP: XP rate limit reached for {chat_id} ({len(xp_history)} msgs in last hour)"
            )
            return 0

        message_stripped = message.strip()
        if len(message_stripped) < SPAM_MIN_MESSAGE_LENGTH:
            self.log(
                f"WSP: message too short for {chat_id} (len={len(message_stripped)})"
            )
            return 0

        if self.hasRepeatedChars(message):
            self.log(f"WSP: repeated chars spam detected for {chat_id}")
            return 0

        with self.data_lock:
            recent_messages = self.recent_messages.get(chat_id, [])
        recent_messages.append(message)
        with self.data_lock:
            self.recent_messages[chat_id] = recent_messages[-SPAM_CHECK_WINDOW_MESSAGES:]

        if self.isSpamMessage(chat_id, message):
            self.log(f"WSP: spam detected for {chat_id}")
            return 0

        xp = XP_REWARDS["msg"]
        last_message_date = self.last_messages.get(chat_id)
        today_msk = get_msk_date()
        now_msk = get_msk_now()

        try:
            if (
                last_message_date is None
                or datetime.fromtimestamp(last_message_date, MSK_TZ).date() < today_msk
            ):
                xp += XP_REWARDS["first_of_day"]
        except (ValueError, OSError):
            xp += XP_REWARDS["first_of_day"]

        current_hour_msk = now_msk.hour
        if NIGHT_HOURS_START <= current_hour_msk < NIGHT_HOURS_END:
            xp += XP_REWARDS["night"]

        current_weekday_msk = now_msk.weekday()
        if current_weekday_msk >= 5:
            xp += XP_REWARDS["weekend"]

        with self.data_lock:
            self.last_xp_time[chat_id] = current_time
            self.xp_history[chat_id].append(current_time)
            if len(self.xp_history[chat_id]) > max_hist:
                self.xp_history[chat_id] = self.xp_history[chat_id][-max_hist:]

        return xp

    def getOrCreatePet(self, chat_id):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            if chat_id not in self.pets:
                self.pets[chat_id] = Pet(chat_id, plugin_ref=self)
                self.log(
                    f"WSP: created NEW pet for chat {chat_id}, total pets: {len(self.pets)}"
                )
            else:
                pet = self.pets[chat_id]
                if not hasattr(pet, "plugin_ref") or pet.plugin_ref is None:
                    pet._plugin_ref = weakref.ref(self)
                self.log(
                    f"WSP: using EXISTING pet for chat {chat_id}, stage={pet.stage}, xp={pet.xp}"
                )
            return self.pets[chat_id]

    def getOrCreateStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if not self.isPrivateChat(chat_id):
            return None

        with self.data_lock:
            if chat_id not in self.streak_enabled_chats:
                return None

            streak_key = self.getStreakKey(chat_id)

            if streak_key not in self.streaks:
                self.streaks[streak_key] = Streak(chat_id, plugin_ref=self)
            return self.streaks[streak_key]

    def getSyncMgr(self, chat_id=None, acct=None):
        current_time = time.time()
        if not hasattr(self, "_sync_manager_cache_time"):
            self._sync_manager_cache_time = 0

        if current_time - self._sync_manager_cache_time > 5:
            sync_mode = self.getSyncMode()
            self.sync_manager.mode = sync_mode
            self.sync_manager.server_url = StreakSyncManager.SERVER_URL
            try:
                self.sync_manager.setInstallId(self.getInstallId())
            except Exception:
                pass
            self._sync_manager_cache_time = current_time
        try:
            acct = self.getAcct(chat_id=chat_id, acct=acct)
            my_id = self.getMyId(acct=acct)
            self.sync_manager.setUserId(my_id)
        except Exception:
            pass
        try:
            self.sync_manager.setDevKey(self.getDevKey())
        except Exception:
            pass

        return self.sync_manager

    def syncStreak(self, chat_id, streak, force=False):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        last_sync = self.last_streak_sync.get(chat_id, 0)

        if not force and current_time - last_sync < self.STREAK_SYNC_MIN_INTERVAL:
            if chat_id not in self._pending_streak_syncs:
                self._pending_streak_syncs[chat_id] = True
                def delayed_sync():
                    time.sleep(self.STREAK_SYNC_MIN_INTERVAL - (current_time - last_sync) + 0.1)
                    with self.data_lock:
                        self._pending_streak_syncs.pop(chat_id, None)
                        streak_key = self.getStreakKey(chat_id)
                        if streak_key in self.streaks:
                            self.sendSyncMsg(chat_id, self.streaks[streak_key])
                self.runAsync(delayed_sync)
            return

        self.last_streak_sync[chat_id] = current_time
        self._pending_streak_syncs.pop(chat_id, None)
        self.sendSyncMsg(chat_id, streak)

    def sendP2pSyncMsg(self, chat_id, sync_message, throttle_key, log_prefix):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        with self.data_lock:
            last_sync = self.last_p2p_sync.get(throttle_key, 0)
            if current_time - last_sync < self.P2P_MIN_INTERVAL:
                self.log(f"WSP: {log_prefix}P2P throttled for {chat_id}, skip")
                return False
            self.last_p2p_sync[throttle_key] = current_time
        send_text(int(chat_id), sync_message, silent=True)
        return True

    def sendSyncMsg(self, chat_id, streak):
        """–ù–∞—Å—Ä–∞–ª –∂–∏–¥–µ–Ω—å–∫–æ —Ç—É—Ç–∞"""
        try:
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            mode = sync_manager.mode
            fallbackOk = mode == StreakSyncManager.MODE_AUTO and sync_manager.enable_fallback
            useP2pFallback = False
            serverOk = False
            degradedFallback = (
                mode == StreakSyncManager.MODE_AUTO
                and sync_manager.enable_fallback
                and getattr(sync_manager, "server_degraded", False)
            )

            if mode in [StreakSyncManager.MODE_SERVER, StreakSyncManager.MODE_AUTO]:
                my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))

                if my_user_id and my_user_id > 0:
                    try:
                        with self.data_lock:
                            streakData = streak.get_sync_data()
                            petData = None
                            if chat_id in self.pets:
                                petData = self.pets[chat_id].get_sync_data()

                        if not self.guardSyncStreak(chat_id, streakData):
                            self.recordSyncStatus(chat_id, "send:server", False, "client_guard")
                            return

                        streakOk = sync_manager.save_streak_to_server(
                            my_user_id, chat_id, streakData
                        )
                        streakReason = None if streakOk else (sync_manager.last_error or "streak_save_failed")
                        self.recordSyncStatus(
                            chat_id,
                            "send:server",
                            bool(streakOk),
                            streakReason,
                        )
                        if streakOk:
                            self.setSyncedHash(chat_id, streak_data=streakData)

                        if petData:
                            user1_id, user2_id = self.getSortedIds(chat_id)
                            if not self.guardSyncPet(chat_id, petData):
                                self.recordSyncStatus(chat_id, "send:server", False, "client_guard")
                                return
                            petOk = sync_manager.save_pet_to_server(
                                user1_id, user2_id, petData
                            )
                            petReason = None if petOk else (sync_manager.last_error or "pet_save_failed")
                            self.recordSyncStatus(
                                chat_id,
                                "send:server",
                                bool(petOk),
                                petReason,
                            )
                            if petOk:
                                self.setSyncedHash(chat_id, pet_data=petData)
                            serverOk = streakOk and petOk
                        else:
                            serverOk = streakOk

                        if (
                            not serverOk
                            and mode == StreakSyncManager.MODE_AUTO
                        ):
                            if fallbackOk:
                                useP2pFallback = True
                    except Exception as e:
                        self.log(f"WSP: server sync error: {e}")
                        self.recordSyncStatus(chat_id, "send:server", False, "server_exception")
                        if fallbackOk:
                            useP2pFallback = True
                else:
                    if fallbackOk:
                        useP2pFallback = True
                    self.recordSyncStatus(chat_id, "send:server", False, "invalid_user_id")

            if degradedFallback:
                useP2pFallback = True

            if mode == StreakSyncManager.MODE_P2P or useP2pFallback:
                with self.data_lock:
                    streakData = streak.get_sync_data()
                    petData = None
                    if chat_id in self.pets:
                        petData = self.pets[chat_id].get_sync_data()

                offer = False
                p2pKey = self.getP2pKey(chat_id)
                if not p2pKey:
                    if sync_manager.mode in [
                        StreakSyncManager.MODE_SERVER,
                        StreakSyncManager.MODE_AUTO,
                    ] and sync_manager.checkServerHealth():
                        try:
                            user1_id, user2_id = self.getSortedIds(chat_id)
                            p2pKey = sync_manager.getP2pSrv(
                                user1_id, user2_id
                            )
                            if not p2pKey:
                                p2pKey = self.newP2pKey(chat_id)
                                if p2pKey:
                                    ok = sync_manager.setP2pSrv(
                                        user1_id, user2_id, p2pKey
                                    )
                                    if not ok:
                                        p2pKey = None
                        except Exception:
                            p2pKey = None
                    if not p2pKey:
                        self.recordSyncStatus(chat_id, "send:p2p", False, "p2p_no_key")
                        self.log(f"WSP: P2P key missing for {chat_id}, skip")
                        return

                syncMsg = StreakSyncManager.create_sync_message(
                    streak_data=streakData,
                    pet_data=petData,
                    chat_id=chat_id,
                    key=p2pKey,
                    offer=offer,
                )
                if not syncMsg:
                    self.log(f"WSP: P2P sync skipped for {chat_id}, missing key")
                    return
                p2pOk = self.sendP2pSyncMsg(chat_id, syncMsg, chat_id, "")
                self.recordSyncStatus(
                    chat_id,
                    "send:p2p",
                    bool(p2pOk),
                    None if p2pOk else "p2p_throttled",
                )

        except Exception as e:

            self.log(f"WSP: sync send error: {e}")
            self.log(f"WSP: sync send traceback: {traceback.format_exc()}")

    def syncPet(self, chat_id, pet, force=False):
        chat_id = self.normChat(chat_id)
        current_time = time.time()
        last_sync = self.last_pet_sync.get(chat_id, 0)

        if not force and current_time - last_sync < self.PET_SYNC_MIN_INTERVAL:
            if chat_id not in self._pending_pet_syncs:
                self._pending_pet_syncs[chat_id] = True
                def delayed_sync():
                    time.sleep(self.PET_SYNC_MIN_INTERVAL - (current_time - last_sync) + 0.1)
                    with self.data_lock:
                        self._pending_pet_syncs.pop(chat_id, None)
                        if chat_id in self.pets:
                            self.sendPetSync(chat_id, self.pets[chat_id])
                self.runAsync(delayed_sync)
            return

        self.last_pet_sync[chat_id] = current_time
        self._pending_pet_syncs.pop(chat_id, None)
        self.sendPetSync(chat_id, pet)

    def sendPetSync(self, chat_id, pet):
        """–ë—Ä–æ —è —Ç—É—Ç —É–º–µ—Ä –∏ —Ç–¥"""
        try:
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr(chat_id=chat_id)
            mode = sync_manager.mode
            fallbackOk = mode == StreakSyncManager.MODE_AUTO and sync_manager.enable_fallback
            useP2pFallback = False
            serverOk = False
            degradedFallback = (
                mode == StreakSyncManager.MODE_AUTO
                and sync_manager.enable_fallback
                and getattr(sync_manager, "server_degraded", False)
            )

            if mode in [StreakSyncManager.MODE_SERVER, StreakSyncManager.MODE_AUTO]:
                my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
                self.log(f"WSP pet sync: got my_user_id={my_user_id}")

                if my_user_id and my_user_id > 0:
                    try:
                        self.log(
                            f"WSP: attempting pet sync to server for chat {chat_id}"
                        )
                        user1_id, user2_id = self.getSortedIds(chat_id)

                        with self.data_lock:
                            petData = pet.get_sync_data()

                        if not self.guardSyncPet(chat_id, petData):
                            self.recordSyncStatus(chat_id, "send:server", False, "client_guard")
                            return

                        serverOk = sync_manager.save_pet_to_server(
                            user1_id, user2_id, petData
                        )
                        petReason = None if serverOk else (sync_manager.last_error or "pet_save_failed")
                        self.recordSyncStatus(
                            chat_id,
                            "send:server",
                            bool(serverOk),
                            petReason,
                        )

                        if serverOk:
                            self.setSyncedHash(chat_id, pet_data=petData)
                            self.log(
                                f"WSP: pet saved to server for {chat_id}, xp={pet.xp}, stage={pet.stage}"
                            )
                        else:
                            self.log(f"WSP: failed to save pet to server for {chat_id}")
                            if fallbackOk:
                                useP2pFallback = True
                                self.log(
                                    f"WSP: falling back to P2P sync for pet due to server failure"
                                )
                    except Exception as e:
                        self.log(f"WSP: pet save error: {e}")
                        if fallbackOk:
                            useP2pFallback = True
                            self.log(
                                f"WSP: falling back to P2P sync for pet due to exception: {e}"
                            )
                else:
                    self.log(
                        f"WSP: my_user_id is invalid ({my_user_id}), cannot sync pet"
                    )
                    self.recordSyncStatus(chat_id, "send:server", False, "invalid_user_id")
                    if fallbackOk:
                        useP2pFallback = True
                        self.log(
                            f"WSP: falling back to P2P sync for pet due to invalid user_id"
                        )

            if degradedFallback:
                useP2pFallback = True

            if mode == StreakSyncManager.MODE_P2P or useP2pFallback:
                petThrottleKey = f"pet_{chat_id}"

                with self.data_lock:
                    petData = pet.get_sync_data()

                offer = False
                p2pKey = self.getP2pKey(chat_id)
                if not p2pKey:
                    if sync_manager.mode in [
                        StreakSyncManager.MODE_SERVER,
                        StreakSyncManager.MODE_AUTO,
                    ] and sync_manager.checkServerHealth():
                        try:
                            user1_id, user2_id = self.getSortedIds(chat_id)
                            p2pKey = sync_manager.getP2pSrv(
                                user1_id, user2_id
                            )
                            if not p2pKey:
                                p2pKey = self.newP2pKey(chat_id)
                                if p2pKey:
                                    ok = sync_manager.setP2pSrv(
                                        user1_id, user2_id, p2pKey
                                    )
                                    if not ok:
                                        p2pKey = None
                        except Exception:
                            p2pKey = None
                    if not p2pKey:
                        self.recordSyncStatus(chat_id, "send:p2p", False, "p2p_no_key")
                        self.log(f"WSP: P2P key missing for {chat_id}, skip")
                        return

                syncMsg = StreakSyncManager.create_sync_message(
                    pet_data=petData,
                    chat_id=chat_id,
                    key=p2pKey,
                    offer=offer,
                )
                if not syncMsg:
                    self.log(f"WSP: pet P2P sync skipped for {chat_id}, missing key")
                    return
                p2pOk = self.sendP2pSyncMsg(
                    chat_id, syncMsg, petThrottleKey, "pet "
                )
                self.recordSyncStatus(
                    chat_id,
                    "send:p2p",
                    bool(p2pOk),
                    None if p2pOk else "p2p_throttled",
                )
                if p2pOk:
                    self.log(f"WSP: pet sync message sent via P2P to {chat_id}")

        except Exception as e:

            self.log(f"WSP: pet sync error: {e}")
            self.log(f"WSP: pet sync traceback: {traceback.format_exc()}")

    def deleteMsg(self, message, acct=None):
        try:
            MessagesController = find_class("org.telegram.messenger.MessagesController")
            if not MessagesController:
                self.log(f"WSP: MessagesController not found, cannot delete message")
                return

            message_id = getattr(message, "id", None)
            if not message_id:
                self.log(f"WSP: message has no id, cannot delete")
                return

            peer = getattr(message, "peerId", None) or getattr(message, "peer_id", None)
            if not peer:
                self.log(f"WSP: message has no peer, cannot delete")
                return

            dialog_id = (
                getattr(peer, "userId", None)
                or getattr(peer, "user_id", None)
                or getattr(peer, "channelId", None)
                or getattr(peer, "channel_id", None)
                or getattr(peer, "chatId", None)
                or getattr(peer, "chat_id", None)
            )
            if not dialog_id:
                self.log(f"WSP: cannot determine dialog_id, cannot delete")
                return
            dialog_id = self.normChat(dialog_id)
            if not self.isPrivateChat(dialog_id):
                self.log(f"WSP: not a private chat, skipping message deletion")
                return

            acct = self.getAcct(chat_id=dialog_id, acct=acct)
            controller = MessagesController.getInstance(int(acct))
            if controller:
                from java.util import ArrayList

                ids = ArrayList()
                ids.add(int(message_id))

                run_on_ui_thread(
                    lambda: self.delMsgCore(controller, ids, int(dialog_id))
                )
                self.log(
                    f"WSP: P2P sync message deleted (id={message_id}, dialog={dialog_id})"
                )
            else:
                self.log(f"WSP: MessagesController instance not available")
        except Exception as e:
            self.log(f"WSP: delete message error (non-critical): {e}")

    def delMsgCore(self, controller, ids, dialog_id):
        try:
            controller.deleteMessages(ids, None, None, int(dialog_id), 0, True, 0)
        except TypeError:
            try:
                controller.deleteMessages(ids, None, None, int(dialog_id), True, 0)
            except Exception:
                controller.deleteMessages(ids, None, None, int(dialog_id), True, False)

    def show_pet_stats(self, data):
        self.log(f"WSP: show_pet_stats called with {data}")
        chat_id = self.extractChatId(data)
        chat_id = self.normChat(chat_id)

        if not chat_id:
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–∞—Ç", "Couldn't determine chat"))
            return

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            streak_key = self.getStreakKey(chat_id)
            streak = self.streaks.get(streak_key)
            if streak and not streak.deleted:
                try:
                    if streak.check_and_reset_if_expired():
                        self.log(f"WSP: streak expired when opening menu for {chat_id}")
                        if streak.is_dead:
                            self.onStreakDied(chat_id)
                        bulletin_safe(
                            "error",
                            tr(
                                "–°—Ç—Ä–∏–∫ —Å–±—Ä–æ—à–µ–Ω. –ü—Ä–æ—à–ª–æ –±–æ–ª–µ–µ 24 —á–∞—Å–æ–≤ –±–µ–∑ —Å–æ–æ–±—â–µ–Ω–∏–π.",
                                "Streak reset. More than 24 hours without messages.",
                            ),
                        )
                        self.runAsync(self.syncStreak, chat_id, streak, True)
                except Exception as e:
                    self.log(f"WSP: error checking streak expiration: {e}")

        activity = self.getActivity()
        if not activity:
            return

        try:
            sheet = PetStatsBottomSheet(activity, self, chat_id)
            sheet.show()
            self.runAsync(self.syncFromServer, chat_id, False)
        except Exception as e:
            self.log(f"WSP: show_pet_stats error: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")

    def feed_pet(self, data):
        self.log(f"WSP: feed_pet called with {data}")
        chat_id = self.extractChatId(data)
        if self.guardAction(f"feedPet:{chat_id}", 0.6):
            return

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é –ø–∏—Ç–æ–º—Ü–∞.",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the pet menu.",
                ),
            )
            if not pet:
                return

            current_time = time.time()
            time_diff = current_time - pet.last_feed_time

            if time_diff < FEED_COOLDOWN_SECONDS:
                remaining_minutes = int(
                    (FEED_COOLDOWN_SECONDS - time_diff) / SECONDS_PER_MINUTE
                )
                bulletin_safe(
                    "info",
                    tr(
                        f"–ü–∏—Ç–æ–º–µ—Ü —Å—ã—Ç. –ü–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ {remaining_minutes} –º–∏–Ω",
                        f"Pet is full. Try again in {remaining_minutes} min",
                    ),
                )
                return

            xp_reward = pet.feed()
            evolved = pet.add_xp(xp_reward)
            emoji = pet.get_emoji()

        if evolved:
            bulletin_safe(
                "success",
                tr(
                    f"üçñ –ü–æ–∫–æ—Ä–º–∏–ª. {emoji} –≠–≤–æ–ª—é—Ü–∏—è: +{xp_reward} XP",
                    f"üçñ Fed. {emoji} Evolution: +{xp_reward} XP",
                ),
            )
        else:
            hunger_emoji = "üçñ" if pet.hunger >= 80 else "ü•ó"
            bulletin_safe(
                "success",
                tr(
                    f"{hunger_emoji} –ü–æ–∫–æ—Ä–º–∏–ª. {emoji} +{xp_reward} XP | –ì–æ–ª–æ–¥: {int(pet.hunger)}%",
                    f"{hunger_emoji} Fed. {emoji} +{xp_reward} XP | Hunger: {int(pet.hunger)}%",
                ),
            )

        self.saveSoon()
        self.runAsync(self.syncPet, chat_id, pet, True)

    def showPetMinigame(self, chat_id):
        chat_id = self.normChat(chat_id)

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the menu",
                ),
            )
            if not pet:
                return

        def show_game():
            try:
                from org.telegram.ui.ActionBar import AlertDialog

                activity = self.getActivity()
                if not activity:
                    self.play_with_pet({"chat_id": chat_id})
                    return

                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(
                    AndroidUtilities.dp(Dp.S20),
                    AndroidUtilities.dp(Dp.S16),
                    AndroidUtilities.dp(Dp.S20),
                    AndroidUtilities.dp(Dp.S16),
                )

                title_tv = TextView(activity)
                title_tv.setText(tr("–ú–∏–Ω–∏‚Äë–∏–≥—Ä–∞: –Ω–∞–π–¥–∏ –ª–∞–∫–æ–º—Å—Ç–≤–æ", "Mini‚Äëgame: find the treat"))
                title_tv.setTextSize(1, 16)
                title_tv.setTextColor(UI.on_surface())
                title_tv.setTypeface(None, Typeface.BOLD)
                container.addView(title_tv)

                desc_tv = TextView(activity)
                desc_tv.setText(
                    tr(
                        f"–í—ã–±–µ—Ä–∏ –ª–∞–ø–∫—É –∑–∞ {MINIGAME_TIME_LIMIT_SECONDS}—Å. –ü–æ–±–µ–¥–∞ –¥–∞—ë—Ç –±–æ–Ω—É—Å –∏ –∫–æ–º–±–æ.",
                        f"Pick a paw in {MINIGAME_TIME_LIMIT_SECONDS}s. Win gives bonus and combo.",
                    )
                )
                desc_tv.setTextSize(1, 12)
                desc_tv.setTextColor(UI.on_surface())
                desc_tv.setAlpha(0.8)
                desc_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                desc_params.setMargins(0, AndroidUtilities.dp(Dp.S8), 0, AndroidUtilities.dp(Dp.S12))
                container.addView(desc_tv, desc_params)

                timer_tv = TextView(activity)
                timer_tv.setText(
                    tr(
                        f"‚è≥ {MINIGAME_TIME_LIMIT_SECONDS}—Å",
                        f"‚è≥ {MINIGAME_TIME_LIMIT_SECONDS}s",
                    )
                )
                timer_tv.setTextSize(1, 12)
                timer_tv.setTextColor(UI.on_surface())
                timer_tv.setAlpha(0.8)
                timer_params = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                )
                timer_params.setMargins(0, 0, 0, AndroidUtilities.dp(Dp.S12))
                container.addView(timer_tv, timer_params)

                row = LinearLayout(activity)
                row.setOrientation(LinearLayout.HORIZONTAL)

                btn_params = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0)
                btn_params.setMargins(AndroidUtilities.dp(Dp.S4), 0, AndroidUtilities.dp(Dp.S4), 0)

                win_index = random.randint(1, 3)
                refs = {"dialog": None, "container": container, "timer": timer_tv}
                state = {"done": False, "cancelled": False, "cleaned": False}
                rare_hit = random.random() < MINIGAME_RARE_BONUS_CHANCE

                def cleanup_minigame():
                    if state.get("cleaned"):
                        return
                    state["cleaned"] = True
                    try:
                        dlg = refs.get("dialog")
                        if dlg:
                            try:
                                dlg.dismiss()
                            except Exception:
                                pass
                    except Exception:
                        pass
                    try:
                        cont = refs.get("container")
                        if cont:
                            cont.removeAllViews()
                    except Exception:
                        pass
                    for key in list(refs.keys()):
                        refs[key] = None

                # –º–∏–Ω–∏-–∏–≥—Ä–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                def finalize_result(is_win, result_label):
                    if state["done"] or state["cancelled"]:
                        return
                    state["done"] = True
                    try:
                        dlg = refs.get("dialog")
                        if dlg:
                            dlg.dismiss()
                    except Exception:
                        pass

                    bonus = 0
                    result = result_label
                    if is_win:
                        combo = self.minigame_combo.get(chat_id, 0) + 1
                        self.minigame_combo[chat_id] = combo
                        combo_bonus = min(
                            combo * MINIGAME_COMBO_BONUS_XP, MINIGAME_MAX_COMBO_BONUS
                        )
                        bonus = MINIGAME_WIN_BONUS_XP + combo_bonus
                        if rare_hit:
                            bonus += MINIGAME_RARE_BONUS_XP
                            result = tr(f"{result} ‚ú® –î–∂–µ–∫–ø–æ—Ç", f"{result} ‚ú® Jackpot")
                        result = tr(f"{result} –ö–æ–º–±–æ x{combo}", f"{result} Combo x{combo}")
                    else:
                        self.minigame_combo[chat_id] = 0

                    self.play_with_pet(
                        {"chat_id": chat_id, "bonus_xp": bonus, "minigame_result": result}
                    )
                    cleanup_minigame()

                def on_pick(index):
                    is_win = index == win_index
                    result = tr("üéØ –ü–æ–±–µ–¥–∞", "üéØ Win") if is_win else tr("üòø –ú–∏–º–æ", "üòø Miss")
                    finalize_result(is_win, result)

                for i in range(1, 4):
                    btn = UI.button(activity, f"üêæ {i}", lambda *args, idx=i: on_pick(idx), "tonal")
                    row.addView(btn, btn_params)

                container.addView(row)

                builder = AlertDialog.Builder(activity)
                builder.setTitle(tr("–ò–≥—Ä–∞—Ç—å", "Play"))
                builder.setView(container)
                builder.setNegativeButton(tr("–û—Ç–º–µ–Ω–∞", "Cancel"), None)

                def on_dismiss():
                    if not state["done"]:
                        state["cancelled"] = True
                    cleanup_minigame()

                dialog = safeShowDialog(builder, on_dismiss)
                refs["dialog"] = dialog

                def countdown():
                    for remaining in range(MINIGAME_TIME_LIMIT_SECONDS, 0, -1):
                        if state["done"] or state["cancelled"]:
                            return
                        def update_timer(r):
                            tv = refs.get("timer")
                            if tv:
                                tv.setText(f"‚è≥ {r}—Å")
                        run_on_ui_thread(lambda r=remaining: update_timer(r))
                        time.sleep(1)
                    if state["done"] or state["cancelled"]:
                        return
                    finalize_result(False, "‚åõ –í—Ä–µ–º—è –≤—ã—à–ª–æ")

                threading.Thread(target=countdown, daemon=True).start()
            except Exception as e:
                self.log(f"WSP: mini-game error: {e}")
                self.play_with_pet({"chat_id": chat_id})

        run_on_ui_thread(show_game)

    def play_with_pet(self, data):
        self.log(f"WSP: poigrat called with {data}")
        chat_id = self.extractChatId(data)
        if self.guardAction(f"playPet:{chat_id}", 0.6):
            return
        bonus_xp = 0
        minigame_result = ""
        try:
            bonus_xp = int(data.get("bonus_xp", 0))
        except Exception:
            bonus_xp = 0
        minigame_result = V.str_or(data.get("minigame_result", "")).strip()

        if not self.needPetChat(chat_id):
            return

        with self.data_lock:
            pet = self.getEnabledPet(
                chat_id,
                tr(
                    "–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω. –ù–∞–∂–º–∏ ¬´–í–æ—Å–∫—Ä–µ—Å–∏—Ç—å¬ª –≤ –º–µ–Ω—é –ø–∏—Ç–æ–º—Ü–∞",
                    "Pet inactive. Tap ‚ÄúRevive‚Äù in the pet menu",
                ),
            )
            if not pet:
                return

            if pet.hunger < HUNGER_CONFIG["critical_level"]:
                bulletin_safe(
                    "error",
                    tr(
                        f"üíÄ –ü–∏—Ç–æ–º–µ—Ü —Å–ª–∏—à–∫–æ–º –≥–æ–ª–æ–¥–Ω—ã–π. –°–Ω–∞—á–∞–ª–∞ –ø–æ–∫–æ—Ä–º–∏ –µ–≥–æ (–≥–æ–ª–æ–¥: {int(pet.hunger)}%)",
                        f"üíÄ Pet is too hungry. Feed it first (hunger: {int(pet.hunger)}%)",
                    ),
                )
                return

            xp_reward = pet.play()

            if xp_reward > 0:
                total_reward = max(0, xp_reward + max(0, bonus_xp))
                evolved = pet.add_xp(total_reward)
                emoji = pet.get_emoji()
                prefix = f"{minigame_result} " if minigame_result else ""
                bonus_msg = tr(
                    f" (+{bonus_xp} –±–æ–Ω—É—Å)",
                    f" (+{bonus_xp} bonus)",
                ) if bonus_xp > 0 else ""

                if evolved:
                    bulletin_safe(
                        "success",
                        tr(
                            f"{prefix}üéÆ –ü–æ–∏–≥—Ä–∞–ª. {emoji} –≠–≤–æ–ª—é—Ü–∏—è: +{total_reward} XP{bonus_msg}",
                            f"{prefix}üéÆ Played. {emoji} Evolution: +{total_reward} XP{bonus_msg}",
                        ),
                    )
                else:
                    mood_emoji = "üòä" if pet.mood >= MOOD_HIGH_THRESHOLD else "üôÇ"
                    bulletin_safe(
                        "success",
                        tr(
                            f"{prefix}{mood_emoji} –ü–æ–∏–≥—Ä–∞–ª. {emoji} +{total_reward} XP{bonus_msg} | –ù–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ: {int(pet.mood)}%",
                            f"{prefix}{mood_emoji} Played. {emoji} +{total_reward} XP{bonus_msg} | Mood: {int(pet.mood)}%",
                        ),
                    )

                self.saveSoon()
                self.runAsync(self.syncPet, chat_id, pet, True)
            else:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ —Ö–æ—á–µ—Ç –∏–≥—Ä–∞—Ç—å", "Pet doesn't want to play"))

    def startStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"startStreak:{chat_id}", 1.0):
            return
        if not self.isChatAllowed(chat_id):
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Streak isn't available in this chat"))
            return

        if chat_id in self.streak_enabled_chats:
            bulletin_safe("info", tr("–°—Ç—Ä–∏–∫ —É–∂–µ –≤–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Streak is already on in this chat"))
            return

        existing = self.getStreak(chat_id)
        if existing and existing.is_dead:
            bulletin_safe(
                "info",
                tr(
                    "–°—Ç—Ä–∏–∫ —É–º–µ—Ä ‚Äî –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ –∏–ª–∏ —Å–±—Ä–æ—Å—å –µ–≥–æ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ",
                    "Streak is dead ‚Äî restore it or reset to start over",
                ),
            )
            return

        sync_manager = self.getSyncMgr()

        def dostartStreak():
            try:
                server_data = None
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
                    if my_user_id and my_user_id > 0:
                        try:
                            server_data = sync_manager.get_streak_from_server(
                                my_user_id, chat_id
                            )
                        except Exception as e:
                            self.log(f"WSP: failed to check server for streak: {e}")

                def finish_on_ui():
                    if (
                        server_data
                        and not server_data.get("deleted", False)
                        and server_data.get("count", 0) > 0
                    ):
                        self.log(
                            f"WSP: found existing streak on server for {chat_id}, loading..."
                        )
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)
                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            streak.apply_sync_data(server_data, source="server")
                            self.setSyncedHash(
                                chat_id, streak_data=streak.get_sync_data()
                            )
                            self.saveSoon()
                            bulletin_safe(
                                "success",
                                tr(
                                    f"üî• –°—Ç—Ä–∏–∫ –∑–∞–≥—Ä—É–∂–µ–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞: {formatDaysRu(server_data.get('count', 0))}",
                                    f"üî• Streak loaded from server: {formatDaysEn(server_data.get('count', 0))}",
                                ),
                            )
                            self.log(
                                f"WSP: streak loaded from server for {chat_id}, count={server_data.get('count')}"
                            )
                    else:
                        self.log(f"WSP: creating new streak for {chat_id}")
                        with self.data_lock:
                            self.streak_enabled_chats.add(chat_id)
                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            self.resetStreakForStart(streak)
                        self.saveSoon()
                        self.log(f"WSP: streak created and enabled for chat {chat_id}")
                        bulletin_safe(
                            "success",
                            tr(
                                "üî• –°—Ç—Ä–∏–∫ –≤–∫–ª—é—á–µ–Ω. –ü–∏—à–∏ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Å–µ—Ä–∏—é",
                                "üî• Streak is on. Write every day to keep it going",
                            ),
                        )
                        if streak:
                            self.runAsync(self.syncStreak, chat_id, streak, True)

                run_on_ui_thread(finish_on_ui)
            except Exception as e:
                self.log(f"WSP: error starting streak: {e}")

        self.runAsync(dostartStreak)

    def resetStreakForStart(self, streak):
        streak.count = 0
        streak.last_date = None
        streak.first_date = None
        streak.deleted = False
        streak.warning_since = None
        streak.dead_since = None
        streak.dead_count = 0
        streak.last_message_time = time.time()
        streak.last_sync_timestamp = time.time()

    def stopStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"stopStreak:{chat_id}", 1.0):
            return
        if chat_id not in self.streak_enabled_chats:
            bulletin_safe("info", tr("–°—Ç—Ä–∏–∫ –≤ —ç—Ç–æ–º —á–∞—Ç–µ –≤—ã–∫–ª—é—á–µ–Ω", "Streak is off in this chat"))
            return

        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        with self.data_lock:
            self.streak_enabled_chats.discard(chat_id)
            if streak:
                self.markStreakDeleted(streak, update_sync_ts=True)
        self.saveSoon()

        if streak:
            self.runAsync(self.syncStreak, chat_id, streak, True)

        bulletin_safe("success", tr("–°—Ç—Ä–∏–∫ –æ—Ç–∫–ª—é—á–µ–Ω –∏ —Å–±—Ä–æ—à–µ–Ω", "Streak disabled and reset"))

    def restoreStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"restoreStreak:{chat_id}", 1.0):
            return
        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        if not streak:
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", "Streak not found"))
            return

        if not streak.is_dead:
            bulletin_safe("info", tr("–°—Ç—Ä–∏–∫ –∂–∏–≤, –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ", "Streak is active; no restore needed"))
            return

        if not streak.can_restore:
            if streak.restore_time_left <= 0:
                bulletin_safe("error", tr("–û–∫–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏—Å—Ç–µ–∫–ª–æ", "Restore window expired"))
            else:
                bulletin_safe("error", tr("–õ–∏–º–∏—Ç –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–π –≤ —ç—Ç–æ–º –º–µ—Å—è—Ü–µ –∏—Å—á–µ—Ä–ø–∞–Ω", "Monthly restore limit reached"))
            return

        pet_to_sync = None
        with self.data_lock:
            if streak.restore():
                self.log(f"WSP: streak restored for {chat_id}, count={streak.count}")
                pet = self.pets.get(chat_id)
                if not pet:
                    pet = Pet(chat_id, plugin_ref=self)
                    self.pets[chat_id] = pet
                    self.log(f"WSP: created new pet for {chat_id} after streak restore")
                if pet.deleted:
                    pet.deleted = False
                    self.log(f"WSP: pet also restored for {chat_id}")
                pet.last_sync_timestamp = time.time()
                self.pet_enabled_chats.add(chat_id)
                pet_to_sync = pet
            else:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∏–∫", "Couldn't restore streak"))
                return

        self.saveSoon()
        self.runAsync(self.syncStreak, chat_id, streak, True)
        if pet_to_sync:
            self.runAsync(self.syncPet, chat_id, pet_to_sync, True)

        bulletin_safe(
            "success",
            tr(
                f"üî• –°—Ç—Ä–∏–∫ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º: {formatDaysRu(streak.count)}",
                f"üî• Streak restored. Continue: {formatDaysEn(streak.count)}",
            ),
        )

    def restartDeadStreak(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"resetStreak:{chat_id}", 1.0):
            return
        streak_key = self.getStreakKey(chat_id)
        streak = self.streaks.get(streak_key)

        if not streak:
            bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", "Streak not found"))
            return

        with self.data_lock:
            streak.count = 0
            streak.last_date = None
            streak.first_date = None
            streak.deleted = False
            streak.dead_since = None
            streak.dead_count = 0
            streak.warning_since = None
            streak.last_sync_timestamp = time.time()
            self.log(f"WSP: dead streak reset for {chat_id}, ready for fresh start")

        self.saveSoon()
        self.runAsync(self.syncStreak, chat_id, streak, True)

        bulletin_safe(
            "success",
            tr(
                "–°—Ç—Ä–∏–∫ —Å–±—Ä–æ—à–µ–Ω. –û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ",
                "Streak reset. Send a message to start again",
            ),
        )

    def startPet(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"startPet:{chat_id}", 1.0):
            return
        if not self.needPetChat(chat_id):
            return

        if chat_id in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü —É–∂–µ –≤–∫–ª—é—á–µ–Ω –≤ —ç—Ç–æ–º —á–∞—Ç–µ", "Pet is already on in this chat"))
            return

        sync_manager = self.getSyncMgr()

        def dostartPet():
            try:
                server_data = None
                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
                    if my_user_id and my_user_id > 0:
                        try:
                            user1_id, user2_id = self.getSortedIds(chat_id)
                            server_data = sync_manager.get_pet_from_server(user1_id, user2_id)
                        except Exception as e:
                            self.log(f"WSP: failed to check server for pet: {e}")

                def finish_on_ui():
                    if server_data and not server_data.get("deleted", False):
                        self.log(
                            f"WSP: found existing pet on server for {chat_id}, loading..."
                        )
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)
                        pet = self.getOrCreatePet(chat_id)
                        pet.apply_sync_data(server_data, source="server")
                        self.setSyncedHash(
                            chat_id, pet_data=pet.get_sync_data()
                        )
                        self.saveSoon()

                        stage = server_data.get("stage", 1)
                        stage_idx = min(stage - 1, len(SERVER_PET_STAGE_EMOJIS) - 1)
                        stage_emoji = SERVER_PET_STAGE_EMOJIS[stage_idx]
                        bulletin_safe(
                            "success",
                            tr(
                                f"üêæ –ü–∏—Ç–æ–º–µ—Ü –∑–∞–≥—Ä—É–∂–µ–Ω —Å —Å–µ—Ä–≤–µ—Ä–∞: {stage_emoji} —É—Ä.{server_data.get('stage')} (XP: {server_data.get('xp')})",
                                f"üêæ Pet loaded from server: {stage_emoji} Lv.{server_data.get('stage')} (XP: {server_data.get('xp')})",
                            ),
                        )
                        self.log(
                            f"WSP: pet loaded from server for {chat_id}, xp={server_data.get('xp')}, stage={server_data.get('stage')}"
                        )
                    else:
                        self.log(f"WSP: creating new pet for {chat_id}")
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)
                            if chat_id in self.pets:
                                old_pet = self.pets[chat_id]
                                if hasattr(old_pet, "cleanup"):
                                    try:
                                        old_pet.cleanup()
                                    except Exception:
                                        pass
                                del self.pets[chat_id]
                        pet = self.getOrCreatePet(chat_id)
                        self.saveSoon()
                        self.log(f"WSP: pet created and enabled for chat {chat_id}")
                        bulletin_safe(
                            "success",
                            tr(
                                "üêæ –ü–∏—Ç–æ–º–µ—Ü —Å–æ–∑–¥–∞–Ω. –û—Ç–ø—Ä–∞–≤—å —Å–æ–æ–±—â–µ–Ω–∏–µ, —á—Ç–æ–±—ã –æ–Ω –Ω–∞—á–∞–ª —Ä–∞—Å—Ç–∏",
                                "üêæ Pet created. Send a message to start growing",
                            ),
                        )
                        self.runAsync(self.syncPet, chat_id, pet, True)

                run_on_ui_thread(finish_on_ui)
            except Exception as e:
                self.log(f"WSP: error starting pet: {e}")

        self.runAsync(dostartPet)

    def revivePet(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"revivePet:{chat_id}", 1.0):
            return
        if not self.needPetChat(chat_id):
            return

        streak = self.getStreak(chat_id)
        if streak and streak.is_dead:
            bulletin_safe("error", tr("–°–Ω–∞—á–∞–ª–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏ —Å—Ç—Ä–∏–∫", "Restore the streak first"))
            return

        with self.data_lock:
            now = time.time()
            last_revive = self.pet_revive_times.get(chat_id, 0)
            if last_revive and now - last_revive < REVIVE_COOLDOWN_SECONDS:
                remaining = int((REVIVE_COOLDOWN_SECONDS - (now - last_revive)) / SECONDS_PER_MINUTE)
                bulletin_safe(
                    "info",
                    tr(
                        f"‚è≥ –í–æ—Å–∫—Ä–µ—à–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ —á–µ—Ä–µ–∑ {remaining} –º–∏–Ω",
                        f"‚è≥ Revive available in {remaining} min",
                    ),
                )
                return

            pet = self.pets.get(chat_id)
            if not pet:
                pet = Pet(chat_id, plugin_ref=self)
                self.pets[chat_id] = pet
            elif not pet.deleted:
                bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü —É–∂–µ –∂–∏–≤", "Pet is already alive"))
                return
            if pet.deleted:
                if pet.xp < REVIVE_XP_COST:
                    bulletin_safe(
                        "error",
                        tr(
                            f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ XP –¥–ª—è –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏—è ({pet.xp}/{REVIVE_XP_COST})",
                            f"Not enough XP to revive ({pet.xp}/{REVIVE_XP_COST})",
                        ),
                    )
                    return
                pet.xp = max(0, pet.xp - REVIVE_XP_COST)
            pet.deleted = False
            pet.last_sync_timestamp = now
            self.pet_enabled_chats.add(chat_id)
            self.pet_revive_times[chat_id] = now

        self.saveSoon()
        self.runAsync(self.syncPet, chat_id, pet, True)
        bulletin_safe("success", tr("‚ú® –ü–∏—Ç–æ–º–µ—Ü –≤–æ—Å–∫—Ä–µ—Å", "‚ú® Pet revived"))

    def stopPet(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"stopPet:{chat_id}", 1.0):
            return
        if chat_id not in self.pet_enabled_chats:
            bulletin_safe("info", tr("–ü–∏—Ç–æ–º–µ—Ü –≤ —ç—Ç–æ–º —á–∞—Ç–µ –≤—ã–∫–ª—é—á–µ–Ω", "Pet is off in this chat"))
            return

        with self.data_lock:
            self.pet_enabled_chats.discard(chat_id)
            if chat_id in self.pets:
                old_pet = self.pets[chat_id]
                if hasattr(old_pet, "cleanup"):
                    try:
                        old_pet.cleanup()
                    except Exception:
                        pass
                del self.pets[chat_id]
        self.saveSoon()

        bulletin_safe("success", tr("–ü–∏—Ç–æ–º–µ—Ü –æ—Ç–∫–ª—é—á–µ–Ω", "Pet disabled"))

    def renamePet(self, chat_id, new_name):
        chat_id = self.normChat(chat_id)
        with self.data_lock:
            pet = self.pets.get(chat_id)
            if not pet:
                bulletin_safe("error", tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ –Ω–∞–π–¥–µ–Ω", "Pet not found"))
                return

            old_name = pet.name
            pet.name = new_name
            pet.last_sync_timestamp = time.time()

        self.saveSoon()

        bulletin_safe(
            "success",
            tr(
                f"–ü–∏—Ç–æ–º–µ—Ü –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω: {old_name} ‚Üí {new_name}",
                f"Pet renamed: {old_name} ‚Üí {new_name}",
            ),
        )

        self.runAsync(self.syncPet, chat_id, pet, True)

    def kickPet(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"kickPet:{chat_id}", 1.0):
            return
        with self.data_lock:
            pet = self.pets.get(chat_id)
            self.pet_enabled_chats.discard(chat_id)
            if pet:
                self.markPetDeleted(pet, update_sync_ts=True)
        self.saveSoon()

        if pet:
            self.runAsync(self.syncPet, chat_id, pet, True)

        bulletin_safe("success", tr("–ü–∏—Ç–æ–º–µ—Ü —É–¥–∞–ª–µ–Ω", "Pet deleted"))

    def checkServerStatus(self, view=None):

        def check_in_thread():
            try:
                sync_manager = self.getSyncMgr()
                server_url = sync_manager.server_url
                current_mode = SYNC_MODE_NAMES.get(
                    sync_manager.mode, str(sync_manager.mode)
                )
                start_time = time.time()
                is_healthy = sync_manager.checkServerHealth()
                response_time = int((time.time() - start_time) * 1000)
                def show_result():
                    try:
                        activity = self.getActivity()
                        if not activity:
                            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                            return

                        if is_healthy:
                            title = tr("–°–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω", "Server is online")
                            message = (
                                tr("–°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ–Ω–ª–∞–π–Ω\n", "Status: online\n")
                                + f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {current_mode}\n"
                                + f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {response_time}ms"
                            )
                        else:
                            title = tr("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Server unavailable")
                            message = (
                                tr("–°–æ—Å—Ç–æ—è–Ω–∏–µ: –æ—Ñ–ª–∞–π–Ω\n", "Status: offline\n")
                                + f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {current_mode}\n"
                                + f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {response_time}ms"
                            )
                            message += "\n" + tr(
                                "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å VPN/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                                "Tip: check VPN/proxy or try later",
                            )

                        self.showAlert(
                            activity,
                            title,
                            message,
                            "OK",
                            lambda b, w: b.dismiss(),
                        )
                    except Exception as e:
                        self.log(f"WSP: error showing server status: {e}")
                        bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç", "Couldn't show result"))

                run_on_ui_thread(show_result)

            except Exception as e:
                self.log(f"WSP: error checking server: {e}")
                run_on_ui_thread(
                    lambda: bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}", f"Check failed: {e}"))
                )

        bulletin_safe("info", tr("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...", "Checking server..."))
        self.runAsync(check_in_thread)

    def resetAuth(self, view=None):
        try:
            activity = self.getActivity()
            if not activity:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                return

            title = tr("–°–±—Ä–æ—Å–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é", "Reset auth")
            message = tr(
                "–°–±—Ä–æ—Å–∏—Ç—å install_id –∏ —Ç–æ–∫–µ–Ω?\n\n"
                "–≠—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö 401/403.\n"
                "–ù–æ–≤—ã–π —Ç–æ–∫–µ–Ω –±—É–¥–µ—Ç –ø–æ–ª—É—á–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –º–∏–Ω—É—Ç—É).",
                "Reset install_id and token?\n\n"
                "Helps with 401/403 errors.\n"
                "A new token will be requested automatically (may take a minute).",
            )
            self.showAlert(
                activity,
                title,
                message,
                tr("–°–±—Ä–æ—Å–∏—Ç—å", "Reset"),
                lambda b, w: self.doResetAuth(b),
                tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
                lambda b, w: b.dismiss(),
            )
        except Exception as e:
            self.log(f"WSP: error showing auth reset: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))

    def doResetAuth(self, builder=None):
        try:
            if builder:
                builder.dismiss()
        except Exception as e:
            self.log(f"WSP: auth reset dismiss error: {e}")

        try:
            self.set_setting("install_id", "")
        except Exception as e:
            self.log(f"WSP: failed to clear install_id: {e}")

        try:
            self.set_setting("devkey", "")
        except Exception as e:
            self.log(f"WSP: failed to clear devkey: {e}")

        try:
            new_id = self.getInstallId()
            sync_manager = self.getSyncMgr()
            if sync_manager:
                sync_manager.setInstallId(new_id)
                sync_manager.setDevKey(self.getDevKey())
                sync_manager.token = None
                sync_manager.tokenExp = 0
                sync_manager.last_error = None
        except Exception as e:
            self.log(f"WSP: failed to reset auth state: {e}")

        bulletin_safe(
            "success",
            tr(
                "–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞. –û—Ç–∫—Ä–æ–π —á–∞—Ç –¥–ª—è –Ω–æ–≤–æ–π —Å–∏–Ω—Ö—Ä—ã",
                "Auth reset. Open a chat to sync",
            ),
        )

    def showResetConfirm(self):
        try:
            activity = self.getActivity()
            if not activity:
                bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))
                return

            title = tr("–°–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö", "Data reset")
            message = tr(
                "–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ?\n\n"
                "‚Ä¢ –ü–∏—Ç–æ–º—Ü—ã –±—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã\n"
                "‚Ä¢ –°—Ç—Ä–∏–∫–∏ –±—É–¥—É—Ç —Å–±—Ä–æ—à–µ–Ω—ã\n"
                "‚Ä¢ –î–∞–Ω–Ω—ã–µ —É–¥–∞–ª—è—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω–æ –∏ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ\n\n"
                "–î–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
                "Delete all data?\n\n"
                "‚Ä¢ Pets will be removed\n"
                "‚Ä¢ Streaks will be reset\n"
                "‚Ä¢ Data will be removed locally and on the server\n\n"
                "This action can't be undone.",
            )
            self.showAlert(
                activity,
                title,
                message,
                tr("–£–¥–∞–ª–∏—Ç—å", "Delete"),
                lambda b, w: self.doReset(b),
                tr("–û—Ç–º–µ–Ω–∞", "Cancel"),
                lambda b, w: b.dismiss(),
            )
        except Exception as e:
            self.log(f"WSP: error showing reset confirmation: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –æ–∫–Ω–æ", "Couldn't open dialog"))

    def doReset(self, builder):
        try:
            builder.dismiss()
        except Exception as e:
            self.log(f"WSP: builder dismiss error: {e}")

        self.resetAllData_internal()

    def resetAllData(self, view=None):
        self.showResetConfirm()

    def clearCache(self, view=None):
        try:
            cleared = 0
            sync_manager = self.getSyncMgr()
            if sync_manager and hasattr(sync_manager, "cache"):
                try:
                    lock = getattr(sync_manager, "_cache_lock", None)
                    if lock:
                        with lock:
                            cleared = len(sync_manager.cache)
                            sync_manager.cache.clear()
                    else:
                        cleared = len(sync_manager.cache)
                        sync_manager.cache.clear()
                except Exception as e:
                    self.log(f"WSP: cache clear error: {e}")

            try:
                UI._cache.clear()
            except Exception:
                pass

            try:
                self._sync_manager_cache_time = 0
            except Exception:
                pass

            try:
                self.last_auto_sync.clear()
                self.last_messages.clear()
            except Exception:
                pass

            bulletin_safe(
                "success",
                tr(
                    f"–ö—ç—à –æ—á–∏—â–µ–Ω ({cleared} –∑–∞–ø–∏—Å–µ–π)",
                    f"Cache cleared ({cleared} entries)",
                ),
            )
        except Exception as e:
            self.log(f"WSP: error clearing cache: {e}")
            bulletin_safe("error", tr("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –∫—ç—à", "Couldn't clear cache"))

    def resetAllData_internal(self):
        try:
            self.log("WSP: resetAllData_internal called!")
            bulletin_safe("info", tr("–°–±—Ä–æ—Å –¥–∞–Ω–Ω—ã—Ö...", "Resetting data..."))

            sync_manager = self.getSyncMgr()
            my_user_id = self.getMyId()

            with self.data_lock:
                pet_count = len(self.pets)
                streak_count = len(self.streaks)

                if sync_manager.mode in [
                    StreakSyncManager.MODE_SERVER,
                    StreakSyncManager.MODE_AUTO,
                ]:
                    if my_user_id and my_user_id > 0:
                        for chat_id, pet in self.pets.items():
                            try:
                                self.markPetDeleted(pet, update_sync_ts=True)
                                self.sendPetSync(chat_id, pet)
                            except Exception as e:
                                self.log(
                                    f"WSP: failed to delete pet {chat_id} on server: {e}"
                                )

                        for chat_id, streak in self.streaks.items():
                            try:
                                self.markStreakDeleted(
                                    streak, update_sync_ts=True
                                )
                                self.sendSyncMsg(chat_id, streak)
                            except Exception as e:
                                self.log(
                                    f"WSP: failed to delete streak {chat_id} on server: {e}"
                                )

                        self.log(
                            "WSP: sent delete sync to server for all pets and streaks"
                        )

                for pet in self.pets.values():
                    if hasattr(pet, "cleanup"):
                        try:
                            pet.cleanup()
                        except Exception:
                            pass
                self.pets.clear()
                self.streaks.clear()
                self.last_messages.clear()
                self.streak_enabled_chats.clear()
                self.pet_enabled_chats.clear()
                self.p2pKeys.clear()

            self.saveData()

            self.log(
                f"WSP: reset completed - removed {pet_count} pets, {streak_count} streaks"
            )
            bulletin_safe("success", 
                tr(
                    f"‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã: {pet_count} –ø–∏—Ç–æ–º—Ü–µ–≤, {streak_count} —Å—Ç—Ä–∏–∫–æ–≤",
                    f"‚úÖ All data removed: {pet_count} pets, {streak_count} streaks",
                )
            )

        except Exception as e:
            self.log(f"WSP: error resetting data: {e}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ —Å–±—Ä–æ—Å–∞ –¥–∞–Ω–Ω—ã—Ö: {e}", f"Reset error: {e}"))

    def showStreakMenu(self, data):
        try:
            self.log(f"WSP: showStreakMenu called with data={data}")
            chat_id = self.extractChatId(data)
            chat_id = self.normChat(chat_id)
            self.log(f"WSP: chat_id={chat_id}")

            if not self.isPrivateChat(chat_id):
                self.log("WSP: not a private chat")
                bulletin_safe("error", tr("–°—Ç—Ä–∏–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–Ω—ã—Ö —á–∞—Ç–∞—Ö", "Streak works only in private chats"))
                return

            streak_key = self.getStreakKey(chat_id)
            streak = None
            with self.data_lock:
                streak = self.streaks.get(streak_key)
                if streak and not streak.deleted:
                    try:
                        changed = streak.check_and_reset_if_expired(allow_warning=True)
                        if changed:
                            if streak.is_dead:
                                self.onStreakDied(chat_id)
                            self.saveSoon()
                            self.runAsync(
                                self.syncStreak, chat_id, streak, True
                            )
                    except Exception as e:
                        self.log(f"WSP: error updating streak state before menu: {e}")

            activity = self.getActivity("WSP:")
            if not activity:
                return

            sheet = StreakMenuBottomSheet(activity, self, chat_id)
            sheet.show()
        except Exception as e:
            self.log(f"WSP: showStreakMenu ERROR: {e}")

            self.log(f"WSP: traceback: {traceback.format_exc()}")

    def showWspMenu(self, data):
        self.showStreakMenu(data)

    def showStreakInfo(self, chat_id):
        self.showStreakMenu({"chat_id": chat_id})

    def showEvolution(self, pet):
        try:
            def show_fallback():
                emoji = pet.get_emoji()
                stage_name = pet.get_stage_name()
                bulletin_safe(
                    "success",
                    tr(
                        f"üéâ {emoji} –≠–≤–æ–ª—é—Ü–∏—è: {pet.name} —Å—Ç–∞–ª {stage_name} (—É—Ä. {pet.stage})",
                        f"üéâ {emoji} Evolution: {pet.name} became {stage_name} (Lv. {pet.stage})",
                    ),
                )

            activity = self.getActivity()
            if not activity:
                show_fallback()
                return

            sheet = EvolutionBottomSheet(activity, pet)
            sheet.show()
        except Exception as e:
            self.log(f"WSP: showEvolution error: {e}")
            show_fallback()

    def syncFromServer(self, chat_id, skip_throttling=True):
        self.checkServerData(chat_id, skip_throttling=skip_throttling)

    def checkServerData(self, chat_id, skip_throttling=False):

        try:
            chat_id = self.normChat(chat_id)
            now = time.time()
            updated_any = False
            chat_id_str = str(chat_id)
            if not skip_throttling:
                if not self.shouldCheckServer(chat_id, SYNC_SERVER_CHECK_COOLDOWN):
                    return

            sync_manager = self.getSyncMgr()

            if sync_manager.mode not in [
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ]:
                return

            my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
            if not my_user_id or my_user_id <= 0:
                return
            if not self.getP2pKey(chat_id):
                try:
                    user1_id, user2_id = self.getSortedIds(chat_id)
                    key = sync_manager.getP2pSrv(user1_id, user2_id)
                    if key:
                        self.setP2pKey(chat_id, key)
                        self.saveSoon()
                except Exception:
                    pass

            try:
                user1_id, user2_id = self.getSortedIds(chat_id)
                server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)

                if server_pet:
                    if server_pet.get("deleted", False):
                        local_pet = None
                        apply_delete = True
                        with self.data_lock:
                            local_pet = self.pets.get(chat_id)
                            if (
                                chat_id in self.pet_enabled_chats
                                and local_pet
                                and not local_pet.deleted
                            ):
                                apply_delete = self.shouldApplyRemoteDelete(
                                    local_pet, server_pet, "server"
                                )

                        if not apply_delete and local_pet:
                            self.logSyncDecision(
                                "pet",
                                chat_id,
                                "server",
                                "keep_local",
                                reason="remote_deleted",
                                local_ts=local_pet.get_sync_data().get("timestamp"),
                                remote_ts=server_pet.get("timestamp"),
                            )
                            self.log(
                                f"WSP: server pet deleted for chat {chat_id}, keeping local and pushing"
                            )
                            self.runAsync(
                                self.syncPet, chat_id, local_pet, True
                            )
                            updated_any = True
                        else:
                            self.logSyncDecision(
                                "pet",
                                chat_id,
                                "server",
                                "accept_delete",
                                reason="remote_deleted",
                                local_ts=(local_pet.get_sync_data().get("timestamp") if local_pet else None),
                                remote_ts=server_pet.get("timestamp"),
                            )
                            self.log(
                                f"WSP: server pet has deleted=True for chat {chat_id}, deactivating"
                            )
                            with self.data_lock:
                                self.pet_enabled_chats.discard(chat_id)
                                if chat_id in self.pets:
                                    self.markPetDeleted(
                                        self.pets[chat_id],
                                        update_sync_ts=True,
                                    )
                                    self.saveDataUnsafe()
                            updated_any = True
                    elif chat_id not in self.pet_enabled_chats:
                        self.log(
                            f"WSP: found pet on server for inactive chat {chat_id}, auto-enabling"
                        )
                        with self.data_lock:
                            self.pet_enabled_chats.add(chat_id)
                            pet = self.getOrCreatePet(chat_id)
                            pet.apply_sync_data(server_pet, source="server")
                            self.setSyncedHash(
                                chat_id, pet_data=pet.get_sync_data()
                            )
                            self.saveDataUnsafe()
                            self.log(
                                f"WSP: pet auto-enabled from server for {chat_id}, xp={server_pet.get('xp')}, stage={server_pet.get('stage')}, name={server_pet.get('name', 'unknown')}"
                            )
                        updated_any = True
                    else:
                        with self.data_lock:
                            pet = self.pets.get(chat_id)
                            if not pet:
                                pet = self.getOrCreatePet(chat_id)

                            result = self.mergeRemoteSync(
                                "pet",
                                chat_id,
                                pet,
                                server_pet,
                                "server",
                                update_hash=True,
                            )
                            if result["applied"]:
                                self.saveDataUnsafe()
                                self.log(
                                    f"WSP: synced pet from server for {chat_id}, xp={server_pet.get('xp')}, stage={server_pet.get('stage')}, name={server_pet.get('name', 'unknown')}"
                                )
                                updated_any = True
            except Exception as e:
                self.log(f"WSP: error checking pet on server: {e}")

            try:
                server_streak = sync_manager.get_streak_from_server(my_user_id, chat_id)

                if server_streak:
                    if server_streak.get("deleted", False):
                        local_streak = None
                        apply_delete = True
                        with self.data_lock:
                            streak_key = self.getStreakKey(chat_id)
                            local_streak = self.streaks.get(streak_key)
                            if (
                                chat_id in self.streak_enabled_chats
                                and local_streak
                                and not local_streak.deleted
                            ):
                                apply_delete = self.shouldApplyRemoteDelete(
                                    local_streak, server_streak, "server"
                                )

                        if not apply_delete and local_streak:
                            self.logSyncDecision(
                                "streak",
                                chat_id,
                                "server",
                                "keep_local",
                                reason="remote_deleted",
                                local_ts=local_streak.get_sync_data().get("timestamp"),
                                remote_ts=server_streak.get("timestamp"),
                            )
                            self.log(
                                f"WSP: server streak deleted for chat {chat_id}, keeping local and pushing"
                            )
                            self.runAsync(
                                self.syncStreak, chat_id, local_streak, True
                            )
                            updated_any = True
                        else:
                            self.logSyncDecision(
                                "streak",
                                chat_id,
                                "server",
                                "accept_delete",
                                reason="remote_deleted",
                                local_ts=(local_streak.get_sync_data().get("timestamp") if local_streak else None),
                                remote_ts=server_streak.get("timestamp"),
                            )
                            self.log(
                                f"WSP: server streak has deleted=True for chat {chat_id}, resetting streak to 0"
                            )
                            with self.data_lock:
                                self.streak_enabled_chats.discard(chat_id)
                                streak_key = self.getStreakKey(chat_id)
                                if streak_key in self.streaks:
                                    streak = self.streaks[streak_key]
                                    self.markStreakDeleted(
                                        streak, update_sync_ts=True
                                    )
                                    self.saveDataUnsafe()
                            updated_any = True
                    elif server_streak.get("count", 0) > 0:
                        if chat_id not in self.streak_enabled_chats:
                            self.log(
                                f"WSP: found streak on server for inactive chat {chat_id}, auto-enabling"
                            )
                            with self.data_lock:
                                self.streak_enabled_chats.add(chat_id)

                        with self.data_lock:
                            streak_key = self.getStreakKey(chat_id)
                            streak = self.streaks.get(streak_key)
                            if not streak:
                                streak = self.getOrCreateStreak(chat_id)

                            if streak:
                                result = self.mergeRemoteSync(
                                    "streak",
                                    chat_id,
                                    streak,
                                    server_streak,
                                    "server",
                                    update_hash=True,
                                )
                                if result["applied"]:
                                    self.saveDataUnsafe()
                                    self.log(
                                        f"WSP: synced streak from server for {chat_id}, count={server_streak.get('count')}"
                                    )
                                    updated_any = True
            except Exception as e:
                self.log(f"WSP: error checking streak on server: {e}")

            if updated_any:
                self.last_auto_sync[chat_id_str] = now
                self.last_server_check[chat_id] = now
                self.last_global_server_check = now
        except Exception as e:
            self.log(f"WSP: checkServerData error: {e}")

    def checkSyncStatus(self, chat_id):
        try:
            chat_id = self.normChat(chat_id)
            sync_manager = self.getSyncMgr()
            my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))

            lines = [tr("üîç –°—Ç–∞—Ç—É—Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏:", "üîç Sync status:"), ""]
            def add_blank():
                lines.append("")

            mode_name = SYNC_MODE_NAMES.get(sync_manager.mode, sync_manager.mode)
            lines.append(tr(f"üì° –†–µ–∂–∏–º: {mode_name}", f"üì° Mode: {mode_name}"))

            if my_user_id and my_user_id > 0:
                lines.append(tr(f"‚úÖ ID: {my_user_id}", f"‚úÖ ID: {my_user_id}"))
            else:
                lines.append(
                    tr(
                        f"‚ùå ID –Ω–µ –ø–æ–ª—É—á–µ–Ω ({my_user_id})",
                        f"‚ùå ID not available ({my_user_id})",
                    )
                )
                bulletin_safe("error", "\n".join(lines))
                return

            if sync_manager.mode in [
                StreakSyncManager.MODE_SERVER,
                StreakSyncManager.MODE_AUTO,
            ]:
                add_blank()
                lines.append(tr("üåê –°–µ—Ä–≤–µ—Ä: –æ—Å–Ω–æ–≤–Ω–æ–π", "üåê Server: default"))

                is_healthy = sync_manager.checkServerHealth()
                if is_healthy:
                    lines.append(tr("‚úÖ –°–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–µ–Ω", "‚úÖ Server available"))
                else:
                    lines.append(tr("‚ùå –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "‚ùå Server unavailable"))

                add_blank()
                server_streak = sync_manager.get_streak_from_server(my_user_id, chat_id)
                if server_streak:
                    count = server_streak.get("count", 0)
                    lines.append(
                        tr(
                            f"üî• –°—Ç—Ä–∏–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: {formatDaysRu(count)}",
                            f"üî• Streak on server: {formatDaysEn(count)}",
                        )
                    )
                else:
                    lines.append(tr("üî• –°—Ç—Ä–∏–∫ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: –Ω–µ –Ω–∞–π–¥–µ–Ω", "üî• Streak on server: not found"))

                user1_id, user2_id = self.getSortedIds(chat_id)
                server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)
                if server_pet:
                    xp = server_pet.get("xp", 0)
                    stage = server_pet.get("stage", 1)
                    lines.append(tr(f"üêæ –ü–∏—Ç–æ–º–µ—Ü –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: —Å—Ç–∞–¥–∏—è {stage}, XP {xp}", f"üêæ Pet on server: stage {stage}, XP {xp}"))
                else:
                    lines.append(tr("üêæ –ü–∏—Ç–æ–º–µ—Ü –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ: –Ω–µ –Ω–∞–π–¥–µ–Ω", "üêæ Pet on server: not found"))

            add_blank()
            lines.append(tr("üíæ –õ–æ–∫–∞–ª—å–Ω–æ:", "üíæ Local:"))

            if chat_id in self.streak_enabled_chats:
                streak = self.streaks.get(self.getStreakKey(chat_id))
                if streak:
                    lines.append(
                        tr(
                            f"üî• –°—Ç—Ä–∏–∫: {formatDaysRu(streak.count)}",
                            f"üî• Streak: {formatDaysEn(streak.count)}",
                        )
                    )
                else:
                    lines.append(tr("üî• –°—Ç—Ä–∏–∫: –≤–∫–ª—é—á–µ–Ω, –Ω–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã", "üî• Streak: enabled but data missing"))
            else:
                lines.append(tr("üî• –°—Ç—Ä–∏–∫: –Ω–µ –≤–∫–ª—é—á–µ–Ω", "üî• Streak: not enabled"))

            if chat_id in self.pets:
                pet = self.pets[chat_id]
                lines.append(tr(f"üêæ –ü–∏—Ç–æ–º–µ—Ü: —Å—Ç–∞–¥–∏—è {pet.stage}, XP {pet.xp}", f"üêæ Pet: stage {pet.stage}, XP {pet.xp}"))
            else:
                lines.append(tr("üêæ –ü–∏—Ç–æ–º–µ—Ü: –Ω–µ —Å–æ–∑–¥–∞–Ω", "üêæ Pet: not created"))

            bulletin_safe("info", "\n".join(lines))

        except Exception as e:
            self.log(f"WSP: checkSyncStatus error: {e}")

            self.log(f"WSP: check_sync_status traceback: {traceback.format_exc()}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏: {e}", f"Check failed: {e}"))

    def forceSyncNow(self, chat_id):
        chat_id = self.normChat(chat_id)
        if self.guardAction(f"syncNow:{chat_id}", 1.0):
            return
        try:
            sync_manager = self.getSyncMgr()

            if sync_manager.mode == StreakSyncManager.MODE_P2P:
                bulletin_safe(
                    "info",
                    tr(
                        "–í P2P –Ω–µ—Ç –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏",
                        "P2P mode doesn't support forced sync",
                    ),
                )
                return

            my_user_id = self.getMyId(acct=self.getAcct(chat_id=chat_id))
            if not my_user_id or my_user_id <= 0:
                bulletin_safe("error", tr(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID: {my_user_id}", f"Failed to get ID: {my_user_id}"))
                return

            bulletin_safe("info", tr("‚è≥ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è...", "‚è≥ Syncing..."))

            def do_sync():
                if not sync_manager.checkServerHealth():
                    self.recordSyncStatus(chat_id, "force:server", False, "server_unavailable")
                    run_on_ui_thread(
                        lambda: bulletin_safe("error", tr("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Server unavailable"))
                    )
                    return
                try:
                    synced_items = []

                    def _append(item):
                        if item:
                            synced_items.append(item)

                    server_streak = sync_manager.get_streak_from_server(
                        my_user_id, chat_id
                    )
                    if server_streak and server_streak.get("count", 0) > 0:
                        with self.data_lock:
                            if chat_id not in self.streak_enabled_chats:
                                self.streak_enabled_chats.add(chat_id)

                        streak = self.getOrCreateStreak(chat_id)
                        if streak:
                            local_data = streak.get_sync_data()
                            result = self.mergeRemoteSync(
                                "streak",
                                chat_id,
                                streak,
                                server_streak,
                                "server",
                                update_hash=True,
                                ignore_local_priority=True,
                            )
                            if result["applied"]:
                                self.recordSyncStatus(chat_id, "force:server", True)
                                _append(
                                    tr(
                                        f"üî• –°—Ç—Ä–∏–∫: {formatDaysRu(server_streak.get('count'))}",
                                        f"üî• Streak: {formatDaysEn(server_streak.get('count'))}",
                                    )
                                )
                            else:
                                success = sync_manager.save_streak_to_server(
                                    my_user_id, chat_id, local_data
                                )
                                self.recordSyncStatus(
                                    chat_id,
                                    "force:server",
                                    bool(success),
                                    None if success else "streak_save_failed",
                                )
                                if success:
                                    self.setSyncedHash(
                                        chat_id, streak_data=local_data
                                    )
                                    _append(
                                        tr(
                                            f"üî• –°—Ç—Ä–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ —Å–µ—Ä–≤–µ—Ä: {formatDaysRu(local_data.get('count'))}",
                                            f"üî• Streak sent to server: {formatDaysEn(local_data.get('count'))}",
                                        )
                                    )
                    else:
                        if chat_id in self.streak_enabled_chats:
                            streak = self.streaks.get(self.getStreakKey(chat_id))
                            if streak:
                                success = sync_manager.save_streak_to_server(
                                    my_user_id, chat_id, streak.get_sync_data()
                                )
                                self.recordSyncStatus(
                                    chat_id,
                                    "force:server",
                                    bool(success),
                                    None if success else "streak_save_failed",
                                )
                                if success:
                                    self.setSyncedHash(
                                        chat_id, streak_data=streak.get_sync_data()
                                    )
                                    _append(
                                        tr(
                                            f"üî• –°—Ç—Ä–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {formatDaysRu(streak.count)}",
                                            f"üî• Streak sent: {formatDaysEn(streak.count)}",
                                        )
                                    )

                    user1_id, user2_id = self.getSortedIds(chat_id)
                    server_pet = sync_manager.get_pet_from_server(user1_id, user2_id)
                    pet = self.getOrCreatePet(chat_id)

                    if server_pet:
                        local_pet_data = pet.get_sync_data()
                        result = self.mergeRemoteSync(
                            "pet",
                            chat_id,
                            pet,
                            server_pet,
                            "server",
                            update_hash=True,
                            ignore_local_priority=True,
                        )
                        if result["applied"]:
                            self.recordSyncStatus(chat_id, "force:server", True)
                            _append(
                                tr(
                                    f"üêæ –ü–∏—Ç–æ–º–µ—Ü –∑–∞–≥—Ä—É–∂–µ–Ω: —Å—Ç–∞–¥–∏—è {server_pet.get('stage')}, XP {server_pet.get('xp')}",
                                    f"üêæ Pet loaded: stage {server_pet.get('stage')}, XP {server_pet.get('xp')}",
                                )
                            )
                        else:
                            success = sync_manager.save_pet_to_server(
                                user1_id, user2_id, local_pet_data
                            )
                            self.recordSyncStatus(
                                chat_id,
                                "force:server",
                                bool(success),
                                None if success else "pet_save_failed",
                            )
                            if success:
                                self.setSyncedHash(
                                    chat_id, pet_data=local_pet_data
                                )
                                _append(
                                    tr(
                                        f"üêæ –ü–∏—Ç–æ–º–µ—Ü –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: —Å—Ç–∞–¥–∏—è {local_pet_data.get('stage')}, XP {local_pet_data.get('xp')}",
                                        f"üêæ Pet sent: stage {local_pet_data.get('stage')}, XP {local_pet_data.get('xp')}",
                                    )
                                )
                    else:
                        success = sync_manager.save_pet_to_server(
                            user1_id, user2_id, pet.get_sync_data()
                        )
                        self.recordSyncStatus(
                            chat_id,
                            "force:server",
                            bool(success),
                            None if success else "pet_save_failed",
                        )
                        if success:
                            self.setSyncedHash(
                                chat_id, pet_data=pet.get_sync_data()
                            )
                            _append(
                                tr(
                                    f"üêæ –ü–∏—Ç–æ–º–µ—Ü –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: —Å—Ç–∞–¥–∏—è {pet.stage}, XP {pet.xp}",
                                    f"üêæ Pet sent: stage {pet.stage}, XP {pet.xp}",
                                )
                            )

                    self.saveData()

                    if synced_items:
                        run_on_ui_thread(
                            lambda: bulletin_safe("success",
                                tr("‚úÖ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n", "‚úÖ Sync complete.\n")
                                + "\n".join(synced_items)
                            )
                        )
                    else:
                        run_on_ui_thread(
                            lambda: bulletin_safe("info",
                                tr("‚ÑπÔ∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏", "‚ÑπÔ∏è No data to sync")
                            )
                        )

                except Exception as e:
                    self.log(f"WSP: force_sync error: {e}")

                    self.log(f"WSP: force_sync traceback: {traceback.format_exc()}")
                    error_msg = str(e)
                    run_on_ui_thread(
                        lambda: bulletin_safe("error",
                            tr(f"–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏: {error_msg}", f"Sync error: {error_msg}")
                        )
                    )

            self.runAsync(do_sync)

        except Exception as e:
            self.log(f"WSP: forceSyncNow error: {e}")

            self.log(f"WSP: force_sync_now traceback: {traceback.format_exc()}")
            bulletin_safe("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def checkServer(self):
        try:
            sync_manager = self.getSyncMgr()

            self.bulletin("info", tr("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...", "Checking server..."))

            def do_check():
                try:
                    t0 = time.time()
                    mode = SYNC_MODE_NAMES.get(
                        sync_manager.mode, sync_manager.mode
                    )
                    is_healthy = sync_manager.checkServerHealth()
                    rt = time.time() - t0

                    if is_healthy:
                        status = tr("–û–Ω–ª–∞–π–Ω", "Online")
                    else:
                        status = tr("–ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Unavailable")

                    message = (
                        f"{tr('–°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–µ—Ä–∞:', 'Server status:')} {status}\n\n"
                        f"{tr('–†–µ–∂–∏–º:', 'Mode:')} {mode}\n"
                        f"{tr('–ó–∞–¥–µ—Ä–∂–∫–∞:', 'Latency:')} {int(rt * 1000)}ms\n\n"
                        f"{tr('–ö—ç—à:', 'Cache:')} {len(sync_manager.cache)} {tr('–∑–∞–ø–∏—Å–µ–π', 'entries')}"
                    )

                    message += tr("\n–ü–æ—Å–ª–µ–¥–Ω—è—è –ø—Ä–æ–≤–µ—Ä–∫–∞: —Ç–æ–ª—å–∫–æ —á—Ç–æ", "\nLast check: just now")

                    self.bulletin(
                        "success" if is_healthy else "error",
                        message,
                        ui_thread=True,
                    )

                except Exception as e:
                    self.log(f"WSP: server health check error: {e}")

                    self.log(f"WSP: health check traceback: {traceback.format_exc()}")
                    self.bulletin(
                        "error",
                        tr(
                            f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–µ—Ä–≤–µ—Ä–∞:\n{str(e)}",
                            f"Server check error:\n{str(e)}",
                        ),
                        ui_thread=True,
                    )

            self.runAsync(do_check)

        except Exception as e:
            self.log(f"WSP: checkServer error: {e}")

            self.log(f"WSP: check_server_health traceback: {traceback.format_exc()}")
            self.bulletin("error", tr(f"–û—à–∏–±–∫–∞: {e}", f"Error: {e}"))

    def saveDataUnsafe(self):
        self.migrateAllPendingStreaks()
        self.cleanupPendingStreaks()
        self.pruneTmpState()
        pets_data = {cid: pet.to_dict() for cid, pet in self.pets.items()}
        streaks_data = {cid: ser.to_dict() for cid, ser in self.streaks.items()}

        errors = []

        try:
            self.set_setting("pets", pets_data)
        except Exception as e:

            errors.append(f"pets: {e}")
            self.log(f"WSP: ERROR saving pets: {e}")
            self.log(f"WSP: save pets traceback: {traceback.format_exc()}")

        try:
            self.set_setting("streaks", streaks_data)
        except Exception as e:

            errors.append(f"streaks: {e}")
            self.log(f"WSP: ERROR saving streaks: {e}")
            self.log(f"WSP: save streaks traceback: {traceback.format_exc()}")

        try:
            self.set_setting("last_msgs", self.last_messages)
        except Exception as e:
            errors.append(f"last_msgs: {e}")
            self.log(f"WSP: ERROR saving last_msgs: {e}")

        try:
            self.set_setting("streak_enabled", list(self.streak_enabled_chats))
        except Exception as e:
            errors.append(f"streak_enabled: {e}")
            self.log(f"WSP: ERROR saving streak_enabled: {e}")

        try:
            self.set_setting("pet_enabled", list(self.pet_enabled_chats))
        except Exception as e:
            errors.append(f"pet_enabled: {e}")
            self.log(f"WSP: ERROR saving pet_enabled: {e}")

        try:
            self.set_setting("pet_revive_times", self.pet_revive_times)
        except Exception as e:
            errors.append(f"pet_revive_times: {e}")
            self.log(f"WSP: ERROR saving pet_revive_times: {e}")

        positions_to_remove = []
        for pos_key in self.widget_positions.keys():
            if pos_key.startswith("streak_"):
                actual_chat_id = pos_key[7:]
                streak_key = self.getStreakKey(actual_chat_id) if hasattr(self, 'getStreakKey') else actual_chat_id
                if streak_key not in self.streaks:
                    positions_to_remove.append(pos_key)
            else:
                if pos_key not in self.pets:
                    positions_to_remove.append(pos_key)

        for pos_key in positions_to_remove:
            del self.widget_positions[pos_key]
            self.log(f"WSP: removed widget position for inactive chat {pos_key}")

        try:
            self.set_setting("widget_positions", self.widget_positions)
        except Exception as e:
            errors.append(f"widget_positions: {e}")
            self.log(f"WSP: ERROR saving widget_positions: {e}")

        try:
            self.set_setting("p2pkeys", self.p2pKeys)
        except Exception as e:
            errors.append(f"p2pkeys: {e}")
            self.log(f"WSP: ERROR saving p2pkeys: {e}")

        if errors:
            self.log(f"WSP: data save FAILED with {len(errors)} errors: {errors}")
            return False
        else:
            return True

    def collectKnownIds(self):
        known = set()
        try:
            known.update(str(cid) for cid in self.pets.keys())
            known.update(str(cid) for cid in self.pet_enabled_chats)
            known.update(str(cid) for cid in self.streak_enabled_chats)
            if hasattr(self, "active_streak_badges"):
                known.update(str(cid) for cid in self.active_streak_badges.keys())
            known.update(str(cid) for cid in self.active_widgets.keys())
        except Exception:
            pass
        try:
            for streak in self.streaks.values():
                cid = getattr(streak, "chat_id", None)
                if cid is not None:
                    known.add(str(cid))
        except Exception:
            pass
        return known

    def pruneTmpMap(self, data_map, known_ids):
        try:
            for key in list(data_map.keys()):
                norm_key = self.normTmpKey(key)
                if norm_key not in known_ids:
                    data_map.pop(key, None)
            max_size = self.maxTmp
            if max_size and len(data_map) > max_size:
                items = list(data_map.items())
                items.sort(key=lambda kv: self.transientTs(kv[1]))
                for key, _ in items[: len(items) - max_size]:
                    data_map.pop(key, None)
        except Exception:
            pass

    def transientTs(self, value):
        try:
            if isinstance(value, dict):
                ts = value.get("ts")
                if ts is None:
                    ts = value.get("timestamp")
                return float(ts or 0)
            if isinstance(value, (int, float)):
                return float(value)
            if isinstance(value, list) and value:
                last = value[-1]
                if isinstance(last, (int, float)):
                    return float(last)
            return 0
        except Exception:
            return 0

    def normTmpKey(self, key):
        try:
            s = str(key)
            if s.startswith("pet_"):
                return s[4:]
            if s.startswith("streak_"):
                return s[7:]
            return s
        except Exception:
            return str(key)

    def pruneTmpState(self):
        known_ids = self.collectKnownIds()
        if not known_ids:
            return
        for data_map in (
            self.last_messages,
            self.recent_messages,
            self.xp_history,
            self.last_auto_sync,
            self.last_server_check,
            self.last_p2p_sync,
            self.last_pet_sync,
            self.last_streak_sync,
            self.minigame_combo,
            self._p2p_offer_last,
            self._last_synced_streak_hash,
            self._last_synced_pet_hash,
            self.last_sync_status,
            self.lastSyncOk,
            self.lastSentStreak,
            self.lastSentPet,
            self.last_flame_time,
        ):
            self.pruneTmpMap(data_map, known_ids)
        try:
            now = time.time()
            if self.actionGuard:
                for key, ts in list(self.actionGuard.items()):
                    if now - float(ts or 0) > 600:
                        self.actionGuard.pop(key, None)
                if len(self.actionGuard) > self.maxTmp:
                    items = sorted(self.actionGuard.items(), key=lambda x: x[1])
                    remove_count = len(self.actionGuard) - self.maxTmp
                    for key, _ in items[:remove_count]:
                        self.actionGuard.pop(key, None)
        except Exception:
            pass

    def recordSyncStatus(self, chat_id, mode, success, reason=None):
        try:
            if not chat_id:
                return
            chat_key = self.normChat(chat_id)
            status = {
                "ts": time.time(),
                "mode": mode,
                "ok": bool(success),
                "reason": reason or "",
            }
            self.last_sync_status[chat_key] = status
            if success:
                self.lastSyncOk[chat_key] = status["ts"]
        except Exception:
            pass

    def formatSyncStatus(self, chat_id):
        try:
            if not self.get_setting("show_last_sync_status", True):
                return ""
            chat_id = self.normChat(chat_id)
            data = self.last_sync_status.get(chat_id)
            if not data:
                return tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –µ—â—ë –Ω–µ –±—ã–ª–æ", "No sync yet")
            ts = data.get("ts", 0)
            if not ts:
                return tr("–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –µ—â—ë –Ω–µ –±—ã–ª–æ", "No sync yet")
            minutes = int(max(0, time.time() - ts) // 60)
            if minutes < 1:
                when = tr("—Ç–æ–ª—å–∫–æ —á—Ç–æ", "just now")
            elif minutes < 60:
                when = tr(f"{minutes} –º–∏–Ω –Ω–∞–∑–∞–¥", f"{minutes}m ago")
            else:
                hours = minutes // 60
                when = tr(f"{hours} —á –Ω–∞–∑–∞–¥", f"{hours}h ago")
            mode = data.get("mode", "")
            ok = data.get("ok", False)
            reason = data.get("reason", "")
            reasons = {
                "server_unavailable": tr("–°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω", "Server unavailable"),
                "network": tr("–û—à–∏–±–∫–∞ —Å–µ—Ç–∏", "Network error"),
                "auth_failed": tr("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏", "Auth failed"),
                "auth_wait": tr("–ü–æ–¥–æ–∂–¥–∏—Ç–µ, –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è", "Auth cooldown"),
                "db_busy": tr("–°–µ—Ä–≤–µ—Ä –∑–∞–Ω—è—Ç", "Server busy"),
                "server_error": tr("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞", "Server error"),
                "bad_request": tr("–ù–µ–≤–µ—Ä–Ω—ã–π –∑–∞–ø—Ä–æ—Å", "Bad request"),
                "missing install id": tr("–ù–µ—Ç install id", "Missing install id"),
                "invalid install id": tr("–ù–µ–≤–µ—Ä–Ω—ã–π install id", "Invalid install id"),
                "missing dev key": tr("–ù–µ—Ç dev key", "Missing dev key"),
                "missing req sig": tr("–ù–µ—Ç –ø–æ–¥–ø–∏—Å–∏", "Missing signature"),
                "bad sig": tr("–ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–¥–ø–∏—Å—å", "Bad signature"),
                "bad ts": tr("–ù–µ–≤–µ—Ä–Ω–æ–µ –≤—Ä–µ–º—è", "Bad timestamp"),
                "p2p_no_key": tr("–ù–µ—Ç P2P –∫–ª—é—á–∞", "Missing P2P key"),
                "throttled": tr("–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ", "Throttled"),
                "rate_limited": tr("–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤", "Too many requests"),
                "token_revoked": tr("–¢–æ–∫–µ–Ω –æ—Ç–æ–∑–≤–∞–Ω", "Token revoked"),
                "install_revoked": tr("–î–æ—Å—Ç—É–ø –æ—Ç–∫–ª—é—á—ë–Ω", "Access revoked"),
                "streak_save_failed": tr("–°—Ç—Ä–∏–∫ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω", "Streak save failed"),
                "pet_save_failed": tr("–ü–∏—Ç–æ–º–µ—Ü –Ω–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω", "Pet save failed"),
                "batch_failed": tr("–û—à–∏–±–∫–∞ –ø–∞–∫–µ—Ç–Ω–æ–π —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏", "Batch sync failed"),
                "invalid_user_id": tr("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID", "Failed to get ID"),
                "client_guard": tr("–ó–∞—â–∏—Ç–∞ –æ—Ç –Ω–∞–∫—Ä—É—Ç–∫–∏", "Anti-abuse guard"),
            }
            hints = {
                "server_unavailable": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å —Å–µ—Ç—å/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: check network/proxy or try later",
                ),
                "network": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å —Å–µ—Ç—å/–ø—Ä–æ–∫—Å–∏ –∏–ª–∏ –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: check network/proxy or try later",
                ),
                "missing install id": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–∫—Å–∏/–æ–±—Ö–æ–¥ –º–æ–∂–µ—Ç —Ä–µ–∑–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º –∏–ª–∏ –ø—Ä–æ–∫—Å–∏.",
                    "Tip: proxy may strip headers. Try another proxy mode.",
                ),
                "invalid install id": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–∫—Å–∏/–æ–±—Ö–æ–¥ –º–æ–∂–µ—Ç –ª–æ–º–∞—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.",
                    "Tip: proxy may modify headers. Try another mode.",
                ),
                "missing dev key": tr(
                    "–°–æ–≤–µ—Ç: –ø–µ—Ä–µ—É—Å—Ç–∞–Ω–æ–≤–∏ –ø–ª–∞–≥–∏–Ω –∏–ª–∏ —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é",
                    "Tip: reinstall plugin or reset auth",
                ),
                "missing req sig": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–∫—Å–∏/–æ–±—Ö–æ–¥ —Ä–µ–∂–µ—Ç –ø–æ–¥–ø–∏—Å–∏. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.",
                    "Tip: proxy strips signature headers. Try another mode.",
                ),
                "bad sig": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞ –∏—Å–ø–æ—Ä—á–µ–Ω–∞ –ø—Ä–æ–∫—Å–∏/–æ–±—Ö–æ–¥–æ–º. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–π —Ä–µ–∂–∏–º.",
                    "Tip: signature broken by proxy. Try another mode.",
                ),
                "bad ts": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å –≤—Ä–µ–º—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∏ –ø—Ä–æ–∫—Å–∏",
                    "Tip: check device time and proxy",
                ),
                "p2p_no_key": tr(
                    "–°–æ–≤–µ—Ç: –Ω—É–∂–Ω–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –≤—ã–¥–∞—á–∏ –∫–ª—é—á–∞",
                    "Tip: run server sync to get a key",
                ),
                "rate_limited": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–¥–æ–∂–¥–∏ 30‚Äì60 —Å–µ–∫",
                    "Tip: wait 30‚Äì60s",
                ),
                "auth_wait": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–¥–æ–∂–¥–∏ –ø–∞—Ä—É –º–∏–Ω—É—Ç",
                    "Tip: wait a couple minutes",
                ),
                "auth_failed": tr(
                    "–°–æ–≤–µ—Ç: —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö",
                    "Tip: reset auth in settings",
                ),
                "token_revoked": tr(
                    "–°–æ–≤–µ—Ç: —Å–±—Ä–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∏ –ø–æ–¥–æ–∂–¥–∏",
                    "Tip: reset auth and wait",
                ),
                "install_revoked": tr(
                    "–°–æ–≤–µ—Ç: –¥–æ—Å—Ç—É–ø –æ—Ç–∫–ª—é—á—ë–Ω ‚Äî –Ω–∞–ø–∏—à–∏ –∞–≤—Ç–æ—Ä—É",
                    "Tip: access revoked ‚Äî contact author",
                ),
                "server_error": tr(
                    "–°–æ–≤–µ—Ç: —Å–µ—Ä–≤–µ—Ä –ø–µ—Ä–µ–≥—Ä—É–∂–µ–Ω, –ø–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ",
                    "Tip: server busy, try later",
                ),
                "db_busy": tr(
                    "–°–æ–≤–µ—Ç: –ø–æ–ø—Ä–æ–±—É–π —á–µ—Ä–µ–∑ –ø–∞—Ä—É –º–∏–Ω—É—Ç",
                    "Tip: try again in a few minutes",
                ),
                "bad_request": tr(
                    "–°–æ–≤–µ—Ç: –æ–±–Ω–æ–≤–∏ –ø–ª–∞–≥–∏–Ω –¥–æ —Å–≤–µ–∂–µ–π –≤–µ—Ä—Å–∏–∏",
                    "Tip: update the plugin",
                ),
                "client_guard": tr(
                    "–°–æ–≤–µ—Ç: –ø—Ä–æ–≤–µ—Ä—å –≤—Ä–µ–º—è –∏ –∏–∑–±–µ–≥–∞–π —Ä–µ–∑–∫–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π",
                    "Tip: check time and avoid big jumps",
                ),
            }
            label = tr("–£—Å–ø–µ—à–Ω–æ", "OK") if ok else tr("–û—à–∏–±–∫–∞", "Failed")
            modeTag = ""
            if mode.startswith("remote:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            elif mode.startswith("send:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            elif mode.startswith("force:"):
                src = mode.split(":", 1)[-1]
                modeTag = tr(f"‚Ä¢ {src}", f"‚Ä¢ {src}")
            lines = [
                f"{tr('–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è:', 'Last sync:')} {when} ‚Äî {label} {modeTag}".strip()
            ]
            if not ok and reason:
                why = reasons.get(reason, reason)
                lines.append(tr(f"–ü—Ä–∏—á–∏–Ω–∞: {why}", f"Reason: {why}"))
                hint = hints.get(reason)
                if hint:
                    lines.append(hint)
            if not ok:
                ok_ts = self.lastSyncOk.get(chat_id)
                if ok_ts:
                    ok_min = int(max(0, time.time() - ok_ts) // 60)
                    if ok_min < 1:
                        ok_part = tr("—Ç–æ–ª—å–∫–æ —á—Ç–æ", "just now")
                    elif ok_min < 60:
                        ok_part = tr(f"{ok_min} –º–∏–Ω –Ω–∞–∑–∞–¥", f"{ok_min}m ago")
                    else:
                        ok_hours = ok_min // 60
                        ok_part = tr(f"{ok_hours} —á –Ω–∞–∑–∞–¥", f"{ok_hours}h ago")
                    lines.append(
                        tr(f"–ü–æ—Å–ª–µ–¥–Ω—è—è —É—Å–ø–µ—à–Ω–∞—è: {ok_part}", f"Last OK: {ok_part}")
                    )
            return "\n".join(lines)
        except Exception:
            return ""

    def saveData(self):
        with self.data_lock:
            self.saveDataUnsafe()

    def createFlameParticle(self, chat_id, xp_amount):
        try:
            chat_id = self.normChat(chat_id)
            now = time.time()
            with self.data_lock:
                last = self.last_flame_time.get(chat_id, 0)
                if now - last < 0.4:
                    return
                self.last_flame_time[chat_id] = now
            with self.data_lock:
                if chat_id not in self.active_widgets:
                    return
                widget = self.active_widgets[chat_id]

            widget_view = widget.get_view()

            parent = widget_view.getParent()
            if not parent:
                return

            widget_x = widget_view.getX() + widget_view.getWidth() / 2
            widget_y = widget_view.getY() + widget_view.getHeight() / 2

            start_x = AndroidUtilities.dp(Dp.S20)
            start_y = parent.getHeight() - AndroidUtilities.dp(Dp.S100)

            flame = FlyingXPParticle(
                widget_view.getContext(),
                start_x,
                start_y,
                widget_x,
                widget_y,
                xp_amount,
                lambda: self.removeFlameParticle(parent, flame),
            )

            flame_view = flame.get_view()
            parent.addView(flame_view)

            pulse = ObjectAnimator.ofFloat(widget.container, "scaleX", 1.0, 1.3, 1.0)
            pulse.setDuration(300)
            pulse.setStartDelay(800)
            pulse.start()
            pulse2 = ObjectAnimator.ofFloat(widget.container, "scaleY", 1.0, 1.3, 1.0)
            pulse2.setDuration(300)
            pulse2.setStartDelay(800)
            pulse2.start()

            widget._update_visual()

        except Exception as e:
            self.log(f"WSP flame error: {e}")

    def removeFlameParticle(self, parent, flame):
        try:
            if hasattr(flame, "cleanup"):
                flame.cleanup()
            parent.removeView(flame.get_view())
        except Exception:
            pass

    def loadData(self):
        self.log("WSP: loading data from settings...")

        pets_raw = self.get_setting("pets", {})
        streaks_raw = self.get_setting("streaks", {})
        pets_data = pets_raw if V.is_dict(pets_raw) else {}
        streaks_data = streaks_raw if V.is_dict(streaks_raw) else {}

        last_msgs_raw = self.get_setting("last_msgs", {})
        self.last_messages = last_msgs_raw if V.is_dict(last_msgs_raw) else {}

        streak_enabled_raw = self.get_setting("streak_enabled", [])
        streak_enabled_list = streak_enabled_raw if V.is_list(streak_enabled_raw) else []
        self.streak_enabled_chats = set(str(x) for x in streak_enabled_list if x)

        pet_enabled_raw = self.get_setting("pet_enabled", [])
        pet_enabled_list = pet_enabled_raw if V.is_list(pet_enabled_raw) else []
        self.pet_enabled_chats = set(str(x) for x in pet_enabled_list if x)

        revive_raw = self.get_setting("pet_revive_times", {})
        revive_data = revive_raw if V.is_dict(revive_raw) else {}
        self.pet_revive_times = {
            str(k): V.ts(v, 0) for k, v in revive_data.items() if k
        }

        self.log(f"WSP: raw {len(pets_data)} pets, {len(streaks_data)} streaks")

        skipped_pets = 0
        for chat_id, data in pets_data.items():
            try:
                validated = V.pet_data(data)
                if not validated:
                    self.log(f"WSP: invalid pet data for {chat_id}, skipping")
                    skipped_pets += 1
                    continue
                if validated.get("deleted", False):
                    continue
                self.pets[chat_id] = Pet.from_dict(validated, plugin_ref=self)
            except Exception as e:
                self.log(f"WSP: ERROR loading pet {chat_id}: {e}")
                skipped_pets += 1

        skipped_streaks = 0
        for chat_id, data in streaks_data.items():
            try:
                validated = V.streak_data(data)
                if not validated:
                    self.log(f"WSP: invalid streak data for {chat_id}, skipping")
                    skipped_streaks += 1
                    continue
                if validated.get("deleted", False):
                    continue
                self.streaks[chat_id] = Streak.from_dict(validated, plugin_ref=self)
            except Exception as e:
                self.log(f"WSP: ERROR loading streak {chat_id}: {e}")
                skipped_streaks += 1

        if skipped_pets > 0 or skipped_streaks > 0:
            self.log(f"WSP: skipped {skipped_pets} pets, {skipped_streaks} streaks due to validation")

        positions_raw = self.get_setting("widget_positions", {})
        self.widget_positions = positions_raw if V.is_dict(positions_raw) else {}

        keys_raw = self.get_setting("p2pkeys", {})
        self.p2pKeys = keys_raw if V.is_dict(keys_raw) else {}

        self.log(f"WSP: loaded {len(self.pets)} pets, {len(self.streaks)} streaks, {len(self.widget_positions)} positions")
