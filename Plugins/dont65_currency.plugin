# –ü–ª–∞–≥–∏–Ω: Currency Monitor
# –ê–≤—Ç–æ—Ä: @dont65 (idea), Gemini (code)
# –í–µ—Ä—Å–∏—è 1.2.0
# –¢—Ä–µ–±—É–µ—Ç: Dont65 Library (dont65_lib)

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Text, Switch, Input
import json
import urllib.request
import xml.etree.ElementTree as ET
import time
import traceback
import re

__name__ = "Currency Monitor"
__description__ = (
    "üí± –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –≤–∞–ª—é—Ç –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç.\n"
    "–ò—Å—Ç–æ—á–Ω–∏–∫–∏: –¶–ë –†–§ (–§–∏–∞—Ç) –∏ Bybit (–ö—Ä–∏–ø—Ç–∞).\n\n"
    "–ö–æ–º–∞–Ω–¥—ã:\n"
    "‚Ä¢ .curs [—Å—É–º–º–∞] [–≤–∞–ª—é—Ç–∞] ‚Äî –ö–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º\n"
    "‚Ä¢ .curs [–≤–∞–ª—é—Ç–∞] [–≤–∞–ª—é—Ç–∞] ‚Äî –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –ø–∞—Ä—ã\n"
    "–ü—Ä–∏–º–µ—Ä—ã: .curs ton rub, .curs usd/eur, .curs –±–∏—Ç–æ–∫ –∫ —Ç–µ–Ω–≥–µ"
)
__icon__ = "Monakasfx/26" 
__version__ = "1.2.0"
__id__ = "dont65_currency"
__author__ = "@dont65"
__min_version__ = "11.0.0"

class CurrencyPlugin(BasePlugin):
    
    def __init__(self):
        super().__init__()
        self.rates_cache = {}
        self.last_update = 0
        self.lib_missing = False
        self.Dont65Utils = None
        self._check_library()

        # –ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞ –≤–∞–ª—é—Ç –∏ —ç–º–æ–¥–∑–∏
        self.display_order = ["RUB", "USD", "EUR", "BYN", "UAH", "KZT", "BTC", "TON", "USDT"]
        self.meta = {
            "RUB": {"flag": "üá∑üá∫", "name": "RUB"},
            "USD": {"flag": "üá∫üá∏", "name": "USD"},
            "EUR": {"flag": "üá™üá∫", "name": "EUR"},
            "BYN": {"flag": "üáßüáæ", "name": "BYN"},
            "UAH": {"flag": "üá∫üá¶", "name": "UAH"},
            "KZT": {"flag": "üá∞üáø", "name": "KZT"},
            "BTC": {"flag": "üíé", "name": "BTC"},
            "TON": {"flag": "üíé", "name": "TON"},
            "USDT": {"flag": "‚ÇÆ", "name": "USDT"}
        }

        # –°–ª–æ–≤–∞—Ä—å —Å–∏–Ω–æ–Ω–∏–º–æ–≤
        self.synonyms = {
            "rub": "RUB", "—Ä—É–±": "RUB", "‚ÇΩ": "RUB", "—Ä—É–±–ª—å": "RUB", "rur": "RUB",
            "usd": "USD", "$": "USD", "–¥–æ–ª–ª–∞—Ä": "USD", "–±–∞–∫—Å": "USD",
            "byn": "BYN", "–±—É–Ω": "BYN", "–±–µ–ª—Ä—É–±": "BYN", "–±—Ä—É–±–ª—å": "BYN",
            "eur": "EUR", "‚Ç¨": "EUR", "euro": "EUR", "–µ–≤—Ä–æ": "EUR",
            "kzt": "KZT", "—Ç–µ–Ω–≥–µ": "KZT",
            "ton": "TON", "—Ç–æ–Ω": "TON",
            "btc": "BTC", "–±–∏—Ç–∫–æ–∏–Ω": "BTC", "–±–∏—Ç–æ–∫": "BTC", "bct": "BTC",
            "usdt": "USDT", "tether": "USDT", "—Ç–µ—Ç—Ö–µ—Ä": "USDT", "–∫—Ä–∏–ø—Ç–æ–¥–æ–ª–ª–∞—Ä": "USDT",
            "uah": "UAH", "–≥—Ä–∏–≤–Ω–∞": "UAH"
        }

    def _check_library(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            from client_utils import log
            log(f"[{__id__}] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ Dont65Lib –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
        except ImportError:
            self.lib_missing = True
            from client_utils import log
            log(f"[{__id__}] –û—à–∏–±–∫–∞: –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ dont65_lib –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    # --- UI –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---
    def create_settings(self):
        settings = [
            Header("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞–ª—é—Ç"),
            Text("–ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç."),
            Divider()
        ]
        
        if self.lib_missing:
            settings.extend([
                Text("‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è Dont65 Library!"),
                Divider(text="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–≥–∏–Ω dont65_lib –¥–ª—è —Ä–∞–±–æ—Ç—ã"),
                Divider(),
                Divider(text="–ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏\n–ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç")
            ])
        else:
            settings.extend([
                Switch(key="enable_plugin", text="–í–∫–ª—é—á–∏—Ç—å –ø–ª–∞–≥–∏–Ω (.curs)", default=True),
                Input(
                    key="update_interval",
                    text="–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–º–∏–Ω)", 
                    subtext="–ö–∞–∫ —á–∞—Å—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫—É—Ä—Å—ã",
                    default="30" 
                ),
                Divider(text="–ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∞–Ω–¥:\n.curs 100 usd\n.curs ton/rub\n.curs btc –∫ kzt"),
            ])
        
        return settings

    # --- –°–µ—Ç–µ–≤–∞—è –ª–æ–≥–∏–∫–∞ ---
    def _fetch_url(self, url):
        req = urllib.request.Request(
            url, 
            headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
        )
        with urllib.request.urlopen(req, timeout=10) as response:
            return response.read()

    def update_rates(self):
        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –º–∏–Ω—É—Ç –∏–∑ UI
        try:
            interval_min = float(self.get_setting("update_interval", "30"))
        except ValueError:
            interval_min = 30.0 # –§–æ–ª–±–µ–∫ –µ—Å–ª–∏ –≤–≤–µ–ª–∏ —Ç–µ–∫—Å—Ç –≤–º–µ—Å—Ç–æ —Ü–∏—Ñ—Ä
        
        # –ü–µ—Ä–µ–≤–æ–¥–∏–º –≤ —Å–µ–∫—É–Ω–¥—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        timeout_seconds = interval_min * 60

        if time.time() - self.last_update < timeout_seconds and self.rates_cache:
            return

        new_rates = {"RUB": 1.0} 
        try:
            # –¶–ë –†–§
            xml_data = self._fetch_url("https://www.cbr.ru/scripts/XML_daily.asp")
            root = ET.fromstring(xml_data)
            target_fiats = ["USD", "EUR", "BYN", "UAH", "KZT"]
            usd_rub_rate = 0.0

            for valute in root.findall('Valute'):
                code = valute.find('CharCode').text
                if code in target_fiats:
                    nominal = float(valute.find('Nominal').text.replace(',', '.'))
                    value = float(valute.find('Value').text.replace(',', '.'))
                    rate = value / nominal
                    new_rates[code] = rate
                    if code == "USD": usd_rub_rate = rate

            if usd_rub_rate == 0: usd_rub_rate = 90.0 
            new_rates["USDT"] = usd_rub_rate

            # Bybit
            crypto_pairs = {"BTC": "BTCUSDT", "TON": "TONUSDT"}
            for coin, ticker in crypto_pairs.items():
                try:
                    url = f"https://api.bybit.com/v5/market/tickers?category=spot&symbol={ticker}"
                    data = json.loads(self._fetch_url(url))
                    price_usdt = float(data['result']['list'][0]['lastPrice'])
                    new_rates[coin] = price_usdt * usd_rub_rate
                except:
                    new_rates[coin] = 0.0

            self.rates_cache = new_rates
            self.last_update = time.time()
        except Exception:
            pass

    def _format_number(self, num):
        if num == 0: return "Err"
        if num < 0.000001: return f"{num:.8f}"
        if num < 0.01: return f"{num:.6f}"
        elif num < 100: return f"{num:.2f}"
        else: return "{:,.2f}".format(num)

    # --- –•—É–∫–∏ ---
    def on_plugin_load(self):
        if not self.lib_missing:
            self.add_on_send_message_hook(priority=200)

    def on_send_message_hook(self, account, params):
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
            if self.lib_missing:
                msg_text = params.message or params.caption or ""
                if msg_text.strip().startswith('.curs'):
                    header = "‚ùå –û—à–∏–±–∫–∞"
                    body = "–¢—Ä–µ–±—É–µ—Ç—Å—è Dont65 Library!\n–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–≥–∏–Ω `dont65_lib` –¥–ª—è —Ä–∞–±–æ—Ç—ã Currency Monitor."
                    params.message = f"**{header}**\n{body}"
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                return HookResult()

            if not self.get_setting("enable_plugin", True):
                return HookResult()

            msg_text = ""
            is_caption = False
            if hasattr(params, 'message') and params.message: msg_text = params.message
            elif hasattr(params, 'caption') and params.caption: 
                msg_text = params.caption
                is_caption = True
            
            if not msg_text or not msg_text.lower().startswith(".curs"): return HookResult()

            # 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
            # –£–¥–∞–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É .curs, –∑–∞–º–µ–Ω—è–µ–º —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–∏ –Ω–∞ –ø—Ä–æ–±–µ–ª—ã
            raw_args = msg_text[5:].lower()
            clean_args = raw_args.replace('/', ' ').replace(' –∫ ', ' ').replace(' to ', ' ')
            tokens = clean_args.split()

            amount = 1.0
            currencies = []

            # 2. –ü–∞—Ä—Å–∏–Ω–≥ —Ç–æ–∫–µ–Ω–æ–≤
            for token in tokens:
                if token in self.synonyms:
                    currencies.append(self.synonyms[token])
                else:
                    try:
                        # –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É –¥–ª—è float
                        amount = float(token.replace(',', '.'))
                    except:
                        pass # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –º—É—Å–æ—Ä–Ω—ã–µ —Å–ª–æ–≤–∞

            # 3. –õ–æ–≥–∏–∫–∞ –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞
            # –ï—Å–ª–∏ –≤–∞–ª—é—Ç –Ω–µ—Ç –≤–æ–æ–±—â–µ -> —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –ø–µ—Ä–≤–∞—è –≤–∞–ª—é—Ç–∞ —ç—Ç–æ RUB (–¥–µ—Ñ–æ–ª—Ç)
            if not currencies:
                currencies.append("RUB")

            self.update_rates()
            if not self.rates_cache:
                header = "‚ö†Ô∏è –û—à–∏–±–∫–∞"
                body = "–ö—É—Ä—Å—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã."
            else:
                source_curr = currencies[0]
                
                # –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ –∏—Å—Ö–æ–¥–Ω–∞—è –≤–∞–ª—é—Ç–∞ –≤ –∫—ç—à–µ
                if source_curr not in self.rates_cache:
                    header = "‚ö†Ô∏è –û—à–∏–±–∫–∞"
                    body = f"–í–∞–ª—é—Ç–∞ {source_curr} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞."
                else:
                    src_rate = self.rates_cache[source_curr]
                    src_meta = self.meta.get(source_curr, {"flag": "üí∞", "name": source_curr})
                    
                    # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
                    header = f"{src_meta['flag']} {src_meta['name']} {amount} "
                    body_lines = []

                    # –†–ï–ñ–ò–ú 1: –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –ø–∞—Ä–∞ (.curs ton rub)
                    if len(currencies) >= 2:
                        target_curr = currencies[1]
                        if target_curr in self.rates_cache:
                            tgt_rate = self.rates_cache[target_curr]
                            if tgt_rate > 0:
                                res = (amount * src_rate) / tgt_rate
                                tgt_meta = self.meta.get(target_curr, {"flag": "üí∞", "name": target_curr})
                                body_lines.append(f"{tgt_meta['flag']} {tgt_meta['name']} = `{self._format_number(res)}`")
                    
                    # –†–ï–ñ–ò–ú 2: –ö–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º (.curs ton)
                    else:
                        for target_code in self.display_order:
                            if target_code == source_curr: continue # –ù–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–∞–º—É —Å–µ–±—è
                            if target_code not in self.rates_cache: continue
                            
                            tgt_rate = self.rates_cache[target_code]
                            if tgt_rate == 0: continue

                            res = (amount * src_rate) / tgt_rate
                            tgt_meta = self.meta.get(target_code, {"flag": "üí∞", "name": target_code})
                            body_lines.append(f"{tgt_meta['flag']} {tgt_meta['name']} = `{self._format_number(res)}`")

                    body = "\n".join(body_lines)

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞
            new_params = self.Dont65Utils.reply_with_style(
                params,
                body=body,
                header=header,
                source=None,
                quote='block'
            )
            
            return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=new_params)

        except Exception:
            from client_utils import log
            log(f"[{__id__}] –û—à–∏–±–∫–∞:\n{traceback.format_exc()}")
            return HookResult()