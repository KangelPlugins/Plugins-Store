# –ü–ª–∞–≥–∏–Ω: Currency Monitor
# –ê–≤—Ç–æ—Ä: @dont65 (idea), Gemini (code)
# –í–µ—Ä—Å–∏—è 1.5.2
# –¢—Ä–µ–±—É–µ—Ç: Dont65 Library (dont65_lib)

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Text, Switch, Input
from android_utils import run_on_ui_thread
from client_utils import get_messages_controller, get_last_fragment, log
import json
import urllib.request
import xml.etree.ElementTree as ET
import time
import traceback
import datetime

__name__ = "Currency Monitor"
__description__ = (
    "üí± –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –≤–∞–ª—é—Ç –∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç.\n"
    "–ò—Å—Ç–æ—á–Ω–∏–∫–∏: –¶–ë –†–§ (–§–∏–∞—Ç, –∑–æ–ª–æ—Ç–æ), Bybit (–ö—Ä–∏–ø—Ç–∞), CoinGecko (—Ä–µ–∑–µ—Ä–≤).\n"
    "–î–æ–±–∞–≤–ª–µ–Ω—ã: —à–µ–∫–µ–ª—å (üáÆüá±), –∏—Ä–∞–Ω—Å–∫–∏–π —Ä–∏–∞–ª (üáÆüá∑), –∑–æ–ª–æ—Ç–æ (ü™ô), –≥—Ä–∞–º–º –∑–æ–ª–æ—Ç–∞ (‚öñÔ∏è), Telegram –ó–≤—ë–∑–¥—ã (‚≠ê).\n"
    "–í –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å, –∫–∞–∫–∏–µ –≤–∞–ª—é—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ.\n\n"
    "–ö–æ–º–∞–Ω–¥—ã:\n"
    "‚Ä¢ .curs [—Å—É–º–º–∞] [–≤–∞–ª—é—Ç–∞] ‚Äî –ö–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º (—Å —É—á—ë—Ç–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–∫)\n"
    "‚Ä¢ .curs [–≤–∞–ª—é—Ç–∞] [–≤–∞–ª—é—Ç–∞] ‚Äî –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –ø–∞—Ä—ã (–±–µ–∑ —É—á—ë—Ç–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫)\n"
    "–ü—Ä–∏–º–µ—Ä—ã: .curs 100 usd, .curs ton/rub, .curs –∑–æ–ª–æ—Ç–æ –∫ –≥—Ä–∞–º–º"
)
__icon__ = "Monakasfx/26"
__version__ = "1.5.2"
__id__ = "dont65_currency"
__author__ = "@dont65"
__min_version__ = "11.0.0"
_dependencies_ = "dont65_lib"

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
AUTOUPDATE_CHANNEL_ID = 3624287619  # @dontplugin
AUTOUPDATE_MSG_ID = 14              # ID –ø–æ—Å—Ç–∞ —Å —ç—Ç–∏–º –ø–ª–∞–≥–∏–Ω–æ–º

class CurrencyPlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self.rates_cache = {}
        self.last_update = 0
        self.lib_missing = False
        self.Dont65Utils = None
        self.logger = None
        self._check_library()

        # –ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞ –≤–∞–ª—é—Ç –∏ —ç–º–æ–¥–∑–∏
        self.display_order = ["RUB", "USD", "EUR", "BYN", "UAH", "KZT", "ILS", "IRR", "BTC", "TON", "USDT", "XAU", "GRAM", "STARS"]
        self.meta = {
            "RUB": {"flag": "üá∑üá∫", "name": "RUB"},
            "USD": {"flag": "üá∫üá∏", "name": "USD"},
            "EUR": {"flag": "üá™üá∫", "name": "EUR"},
            "BYN": {"flag": "üáßüáæ", "name": "BYN"},
            "UAH": {"flag": "üá∫üá¶", "name": "UAH"},
            "KZT": {"flag": "üá∞üáø", "name": "KZT"},
            "ILS": {"flag": "üáÆüá±", "name": "ILS"},
            "IRR": {"flag": "üáÆüá∑", "name": "IRR"},
            "BTC": {"flag": "üíé", "name": "BTC"},
            "TON": {"flag": "üíé", "name": "TON"},
            "USDT": {"flag": "‚ÇÆ", "name": "USDT"},
            "XAU": {"flag": "ü™ô", "name": "XAU"},
            "GRAM": {"flag": "‚öñÔ∏è", "name": "GRAM"},
            "STARS": {"flag": "‚≠ê", "name": "STARS"}
        }

        # –°–ª–æ–≤–∞—Ä—å —Å–∏–Ω–æ–Ω–∏–º–æ–≤
        self.synonyms = {
            "rub": "RUB", "—Ä—É–±": "RUB", "‚ÇΩ": "RUB", "—Ä—É–±–ª—å": "RUB", "rur": "RUB",
            "usd": "USD", "$": "USD", "–¥–æ–ª–ª–∞—Ä": "USD", "–±–∞–∫—Å": "USD",
            "byn": "BYN", "–±—É–Ω": "BYN", "–±–µ–ª—Ä—É–±": "BYN", "–±—Ä—É–±–ª—å": "BYN",
            "eur": "EUR", "‚Ç¨": "EUR", "euro": "EUR", "–µ–≤—Ä–æ": "EUR",
            "kzt": "KZT", "—Ç–µ–Ω–≥–µ": "KZT",
            "ils": "ILS", "—à–µ–∫–µ–ª—å": "ILS", "—à–µ–∫–µ–ª–∏": "ILS", "–∏–∑—Ä–∞–∏–ª—å": "ILS",
            "irr": "IRR", "–∏—Ä–∞–Ω—Å–∫–∏–π —Ä–∏–∞–ª": "IRR", "–∏—Ä–∞–Ω": "IRR", "—Ä–µ–∞–ª": "IRR", "—Ä–∏–∞–ª": "IRR",
            "ton": "TON", "—Ç–æ–Ω": "TON",
            "btc": "BTC", "–±–∏—Ç–∫–æ–∏–Ω": "BTC", "–±–∏—Ç–æ–∫": "BTC", "bct": "BTC",
            "usdt": "USDT", "tether": "USDT", "—Ç–µ—Ç—Ö–µ—Ä": "USDT", "–∫—Ä–∏–ø—Ç–æ–¥–æ–ª–ª–∞—Ä": "USDT",
            "uah": "UAH", "–≥—Ä–∏–≤–Ω–∞": "UAH",
            "xau": "XAU", "–∑–æ–ª–æ—Ç–æ": "XAU", "gold": "XAU", "—É–Ω—Ü–∏—è": "XAU",
            "gram": "GRAM", "–≥—Ä–∞–º–º": "GRAM", "–≥—Ä–∞–º–º –∑–æ–ª–æ—Ç–∞": "GRAM",
            "stars": "STARS", "star": "STARS", "–∑–≤—ë–∑–¥—ã": "STARS", "—Ç–≥–∑–≤": "STARS", "—Ç–µ–ª–µ–≥—Ä–∞–º –∑–≤—ë–∑–¥—ã": "STARS"
        }

    def _check_library(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
        except ImportError:
            self.lib_missing = True
            log(f"[{__id__}] –û—à–∏–±–∫–∞: –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ dont65_lib –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

    def _show_library_check_dialog(self, context):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            context.show_alert(
                "‚úÖ –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–∞–π–¥–µ–Ω–∞",
                f"Dont65 Library v{self.Dont65Utils.__version__ if hasattr(self.Dont65Utils, '__version__') else '1.0.6'}\n\n–í—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã."
            )
        except ImportError:
            self.lib_missing = True
            self.Dont65Utils = None
            context.show_alert(
                "‚ùå –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
                "–ü–ª–∞–≥–∏–Ω dont65_lib –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!\n\n–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Dont65 Library –¥–ª—è —Ä–∞–±–æ—Ç—ã MultiTool."
            )

    # --- UI –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ---
    def create_settings(self):
        settings = [
            Header("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞–ª—é—Ç"),
            Text("–ü–ª–∞–≥–∏–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç –∫—É—Ä—Å—ã –≤–∞–ª—é—Ç."),
            Divider()
        ]

        if self.lib_missing:
            settings.extend([
                Text("‚ö†Ô∏è –¢—Ä–µ–±—É–µ—Ç—Å—è Dont65 Library!"),
                Divider(text="–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–≥–∏–Ω dont65_lib –¥–ª—è —Ä–∞–±–æ—Ç—ã"),
                Divider(),
                Divider(text="–ü–æ—Å–ª–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏\n–ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç")
            ])
        else:
            settings.extend([
                Switch(key="enable_plugin", text="–í–∫–ª—é—á–∏—Ç—å –ø–ª–∞–≥–∏–Ω (.curs)", default=True),
                Input(
                    key="update_interval",
                    text="–ò–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–º–∏–Ω)",
                    subtext="–ö–∞–∫ —á–∞—Å—Ç–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫—É—Ä—Å—ã",
                    default="30"
                ),
                Divider(text="–ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∞–Ω–¥:\n.curs 100 usd\n.curs ton/rub\n.curs –∑–æ–ª–æ—Ç–æ –∫ –≥—Ä–∞–º–º\n.curs 50 stars"),
            ])

            # --- –°–µ–∫—Ü–∏—è –≤—ã–±–æ—Ä–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã—Ö –≤–∞–ª—é—Ç ---
            settings.append(Header("–û—Ç–æ–±—Ä–∞–∂–∞–µ–º—ã–µ –≤–∞–ª—é—Ç—ã"))
            settings.append(Text("–í—ã–±–µ—Ä–∏—Ç–µ, –∫–∞–∫–∏–µ –≤–∞–ª—é—Ç—ã –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ (–ø—Ä–∏ .curs <–≤–∞–ª—é—Ç–∞>)."))
            for code in self.display_order:
                flag = self.meta.get(code, {}).get('flag', '')
                label = f"{flag} {code}"
                settings.append(Switch(key=f"show_{code}", text=label, default=True))
            settings.append(Divider())

        # –ö–ª–∏–∫–∞–±–µ–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –Ω–∞ –∞–≤—Ç–æ—Ä–∞ –≤–Ω–∏–∑—É –Ω–∞—Å—Ç—Ä–æ–µ–∫
        settings.append(
            Text(
                text="–ê–≤—Ç–æ—Ä: @dont65",
                accent=False,
                on_click=lambda view: run_on_ui_thread(
                    lambda: get_messages_controller().openByUserName(
                        "dont65", get_last_fragment(), 1
                    )
                )
            )
        )
        settings.append(Divider())

        return settings

    # --- –°–µ—Ç–µ–≤–∞—è –ª–æ–≥–∏–∫–∞ ---
    def _fetch_url(self, url, timeout=10):
        req = urllib.request.Request(
            url,
            headers={'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
        )
        with urllib.request.urlopen(req, timeout=timeout) as response:
            return response.read()

    def _fetch_json(self, url, timeout=10):
        return json.loads(self._fetch_url(url, timeout))

    def _fetch_xml_with_date(self, base_url, date_param_name="date_req"):
        """–§–æ—Ä–º–∏—Ä—É–µ—Ç URL —Å —Ç–µ–∫—É—â–µ–π –¥–∞—Ç–æ–π –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –¶–ë –†–§"""
        today = datetime.date.today().strftime("%d/%m/%Y")
        return f"{base_url}?{date_param_name}={today}"

    def _fetch_from_coingecko(self, coin_ids):
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Ü–µ–Ω—ã –≤ USD –¥–ª—è —Å–ø–∏—Å–∫–∞ coin_ids (–∫–∞–∫ –Ω–∞ CoinGecko).
        –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å {symbol: price_usd}
        """
        result = {}
        try:
            ids = ','.join(coin_ids)
            url = f"https://api.coingecko.com/api/v3/simple/price?ids={ids}&vs_currencies=usd"
            data = self._fetch_json(url, timeout=15)
            for coin_id in coin_ids:
                if coin_id in data and 'usd' in data[coin_id]:
                    result[coin_id] = data[coin_id]['usd']
            if self.logger:
                self.logger.info(f"CoinGecko fetched: {result}")
        except Exception as e:
            if self.logger:
                self.logger.warning(f"CoinGecko error: {e}")
        return result

    def update_rates(self):
        try:
            interval_min = float(self.get_setting("update_interval", "30"))
        except ValueError:
            interval_min = 30.0

        timeout_seconds = interval_min * 60
        if time.time() - self.last_update < timeout_seconds and self.rates_cache:
            return

        new_rates = {}
        usd_rub_rate = None

        # --- 1. –§–∏–∞—Ç—ã —Å –¶–ë –†–§ ---
        try:
            xml_data = self._fetch_url("https://www.cbr.ru/scripts/XML_daily.asp")
            root = ET.fromstring(xml_data)
            target_fiats = ["USD", "EUR", "BYN", "UAH", "KZT", "ILS", "IRR"]

            for valute in root.findall('Valute'):
                code = valute.find('CharCode').text
                if code in target_fiats:
                    try:
                        nominal_str = valute.find('Nominal').text.replace(',', '.').strip()
                        value_str = valute.find('Value').text.replace(',', '.').strip()
                        nominal = float(nominal_str)
                        value = float(value_str)
                        rate = value / nominal
                        if rate > 0:
                            new_rates[code] = rate
                            if code == "USD":
                                usd_rub_rate = rate
                    except Exception as e:
                        if self.logger:
                            self.logger.warning(f"Failed to parse {code}: {e}")

            # –ï—Å–ª–∏ USD –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω–æ–π –∫—É—Ä—Å
            if usd_rub_rate is None:
                usd_rub_rate = 90.0
                if self.logger:
                    self.logger.warning("USD rate not found in CBR, using fallback 90.0")
                new_rates["USD"] = usd_rub_rate

            new_rates["RUB"] = 1.0
            new_rates["USDT"] = usd_rub_rate  # –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º USDT –∫ USD

        except Exception as e:
            if self.logger:
                self.logger.error(f"CBR fetch failed: {traceback.format_exc()}")
            # –ï—Å–ª–∏ –¶–ë –†–§ —Å–æ–≤—Å–µ–º –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞–ø–∞—Å–Ω—ã–µ –∫—É—Ä—Å—ã –¥–ª—è USD
            usd_rub_rate = 90.0
            new_rates["USD"] = usd_rub_rate
            new_rates["RUB"] = 1.0
            new_rates["USDT"] = usd_rub_rate

        # --- 2. –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã: Bybit + CoinGecko (—Ä–µ–∑–µ—Ä–≤) ---
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º Bybit
        crypto_symbols = ["BTC", "TON", "XAU"]
        crypto_from_bybit = {}

        for coin in crypto_symbols:
            try:
                if coin == "XAU":
                    ticker = "XAUUSDT"
                else:
                    ticker = f"{coin}USDT"
                url = f"https://api.bybit.com/v5/market/tickers?category=spot&symbol={ticker}"
                data = self._fetch_json(url, timeout=10)
                price_usdt = float(data['result']['list'][0]['lastPrice'])
                rate_rub = price_usdt * usd_rub_rate
                if rate_rub > 0:
                    crypto_from_bybit[coin] = rate_rub
                    if self.logger:
                        self.logger.info(f"Bybit {coin}: {rate_rub} RUB")
            except Exception as e:
                if self.logger:
                    self.logger.warning(f"Bybit {coin} failed: {e}")

        # –î–ª—è XAU, –µ—Å–ª–∏ Bybit –Ω–µ –¥–∞–ª, –ø—Ä–æ–±—É–µ–º –¶–ë –†–§
        if "XAU" not in crypto_from_bybit:
            self._fetch_gold_from_cbr(new_rates, usd_rub_rate)
            if "XAU" in new_rates:
                crypto_from_bybit["XAU"] = new_rates["XAU"]

        # –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö (BTC, TON) –∏ XAU (–µ—Å–ª–∏ –µ—â—ë –Ω–µ—Ç) –ø—Ä–æ–±—É–µ–º CoinGecko
        missing_crypto = [c for c in crypto_symbols if c not in crypto_from_bybit]
        if missing_crypto:
            # –ú–∞–ø–ø–∏–Ω–≥ –Ω–∞—à–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ ID CoinGecko
            cg_map = {
                "BTC": "bitcoin",
                "TON": "the-open-network",
                "XAU": "gold"  # –Ω–∞ CoinGecko –∑–æ–ª–æ—Ç–æ –∏–¥—ë—Ç –∫–∞–∫ "gold" (XAU)
            }
            cg_ids = [cg_map[c] for c in missing_crypto if c in cg_map]
            if cg_ids:
                cg_prices = self._fetch_from_coingecko(cg_ids)
                # –ü–µ—Ä–µ–≤–æ–¥–∏–º USD –≤ RUB
                for coin, price_usd in cg_prices.items():
                    rate_rub = price_usd * usd_rub_rate
                    if rate_rub > 0:
                        # –ù–∞–π—Ç–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Å–∏–º–≤–æ–ª
                        for sym, cid in cg_map.items():
                            if cid == coin:
                                crypto_from_bybit[sym] = rate_rub
                                if self.logger:
                                    self.logger.info(f"CoinGecko {sym}: {rate_rub} RUB")
                                break

        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã –≤ new_rates
        for coin, rate in crypto_from_bybit.items():
            new_rates[coin] = rate

        # --- 3. –ü—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ ---
        if new_rates.get("XAU", 0) > 0:
            new_rates["GRAM"] = new_rates["XAU"] / 31.1035
            if self.logger:
                self.logger.info(f"GRAM derived: {new_rates['GRAM']}")

        # --- 4. Telegram Stars (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫—É—Ä—Å) ---
        new_rates["STARS"] = 1.5

        # –û—á–∏—â–∞–µ–º –∫—ç—à –æ—Ç –Ω—É–ª–µ–≤—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
        self.rates_cache = {k: v for k, v in new_rates.items() if v > 0}
        self.last_update = time.time()

        if self.logger:
            self.logger.info(f"Rates updated. Loaded: {list(self.rates_cache.keys())}")

    def _fetch_gold_from_cbr(self, rates_dict, usd_rub_rate):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —É—á—ë—Ç–Ω—É—é —Ü–µ–Ω—É –∑–æ–ª–æ—Ç–∞ —Å –¶–ë –†–§ (–≤ —Ä—É–±–ª—è—Ö –∑–∞ –≥—Ä–∞–º–º) –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç XAU"""
        try:
            url = self._fetch_xml_with_date("https://www.cbr.ru/scripts/xml_metall.asp", "date_req")
            xml_data = self._fetch_url(url)
            root = ET.fromstring(xml_data)
            for metal in root.findall('Metal'):
                code = metal.find('Code').text  # 1 - –∑–æ–ª–æ—Ç–æ
                if code == "1":
                    buy = metal.find('Buy').text.replace(',', '.').strip()
                    sell = metal.find('Sell').text.replace(',', '.').strip()
                    # –ë–µ—Ä—ë–º —Å—Ä–µ–¥–Ω–µ–µ –∏–ª–∏ Buy –∫–∞–∫ —É—á—ë—Ç–Ω—É—é —Ü–µ–Ω—É (–æ–±—ã—á–Ω–æ Buy)
                    price_per_gram_rub = float(buy)
                    # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –≤ —Ç—Ä–æ–π—Å–∫–∏–µ —É–Ω—Ü–∏–∏ (1 —É–Ω—Ü–∏—è = 31.1035 –≥)
                    price_per_ounce_rub = price_per_gram_rub * 31.1035
                    if price_per_ounce_rub > 0:
                        rates_dict["XAU"] = price_per_ounce_rub
                        if self.logger:
                            self.logger.info("Gold rate fetched from CBR")
                    break
        except Exception as e:
            if self.logger:
                self.logger.warning(f"Failed to fetch gold from CBR: {e}")

    def _format_number(self, num):
        if num == 0:
            return "Err"
        if num < 0.000001:
            return f"{num:.8f}"
        if num < 0.01:
            return f"{num:.6f}"
        elif num < 100:
            return f"{num:.2f}"
        else:
            return "{:,.2f}".format(num)

    # --- –•—É–∫–∏ ---
    def on_plugin_load(self):
        if not self.lib_missing:
            try:
                self.logger = self.Dont65Utils.build_log(__id__)
                self.logger.info("Plugin loaded, library detected")

                self.Dont65Utils.add_autoupdater_task(
                    __id__,
                    AUTOUPDATE_CHANNEL_ID,
                    AUTOUPDATE_MSG_ID
                )
                self.logger.info("Auto-updater task registered (msg_id=14)")

                self.add_on_send_message_hook(priority=200)

            except Exception as e:
                log(f"[{__id__}] Error during library init: {traceback.format_exc()}")
                self.lib_missing = True
        else:
            log(f"[{__id__}] –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —Ö—É–∫ –∏ –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")

    def on_send_message_hook(self, account, params):
        try:
            if self.lib_missing:
                msg_text = params.message or params.caption or ""
                if msg_text.strip().startswith('.curs'):
                    header = "‚ùå –û—à–∏–±–∫–∞"
                    body = "–¢—Ä–µ–±—É–µ—Ç—Å—è Dont65 Library!\n–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–ª–∞–≥–∏–Ω `dont65_lib` –¥–ª—è —Ä–∞–±–æ—Ç—ã Currency Monitor."
                    params.message = f"**{header}**\n{body}"
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                return HookResult()

            if not self.get_setting("enable_plugin", True):
                return HookResult()

            msg_text = ""
            if hasattr(params, 'message') and params.message:
                msg_text = params.message
            elif hasattr(params, 'caption') and params.caption:
                msg_text = params.caption

            if not msg_text or not msg_text.lower().startswith(".curs"):
                return HookResult()

            # –ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
            raw_args = msg_text[5:].lower()
            clean_args = raw_args.replace('/', ' ').replace(' –∫ ', ' ').replace(' to ', ' ')
            tokens = clean_args.split()

            amount = 1.0
            currencies = []

            for token in tokens:
                if token in self.synonyms:
                    currencies.append(self.synonyms[token])
                else:
                    try:
                        amount = float(token.replace(',', '.'))
                    except:
                        pass

            if not currencies:
                currencies.append("RUB")

            self.update_rates()
            if not self.rates_cache:
                header = "‚ö†Ô∏è –û—à–∏–±–∫–∞"
                body = "–ö—É—Ä—Å—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã."
            else:
                source_curr = currencies[0]

                if source_curr not in self.rates_cache:
                    header = "‚ö†Ô∏è –û—à–∏–±–∫–∞"
                    body = f"–í–∞–ª—é—Ç–∞ {source_curr} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫—É—Ä—Å–∞—Ö."
                else:
                    src_rate = self.rates_cache[source_curr]
                    src_meta = self.meta.get(source_curr, {"flag": "üí∞", "name": source_curr})

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏—Å—Ö–æ–¥–Ω—ã–π –∫—É—Ä—Å –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω
                    if src_rate <= 0:
                        header = f"{src_meta['flag']} {src_meta['name']} {amount}"
                        body = "–ö—É—Ä—Å –∏—Å—Ö–æ–¥–Ω–æ–π –≤–∞–ª—é—Ç—ã –Ω–µ –ø–æ–ª—É—á–µ–Ω (–≤–æ–∑–º–æ–∂–Ω–æ, –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã —Å –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º)."
                    else:
                        header = f"{src_meta['flag']} {src_meta['name']} {amount} "
                        body_lines = []

                        # –†–ï–ñ–ò–ú 1: –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è –ø–∞—Ä–∞ (–Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ —É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è)
                        if len(currencies) >= 2:
                            target_curr = currencies[1]
                            if target_curr in self.rates_cache:
                                tgt_rate = self.rates_cache[target_curr]
                                if tgt_rate > 0:
                                    res = (amount * src_rate) / tgt_rate
                                    tgt_meta = self.meta.get(target_curr, {"flag": "üí∞", "name": target_curr})
                                    body_lines.append(f"{tgt_meta['flag']} {tgt_meta['name']} = `{self._format_number(res)}`")
                                else:
                                    body_lines.append(f"{target_curr} = Err (–∫—É—Ä—Å —Ü–µ–ª–µ–≤–æ–π –≤–∞–ª—é—Ç—ã –Ω–µ –ø–æ–ª—É—á–µ–Ω)")
                            else:
                                body_lines.append(f"{target_curr} = Err (–Ω–µ—Ç –≤ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫—É—Ä—Å–∞—Ö)")

                        # –†–ï–ñ–ò–ú 2: –ö–æ –≤—Å–µ–º –≤–∞–ª—é—Ç–∞–º (—Å —É—á—ë—Ç–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è)
                        else:
                            for target_code in self.display_order:
                                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∏—Å—Ö–æ–¥–Ω—É—é –≤–∞–ª—é—Ç—É
                                if target_code == source_curr:
                                    continue
                                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫—É –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                                if not self.get_setting(f"show_{target_code}", True):
                                    continue
                                if target_code not in self.rates_cache:
                                    continue
                                tgt_rate = self.rates_cache[target_code]
                                if tgt_rate == 0:
                                    continue
                                res = (amount * src_rate) / tgt_rate
                                tgt_meta = self.meta.get(target_code, {"flag": "üí∞", "name": target_code})
                                body_lines.append(f"{tgt_meta['flag']} {tgt_meta['name']} = `{self._format_number(res)}`")

                        body = "\n".join(body_lines)

                        if self.last_update > 0:
                            update_time = datetime.datetime.fromtimestamp(self.last_update).strftime("%d.%m.%Y %H:%M:%S")
                            body += f"\n\n‚è± *–û–±–Ω–æ–≤–ª–µ–Ω–æ:* {update_time} –ú–°–ö"

            new_params = self.Dont65Utils.reply_with_style(
                params,
                body=body,
                header=header,
                source=None,
                quote='block'
            )

            return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=new_params)

        except Exception as e:
            if self.logger:
                self.logger.error(f"Error in hook: {self.Dont65Utils.format_exc_only(e)}")
            else:
                log(f"[{__id__}] –û—à–∏–±–∫–∞:\n{traceback.format_exc()}")
            return HookResult()

    def on_plugin_unload(self):
        if not self.lib_missing and self.Dont65Utils:
            try:
                self.Dont65Utils.remove_autoupdater_task(__id__)
                if self.logger:
                    self.logger.info("Auto-updater task removed")
            except Exception as e:
                if self.logger:
                    self.logger.error(f"Failed to remove autoupdater task: {e}")