import threading, time, requests, urllib.parse, socket, os, traceback, base64, json, ctypes

from android.os import Build
from base_plugin import BasePlugin, MethodHook
from android_utils import log, run_on_ui_thread
from ui.bulletin import BulletinHelper
from ui.settings import Header, Text, Divider
from ui.alert import AlertDialogBuilder

from org.telegram.messenger import ApplicationLoader, SharedConfig, MessagesController, NotificationCenter, UserConfig, AndroidUtilities
from org.telegram.tgnet import ConnectionsManager
from org.telegram.ui.ActionBar import Theme, AlertDialog
from hook_utils import find_class, get_private_field, set_private_field
from client_utils import get_last_fragment
from java import dynamic_proxy

try:
    from java import jint, jlong
except ImportError:
    jint = int
    jlong = int

try:
    import ReMandre
except ImportError:
    ReMandre = None

__id__ = "Vless"
__name__ = "Vless"
__version__ = "1.0"
__author__ = "@swagnonher"
__description__ = "Плагин на проткол Vless нужен ReMandre"
__min_version__ = "12.0.1"

class Logger:
    TAG = "[MandreVless]"
    @staticmethod
    def d(msg): log(f"{Logger.TAG} {msg}")
    @staticmethod
    def e(msg, exc=None):
        if exc: log(f"{Logger.TAG} ERROR: {msg} | {exc}\n{traceback.format_exc()}")
        else: log(f"{Logger.TAG} ERROR: {msg}")

_cached_textview = None
_cached_checkimg = None

def init_ui_reflection():
    global _cached_textview, _cached_checkimg
    try:
        JavaClass = find_class("java.lang.Class")
        CellCls = JavaClass.forName("org.telegram.ui.ProxyListActivity$TextDetailProxyCell")
        if not CellCls: return
        fields = CellCls.getDeclaredFields()
        tv_counter = 0 
        for f in fields:
            f.setAccessible(True)
            type_name = f.getType().getName()
            if type_name == "android.widget.TextView":
                tv_counter += 1
                if tv_counter == 1: _cached_textview = f
            elif type_name == "android.widget.ImageView":
                _cached_checkimg = f
    except: pass

def safe_jint(val):
    try:
        v = int(val)
        if v > 0x7FFFFFFF: v -= 0x100000000
        return jint(v)
    except: return jint(0)

ProxyInfoClass = find_class("org.telegram.messenger.SharedConfig$ProxyInfo")
ViewClass = find_class("android.view.View")

class ViewClickProxy(dynamic_proxy(find_class("android.view.View$OnClickListener"))):
    def __init__(self, cb):
        super().__init__()
        self.cb = cb
    def onClick(self, v):
        self.cb()

class RowData:
    def __init__(self, vt, title="", uri="", sub_id=None, proxy_info=None, action_type=""):
        self.vt = vt
        self.title = title
        self.uri = uri
        self.sub_id = sub_id
        self.proxy_info = proxy_info
        self.action_type = action_type
        self.info_click = None

class NetUtils:
    @staticmethod
    def get_free_port() -> int:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('', 0))
                return s.getsockname()[1]
        except Exception as e:
            Logger.e("Failed to get free port", e)
            return 20808 

    @staticmethod
    def check_port(port: int, timeout: float = 0.2) -> bool:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                return s.connect_ex(('127.0.0.1', port)) == 0
        except: return False

    @staticmethod
    def tcp_ping(uri_str: str, timeout: float = 1.5) -> int:
        try:
            part = uri_str.replace("vless://", "")
            if "@" not in part: return 9999
            host_port = part.split("@", 1)[1].split("?", 1)[0].split("#", 1)[0]
            if ":" not in host_port: return 9999
            host, port = host_port.split(":", 1)
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)
                start_time = time.time()
                s.connect((host, int(port)))
                return int((time.time() - start_time) * 1000)
        except: return 9999

class ConfigParser:
    @staticmethod
    def parse(uri_str: str, local_port: int) -> tuple:
        try:
            if not uri_str or not uri_str.startswith("vless://"): return None, None
            part = uri_str[8:]
            name = "VLESS Node"
            if "#" in part:
                part, name = part.split("#", 1)
                name = urllib.parse.unquote(name).strip() or name
            if "@" not in part: return None, None
            uuid_str, rest = part.split("@", 1)
            if "?" in rest: host_port, params_raw = rest.split("?", 1)
            else: host_port, params_raw = rest, ""
            
            if ":" not in host_port: return None, None
            host, port = host_port.split(":", 1)
            try: port = int(port)
            except: return None, None

            params = {}
            if params_raw:
                for pair in params_raw.split("&"):
                    if "=" in pair:
                        k, v = pair.split("=", 1)
                        params[k] = urllib.parse.unquote(v)
                        
            config = {
                "log": {"loglevel": "none"},
                "inbounds": [{"tag": "socks-in", "port": local_port, "listen": "127.0.0.1", "protocol": "socks", "settings": {"auth": "noauth", "udp": True, "ip": "127.0.0.1"}, "sniffing": {"enabled": True, "destOverride": ["http", "tls"], "routeOnly": False}}],
                "outbounds": [{"tag": "proxy", "protocol": "vless", "settings": {"vnext": [{"address": host, "port": port, "users": [{"id": uuid_str, "encryption": "none", "flow": params.get("flow", "")}]}]}, "streamSettings": {"network": params.get("type", "tcp"), "security": params.get("security", "none")}}]
            }
            stream = config["outbounds"][0]["streamSettings"]
            fp = params.get("fp", "chrome")
            if params.get("security") == "reality": stream["realitySettings"] = {"show": False, "fingerprint": fp, "serverName": params.get("sni", ""), "publicKey": params.get("pbk", ""), "shortId": params.get("sid", ""), "spiderX": params.get("spx", "")}
            elif params.get("security") == "tls": stream["tlsSettings"] = {"serverName": params.get("sni", ""), "allowInsecure": False, "fingerprint": fp}
            net = params.get("type", "tcp")
            if net == "ws": stream["wsSettings"] = {"path": params.get("path", "/"), "headers": {"Host": params.get("host", params.get("sni", ""))}}
            elif net == "grpc": stream["grpcSettings"] = {"serviceName": params.get("serviceName", ""), "multiMode": params.get("mode", "multi") == "multi"}
            
            return json.dumps(config), name
        except Exception as e:
            Logger.e("Parse error", e)
            return None, None

# --- Самостоятельный NativeLinker для загрузки .so без участия ReMandre ---
class NativeLinker:
    def __init__(self):
        self.libdl = ctypes.CDLL("libdl.so")
        try:
            self.open_ext = self.libdl.android_dlopen_ext
            class Info(ctypes.Structure):
                _fields_ = [
                    ("flags", ctypes.c_uint64), 
                    ("reserved_addr", ctypes.c_void_p), 
                    ("reserved_size", ctypes.c_size_t), 
                    ("relro_fd", ctypes.c_int), 
                    ("library_fd", ctypes.c_int), 
                    ("library_fd_offset", ctypes.c_uint64), 
                    ("library_namespace", ctypes.c_void_p)
                ]
            self.Info = Info
            self.open_ext.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.POINTER(self.Info)]
            self.open_ext.restype = ctypes.c_void_p
        except: 
            self.open_ext = None

    def load(self, path: str):
        if not os.path.exists(path): return None
        if Build.VERSION.SDK_INT >= 29 and self.open_ext:
            fd = os.open(path, os.O_RDONLY)
            try:
                info = self.Info(flags=0x10, library_fd=fd)
                h = self.open_ext(path.encode(), 2 | 0x100, ctypes.byref(info))
                if h: return ctypes.CDLL(path, handle=h)
            except Exception as e: Logger.e("NativeLinker: ext_err", e)
            finally: os.close(fd)
        try: return ctypes.CDLL(path, mode=2 | 0x100)
        except Exception as e:
            Logger.e("NativeLinker generic err", e)
            return None

class VlessCore:
    def __init__(self):
        self.mode = None 
        self.lib = None
        self.ffi = None
        self.libc = None
        self.is_downloading = False

    def init_native(self, on_success=None, on_error=None):
        if self.is_available():
            if on_success: on_success()
            return

        def init_task():
            self.is_downloading = True
            try:
                ctx = ApplicationLoader.applicationContext
                dir_path = os.path.join(str(ctx.getFilesDir()), "remandre_modules")
                if not os.path.exists(dir_path): os.makedirs(dir_path)
                so_path = os.path.join(dir_path, "libvless.so")

                # Самостоятельная загрузка ядра, если его нет
                if not os.path.exists(so_path) or os.path.getsize(so_path) < 1024:
                    Logger.d("libvless.so not found, self-downloading fallback...")
                    run_on_ui_thread(lambda: BulletinHelper.show_info("Скачивание ядра VLESS..."))
                    url = "https://github.com/coidarashka/MandreLib-Modules/releases/download/LocalAiChat/libvless.so"
                    r = requests.get(url, stream=True, timeout=30)
                    r.raise_for_status()
                    with open(so_path, "wb") as f:
                        for chunk in r.iter_content(8192): f.write(chunk)
                    Logger.d("libvless.so downloaded successfully.")

                # Сначала пытаемся через CFFI
                try:
                    import cffi
                    self.ffi = cffi.FFI()
                    self.ffi.cdef("char* StartCore(char* configContent); void StopCore(); void free(void *ptr);")
                    self.lib = self.ffi.dlopen(so_path)
                    try: self.libc = self.ffi.dlopen("libc.so")
                    except: pass
                    self.mode = "cffi"
                    Logger.d("Core initialized using CFFI")
                except Exception as e:
                    Logger.e("CFFI Init failed, falling back to standalone ctypes + NativeLinker", e)
                    
                    # CFFI недоступен или упал - используем встроенный линкер
                    linker = NativeLinker()
                    self.lib = linker.load(so_path)
                    if self.lib:
                        self.lib.StartCore.argtypes = [ctypes.c_char_p]
                        self.lib.StartCore.restype = ctypes.c_void_p
                        self.lib.StopCore.argtypes = []
                        self.lib.StopCore.restype = None
                        try:
                            self.libc = ctypes.CDLL("libc.so")
                            self.libc.free.argtypes = [ctypes.c_void_p]
                            self.libc.free.restype = None
                        except: pass
                        self.mode = "ctypes"
                        Logger.d("Core initialized using standalone NativeLinker")
                    else:
                        raise Exception("NativeLinker failed to inject library")

                self.is_downloading = False
                if self.is_available() and on_success:
                    on_success()

            except Exception as e:
                self.is_downloading = False
                Logger.e("Failed to init native core", e)
                if on_error: on_error(str(e))

        threading.Thread(target=init_task, daemon=True).start()

    def is_available(self) -> bool: return self.mode is not None
    
    def start(self, config_json: str) -> str:
        if not self.is_available(): return "Native library not loaded"
        try:
            if self.mode == "cffi":
                c_config = self.ffi.new("char[]", config_json.encode('utf-8'))
                res_ptr = self.lib.StartCore(c_config)
                if res_ptr != self.ffi.NULL:
                    res_str = self.ffi.string(res_ptr).decode('utf-8', errors='ignore')
                    if self.libc: self.libc.free(res_ptr)
                    return res_str
                return ""
                
            elif self.mode == "ctypes":
                c_config = config_json.encode('utf-8')
                res_ptr = self.lib.StartCore(c_config)
                if res_ptr:
                    res_str = ctypes.cast(res_ptr, ctypes.c_char_p).value.decode('utf-8', errors='ignore')
                    if self.libc: self.libc.free(res_ptr)
                    return res_str
                return ""
                
        except Exception as e: 
            Logger.e("Start core error", e)
            return str(e)
        
    def stop(self):
        if self.is_available():
            try: self.lib.StopCore()
            except Exception as e: Logger.e("Stop core error", e)

class TelegramProxy:
    @staticmethod
    def cleanup_local_proxies():
        try:
            proxy_list = SharedConfig.proxyList
            if proxy_list:
                to_remove = []
                for i in range(proxy_list.size()):
                    p = proxy_list.get(i)
                    if str(p.address) == "127.0.0.1":
                        to_remove.append(p)
                for p in to_remove:
                    SharedConfig.deleteProxy(p)
            
            curr = SharedConfig.currentProxy
            if curr and str(curr.address) == "127.0.0.1":
                SharedConfig.currentProxy = None
                
            SharedConfig.proxyEnabled = False
            prefs = MessagesController.getGlobalMainSettings()
            prefs.edit().putBoolean("proxy_enabled", False).apply()
            SharedConfig.saveProxyList()
            SharedConfig.saveConfig()
            
            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                cm = ConnectionsManager.getInstance(ac)
                if cm: cm.setProxySettings(False, "", 0, "", "", "")
                
        except Exception as e:
            Logger.e("Cleanup Error", e)

    @staticmethod
    def apply(port: int, enable: bool):
        try:
            prefs = MessagesController.getGlobalMainSettings()
            ed = prefs.edit()

            TelegramProxy.cleanup_local_proxies()

            if enable:
                proxy_obj = ProxyInfoClass("127.0.0.1", port, "", "", "")
                SharedConfig.addProxy(proxy_obj)
                SharedConfig.currentProxy = proxy_obj
                SharedConfig.proxyEnabled = True
                
                ed.putString("proxy_ip", "127.0.0.1"); ed.putInt("proxy_port", port)
                ed.putString("proxy_user", ""); ed.putString("proxy_pass", ""); ed.putString("proxy_secret", "")
                ed.putBoolean("proxy_enabled", True)
            else:
                SharedConfig.proxyEnabled = False
                ed.putBoolean("proxy_enabled", False)
            
            ed.apply()
            SharedConfig.saveConfig()

            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                cm = ConnectionsManager.getInstance(ac)
                if cm:
                    if enable: cm.setProxySettings(True, "127.0.0.1", port, "", "", "")
                    else: cm.setProxySettings(False, "", 0, "", "", "")

            def notify():
                try:
                    from java import jarray; from java.lang import Object
                    NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged, jarray(Object)(0))
                except: pass
            run_on_ui_thread(notify, 300)
        except Exception as e: Logger.e("Telegram Proxy Error", e)

class AlwaysShowShieldHook(MethodHook):
    def __init__(self, plugin): self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            proxy_item = get_private_field(dialogs_activity, "proxyItem")
            if not proxy_item:
                fields = dialogs_activity.getClass().getDeclaredFields()
                for f in fields:
                    if "ActionBarMenuItem" in f.getType().getName():
                        f.setAccessible(True)
                        item = f.get(dialogs_activity)
                        if item: item.setVisibility(0)
            if proxy_item:
                proxy_item.setVisibility(0)
                set_private_field(dialogs_activity, "proxyItemVisible", True)
        except: pass

class ProxyListInjector:
    def __init__(self, plugin): self.p = plugin; self.installed = False
    def install(self):
        if self.installed: return
        try:
            JavaClass = find_class("java.lang.Class")
            ActivityJavaCls = JavaClass.forName("org.telegram.ui.ProxyListActivity")
            AdapterJavaCls = JavaClass.forName("org.telegram.ui.ProxyListActivity$ListAdapter")
            methods = {
                "updateRows": ActivityJavaCls, "getItemCount": AdapterJavaCls,
                "getItemViewType": AdapterJavaCls, "onBindViewHolder": AdapterJavaCls, 
                "getItemId": AdapterJavaCls, "createView": ActivityJavaCls
            }
            for m_name, cls in methods.items():
                for m in cls.getDeclaredMethods():
                    if m.getName() == m_name:
                        if m_name == "onBindViewHolder" and len(m.getParameterTypes()) != 2: continue
                        self.p.hook_method(m, getattr(self, f"{m_name[0].upper() + m_name[1:]}Hook")(self.p))
                        break
            self.installed = True
        except: pass

    class UpdateRowsHook(MethodHook):
        def __init__(self, p): self.p = p
        def after_hooked_method(self, param):
            try:
                row_count = get_private_field(param.thisObject, "rowCount")
                row_count = int(row_count) if row_count else 0
                self.p.vless_start_row = row_count
                self.p._rebuild_fast_layout()
                set_private_field(param.thisObject, "rowCount", safe_jint(row_count + len(self.p.fast_layout)))
            except: pass

    class GetItemCountHook(MethodHook):
        def __init__(self, p): self.p = p
        def after_hooked_method(self, param):
            try:
                orig = param.getResult(); orig = int(orig) if orig else 0
                param.setResult(safe_jint(orig + len(self.p.fast_layout)))
            except: pass

    class GetItemIdHook(MethodHook):
        def __init__(self, p): self.p = p
        def after_hooked_method(self, param):
            try:
                pos = int(param.args[0])
                if pos >= self.p.vless_start_row:
                    idx = pos - self.p.vless_start_row
                    if idx < len(self.p.fast_layout):
                        item_id = hash(self.p.fast_layout[idx].title + str(idx)) & 0x7FFFFFFFFFFFFFFF
                        param.setResult(jlong(item_id))
            except: pass

    class GetItemViewTypeHook(MethodHook):
        def __init__(self, p): self.p = p
        def before_hooked_method(self, param):
            try:
                pos = int(param.args[0])
                if pos >= self.p.vless_start_row:
                    idx = pos - self.p.vless_start_row
                    if idx < len(self.p.fast_layout):
                        param.setResult(safe_jint(self.p.fast_layout[idx].vt))
            except: pass

    class OnBindViewHolderHook(MethodHook):
        def __init__(self, p): self.p = p
        def before_hooked_method(self, param):
            try:
                pos = int(param.args[1])
                if pos >= self.p.vless_start_row:
                    idx = pos - self.p.vless_start_row
                    ui = self.p.fast_layout
                    if idx < len(ui):
                        row = ui[idx]
                        view = param.args[0].itemView
                        if row.vt == 5: 
                            view.setProxy(row.proxy_info)
                            view.setChecked(self.p.active_uri == row.uri)
                            view.updateStatus()
                            if _cached_textview:
                                try:
                                    tv = _cached_textview.get(view)
                                    if tv: tv.setText(row.title)
                                except: pass
                            if _cached_checkimg and row.info_click:
                                try:
                                    img = _cached_checkimg.get(view)
                                    if img: img.setOnClickListener(row.info_click)
                                except: pass
                        elif row.vt == 1:
                            view.setText(row.title, row.sub_id is not None)
                            if row.action_type == "delete_sub": view.setTextColor(Theme.getColor(Theme.key_text_RedRegular))
                            else: view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueText4))
                        elif row.vt == 2: view.setText(row.title)
                        param.setResult(None) 
            except Exception: pass

    class CreateViewHook(MethodHook):
        def __init__(self, p): self.p = p
        def after_hooked_method(self, param):
            try:
                listView = get_private_field(param.thisObject, "listView")
                if not listView: return
                self.p._list_view = listView 
                orig_l = get_private_field(listView, "onItemClickListener")
                orig_ll = get_private_field(listView, "onItemLongClickListener")
                
                ListenerCls = find_class("org.telegram.ui.Components.RecyclerListView$OnItemClickListener")
                class WrappedClick(dynamic_proxy(ListenerCls)):
                    def __init__(self, p, orig): super().__init__(); self.p, self.orig = p, orig
                    def onItemClick(self, view, pos):
                        pos = int(pos)
                        if pos >= self.p.vless_start_row: self.p._handle_click(pos - self.p.vless_start_row)
                        elif self.orig: self.orig.onItemClick(view, pos)
                listView.setOnItemClickListener(WrappedClick(self.p, orig_l))
                
                LongListenerCls = find_class("org.telegram.ui.Components.RecyclerListView$OnItemLongClickListener")
                class WrappedLongClick(dynamic_proxy(LongListenerCls)):
                    def __init__(self, p, orig): super().__init__(); self.p, self.orig = p, orig
                    def onItemClick(self, view, pos):
                        pos = int(pos)
                        if pos >= self.p.vless_start_row: return self.p._handle_long_click(pos - self.p.vless_start_row)
                        if self.orig: return self.orig.onItemClick(view, pos)
                        return False
                listView.setOnItemLongClickListener(WrappedLongClick(self.p, orig_ll))
                self.p._list_adapter = listView.getAdapter()
            except: pass

class ProxySettingsInjector:
    def __init__(self, plugin):
        self.p = plugin; self.installed = False; self.current_mode = -1
        self.native_fields = []; self.radio_cells = []; self.input_field = None; self.vless_layout = None; self.done_item = None

    def install(self):
        if self.installed: return
        try:
            JavaClass = find_class("java.lang.Class")
            ActivityCls = JavaClass.forName("org.telegram.ui.ProxySettingsActivity")
            create_view_method = ActivityCls.getDeclaredMethod("createView", JavaClass.forName("android.content.Context"))
            self.p.hook_method(create_view_method, self.CreateViewHook(self, self.p))
            self.installed = True
        except: pass

    def update_ui(self):
        for i, cell in enumerate(self.radio_cells):
            if self.current_mode == -1: is_checked = False if i >= len(self.radio_cells) - 2 else None
            else: is_checked = (i == len(self.radio_cells) - 2 + self.current_mode)
            if is_checked is not None: cell.setChecked(is_checked, True)
        if self.current_mode == -1:
            for v in self.native_fields: v.setVisibility(0)
            if self.vless_layout: self.vless_layout.setVisibility(8)
            if self.done_item: self.done_item.setEnabled(True); self.done_item.setAlpha(1.0)
        else:
            for v in self.native_fields: v.setVisibility(8)
            if self.vless_layout: self.vless_layout.setVisibility(0)
            if self.input_field: self.input_field.setHintText("Вставьте ключ vless://" if self.current_mode == 0 else "Ссылка на подписку https://")
            self.check_done_button()

    def check_done_button(self):
        if not self.done_item or not self.input_field: return
        text_obj = self.input_field.getText()
        text = str(text_obj.toString()).strip() if text_obj else ""
        is_enabled = len(text) > 5
        self.done_item.setEnabled(is_enabled)
        self.done_item.setAlpha(1.0 if is_enabled else 0.5)

    class CreateViewHook(MethodHook):
        def __init__(self, inj, p): self.inj, self.p = inj, p
        def after_hooked_method(self, param):
            try:
                activity = param.thisObject; context = param.args[0]
                self.inj.done_item = get_private_field(activity, "doneItem")
                ll2_container = get_private_field(activity, "linearLayout2")
                container_fields = get_private_field(activity, "inputFieldsContainer")
                if not ll2_container or not container_fields: return
                RadioCell = find_class("org.telegram.ui.Cells.RadioCell")
                LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
                EditTextBoldCursor = find_class("org.telegram.ui.Components.EditTextBoldCursor")
                TextSettingsCell = find_class("org.telegram.ui.Cells.TextSettingsCell")
                self.inj.native_fields = [container_fields.getChildAt(i) for i in range(container_fields.getChildCount())]
                self.inj.radio_cells = [ll2_container.getChildAt(i) for i in range(ll2_container.getChildCount()) if "RadioCell" in str(ll2_container.getChildAt(i).getClass().getName())]
                insert_idx = ll2_container.indexOfChild(self.inj.radio_cells[-1]) + 1 if self.inj.radio_cells else 2
                cell_key = RadioCell(context); cell_key.setBackground(Theme.getSelectorDrawable(True)); cell_key.setText("VLESS Ключ", False, True)
                cell_sub = RadioCell(context); cell_sub.setBackground(Theme.getSelectorDrawable(True)); cell_sub.setText("VLESS Подписка", False, False)
                self.inj.radio_cells.extend([cell_key, cell_sub])
                ll2_container.addView(cell_key, insert_idx, LayoutHelper.createLinear(-1, 50))
                ll2_container.addView(cell_sub, insert_idx + 1, LayoutHelper.createLinear(-1, 50))
                LinearLayout = find_class("android.widget.LinearLayout")
                self.inj.vless_layout = LinearLayout(context); self.inj.vless_layout.setOrientation(1); self.inj.vless_layout.setVisibility(8)
                container_fields.addView(self.inj.vless_layout, LayoutHelper.createLinear(-1, -2))
                self.inj.input_field = EditTextBoldCursor(context); self.inj.input_field.setTextSize(1, 16.0)
                self.inj.input_field.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                self.inj.input_field.setHintColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
                self.inj.input_field.setBackground(None); self.inj.input_field.setPadding(0, AndroidUtilities.dp(12), 0, AndroidUtilities.dp(12))
                TextWatcher = find_class("android.text.TextWatcher")
                class Watcher(dynamic_proxy(TextWatcher)):
                    def __init__(self, inj): super().__init__(); self.inj = inj
                    def beforeTextChanged(self, s, start, count, after): pass
                    def onTextChanged(self, s, start, before, count): pass
                    def afterTextChanged(self, s): self.inj.check_done_button()
                self.inj.input_field.addTextChangedListener(Watcher(self.inj))
                
                paste_btn = TextSettingsCell(context); paste_btn.setBackground(Theme.getSelectorDrawable(True))
                paste_btn.setText("Вставить из буфера обмена", False)
                paste_btn.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueText4))
                
                class PasteClick(dynamic_proxy(ViewClass.OnClickListener)):
                    def __init__(self, inj): super().__init__(); self.inj = inj
                    def onClick(self, v):
                        def do_paste():
                            try:
                                ContextCls = find_class("android.content.Context")
                                ctx_app = ApplicationLoader.applicationContext
                                man = ctx_app.getSystemService(ContextCls.CLIPBOARD_SERVICE)
                                if man and man.hasPrimaryClip():
                                    clip = man.getPrimaryClip()
                                    if clip and clip.getItemCount() > 0:
                                        item = clip.getItemAt(0)
                                        text_obj = item.getText()
                                        if not text_obj:
                                            text_obj = item.coerceToText(ctx_app)
                                        
                                        if text_obj:
                                            pasted_str = str(text_obj.toString())
                                            self.inj.input_field.setText(pasted_str)
                                            self.inj.input_field.setSelection(len(pasted_str))
                                            self.inj.check_done_button()
                                            return
                                BulletinHelper.show_error("Буфер обмена пуст или не содержит текст")
                            except Exception as e: 
                                Logger.e("Paste failed", e)
                                BulletinHelper.show_error("Ошибка при вставке")
                        run_on_ui_thread(do_paste)
                paste_btn.setOnClickListener(PasteClick(self.inj))
                
                self.inj.vless_layout.addView(self.inj.input_field, LayoutHelper.createLinear(-1, -2, 17, 0, 17, 0))
                self.inj.vless_layout.addView(paste_btn, LayoutHelper.createLinear(-1, -2))
                
                class ClickListener(dynamic_proxy(ViewClass.OnClickListener)):
                    def __init__(self, inj, mode): super().__init__(); self.inj, self.mode = inj, mode
                    def onClick(self, v): self.inj.current_mode = self.mode; self.inj.update_ui()
                for i in range(len(self.inj.radio_cells) - 2):
                    cell = self.inj.radio_cells[i]; orig = get_private_field(cell, "mOnClickListener")
                    class ProxyClick(dynamic_proxy(ViewClass.OnClickListener)):
                        def __init__(self, inj, orig): super().__init__(); self.inj, self.orig = inj, orig
                        def onClick(self, v): 
                            self.inj.current_mode = -1; self.inj.update_ui(); 
                            if self.orig: self.orig.onClick(v)
                    cell.setOnClickListener(ProxyClick(self.inj, orig))
                cell_key.setOnClickListener(ClickListener(self.inj, 0))
                cell_sub.setOnClickListener(ClickListener(self.inj, 1))
                
                action_bar = get_private_field(activity, "actionBar")
                if action_bar:
                    listener = action_bar.getActionBarMenuOnItemClick()
                    if listener:
                        listener_cls = listener.getClass()
                        for m in listener_cls.getDeclaredMethods():
                            if m.getName() == "onItemClick" and len(m.getParameterTypes()) == 1:
                                class DoneHook(MethodHook):
                                    def __init__(self, injector, act): self.inj = injector; self.act = act
                                    def before_hooked_method(self, param):
                                        try:
                                            if int(param.args[0]) == 1 and self.inj.current_mode != -1:
                                                param.setResult(None) 
                                                text_obj = self.inj.input_field.getText()
                                                text = str(text_obj.toString()).strip() if text_obj else ""
                                                if self.inj.current_mode == 0: self.inj.p._do_add_key(text, self.act)
                                                else: self.inj.p._do_add_sub(text, self.act)
                                        except Exception as e: 
                                            Logger.e("Done button hook failed", e)
                                self.p.hook_method(m, DoneHook(self.inj, activity))
                                break
            except Exception as e: 
                Logger.e("CreateViewHook failed", e)

class VlessPlugin(BasePlugin):
    __ReqRements__ = {"libvless": "https://github.com/coidarashka/MandreLib-Modules/releases/download/LocalAiChat/libvless.so - need"}

    def on_plugin_load(self):
        # 1. Попытка инициализации через ReMandre (если установлен и включен)
        if ReMandre:
            try: ReMandre.ReMandreCore.initialize(self)
            except Exception as e: Logger.e("ReMandre init failed", e)

        init_ui_reflection()

        try:
            JavaClass = find_class("java.lang.Class")
            DialogsActClass = JavaClass.forName("org.telegram.ui.DialogsActivity")
            jbool = find_class("java.lang.Boolean").TYPE
            m = DialogsActClass.getDeclaredMethod("updateProxyButton", jbool, jbool)
            if m:
                m.setAccessible(True)
                self.hook_method(m, AlwaysShowShieldHook(self))
        except: pass

        self.core = VlessCore()
        
        # 2. Вызываем асинхронную подгрузку и инициализацию нативного ядра
        self.core.init_native()

        self.data = self.get_setting("vless_data", {"manual": [], "subs": [], "active_uri": ""})
        
        self.active_uri = ""
        self._save_data()
        TelegramProxy.cleanup_local_proxies()

        self.local_port = 20808; self.is_running = False
        self.fast_layout = []; self.vless_start_row = 999
        self._list_adapter = None; self._list_view = None

        self.list_injector = ProxyListInjector(self); self.list_injector.install()
        self.settings_injector = ProxySettingsInjector(self); self.settings_injector.install()
        
        threading.Thread(target=self._pinger_loop, daemon=True).start()

    def on_plugin_unload(self): self._disconnect(silent=True)
    def _save_data(self): self.data["active_uri"] = self.active_uri; self.set_setting("vless_data", self.data)

    def create_settings(self): return []

    def _clear_all_data(self):
        self._disconnect(silent=True)
        self.data = {"manual": [], "subs": [], "active_uri": ""}
        self.active_uri = ""
        self._save_data(); self._force_tg_rows_update()
        BulletinHelper.show_success("Данные очищены")

    def _open_tg_proxy_screen(self): 
        try: get_last_fragment().presentFragment(find_class("org.telegram.ui.ProxyListActivity")())
        except: pass

    def _rebuild_fast_layout(self):
        self.fast_layout = []
        if not ProxyInfoClass: return

        if self.data.get("manual"):
            self.fast_layout.append(RowData(0)) 
            self.fast_layout.append(RowData(2, title="Ключи VLESS")) 
            for node in self.data["manual"]:
                info = ProxyInfoClass("127.0.0.1", 1080, "", "", "") 
                ping = node.get("ping", 9999)
                info.ping = ping if ping >= 0 else 0
                info.available = (0 <= ping < 2000)
                info.checking = (ping == -1)
                
                r = RowData(5, uri=node["uri"], proxy_info=info, title=node["name"])
                r.info_click = ViewClickProxy(lambda u=node["uri"]: self._ask_delete_key(u, None))
                self.fast_layout.append(r)
        
        for sub in self.data.get("subs", []):
            nodes = sub.get("nodes", [])
            if not nodes: continue
            url_id = sub["url"]
            self.fast_layout.append(RowData(0))
            self.fast_layout.append(RowData(2, title=f"{sub['name']} ({len(nodes)} узлов)"))
            
            for node in nodes:
                info = ProxyInfoClass("127.0.0.1", 1080, "", "", "")
                ping = node.get("ping", 9999)
                info.ping = ping if ping >= 0 else 0
                info.available = (0 <= ping < 2000)
                info.checking = (ping == -1)
                
                r = RowData(5, uri=node["uri"], proxy_info=info, sub_id=url_id, title=node["name"])
                r.info_click = ViewClickProxy(lambda u=node["uri"], s=url_id: self._ask_delete_key(u, None) if s is None else self._ask_delete_sub(s))
                self.fast_layout.append(r)

            self.fast_layout.append(RowData(1, action_type="update", sub_id=url_id, title="Обновить подписку"))
            self.fast_layout.append(RowData(1, action_type="delete_sub", sub_id=url_id, title="Удалить подписку"))
            
        if self.fast_layout: self.fast_layout.append(RowData(0))

    def _notify_node_changed(self, uri):
        node_idx = -1
        for idx, item in enumerate(self.fast_layout):
            if item.vt == 5 and item.uri == uri:
                node_idx = idx
                break
                
        if node_idx != -1:
            if not self._list_adapter or not self._list_view: return
            try:
                state = self._list_view.getScrollState()
                is_comp_func = getattr(self._list_view, "isComputingLayout", None)
                if state == 0 and not (is_comp_func and is_comp_func()):
                    self._list_adapter.notifyItemChanged(self.vless_start_row + node_idx)
            except: pass

    def _force_tg_rows_update(self):
        self._rebuild_fast_layout()
        def safe_notify():
            if not self._list_adapter: return
            try:
                if self._list_view:
                    state = self._list_view.getScrollState()
                    is_comp = getattr(self._list_view, "isComputingLayout", None)
                    if state != 0 or (is_comp and is_comp()):
                        return 
                self._list_adapter.notifyDataSetChanged()
            except: pass
        run_on_ui_thread(safe_notify)

    def _handle_click(self, idx):
        item = self.fast_layout[idx]
        if item.vt == 1:
            if item.action_type == "update": self._update_sub(item.sub_id)
            elif item.action_type == "delete_sub": self._ask_delete_sub(item.sub_id)
        elif item.vt == 5:
            if self.active_uri == item.uri:
                self.active_uri = ""; self._disconnect()
                self._save_data(); self._force_tg_rows_update()
            else:
                self.active_uri = item.uri
                self._save_data(); self._force_tg_rows_update()
                run_on_ui_thread(self._connect, delay=100)

    def _handle_long_click(self, idx):
        item = self.fast_layout[idx]
        if item.vt == 5 and not item.sub_id:
            self._ask_delete_key(item.uri, None)
            return True
        return False

    def _ask_delete_key(self, uri, dialog_to_dismiss):
        if dialog_to_dismiss: dialog_to_dismiss.dismiss()
        frag = get_last_fragment()
        if not frag: return
        builder = AlertDialogBuilder(frag.getParentActivity())
        builder.set_title("Удаление ключа")
        builder.set_message("Удалить этот ключ?")
        builder.set_positive_button("Удалить", lambda d, w: self._do_del_key(uri, d))
        builder.set_negative_button("Отмена", lambda d, w: d.dismiss())
        builder.make_button_red(-1); builder.show()

    def _ask_delete_sub(self, sub_id):
        frag = get_last_fragment()
        if not frag: return
        builder = AlertDialogBuilder(frag.getParentActivity())
        builder.set_title("Удаление подписки")
        builder.set_message("Вы уверены, что хотите удалить эту подписку и все её серверы?")
        builder.set_positive_button("Удалить", lambda d, w: self._do_del_sub(sub_id, d))
        builder.set_negative_button("Отмена", lambda d, w: d.dismiss())
        builder.make_button_red(-1); builder.show()

    def _do_add_key(self, text, activity):
        if not text.startswith("vless://"): 
            run_on_ui_thread(lambda: BulletinHelper.show_error("Неверный формат ключа"))
            return
        conf, name = ConfigParser.parse(text, 1080)
        if not conf: 
            run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка парсинга конфига"))
            return
            
        if "manual" not in self.data: self.data["manual"] = []
        self.data["manual"].append({"name": name, "uri": text, "ping": -1})
        self._save_data(); self._force_tg_rows_update()
        try: activity.finishFragment()
        except: pass

    def _do_add_sub(self, url, activity):
        if not url.startswith("http"): 
            run_on_ui_thread(lambda: BulletinHelper.show_error("Неверная ссылка"))
            return
            
        def task():
            try:
                run_on_ui_thread(lambda: BulletinHelper.show_info("Загрузка..."))
                r = requests.get(url, timeout=15); text = r.text.strip()
                if "vless://" not in text:
                    try: 
                        missing_padding = len(text) % 4
                        if missing_padding: text += '=' * (4 - missing_padding)
                        text = base64.b64decode(text, validate=False).decode('utf-8', errors='ignore')
                    except Exception as e: Logger.e("Base64 Decode Error", e)
                nodes = []
                for line in text.splitlines():
                    line = line.strip()
                    if line.startswith("vless://"):
                        conf, name = ConfigParser.parse(line, 1080)
                        if conf: nodes.append({"name": name, "uri": line, "ping": -1})
                if nodes:
                    if "subs" not in self.data: self.data["subs"] = []
                    self.data["subs"].append({"id": url, "url": url, "name": urllib.parse.urlparse(url).netloc, "nodes": nodes})
                    self._save_data()
                    run_on_ui_thread(lambda: (self._force_tg_rows_update(), BulletinHelper.show_success(f"Добавлено: {len(nodes)}"), activity.finishFragment()))
                else: run_on_ui_thread(lambda: BulletinHelper.show_error("VLESS конфигураций не найдено"))
            except Exception as e: 
                Logger.e("Sub Fetch Error", e)
                run_on_ui_thread(lambda: BulletinHelper.show_error("Ошибка сети"))
        threading.Thread(target=task, daemon=True).start()

    def _update_sub(self, url):
        run_on_ui_thread(lambda: BulletinHelper.show_info("Обновление..."))
        def task():
            changed = False
            for sub in self.data.get("subs", []):
                if sub["url"] != url: continue
                try:
                    r = requests.get(url, timeout=15); text = r.text.strip()
                    if "vless://" not in text:
                        try: 
                            missing_padding = len(text) % 4
                            if missing_padding: text += '=' * (4 - missing_padding)
                            text = base64.b64decode(text, validate=False).decode('utf-8', errors='ignore')
                        except: pass
                    nodes = []
                    for line in text.splitlines():
                        line = line.strip()
                        if line.startswith("vless://"):
                            conf, name = ConfigParser.parse(line, 1080)
                            if conf: nodes.append({"name": name, "uri": line, "ping": -1})
                    if nodes: sub["nodes"] = nodes; changed = True
                except: pass
            if changed: 
                self._save_data()
                run_on_ui_thread(lambda: (self._force_tg_rows_update(), BulletinHelper.show_success("Подписка обновлена")))
            else: run_on_ui_thread(lambda: BulletinHelper.show_error("Сбой обновления"))
        threading.Thread(target=task, daemon=True).start()

    def _do_del_key(self, uri, dialog):
        if dialog: dialog.dismiss()
        self.data["manual"] = [k for k in self.data.get("manual", []) if k["uri"] != uri]
        if self.active_uri == uri: self.active_uri = ""; self._disconnect()
        self._save_data(); self._force_tg_rows_update()

    def _do_del_sub(self, url, dialog):
        if dialog: dialog.dismiss()
        for sub in self.data.get("subs", []):
            if sub["url"] == url:
                if any(n["uri"] == self.active_uri for n in sub["nodes"]): self.active_uri = ""; self._disconnect()
        self.data["subs"] = [s for s in self.data.get("subs", []) if s["url"] != url]
        self._save_data(); self._force_tg_rows_update()

    def _connect(self):
        if not self.active_uri: return
        self._disconnect(silent=True)
        
        def proceed_connect():
            self.local_port = NetUtils.get_free_port()
            config_json, _ = ConfigParser.parse(self.active_uri, self.local_port)
            if not config_json: 
                run_on_ui_thread(lambda: BulletinHelper.show_error("Сбой парсинга конфига"))
                return
                
            err = self.core.start(config_json)
            if err: 
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка ядра: {err}"))
                return

            def connection_watchdog():
                for _ in range(15):
                    if NetUtils.check_port(self.local_port):
                        run_on_ui_thread(lambda: (TelegramProxy.apply(self.local_port, True), BulletinHelper.show_success("Подключено"), setattr(self, "is_running", True), self._force_tg_rows_update()))
                        return
                    time.sleep(0.3)
                run_on_ui_thread(lambda: (self._disconnect(), BulletinHelper.show_error("Таймаут локального порта")))
            threading.Thread(target=connection_watchdog, daemon=True).start()

        # Если нативный код еще не загрузился - дожидаемся
        if not self.core.is_available():
            if self.core.is_downloading:
                run_on_ui_thread(lambda: BulletinHelper.show_info("Ядро загружается, подождите..."))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_info("Инициализация ядра..."))
                self.core.init_native(
                    on_success=proceed_connect, 
                    on_error=lambda e: run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка загрузки ядра: {e}"))
                )
            return

        proceed_connect()

    def _disconnect(self, silent=False):
        self.core.stop(); self.is_running = False
        TelegramProxy.apply(0, False)
        if not silent: 
            run_on_ui_thread(lambda: BulletinHelper.show_success("Отключено"))
            self._force_tg_rows_update()

    def _pinger_loop(self):
        while True:
            try:
                for node in self.data.get("manual", []):
                    p = NetUtils.tcp_ping(node["uri"])
                    if p != node.get("ping", -1): 
                        node["ping"] = p
                        for row in self.fast_layout:
                            if row.vt == 5 and row.uri == node["uri"]:
                                row.proxy_info.ping = p if p >= 0 else 0
                                row.proxy_info.available = (0 <= p < 2000)
                                row.proxy_info.checking = (p == -1)
                        run_on_ui_thread(lambda n=node: self._notify_node_changed(n["uri"]))
                    time.sleep(0.5) 
                        
                for sub in self.data.get("subs", []):
                    for node in sub.get("nodes", []):
                        p = NetUtils.tcp_ping(node["uri"])
                        if p != node.get("ping", -1): 
                            node["ping"] = p
                            for row in self.fast_layout:
                                if row.vt == 5 and row.uri == node["uri"]:
                                    row.proxy_info.ping = p if p >= 0 else 0
                                    row.proxy_info.available = (0 <= p < 2000)
                                    row.proxy_info.checking = (p == -1)
                            run_on_ui_thread(lambda n=node: self._notify_node_changed(n["uri"]))
                        time.sleep(0.5)
            except Exception as e: 
                Logger.e("Pinger loop error", e)
            time.sleep(15)