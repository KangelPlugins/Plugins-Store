__id__ = "streak_plugin_by_kvez"
__name__ = "Streak"
__description__ = "RU: –î–æ–±–∞–≤–ª—è–µ—Ç —Å–µ—Ä–∏–∏ –∫–∞–∫ –≤ TikTok\n\nEN: Adds streaks just like on TikTok"
__author__ = "@mqkvez"
__version__ = "1.1.0" 
__icon__ = "exteraStreaksByKvez/0"
__min_version__ = "11.12.0"
 
from base_plugin import BasePlugin, HookResult, HookStrategy, HookFilter, hook_filters, MethodHook
from android_utils import log, jclass
from hook_utils import find_class
from org.telegram.ui.Cells import TextDetailCell
from org.telegram.messenger import NotificationCenter, MessagesController, UserConfig
import weakref
import json
import datetime
import os
from file_utils import write_file, get_plugins_dir, ensure_dir_exists, read_file, delete_file
from java.lang import Integer, Object
from java.lang.reflect import Array
from java.util import Locale

class LocaleController:
    def __init__(self):
        self.language: str = Locale.getDefault().getLanguage()

    def get_controller(self):
        if self.language == "ru":
            return self.LanguageRussian()
        else:
            return self.LanguageEnglish()

    class LanguageRussian:
        language = 'ru'
        Streak_Title = "üî• –°–µ—Ä–∏—è"
        Streak_Frozen = "‚ùÑÔ∏è –°–µ—Ä–∏—è –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞"
        Days_1 = "–¥–µ–Ω—å"
        Days_2 = "–¥–Ω—è"
        Days_5 = "–¥–Ω–µ–π"

    class LanguageEnglish:
        language = 'en'
        Streak_Title = "üî• Streak"
        Streak_Frozen = "‚ùÑÔ∏è Streak frozen"
        Days_1 = "day"
        Days_2 = "days"
        Days_5 = "days"

def get_days_string(locale, n):
    if locale.language == 'en':
        return locale.Days_1 if n == 1 else locale.Days_5
    
    n = abs(n)
    if 11 <= n % 100 <= 14:
        return locale.Days_5
    
    n1 = n % 10
    if n1 == 1:
        return locale.Days_1
    if 2 <= n1 <= 4:
        return locale.Days_2
    
    return locale.Days_5


# –∑–∞ –æ—Å–Ω–æ–≤—É –¥–ª—è —ç—Ç–∏—Ö —Ö—É–∫–æ–≤ –¥–ª—è ProfileActivity –±—Ä–∞–ªc—è UITweaks –æ—Ç @luvztroy
class ProfileUpdateRowsIdsHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def before_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        activity = param.thisObject
        state = plugin.streak_activity_state.setdefault(activity, {"streakRow": -1})
        state["shouldInsertStreak"] = False

        user_id = self._get_profile_user_id(activity)
        if user_id is not None:
            state["userId"] = user_id
            info = {
                "account": UserConfig.selectedAccount,
                "id": user_id,
                "type": "update"
            }
            plugin._update_data(info)
            streak_info = plugin._get_streak_info(UserConfig.selectedAccount, user_id)
            if streak_info and streak_info["streak_count"] > 0:
                state["shouldInsertStreak"] = True
                state["streakCount"] = f"{streak_info['streak_count']} {get_days_string(plugin.locale, streak_info['streak_count'])}"
                if streak_info["streak_active"]:
                    state["streakText"] = plugin.locale.Streak_Title
                else:
                    state["streakText"] = plugin.locale.Streak_Frozen
                log(f"localized streak texts: {state['streakText']}, {state['streakCount']}")
    
    @hook_filters(HookFilter.Condition("param.thisObject != null"))
    def after_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        activity = param.thisObject
        state = plugin.streak_activity_state.get(activity)
        if state is None:
            return
        
        if not state["shouldInsertStreak"]:
            state["streakRow"] = -1
            return
        
        insert_pos = self._calculate_insert_position(activity)
        state["streakRow"] = insert_pos

        row_count = self._get_int_field(activity, "rowCount")
        if insert_pos != -1:
            self._set_int_field(activity, "rowCount", row_count + 1)

        try:
            activity_class = activity.getClass()
            fields = activity_class.getDeclaredFields()
            for field in fields:
                field_name = field.getName()
                if "Row" not in field_name and "row" not in field_name:
                    continue
                if field_name == "rowCount" or field_name == "streakRow":
                    continue
                field_type = field.getType()
                INTEGER_CLASS = jclass("java.lang.Integer")
                if field_type != INTEGER_CLASS.TYPE and field_type != INTEGER_CLASS:
                    continue
                field.setAccessible(True)
                value_obj = field.get(activity)
                if value_obj is None:
                    continue
                try:
                    value = int(value_obj)
                except Exception:
                    continue
                if value >= insert_pos and value != -1:
                    try:
                        if field_type == INTEGER_CLASS.TYPE:
                            field.setInt(activity, value + 1)
                        else:
                            field.set(activity, INTEGER_CLASS(value + 1))
                    except Exception:
                        pass
        except Exception:
            pass

    def _get_profile_user_id(self, activity):
        try:
            user_id = self._get_long_field(activity, "userId")
            if user_id == 0:
                return None
            account = UserConfig.selectedAccount
            controller = MessagesController.getInstance(account)
            if not controller:
                return None
            try:
                user_id_int = int(user_id)
            except Exception:
                user_id_int = user_id
            if user_id_int:
                return user_id_int
        except Exception:
            log("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è userId –∏–∑ ProfileActivity")
            return None

    def _get_int_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getInt(obj)
        except Exception:
            return -1

    def _set_int_field(self, obj, name, value):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            field.setInt(obj, value)
        except Exception:
            pass

    def _get_long_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getLong(obj)
        except Exception:
            return 0

    def _get_object_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.get(obj)
        except Exception:
            return None
        
    def _calculate_insert_position(self, activity):
        bio_val = self._get_int_field(activity, "userInfoRow")
        if bio_val != -1:
            return bio_val + 1

        username_val = self._get_int_field(activity, "usernameRow")
        if username_val != -1:
            return username_val + 1

        fallback_anchors = [
            "bizHoursRow",
            "bizLocationRow",
            "birthdayRow",
            "infoHeaderRow",
            "infoHeaderRowEmpty",
        ]
        for name in fallback_anchors:
            value = self._get_int_field(activity, name)
            if value != -1:
                return value + 1

        phone_val = self._get_int_field(activity, "phoneRow")
        if phone_val != -1:
            return phone_val + 1

        info_end_row = self._get_int_field(activity, "infoEndRow")
        if info_end_row != -1:
            return info_end_row + 1

        return -1

class ProfileListAdapterGetItemViewTypeHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.Condition("param.thisObject != null"), HookFilter.ArgumentNotNull(0))
    def before_hooked_method(self, param):
        plugin = self._plugin_ref()
        if not plugin:
            return
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = plugin.streak_activity_state.get(activity)
        if not state:
            return
        position_arg = param.args[0]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        if position == state.get("streakRow", -1):
            try:
                INTEGER_CLASS = jclass("java.lang.Integer")
                param.setResult(INTEGER_CLASS(2))
            except Exception:
                param.setResult(2)
    
    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None
        
class ProfileListAdapterBindViewHolderHook:
    def __init__(self, plugin):
        self._plugin_ref = weakref.ref(plugin)

    @hook_filters(HookFilter.ArgumentNotNull(0), HookFilter.ArgumentNotNull(1))
    def after_hooked_method(self, param):
        position_arg = param.args[1]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        plugin = self._plugin_ref()
        if not plugin:
            return
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = plugin.streak_activity_state.get(activity)
        if not state or position != state.get("streakRow", -1):
            return
        try:
            holder = param.args[0]
            item_view = holder.itemView
            if isinstance(item_view, TextDetailCell):
                item_view.setTextAndValue(
                    state["streakText"],
                    state["streakCount"],
                    True
                )
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None

class StreakMessageHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    @hook_filters(HookFilter.Condition("param.args[0] == org.telegram.messenger.NotificationCenter.didReceiveNewMessages"))
    def after_hooked_method(self, param):
        try:
            args = param.args[1]
            messages_list = args[1]
            if not messages_list or messages_list.size() == 0: return

            for i in range(messages_list.size()):
                msg = messages_list.get(i)
                if msg.isOut(): continue

                from_id = msg.getFromChatId()
                if from_id > 0:
                    self.plugin._update_data({
                        "type": "receive_message",
                        "timestamp": datetime.datetime.now().isoformat(),
                        "account": msg.currentAccount,
                        "id": from_id
                    })
        except Exception as e:
            self.plugin.log(f"Err StreakMessageHook: {e}")

class StreakPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._class_cache = {}
        self.streak_activity_state = {}
        self._data_cache = None

    def on_plugin_load(self):
        self.log("Loading Streak plugin...")
        self.locale = LocaleController().get_controller()
        
        self.plugin_data_dir = os.path.join(get_plugins_dir(), "streak_plugin_data")
        ensure_dir_exists(self.plugin_data_dir)
        self.plugin_data_file = os.path.join(self.plugin_data_dir, "streak_data.json")
        # delete_file(self.plugin_data_file)
        
        if read_file(self.plugin_data_file) is None:
            write_file(self.plugin_data_file, '{"version": 1}') 
        
        self._load_data_to_cache()
        
        try:
            self._hook_streak_status_in_profile()
            self.add_on_send_message_hook()
            self._setup_message_observation()
            self.log("Hooking done.")
        except Exception as e:
            self.log(f"Error hooking: {e}")

    def on_send_message_hook(self, account, params):
        info = {
            "type": "send_message",
            "timestamp": datetime.datetime.now().isoformat(),
            "account": account,
            "id": params.peer
        }
        self._update_data(info)
        return HookResult()

    def _update_data(self, info):
        if self._data_cache is None: self._load_data_to_cache()
        data = self._data_cache
        
        account = str(info.get("account", ""))
        user_id = str(info.get("id", ""))
        if not account or not user_id: return

        if account not in data: data[account] = {}
        if user_id not in data[account]:
            data[account][user_id] = {
                "streak_count": 0,
                "last_interaction_by_send": None,
                "last_interaction_by_receive": None,
                "last_increment_date": None,
                "streak_active": False,
            }
        
        user_stats = data[account][user_id]
        today = datetime.date.today()
        today_str = str(today)
        
        changed = False

        if info["type"] == "send_message":
            user_stats["last_interaction_by_send"] = info["timestamp"]
            changed = True
        elif info["type"] == "receive_message":
            user_stats["last_interaction_by_receive"] = info["timestamp"]
            changed = True
        
        if user_stats.get("last_increment_date"):
            last_incr_date = datetime.date.fromisoformat(user_stats["last_increment_date"])
            days_diff = (today - last_incr_date).days
            
            if days_diff > 1:
                if user_stats["streak_count"] != 0:
                    user_stats["streak_count"] = 0
                    user_stats["streak_active"] = False
                    changed = True
            elif days_diff == 1:
                if user_stats["streak_active"]:
                    user_stats["streak_active"] = False
                    changed = True

        if user_stats["last_interaction_by_send"] and user_stats["last_interaction_by_receive"]:
            send_date = datetime.datetime.fromisoformat(user_stats["last_interaction_by_send"]).date()
            rcv_date = datetime.datetime.fromisoformat(user_stats["last_interaction_by_receive"]).date()
            
            if send_date == today and rcv_date == today:
                if user_stats["last_increment_date"] != today_str:
                    user_stats["streak_count"] += 1
                    user_stats["last_increment_date"] = today_str
                    user_stats["streak_active"] = True
                    self.log(f"üî• +1 day in {user_id} chat")
                    changed = True
                elif not user_stats["streak_active"]:
                    user_stats["streak_active"] = True
                    changed = True
            else:
                if user_stats["streak_active"]:
                    user_stats["streak_active"] = False
                    changed = True
        if changed:
            self._save_cache_to_disk()

    def _get_streak_info(self, account, user_id):
        if self._data_cache is None: self._load_data_to_cache()
        ac = str(account)
        uid = str(user_id)
        return self._data_cache.get(ac, {}).get(uid, None)

    def _load_data_to_cache(self):
        try:
            content = read_file(self.plugin_data_file)
            if content:
                self._data_cache = json.loads(content)
            else:
                self._data_cache = {}
        except:
            self._data_cache = {}

    def _save_cache_to_disk(self):
        if self._data_cache is not None:
            try:
                write_file(self.plugin_data_file, json.dumps(self._data_cache))
            except: pass

    def _setup_message_observation(self):
        try:
            NC = self._get_class("org.telegram.messenger.NotificationCenter")
            if not NC: return
            
            NC_clazz = NC.getClass() 
            
            method = NC_clazz.getDeclaredMethod(
                "postNotificationName",
                Integer.TYPE,
                Array.newInstance(Object, 0).getClass()
            )
            
            if method:
                method.setAccessible(True)
                self.hook_method(method, StreakMessageHook(self))
        except Exception as e:
            self.log(f"Err observing msgs: {e}")

    def _get_class(self, class_name: str):
        if class_name in self._class_cache:
            return self._class_cache[class_name]
        cls = find_class(class_name)
        if cls: self._class_cache[class_name] = cls
        return cls

    def _hook_streak_status_in_profile(self):
        try:
            ProfileActivity = self._get_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivity: return
            
            try:
                pa_clazz = ProfileActivity.getClass()
            except:
                pa_clazz = ProfileActivity

            update_rows = pa_clazz.getDeclaredMethod("updateRowsIds")
            update_rows.setAccessible(True)
            self.hook_method(update_rows, ProfileUpdateRowsIdsHook(self))

            ListAdapter = self._get_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if ListAdapter:
                try:
                    la_clazz = ListAdapter.getClass()
                except:
                    la_clazz = ListAdapter
                
                int_type = Integer.TYPE
                vh_type = jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")

                m_viewtype = la_clazz.getDeclaredMethod("getItemViewType", int_type)
                m_viewtype.setAccessible(True)
                self.hook_method(m_viewtype, ProfileListAdapterGetItemViewTypeHook(self))

                m_bind = la_clazz.getDeclaredMethod("onBindViewHolder", vh_type, int_type)
                m_bind.setAccessible(True)
                self.hook_method(m_bind, ProfileListAdapterBindViewHolderHook(self))
        except Exception as e:
            self.log(f"Err profile hook: {e}")