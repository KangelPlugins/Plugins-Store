"""
В целях оптимизации и в связи с ограничениями Android,
Основная часть кода написана на Java и загружается с помощью технологии InMemoryDexClassLoader.
Актуальный исходный код плагина можно найти на GitHub: https://github.com/Hazzz895/ExteraPluginsAssets/blob/main/lyrics/dex/src/main/

По поводу форков:
1. Любой метод из Java кода можно хукнуть через Xposed хуки (в точности как и обычные тг методы).
Если вам необходимо изменить Java код, то создайте форк на Github и измените ссылку DEX_URL на свою.
О том как скомпилировать .dex: https://github.com/dextestv/DexSystem/blob/main/doc.md
2. О том как добавить новые источники текстов:
Добавить новый провайдер текстов можно вызвав метод add_lyrics_provider. Пример можно так-же найти в канале @PESSDES_plugins

Спасибо за использование плагина.
"""

# =============== константы ======================
# ссылка на .dex (Java код плагина)
DEX_URL = "https://github.com/Hazzz895/ExteraPluginsAssets/raw/refs/heads/dev/lyrics/dex/classes.dex"
DEX_FILE_NAME = "classes.dex"

# шрифт который используется в синхронизированных текстах. измените любое из значений на None, чтобы не скачивать.
FONT_DOWNLOAD_URL = "https://github.com/Hazzz895/ExteraPluginsAssets/raw/refs/heads/main/lyrics/fonts/YSMusic-Bold.ttf"
FONT_FILE_NAME = "YSMusic-Bold.ttf"

# пространства имен классов
CONTROLLER_CLASS_NAME = "com.pessdes.lyrics.components.lrclib.LyricsController"

# id кнопки
SHOW_LYRICS_ITEM_ID = 6767
# ================================================

__module_name__ = __name__
__id__ = "lyrics"
__name__ = "Reach Text"
__description__ = 'Displays lyrics for your music directly in Telegram.\nAdds a "Show Lyrics" button to the audio player, with support for synchronized (karaoke-style) lyrics.\nPowered by LRCLib.net'
__author__ = "@PESSDES_Plugins"
__min_version__ = "11.12.1"
__icon__ = "VoiceToText7/12"
__version__ = "2.0" 

from android.graphics import Typeface
from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment, run_on_queue, get_media_controller
from dalvik.system import InMemoryDexClassLoader
from hook_utils import get_private_field, find_class
from java.io import File
from java.lang import Boolean, Integer
from java import dynamic_proxy
from java.util import Locale
from java.nio import ByteBuffer
from android_utils import run_on_ui_thread
from org.telegram.messenger import ApplicationLoader, MessageObject, LocaleController as TGLocale, Utilities
from org.telegram.ui.ActionBar import ActionBarMenuItem
from org.telegram.ui.Components import AudioPlayerAlert
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from typing import Callable, Optional, Dict, Any, Tuple
import time
import os
import requests

LyricsController = None # LyricsController - главный класс через который и построена связь между .dex и Python

class LocaleController:
    @staticmethod
    def get_string_tg(string_key) -> str:
        return TelegramUtils.locale_string(string_key)

    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self._get_supported_languages() else "en"

    def get_string(self, string_key) -> str:
        string = self.strings[self.language].get(string_key, self.strings["en"].get(string_key, string_key))
        return string if string else string_key

    def _get_supported_languages(self):
        return self.strings.keys() 
    
    def __getitem__(self, key) -> str:
        return self.get_string(key)
    
    strings: Dict[str, Dict[str, str]] = {
        "en": {
            "ShowLyrics": "Show Lyrics",
            "FetchingLyrics": "Fetching Lyrics...",
            "LyricsNotFound": "Lyrics not found",
            "LyricsControllerNotLoaded": "An error occurred while loading an additional module. Press '%s' to try again.",
            "UnsupportedVersion": "Your version of the ReachText plugin does not support this feature. Please update it from the official Telegram channel @PESSDES_Plugins."
        },
        "ru": {
            "ShowLyrics": "Показать текст",
            "FetchingLyrics": "Получаю текст...",
            "LyricsNotFound": "Текст не найден",
            "LyricsControllerNotLoaded": "Произошла ошибка во время загрузки дополнительного модуля. Нажмите '%s', чтобы попробовать снова.",
            "UnsupportedVersion": "Ваша версия плагина ReachText не поддерживает эту функцию. Обновите ее из официального телеграм канала @PESSDES_Plugins"
        },
        "de": {
            "ShowLyrics": "Songtext anzeigen",
            "FetchingLyrics": "Songtext wird abgerufen...",
            "LyricsNotFound": "Songtext nicht gefunden",
            "LyricsControllerNotLoaded": "Beim Laden eines zusätzlichen Moduls ist ein Fehler aufgetreten. Drücken Sie '%s', um es erneut zu versuchen.",
            "UnsupportedVersion": "Ihre Version des ReachText-Plugins unterstützt diese Funktion nicht. Bitte aktualisieren Sie es über den offiziellen Telegram-Kanal @PESSDES_Plugins."
        },
        "es": {
            "ShowLyrics": "Mostrar letra",
            "FetchingLyrics": "Obteniendo la letra...",
            "LyricsNotFound": "Letra no encontrada",
            "LyricsControllerNotLoaded": "Ocurrió un error al cargar el módulo adicional. Presiona '%s' para intentarlo de nuevo.",
            "UnsupportedVersion": "Tu versión del plugin ReachText no es compatible con esta función. Por favor, actualízala desde el canal oficial de Telegram @PESSDES_Plugins."
        },
        "fr": {
            "ShowLyrics": "Afficher les paroles",
            "FetchingLyrics": "Récupération des paroles...",
            "LyricsNotFound": "Paroles non trouvées",
            "LyricsControllerNotLoaded": "Une erreur s'est produite lors du chargement du module additionnel. Appuyez sur '%s' pour réessayer.",
            "UnsupportedVersion": "Votre version du plugin ReachText ne prend pas en charge cette fonctionnalité. Veuillez la mettre à jour depuis le canal Telegram officiel @PESSDES_Plugins."
        },
        "it": {
            "ShowLyrics": "Mostra il testo",
            "FetchingLyrics": "Recupero il testo...",
            "LyricsNotFound": "Testo non trovato",
            "LyricsControllerNotLoaded": "Si è verificato un errore durante il caricamento del modulo aggiuntivo. Premi '%s' per riprovare.",
            "UnsupportedVersion": "La tua versione del plugin ReachText non supporta questa funzionalità. Si prega di aggiornarla dal canale Telegram ufficiale @PESSDES_Plugins."
        },
        "pt": {
            "ShowLyrics": "Mostrar a letra",
            "FetchingLyrics": "Buscando a letra...",
            "LyricsNotFound": "Letra não encontrada",
            "LyricsControllerNotLoaded": "Ocorreu um erro ao carregar o módulo adicional. Pressione '%s' para tentar novamente.",
            "UnsupportedVersion": "Sua versão do plugin ReachText não suporta este recurso. Por favor, atualize-o a partir do canal oficial do Telegram @PESSDES_Plugins."
        },
        "zh": {
            "ShowLyrics": "显示歌词",
            "FetchingLyrics": "正在获取歌词...",
            "LyricsNotFound": "未找到歌词",
            "LyricsControllerNotLoaded": "加载附加模块时出错。请按“%s”重试。",
            "UnsupportedVersion": "您的 ReachText 插件版本不支持此功能。请从官方 Telegram 频道 @PESSDES_Plugins 更新。"
        },
        "ja": {
            "ShowLyrics": "歌詞を表示",
            "FetchingLyrics": "歌詞を取得中...",
            "LyricsNotFound": "歌詞が見つかりません",
            "LyricsControllerNotLoaded": "追加モジュールの読み込み中にエラーが発生しました。「%s」を押して再試行してください。",
            "UnsupportedVersion": "お使いのReachTextプラグインのバージョンでは、この機能はサポートされていません。公式Telegramチャンネル@PESSDES_Pluginsから更新してください。"
        },
        "uk": {
            "ShowLyrics": "Показати текст",
            "FetchingLyrics": "Отримання тексту...",
            "LyricsNotFound": "Текст не знайдено",
            "LyricsControllerNotLoaded": "Сталася помилка під час завантаження додаткового модуля. Натисніть '%s', щоб спробувати знову.",
            "UnsupportedVersion": "Ваша версія плагіна ReachText не підтримує цю функцію. Оновіть її з офіційного телеграм-каналу @PESSDES_Plugins."
        },
        "pl": {
            "ShowLyrics": "Pokaż tekst",
            "FetchingLyrics": "Pobieranie tekstu...",
            "LyricsNotFound": "Nie znaleziono tekstu",
            "LyricsControllerNotLoaded": "Wystąpił błąd podczas ładowania dodatkowego modułu. Naciśnij '%s', aby spróbować ponownie.",
            "UnsupportedVersion": "Twoja wersja wtyczki ReachText nie obsługuje tej funkcji. Zaktualizuj ją z oficjalnego kanału Telegram @PESSDES_Plugins."
        },
        "ko": {
            "ShowLyrics": "가사 보기",
            "FetchingLyrics": "가사 불러오는 중...",
            "LyricsNotFound": "가사를 찾을 수 없습니다",
            "LyricsControllerNotLoaded": "추가 모듈을 로드하는 중 오류가 발생했습니다. '%s' 버튼을 눌러 다시 시도하세요.",
            "UnsupportedVersion": "사용 중인 ReachText 플러그인 버전이 이 기능을 지원하지 않습니다. 공식 텔레그램 채널 @PESSDES_Plugins에서 업데이트하세요."
        },
        "ar": {
            "ShowLyrics": "إظهار الكلمات",
            "FetchingLyrics": "جارٍ جلب الكلمات...",
            "LyricsNotFound": "لم يتم العثور على الكلمات",
            "LyricsControllerNotLoaded": "حدث خطأ أثناء تحميل الوحدة الإضافية. اضغط على '%s' للمحاولة مرة أخرى.",
            "UnsupportedVersion": "إصدار المكون الإضافي ReachText الخاص بك لا يدعم هذه الميزة. يرجى تحديثه من قناة تيليجرام الرسمية @PESSDES_Plugins."
        }
    }

locale_controller = LocaleController()

class Plugin(BasePlugin):
    font_file_path = None
    instance = None

    def on_plugin_load(self) -> None:
        Plugin.instance = self
        self.hook_method(AudioPlayerAlert.getClass().getDeclaredConstructors()[0], AudioPlayerAlertHook())
        self.hook_method(AudioPlayerAlert.getClass().getDeclaredMethod("updateTitle", Boolean.TYPE), UpdateHook())
        self.hook_method(AudioPlayerAlert.getClass().getDeclaredMethod("onSubItemClick", Integer.TYPE), SubItemClickHook(self))

        run_on_queue(self.load_dex)

        if FONT_DOWNLOAD_URL is not None and FONT_FILE_NAME is not None:
            run_on_queue(self.download_font)

    # шрифт который будет применен на синхронизированный текст.
    typeface = None

    @staticmethod
    def dir():
        dir = File(ApplicationLoader.applicationContext.getExternalCacheDir(), __id__) # Директория кэша прилоежния
        if not dir.exists():
            dir.mkdirs()
        return dir
    
    @classmethod
    def get_font_path(cls):
        if not cls.font_file_path:
            cls.font_file_path = File(cls.dir(), FONT_FILE_NAME).getAbsolutePath()
        return cls.font_file_path

    @classmethod
    def get_dex_path(cls):
        return File(cls.dir(), DEX_FILE_NAME).getAbsolutePath()

    def download_font(self):
        """ Скачивает шрифт и вызывает on_font_downloaded() по завершению """
        if not os.path.exists(self.get_font_path()):
            response = requests.get(FONT_DOWNLOAD_URL)
            response.raise_for_status()
            with open(self.get_font_path(), "wb") as file:
                file.write(response.content)
        
        self.on_font_downloaded()
    
    def on_font_downloaded(self):
        """ Вызывается после скачивания шрифта """
        self.typeface = Typeface.createFromFile(self.get_font_path())
        if LyricsController:
            LyricsController.setTypeface(self.typeface)

    def load_dex(self, then: Optional[Callable] = None):
        """Загружает .dex по ссылке и создает экземпляр LyricsController 

        Args:
            then (Callable, optional): Функция, которая будет вызвана после загрузки LyricsController. Принимает экземпляр LyricsController в качестве первого аргумента. Defaults to None.
        """

        global LyricsController
        try:
            if not LyricsController:
                try:
                    lyrics_controller_class = find_class(CONTROLLER_CLASS_NAME).getClass()
                except:
                    self.log("LyricsController class not found, loading DEX...")
                    lyrics_controller_class = self._init_lyrics_controller_class()
                        
                LyricsController = lyrics_controller_class.getDeclaredMethod("getInstance").invoke(None)
                self._on_lyrics_controller_loaded()

            if then is not None:
                then()
        except Exception as e:
            LyricsController = None
            self.log(f"Failed to load LyricsController: {e}")
            BulletinHelper.show_error("Failed to load LyricsController!")

    def _init_lyrics_controller_class(self):
        """ Загружает .dex и создает экземпляр LyricsController

        Returns:
            LyricsController: загруженный LyricsController
        """
        if False: # TODO Вернуть в 2.1                   # os.path.exists(self.get_dex_path()) and (time.time() - os.path.getmtime(self.get_dex_path()) < 60 * 60 * 12):
            dex_bytes = self._load_dex_from_cache()
        else:
            self.log(".dex not found or too old, downloading...")
            try:
                response = requests.get(DEX_URL)
                response.raise_for_status()  
                dex_bytes = response.content
                with open(self.get_dex_path(), "wb") as file:
                    file.write(dex_bytes)
            except Exception as e:
                self.log(f"Failed to download .dex: {e}, reading from cache...")
                self._load_dex_from_cache()
        
        app_class_loader = ApplicationLoader.applicationContext.getClassLoader()
        dex_loader = InMemoryDexClassLoader(ByteBuffer.wrap(dex_bytes), app_class_loader)
        return dex_loader.loadClass(CONTROLLER_CLASS_NAME)

    def _load_dex_from_cache(self) -> bytes:
        with open(self.get_dex_path(), "rb") as file:
            dex_bytes = file.read()
        return dex_bytes

    def _on_lyrics_controller_loaded(self):
        """ Вызывается после загрузки LyricsController """
        LyricsController.initPluginController(__module_name__)
        if self.typeface:
            LyricsController.setTypeface(self.typeface)

        self.log("LyricsController loaded")
    
    @staticmethod
    def get_instance() -> "Plugin":
        return Plugin.instance

def is_music() -> bool:
    """ Проверяет, является ли текущий трек музыкой

    Returns:
        bool: True, если текущий трек является музыкой, иначе False
    """
    playing_message_object: MessageObject = get_media_controller().getInstance().getPlayingMessageObject()
    return playing_message_object.isMusic()

def get_plugin_instance() -> Plugin:
    """ Возвращает экземпляр плагина

    Returns:
        Plugin: экземпляр Plugin
    """
    return Plugin.get_instance()

def add_lyrics_provider(name: str, id: str, on_get_lyrics: Callable[[Any, Any, Any], Optional[Tuple[Optional[float], Optional[str], Optional[str]]]], default_priority: int = 0) -> Any:
    """ Добавляет провайдер для получения текстов.

    Args:
        name (str): Название провайдера.
        on_get_lyrics (Callable[[Any, Any, Any], Optional[Tuple[Optional[float], Optional[str], Optional[str]]]]): Функция, которая будет вызвана при получении текста.
        priority (int, optional): Приоритет. Defaults to 0.

    Returns:
        Any: Созданный провайдер.
    """
    if not LyricsController:
        raise Exception("LyricsController is not initialized yet.")
    if LyricsController.createAndAddSimpleProvider(
            name, 
            id, 
            SearchLyricsFnWrapper(on_get_lyrics), 
            default_priority):
        get_plugin_instance().log("Added lyrics provider: " + id)

def remove_lyrics_provider(id: str) -> None:
    if not LyricsController:
        raise Exception("LyricsController is not initialized yet.")
    if LyricsController.removeProvider(id):
        get_plugin_instance().log("Removed lyrics provider: " + id)

class SearchLyricsFnWrapper(dynamic_proxy(Utilities.Callback3Return)):
    def __init__(self, fn: Callable[[Any, Any, Any], Optional[Tuple[Optional[float], Optional[str], Optional[str]]]]):
        super().__init__()
        self.fn = fn
    
    def run(self, *args):
        result = self.fn(*args)
        if result is None:
            return result
        else:
            duration, plain_lyrics, plain_synced_lyrics = result
            if duration is None:
                duration = 0.0
            return LyricsController.createLyrics(duration, plain_lyrics, plain_synced_lyrics)

class AudioPlayerAlertHook(MethodHook):
    """ Вызывается при создании AudioPlayerAlert """

    def after_hooked_method(self, param):
        optionsButton: ActionBarMenuItem = get_private_field(param.thisObject, "optionsButton")
        optionsButton.addSubItem(
            SHOW_LYRICS_ITEM_ID, 
            TelegramUtils.get_icon_id("msg_photo_text2"),
            locale_controller["ShowLyrics"]
        )
        optionsButton.setSubItemShown(SHOW_LYRICS_ITEM_ID, is_music())

class UpdateHook(MethodHook):
    """ Вызывается при обновлении AudioPlayerAlert """

    def after_hooked_method(self, param):
        optionsButton: ActionBarMenuItem = get_private_field(param.thisObject, "optionsButton")
        optionsButton.setSubItemShown(SHOW_LYRICS_ITEM_ID, is_music())

class SubItemClickHook(MethodHook):
    """ Вызывается при нажатии на кнопку "Текст трека" """
    def __init__(self, plugin: Plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        if param.args[0] != SHOW_LYRICS_ITEM_ID:
            return
        elif LyricsController is None:
            alert = AlertDialogBuilder(get_last_fragment().getContext())
            alert.set_title(LocaleController.get_string_tg("ErrorOccurred"))
            alert.set_message(locale_controller["LyricsControllerNotLoaded"] % LocaleController.get_string_tg("Retry"))

            def on_download_click(dialog, which):
                loading_dialog = AlertDialogBuilder(get_last_fragment().getContext(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                loading_dialog_dismissed = False

                def on_dismiss(*_):
                    nonlocal loading_dialog_dismissed
                    loading_dialog_dismissed = True

                loading_dialog.set_on_dismiss_listener(on_dismiss)
                loading_dialog.show()

                def on_loaded(*_):
                    loading_dialog.dismiss()
                    if not loading_dialog_dismissed:
                        self.before_hooked_method(param)

                run_on_queue(lambda: 
                             self.plugin.load_dex(lambda: 
                                                  run_on_ui_thread(on_loaded))
                             )

            alert.set_positive_button(LocaleController.get_string_tg("Retry"), on_download_click)
            alert.set_negative_button(LocaleController.get_string_tg("Cancel"), lambda dialog, which: dialog.dismiss())
            alert.show()
            return
        
        param.setResult(None)
        LyricsController.presentLyricsActivity(get_last_fragment())

class TelegramUtils:
    @staticmethod
    def get_icon_id(name: str) -> int:
        context = get_last_fragment().getContext()
        return context.getResources().getIdentifier(name, "drawable", context.getPackageName())

    @staticmethod
    def get_locale_id(name: str) -> int:
        context = get_last_fragment().getContext()
        return context.getResources().getIdentifier(name, "string", context.getPackageName())
    
    @classmethod
    def locale_string(cls, name: str) -> str:
        try:
            return TGLocale.getString(cls.get_locale_id(name))
        except Exception as e:
            return name