from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Switch
from ui.bulletin import BulletinHelper
from client_utils import get_send_messages_helper, get_messages_controller, send_message
from org.telegram.messenger import ApplicationLoader
from java.io import File
from java.util import Locale
import sqlite3
import os
import traceback
import uuid
import datetime

__id__ = "usernotes"
__name__ = "User Notes"
__description__ = "Local notes about users with .addnote, .lsnotes, .delnote commands"
__author__ = "@koshbko"
__min_version__ = "11.12.0"
__icon__ = "koshbkoplugins/0"
__version__ = "1.0.1"

class DebugLogger:
    logs_dir = "/storage/emulated/0/Download/tailed_notes_logs"
    logs = []

    @staticmethod
    def make_log(log):
        DebugLogger.logs.append(log)

    @staticmethod
    def save_logs():
        save_dir = DebugLogger.logs_dir + f"/log-{uuid.uuid4()}.txt"
        Filesystem.write_file(save_dir, '\n'.join(DebugLogger.logs).encode('utf-8'))
        return save_dir

class NotesPlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            LocalizationManager.init()
            DatabaseManager.init()
            self.add_on_send_message_hook()
        except Exception as e:
            DebugLogger.make_log("on_plugin_load\n" + str(traceback.format_exc()))

    def create_settings(self):
        return [
            Header(
                LocalizationManager.get_string("SETTINGS_TITLE")
            ),
            Switch(
                key="show_note_count",
                text=LocalizationManager.get_string("SETTINGS_SHOW_COUNT"),
                default=True
            ),
            Switch(
                key="confirm_delete",
                text=LocalizationManager.get_string("SETTINGS_CONFIRM_DELETE"),
                default=True
            )
        ]

    def on_send_message_hook(self, account, params) -> HookStrategy:
        if not isinstance(params.message, str):
            return HookResult()

        # Debug logs command
        if params.message.startswith(".notesdebuglogs"):
            save_dir = DebugLogger.save_logs()
            params.message = f"Logs saved to {save_dir}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        # Add note command
        if params.message.startswith(".addnote"):
            return self.handle_add_note(params)

        # List notes command
        if params.message.startswith(".lsnotes"):
            return self.handle_list_notes(params)

        # Delete note command
        if params.message.startswith(".delnote"):
            return self.handle_delete_note(params)

        return HookResult()

    def handle_add_note(self, params):
        try:
            if not params.replyToMsg:
                BulletinHelper.show_error(LocalizationManager.get_string("FORGOT_TO_REPLY"))
                return HookResult(strategy=HookStrategy.CANCEL)

            # Extract note content from command
            args = params.message.split(" ", 1)
            if len(args) < 2:
                BulletinHelper.show_error(LocalizationManager.get_string("NOTE_CONTENT_REQUIRED"))
                return HookResult(strategy=HookStrategy.CANCEL)

            note_content = args[1]
            user_id = self.get_reply_user_id(params)
            
            # Add note to database
            note_id = DatabaseManager.add_note(user_id, note_content)
            
            user_name = self.get_user_name(user_id)
            params.message = LocalizationManager.get_string("NOTE_ADDED").format(
                note_id, user_name, note_content[:50] + "..." if len(note_content) > 50 else note_content
            )
            
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception as e:
            DebugLogger.make_log("handle_add_note\n" + str(traceback.format_exc()))
            BulletinHelper.show_error(LocalizationManager.get_string("PLUGIN_ERROR"))
            return HookResult(strategy=HookStrategy.CANCEL)

    def handle_list_notes(self, params):
        try:
            if not params.replyToMsg:
                BulletinHelper.show_error(LocalizationManager.get_string("FORGOT_TO_REPLY"))
                return HookResult(strategy=HookStrategy.CANCEL)

            user_id = self.get_reply_user_id(params)
            notes = DatabaseManager.get_notes_by_user(user_id)
            
            if not notes:
                user_name = self.get_user_name(user_id)
                params.message = LocalizationManager.get_string("NO_NOTES_FOUND").format(user_name)
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

            # Format notes for display
            user_name = self.get_user_name(user_id)
            show_count = self.get_setting("show_note_count", True)
            
            notes_header = LocalizationManager.get_string("NOTES_HEADER").format(
                user_name, f" ({len(notes)})" if show_count else ""
            )
            
            notes_content = []
            for note in notes:
                timestamp = datetime.datetime.fromtimestamp(note[2]).strftime("%Y-%m-%d %H:%M")
                notes_content.append(f"#{note[0]} [{timestamp}]: {note[3]}")

            # Create spoiler text with notes
            notes_text = notes_header + "\n" + "\n".join(notes_content)
            params.message = f"{notes_text}"
            
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception as e:
            DebugLogger.make_log("handle_list_notes\n" + str(traceback.format_exc()))
            BulletinHelper.show_error(LocalizationManager.get_string("PLUGIN_ERROR"))
            return HookResult(strategy=HookStrategy.CANCEL)

    def handle_delete_note(self, params):
        try:
            args = params.message.split(" ", 1)
            if len(args) < 2:
                BulletinHelper.show_error(LocalizationManager.get_string("NOTE_ID_REQUIRED"))
                return HookResult(strategy=HookStrategy.CANCEL)

            try:
                note_id = int(args[1])
            except ValueError:
                BulletinHelper.show_error(LocalizationManager.get_string("INVALID_NOTE_ID"))
                return HookResult(strategy=HookStrategy.CANCEL)

            # Check if note exists
            note = DatabaseManager.get_note_by_id(note_id)
            if not note:
                BulletinHelper.show_error(LocalizationManager.get_string("NOTE_NOT_FOUND").format(note_id))
                return HookResult(strategy=HookStrategy.CANCEL)

            # Delete note
            DatabaseManager.delete_note(note_id)
            params.message = LocalizationManager.get_string("NOTE_DELETED").format(note_id)
            
            return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception as e:
            DebugLogger.make_log("handle_delete_note\n" + str(traceback.format_exc()))
            BulletinHelper.show_error(LocalizationManager.get_string("PLUGIN_ERROR"))
            return HookResult(strategy=HookStrategy.CANCEL)

    def get_reply_user_id(self, params):
        return params.replyToMsg.messageOwner.from_id.user_id

    def get_user_name(self, user_id):
        try:
            user = get_messages_controller().getUser(user_id)
            first_name = user.first_name if user.first_name else ""
            last_name = user.last_name if user.last_name else ""
            return " ".join([first_name, last_name]).strip() or f"User {user_id}"
        except:
            return f"User {user_id}"

class LocalizationManager:
    language = "en"

    @staticmethod
    def init():
        language = Locale.getDefault().getLanguage()
        LocalizationManager.language = language if language in LocalizationManager._get_supported_languages() else "en"

    @staticmethod
    def get_string(string):
        locali = LocalizationManager.strings[LocalizationManager.language].get(string)
        return locali if locali is not None else string

    @staticmethod
    def _get_supported_languages():
        return LocalizationManager.strings.keys()

    strings = {
        "ru": {
            "SETTINGS_TITLE": "Настройки заметок",
            "SETTINGS_SHOW_COUNT": "Показывать количество заметок",
            "SETTINGS_CONFIRM_DELETE": "Подтверждение удаления",
            "FORGOT_TO_REPLY": "Ответьте на сообщение пользователя!",
            "NOTE_CONTENT_REQUIRED": "Укажите содержание заметки после команды!",
            "NOTE_ADDED": "✅ Заметка #{0} добавлена для {1}: {2}",
            "NO_NOTES_FOUND": "📝 Нет заметок для пользователя {0}",
            "NOTES_HEADER": "📝 Заметки для {0}{1}:",
            "NOTE_ID_REQUIRED": "Укажите ID заметки для удаления!",
            "INVALID_NOTE_ID": "Неверный ID заметки!",
            "NOTE_NOT_FOUND": "Заметка #{0} не найдена!",
            "NOTE_DELETED": "🗑️ Заметка #{0} удалена",
            "PLUGIN_ERROR": "Ошибка в плагине заметок!",
            "DATABASE_ERROR": "Ошибка базы данных!"
        },
        "en": {
            "SETTINGS_TITLE": "Notes Settings",
            "SETTINGS_SHOW_COUNT": "Show notes count",
            "SETTINGS_CONFIRM_DELETE": "Confirm deletion",
            "FORGOT_TO_REPLY": "Reply to user's message!",
            "NOTE_CONTENT_REQUIRED": "Specify note content after command!",
            "NOTE_ADDED": "✅ Note #{0} added for {1}: {2}",
            "NO_NOTES_FOUND": "📝 No notes found for user {0}",
            "NOTES_HEADER": "📝 Notes for {0}{1}:",
            "NOTE_ID_REQUIRED": "Specify note ID to delete!",
            "INVALID_NOTE_ID": "Invalid note ID!",
            "NOTE_NOT_FOUND": "Note #{0} not found!",
            "NOTE_DELETED": "🗑️ Note #{0} deleted",
            "PLUGIN_ERROR": "Notes plugin error!",
            "DATABASE_ERROR": "Database error!"
        }
    }

class Filesystem:
    @staticmethod
    def write_file(file_path, content):
        file_full_path = "/".join(file_path.split("/")[:-1])
        if not os.path.exists(file_full_path):
            os.makedirs(file_full_path)
        with open(file_path, 'wb') as file:
            file.write(content)

    @staticmethod
    def get_absolute_path(dir, file_name):
        return File(dir, file_name).getAbsolutePath()

    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            if not fixed_dir:
                return None
            temp_dir = File(fixed_dir, "tailed_notes").getAbsolutePath()
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            return temp_dir
        except Exception as e:
            DebugLogger.make_log("get_temp_dir\n" + str(traceback.format_exc()))
            return None

class DatabaseManager:
    db_path = None
    
    @staticmethod
    def init():
        try:
            temp_dir = Filesystem.get_temp_dir()
            if temp_dir:
                DatabaseManager.db_path = os.path.join(temp_dir, "user_notes.db")
            else:
                # Fallback path
                DatabaseManager.db_path = "/storage/emulated/0/Download/user_notes.db"
            
            DatabaseManager.create_table()
        except Exception as e:
            DebugLogger.make_log("DatabaseManager.init\n" + str(traceback.format_exc()))

    @staticmethod
    def get_connection():
        """Get database connection with proper path handling for Android"""
        try:
            if not DatabaseManager.db_path:
                DatabaseManager.init()
            return sqlite3.connect(DatabaseManager.db_path)
        except Exception as e:
            DebugLogger.make_log("get_connection\n" + str(traceback.format_exc()))
            raise

    @staticmethod
    def create_table():
        """Create notes table if it doesn't exist"""
        try:
            conn = DatabaseManager.get_connection()
            cursor = conn.cursor()
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS notes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    created_at REAL NOT NULL,
                    content TEXT NOT NULL
                )
            ''')
            conn.commit()
            conn.close()
        except Exception as e:
            DebugLogger.make_log("create_table\n" + str(traceback.format_exc()))

    @staticmethod
    def add_note(user_id, content):
        """Add a new note for user"""
        try:
            conn = DatabaseManager.get_connection()
            cursor = conn.cursor()
            timestamp = datetime.datetime.now().timestamp()
            cursor.execute(
                'INSERT INTO notes (user_id, created_at, content) VALUES (?, ?, ?)',
                (user_id, timestamp, content)
            )
            note_id = cursor.lastrowid
            conn.commit()
            conn.close()
            return note_id
        except Exception as e:
            DebugLogger.make_log("add_note\n" + str(traceback.format_exc()))
            raise

    @staticmethod
    def get_notes_by_user(user_id):
        """Get all notes for a specific user"""
        try:
            conn = DatabaseManager.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, user_id, created_at, content FROM notes WHERE user_id = ? ORDER BY created_at DESC',
                (user_id,)
            )
            notes = cursor.fetchall()
            conn.close()
            return notes
        except Exception as e:
            DebugLogger.make_log("get_notes_by_user\n" + str(traceback.format_exc()))
            return []

    @staticmethod
    def get_note_by_id(note_id):
        """Get note by ID"""
        try:
            conn = DatabaseManager.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                'SELECT id, user_id, created_at, content FROM notes WHERE id = ?',
                (note_id,)
            )
            note = cursor.fetchone()
            conn.close()
            return note
        except Exception as e:
            DebugLogger.make_log("get_note_by_id\n" + str(traceback.format_exc()))
            return None

    @staticmethod
    def delete_note(note_id):
        """Delete note by ID"""
        try:
            conn = DatabaseManager.get_connection()
            cursor = conn.cursor()
            cursor.execute('DELETE FROM notes WHERE id = ?', (note_id,))
            conn.commit()
            conn.close()
        except Exception as e:
            DebugLogger.make_log("delete_note\n" + str(traceback.format_exc()))
            raise
