
from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Selector, Input
from client_utils import get_send_messages_helper, get_messages_controller, send_request, RequestCallback, send_message
from ui.bulletin import BulletinHelper
from org.telegram.messenger import ApplicationLoader
from org.telegram.tgnet import TLRPC
from java.io import File
from java.util import Locale
from android_utils import log
from PIL import Image, ImageDraw, ImageFont
import requests, uuid, os, traceback, threading, time

__id__ = "Profile_Plugin"
__name__ = "Profile Generator"
__description__ = "Create a user profile command .profile"
__author__ = "@MorePlugins"
__min_version__ = "11.9.0"
__icon__ = "NewsEmoji/0"
__version__ = "1.0"

def plog(message):
    try:
        log(f"[Profile Plugin] {message}")
    except:
        pass

def validate_hex_color(color_str):
    color_str = color_str.strip()
    if color_str.startswith("#"):
        color_str = color_str[1:]
    if len(color_str) == 6:
        try:
            int(color_str, 16)
            return "#" + color_str
        except ValueError:
            pass
    return None

class ProfilePlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            FontManager.init()
            LocalizationManager.init()
            self.add_on_send_message_hook()
        except Exception:
            plog("on_plugin_load error\n" + str(traceback.format_exc()))

    def create_settings(self):
        return [
            Input(
                key="command",
                text="Команда(Работает только с .)",
                default=".profile",
                subtext="Команда для вызова профиля",
                icon="msg_text"
            ),
            Header("Настройки профиля"),
            Selector(
                key="font",
                text="Шрифт",
                default=0,
                items=FontManager.get_fonts_names(),
                icon="msg_photo_text_regular"
            ),
            Input(
                key="custom_font_url",
                text="Ссылка на кастомный шрифт",
                default="",
                subtext="Прямая ссылка на .ttf файл",
                icon="msg_photo_text_framed3"
            ),
            Input(key="bg_color", text="Цвет 1 фона", default="#0E1621", subtext="HEX основного фона", icon="msg_round"),
            Input(key="header_bg_color", text="Цвет 2 фона", default="#212D3B", subtext="HEX фона шапки", icon="msg_round"),
            Input(key="info_bg_color", text="Цвет 3 фона", default="#1D2733", subtext="HEX фона информации", icon="msg_round"),
            Input(key="name_color", text="Цвет Имени", default="#FFFFFF", subtext="HEX цвета имени", icon="msg_user"),
            Input(key="text_color", text="Цвет текста", default="#FFFFFF", subtext="HEX основного текста", icon="msg_text"),
            Input(key="sub_text_color", text="Цвет подтекста", default="#829AB1", subtext="HEX подписей", icon="msg_text"),
            Input(key="accent_color", text="Цвет акцента", default="#5288C1", subtext="HEX акцентных элементов", icon="msg_round"),
            Input(key="online_color", text="Цвет Онлайна", default="#74BAF5", subtext="HEX статуса онлайн", icon="msg_round"),
            Input(key="offline_color", text="Цвет Оффлайна", default="#829AB1", subtext="HEX статуса офлайн", icon="msg_round"),
            Input(key="section_color", text="Цвет секций", default="#7DC3F7", subtext="HEX заголовков секций", icon="msg_text"),
            Input(key="divider_color", text="Цвет разделителей", default="#1E2C3A", subtext="HEX линий разделителей", icon="msg_round")
        ]

    def on_send_message_hook(self, account, params) -> HookStrategy:
        if not isinstance(params.message, str):
            return HookResult()
        
        message_text = params.message.strip()
        command = self.get_setting("command", ".profile")
        
        if message_text == command or message_text.startswith(command + " "):
            try:
                parts = message_text.split(maxsplit=1)
                if len(parts) < 2:
                    BulletinHelper.show_error("Укажите ID пользавателя")
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                query = parts[1].strip().lstrip('@')

                font_index = self.get_setting("font", 0)
                custom_font_url = self.get_setting("custom_font_url", "").strip()
                FontManager.custom_font_url = custom_font_url

                bg_color = validate_hex_color(self.get_setting("bg_color", "#0E1621")) or "#0E1621"
                header_bg_color = validate_hex_color(self.get_setting("header_bg_color", "#212D3B")) or "#212D3B"
                info_bg_color = validate_hex_color(self.get_setting("info_bg_color", "#1D2733")) or "#1D2733"
                name_color = validate_hex_color(self.get_setting("name_color", "#FFFFFF")) or "#FFFFFF"
                text_color = validate_hex_color(self.get_setting("text_color", "#FFFFFF")) or "#FFFFFF"
                sub_text_color = validate_hex_color(self.get_setting("sub_text_color", "#829AB1")) or "#829AB1"
                accent_color = validate_hex_color(self.get_setting("accent_color", "#5288C1")) or "#5288C1"
                online_color = validate_hex_color(self.get_setting("online_color", "#74BAF5")) or "#74BAF5"
                offline_color = validate_hex_color(self.get_setting("offline_color", "#829AB1")) or "#829AB1"
                section_color = validate_hex_color(self.get_setting("section_color", "#7DC3F7")) or "#7DC3F7"
                divider_color = validate_hex_color(self.get_setting("divider_color", "#1E2C3A")) or "#1E2C3A"

                profile = ProfileManager(
                    params, query, font_index,
                    bg_color=bg_color, header_bg_color=header_bg_color, info_bg_color=info_bg_color,
                    name_color=name_color, text_color=text_color, sub_text_color=sub_text_color,
                    accent_color=accent_color, online_color=online_color, offline_color=offline_color,
                    section_color=section_color, divider_color=divider_color
                )
                profile.generate_profile()
                return HookResult(strategy=HookStrategy.CANCEL)
            except Exception:
                plog("profile processing error\n" + str(traceback.format_exc()))
                BulletinHelper.show_error(LocalizationManager.get_string("error"))
                return HookResult(strategy=HookStrategy.CANCEL)
        return HookResult()

class LocalizationManager:
    language = "en"
    @staticmethod
    def init():
        lang = Locale.getDefault().getLanguage()
        LocalizationManager.language = "ru" if lang == "ru" else "en"
    @staticmethod
    def get_string(key):
        strings = {
            "ru": {
                "error": "Ошибка при создании профиля!",
                "photo_error": "Ошибка загрузки фото!",
                "user_not_found": "Пользователь не найден!"
            },
            "en": {
                "error": "Error creating profile!",
                "photo_error": "Error loading photo!",
                "user_not_found": "User not found!"
            }
        }
        return strings.get(LocalizationManager.language, strings["en"]).get(key, key)

class Filesystem:
    @staticmethod
    def get_temp_dir():
        try:
            fixed_dir = ApplicationLoader.getFilesDirFixed()
            if not fixed_dir:
                return None
            temp_dir = File(fixed_dir, "extra_profiles").getAbsolutePath()
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            return temp_dir
        except:
            return None

    @staticmethod
    def get_absolute_path(dir, file_name):
        return File(dir, file_name).getAbsolutePath()

    @staticmethod
    def write_file(file_path, content):
        parent = os.path.dirname(file_path)
        if not os.path.exists(parent):
            os.makedirs(parent)
        with open(file_path, 'wb') as f:
            f.write(content)

class TelegramUtils:
    @staticmethod
    def get_user(user_id):
        return get_messages_controller().getUser(user_id)

class ProfileManager:
    def __init__(self, params, query, font_index, **colors):
        self.params = params
        self.query = query
        self.font_index = font_index
        for k, v in colors.items():
            setattr(self, k, v)
        self.avatar_file_path = None
        self.user = None

    def generate_profile(self):
        try:
            user = self.find_user(self.query)
            if not user:
                BulletinHelper.show_error(LocalizationManager.get_string("user_not_found"))
                return
            self.user = user
            if hasattr(user, 'photo') and user.photo and user.photo.photo_id != 0:
                self._download_user_photo(user.photo, user.id)
            else:
                self.create_profile_without_avatar()
        except Exception:
            plog("generate_profile init error\n" + str(traceback.format_exc()))
            self.create_profile_without_avatar()

    def find_user(self, query):
        try:
            if query.isdigit():
                user = TelegramUtils.get_user(int(query))
                return user if user else None

            users = get_messages_controller().getAllUsers()
            if not users:
                return None

            for user in users:
                if hasattr(user, 'username') and user.username and user.username.lower() == query.lower():
                    return user
                full = f"{getattr(user, 'first_name', '')} {getattr(user, 'last_name', '')}".strip().lower()
                if query.lower() in full:
                    return user
            return None
        except:
            return None

    def _download_user_photo(self, photo, user_id):
        try:
            req = TLRPC.TL_upload_getFile()
            location = TLRPC.TL_inputPeerPhotoFileLocation()
            location.photo_id = photo.photo_id
            location.peer = TLRPC.TL_inputPeerUser(user_id=user_id, access_hash=0)
            req.location = location
            req.offset = 0
            req.limit = 1024 * 1024
            send_request(req, RequestCallback(self.handle_get_file_callback))
        except:
            self.create_profile_without_avatar()

    def handle_get_file_callback(self, response, error):
        if error or not response:
            return self.create_profile_without_avatar()
        try:
            buffer = response.bytes.buffer
            buffer.rewind()
            data = bytearray(buffer.remaining())
            buffer.get(data)
            tmp_file = f"avatar_{uuid.uuid4()}.jpg"
            temp_dir = Filesystem.get_temp_dir()
            self.avatar_file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
            Filesystem.write_file(self.avatar_file_path, bytes(data))
            self.create_profile_with_avatar()
        except:
            self.create_profile_without_avatar()

    def create_profile_with_avatar(self):
        self._create_profile(avatar_path=self.avatar_file_path)

    def create_profile_without_avatar(self):
        self._create_profile(avatar_path=None)

    def _create_profile(self, avatar_path):
        try:
            tmp_file = f"profile_{uuid.uuid4()}.png"
            temp_dir = Filesystem.get_temp_dir()
            file_path = Filesystem.get_absolute_path(temp_dir, tmp_file)
            profile_data = self.get_profile_data()
            self.create_profile_image(file_path, profile_data, avatar_path)
        except:
            plog("create profile error\n" + str(traceback.format_exc()))
            BulletinHelper.show_error(LocalizationManager.get_string("error"))

    def get_profile_data(self):
        user = self.user
        if not user:
            return {}

        first = getattr(user, 'first_name', '') or ''
        last = getattr(user, 'last_name', '') or ''
        full_name = f"{first} {last}".strip()
        is_deleted = any(w in full_name.lower() for w in ['deleted', 'temporarily', 'временно', 'недоступен'])
        name = "Удалённый аккаунт" if is_deleted else (full_name or getattr(user, 'username', '') or "Пользователь")
        username = f"@{user.username}" if getattr(user, 'username', None) else "Нет username"
        phone = f"+{user.phone}" if getattr(user, 'phone', None) else "Неизвестен"
        status = self.get_user_status(user)
        about = self.get_user_about(user)
        is_premium = getattr(user, 'premium', False)
        dc_info = self.get_dc_info(user)
        reg_date = self.get_registration_date(getattr(user, 'id', None))

        return {
            'name': name,
            'username': username,
            'phone': phone,
            'status': status,
            'about': about,
            'user_id': getattr(user, 'id', None),
            'is_premium': is_premium,
            'dc_info': dc_info,
            'reg_date': reg_date,
            'first_name': first,
            'last_name': last
        }

    def get_user_status(self, user):
        if not hasattr(user, 'status') or not user.status:
            return "был(а) недавно"

        s = user.status
        cls = s.__class__.__name__

        if cls == 'UserStatusOnline':
            return "в сети"
        elif cls == 'UserStatusOffline' and hasattr(s, 'was_online') and s.was_online:
            diff = int(time.time()) - s.was_online
            if diff < 60:
                return f"был(а) в сети {diff} сек назад"
            elif diff < 3600:
                return f"был(а) в сети {diff // 60} мин назад"
            elif diff < 86400:
                return f"был(а) в сети {diff // 3600} ч назад"
            else:
                from java.text import SimpleDateFormat
                return f"был(а) в сети в {SimpleDateFormat('HH:mm').format(java.util.Date(s.was_online * 1000))}"
        elif cls == 'UserStatusRecently':
            return "был(а) недавно"
        elif cls == 'UserStatusLastWeek':
            return "был(а) на этой неделе"
        elif cls == 'UserStatusLastMonth':
            return "был(а) в этом месяце"
        else:
            return "был(а) недавно"

    def get_user_about(self, user):
        try:
            full = get_messages_controller().getUserFull(user.id)
            if full and hasattr(full, 'about') and full.about:
                return (full.about[:200] + "...") if len(full.about) > 200 else full.about
        except:
            pass
        return None

    def get_dc_info(self, user):
        if hasattr(user, 'photo') and user.photo and hasattr(user.photo, 'dc_id'):
            dc = user.photo.dc_id
            locs = {1: "Miami FL, USA", 2: "Amsterdam, NL", 3: "Miami FL, USA", 4: "Amsterdam, NL", 5: "Singapore, SG"}
            return f"DC{dc}, {locs.get(dc, f'DC {dc}')}"
        return "Неизвестен"

    def get_registration_date(self, user_id):
        try:
            u = TelegramUtils.get_user(user_id)
            if u and hasattr(u, 'date') and u.date:
                return java.text.SimpleDateFormat("dd.MM.yyyy HH:mm").format(java.util.Date(u.date * 1000))
        except:
            pass
        return None

    def create_profile_image(self, output_path, profile_data, avatar_path):
        WIDTH = 400
        AVATAR_SIZE = 55
        AVATAR_LEFT = 15
        AVATAR_TOP = 25
        NAME_LEFT = AVATAR_LEFT + AVATAR_SIZE + 12
        PADDING = 16
        HEADER_HEIGHT = 100

        font_path = FontManager.get(self.font_index).get_path()
        try:
            font_name = ImageFont.truetype(font_path, 18)
            font_status = ImageFont.truetype(font_path, 14)
            font_section = ImageFont.truetype(font_path, 15)
            font_info = ImageFont.truetype(font_path, 16)
            font_label = ImageFont.truetype(font_path, 14)
            font_small = ImageFont.truetype(font_path, 13)
        except:
            font_name = ImageFont.load_default()
            font_status = ImageFont.load_default()
            font_section = ImageFont.load_default()
            font_info = ImageFont.load_default()
            font_label = ImageFont.load_default()
            font_small = ImageFont.load_default()

        base_height = 300
        about = profile_data.get('about')
        if about:
            lines = (len(about) // 45) + 1
            base_height += max(0, lines * 22 - 22) + 15
        if profile_data.get('reg_date'):
            base_height += 30

        height = HEADER_HEIGHT + base_height + 15
        img = Image.new('RGB', (WIDTH, height), self._hex_to_rgb(self.bg_color))
        draw = ImageDraw.Draw(img)
        draw.rectangle((0, 0, WIDTH, HEADER_HEIGHT), fill=self._hex_to_rgb(self.header_bg_color))

        avatar_img = None
        if avatar_path and os.path.exists(avatar_path):
            try:
                avatar = Image.open(avatar_path).convert("RGBA")
                avatar = avatar.resize((AVATAR_SIZE, AVATAR_SIZE))
                mask = Image.new("L", (AVATAR_SIZE, AVATAR_SIZE), 0)
                ImageDraw.Draw(mask).ellipse((0, 0, AVATAR_SIZE, AVATAR_SIZE), fill=255)
                result = Image.new("RGBA", (AVATAR_SIZE, AVATAR_SIZE))
                result.paste(avatar, (0, 0), mask)
                avatar_img = result
            except:
                pass

        if avatar_img:
            img.paste(avatar_img, (AVATAR_LEFT, AVATAR_TOP), avatar_img)
        else:
            draw.ellipse((AVATAR_LEFT, AVATAR_TOP, AVATAR_LEFT + AVATAR_SIZE, AVATAR_TOP + AVATAR_SIZE),
                         fill=self._hex_to_rgb(self.accent_color))
            # === ИНИЦИАЛЫ ===
            first = (profile_data.get('first_name') or "")[:1].upper()
            last = (profile_data.get('last_name') or "")[:1].upper()
            initials = (first + last)[:2] or "??"
            try:
                bbox = draw.textbbox((0, 0), initials, font=font_name)
                tw = bbox[2] - bbox[0]
                th = bbox[3] - bbox[1]
                x = AVATAR_LEFT + (AVATAR_SIZE - tw) // 2
                y = AVATAR_TOP + (AVATAR_SIZE - th) // 2 - 2
                draw.text((x, y), initials, fill="white", font=font_name)
            except:
                draw.text((AVATAR_LEFT + 15, AVATAR_TOP + 15), initials, fill="white")

        name = profile_data.get('name', '')
        try:
            max_width = WIDTH - NAME_LEFT - 10
            truncated = self.smart_truncate(draw, name, font_name, max_width)
            draw.text((NAME_LEFT, AVATAR_TOP + 8), truncated, font=font_name, fill=self.name_color)
            bbox = draw.textbbox((0, 0), truncated, font=font_name)
            text_width = bbox[2]
        except:
            draw.text((NAME_LEFT, AVATAR_TOP + 8), name[:20], fill=self.name_color)
            text_width = 100

        status = profile_data.get('status', '')
        status_color = self.online_color if status == "в сети" else self.offline_color
        try:
            draw.text((NAME_LEFT, AVATAR_TOP + 33), status, font=font_status, fill=status_color)
        except:
            draw.text((NAME_LEFT, AVATAR_TOP + 33), status, fill=status_color)

        if profile_data.get('is_premium'):
            try:
                crown = self.create_premium_icon(15)
                if crown:
                    img.paste(crown, (NAME_LEFT + int(text_width) + 5, AVATAR_TOP + 12), crown)
            except:
                pass

        draw.rectangle((0, HEADER_HEIGHT, WIDTH, height), fill=self._hex_to_rgb(self.info_bg_color))
        y = HEADER_HEIGHT + 15
        try:
            draw.text((PADDING, y), "Информация", font=font_section, fill=self.section_color)
        except:
            draw.text((PADDING, y), "Информация", fill=self.section_color)
        y += 30

        if about:
            words = about.split()
            lines = []
            line = ""
            for word in words:
                test_line = f"{line} {word}".strip()
                try:
                    if draw.textlength(test_line, font=font_info) <= WIDTH - 2 * PADDING:
                        line = test_line
                    else:
                        if line:
                            lines.append(line)
                        line = word
                except:
                    line = test_line
            if line:
                lines.append(line)
            for line in lines:
                draw.text((PADDING, y), line, font=font_info, fill=self.text_color)
                y += 22
            draw.text((PADDING, y), "О себе", font=font_label, fill=self.sub_text_color)
            y += 30

        username = profile_data.get('username')
        if username and username != "Нет username":
            draw.text((PADDING, y), username, font=font_info, fill=self.text_color)
            y += 25
            draw.text((PADDING, y), "Имя пользователя", font=font_label, fill=self.sub_text_color)
            y += 30

        phone = profile_data.get('phone')
        draw.text((PADDING, y), phone, font=font_info, fill=self.text_color)
        y += 25
        draw.text((PADDING, y), "Телефон", font=font_label, fill=self.sub_text_color)
        y += 30

        reg_date = profile_data.get('reg_date')
        if reg_date:
            draw.text((PADDING, y), reg_date, font=font_info, fill=self.text_color)
            y += 25
            draw.text((PADDING, y), "Дата регистрации аккаунта", font=font_label, fill=self.sub_text_color)
            y += 30

        user_id = profile_data.get('user_id')
        dc_info = profile_data.get('dc_info')
        if user_id:
            draw.text((PADDING, y), str(user_id), font=font_info, fill=self.text_color)
            y += 25
            draw.text((PADDING, y), dc_info, font=font_small, fill=self.sub_text_color)

        img.save(output_path, "PNG")
        self._send_profile(output_path)

    def smart_truncate(self, draw, text, font, max_width):
        if draw.textlength(text, font=font) <= max_width:
            return text
        for i in range(len(text), 0, -1):
            test = text[:i] + "..."
            if draw.textlength(test, font=font) <= max_width:
                return test
        return text[:1] + "..."

    def _hex_to_rgb(self, hex_color):
        h = hex_color.lstrip('#')
        return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

    def create_premium_icon(self, size):
        try:
            img = Image.new("RGBA", (size, size), (0, 0, 0, 0))
            draw = ImageDraw.Draw(img)
            draw.ellipse((0, 0, size, size), fill=(255, 204, 0, 255))
            draw.text((size//2 - 5, size//2 - 6), "👑", fill="white", font=ImageFont.load_default())
            return img
        except:
            return None

    def _send_profile(self, output_path):
        try:
            helper = get_send_messages_helper()
            photo = helper.generatePhotoSizes(output_path, None)
            send_message({"peer": self.params.peer, "photo": photo, "path": output_path})
        except:
            plog("send_profile error\n" + str(traceback.format_exc()))
            BulletinHelper.show_error(LocalizationManager.get_string("photo_error"))

class FontManager:
    fonts = []
    custom_font_url = ""
    @staticmethod
    def init():
        FontManager.fonts = [
            Font("Huninn", "https://fonts.gstatic.com/s/huninn/v2/OpNNnoINg9bQ4xkpjiHQjittXw.ttf"),
            Font("Roboto", "https://fonts.gstatic.com/s/roboto/v49/KFOmCnqEu92Fr1Mu72xKOzY.woff2"),
            Font("Montserrat", "https://fonts.gstatic.com/s/montserrat/v31/JTUSjIg69CK48gW7PXoo9W1hyzY.woff2"),
            Font("Ubuntu", "https://fonts.gstatic.com/s/ubuntu/v21/4iCs6KVjbNBYlgoKfw72.woff2"),
            Font("Кастомный шрифт", None)
        ]
        threading.Thread(target=FontManager._download_fonts, daemon=True).start()

    @staticmethod
    def _download_fonts():
        for font in FontManager.fonts:
            if font.download_uri and not font.exists():
                font.download()

    @staticmethod
    def get(index):
        if index == 4:
            url = FontManager.custom_font_url
            if url:
                temp_dir = Filesystem.get_temp_dir()
                path = Filesystem.get_absolute_path(temp_dir, "custom_font.ttf")
                if not os.path.exists(path):
                    try:
                        resp = requests.get(url, timeout=15)
                        with open(path, 'wb') as f:
                            f.write(resp.content)
                    except:
                        return FontManager.fonts[0]
                return Font("Кастомный", None, custom_path=path)
        return FontManager.fonts[index]

    @staticmethod
    def get_fonts_names():
        return [f.name for f in FontManager.fonts]

class Font:
    def __init__(self, name, download_uri, custom_path=None):
        self.name = name
        self.download_uri = download_uri
        self.custom_path = custom_path

    def get_path(self):
        if self.custom_path:
            return self.custom_path
        temp_dir = Filesystem.get_temp_dir()
        fn = self.name.replace(" ", "_") + ".ttf"
        return Filesystem.get_absolute_path(temp_dir, fn)

    def exists(self):
        return os.path.exists(self.get_path())

    def download(self):
        if not self.download_uri or self.exists():
            return
        try:
            resp = requests.get(self.download_uri, timeout=10)
            with open(self.get_path(), 'wb') as f:
                f.write(resp.content)
        except:
            pass