#Author: @SaturnFake #Channel: @Fantom_Plugins
__id__ = "web_file_manager"
__name__ = "Web File Manager"
__description__ = (
    "Плагин с веб-панелью для управления файлами\n"
    ".fm - получить актуальную local-ссылку на веб-панель\n"
    ".cc - очистить кеш HTML-страниц, не использовать, BUG(!)"
)
__author__ = "@SaturnFake"
__version__ = "1.0.0"
__icon__ = "exteraPlugins/1"
__min_version__ = "12.1.1"

import os
import threading
import time
import json
import requests
import socket
import zipfile
import tempfile
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse, parse_qs

from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, AppEvent, MenuItemData, MenuItemType, HookResult, HookStrategy
from client_utils import get_last_fragment, send_message, run_on_queue
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from file_utils import ensure_dir_exists, list_dir

try:
    import socketserver as ss
    import http.server as http_h
    HTTPRequestHandler = http_h.BaseHTTPRequestHandler
    HTTPServer = http_h.HTTPServer
except ImportError:
    try:
        import sys
        sys.path.append('/data/data/ru.ivxt.client/includes')
        import socketserver as ss
        from urllib.parse import urlparse, parse_qs
        import http.server as http_h
        HTTPRequestHandler = http_h.BaseHTTPRequestHandler
        HTTPServer = http_h.HTTPServer
    except ImportError:
        log("WebFileManager: HTTP сервер недоступен, используем без веб-интерфейса")
        ss = None
        HTTPRequestHandler = object
        HTTPServer = object

#Author: @SaturnFake #Channel: @Fantom_Plugins

class FileManager:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.current_path = "/"
        self.history_stack = []
        self._lock = threading.Lock()
        self.ROOT_PATHS = self._get_root_paths()

    def _get_root_paths(self) -> Dict[str, str]:
        try:
            from file_utils import (
                get_plugins_dir, get_cache_dir, get_files_dir,
                get_images_dir, get_videos_dir, get_audios_dir, get_documents_dir
            )
            return {
                "plugins": get_plugins_dir(),
                "cache": get_cache_dir(),
                "files": get_files_dir(),
                "images": get_images_dir(),
                "videos": get_videos_dir(),
                "audios": get_audios_dir(),
                "documents": get_documents_dir(),
                "/": "/"
            }
        except Exception as e:
            log(f"WebFileManager: Ошибка получения путей: {e}")
            return {
                "/": "/",
                "plugins": "/data/data/com.exteragram.messenger/files/plugins",
                "cache": "/data/data/com.exteragram.messenger/cache",
                "files": "/data/data/com.exteragram.messenger/files"
            }

    def get_current_path(self) -> str:
        with self._lock:
            return self.current_path

    def set_current_path(self, path: str):
        with self._lock:
            self.history_stack.append(self.current_path)
            self.current_path = path

    def go_back(self) -> str:
        with self._lock:
            if self.history_stack:
                self.current_path = self.history_stack.pop()
            return self.current_path

    def reset_to_root(self):
        with self._lock:
            self.current_path = "/"
            self.history_stack.clear()

    def navigate_to(self, path: str) -> Tuple[bool, str]:
        try:
            path = os.path.normpath(path)
            if path == "/" or path == ".":
                self.set_current_path("/")
                return True, ""
            if path.startswith("/"):
                abs_path = path
            else:
                current = self.get_current_path()
                if current == "/":
                    abs_path = "/" + path
                else:
                    abs_path = os.path.join(current, path)
            abs_path = os.path.normpath(abs_path)
            if os.path.exists(abs_path) and os.path.isdir(abs_path):
                self.set_current_path(abs_path)
                return True, ""
            else:
                return False, "Папка не найдена"
        except Exception as e:
            return False, f"Ошибка навигации: {e}"

    def get_directory_listing(self, path: Optional[str] = None) -> Dict:
        if not path:
            path = self.get_current_path()
        try:
            if not os.path.exists(path) or not os.path.isdir(path):
                return {
                    "success": False,
                    "error": f"Папка не найдена: {path}",
                    "path": path,
                    "directories": [],
                    "files": [],
                    "total_items": 0,
                    "dir_count": 0,
                    "file_count": 0,
                    "timestamp": int(time.time())
                }
            items = os.listdir(path)
            file_list = []
            dir_list = []
            for item_name in items:
                try:
                    item_path = os.path.join(path, item_name)
                    if os.path.isdir(item_path):
                        try:
                            sub_items = os.listdir(item_path)
                            dir_count = len(sub_items)
                        except (PermissionError, OSError):
                            dir_count = 0
                        stat_info = os.stat(item_path)
                        dir_list.append({
                            "name": item_name,
                            "path": item_path,
                            "type": "directory",
                            "size": 0,
                            "dir_count": dir_count,
                            "modified": stat_info.st_mtime,
                            "modified_formatted": datetime.fromtimestamp(stat_info.st_mtime).strftime('%d.%m.%Y %H:%M:%S')
                        })
                    else:
                        stat_info = os.stat(item_path)
                        size = stat_info.st_size
                        file_list.append({
                            "name": item_name,
                            "path": item_path,
                            "type": "file",
                            "size": size,
                            "size_formatted": self._format_size(size),
                            "modified": stat_info.st_mtime,
                            "modified_formatted": datetime.fromtimestamp(stat_info.st_mtime).strftime('%d.%m.%Y %H:%M:%S')
                        })
                except (OSError, PermissionError) as e:
                    log(f"WebFileManager: Ошибка обработки элемента {item_name}: {e}")
                    continue
            dir_list.sort(key=lambda x: x['name'].lower())
            file_list.sort(key=lambda x: x['name'].lower())
            parent_path = os.path.dirname(path) if path != "/" else "/"
            path_parts = []
            if path != "/":
                parts = path.strip("/").split("/")
                current = "/"
                for i, part in enumerate(parts):
                    current = os.path.join(current, part) if current != "/" else "/" + part
                    path_parts.append({
                        "name": part,
                        "path": current
                    })
            return {
                "success": True,
                "path": path,
                "parent_path": parent_path,
                "path_parts": path_parts,
                "directories": dir_list,
                "files": file_list,
                "total_items": len(dir_list) + len(file_list),
                "dir_count": len(dir_list),
                "file_count": len(file_list),
                "timestamp": int(time.time())
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "path": path,
                "directories": [],
                "files": [],
                "total_items": 0,
                "dir_count": 0,
                "file_count": 0,
                "timestamp": int(time.time())
            }

#Author: @SaturnFake #Channel: @Fantom_Plugins

    def get_root_paths_info(self) -> List[Dict]:
        root_info = []
        for name, path in self.ROOT_PATHS.items():
            try:
                if os.path.exists(path) and os.path.isdir(path):
                    stat = os.stat(path)
                    try:
                        items = os.listdir(path)
                        dir_count = len([x for x in items if os.path.isdir(os.path.join(path, x))])
                        file_count = len([x for x in items if os.path.isfile(os.path.join(path, x))])
                        total_count = len(items)
                    except (PermissionError, OSError):
                        dir_count = file_count = total_count = 0
                    root_info.append({
                        "name": name,
                        "path": path,
                        "exists": True,
                        "size": self._get_directory_size(path),
                        "size_formatted": self._format_size(self._get_directory_size(path)),
                        "dir_count": dir_count,
                        "file_count": file_count,
                        "total_count": total_count,
                        "modified": stat.st_mtime,
                        "modified_formatted": datetime.fromtimestamp(stat.st_mtime).strftime('%d.%m.%Y %H:%M:%S')
                    })
                else:
                    root_info.append({
                        "name": name,
                        "path": path,
                        "exists": False,
                        "size": 0,
                        "size_formatted": "0 B",
                        "dir_count": 0,
                        "file_count": 0,
                        "total_count": 0,
                        "modified": 0,
                        "modified_formatted": "Не найден"
                    })
            except Exception as e:
                root_info.append({
                    "name": name,
                    "path": path,
                    "exists": False,
                    "size": 0,
                    "size_formatted": "Ошибка",
                    "dir_count": 0,
                    "file_count": 0,
                    "total_count": 0,
                    "modified": 0,
                    "modified_formatted": f"Ошибка: {str(e)[:20]}"
                })
        return root_info

    def get_root_paths_stats(self) -> Dict:
        roots_info = self.get_root_paths_info()
        total_dir_count = sum(root.get('dir_count', 0) for root in roots_info)
        total_file_count = sum(root.get('file_count', 0) for root in roots_info)
        total_items = total_dir_count + total_file_count
        return {
            'total_items': total_items,
            'dir_count': total_dir_count,
            'file_count': total_file_count
        }

    def _get_directory_size(self, path: str) -> int:
        try:
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except (OSError, IOError):
                        continue
            return total_size
        except Exception:
            return 0

    def _format_size(self, size_bytes: int) -> str:
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = 0
        while size_bytes >= 1024 and i < len(size_names) - 1:
            size_bytes /= 1024.0
            i += 1
        return f"{size_bytes:.1f} {size_names[i]}"

    def create_zip_archive(self, folder_path: str) -> Tuple[bool, str, Optional[str]]:
        try:
            if not os.path.exists(folder_path):
                return False, "Папка не найдена", None
            if not os.path.isdir(folder_path):
                return False, "Это не папка", None
            temp_fd, temp_path = tempfile.mkstemp(suffix='.zip', prefix='folder_')
            os.close(temp_fd)
            folder_name = os.path.basename(folder_path) or "folder"
            zip_filename = f"{folder_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            try:
                with zipfile.ZipFile(temp_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for root, dirs, files in os.walk(folder_path):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, os.path.dirname(folder_path))
                            zipf.write(file_path, arcname)
                return True, f"Архив создан: {zip_filename}", temp_path
            except Exception as e:
                if os.path.exists(temp_path):
                    os.remove(temp_path)
                return False, f"Ошибка создания архива: {str(e)}", None
        except Exception as e:
            return False, f"Ошибка: {str(e)}", None

    def read_file_content(self, file_path: str) -> Tuple[bool, str, Optional[str]]:
        try:
            if not os.path.exists(file_path):
                return False, "Файл не найден", None
            if not os.path.isfile(file_path):
                return False, "Это не файл", None
            file_size = os.path.getsize(file_path)
            if file_size > 5 * 1024 * 1024:
                return False, "Файл слишком большой для редактирования (макс. 5MB)", None
            try:
                for encoding in ['utf-8', 'cp1251', 'latin-1']:
                    try:
                        with open(file_path, 'r', encoding=encoding) as f:
                            content = f.read()
                        return True, f"Файл загружен ({self._format_size(file_size)})", content
                    except UnicodeDecodeError:
                        continue
                return False, "Не удалось определить кодировку файла", None
            except Exception as e:
                return False, f"Ошибка чтения файла: {str(e)}", None
        except Exception as e:
            return False, f"Ошибка: {str(e)}", None

    def save_file_content(self, file_path: str, content: str) -> Tuple[bool, str]:
        try:
            if not os.path.exists(file_path):
                return False, "Файл не найден"
            if not os.path.isfile(file_path):
                return False, "Это не файл"
            try:
                backup_path = file_path + '.backup'
                if os.path.exists(backup_path):
                    os.remove(backup_path)
                os.rename(file_path, backup_path)
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                return True, "Файл сохранен успешно"
            except Exception as e:
                if os.path.exists(backup_path):
                    os.rename(backup_path, file_path)
                return False, f"Ошибка записи файла: {str(e)}"
        except Exception as e:
            return False, f"Ошибка: {str(e)}"

    def rename_item(self, old_path: str, new_name: str) -> Tuple[bool, str]:
        try:
            if not os.path.exists(old_path):
                return False, "Файл/папка не найден"
            parent_dir = os.path.dirname(old_path)
            new_path = os.path.join(parent_dir, new_name)
            if os.path.exists(new_path) and new_path != old_path:
                return False, "Файл/папка с таким именем уже существует"
            os.rename(old_path, new_path)
            return True, "Переименовано успешно"
        except Exception as e:
            return False, f"Ошибка переименования: {str(e)}"

#Author: @SaturnFake #Channel: @Fantom_Plugins

class WebFileManagerHandler(HTTPRequestHandler if ss else object):
    def __init__(self, plugin_instance, *args, **kwargs):
        self.plugin = plugin_instance
        if ss:
            super().__init__(*args, **kwargs)

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        if not ss:
            return
        try:
            parsed_path = urlparse(self.path)
            path = parsed_path.path
            if path == '/' or path == '/index.html':
                self._serve_index()
            elif path == '/api/roots':
                self._serve_roots()
            elif path == '/api/list':
                self._serve_directory_listing(parsed_path.query)
            elif path == '/api/download':
                self._serve_file_download(parsed_path.query)
            elif path == '/api/download-folder':
                self._serve_folder_download(parsed_path.query)
            elif path == '/api/read-file':
                self._serve_file_read(parsed_path.query)
            elif path == '/api/stats':
                self._serve_stats()
            elif path == '/api/breadcrumbs':
                self._serve_breadcrumbs()
            elif path == '/api/heartbeat':
                self._serve_heartbeat()
            else:
                self._serve_404()
        except Exception as e:
            log(f"WebFileManager: Ошибка GET: {e}")
            self._serve_error(str(e))

    def do_POST(self):
        if not ss:
            return
        try:
            parsed_path = urlparse(self.path)
            path = parsed_path.path
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length).decode('utf-8') if content_length > 0 else '{}'
            try:
                data = json.loads(post_data) if post_data else {}
            except json.JSONDecodeError:
                data = {}
            if path == '/api/navigate':
                self._handle_navigate_request(data)
            elif path == '/api/upload':
                self._handle_upload_request()
            elif path == '/api/delete':
                self._handle_delete_request(data)
            elif path == '/api/create_folder':
                self._handle_create_folder_request(data)
            elif path == '/api/refresh':
                self._handle_refresh_request(data)
            elif path == '/api/go_home':
                self._handle_go_home_request(data)
            elif path == '/api/save-file':
                self._handle_save_file_request(data)
            elif path == '/api/rename':
                self._handle_rename_request(data)
            elif path == '/api/refresh-html':
                self._handle_refresh_html_request()
            else:
                self._serve_404()
        except Exception as e:
            log(f"WebFileManager: Ошибка POST: {e}")
            self._serve_error(str(e))

    def do_OPTIONS(self):
        if not ss:
            return
        self.send_response(200)
        self._set_cors_headers()
        self.end_headers()

    def _serve_heartbeat(self):
        self._send_json({
            'status': 'alive',
            'timestamp': int(time.time()),
            'server_time': datetime.now().isoformat(),
            'version': '1.0.0'
        })

    def _serve_stats(self):
        try:
            current_path = self.plugin.file_manager.get_current_path()
            listing = self.plugin.file_manager.get_directory_listing(current_path)
            self._send_json({
                'success': True,
                'current_path': current_path,
                'total_items': listing.get('total_items', 0),
                'dir_count': listing.get('dir_count', 0),
                'file_count': listing.get('file_count', 0),
                'history_depth': len(self.plugin.file_manager.history_stack),
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _serve_roots(self):
        try:
            roots_info = self.plugin.file_manager.get_root_paths_info()
            root_stats = self.plugin.file_manager.get_root_paths_stats()
            self._send_json({
                'success': True,
                'roots': roots_info,
                'root_stats': root_stats,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _serve_breadcrumbs(self):
        try:
            current_path = self.plugin.file_manager.get_current_path()
            if current_path == "/":
                self._send_json({
                    'success': True,
                    'current_path': current_path,
                    'breadcrumbs': [],
                    'parent_path': "/",
                    'timestamp': int(time.time())
                })
                return
            listing = self.plugin.file_manager.get_directory_listing(current_path)
            self._send_json({
                'success': True,
                'current_path': current_path,
                'breadcrumbs': listing.get('path_parts', []),
                'parent_path': listing.get('parent_path'),
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _serve_directory_listing(self, query_string: str):
        try:
            params = parse_qs(query_string)
            path = params.get('path', [None])[0]
            listing = self.plugin.file_manager.get_directory_listing(path)
            self._send_json(listing)
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _serve_file_download(self, query_string: str):
        try:
            params = parse_qs(query_string)
            file_path = params.get('file', [None])[0]
            if not file_path:
                self._send_json({
                    'success': False,
                    'error': 'Файл не указан',
                    'timestamp': int(time.time())
                })
                return
            if not os.path.exists(file_path):
                self._send_json({
                    'success': False,
                    'error': 'Файл не найден',
                    'timestamp': int(time.time())
                })
                return
            if os.path.isdir(file_path):
                self._send_json({
                    'success': False,
                    'error': 'Нельзя скачать папку',
                    'timestamp': int(time.time())
                })
                return
            try:
                file_size = os.path.getsize(file_path)
                file_name = os.path.basename(file_path)
                self.send_response(200)
                self.send_header('Content-Type', 'application/octet-stream')
                self.send_header('Content-Disposition', f'attachment; filename="{file_name}"')
                self.send_header('Content-Length', str(file_size))
                self._set_cors_headers()
                self.end_headers()
                with open(file_path, 'rb') as f:
                    self.wfile.write(f.read())
                log(f"WebFileManager: Скачан файл {file_name} ({self.plugin.file_manager._format_size(file_size)})")
            except Exception as e:
                self._send_json({
                    'success': False,
                    'error': f'Ошибка чтения файла: {str(e)}',
                    'timestamp': int(time.time())
                })
        except Exception as e:
            self._serve_error(str(e))

    def _serve_folder_download(self, query_string: str):
        try:
            params = parse_qs(query_string)
            folder_path = params.get('folder', [None])[0]
            if not folder_path:
                self._send_json({
                    'success': False,
                    'error': 'Папка не указана',
                    'timestamp': int(time.time())
                })
                return
            success, message, zip_path = self.plugin.file_manager.create_zip_archive(folder_path)
            if not success:
                self._send_json({
                    'success': False,
                    'error': message,
                    'timestamp': int(time.time())
                })
                return
            try:
                zip_name = os.path.basename(zip_path)
                zip_size = os.path.getsize(zip_path)
                self.send_response(200)
                self.send_header('Content-Type', 'application/zip')
                self.send_header('Content-Disposition', f'attachment; filename="{zip_name}"')
                self.send_header('Content-Length', str(zip_size))
                self._set_cors_headers()
                self.end_headers()
                with open(zip_path, 'rb') as f:
                    self.wfile.write(f.read())
                log(f"WebFileManager: Скачан архив {zip_name} ({self.plugin.file_manager._format_size(zip_size)})")
            except Exception as e:
                self._send_json({
                    'success': False,
                    'error': f'Ошибка отправки архива: {str(e)}',
                    'timestamp': int(time.time())
                })
            finally:
                if os.path.exists(zip_path):
                    try:
                        os.remove(zip_path)
                    except:
                        pass
        except Exception as e:
            self._serve_error(str(e))

    def _serve_file_read(self, query_string: str):
        try:
            params = parse_qs(query_string)
            file_path = params.get('file', [None])[0]
            if not file_path:
                self._send_json({
                    'success': False,
                    'error': 'Файл не указан',
                    'timestamp': int(time.time())
                })
                return
            success, message, content = self.plugin.file_manager.read_file_content(file_path)
            file_extension = os.path.splitext(file_path)[1].lower()
            language = self._get_language_from_extension(file_extension)
            self._send_json({
                'success': success,
                'message': message,
                'content': content if success else None,
                'file_path': file_path,
                'language': language,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _get_language_from_extension(self, extension: str) -> str:
        lang_map = {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.jsx': 'jsx',
            '.tsx': 'tsx',
            '.java': 'text/x-java',
            '.kt': 'text/x-kotlin',
            '.xml': 'xml',
            '.html': 'htmlmixed',
            '.htm': 'htmlmixed',
            '.css': 'css',
            '.scss': 'text/x-scss',
            '.sass': 'text/x-sass',
            '.less': 'text/x-less',
            '.json': 'application/json',
            '.yaml': 'text/x-yaml',
            '.yml': 'text/x-yaml',
            '.md': 'text/x-markdown',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            '.sh': 'text/x-shellscript',
            '.bash': 'text/x-shellscript',
            '.zsh': 'text/x-shellscript',
            '.fish': 'text/x-shellscript',
            '.bat': 'text/x-msdos-batch',
            '.ps1': 'powershell',
            '.sql': 'text/x-sql',
            '.php': 'text/x-php',
            '.rb': 'text/x-ruby',
            '.go': 'text/x-go',
            '.rs': 'text/x-rust',
            '.c': 'text/x-csrc',
            '.cpp': 'text/x-c++src',
            '.cxx': 'text/x-c++src',
            '.cc': 'text/x-c++src',
            '.h': 'text/x-csrc',
            '.hpp': 'text/x-c++src',
            '.hxx': 'text/x-c++src',
            '.cs': 'text/x-csharp',
            '.vb': 'text/x-vb',
            '.swift': 'text/x-swift',
            '.dart': 'text/x-dart',
            '.r': 'text/x-rsrc',
            '.m': 'text/x-objectivec',
            '.mm': 'text/x-objectivec',
            '.scala': 'text/x-scala',
            '.clj': 'text/x-clojure',
            '.hs': 'text/x-haskell',
            '.elm': 'text/x-elm',
            '.ex': 'text/x-elixir',
            '.exs': 'text/x-elixir',
            '.erl': 'text/x-erlang',
            '.hrl': 'text/x-erlang',
            '.pl': 'text/x-perl',
            '.pm': 'text/x-perl',
            '.lua': 'text/x-lua',
            '.vim': 'text/x-vim'
        }
        return lang_map.get(extension, 'text/plain')

#Author: @SaturnFake #Channel: @Fantom_Plugins

    def _handle_navigate_request(self, data: Dict):
        try:
            path = data.get('path')
            action = data.get('action', 'navigate')
            success = False
            message = ""
            if action == 'back':
                new_path = self.plugin.file_manager.go_back()
                success = True
                message = ""
            else:
                success, message = self.plugin.file_manager.navigate_to(path)
            current_path = self.plugin.file_manager.get_current_path()
            listing = self.plugin.file_manager.get_directory_listing(current_path)
            response_data = {
                'success': success,
                'message': message,
                'current_path': current_path,
                'listing': listing,
                'timestamp': int(time.time())
            }
            if current_path == "/":
                root_stats = self.plugin.file_manager.get_root_paths_stats()
                response_data['root_stats'] = root_stats
            self._send_json(response_data)
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_go_home_request(self, data: Dict):
        try:
            self.plugin.file_manager.reset_to_root()
            roots_info = self.plugin.file_manager.get_root_paths_info()
            root_stats = self.plugin.file_manager.get_root_paths_stats()
            self._send_json({
                'success': True,
                'message': 'Возврат в корневую папку',
                'current_path': '/',
                'roots': roots_info,
                'root_stats': root_stats,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_upload_request(self):
        try:
            self._send_json({
                'success': False,
                'error': 'Загрузка файлов пока не реализована',
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_delete_request(self, data: Dict):
        try:
            file_path = data.get('path')
            item_type = data.get('type')
            if not file_path or not os.path.exists(file_path):
                self._send_json({
                    'success': False,
                    'error': 'Файл/папка не найден',
                    'timestamp': int(time.time())
                })
                return
            if item_type == 'directory':
                if os.path.isdir(file_path):
                    import shutil
                    shutil.rmtree(file_path)
                    message = 'Папка удалена'
                else:
                    self._send_json({
                        'success': False,
                        'error': 'Это не папка',
                        'timestamp': int(time.time())
                    })
                    return
            else:
                if os.path.isfile(file_path):
                    os.remove(file_path)
                    message = 'Файл удален'
                else:
                    self._send_json({
                        'success': False,
                        'error': 'Это не файл',
                        'timestamp': int(time.time())
                    })
                    return
            current_path = self.plugin.file_manager.get_current_path()
            if file_path == current_path:
                self.plugin.file_manager.reset_to_root()
                current_path = "/"
            if current_path != "/":
                listing = self.plugin.file_manager.get_directory_listing(current_path)
            else:
                roots_info = self.plugin.file_manager.get_root_paths_info()
                root_stats = self.plugin.file_manager.get_root_paths_stats()
                listing = {'success': True, 'roots': roots_info, 'root_stats': root_stats}
            self._send_json({
                'success': True,
                'message': message,
                'current_path': current_path,
                'listing': listing,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_create_folder_request(self, data: Dict):
        try:
            parent_path = data.get('parent_path')
            folder_name = data.get('name')
            if not parent_path or not folder_name:
                self._send_json({
                    'success': False,
                    'error': 'Не указаны параметры',
                    'timestamp': int(time.time())
                })
                return
            new_folder_path = os.path.join(parent_path, folder_name)
            if os.path.exists(new_folder_path):
                self._send_json({
                    'success': False,
                    'error': 'Папка с таким именем уже существует',
                    'timestamp': int(time.time())
                })
                return
            os.makedirs(new_folder_path)
            self._send_json({
                'success': True,
                'message': f'Папка создана',
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_save_file_request(self, data: Dict):
        try:
            file_path = data.get('file_path')
            content = data.get('content')
            if not file_path or content is None:
                self._send_json({
                    'success': False,
                    'error': 'Не указаны параметры',
                    'timestamp': int(time.time())
                })
                return
            success, message = self.plugin.file_manager.save_file_content(file_path, content)
            self._send_json({
                'success': success,
                'message': message,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_rename_request(self, data: Dict):
        try:
            old_path = data.get('old_path')
            new_name = data.get('new_name')
            if not old_path or not new_name:
                self._send_json({
                    'success': False,
                    'error': 'Не указаны параметры',
                    'timestamp': int(time.time())
                })
                return
            success, message = self.plugin.file_manager.rename_item(old_path, new_name)
            current_path = self.plugin.file_manager.get_current_path()
            if current_path != "/":
                listing = self.plugin.file_manager.get_directory_listing(current_path)
            else:
                roots_info = self.plugin.file_manager.get_root_paths_info()
                root_stats = self.plugin.file_manager.get_root_paths_stats()
                listing = {'success': True, 'roots': roots_info, 'root_stats': root_stats}
            self._send_json({
                'success': success,
                'message': message,
                'listing': listing,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_refresh_request(self, data: Dict):
        try:
            path = data.get('path')
            if not path or path == self.plugin.file_manager.get_current_path():
                current_path = self.plugin.file_manager.get_current_path()
                if current_path == "/":
                    roots_info = self.plugin.file_manager.get_root_paths_info()
                    root_stats = self.plugin.file_manager.get_root_paths_stats()
                    listing = {'success': True, 'roots': roots_info, 'root_stats': root_stats}
                else:
                    listing = self.plugin.file_manager.get_directory_listing(current_path)
            else:
                listing = self.plugin.file_manager.get_directory_listing(path)
            self._send_json({
                'success': True,
                'listing': listing,
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _handle_refresh_html_request(self):
        try:
            run_on_queue(self.plugin._force_refresh_html)
            self._send_json({
                'success': True,
                'message': 'Запрос на обновление HTML отправлен',
                'timestamp': int(time.time())
            })
        except Exception as e:
            self._send_json({
                'success': False,
                'error': str(e),
                'timestamp': int(time.time())
            })

    def _serve_index(self):
        html = self.plugin.cached_html
        if html is None:
            html = """<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Web File Manager</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif; background:#000; color:#fff; display:flex; align-items:center; justify-content:center; height:100vh; margin:0; }
        .loading { text-align:center; }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes spin { 0%{ transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="loading">
        <div class="spinner"></div>
        <h2>Загрузка интерфейса...</h2>
        <p>Пожалуйста, подождите несколько секунд.</p>
    </div>
</body>
</html>"""
        self._send_response(200, html.encode('utf-8'), 'text/html')

    def _set_cors_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.send_header('Access-Control-Max-Age', '86400')

    def _send_response(self, code: int, content: bytes, content_type: str = 'text/plain'):
        if not ss:
            return
        try:
            self.send_response(code)
            self.send_header('Content-Type', content_type)
            self._set_cors_headers()
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
            self.end_headers()
            self.wfile.write(content)
        except Exception as e:
            log(f"WebFileManager: Ошибка отправки: {e}")

    def _send_json(self, data: Dict):
        try:
            def clean_for_json(obj):
                if isinstance(obj, dict):
                    return {k: clean_for_json(v) for k, v in obj.items()}
                elif isinstance(obj, list):
                    return [clean_for_json(item) for item in obj]
                elif isinstance(obj, (str, int, float, bool, type(None))):
                    return obj
                else:
                    return str(obj)
            cleaned_data = clean_for_json(data)
            json_data = json.dumps(cleaned_data, ensure_ascii=False, separators=(',', ':'))
            self._send_response(200, json_data.encode('utf-8'), 'application/json')
        except Exception as e:
            error_data = {"error": "Internal server error", "timestamp": int(time.time())}
            json_data = json.dumps(error_data)
            self._send_response(500, json_data.encode('utf-8'), 'application/json')

    def _serve_error(self, error: str):
        self._send_response(500, json.dumps({
            "error": error,
            "timestamp": int(time.time())
        }).encode('utf-8'), 'application/json')

    def _serve_404(self):
        self._send_response(404, json.dumps({
            "error": "Endpoint not found",
            "timestamp": int(time.time()),
            "available_endpoints": [
                "/api/roots",
                "/api/list",
                "/api/download",
                "/api/download-folder",
                "/api/read-file",
                "/api/stats",
                "/api/breadcrumbs",
                "/api/navigate",
                "/api/go_home",
                "/api/upload",
                "/api/delete",
                "/api/create_folder",
                "/api/refresh",
                "/api/save-file",
                "/api/rename",
                "/api/refresh-html"
            ]
        }).encode('utf-8'), 'application/json')

    def _format_size(self, size_bytes: int) -> str:
        if size_bytes == 0:
            return "0 B"
        size_names = ["B", "KB", "MB", "GB", "TB"]
        i = 0
        while size_bytes >= 1024 and i < len(size_names) - 1:
            size_bytes /= 1024.0
            i += 1
        return f"{size_bytes:.1f} {size_names[i]}"

#Author: @SaturnFake #Channel: @Fantom_Plugins

class WebFileManagerPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.web_server = None
        self.web_thread = None
        self.current_port = None
        self.file_manager = None
        self._server_lock = threading.Lock()
        self.context = None

        self.cached_html: Optional[str] = None

        self.html_source_url = "https://pastebin.com/raw/z1dCMHCj"

    def on_plugin_load(self):
        try:
            log("WebFileManager: Загрузка плагина v1.0.0...")

            try:
                fragment = get_last_fragment()
                if fragment:
                    self.context = fragment.getParentActivity()
            except Exception:
                pass

            self.file_manager = FileManager(self)

            self._start_html_fetch()

            self.add_on_send_message_hook()

            self._setup_menu()

            self._start_web_server()

            log("WebFileManager: Плагин загружен успешно")
        except Exception as e:
            log(f"WebFileManager: Ошибка загрузки: {e}")

    def on_plugin_unload(self):
        try:
            with self._server_lock:
                if self.web_server:
                    try:
                        self.web_server.shutdown()
                        self.web_server.server_close()
                    except:
                        pass

                    if self.web_thread and self.web_thread.is_alive():
                        self.web_thread.join(timeout=3)

                    self.web_server = None
                    self.web_thread = None

            log("WebFileManager: Плагин выгружен")
        except Exception as e:
            log(f"WebFileManager: Ошибка выгрузки: {e}")

    def _start_html_fetch(self):
        def _fetch():
            try:
                resp = requests.get(self.html_source_url, timeout=30)
                if resp.status_code == 200:
                    self.cached_html = resp.text
                    log("WebFileManager: HTML‑интерфейс успешно скачан")
                else:
                    log(f"WebFileManager: Ошибка загрузки HTML, HTTP {resp.status_code}")
                    self.cached_html = None
            except Exception as e:
                log(f"WebFileManager: Исключение при загрузке HTML: {e}")
                self.cached_html = None

        run_on_queue(_fetch)

    def _force_refresh_html(self):
        try:
            log("WebFileManager: Принудительное обновление HTML...")
            resp = requests.get(self.html_source_url, timeout=30)
            if resp.status_code == 200:
                self.cached_html = resp.text
                log("WebFileManager: HTML‑интерфейс обновлён")
            else:
                log(f"WebFileManager: Ошибка обновления HTML, HTTP {resp.status_code}")
        except Exception as e:
            log(f"WebFileManager: Исключение при обновлении HTML: {e}")

    def _clear_html_cache(self):
        self.cached_html = None
        log("WebFileManager: Кеш HTML очищен")

    def _start_web_server(self):
        if not ss:
            return

        def create_handler(*args, **kwargs):
            return WebFileManagerHandler(self, *args, **kwargs)

        ports_to_try = [8090, 8091, 8092, 8093, 3001, 5001]
        server_started = False

        for port in ports_to_try:
            try:
                if self._check_port_available('localhost', port):
                    self.web_server = HTTPServer(('localhost', port), create_handler)
                    self.web_server.allow_reuse_address = True
                    self.web_server.allow_reuse_port = True

                    self.web_thread = threading.Thread(target=self._serve_forever_wrapper, daemon=True)
                    self.web_thread.start()

                    self.current_port = port
                    server_started = True
                    log(f"WebFileManager: Сервер запущен на порту {port}")
                    break

            except Exception:
                if self.web_server:
                    try:
                        self.web_server.server_close()
                    except:
                        pass
                self.web_server = None
                continue

        if not server_started:
            log("WebFileManager: Не удалось запустить сервер")

    def _serve_forever_wrapper(self):
        try:
            with self._server_lock:
                if self.web_server:
                    self.web_server.serve_forever()
        except Exception:
            pass

    def _check_port_available(self, host: str, port: int) -> bool:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex((host, port))
                return result != 0
        except:
            return True

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:
            if hasattr(params, 'message') and isinstance(params.message, str):
                message = params.message.strip()

                if message.lower() == '.fm' or message.lower() == '. fm':
                    server_url = self._get_server_url()
                    response_message = f"🌐 Web File Manager:\n{server_url}"
                    self._send_message_to_chat(params.peer, response_message)
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                elif message.lower() == '.cc' or message.lower() == '. cc':
                    self._clear_html_cache()
                    response_message = "🧹 Кеш HTML очищен. Интерфейс будет обновлён при следующем запросе."
                    self._send_message_to_chat(params.peer, response_message)
                    return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            log(f"WebFileManager: Ошибка обработки команды: {e}")

        return HookResult()

    def _get_server_url(self) -> str:
        if self.current_port:
            return f"http://127.0.0.1:{self.current_port}"
        else:
            return "Сервер не запущен"

    def _setup_menu(self):
        try:
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    text="Открыть File Manager",
                    on_click=self._handle_file_manager_click,
                    icon="files_folder",
                    priority=100
                )
            )
        except Exception as e:
            log(f"WebFileManager: Ошибка настройки меню: {e}")

    def _handle_file_manager_click(self, context: Dict[str, Any]):
        try:
            server_url = self._get_server_url()
            if server_url != "Сервер не запущен":
                self._show_success(f"🌐 Web File Manager:\n{server_url}")
            else:
                self._show_error("Веб‑сервер не запущен")
        except Exception as e:
            self._show_error(f"Ошибка: {e}")

    def _send_message_to_chat(self, peer_id: int, message: str):
        try:
            message_params = {
                "peer": peer_id,
                "message": message
            }
            send_message(message_params)
        except Exception as e:
            log(f"WebFileManager: Ошибка отправки сообщения: {e}")

    def _show_success(self, message: str):
        try:
            fragment = get_last_fragment()
            if fragment:
                BulletinHelper.show_success(message, fragment)
        except Exception:
            pass

    def _show_error(self, message: str):
        try:
            fragment = get_last_fragment()
            if fragment:
                BulletinHelper.show_error(f"Ошибка: {message}", fragment)
        except Exception:
            pass

#Author: @SaturnFake #Channel: @Fantom_Plugins
