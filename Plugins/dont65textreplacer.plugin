# Плагин: AutoTextReplacer
# Автор: @dont65
# Версия 1.4.0
# Требует: Dont65 Library (dont65_lib)

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Input, Text
from android_utils import run_on_ui_thread
from client_utils import get_messages_controller, get_last_fragment
import traceback

# Пытаемся импортировать ArrayList (зависит от среды выполнения, обычно доступен в таких клиентах)
try:
    from java.util import ArrayList
except ImportError:
    ArrayList = list

__name__ = "AutoTextReplacer"
__description__ = "Заменяет до 100 команд на текст с поддержкой Markdown форматирования (требует Dont65 Library)"
__icon__ = "wtfffffff_2_Fix_x_Fox/3"
__version__ = "1.4.0"
__id__ = "dont65textreplacer"
__author__ = "@dont65"
__min_version__ = "11.12.0"

# Константы автообновления
AUTOUPDATE_CHANNEL_ID = 3624287619  # @dontplugin
AUTOUPDATE_MSG_ID = 13              # ID поста с этим плагином

class TextReplacerPlugin(BasePlugin):

    def __init__(self):
        super().__init__()
        self.lib_missing = False
        self.Dont65Utils = None
        self.logger = None
        self._check_library()

    def _check_library(self):
        """Проверяет наличие библиотеки"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            # Логгер создадим позже, когда библиотека будет точно доступна
        except ImportError:
            self.lib_missing = True
            from client_utils import log
            log(f"[{__id__}] Ошибка: Библиотека dont65_lib не найдена")

    def _show_library_check_dialog(self, context):
        """Показывает диалог проверки библиотеки"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            context.show_alert(
                "✅ Библиотека найдена",
                f"Dont65 Library v{self.Dont65Utils.__version__ if hasattr(self.Dont65Utils, '__version__') else '1.0.6'}\n\nВсе функции доступны."
            )
        except ImportError:
            self.lib_missing = True
            self.Dont65Utils = None
            context.show_alert(
                "❌ Библиотека не найдена",
                "Плагин dont65_lib не установлен!\n\nУстановите Dont65 Library для работы TextReplacer."
            )

    def create_settings(self):
        quality = 100
        settings = [
            Header("Настройки AutoTextReplacer"),
        ]

        # Кликабельная кнопка на автора (всегда отображается)
        settings.append(
            Text(
                text="Автор: @dont65",
                accent=False,
                on_click=lambda view: run_on_ui_thread(
                    lambda: get_messages_controller().openByUserName(
                        "dont65", get_last_fragment(), 1
                    )
                )
            )
        )
        settings.append(Divider())

        if self.lib_missing:
            settings.extend([
                Text("⚠️ Требуется Dont65 Library!"),
                Divider(text="Установите плагин dont65_lib для работы"),
                Divider(),
                Divider(text="После установки библиотеки\nперезагрузите клиент")
            ])
        else:
            settings.extend([
                Divider(text=f"Настройте до {quality} пар (команда и текст). Поддерживается Markdown (**жирный**, __курсив__)."),
            ])

        for i in range(1, quality + 1):
            settings.append(Header(text=f"Слот {i}"))
            settings.append(Input(
                key=f"command_{i}",
                text="Команда-триггер",
                subtext="Например, .hi",
                default=""
            ))
            settings.append(Input(
                key=f"text_{i}",
                text="Текст для замены",
                subtext="Поддерживает форматирование Markdown",
                default=""
            ))
            settings.append(Divider())

        return settings

    def on_plugin_load(self):
        # Если библиотека доступна – инициализируем логгер и автообновление
        if not self.lib_missing:
            try:
                # Создаём логгер для плагина через утилиту библиотеки
                self.logger = self.Dont65Utils.build_log(__id__)
                self.logger.info("Plugin loaded, library detected")

                # Регистрируем задачу автообновления
                self.Dont65Utils.add_autoupdater_task(
                    __id__,
                    AUTOUPDATE_CHANNEL_ID,
                    AUTOUPDATE_MSG_ID
                )
                self.logger.info("Auto-updater task registered (msg_id=13)")

                # Хук сообщений с приоритетом 200
                self.add_on_send_message_hook(priority=200)

            except Exception as e:
                from client_utils import log
                log(f"[{__id__}] Error during library init: {traceback.format_exc()}")
                self.lib_missing = True
        else:
            from client_utils import log
            log(f"[{__id__}] Библиотека не найдена, хук и автообновление не загружены")

    def on_send_message_hook(self, account, params):
        try:
            # Проверка наличия библиотеки
            if self.lib_missing:
                msg_text = params.message or params.caption or ""
                if msg_text.strip().startswith('.'):
                    params.message = "⚠️ *Ошибка:* Требуется Dont65 Library!\nУстановите плагин `dont65_lib` для работы TextReplacer."
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                return HookResult()

            if hasattr(params, 'message') and params.message:
                original_text = params.message.strip().lower()

                # Собираем карту активных команд
                command_map = {}
                for i in range(1, 101):  # 100 слотов
                    command = self.get_setting(f"command_{i}", "").strip().lower()
                    custom_text = self.get_setting(f"text_{i}", "")

                    if command:
                        if not custom_text.strip():
                            continue  # Пропускаем пустые замены

                        if command not in command_map:
                            command_map[command] = custom_text

                # Если введенный текст — это наша команда
                if original_text in command_map:
                    full_text = command_map[original_text]

                    try:
                        # Используем библиотеку для применения Markdown
                        new_params = self.Dont65Utils.apply_markdown(params, full_text)
                        if self.logger:
                            self.logger.debug(f"Replaced '{original_text}' with custom text")
                        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=new_params)
                    except Exception as e:
                        # Если Markdown сломался, отправляем как обычный текст
                        params.message = full_text
                        params.entities = ArrayList()
                        if self.logger:
                            self.logger.error(f"Markdown error: {self.Dont65Utils.format_exc_only(e)}")
                        else:
                            from client_utils import log
                            log(f"[{__id__}] Markdown error: {traceback.format_exc()}")
                        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

        except Exception as e:
            if self.logger:
                self.logger.error(f"General error in hook: {self.Dont65Utils.format_exc_only(e)}")
            else:
                from client_utils import log
                log(f"[{__id__}] General error in hook: {traceback.format_exc()}")

        return HookResult()

    def on_plugin_unload(self):
        # Удаляем задачу автообновления при выгрузке плагина
        if not self.lib_missing and self.Dont65Utils:
            try:
                self.Dont65Utils.remove_autoupdater_task(__id__)
                if self.logger:
                    self.logger.info("Auto-updater task removed")
            except Exception as e:
                if self.logger:
                    self.logger.error(f"Failed to remove autoupdater task: {e}")
        # Логгер уничтожится сам
        pass