# Плагин: AutoTextReplacer
# Автор: @dont65
# Версия 1.3.1
# Требует: Dont65 Library (dont65_lib)

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Header, Divider, Input  
import traceback

# Пытаемся импортировать ArrayList (зависит от среды выполнения, обычно доступен в таких клиентах)
try:
    from java.util import ArrayList
except ImportError:
    ArrayList = list

__name__ = "AutoTextReplacer"
__description__ = "Заменяет до 100 команд на текст с поддержкой Markdown форматирования (требует Dont65 Library)"
__icon__ = "wtfffffff_2_Fix_x_Fox/3" 
__version__ = "1.3.1" 
__id__ = "dont65textreplacer"
__author__ = "@dont65"  
__min_version__ = "11.12.0"

class TextReplacerPlugin(BasePlugin):
    
    def __init__(self):
        super().__init__()
        self.lib_missing = False
        self.Dont65Utils = None
        self._check_library()

    def _check_library(self):
        """Проверяет наличие библиотеки"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            from client_utils import log
            log(f"[{__id__}] Библиотека Dont65Lib загружена")
        except ImportError:
            self.lib_missing = True
            from client_utils import log
            log(f"[{__id__}] Ошибка: Библиотека dont65_lib не найдена")

    def _show_library_check_dialog(self, context):
        """Показывает диалог проверки библиотеки"""
        try:
            from dont65_lib import Dont65Utils as LibUtils
            self.Dont65Utils = LibUtils
            self.lib_missing = False
            context.show_alert(
                "✅ Библиотека найдена",
                f"Dont65 Library v{self.Dont65Utils.__version__ if hasattr(self.Dont65Utils, '__version__') else '1.0.6'}\n\nВсе функции доступны."
            )
        except ImportError:
            self.lib_missing = True
            self.Dont65Utils = None
            context.show_alert(
                "❌ Библиотека не найдена",
                "Плагин dont65_lib не установлен!\n\nУстановите Dont65 Library для работы TextReplacer."
            )

    def create_settings(self):
        quality = 100
        settings = [
            Header("Настройки AutoTextReplacer"),
        ]
        
        if self.lib_missing:
            settings.extend([
                Text("⚠️ Требуется Dont65 Library!"),
                Divider(text="Установите плагин dont65_lib для работы"),
                Divider(),
                Divider(text="После установки библиотеки\nперезагрузите клиент")
            ])
        else:
            settings.extend([
                Divider(text=f"Настройте до {quality} пар (команда и текст). Поддерживается Markdown (**жирный**, __курсив__)."),
            ])
     
        for i in range(1, quality + 1): 
            settings.append(Header(text=f"Слот {i}"))
            settings.append(Input(
                key=f"command_{i}",
                text="Команда-триггер", 
                subtext="Например, .hi",
                default="" 
            ))
            settings.append(Input(
                key=f"text_{i}",  
                text="Текст для замены", 
                subtext="Поддерживает форматирование Markdown", 
                default="" 
            ))
            settings.append(Divider())
            
        return settings
    
    def on_plugin_load(self):
        # Загружаем хук только если библиотека доступна
        if not self.lib_missing:
            # Приоритет 200, чтобы сработать раньше стандартных обработчиков
            self.add_on_send_message_hook(priority=200)
        else:
            from client_utils import log
            log(f"[{__id__}] Библиотека не найдена, хук не загружен")

    def on_send_message_hook(self, account, params):
        try:
            # Проверка наличия библиотеки
            if self.lib_missing:
                msg_text = params.message or params.caption or ""
                if msg_text.strip().startswith('.'):
                    params.message = "⚠️ *Ошибка:* Требуется Dont65 Library!\nУстановите плагин `dont65_lib` для работы TextReplacer."
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                return HookResult()

            if hasattr(params, 'message') and params.message:
                original_text = params.message.strip().lower()
                
                # Собираем карту активных команд
                command_map = {}
                for i in range(1, 101):  # 100 слотов
                    command = self.get_setting(f"command_{i}", "").strip().lower()
                    custom_text = self.get_setting(f"text_{i}", "")
                    
                    if command:
                        if not custom_text.strip():
                            continue  # Пропускаем пустые замены
                        
                        if command not in command_map:
                            command_map[command] = custom_text

                # Если введенный текст — это наша команда
                if original_text in command_map:
                    full_text = command_map[original_text]
                    
                    try:
                        # Используем библиотеку для применения Markdown
                        new_params = self.Dont65Utils.apply_markdown(params, full_text)
                        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=new_params)
                    except Exception:
                        # Если Markdown сломался, отправляем как обычный текст
                        params.message = full_text
                        params.entities = ArrayList()
                        from client_utils import log
                        log(f"[{__id__}] Markdown error: {traceback.format_exc()}")
                        return HookResult(strategy=HookStrategy.MODIFY_FINAL, params=params)

        except Exception:
            from client_utils import log
            log(f"[{__id__}] General error in hook: {traceback.format_exc()}")

        return HookResult()

    def on_plugin_unload(self):
        pass