# -*- coding: utf-8 -*-

__id__ = "MandreTqfy"
__name__ = "MandreTqfy 12.0"
__author__ = "–°–≤–∞–≥–∞–ù–µ–¢—É—Ç–∞ @swagnonher"
__version__ = "12.0"
__description__ = """
–§–∏–Ω–∞–ª—å–Ω–∞—è –∫–∞—Å—Ç–æ–º–∏–∑–∏—Ä—É–µ–º–∞—è –≤–µ—Ä—Å–∏—è –ø–ª–∞–≥–∏–Ω–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç—Ä–µ–∫–æ–≤.

–ù–æ–≤–æ–µ –≤ v12.0:
‚Ä¢ –í –∫–∞—Å–∫–∞–¥ –¥–æ–±–∞–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ –æ–±–ª–æ–∂–∫–∏ –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞.
‚Ä¢ –£–ª—É—á—à–µ–Ω–∞ –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç—å –ø–æ–∏—Å–∫–∞.

–ö–æ–º–∞–Ω–¥—ã:
‚Ä¢ .np - –ø–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É —Ç—Ä–µ–∫–∞
‚Ä¢ .nplist - –ø–æ–∫–∞–∑–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç
‚Ä¢ .netx - —Å–ª–µ–¥—É—é—â–∏–π —Ç—Ä–µ–∫
‚Ä¢ .batx - –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç—Ä–µ–∫
‚Ä¢ .pptx - –ø–∞—É–∑–∞/–ø–ª–µ–π
"""
__min_version__ = "11.12.0"
__icon__ = "sPluginIDE/27"

import requests
import traceback
import os
import uuid
import time
import threading
import random
from io import BytesIO

try:
    from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
except ImportError:
    raise ImportError("–ù–µ–æ–±—Ö–æ–¥–∏–º–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ Pillow. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –æ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –≤ –≤–∞—à–µ–º –æ–∫—Ä—É–∂–µ–Ω–∏–∏.")

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_last_fragment, get_send_messages_helper, run_on_queue, send_message
from android_utils import run_on_ui_thread, log
from ui.settings import Header, Input, Switch, Divider, Text, Selector
from ui.bulletin import BulletinHelper
from org.telegram.ui.ActionBar import AlertDialog
from org.telegram.messenger import (
    MediaController, ApplicationLoader, FileLoader, UserConfig, AndroidUtilities
)
from org.telegram.tgnet import TLRPC
from java.io import File
from android.widget import EditText, FrameLayout

# --- –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏ —Ö–µ–ª–ø–µ—Ä—ã ---

APPLE_FONTS = [
    {"name": "SF Pro Text Regular", "filename": "SFProText-Regular.ttf", "url": "https://github.com/sahibjotsaggu/San-Francisco-Pro-Fonts/raw/master/SF-Pro-Text-Regular.otf"},
    {"name": "SF Pro Text Medium", "filename": "SFProText-Medium.ttf", "url": "https://github.com/sahibjotsaggu/San-Francisco-Pro-Fonts/raw/master/SF-Pro-Text-Medium.otf"},
    {"name": "SF Pro Text Bold", "filename": "SFProText-Bold.ttf", "url": "https://github.com/sahibjotsaggu/San-Francisco-Pro-Fonts/raw/master/SF-Pro-Text-Bold.otf"}
]
TEMP_DIR_NAME = "now_playing_cards_enhanced_v12"
CUSTOM_FONT_FILENAME = "custom_font.ttf"

def format_time(seconds):
    if seconds is None: return "00:00"
    m, s = divmod(int(seconds), 60)
    return f"{m:02d}:{s:02d}"

class MandreTqfyPluginV12(BasePlugin):
    def __init__(self):
        super().__init__()
        self.progress_dialog = None
        self.temp_dir = None
        self._fonts_dir = None
        self._session = requests.Session()

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._get_temp_dir()
        base_dir = ApplicationLoader.getFilesDirFixed()
        self._fonts_dir = File(base_dir, "MandreTqfy_fonts")
        if not self._fonts_dir.exists(): self._fonts_dir.mkdirs()

    def _get_temp_dir(self):
        if self.temp_dir: return self.temp_dir
        base_dir = ApplicationLoader.getFilesDirFixed()
        if not base_dir: return None
        temp_dir_pb = File(base_dir, TEMP_DIR_NAME)
        if not temp_dir_pb.exists(): temp_dir_pb.mkdirs()
        self.temp_dir = temp_dir_pb.getAbsolutePath()
        return self.temp_dir
    
    def _get_custom_font_path(self):
        return os.path.join(self._fonts_dir.getAbsolutePath(), CUSTOM_FONT_FILENAME)

    def create_settings(self):
        card_styles = ["–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π (Mandre)", "–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π (Tgfy)", "–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π (–í–æ–ª–Ω–∞)"]
        resolutions = ["720x720", "1024x1024", "1280x1280", "2048x2048"]
        font_items = [f["name"] for f in APPLE_FONTS]
        if os.path.exists(self._get_custom_font_path()):
            font_items.append("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —à—Ä–∏—Ñ—Ç")

        return [
            Header(text="–û–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"),
            Input(key="custom_footer_text", text="–¢–µ–∫—Å—Ç –≤ –ø–æ–¥–ø–∏—Å–∏", icon="msg_photo_text2", default="üé∂"),
            
            Divider(text="–°—Ç–∏–ª—å –∫–∞—Ä—Ç–æ—á–∫–∏"),
            Selector(key="card_style", text="–°—Ç–∏–ª—å –∫–∞—Ä—Ç–æ—á–∫–∏", default=2, items=card_styles, icon="msg_image_view"),
            Selector(key="image_resolution", text="–†–∞–∑—Ä–µ—à–µ–Ω–∏–µ (–¥–ª—è –≤–µ—Ä—Ç. —Å—Ç–∏–ª—è)", default=0, items=resolutions, icon="msg_photo"),
            Input(key="horizontal_margin", text="–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–π –æ—Ç—Å—Ç—É–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (px)", default="20", icon="msg_select_between"),
            
            Divider(text="–≠—Ñ—Ñ–µ–∫—Ç—ã"),
            Switch(key="wet_glass_effect", text="–≠—Ñ—Ñ–µ–∫—Ç –º–æ–∫—Ä–æ–≥–æ —Å—Ç–µ–∫–ª–∞", default=True, icon="msg_water"),
            Input(key="blur_radius", text="–†–∞–¥–∏—É—Å —Ä–∞–∑–º—ã—Ç–∏—è (px)", default="30", icon="msg_photo_blur"),
            
            Divider(text="–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —à—Ä–∏—Ñ—Ç–æ–≤"),
            Selector(key="font_family", text="–°–µ–º–µ–π—Å—Ç–≤–æ —à—Ä–∏—Ñ—Ç–æ–≤", default=1, items=font_items, icon="msg_font_size"),
            Text(text="–ó–∞–≥—Ä—É–∑–∏—Ç—å —Å–≤–æ–π —à—Ä–∏—Ñ—Ç...", icon="msg_download", on_click=self._show_font_download_dialog),

            Divider(text="–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ API"),
            Input(key="yandex_token", text="–¢–æ–∫–µ–Ω –Ø–Ω–¥–µ–∫—Å.–ú—É–∑—ã–∫–∏", subtext="–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ. –ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ.", icon="msg_info")
        ]

    # --- –ó–∞–≥—Ä—É–∑–∫–∞ —à—Ä–∏—Ñ—Ç–∞ ---
    def _show_font_download_dialog(self):
        activity = get_last_fragment().getParentActivity()
        if not activity: return

        builder = AlertDialog.Builder(activity)
        builder.setTitle("–ó–∞–≥—Ä—É–∑–∏—Ç—å —à—Ä–∏—Ñ—Ç")
        container = FrameLayout(activity)
        editText = EditText(activity)
        editText.setHint("–ü—Ä—è–º–∞—è —Å—Å—ã–ª–∫–∞ –Ω–∞ .ttf –∏–ª–∏ .otf —Ñ–∞–π–ª...")
        container.addView(editText)
        padding = AndroidUtilities.dp(24)
        container.setPadding(padding, AndroidUtilities.dp(6), padding, AndroidUtilities.dp(6))
        builder.setView(container)

        builder.setPositiveButton("–ó–∞–≥—Ä—É–∑–∏—Ç—å", lambda dialog, which: self._download_custom_font(editText.getText().toString()))
        builder.setNegativeButton("–û—Ç–º–µ–Ω–∞", None)
        builder.show()

    def _download_custom_font(self, url):
        if not url or not (url.endswith(".ttf") or url.endswith(".otf")):
            BulletinHelper.show_error("–ù–µ–≤–µ—Ä–Ω–∞—è —Å—Å—ã–ª–∫–∞. –£–∫–∞–∂–∏—Ç–µ –ø—Ä—è–º—É—é —Å—Å—ã–ª–∫—É –Ω–∞ .ttf –∏–ª–∏ .otf —Ñ–∞–π–ª.")
            return
        
        BulletinHelper.show_info("–ù–∞—á–∏–Ω–∞—é –∑–∞–≥—Ä—É–∑–∫—É —à—Ä–∏—Ñ—Ç–∞...")
        run_on_queue(lambda: self._perform_font_download(url))
        
    def _perform_font_download(self, url):
        try:
            response = self._session.get(url, timeout=30, stream=True)
            response.raise_for_status()
            with open(self._get_custom_font_path(), 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192): f.write(chunk)
            run_on_ui_thread(lambda: BulletinHelper.show_success("–®—Ä–∏—Ñ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω! –ü–µ—Ä–µ–∑–∞–π–¥–∏—Ç–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, —á—Ç–æ–±—ã –µ–≥–æ –≤—ã–±—Ä–∞—Ç—å."))
        except Exception as e:
            log(f"[{self.id}] Font download error: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —à—Ä–∏—Ñ—Ç–∞."))

    # --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ ---
    def on_send_message_hook(self, account, params):
        if not isinstance(params.message, str): return HookResult()
        message = params.message.strip().lower()
        
        mc = MediaController.getInstance()
        if message == ".netx": mc.playNextMessage(); BulletinHelper.show_info("–°–ª–µ–¥—É—é—â–∏–π —Ç—Ä–µ–∫"); return HookResult(strategy=HookStrategy.CANCEL)
        if message == ".batx": mc.playPreviousMessage(); BulletinHelper.show_info("–ü—Ä–µ–¥—ã–¥—É—â–∏–π —Ç—Ä–µ–∫"); return HookResult(strategy=HookStrategy.CANCEL)
        if message == ".pptx":
            if mc.isMessagePaused(): mc.playMessage(mc.getPlayingMessageObject()); BulletinHelper.show_info("–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ")
            else: mc.pauseMessage(mc.getPlayingMessageObject()); BulletinHelper.show_info("–ü–∞—É–∑–∞")
            return HookResult(strategy=HookStrategy.CANCEL)
            
        if message not in [".np", ".nplist"]: return HookResult()
        
        playing_song = mc.getPlayingMessageObject()
        if not playing_song or not playing_song.isMusic():
            run_on_ui_thread(lambda: BulletinHelper.show_info("–í Telegram –Ω–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è –º—É–∑—ã–∫–∞."))
            return HookResult(strategy=HookStrategy.CANCEL)
            
        self._show_loading_dialog()
        if message == ".np": run_on_queue(lambda: self._generate_and_send_card(playing_song, params.peer))
        elif message == ".nplist": run_on_queue(lambda: self._generate_and_send_playlist(playing_song, params.peer))

        return HookResult(strategy=HookStrategy.CANCEL)

    def _generate_and_send_card(self, song_object, peer_id):
        try:
            title = song_object.getMusicTitle() or "Unknown Title"
            artist = song_object.getMusicAuthor() or "Unknown Artist"
            duration = song_object.getDuration()
            progress = MediaController.getInstance().getPlayingMessageObject().audioProgressSec
            
            album_art_image = self._fetch_album_art_cascade(artist, title, song_object)
            image_path = self._create_card_image(album_art_image, title, artist, progress, duration)
            
            if image_path: run_on_ui_thread(lambda: self._send_results(image_path, peer_id))
            else: run_on_ui_thread(lambda: BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É."))
        except Exception: log(f"[{self.id}] –û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ (–∫–∞—Ä—Ç–∞): {traceback.format_exc()}")
        finally: run_on_ui_thread(self._dismiss_loading_dialog)
            
    def _generate_and_send_playlist(self, playing_song, peer_id):
        try:
            image_path = self._create_playlist_image(playing_song)
            if image_path: run_on_ui_thread(lambda: self._send_results(image_path, peer_id))
            else: run_on_ui_thread(lambda: BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–ª–µ–π–ª–∏—Å—Ç."))
        except Exception: log(f"[{self.id}] –û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ (–ø–ª–µ–π–ª–∏—Å—Ç): {traceback.format_exc()}")
        finally: run_on_ui_thread(self._dismiss_loading_dialog)
    
    def _send_results(self, image_path, peer_id):
        if image_path:
            params = {"peer": peer_id, "photo": get_send_messages_helper().generatePhotoSizes(image_path, None), "path": image_path, "caption": self.get_setting("custom_footer_text", "üé∂")}
            send_message(params)
            threading.Timer(10, lambda: os.remove(image_path) if os.path.exists(image_path) else None).start()

    # --- –°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ---
    def _create_card_image(self, album_art, title, artist, progress, duration):
        card_style_index = self.get_setting("card_style", 0)
        if card_style_index == 0: return self._create_card_style_vertical_waveform(album_art, title, artist, progress, duration, legacy_mode=True)
        if card_style_index == 1: return self._create_card_style_horizontal(album_art, title, artist, progress, duration)
        if card_style_index == 2: return self._create_card_style_vertical_waveform(album_art, title, artist, progress, duration)
        return None

    def _create_playlist_image(self, playing_song):
        playlist = MediaController.getInstance().getPlaylist()
        playing_song_id = playing_song.getId()
        
        current_index = -1
        for i in range(playlist.size()):
            if playlist.get(i).getId() == playing_song_id: current_index = i; break
        
        if current_index == -1: log(f"[{self.id}] Playing song not found."); return None
            
        start = max(0, current_index - 5); end = min(playlist.size(), current_index + 6)
        
        item_height = 130; padding = 20; width = 1080; art_radius = 12
        num_items = end - start
        total_height = num_items * (item_height + padding) - padding if num_items > 0 else 0
        
        if total_height == 0: return None

        playlist_img = Image.new("RGBA", (width, total_height), (18, 22, 33, 255))
        font_paths = self._get_font_paths()

        current_y = 0
        for i in range(start, end):
            song_obj = playlist.get(i)
            is_current = (song_obj.getId() == playing_song_id)
            item_bg = Image.new("RGBA", (width, item_height), (30, 35, 50, 255) if is_current else (22, 26, 40, 255))
            
            title = song_obj.getMusicTitle() or "Unknown Title"
            artist = song_obj.getMusicAuthor() or "Unknown Artist"
            duration = song_obj.getDuration()
            progress = playing_song.audioProgressSec if is_current else 0
            
            art = self._fetch_album_art_cascade(artist, title, song_obj)
            art_size = item_height - 30
            art_img = art.resize((art_size, art_size), Image.Resampling.LANCZOS) if art else Image.new("RGBA", (art_size, art_size), "#505050")
            
            mask = Image.new('L', (art_size, art_size), 0)
            ImageDraw.Draw(mask).rounded_rectangle((0, 0, art_size, art_size), radius=art_radius, fill=255)
            item_bg.paste(art_img, (20, 15), mask)
            
            item_draw = ImageDraw.Draw(item_bg)
            text_x = art_size + 45
            max_text_width = width - text_x - 150
            
            title_font = self._get_adaptive_font(title, max_text_width, 34, font_paths["bold"])
            artist_font = self._get_adaptive_font(artist, max_text_width, 28, font_paths["main"])
            time_font = self._get_adaptive_font("00:00", 100, 28, font_paths["main"])

            item_draw.text((text_x, 25), title, font=title_font, fill=(255,255,255,255))
            item_draw.text((text_x, 65), artist, font=artist_font, fill=(200,200,200,255))
            duration_text = format_time(duration)
            time_len = time_font.getlength(duration_text)
            item_draw.text((width - time_len - 30, 30), duration_text, font=time_font, fill=(200,200,200,255))
            
            progress_ratio = progress / duration if duration > 0 else 0
            pb_y = item_height - 25
            self._draw_progress_dots(item_draw, (text_x, pb_y-10, width - 30, pb_y + 10), progress_ratio, self._get_dominant_color(art), (255,255,255,80))
            
            playlist_img.paste(item_bg, (0, current_y))
            current_y += item_height + padding

        return self._save_image(playlist_img)

    def _create_card_style_horizontal(self, album_art, title, artist, progress, duration):
        resolution_str = self.get_setting("image_resolution", "720x720")
        base_width, _ = map(int, resolution_str.split('x'))
        width, height = base_width, int(base_width / 3)
        try: blur_radius = int(self.get_setting("blur_radius", "30"))
        except ValueError: blur_radius = 30
        try: margin = int(self.get_setting("horizontal_margin", "20"))
        except ValueError: margin = 20

        if album_art: bg_image = album_art.resize((width, height), Image.Resampling.LANCZOS).convert("RGBA").filter(ImageFilter.GaussianBlur(radius=blur_radius))
        else: bg_image = Image.new("RGBA", (width, height), (24, 24, 24, 255))
        pi_card = bg_image.convert("RGBA")
        dominant_color = self._get_dominant_color(album_art)
        gradient = Image.new('L', (width, height)); draw_grad = ImageDraw.Draw(gradient)
        for x in range(width): draw_grad.line([(x, 0), (x, height)], fill=int(220 - (180 * (x / width) ** 0.5)))
        color_overlay = Image.new('RGBA', (width, height), dominant_color)
        pi_card.paste(color_overlay, (0,0), gradient)
        draw = ImageDraw.Draw(pi_card, "RGBA")
        art_size = height - 40; art_pos = (margin, 20)
        art_img = album_art.resize((art_size, art_size), Image.Resampling.LANCZOS) if album_art else Image.new("RGBA", (art_size, art_size), "#505050")
        shadow_img = Image.new('RGBA', pi_card.size, (0,0,0,0))
        ImageDraw.Draw(shadow_img).rounded_rectangle((art_pos[0] + 5, art_pos[1] + 5, art_pos[0] + art_size + 5, art_pos[1] + art_size + 5), radius=20, fill=(0,0,0,176))
        pi_card.paste(shadow_img.filter(ImageFilter.GaussianBlur(15)), (0, 0), shadow_img)
        mask = Image.new('L', (art_size, art_size), 0); ImageDraw.Draw(mask).rounded_rectangle((0, 0, art_size, art_size), radius=20, fill=255)
        pi_card.paste(art_img, art_pos, mask)
        
        font_paths = self._get_font_paths(); text_x = art_pos[0] + art_size + margin
        max_text_width = width - text_x - margin
        title_font = self._get_adaptive_font(title, max_text_width, int(height * 0.16), font_paths["bold"])
        artist_font = self._get_adaptive_font(artist, max_text_width, int(height * 0.12), font_paths["main"])
        
        current_y = 30
        draw.text((text_x, current_y), title, font=title_font, fill="white"); current_y += title_font.getbbox(title)[3] + 10
        draw.text((text_x, current_y), artist, font=artist_font, fill=(200, 200, 200, 255))
        
        progress_ratio = progress / duration if duration > 0 else 0
        pb_y = height - 40
        self._draw_progress_waveform(draw, (text_x, pb_y, width - margin, pb_y + 20), progress_ratio, self._get_dominant_color(album_art), (255,255,255,80))

        return self._save_image(pi_card)

    def _create_card_style_vertical_waveform(self, album_art, title, artist, progress, duration, legacy_mode=False):
        resolution_str = self.get_setting("image_resolution", "720x720")
        width, height = map(int, resolution_str.split('x'))
        
        img = album_art.resize((width, height), Image.Resampling.LANCZOS) if album_art else None
        
        if img: final_image = img.convert("RGB")
        else: final_image = Image.new("RGB", (width, height), (25, 30, 45))
            
        footer_height = int(height * 0.4); footer_y = height - footer_height; footer_radius = 45
        
        if img:
            footer_bg_crop = img.crop((0, footer_y, width, height))
            try: blur_radius = int(self.get_setting("blur_radius", "30"))
            except ValueError: blur_radius = 30
            if self.get_setting("wet_glass_effect", True): footer_bg = self._apply_wet_glass_effect(footer_bg_crop, blur_radius)
            else: footer_bg = footer_bg_crop.filter(ImageFilter.GaussianBlur(blur_radius))
        else: footer_bg = Image.new("RGBA", (width, footer_height), (18, 22, 33, 255))

        footer_mask = Image.new('L', (width, footer_height), 0)
        draw_mask = ImageDraw.Draw(footer_mask)
        if legacy_mode:
            draw_mask.rounded_rectangle((0, 0, width, footer_height), radius=30, fill=255)
            draw_mask.rectangle((0, 30, width, footer_height), fill=255)
        else:
            draw_mask.rounded_rectangle((0, 0, width, footer_height), radius=footer_radius, fill=255)
            draw_mask.rectangle((0, footer_radius, width, footer_height), fill=255)
        
        final_image.paste(footer_bg, (0, footer_y), footer_mask)
        draw = ImageDraw.Draw(final_image)
        
        font_paths = self._get_font_paths(); max_text_width = width - 60
        title_font = self._get_adaptive_font(title, max_text_width, int(height * 0.08), font_paths["bold"])
        artist_font = self._get_adaptive_font(artist, max_text_width, int(height * 0.05), font_paths["main"])
        
        current_y = footer_y + 40
        title_len = title_font.getlength(title)
        draw.text(((width - title_len) / 2, current_y), title, font=title_font, fill="white"); current_y += title_font.getbbox(title)[3] + 10
        artist_len = artist_font.getlength(artist)
        draw.text(((width - artist_len) / 2, current_y), artist, font=artist_font, fill=(200, 200, 200, 255))
        
        progress_ratio = progress / duration if duration > 0 else 0
        pb_y = height - 80
        self._draw_progress_waveform(draw, (30, pb_y, width - 30, pb_y + 40), progress_ratio, self._get_dominant_color(album_art), (255,255,255,80))

        return self._save_image(final_image)

    # --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
    def _draw_progress_waveform(self, draw, box, progress, color, bg_color):
        x0, y0, x1, y1 = box; bar_width = x1 - x0; bar_height = y1 - y0; num_bars = 40; single_bar_w = bar_width / (num_bars * 1.5)
        progress_bars_count = int(num_bars * progress)
        for i in range(num_bars):
            bar_h = random.uniform(0.1, 1.0) * bar_height
            bar_x = x0 + i * (bar_width / num_bars)
            current_color = color if i < progress_bars_count else bg_color
            draw.rounded_rectangle((bar_x, y0 + (bar_height - bar_h) / 2, bar_x + single_bar_w, y0 + (bar_height + bar_h) / 2), radius=single_bar_w/2, fill=current_color)
    
    def _draw_progress_dots(self, draw, box, progress, color, bg_color):
        x0, y0, x1, y1 = box; height = y1 - y0; width = x1 - x0; num_dots = 30; radius = height / 2.5
        progress_dots_count = int(num_dots * progress)
        for i in range(num_dots):
            dot_x = x0 + i * (width / (num_dots - 1))
            current_color = color if i < progress_dots_count else bg_color
            draw.ellipse((dot_x - radius, y0, dot_x + radius, y1), fill=current_color)

    def _fetch_album_art_cascade(self, artist, title, song_object=None):
        sources = [
            (self._fetch_from_itunes, (artist, title)),
            (self._fetch_from_deezer, (artist, title)),
            (self._fetch_from_yandex, (artist, title)),
            (self._fetch_from_audiodb, (artist, title)),
            (self._fetch_from_telegram_metadata, (song_object,))
        ]
        for source_func, args in sources:
            if not all(arg is not None for arg in args): continue
            try:
                art = source_func(*args)
                if art: return art
            except Exception as e: log(f"[{self.id}] Error in {source_func.__name__}: {e}")
        log(f"[{self.id}] Art not found anywhere for {artist} - {title}")
        return None

    def _fetch_from_itunes(self, artist, title):
        params = {"term": f"{artist} {title}", "entity": "song", "limit": 1}
        response = self._session.get("https://itunes.apple.com/search", params=params, timeout=5)
        response.raise_for_status(); data = response.json()
        if data.get('resultCount', 0) > 0:
            url = data['results'][0]['artworkUrl100'].replace('100x100', '1200x1200')
            art_response = self._session.get(url, timeout=10); art_response.raise_for_status()
            log(f"[{self.id}] Art found on iTunes"); return Image.open(BytesIO(art_response.content)).convert("RGBA")
        return None

    def _fetch_from_deezer(self, artist, title):
        query = f'artist:"{artist}" track:"{title}"'
        response = self._session.get(f"https://api.deezer.com/search?q={requests.utils.quote(query)}", timeout=5)
        response.raise_for_status(); data = response.json()
        if data.get('data') and len(data['data']) > 0 and data['data'][0].get('album'):
            url = data['data'][0]['album']['cover_xl']
            art_response = self._session.get(url, timeout=10); art_response.raise_for_status()
            log(f"[{self.id}] Art found on Deezer"); return Image.open(BytesIO(art_response.content)).convert("RGBA")
        return None

    def _fetch_from_yandex(self, artist, title):
        token = self.get_setting("yandex_token", "").strip()
        if not token: return None

        headers = {"Authorization": f"OAuth {token}"}
        params = {"text": f"{artist} - {title}", "type": "track"}
        response = self._session.get("https://api.music.yandex.net/search", params=params, headers=headers, timeout=5)
        response.raise_for_status(); data = response.json()
        if data.get('result') and data['result'].get('tracks') and data['result']['tracks'].get('results'):
            track = data['result']['tracks']['results'][0]
            if track.get('albums') and track['albums'][0].get('coverUri'):
                cover_uri = track['albums'][0]['coverUri']
                url = f"https://{cover_uri.replace('%%', '1000x1000')}"
                art_response = self._session.get(url, timeout=10); art_response.raise_for_status()
                log(f"[{self.id}] Art found on Yandex.Music"); return Image.open(BytesIO(art_response.content)).convert("RGBA")
        return None
        
    def _fetch_from_audiodb(self, artist, title):
        url = f"https://www.theaudiodb.com/api/v1/json/2/search.php?s={requests.utils.quote(artist)}&t={requests.utils.quote(title)}"
        response = self._session.get(url, timeout=5)
        response.raise_for_status(); data = response.json()
        if data and data.get('track') and data['track'][0].get('strTrackThumb'):
            art_url = data['track'][0]['strTrackThumb']
            art_response = self._session.get(art_url, timeout=10); art_response.raise_for_status()
            log(f"[{self.id}] Art found on TheAudioDB"); return Image.open(BytesIO(art_response.content)).convert("RGBA")
        return None

    def _fetch_from_telegram_metadata(self, song_object):
        doc = song_object.getDocument()
        if not doc or not hasattr(doc, 'thumbs') or not doc.thumbs: return None
        
        best_thumb = None
        for i in range(doc.thumbs.size()):
            thumb = doc.thumbs.get(i)
            if isinstance(thumb, TLRPC.TL_photoSize):
                if not best_thumb or thumb.w > best_thumb.w: best_thumb = thumb
        
        if best_thumb:
            path = FileLoader.getInstance(UserConfig.selectedAccount).getPathToAttach(best_thumb, True)
            if path and path.exists():
                log(f"[{self.id}] Art found in local Telegram metadata")
                return Image.open(path.getAbsolutePath()).convert("RGBA")
        return None

    def _get_dominant_color(self, image):
        if not image: return (128, 128, 128)
        try: return image.copy().resize((1, 1), Image.Resampling.LANCZOS).getpixel((0, 0))[:3]
        except Exception: return (128, 128, 128)

    def _apply_wet_glass_effect(self, image, blur_radius):
        blurred_bg = image.filter(ImageFilter.GaussianBlur(radius=blur_radius))
        width, height = image.size
        noise = Image.new("L", (width // 6, height // 6))
        noise_draw = ImageDraw.Draw(noise)
        for _ in range(int(noise.width * noise.height * 0.1)):
            noise_draw.point((random.randint(0, noise.width - 1), random.randint(0, noise.height - 1)), fill=random.randint(180, 255))
        raindrop_mask = noise.resize(image.size, Image.Resampling.LANCZOS).filter(ImageFilter.GaussianBlur(radius=30))
        sharp_fg = ImageEnhance.Brightness(image).enhance(1.1)
        return Image.composite(sharp_fg, blurred_bg, raindrop_mask)

    def _get_font_paths(self):
        try:
            font_items = [f["name"] for f in APPLE_FONTS]
            custom_font_exists = os.path.exists(self._get_custom_font_path())
            if custom_font_exists: font_items.append("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —à—Ä–∏—Ñ—Ç")
            
            selected_font_index = self.get_setting("font_family", 1)
            font_name_str = font_items[selected_font_index]
            
            bold_font_path = self._download_font(APPLE_FONTS[2])
            if font_name_str == "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π —à—Ä–∏—Ñ—Ç":
                main_font_path = self._get_custom_font_path()
            else:
                font_index = font_items.index(font_name_str)
                main_font_path = self._download_font(APPLE_FONTS[font_index])

            if not main_font_path or not bold_font_path: raise IOError("Font not found")
            return {"main": main_font_path, "bold": bold_font_path}
        except Exception: return {"main": "/system/fonts/Roboto-Regular.ttf", "bold": "/system/fonts/Roboto-Bold.ttf"}

    def _download_font(self, font_info):
        try:
            font_path = File(self._fonts_dir, font_info["filename"]).getAbsolutePath()
            if os.path.exists(font_path): return font_path
            response = self._session.get(font_info["url"], timeout=30, stream=True); response.raise_for_status()
            with open(font_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192): f.write(chunk)
            return font_path
        except Exception as e: log(f"[{self.id}] Error downloading font {font_info['name']}: {e}"); return None

    def _get_adaptive_font(self, text, max_width, initial_size, font_path):
        font_size = initial_size
        try:
            font = ImageFont.truetype(font_path, font_size)
            while font.getlength(text) > max_width and font_size > 10:
                font_size -= 1; font = ImageFont.truetype(font_path, font_size)
            return font
        except IOError: return ImageFont.load_default()

    def _save_image(self, image):
        final_image = image.convert("RGB")
        output_path = os.path.join(self._get_temp_dir(), f"np_{uuid.uuid4()}.png")
        final_image.save(output_path, "PNG", quality=95)
        return output_path

    def _show_loading_dialog(self):
        if self.progress_dialog and self.progress_dialog.isShowing(): return
        last_fragment = get_last_fragment()
        if last_fragment and last_fragment.getParentActivity():
            self.progress_dialog = AlertDialog(last_fragment.getParentActivity(), 3)
            self.progress_dialog.setCancelable(False); self.progress_dialog.show()

    def _dismiss_loading_dialog(self):
        if self.progress_dialog:
            try: self.progress_dialog.dismiss()
            except Exception: pass
            self.progress_dialog = None
