__id__ = "Unlimited_GIFs"
__name__ = "Unlimited GIFs"
__description__ = "Removes the limit on the number of Saved GIFs via Xposed hooks"
__version__ = "1.0.0"
__author__ = "@ArThirtyFour | @KangelPlugins"
__icon__ = "chaotianjiang/32"
__min_version__ = "11.12.0"

import os, sqlite3, pickle
from base_plugin import BasePlugin, MethodHook, MethodReplacement, HookResult, HookStrategy
from android_utils import log
from hook_utils import find_class, set_static_private_field
from java import jclass, jint

class UnlimitedGifsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.target_classes_names = ["org.telegram.messenger.MediaDataController", "org.telegram.messenger.query.StickersQuery", "org.telegram.messenger.query.EmojiSearch"]
        self.hooked_methods = []
        self.bumped_limits = 0
        self._db = None

    def on_plugin_load(self):
        try:
            self._raise_known_limits()
            self._hook_trimming_methods()
            self._setup_gif_local_store_hooks()
            self._suppress_ui_limit_warnings()
            self.add_hook("TL_messages_saveGif", match_substring=True)
            self.add_hook("TL_messages_getSavedGifs", match_substring=True)
            log(f"[{__id__}] ready: bumped_limits={self.bumped_limits}, hooked={len(self.hooked_methods)}")
        except Exception as e:
            log(f"[{__id__}] init error: {e}")

    def on_plugin_unload(self):
        pass

    def _raise_known_limits(self):
        for cls_name in self.target_classes_names:
            clazz = find_class(cls_name)
            if not clazz:
                continue
            try:
                for field in clazz.getClass().getDeclaredFields():
                    try:
                        lname = field.getName().lower()
                        if "gif" in lname and any(x in lname for x in ("max", "limit", "cap")):
                            if set_static_private_field(clazz, field.getName(), 100000):
                                self.bumped_limits += 1
                    except:
                        pass
            except:
                pass

    class _NoTrimReplacement(MethodReplacement):
        def replace_hooked_method(self, param):
            try:
                rtype = param.method.getReturnType()
                if rtype is None:
                    return None
                name = rtype.getName()
                if name in ("void", "boolean", "java.lang.Boolean"):
                    return False if "boolean" in name else None
                if any(x in name for x in ("int", "long", "short", "byte", "float", "double")):
                    return 0
            except:
                pass
            return None

    class _BeforeNoopTrim(MethodHook):
        def before_hooked_method(self, param):
            try:
                param.setResult(None)
            except:
                pass

    def _hook_trimming_methods(self):
        patterns = ("trim", "cleanup", "removeold", "cap", "limit")
        for cls_name in self.target_classes_names:
            clazz = find_class(cls_name)
            if not clazz:
                continue
            try:
                for m in clazz.getClass().getDeclaredMethods():
                    lname = m.getName().lower()
                    if any(p in lname for p in patterns) and "gif" in lname:
                        try:
                            m.setAccessible(True)
                            u = self.hook_method(m, self._NoTrimReplacement())
                            if u:
                                self.hooked_methods.append(u)
                        except:
                            pass
            except:
                pass

    class _J:
        def __getattr__(self, name):
            return jclass(f"java.lang.{name.title()}")

    def _context(self):
        return jclass("android.app.ActivityThread").currentApplication()

    @property
    def _gifdb(self):
        if self._db is None:
            app = self._context()
            base_dir = str(app.getFilesDir()) if app else "."
            self._db = self._GifDB(os.path.join(base_dir, "gifs.db"))
        return self._db

    class _GifDB:
        def __init__(self, path):
            self.path = path
            with sqlite3.connect(path) as c:
                c.execute("CREATE TABLE IF NOT EXISTS gifs(id INTEGER PRIMARY KEY, serialized_data BLOB)")
                c.commit()
        def all(self):
            try:
                with sqlite3.connect(self.path) as c:
                    return [pickle.loads(r[0]) for r in c.execute("SELECT serialized_data FROM gifs")]
            except:
                return []
        def add(self, doc_dict):
            try:
                with sqlite3.connect(self.path) as c:
                    c.execute("INSERT OR REPLACE INTO gifs VALUES(?, ?)", (int(doc_dict.get("id", 0)), pickle.dumps(doc_dict)))
                    c.commit()
            except:
                pass
        def remove(self, doc_dict):
            try:
                with sqlite3.connect(self.path) as c:
                    c.execute("DELETE FROM gifs WHERE id=?", (int(doc_dict.get("id", 0)),))
                    c.commit()
            except:
                pass

    def _doc_to_dict(self, sticker):
        try:
            if hasattr(sticker, "document") and sticker.document:
                sticker = sticker.document
            if not sticker:
                return None
            return {
                "id": int(sticker.id),
                "access_hash": int(getattr(sticker, "access_hash", 0)),
                "dc_id": int(getattr(sticker, "dc_id", 0)),
                "mime_type": str(getattr(sticker, "mime_type", "")),
                "size": int(getattr(sticker, "size", 0)),
                "file_reference": bytes(getattr(sticker, "file_reference", b"")),
                "version": int(getattr(sticker, "version", 0)),
            }
        except:
            return None

    def _dict_to_doc(self, data):
        try:
            doc = jclass("org.telegram.tgnet.TLRPC").TL_document()
            doc.id = int(data.get("id", 0))
            doc.access_hash = int(data.get("access_hash", 0))
            doc.dc_id = int(data.get("dc_id", 0))
            doc.mime_type = data.get("mime_type", "")
            doc.size = int(data.get("size", 0))
            try:
                pyref = data.get("file_reference", b"")
                ba = jclass("[B")(len(pyref))
                for i, b in enumerate(pyref):
                    ba[i] = b - 256 if b > 127 else b
                doc.file_reference = ba
            except:
                pass
            doc.attributes = jclass("java.util.ArrayList")()
            return doc
        except:
            return None

    class _AddGifHook(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin
        def before_hooked_method(self, param):
            try:
                doc = None
                bool_seen = False
                for a in param.args:
                    if a and a.getClass().getName().endswith("TLRPC$Document"):
                        doc = a
                        break
                for a in param.args:
                    if a and str(getattr(a.__class__, 'TYPE', a)).endswith('Boolean'):
                        bool_seen = bool(a)
                        break
                if not doc:
                    return
                mime = str(getattr(doc, 'mime_type', '')).lower()
                looks_gif = 'gif' in mime
                if not looks_gif:
                    atts = getattr(doc, 'attributes', None)
                    if atts:
                        for i in range(atts.size()):
                            if atts.get(i) and atts.get(i).getClass().getName().endswith('TL_documentAttributeAnimated'):
                                looks_gif = True
                                break
                if not looks_gif:
                    return
                d = self.plugin._doc_to_dict(doc)
                if d:
                    (self.plugin._gifdb.remove(d) if bool_seen else self.plugin._gifdb.add(d))
                param.setResult(None)
            except:
                pass

    class _GetGifsHook(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin
        def after_hooked_method(self, param):
            try:
                out = jclass("java.util.ArrayList")()
                for d in self.plugin._gifdb.all():
                    doc = self.plugin._dict_to_doc(d)
                    if doc:
                        out.add(doc)
                param.setResult(out)
            except:
                pass

    def _setup_gif_local_store_hooks(self):
        MDC = find_class("org.telegram.messenger.MediaDataController")
        if not MDC:
            return
        try:
            methods = MDC.getClass().getDeclaredMethods()
        except:
            return
        for m in methods:
            try:
                lname = m.getName().lower()
                if any(x in lname for x in ("ringtone", "sound", "reaction", "thumb", "sticker", "emoji", "wallpaper", "theme")):
                    continue
                m.setAccessible(True)
                if "gif" in lname and any(x in lname for x in ("add", "put", "save", "mark", "recent")):
                    u = self.hook_method(m, self._AddGifHook(self))
                    if u:
                        self.hooked_methods.append(u)
                elif "gif" in lname and any(x in lname for x in ("get", "saved", "load", "list")):
                    u = self.hook_method(m, self._GetGifsHook(self))
                    if u:
                        self.hooked_methods.append(u)
                else:
                    try:
                        params = list(m.getParameterTypes())
                        ret = m.getReturnType()
                        has_doc = any(p and p.getName().endswith('TLRPC$Document') for p in params)
                        if has_doc:
                            u = self.hook_method(m, self._AddGifHook(self))
                            if u:
                                self.hooked_methods.append(u)
                        elif ret and ret.getName() == 'java.util.ArrayList' and len(params) <= 1:
                            u = self.hook_method(m, self._GetGifsHook(self))
                            if u:
                                self.hooked_methods.append(u)
                    except:
                        pass
            except:
                pass

    class _ToastFilter(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin
        def before_hooked_method(self, param):
            try:
                if len(param.args) >= 2:
                    s = str(param.args[1]).lower() if param.args[1] else ""
                    if any(x in s for x in ("200", "400")):
                        param.args[1] = ""
            except:
                pass

    def _suppress_ui_limit_warnings(self):
        try:
            Toast = find_class("android.widget.Toast")
            Context = find_class("android.content.Context")
            CharSequence = find_class("java.lang.CharSequence")
            if Toast and Context and CharSequence:
                makeText = Toast.getClass().getDeclaredMethod("makeText", Context, CharSequence, jint)
                self.hook_method(makeText, self._ToastFilter(self))
        except:
            pass
        try:
            Snackbar = find_class("com.google.android.material.snackbar.Snackbar")
            View = find_class("android.view.View")
            CharSequence = find_class("java.lang.CharSequence")
            if Snackbar and View and CharSequence:
                make = Snackbar.getClass().getDeclaredMethod("make", View, CharSequence, jint)
                self.hook_method(make, self._ToastFilter(self))
        except:
            pass

    def pre_request_hook(self, request_name: str, account: int, request) -> HookResult:
        try:
            if "savegif" in request_name.lower():
                return HookResult(strategy=HookStrategy.CANCEL)
        except:
            pass
        return HookResult(strategy=HookStrategy.DEFAULT)

    def post_request_hook(self, request_name: str, account: int, response, error) -> HookResult:
        return HookResult(strategy=HookStrategy.DEFAULT)
