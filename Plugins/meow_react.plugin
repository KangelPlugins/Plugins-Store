__id__ = "meow_react"
__name__ = "MeowReact"
__version__ = "0.2"
__author__ = "@oodze"
__description__ = "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∞–∫—Ü–∏–∏. –ö–æ—Å–∏—Ç –ø–æ–¥ —é–∑–µ—Ä–±–æ—Ç–∞ –ø–æ—Ç–æ–º—É —á—Ç–æ —è —Ç–∞–∫ —Ö–æ—á—É. –ö—Ç–æ –ø–µ—Ä–µ–Ω—ë—Å–µ—Ç —Ç–æ—Ç –∫–∞–∫–∞—à–∫–∞."

import json
from base_plugin import BasePlugin, HookResult, HookStrategy
from hook_utils import find_class
from android_utils import run_on_ui_thread, log
from java import jclass, jlong, cast, dynamic_proxy

try:
    TLRPC = find_class("org.telegram.tgnet.TLRPC")
    MessagesController = find_class("org.telegram.messenger.MessagesController")
    ConnectionsManager = find_class("org.telegram.tgnet.ConnectionsManager")
    UserConfig = find_class("org.telegram.messenger.UserConfig")
    NotificationCenter = find_class("org.telegram.messenger.NotificationCenter")
    ArrayList = find_class("java.util.ArrayList")
    RequestDelegate = find_class("org.telegram.tgnet.RequestDelegate")
    TL_messageEntityCustomEmoji = find_class("org.telegram.tgnet.TLRPC$TL_messageEntityCustomEmoji")
    SendMessagesHelper = find_class("org.telegram.messenger.SendMessagesHelper")
    SendMessageParams = find_class("org.telegram.messenger.SendMessagesHelper$SendMessageParams")
    JavaString = find_class("java.lang.String")
except:
    pass

class ServerResponseHandler(dynamic_proxy(RequestDelegate)):
    def run(self, response, error):
        if error:
            log(f"[Meow] –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {getattr(error, 'text', 'Unknown')}")

class TelegramNotificationObserver:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance

    def before_hooked_method(self, parameter):
        try:
            notification_id = int(str(parameter.args[0]))
            
            if notification_id == self.plugin.id_new_msg:
                arguments = parameter.args[1]
                if arguments and len(arguments) >= 2:
                    raw_messages = arguments[1]
                    if raw_messages:
                        messages_list = cast(ArrayList, raw_messages)
                        for index in range(messages_list.size()):
                            message_item = messages_list.get(index)
                            self.plugin.analyze_message(message_item)

            elif notification_id == self.plugin.id_sent_msg:
                sync_args = parameter.args[1]
                if sync_args and len(sync_args) >= 2:
                    original_id = int(str(sync_args[0]))
                    confirmed_id = int(str(sync_args[1]))
                    self.plugin.process_pending_reaction(original_id, confirmed_id)
        except:
            pass

class MeowReact(BasePlugin):
    strings = {
        "enabled": "‚úÖ –†–µ–∞–∫—Ü–∏–∏ –≤–∫–ª—é—á–µ–Ω—ã –≤ —ç—Ç–æ–º —á–∞—Ç–µ",
        "disabled": "üö´ –†–µ–∞–∫—Ü–∏–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã –≤ —ç—Ç–æ–º —á–∞—Ç–µ",
        "already_enabled": "‚ö†Ô∏è –†–µ–∞–∫—Ü–∏–∏ —É–∂–µ –≤–∫–ª—é—á–µ–Ω—ã –∑–¥–µ—Å—å",
        "reaction_set": "‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ä–µ–∞–∫—Ü–∏—è –¥–ª—è —Ç—Ä–∏–≥–≥–µ—Ä–∞ \"{}\": {}",
        "premium_set_prefix": "‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ Premium —Ä–µ–∞–∫—Ü–∏—è –¥–ª—è —Ç—Ä–∏–≥–≥–µ—Ä–∞ \"{}\": ", 
        "trigger_list_header": "üìã –°–ø–∏—Å–æ–∫ —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤:\n\n",
        "trigger_removed": "üóë –¢—Ä–∏–≥–≥–µ—Ä \"{}\" —É–¥–∞–ª—ë–Ω",
        "all_cleared": "üóë –í—Å–µ —Ç—Ä–∏–≥–≥–µ—Ä—ã —É—Å–ø–µ—à–Ω–æ –æ—á–∏—â–µ–Ω—ã",
        "not_found": "‚ö†Ô∏è –¢—Ä–∏–≥–≥–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω",
        "no_args": "‚ö†Ô∏è –£–∫–∞–∂–∏—Ç–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã",
        "no_triggers": "‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤",
        "premium_needed": "‚ö†Ô∏è –ë–µ–∑ Premium –∫–∞—Å—Ç–æ–º–Ω—ã–µ —ç–º–æ–¥–∑–∏ –Ω–µ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å!",
        "settings": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ MeowReact\n\nüìä –ê–∫—Ç–∏–≤–Ω—ã—Ö —á–∞—Ç–æ–≤: {}\nü§ñ –ê–≤—Ç–æ-—Ä–µ–∞–∫—Ü–∏–π: {}\nüéØ –¢—Ä–∏–≥–≥–µ—Ä–æ–≤: {}\n\n–ö–æ–º–∞–Ω–¥—ã:\n.mr on/off\n.mr auto <—Å–º–∞–π–ª> / off\n.mr add <—Ñ—Ä–∞–∑–∞> <—Å–º–∞–π–ª>\n.mr del <—Ñ—Ä–∞–∑–∞>\n.mr clear - –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—ë\n.mr list",
        "auto_enabled": "ü§ñ –í–∫–ª—é—á–µ–Ω–∞ –∞–≤—Ç–æ-—Ä–µ–∞–∫—Ü–∏—è –≤ —ç—Ç–æ–º —á–∞—Ç–µ: {}",
        "auto_disabled": "ü§ñ –ê–≤—Ç–æ-—Ä–µ–∞–∫—Ü–∏—è –≤—ã–∫–ª—é—á–µ–Ω–∞",
    }

    def __init__(self):
        super().__init__()
        self.triggers = {}
        self.active_chats = []
        self.auto_react_chats = {}
        self.pending_reactions = {} 
        self.config_prefix = ".mr"
        self.id_new_msg = 1
        self.id_sent_msg = 3
        self.ignore_prefixes = ["‚úÖ", "üö´", "‚ö†Ô∏è", "üìã", "üóë", "‚öôÔ∏è", "ü§ñ"]

    def on_plugin_load(self):
        self.load_settings_from_storage()
        self.add_on_send_message_hook(priority=50)

        try:
            if hasattr(NotificationCenter, "didReceiveNewMessages"):
                self.id_new_msg = getattr(NotificationCenter, "didReceiveNewMessages")
            if hasattr(NotificationCenter, "messageReceivedByServer"):
                self.id_sent_msg = getattr(NotificationCenter, "messageReceivedByServer")
        except:
            pass

        try:
            target_method = None
            for method in NotificationCenter.getClass().getDeclaredMethods():
                if method.getName() == "postNotificationName":
                    if len(method.getParameterTypes()) == 2:
                        target_method = method
                        break
            if target_method:
                target_method.setAccessible(True)
                self.hook_method(target_method, TelegramNotificationObserver(self))
        except:
            pass

    def on_plugin_unload(self):
        pass

    def load_settings_from_storage(self):
        try:
            self.triggers = json.loads(self.get_setting("triggers", "{}"))
            self.active_chats = json.loads(self.get_setting("active_chats", "[]"))
            self.auto_react_chats = json.loads(self.get_setting("auto_react_chats", "{}"))
        except:
            self.triggers = {}
            self.active_chats = []
            self.auto_react_chats = {}

    def save_settings_to_storage(self):
        self.set_setting("triggers", json.dumps(self.triggers))
        self.set_setting("active_chats", json.dumps(self.active_chats))
        self.set_setting("auto_react_chats", json.dumps(self.auto_react_chats))

    def has_premium_status(self):
        try:
            current_account = UserConfig.selectedAccount
            return UserConfig.getInstance(current_account).isPremium()
        except:
            return False

    def on_send_message_hook(self, account_id, params):
        try:
            input_text = getattr(params, "message", "")
            if not isinstance(input_text, str) or not input_text.startswith(self.config_prefix):
                return HookResult()

            command_parts = input_text.split(None, 2)
            current_chat_id = params.peer if hasattr(params, "peer") else 0
            chat_id_string = str(current_chat_id)
            
            if len(command_parts) < 2:
                warning = "\n" + self.strings["premium_needed"] if not self.has_premium_status() else ""
                stats = self.strings["settings"].format(len(self.active_chats), len(self.auto_react_chats), len(self.triggers)) + warning
                self.send_reply_to_chat(current_chat_id, stats)
                return HookResult(strategy=HookStrategy.CANCEL)

            action = command_parts[1].lower()

            if action == "on":
                if current_chat_id not in self.active_chats:
                    self.active_chats.append(current_chat_id)
                    self.save_settings_to_storage()
                self.send_reply_to_chat(current_chat_id, self.strings["enabled"])

            elif action == "off":
                if current_chat_id in self.active_chats:
                    self.active_chats.remove(current_chat_id)
                    self.save_settings_to_storage()
                self.send_reply_to_chat(current_chat_id, self.strings["disabled"])

            elif action == "clear":
                self.triggers = {}
                self.save_settings_to_storage()
                self.send_reply_to_chat(current_chat_id, self.strings["all_cleared"])

            elif action == "auto":
                if len(command_parts) < 3:
                    self.send_reply_to_chat(current_chat_id, self.strings["no_args"])
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                parameter = command_parts[2].strip()
                if parameter.lower() == "off":
                    if chat_id_string in self.auto_react_chats:
                        del self.auto_react_chats[chat_id_string]
                        self.save_settings_to_storage()
                        self.send_reply_to_chat(current_chat_id, self.strings["auto_disabled"])
                else:
                    emoji_value = parameter
                    is_custom = False
                    entities = getattr(params, "entities", None)
                    if entities:
                        for i in range(entities.size()):
                            item = entities.get(i)
                            doc_id = getattr(item, "document_id", 0)
                            if doc_id != 0:
                                emoji_value = str(doc_id)
                                is_custom = True
                                break
                    if not is_custom and emoji_value.isdigit() and len(emoji_value) > 10:
                        is_custom = True

                    if is_custom and not self.has_premium_status():
                        self.send_reply_to_chat(current_chat_id, self.strings["premium_needed"])
                        return HookResult(strategy=HookStrategy.CANCEL)

                    self.auto_react_chats[chat_id_string] = {"r": emoji_value, "p": is_custom}
                    self.save_settings_to_storage()
                    
                    message_text = self.strings["auto_enabled"].format("")
                    visual_entities = None
                    if is_custom:
                        icon = "üíé"
                        offset = JavaString(message_text).length()
                        ent = TL_messageEntityCustomEmoji()
                        ent.offset, ent.length = offset, JavaString(icon).length()
                        ent.document_id = jlong(int(emoji_value))
                        visual_entities = ArrayList()
                        visual_entities.add(ent)
                        message_text += icon
                    else:
                        message_text += emoji_value
                    self.send_reply_to_chat(current_chat_id, message_text, visual_entities)

            elif action == "del" or action == "rem":
                if len(command_parts) < 3: return HookResult(strategy=HookStrategy.CANCEL)
                target_trigger = command_parts[2].lower().strip()
                if target_trigger in self.triggers:
                    del self.triggers[target_trigger]
                    self.save_settings_to_storage()
                    self.send_reply_to_chat(current_chat_id, self.strings["trigger_removed"].format(target_trigger))
                else:
                    self.send_reply_to_chat(current_chat_id, self.strings["not_found"])

            elif action == "add" or action == "set":
                if len(command_parts) < 3:
                    self.send_reply_to_chat(current_chat_id, self.strings["no_args"])
                    return HookResult(strategy=HookStrategy.CANCEL)
                
                content = command_parts[2]
                trigger_word, reaction_data, is_premium = "", "", False
                msg_entities = getattr(params, "entities", None)
                found_premium_entity = False
                
                if msg_entities:
                    for i in range(msg_entities.size() - 1, -1, -1):
                        entity = msg_entities.get(i)
                        doc_id = getattr(entity, "document_id", 0)
                        if doc_id != 0:
                            reaction_data, is_premium, found_premium_entity = str(doc_id), True, True
                            split_pos = content.rfind(" ")
                            trigger_word = content[:split_pos].strip().lower() if split_pos != -1 else "error"
                            break 
                
                if not found_premium_entity:
                    split_pos = content.rfind(" ")
                    if split_pos != -1:
                        trigger_word = content[:split_pos].strip().lower()
                        reaction_data = content[split_pos+1:].strip()
                        if reaction_data.isdigit() and len(reaction_data) > 10: is_premium = True
                    else:
                        self.send_reply_to_chat(current_chat_id, self.strings["no_args"])
                        return HookResult(strategy=HookStrategy.CANCEL)

                if is_premium and not self.has_premium_status():
                    self.send_reply_to_chat(current_chat_id, self.strings["premium_needed"])
                    return HookResult(strategy=HookStrategy.CANCEL)

                if trigger_word:
                    self.triggers[trigger_word] = {"r": reaction_data, "p": is_premium}
                    self.save_settings_to_storage()
                    if is_premium:
                        prefix = self.strings["premium_set_prefix"].format(trigger_word)
                        icon = "üíé"
                        custom_ent = TL_messageEntityCustomEmoji()
                        custom_ent.offset = JavaString(prefix).length()
                        custom_ent.length = JavaString(icon).length()
                        custom_ent.document_id = jlong(int(reaction_data))
                        list_entities = ArrayList()
                        list_entities.add(custom_ent)
                        self.send_reply_to_chat(current_chat_id, prefix + icon + f" (ID {reaction_data})", list_entities)
                    else:
                        self.send_reply_to_chat(current_chat_id, self.strings["reaction_set"].format(trigger_word, reaction_data))

            elif action == "list":
                if not self.triggers:
                    self.send_reply_to_chat(current_chat_id, self.strings["no_triggers"])
                else:
                    output_text = self.strings["trigger_list_header"]
                    entity_collection = ArrayList()
                    for word, data in self.triggers.items():
                        start_line = f"‚Ä¢ {word} -> "
                        if data['p']:
                            current_pos = JavaString(output_text).length() + JavaString(start_line).length()
                            placeholder = "üíé" 
                            visual_ent = TL_messageEntityCustomEmoji()
                            visual_ent.offset = current_pos
                            visual_ent.length = JavaString(placeholder).length()
                            visual_ent.document_id = jlong(int(data['r']))
                            entity_collection.add(visual_ent)
                            output_text += f"{start_line}{placeholder}\n"
                        else:
                            output_text += f"{start_line}{data['r']}\n"
                    self.send_reply_to_chat(current_chat_id, output_text, entity_collection)
            return HookResult(strategy=HookStrategy.CANCEL)
        except:
            return HookResult()

    def analyze_message(self, message_object):
        try:
            if not hasattr(message_object, "messageOwner"): return
            owner = message_object.messageOwner
            text = getattr(owner, "message", "")
            dialog_id = getattr(owner, "dialog_id", 0)
            message_id = getattr(owner, "id", 0)
            is_outgoing = getattr(owner, "out", False)
            
            if not text: return
            if is_outgoing and any(text.startswith(prefix) for prefix in self.ignore_prefixes):
                return

            chat_key = str(dialog_id)
            active_list = [str(chat) for chat in self.active_chats]
            is_chat_active = chat_key in active_list or (chat_key.startswith("-") and chat_key[1:] in active_list)
            
            auto_info = self.auto_react_chats.get(chat_key) or (self.auto_react_chats.get(chat_key[1:]) if chat_key.startswith("-") else None)
            
            if auto_info:
                batch = [auto_info]
                if message_id > 0: self.execute_reaction_delivery(dialog_id, message_id, batch)
                else: self.pending_reactions[message_id] = {"chat_id": dialog_id, "reactions": batch}
                return 

            if not is_chat_active: return

            text_lowercase = str(text).lower()
            matches_found = []
            for phrase, info in self.triggers.items():
                position = text_lowercase.find(phrase)
                if position != -1: matches_found.append((position, info))
            
            if not matches_found: return
            matches_found.sort(key=lambda x: x[0])

            is_premium = self.has_premium_status()
            final_stack, unique_check = [], set()
            
            for _, info in matches_found:
                if not is_premium:
                    if not info['p']:
                        final_stack = [info]
                        break
                    continue
                
                if len(final_stack) >= 3: break
                check_key = f"{info['r']}_{info['p']}"
                if check_key not in unique_check:
                    final_stack.append(info)
                    unique_check.add(check_key)

            if not final_stack: return
            if message_id > 0: self.execute_reaction_delivery(dialog_id, message_id, final_stack)
            else: self.pending_reactions[message_id] = {"chat_id": dialog_id, "reactions": final_stack}
        except:
            pass

    def process_pending_reaction(self, old_id, new_id):
        try:
            data = self.pending_reactions.pop(old_id, None)
            if data:
                self.execute_reaction_delivery(data["chat_id"], new_id, data["reactions"])
        except:
            pass

    def execute_reaction_delivery(self, chat_id, message_id, reactions_list):
        def background_task():
            try:
                selected_acc = UserConfig.selectedAccount
                controller = MessagesController.getInstance(selected_acc)
                request = TLRPC.TL_messages_sendReaction()
                request.msg_id = int(message_id)
                target_peer = controller.getInputPeer(jlong(int(chat_id)))
                if not target_peer: return
                request.peer = target_peer
                request.reaction = ArrayList()
                request.flags = 0
                for item in reactions_list:
                    if item['p']:
                        reaction_obj = TLRPC.TL_reactionCustomEmoji()
                        reaction_obj.document_id = jlong(int(item['r']))
                    else:
                        reaction_obj = TLRPC.TL_reactionEmoji()
                        reaction_obj.emoticon = item['r']
                    request.reaction.add(reaction_obj)
                    request.flags |= 1
                request.big = False
                request.add_to_recent = True
                ConnectionsManager.getInstance(selected_acc).sendRequest(request, ServerResponseHandler())
            except:
                pass
        run_on_ui_thread(background_task)

    def send_reply_to_chat(self, chat_id, text, entities=None):
        def ui_task():
            try:
                message_params = SendMessageParams()
                message_params.peer = chat_id
                message_params.message = text
                message_params.entities = entities
                SendMessagesHelper.getInstance(UserConfig.selectedAccount).sendMessage(message_params)
            except:
                pass
        run_on_ui_thread(ui_task)
