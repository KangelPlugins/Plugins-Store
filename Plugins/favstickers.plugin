import os
import pickle
import sqlite3

from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from java import jclass
from ui.bulletin import BulletinHelper

__id__ = "favstickers"
__name__ = "Unlim favorite stickers"
__description__ = "Remove limits on adding stickers to favorites"
__author__ = "@DaShMore"
__version__ = "1.0.0"
__icon__ = "plugins_covers/0"
__min_version__ = "11.12.0"


class Jclass:
    def __getattr__(self, name: str):
        return jclass(f"java.lang.{name.title()}")


J = Jclass()


def pybytes_to_jbytes(data: bytes):
    ByteArray = jclass("[B")
    arr = ByteArray(len(data))
    for i, b in enumerate(data):
        arr[i] = b - 256 if b > 127 else b
    return arr


def serialize_sticker(sticker) -> dict:
    try:
        # sometimes sticker wrapper holds .document
        if hasattr(sticker, "document") and sticker.document is not None:
            sticker = sticker.document

        if sticker is None:
            return None

        data = {
            "id": int(sticker.id),
            "access_hash": int(sticker.access_hash),
            "dc_id": int(sticker.dc_id),
            "mime_type": str(sticker.mime_type),
            "size": int(sticker.size),
            "file_reference": bytes(sticker.file_reference)
            if hasattr(sticker, "file_reference") and sticker.file_reference
            else b"",
            "version": int(sticker.version) if hasattr(sticker, "version") else 0,
            "attributes": [],
        }

        if hasattr(sticker, "attributes") and sticker.attributes is not None:
            attr_list = sticker.attributes
            count = attr_list.size()
            for i in range(count):
                att = attr_list.get(i)

                if hasattr(att, "alt") and hasattr(att, "stickerset"):
                    ss = att.stickerset
                    data["attributes"].append(
                        {
                            "alt": att.alt,
                            "sticker_set_id": getattr(ss, "id", 0),
                            "sticker_set_access_hash": getattr(ss, "access_hash", 0),
                        }
                    )

        return data

    except:
        return None


def deserialize_sticker(data: dict):
    try:
        TLRPC = jclass("org.telegram.tgnet.TLRPC")
        ArrayList = jclass("java.util.ArrayList")

        doc = TLRPC.TL_document()

        doc.id = data["id"]
        doc.access_hash = data["access_hash"]
        doc.dc_id = data["dc_id"]
        doc.mime_type = data["mime_type"]
        doc.size = data["size"]
        doc.version = data.get("version", 0)

        # ✅ file_reference
        doc.file_reference = pybytes_to_jbytes(data["file_reference"])

        # ✅ progress from older Telegram: might exist
        if "thumb" in data:
            doc.thumb = None  # or construct TL_photoSize if needed

        # ✅ attributes
        doc.attributes = ArrayList()

        for att in data["attributes"]:
            a = TLRPC.TL_documentAttributeSticker()
            a.alt = att["alt"]

            if att["sticker_set_id"] != 0:
                ss = TLRPC.TL_inputStickerSetID()
                ss.id = att["sticker_set_id"]
                ss.access_hash = att["sticker_set_access_hash"]
                a.stickerset = ss

            doc.attributes.add(a)

        return doc

    except:
        return None


class StickersDB:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.__create_db(db_path)
        self.stickers = self.__read_db()

    def __create_db(self, db_path: str):
        """Создание таблицы stickers в SQLite."""
        with sqlite3.connect(db_path) as conn:
            cursor = conn.cursor()
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS stickers (
                    id INTEGER PRIMARY KEY,
                    serialized_data BLOB
                )
            """)
            conn.commit()

    def __read_db(self):
        """Чтение всех стикеров из базы в self.stickers."""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT serialized_data FROM stickers
                """)
                rows = cursor.fetchall()
                stickers = [
                    pickle.loads(row[0]) for row in rows
                ]  # Десериализуем словари
                return stickers
        except Exception as e:
            return []

    def get_all_stickers(self):
        """Получение всех стикеров в виде объектов TLRPC$TL_document."""
        return list(map(deserialize_sticker, self.stickers))[::-1]

    def add_sticker(self, sticker):
        """Сериализация и добавление стикера в базу без дубликатов."""
        serialized_sticker = serialize_sticker(sticker)
        if serialized_sticker is None:
            return
        sticker_id = serialized_sticker["id"]
        pickled_data = pickle.dumps(serialized_sticker)
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                INSERT OR REPLACE INTO stickers (id, serialized_data)
                VALUES (?, ?)
            """,
                (sticker_id, pickled_data),
            )
            conn.commit()
            if self.is_sticker_in_db(sticker):
                return
            self.stickers.append(serialized_sticker)

    def remove_sticker(self, sticker):
        """Удаление стикера из базы и self.stickers."""
        serialized_sticker = serialize_sticker(sticker)
        if serialized_sticker is None:
            return
        sticker_id = serialized_sticker["id"]
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                """
                DELETE FROM stickers WHERE id = ?
            """,
                (sticker_id,),
            )
            conn.commit()
            if cursor.rowcount > 0:
                if serialized_sticker in self.stickers:
                    self.stickers.remove(serialized_sticker)

    def is_sticker_in_db(self, sticker):
        """Проверка, есть ли стикер в базе."""
        try:
            serialized_sticker = serialize_sticker(sticker)
            if serialized_sticker is None:
                return False
            return serialized_sticker["id"] in [i["id"] for i in self.stickers]
        except Exception as e:
            return False



class ChangeFavoriteStickerHook(MethodHook):
    def __init__(self, on_add_favorite, on_remove_favorite, on_update):
        self.on_add_favorite = on_add_favorite
        self.on_remove_favorite = on_remove_favorite
        self.on_update = on_update

    def before_hooked_method(self, param):
        sticker = param.args[2]
        # Проверяем, что выбран пукнкт добавления / удаления из избранное (TYPE_FAVE = 2)
        # И что стикер не находится в избранном (not inFavs)
        if param.args[0] == 2 and not param.args[4]:
            self.on_add_favorite(sticker)
            BulletinHelper.show_success("Sticker added to favorites")
        elif param.args[0] == 2:
            self.on_remove_favorite(sticker)
            BulletinHelper.show_error("Sticker removed from favorites")
        self.on_update()
        param.setResult(None)


class GetFavoriteStickersHook(MethodHook):
    def __init__(self, get_favorite_stickers):
        self.get_favorite_stickers = get_favorite_stickers

    def after_hooked_method(self, param):
        favorite_stickers = self.get_favorite_stickers()
        if not favorite_stickers:
            return
        new_list = jclass("java.util.ArrayList")()
        for sticker in favorite_stickers:
            new_list.add(sticker)
        param.setResult(new_list)


class IsStickerInFavoritesHook(MethodHook):
    def __init__(self, is_favorite_sticker):
        self.is_favorite_sticker = is_favorite_sticker

    def before_hooked_method(self, param):
        sticker = param.args[0]
        param.setResult(self.is_favorite_sticker(sticker))


class MyPlugin(BasePlugin):
    __DB = None

    def __get_context(self):
        """
        Возвращает контекст приложения
        """
        current_app = jclass("android.app.ActivityThread").currentApplication()
        if not current_app:
            RuntimeError("app not find")
        return current_app

    @property
    def db(self):
        if self.__DB is None:
            self.__DB = StickersDB(
                os.path.join(str(self.__get_context().getFilesDir()), "stickers.db")
            )
        return self.__DB

    def __get_current_account(self) -> int:
        UserConfig = find_class("org.telegram.messenger.UserConfig")
        selectedAccountField = UserConfig.getClass().getDeclaredField("selectedAccount")
        selectedAccountField.setAccessible(True)
        currentAccount = selectedAccountField.getInt(None)
        return currentAccount

    def on_plugin_load(self):
        MediaController = find_class("org.telegram.messenger.MediaDataController")
        TLRPCDocument = find_class("org.telegram.tgnet.TLRPC$Document")
        media_instance = MediaController.getInstance(self.__get_current_account())
        media_class = media_instance.getClass()
        # Перехват метода добавления стикера в избраные
        method = MediaController.getClass().getDeclaredMethod(
            "addRecentSticker",
            J.Integer.TYPE,
            J.Object,
            TLRPCDocument,
            J.Integer.TYPE,
            J.Boolean.TYPE,
        )
        method.setAccessible(True)
        self.hook_method(
            method,
            ChangeFavoriteStickerHook(
                on_add_favorite=self.db.add_sticker,
                on_remove_favorite=self.db.remove_sticker,
                on_update=media_instance.processLoadedRecentDocuments,
            ),
        )

        # Перехват метода получения списка избранных стикеров

        getRecentStickersMethod = media_class.getDeclaredMethod(
            "getRecentStickers",
            J.Integer.TYPE,
        )
        getRecentStickersMethod.setAccessible(True)
        self.unhook_obj = self.hook_method(
            getRecentStickersMethod,
            GetFavoriteStickersHook(self.db.get_all_stickers),
        )

        isStickerInFavoritesMethod = media_class.getDeclaredMethod(
            "isStickerInFavorites", jclass("org.telegram.tgnet.TLRPC$Document")
        )
        isStickerInFavoritesMethod.setAccessible(True)
        self.unhook_obj = self.hook_method(
            isStickerInFavoritesMethod,
            IsStickerInFavoritesHook(self.db.is_sticker_in_db),
        )
        self.__load_favorite_stickers(media_instance)

    def __load_favorite_stickers(self, mediaController):
        if not self.db.get_all_stickers():
            stickers = mediaController.getRecentStickers(2)
            for sticker in range(stickers.size() - 1, -1, -1):
                self.db.add_sticker(stickers.get(sticker))
