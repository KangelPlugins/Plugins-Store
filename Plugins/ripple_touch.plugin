__id__ = "ripple_touch"
__name__ = "Ripple Touch"
__description__ = "Triggers Ripple on each UI touch"
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "1.2.0"
__icon__ = "DateRegBot_by_MoiStikiBot/13"
__min_version__ = "11.12.1"

from typing import Any, Optional, List
from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from java.lang import Class as JClass, Float as JFloat
from ui.settings import Header, Selector, Input, Divider, Text, Switch
from client_utils import get_last_fragment, get_messages_controller

class _RippleTouchHook(MethodHook):
    def __init__(self, plugin: "RippleTouchPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if param.args and len(param.args) > 0 else None
            if motion_event is None:
                return
            self.plugin._handle_touch(param.thisObject, motion_event)
        except Exception as e:
            try:
                log(f"RippleTouch: hook error: {e}")
            except Exception:
                pass

    def after_hooked_method(self, param):
        return


class _RippleDialogHook(MethodHook):
    def __init__(self, plugin: "RippleTouchPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if param.args and len(param.args) > 0 else None
            if motion_event is None:
                return
            self.plugin._handle_touch(param.thisObject, motion_event)
        except Exception as e:
            try:
                log(f"RippleTouch: dialog hook error: {e}")
            except Exception:
                pass

    def after_hooked_method(self, param):
        return


class _RipplePopupHook(MethodHook):
    def __init__(self, plugin: "RippleTouchPlugin"):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if param.args and len(param.args) > 0 else None
            if motion_event is None:
                return
            self.plugin._handle_touch(param.thisObject, motion_event)
        except Exception as e:
            try:
                log(f"RippleTouch: popup hook error: {e}")
            except Exception:
                pass

    def after_hooked_method(self, param):
        return

class RippleTouchPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.launch_activity_class = None
        self.motion_event_class = None
        self.activity_class = None
        self.dialog_class = None
        self.popup_layout_class = None
        self.launch_activity_jclass = None
        self.motion_event_jclass = None
        self.activity_jclass = None
        self.dialog_jclass = None
        self.popup_layout_jclass = None
        self.make_ripple_method = None
        self.unhook_ref = None
        self.unhook_dialog_ref = None
        self.unhook_popup_ref = None
        self._extra_unhooks = []
        self._hook_extras_enabled = False
        self.launch_activity_clsobj = None
        self.motion_event_clsobj = None
        self.activity_clsobj = None
        self.dialog_clsobj = None
        self.popup_layout_clsobj = None
        self._cached_mode_fixed = False
        self._cached_fixed_intensity = 0.55
        self._cached_min_pressure = 0.2
        self._cached_max_pressure = 1.0
        self._cached_global_multiplier = 1.0
        self._cached_vibration_enabled = True
        self._cached_vibration_engine = 0
        self._cached_vibration_strength = 1
        self._cached_vibration_duration_ms = 20
        self._cached_release_effect = False
        self._cached_release_vibration = False
        self._last_press_intensity = None
        self._last_press_pressure = None
        self._last_down_token = None
        self._last_up_token = None

    def on_plugin_load(self):
        try:
            self._refresh_settings_cache()
            self.launch_activity_class = None
            self.motion_event_class = None
            self.activity_class = None
            self.dialog_class = None
            self.popup_layout_class = None

            try:
                self.launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
                self.motion_event_jclass = JClass.forName("android.view.MotionEvent")
                self.activity_jclass = JClass.forName("android.app.Activity")
                try:
                    self.dialog_jclass = JClass.forName("android.app.Dialog")
                except Exception:
                    self.dialog_jclass = None
                try:
                    self.popup_layout_jclass = JClass.forName("org.telegram.ui.ActionBar.ActionBarPopupWindow$ActionBarPopupWindowLayout")
                except Exception:
                    self.popup_layout_jclass = None
            except Exception as e:
                self.log(f"RippleTouch: Class.forName failed: {e}")
                return

            try:
                self._make_ripple_static = getattr(self.launch_activity_jclass, "makeRipple") if self.launch_activity_jclass else None
            except Exception:
                self._make_ripple_static = None

            try:
                self.launch_activity_clsobj = getattr(self.launch_activity_jclass, "class_", None)
                self.motion_event_clsobj = getattr(self.motion_event_jclass, "class_", None)
                self.activity_clsobj = getattr(self.activity_jclass, "class_", None)
                self.dialog_clsobj = getattr(self.dialog_jclass, "class_", None) if self.dialog_jclass else None
                self.popup_layout_clsobj = getattr(self.popup_layout_jclass, "class_", None) if self.popup_layout_jclass else None
            except Exception:
                self.launch_activity_clsobj = None
                self.motion_event_clsobj = None
                self.activity_clsobj = None
                self.dialog_clsobj = None
                self.popup_layout_clsobj = None

            dispatch_method = None
            try:
                target_class_for_methods = self.launch_activity_clsobj or self.launch_activity_jclass
                param_motion_event_class = self.motion_event_clsobj or self.motion_event_jclass
                dispatch_method = target_class_for_methods.getDeclaredMethod("dispatchTouchEvent", param_motion_event_class)
            except Exception:
                if self.activity_clsobj or self.activity_jclass:
                    try:
                        activity_owner = self.activity_clsobj or self.activity_jclass
                        param_motion_event_class = self.motion_event_clsobj or self.motion_event_jclass
                        dispatch_method = activity_owner.getDeclaredMethod("dispatchTouchEvent", param_motion_event_class)
                    except Exception:
                        dispatch_method = None

            if not dispatch_method:
                self.log("RippleTouch: Could not find dispatchTouchEvent to hook.")
                return

            try:
                dispatch_method.setAccessible(True)
            except Exception:
                pass

            self.unhook_ref = self.hook_method(dispatch_method, _RippleTouchHook(self), priority=5)
            if self.unhook_ref:
                self.log("RippleTouch: Hooked dispatchTouchEvent successfully.")
            else:
                self.log("RippleTouch: Failed to hook dispatchTouchEvent.")

            try:
                dialog_owner = self.dialog_clsobj or self.dialog_jclass
                param_motion_event_class = self.motion_event_clsobj or self.motion_event_jclass
                dialog_dispatch = None
                if dialog_owner and param_motion_event_class:
                    try:
                        dialog_dispatch = dialog_owner.getDeclaredMethod("dispatchTouchEvent", param_motion_event_class)
                    except Exception:
                        try:
                            dialog_dispatch = dialog_owner.getMethod("dispatchTouchEvent", param_motion_event_class)
                        except Exception:
                            dialog_dispatch = None
                if dialog_dispatch:
                    try:
                        dialog_dispatch.setAccessible(True)
                    except Exception:
                        pass
                    self.unhook_dialog_ref = self.hook_method(dialog_dispatch, _RippleDialogHook(self), priority=5)
                    if self.unhook_dialog_ref:
                        self.log("RippleTouch: Hooked Dialog.dispatchTouchEvent successfully.")
                    else:
                        self.log("RippleTouch: Failed to hook Dialog.dispatchTouchEvent.")
            except Exception as e:
                self.log(f"RippleTouch: Dialog hook error: {e}")

            try:
                popup_owner = self.popup_layout_clsobj or self.popup_layout_jclass
                param_motion_event_class = self.motion_event_clsobj or self.motion_event_jclass
                popup_dispatch = None
                if popup_owner and param_motion_event_class:
                    try:
                        popup_dispatch = popup_owner.getDeclaredMethod("dispatchTouchEvent", param_motion_event_class)
                    except Exception:
                        try:
                            popup_dispatch = popup_owner.getMethod("dispatchTouchEvent", param_motion_event_class)
                        except Exception:
                            popup_dispatch = None
                if popup_dispatch:
                    try:
                        popup_dispatch.setAccessible(True)
                    except Exception:
                        pass
                    self.unhook_popup_ref = self.hook_method(popup_dispatch, _RipplePopupHook(self), priority=5)
                    if self.unhook_popup_ref:
                        self.log("RippleTouch: Hooked ActionBarPopupWindowLayout.dispatchTouchEvent successfully.")
                    else:
                        self.log("RippleTouch: Failed to hook ActionBarPopupWindowLayout.dispatchTouchEvent.")
            except Exception as e:
                self.log(f"RippleTouch: Popup hook error: {e}")

            if self._hook_extras_enabled:
                for extra_class in (
                    "org.telegram.ui.ActionBar.DrawerLayoutContainer",
                    "org.telegram.ui.ActionBar.BottomSheet",
                    "org.telegram.ui.ActionBar.BottomSheetTabsOverlay",
                    "org.telegram.ui.Stories.PeerStoriesView",
                    "org.telegram.ui.Stars.StarReactionsOverlay",
                    "org.telegram.ui.Stars.StarsReactionsSheet",
                ):
                    try:
                        owner = None
                        try:
                            owner = JClass.forName(extra_class)
                        except Exception:
                            owner = None
                        if not owner:
                            continue
                        param_motion_event_class = self.motion_event_clsobj or self.motion_event_jclass
                        if not param_motion_event_class:
                            continue
                        method = None
                        try:
                            method = owner.getDeclaredMethod("dispatchTouchEvent", param_motion_event_class)
                        except Exception:
                            try:
                                method = owner.getMethod("dispatchTouchEvent", param_motion_event_class)
                            except Exception:
                                method = None
                        if not method:
                            continue
                        try:
                            method.setAccessible(True)
                        except Exception:
                            pass
                        unhook = self.hook_method(method, _RippleTouchHook(self), priority=5)
                        if unhook:
                            self._extra_unhooks.append(unhook)
                            self.log(f"RippleTouch: Hooked dispatchTouchEvent for {extra_class}.")
                    except Exception:
                        pass
        except Exception as e:
            self.log(f"RippleTouch: setup error: {e}")

    def on_plugin_unload(self):
        try:
            if self.unhook_ref:
                self.unhook_method(self.unhook_ref)
                self.unhook_ref = None
            if self.unhook_dialog_ref:
                try:
                    self.unhook_method(self.unhook_dialog_ref)
                except Exception:
                    pass
                self.unhook_dialog_ref = None
            if self.unhook_popup_ref:
                try:
                    self.unhook_method(self.unhook_popup_ref)
                except Exception:
                    pass
                self.unhook_popup_ref = None
            if self._extra_unhooks:
                for _h in self._extra_unhooks:
                    try:
                        self.unhook_method(_h)
                    except Exception:
                        pass
                self._extra_unhooks = []
        except Exception:
            pass

    def _handle_touch(self, owner: Any, motion_event: Any) -> None:
        try:
            action_masked = motion_event.getActionMasked()
            try:
                dt = float(motion_event.getDownTime())
            except Exception:
                try:
                    dt = float(motion_event.getEventTime())
                except Exception:
                    dt = 0.0
            token = (int(dt), int(action_masked))

            if action_masked == 0:
                if self._last_down_token is not None and self._last_down_token == token:
                    return
                try:
                    rx = float(motion_event.getRawX()); ry = float(motion_event.getRawY())
                except Exception:
                    rx = float(motion_event.getX()); ry = float(motion_event.getY())
                try:
                    pressure = float(motion_event.getPressure())
                except Exception:
                    pressure = 0.55
                intensity = self._compute_intensity(pressure)
                self._last_press_pressure = pressure
                self._last_press_intensity = intensity
                self._last_down_token = token
                self._invoke_ripple(rx, ry, intensity)
                try:
                    self._perform_vibration(owner, intensity)
                except Exception:
                    pass
                return

            if action_masked == 1:
                if not self._cached_release_effect and not self._cached_release_vibration:
                    return
                if self._last_up_token is not None and self._last_up_token == token:
                    return
                try:
                    rx = float(motion_event.getRawX()); ry = float(motion_event.getRawY())
                except Exception:
                    rx = float(motion_event.getX()); ry = float(motion_event.getY())
                try:
                    pressure = float(motion_event.getPressure())
                except Exception:
                    pressure = self._last_press_pressure if self._last_press_pressure is not None else 0.55
                intensity = self._compute_intensity(pressure)
                if self._last_press_intensity is not None and (pressure is None or pressure == 0.0):
                    intensity = self._last_press_intensity
                self._last_up_token = token
                if self._cached_release_effect:
                    self._invoke_ripple(rx, ry, intensity)
                if self._cached_release_vibration:
                    try:
                        self._perform_vibration(owner, intensity)
                    except Exception:
                        pass
        except Exception:
            pass
    def _open_channel_with_effects(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            activity = fragment.getParentActivity()
            if not activity:
                return
            try:
                view = None
                try:
                    window = activity.getWindow()
                    if window:
                        view = window.getDecorView()
                except Exception:
                    view = None
                if view:
                    try:
                        width = float(view.getWidth())
                        height = float(view.getHeight())
                    except Exception:
                        width = 540.0
                        height = 960.0
                    cx = width / 2.0
                    cy = height / 2.0
                    self._invoke_ripple(cx, cy, 3.0)
                    try:
                        self._perform_vibration(activity, 3.0)
                    except Exception:
                        pass
            except Exception:
                pass

            def _navigate():
                try:
                    username = str(self.get_setting("channel_username", "mishabotov"))
                    mc = get_messages_controller()
                    if mc and hasattr(mc, "openByUserName"):
                        mc.openByUserName(username, fragment, 0)
                except Exception:
                    pass

            run_on_ui_thread(_navigate)
        except Exception:
            pass

    def _invoke_ripple(self, x: float, y: float, intensity: float):
        try:
            try:
                if getattr(self, "_make_ripple_static", None):
                    self._make_ripple_static(float(x), float(y), float(intensity))
                    return
            except Exception:
                pass
            if not self.make_ripple_method:
                method = None
                try:
                    owner = self.launch_activity_clsobj or self.launch_activity_jclass
                    method = owner.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                except Exception:
                    try:
                        methods = (self.launch_activity_clsobj or self.launch_activity_jclass).getDeclaredMethods()
                        for m in methods:
                            try:
                                if m.getName() != "makeRipple":
                                    continue
                                if len(m.getParameterTypes()) == 3:
                                    method = m
                                    break
                            except Exception:
                                method = m
                                break
                    except Exception:
                        method = None
                if method:
                    try:
                        method.setAccessible(True)
                    except Exception:
                        pass
                    self.make_ripple_method = method
            if self.make_ripple_method:
                self.make_ripple_method.invoke(None, JFloat(x), JFloat(y), JFloat(intensity))
        except Exception as e:
            self.log(f"RippleTouch: makeRipple invoke error: {e}")

    def _refresh_settings_cache(self):
        try:
            mode_idx = int(self.get_setting("mode", 0))
            self._cached_mode_fixed = (mode_idx == 1)
        except Exception:
            self._cached_mode_fixed = False
        try:
            self._cached_fixed_intensity = self._as_float(self.get_setting("fixed_intensity", "0.55"), 0.55)
        except Exception:
            self._cached_fixed_intensity = 0.55
        try:
            self._cached_min_pressure = self._as_float(self.get_setting("min_pressure", "0.2"), 0.2)
        except Exception:
            self._cached_min_pressure = 0.2
        try:
            self._cached_max_pressure = self._as_float(self.get_setting("max_pressure", "1.0"), 1.0)
        except Exception:
            self._cached_max_pressure = 1.0
        try:
            self._cached_global_multiplier = self._as_float(self.get_setting("global_multiplier", "1.0"), 1.0)
        except Exception:
            self._cached_global_multiplier = 1.0
        try:
            vib_enabled_val = self.get_setting("vibration_enabled", True)
            if isinstance(vib_enabled_val, bool):
                self._cached_vibration_enabled = vib_enabled_val
            else:
                s = str(vib_enabled_val).strip().lower()
                self._cached_vibration_enabled = s in ("1", "true", "yes", "on")
        except Exception:
            self._cached_vibration_enabled = True
        try:
            self._cached_vibration_engine = int(self.get_setting("vibration_engine", 0))
        except Exception:
            self._cached_vibration_engine = 0
        try:
            self._cached_vibration_strength = int(self.get_setting("vibration_strength", 1))
        except Exception:
            self._cached_vibration_strength = 1
        try:
            self._cached_vibration_duration_ms = int(float(self.get_setting("vibration_duration_ms", "20")))
        except Exception:
            self._cached_vibration_duration_ms = 20
        try:
            self._cached_release_effect = bool(self.get_setting("release_effect", False))
        except Exception:
            self._cached_release_effect = False
        try:
            self._cached_release_vibration = bool(self.get_setting("release_vibration", False))
        except Exception:
            self._cached_release_vibration = False

    def _compute_intensity(self, pressure_value: float) -> float:
        if self._cached_mode_fixed:
            base = self._cached_fixed_intensity
        else:
            p = pressure_value
            try:
                if p < self._cached_min_pressure:
                    p = self._cached_min_pressure
                if p > self._cached_max_pressure:
                    p = self._cached_max_pressure
            except Exception:
                pass
            base = p
        intensity = base * (self._cached_global_multiplier or 1.0)
        return float(intensity)

    def _as_float(self, s: Any, default: float) -> float:
        try:
            return float(str(s).strip().replace(",", "."))
        except Exception:
            return default

    def _map_haptic_constant(self, strength_idx: int) -> int:
        try:
            HFC = JClass.forName("android.view.HapticFeedbackConstants")
            if strength_idx <= 0:
                return getattr(HFC, "KEYBOARD_TAP", getattr(HFC, "VIRTUAL_KEY", 1))
            if strength_idx == 1:
                return getattr(HFC, "VIRTUAL_KEY", getattr(HFC, "KEYBOARD_TAP", 1))
            return getattr(HFC, "LONG_PRESS", getattr(HFC, "VIRTUAL_KEY", 1))
        except Exception:
            return 1

    def _map_amplitude(self, strength_idx: int, intensity: float) -> int:
        try:
            mult = 0.4 if strength_idx <= 0 else (0.7 if strength_idx == 1 else 1.0)
            scaled = abs(float(intensity)) * mult
            amp = int(round(255 * scaled))
            if amp < 1:
                amp = 1
            if amp > 255:
                amp = 255
            return amp
        except Exception:
            return 120

    def _perform_vibration(self, activity: Any, intensity: float) -> None:
        if not self._cached_vibration_enabled:
            return
        try:
            if self._cached_vibration_engine == 0:
                try:
                    try:
                        if hasattr(activity, "performHapticFeedback"):
                            const_val = self._map_haptic_constant(self._cached_vibration_strength)
                            activity.performHapticFeedback(const_val)
                            return
                    except Exception:
                        pass

                    view = None
                    try:
                        window = activity.getWindow()
                        if window:
                            view = window.getDecorView()
                    except Exception:
                        view = None
                    if view:
                        const_val = self._map_haptic_constant(self._cached_vibration_strength)
                        view.performHapticFeedback(const_val)
                        return
                except Exception:
                    pass
            try:
                vibrator = activity.getSystemService("vibrator")
            except Exception:
                vibrator = None
            if vibrator is None:
                return
            duration = int(self._cached_vibration_duration_ms or 20)
            if duration < 1:
                duration = 10
            amp = self._map_amplitude(self._cached_vibration_strength, intensity)
            try:
                version = JClass.forName("android.os.Build$VERSION")
                sdk_int = int(getattr(version, "SDK_INT", 26))
            except Exception:
                sdk_int = 26
            if sdk_int >= 26:
                try:
                    VibrationEffect = JClass.forName("android.os.VibrationEffect")
                    DEFAULT_AMP = getattr(VibrationEffect, "DEFAULT_AMPLITUDE", -1)
                    effect = VibrationEffect.createOneShot(duration, amp if amp > 0 else DEFAULT_AMP)
                    vibrator.vibrate(effect)
                    return
                except Exception:
                    pass
            try:
                vibrator.vibrate(duration)
            except Exception:
                pass
        except Exception as e:
            try:
                self.log(f"RippleTouch: vibration error: {e}")
            except Exception:
                pass

    def create_settings(self) -> List[Any]:
        try:
            from org.telegram.messenger import LocaleController
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
        except Exception:
            lang = "en"

        strings = {
            "ru": {
                "title": "Ripple — настройки",
                "mode": "Режим",
                "mode_items": ["По давлению", "Фиксированный"],
                "fixed": "Фиксированная интенсивность",
                "minp": "Мин. давление",
                "maxp": "Макс. давление",
                "mult": "Глобальный множитель",
                "apply": "Применить изменения",
                "vib_header": "Вибрация",
                "vib_enable": "Включить вибрацию",
                "vib_engine": "Движок",
                "vib_engine_items": ["Системная тактильная", "Вибратор"],
                "vib_strength": "Сила вибрации",
                "vib_strength_items": ["Лёгкая", "Средняя", "Сильная"],
                "vib_duration": "Длительность",
                "vib_duration_subtext": "мс / для вибратора",
                "release_effect": "Эффект при отпускании",
                "release_vibration": "Вибрация при отпускании",
                "go_channel": "Перейти в канал"
            },
            "en": {
                "title": "Ripple — settings",
                "mode": "Mode",
                "mode_items": ["By pressure", "Fixed"],
                "fixed": "Fixed intensity (0.05..3.0)",
                "minp": "Min pressure (0.0..1.0)",
                "maxp": "Max pressure (0.0..1.0)",
                "mult": "Global multiplier (0.1..3.0)",
                "apply": "Apply changes",
                "vib_header": "Vibration",
                "vib_enable": "Enable vibration",
                "vib_engine": "Engine",
                "vib_engine_items": ["System haptics", "Vibrator"],
                "vib_strength": "Vibration strength",
                "vib_strength_items": ["Light", "Medium", "Heavy"],
                "vib_duration": "Duration",
                "vib_duration_subtext": "ms / for vibrator",
                "release_effect": "Effect on release",
                "release_vibration": "Vibration on release",
                "go_channel": "Open channel"
            }
        }
        s = strings["ru" if str(lang).startswith("ru") else "en"]

        mode_default = int(self.get_setting("mode", 0))
        fixed_default = str(self.get_setting("fixed_intensity", "0.55"))
        minp_default = str(self.get_setting("min_pressure", "0.2"))
        maxp_default = str(self.get_setting("max_pressure", "1.0"))
        mult_default = str(self.get_setting("global_multiplier", "1.0"))
        vib_enabled_default_val = self.get_setting("vibration_enabled", True)
        vib_enabled_default = vib_enabled_default_val if isinstance(vib_enabled_default_val, bool) else str(vib_enabled_default_val).strip().lower() in ("1", "true", "yes", "on")
        vib_engine_default = int(self.get_setting("vibration_engine", 0))
        vib_strength_default = int(self.get_setting("vibration_strength", 1))
        vib_duration_default = str(self.get_setting("vibration_duration_ms", "20"))

        def _on_any_change(_):
            try:
                self._refresh_settings_cache()
            except Exception:
                pass

        return [
            Header(text=s["title"]),
            Selector(key="mode", text=s["mode"], default=mode_default, items=s["mode_items"], icon="msg_speed", on_change=lambda v: _on_any_change(v)),
            Input(key="fixed_intensity", text=s["fixed"], default=fixed_default, icon="msg_brightness_high"),
            Divider(),
            Input(key="min_pressure", text=s["minp"], default=minp_default, icon="fingerprint"),
            Input(key="max_pressure", text=s["maxp"], default=maxp_default, icon="fingerprint"),
            Input(key="global_multiplier", text=s["mult"], default=mult_default, icon="menu_sort_number"),
            Header(text=s["vib_header"]),
            Switch(key="vibration_enabled", text=s["vib_enable"], default=vib_enabled_default, icon="media_like_active_solar", on_change=lambda v: _on_any_change(v)),
            Selector(key="vibration_engine", text=s["vib_engine"], default=vib_engine_default, items=s["vib_engine_items"], icon="msg_settings", on_change=lambda v: _on_any_change(v)),
            Selector(key="vibration_strength", text=s["vib_strength"], default=vib_strength_default, items=s["vib_strength_items"], icon="msg_brightness_high", on_change=lambda v: _on_any_change(v)),
            Switch(key="release_effect", text=s["release_effect"], default=bool(self.get_setting("release_effect", False)), icon="", on_change=lambda v: _on_any_change(v)),
            Switch(key="release_vibration", text=s["release_vibration"], default=bool(self.get_setting("release_vibration", False)), icon="", on_change=lambda v: _on_any_change(v)),
        ] \
        + ([Input(key="vibration_duration_ms", text=s["vib_duration"], subtext=s.get("vib_duration_subtext"), default=vib_duration_default, icon="msg_calendar2")] if vib_engine_default != 0 else []) \
        + [
            Text(text=s["apply"], accent=True, icon="ic_ab_done", on_click=lambda _v=None: self._refresh_settings_cache()),
            Divider(),
            Text(text=s["go_channel"], icon="menu_instant_view_solar", accent=True, on_click=lambda _v=None: self._open_channel_with_effects()),
        ]