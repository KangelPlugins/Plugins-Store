__id__ = "font_magic_selector"
__name__ = "Font Magic"
__description__ = "ÐœÐµÐ½ÑÐ¹Ñ‚Ðµ ÑˆÑ€Ð¸Ñ„Ñ‚ Ñ‚ÐµÐºÑÑ‚Ð° Ð¿Ñ€ÑÐ¼Ð¾ Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¾Ð¹!\n\n1. ÐÐ°Ð¿Ð¸ÑˆÐ¸Ñ‚Ðµ Ñ‚ÐµÐºÑÑ‚.\n2. Ð—Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸.\n3. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ 'ð”‰ Ð¨Ñ€Ð¸Ñ„Ñ‚'.\n4. Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÑ‚Ð¸Ð»ÑŒ!"
__author__ = "@pl_meow"
__version__ = "1.0.0"
__icon__ = "exteraPlugins/5"
__min_version__ = "11.12.1"

import traceback
from typing import Any, Dict, List

# Base Imports
from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook
from android_utils import log, run_on_ui_thread
from client_utils import get_last_fragment
from ui.bulletin import BulletinHelper
from ui.settings import Header, Text

# Reflection & Java Imports
from hook_utils import find_class, get_private_field
from java import dynamic_proxy, jclass
from java.lang import Integer, Runnable, CharSequence, String as JString, Class as JClass
from java.util import ArrayList

# Telegram Classes
from org.telegram.messenger import R, AndroidUtilities, LocaleController
from org.telegram.ui import ChatActivity, MessageSendPreview
from org.telegram.ui.Components import ItemOptions
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import BottomSheet, Theme
from android.view import View, Gravity, ViewGroup

from android.widget import FrameLayout, LinearLayout, TextView, ScrollView
from android.widget import EditText
from android.graphics import Color, Typeface
from android.graphics.drawable import GradientDrawable

# --- Constants ---
MENU_ITEM_ID = 18492

# --- Fonts Data ---
# Mapping standard characters to styled unicode characters
LOWER_ALPHA = "abcdefghijklmnopqrstuvwxyz"
UPPER_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
DIGITS = "0123456789"

FONTS_DATA = [
    ("Normal", None, None), # 0
    ("Alien", "É‘á‘²cá‘¯eáºœgá¨ˆiÇ°Æ™lmâ´ºoâ´ê—rêž…êž‡u×˜É¯xÑ‡z", "Aá‘²CDEáº”GHIJÆ˜LMNOPQÐ¯STUVWXYZ"), # 1
    ("Gothic", "ðŒ°ðŒ±ðŒ²ðŒ³ðŒ´ð†ðŒµðŒ·ðŒ¹ðŒ¾ðŒºðŒ»ðŒ¼ðŒ½ðŒ¾ð€ðŒµð‚ðƒð„ðŒ¿ð…ð…ð‡ðˆðŒ¶", "ðŒ°ðŒ±ðŒ²ðŒ³ðŒ´ð†ðŒµðŒ·ðŒ¹ðŒ¾ðŒºðŒ»ðŒ¼ðŒ½ðŒ¾ð€ðŒµð‚ðƒð„ðŒ¿ð…ð…ð‡ðˆðŒ¶"), # 2 (Approx)
    ("Fancy", "É‘bcdê¤•fghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 3
    ("Bubbles White", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“žâ“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©", "â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“Žâ“"), # 4
    ("Small Caps", "á´€Ê™á´„á´…á´‡Ò“É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€sá´›á´œá´ á´¡xÊá´¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 5
    ("Italic Sans", "ð˜¢ð˜£ð˜¤ð˜¥ð˜¦ð˜§ð˜¨ð˜©ð˜ªð˜«ð˜¬ð˜­ð˜®ð˜¯ð˜°ð˜±ð˜²ð˜³ð˜´ð˜µð˜¶ð˜·ð˜¸ð˜¹ð˜ºð˜»", "ð˜ˆð˜‰ð˜Šð˜‹ð˜Œð˜ð˜Žð˜ð˜ð˜‘ð˜’ð˜“ð˜”ð˜•ð˜–ð˜—ð˜˜ð˜™ð˜šð˜›ð˜œð˜ð˜žð˜Ÿð˜ ð˜¡"), # 6
    ("Bold Script", "ð“ªð“«ð“¬ð“­ð“®ð“¯ð“°ð“±ð“²ð“³ð“´ð“µð“¶ð“·ð“¸ð“¹ð“ºð“»ð“¼ð“½ð“¾ð“¿ð”€ð”ð”‚ð”ƒ", "ð“ð“‘ð“’ð““ð“”ð“•ð“–ð“—ð“˜ð“™ð“šð“›ð“œð“ð“žð“Ÿð“ ð“¡ð“¢ð“£ð“¤ð“¥ð“¦ð“§ð“¨ð“©"), # 7
    ("Sans", "ð–ºð–»ð–¼ð–½ð–¾ð–¿ð—€ð—ð—‚ð—ƒð—„ð—…ð—†ð—‡ð—ˆð—‰ð—Šð—‹ð—Œð—ð—Žð—ð—ð—‘ð—’ð—“", "ð– ð–¡ð–¢ð–£ð–¤ð–¥ð–¦ð–§ð–¨ð–©ð–ªð–«ð–¬ð–­ð–®ð–¯ð–°ð–±ð–²ð–³ð–´ð–µð–¶ð–·ð–¸ð–¹"), # 8
    ("Italic", "ð‘Žð‘ð‘ð‘‘ð‘’ð‘“ð‘”â„Žð‘–ð‘—ð‘˜ð‘™ð‘šð‘›ð‘œð‘ð‘žð‘Ÿð‘ ð‘¡ð‘¢ð‘£ð‘¤ð‘¥ð‘¦ð‘§", "ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ð‘€ð‘ð‘‚ð‘ƒð‘„ð‘…ð‘†ð‘‡ð‘ˆð‘‰ð‘Šð‘‹ð‘Œð‘"), # 9
    ("Double Struck", "ð•’ð•“ð•”ð••ð•–ð•—ð•˜ð•™ð•šð•›ð•œð•ð•žð•Ÿð• ð•¡ð•¢ð•£ð•¤ð•¥ð•¦ð•§ð•¨ð•©ð•ªð•«", "ð”¸ð”¹â„‚ð”»ð”¼ð”½ð”¾â„ð•€ð•ð•‚ð•ƒð•„â„•ð•†â„™â„šâ„ð•Šð•‹ð•Œð•ð•Žð•ð•â„¤"), # 10
    ("Monospace", "ðšŠðš‹ðšŒðšðšŽðšðšðš‘ðš’ðš“ðš”ðš•ðš–ðš—ðš˜ðš™ðššðš›ðšœðšðšžðšŸðš ðš¡ðš¢ðš£", "ð™°ð™±ð™²ð™³ð™´ð™µð™¶ð™·ð™¸ð™¹ð™ºð™»ð™¼ð™½ð™¾ð™¿ðš€ðšðš‚ðšƒðš„ðš…ðš†ðš‡ðšˆðš‰"), # 11
    ("Bubbles Black", "ðŸ…ðŸ…‘ðŸ…’ðŸ…“ðŸ…”ðŸ…•ðŸ…–ðŸ…—ðŸ…˜ðŸ…™ðŸ…šðŸ…›ðŸ…œðŸ…ðŸ…žðŸ…ŸðŸ… ðŸ…¡ðŸ…¢ðŸ…£ðŸ…¤ðŸ…¥ðŸ…¦ðŸ…§ðŸ…¨ðŸ…©", "ðŸ…ðŸ…‘ðŸ…’ðŸ…“ðŸ…”ðŸ…•ðŸ…–ðŸ…—ðŸ…˜ðŸ…™ðŸ…šðŸ…›ðŸ…œðŸ…ðŸ…žðŸ…ŸðŸ… ðŸ…¡ðŸ…¢ðŸ…£ðŸ…¤ðŸ…¥ðŸ…¦ðŸ…§ðŸ…¨ðŸ…©"), # 12
    ("Superscript", "áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°á¶¦Ê²áµË¡áµâ¿áµ’áµ–á‘«Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»", "á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾Qá´¿Ë¢áµ€áµâ±½áµ‚Ë£Ê¸á¶»"), # 13
    ("Greek Mix", "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜QÊ€êœ±á´›á´œá´ á´¡xÊá´¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 14 (Approximation)
    ("Coptic", "â²â²ƒcdâ²‰fâ„Šhiâ“™kâ„“mâ²›oâ²£qÊ€sâ²§uâ²©â²±xâ²©z", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 15
    ("Phonetic", "É‘bÉ”dÉ›fÉ¡hijklmnÉ”pqrstuvwxjz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 16
    ("Cherokee", "áŽ¯á‘²á£áŽ eáŽ¸á©á‚iá klmnoáŽµqáŽ¡sá›uá‰á‡xáŽ½z", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"), # 17
    ("Squares", "ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰", "ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰"), # 18
    ("Script", "ð’¶ð’·ð’¸ð’¹â„¯ð’»â„Šð’½ð’¾ð’¿ð“€ð“ð“‚ð“ƒâ„´ð“…ð“†ð“‡ð“ˆð“‰ð“Šð“‹ð“Œð“ð“Žð“", "ð’œâ„¬ð’žð’Ÿâ„°â„±ð’¢â„‹â„ð’¥ð’¦â„’â„³ð’©ð’ªð’«ð’¬â„›ð’®ð’¯ð’°ð’±ð’²ð’³ð’´ð’µ"), # 19
    ("Bold Italic", "ð™–ð™—ð™˜ð™™ð™šð™›ð™œð™ð™žð™Ÿð™ ð™¡ð™¢ð™£ð™¤ð™¥ð™¦ð™§ð™¨ð™©ð™ªð™«ð™¬ð™­ð™®ð™¯", "ð˜¼ð˜½ð˜¾ð˜¿ð™€ð™ð™‚ð™ƒð™„ð™…ð™†ð™‡ð™ˆð™‰ð™Šð™‹ð™Œð™ð™Žð™ð™ð™‘ð™’ð™“ð™”ð™•"), # 20
    ("Fraktur", "ð”žð”Ÿð” ð”¡ð”¢ð”£ð”¤ð”¥ð”¦ð”§ð”¨ð”©ð”ªð”«ð”¬ð”­ð”®ð”¯ð”°ð”±ð”²ð”³ð”´ð”µð”¶ð”·", "ð”„ð”…â„­ð”‡ð”ˆð”‰ð”Šâ„Œâ„‘ð”ð”Žð”ð”ð”‘ð”’ð”“ð””â„œð”–ð”—ð”˜ð”™ð”šð”›ð”œâ„¨"), # 21
    ("Bubbles Small", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“žâ“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“žâ“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©"), # 22
    ("Bold", "ð—®ð—¯ð—°ð—±ð—²ð—³ð—´ð—µð—¶ð—·ð—¸ð—¹ð—ºð—»ð—¼ð—½ð—¾ð—¿ð˜€ð˜ð˜‚ð˜ƒð˜„ð˜…ð˜†ð˜‡", "ð—”ð—•ð—–ð——ð—˜ð—™ð—šð—›ð—œð—ð—žð—Ÿð— ð—¡ð—¢ð—£ð—¤ð—¥ð—¦ð—§ð—¨ð—©ð—ªð—«ð—¬ð—­"), # 23
]

class RunnableImpl(dynamic_proxy(Runnable)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def run(self):
        try: self.func()
        except Exception as e: log(f"Error in Runnable: {e}")

class ClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def onClick(self, view):
        try: self.func(view)
        except Exception as e: log(f"Click Error: {e}")

class FontMagicPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hooks = []

    def on_plugin_load(self):
        try:
            self._hook_send_button_menu()
            self.log("Hook installed successfully!")
        except Exception as e:
            self.log(f"Error loading plugin: {e}")
            self.log(traceback.format_exc())

    def on_plugin_unload(self):
        self.hooks.clear()

    def create_settings(self):
        return [
            Header("Font Magic"),
            Text("ÐŸÐ»Ð°Ð³Ð¸Ð½ Ð°ÐºÑ‚Ð¸Ð²ÐµÐ½. Ð—Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ Ð² Ñ‡Ð°Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ ÑˆÑ€Ð¸Ñ„Ñ‚!", icon="msg_info")
        ]
    def _hook_send_button_menu(self):
        try:
            target_class = None
            # Use JClass.forName to ensure we get a java.lang.Class object for reflection
            for name in ["org.telegram.ui.Components.MessageSendPreview", "org.telegram.ui.MessageSendPreview"]:
                try:
                    target_class = JClass.forName(name)
                    if target_class: 
                        self.log(f"Found MessageSendPreview class: {name}")
                        break
                except Exception: pass
            
            if not target_class:
                self.log("ERROR: MessageSendPreview class NOT found via reflection!")
                return

            item_options_class = None
            for name in ["org.telegram.ui.Components.ItemOptions", "org.telegram.ui.ItemOptions"]:
                try:
                    item_options_class = JClass.forName(name)
                    if item_options_class: break
                except Exception: pass
            
            if not item_options_class:
                self.log("ERROR: ItemOptions class NOT found via reflection!")
                return

            hook_method = target_class.getDeclaredMethod("setItemOptions", item_options_class)
            hook_method.setAccessible(True)
            self.hook_method(hook_method, self.SendButtonMenuHook(self))
            self.log(f"Hooked setItemOptions on {target_class.getName()}")

        except Exception as e:
            self.log(f"Failed to hook MessageSendPreview: {e}")
            self.log(traceback.format_exc())
    class SendButtonMenuHook(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin

        def before_hooked_method(self, param):
            try:
                item_options = param.args[0]
                if not item_options:
                    return
                
                self.plugin.log("SendButtonMenuHook triggered!")
                
                preview_view = param.thisObject

                def open_font_selector():
                    # Dismiss menus on UI thread
                    run_on_ui_thread(lambda: self._dismiss_menus(preview_view, item_options))

                    fragment = get_last_fragment()
                    if not fragment: return
                    
                    try:
                        chat_activity = fragment
                        enter_view = get_private_field(chat_activity, "chatActivityEnterView")
                        if not enter_view: return

                        self.plugin.show_font_selector(chat_activity, enter_view)
                    except Exception as e:
                        log(f"Error opening selector: {e}")

                runnable = RunnableImpl(open_font_selector)
                self.plugin.log("Added 'Edit Font' item to menu")
                item_options.add(R.drawable.msg_edit, "ð”‰ Ð ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑˆÑ€Ð¸Ñ„Ñ‚", runnable)
            except Exception as e:
                log(f"SendButtonMenuHook Error: {e}")

        def _dismiss_menus(self, preview, options):
            # Aggressively try to close the menus
            try:
                if options:
                     if hasattr(options, "dismiss"):
                         options.dismiss()
            except: pass
            
            try:
                if preview: 
                    for m in ["dismiss", "close", "dismissWithAlphaAnimation"]:
                        try:
                            if hasattr(preview, m):
                                getattr(preview, m)()
                        except: pass
            except: pass

    def show_font_selector(self, chat_activity, enter_view):
        try:
            context = chat_activity.getParentActivity()
            if not context: return

            bottom_sheet = BottomSheet(context, False)
            bottom_sheet.setOpenNoDelay(True)

            # Layout
            container = LinearLayout(context)
            container.setOrientation(LinearLayout.VERTICAL)
            container.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(10))
            
            # Header
            header = TextView(context)
            header.setText("Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÑÑ‚Ð¸Ð»ÑŒ")
            header.setTextSize(20)
            header.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
            header.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            header.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(10), AndroidUtilities.dp(20), AndroidUtilities.dp(10))
            container.addView(header)

            # ScrollView for list
            scroll = ScrollView(context)
            list_layout = LinearLayout(context)
            list_layout.setOrientation(LinearLayout.VERTICAL)
            
            for idx, (name, lower_map, upper_map) in enumerate(FONTS_DATA):
                font_item = TextView(context)
                
                # Preview Text
                preview_text = name
                if lower_map or upper_map:
                    preview_text = self.convert_string(name, lower_map, upper_map)
                
                font_item.setText(preview_text)
                font_item.setTextSize(18)
                font_item.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                font_item.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(12), AndroidUtilities.dp(24), AndroidUtilities.dp(12))
                font_item.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT)
                
                # Ripple effect
                bg = Theme.getSelectorDrawable(True)
                font_item.setBackground(bg)
                font_item.setClickable(True)

                def on_click(v, i=idx, l_map=lower_map, u_map=upper_map):
                    try:
                        self.apply_font(enter_view, l_map, u_map)
                        bottom_sheet.dismiss()
                    except Exception as e:
                        log(f"Apply Error: {e}")

                font_item.setOnClickListener(ClickListener(on_click))
                list_layout.addView(font_item)

            scroll.addView(list_layout)
            container.addView(scroll, LinearLayout.LayoutParams(-1, -2))

            bottom_sheet.setCustomView(container)
            bottom_sheet.show()
        except Exception as e:
            log(f"Show Selector Error: {e}")
            try: BulletinHelper.show_error(f"Error: {e}", chat_activity)
            except: pass
    def apply_font(self, enter_view, lower_map, upper_map):
        def action():
            try:
                # 1. Try to find EditText in the passed EnterView
                edit_field = self._find_edit_text(enter_view)
                
                # 2. If not found, try to find EnterView in current fragment first
                if not edit_field:
                    fragment = get_last_fragment()
                    if fragment:
                        new_enter_view = self._find_enter_view(fragment)
                        if new_enter_view:
                            edit_field = self._find_edit_text(new_enter_view)

                if not edit_field: 
                    log("Could not find EditText in EnterView")
                    return
                
                text_obj = edit_field.getText()
                if not text_obj: return
                
                original_text = text_obj.toString()
                new_text = self.convert_string(original_text, lower_map, upper_map)
                
                edit_field.setText(new_text)
                try:
                    edit_field.setSelection(len(new_text))
                except: pass
                try:
                    BulletinHelper.show_success("Ð¨Ñ€Ð¸Ñ„Ñ‚ Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½!", get_last_fragment())
                except: pass
            except Exception as e:
                log(f"Apply Font Error: {e}")
        run_on_ui_thread(action)

    def _find_edit_text(self, view):
        if not view: return None
        
        # 1. Try direct accessor (best for Telegram components)
        try:
            if hasattr(view, "getEditField"):
                f = view.getEditField()
                if f: return f
        except: pass

        # 2. Check class name
        try:
            cls_name = str(view.getClass().getName())
            if "EditText" in cls_name:
                return view
            
            # 3. Traverse children (Duck typing for ViewGroup)
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    child = view.getChildAt(i)
                    res = self._find_edit_text(child)
                    if res: return res
        except: pass
        
        return None

    def _find_enter_view(self, fragment):
        try:
            v = get_private_field(fragment, "chatActivityEnterView")
            if v: return v
        except: pass
        try:
            return self._find_view_by_class_name(fragment.getFragmentView(), "ChatActivityEnterView")
        except: return None

    def _find_view_by_class_name(self, view, class_name_part):
        if not view: return None
        try:
            if class_name_part in str(view.getClass().getName()):
                return view
            
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    res = self._find_view_by_class_name(view.getChildAt(i), class_name_part)
                    if res: return res
        except: pass
        return None

    def convert_string(self, text, lower_map, upper_map):
        if not lower_map and not upper_map:
            return text # Normal

        rus_map = {
            'Ð°':'a','Ð±':'b','Ð²':'v','Ð³':'g','Ð´':'d','Ðµ':'e','Ñ‘':'e','Ð¶':'zh','Ð·':'z','Ð¸':'i',
            'Ð¹':'y','Ðº':'k','Ð»':'l','Ð¼':'m','Ð½':'n','Ð¾':'o','Ð¿':'p','Ñ€':'r','Ñ':'s','Ñ‚':'t',
            'Ñƒ':'u','Ñ„':'f','Ñ…':'h','Ñ†':'c','Ñ‡':'ch','Ñˆ':'sh','Ñ‰':'sh','ÑŠ':'','Ñ‹':'y','ÑŒ':'',
            'Ñ':'e','ÑŽ':'yu','Ñ':'ya',
            'Ð':'A','Ð‘':'B','Ð’':'V','Ð“':'G','Ð”':'D','Ð•':'E','Ð':'E','Ð–':'ZH','Ð—':'Z','Ð˜':'I',
            'Ð™':'Y','Ðš':'K','Ð›':'L','Ðœ':'M','Ð':'N','Ðž':'O','ÐŸ':'P','Ð ':'R','Ð¡':'S','Ð¢':'T',
            'Ð£':'U','Ð¤':'F','Ð¥':'H','Ð¦':'C','Ð§':'CH','Ð¨':'SH','Ð©':'SH','Ðª':'','Ð«':'Y','Ð¬':'',
            'Ð­':'E','Ð®':'YU','Ð¯':'YA'
        }

        result = []
        for char in text:
            # Transliterate if Russian, otherwise keep original
            # This handles single chars that map to multiple (e.g. 'Ñˆ' -> 'sh')
            replacement = rus_map.get(char, char)
            
            if not replacement:
                continue

            for c in replacement:
                # Handle Lowercase
                if 'a' <= c <= 'z' and lower_map:
                    index = ord(c) - ord('a')
                    if index < len(lower_map):
                        result.append(lower_map[index])
                        continue
                
                # Handle Uppercase
                if 'A' <= c <= 'Z' and upper_map:
                    index = ord(c) - ord('A')
                    if index < len(upper_map):
                        result.append(upper_map[index])
                        continue
                
                # Default
                result.append(c)
        
        return "".join(result)
