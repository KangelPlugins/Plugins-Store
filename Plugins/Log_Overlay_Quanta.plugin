__id__ = "logoverlay"
__name__ = "Log Overlay"
__author__ = "@RooniPlugin & fork by @luvztroy"
__version__ = "1.0.0"
__description__ = "A log overlay that watches your app crash, the same way you watched your crush fall for someone else.."

__icon__ = "Doki_Doki_fStikBot_by_fStikBot/17"
__min_version__ = "11.12.1"

import time
import traceback
import re
from typing import Any, List, Tuple
from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy, MethodHook
from android_utils import run_on_ui_thread, log
from hook_utils import find_class
from client_utils import get_last_fragment
from java import dynamic_proxy
from android.content import Context
from ui.alert import AlertDialogBuilder
from ui.settings import Input, Divider, Switch, Selector
from org.telegram.messenger import AndroidUtilities
import threading
from com.exteragram.messenger.plugins import PluginsController

def to_signed_32(n):
    n = n & 0xFFFFFFFF
    return n if n < 0x80000000 else n - 0x100000000

class LogOverlayPlugin(BasePlugin):

    WindowManager, LayoutParams, Gravity, LinearLayout, ScrollView, TextView, Button, View = (None,) * 8
    OnClickListener, OnTouchListener, MotionEvent, ClipboardManager, GradientDrawable, Point, RelativeLayout = (None,) * 7
    PixelFormat, Build_VERSION, Settings, Intent, Uri, ApplicationLoader, ClipData = (None,) * 7
    InputMethodManager, AlphaAnimation, Animation, Html, RippleDrawable, ColorStateList = (None,) * 6
    DecelerateInterpolator, AccelerateInterpolator, OvershootInterpolator, Runnable = (None,) * 4
    PluginsController, PluginSettingsActivity = (None, ) * 2

    full_logs = []
    pi_hooks = []
    is_overlay_open = False
    is_minimized = False
    logs_paused = False

    overlay_view, minimized_button, window_manager, log_text_view, scroll_view = (None,) * 5
    pause_button = None

    last_minimized_pos = (50, 200)
    initial_view_x, initial_view_y, initial_touch_x, initial_touch_y = 0, 0, 0.0, 0.0
    initial_width, initial_height = 0, 0

    MIN_WIDTH_DP = 280
    MIN_HEIGHT_DP = 200
    RESIZE_HANDLE_SIZE_DP = 25
    DRAG_THRESHOLD_DP = 10


    class RunnableProxy(dynamic_proxy(find_class("java.lang.Runnable"))):
        def __init__(self, func):
            super().__init__()
            self.func = func
        def run(self):
            try:
                self.func()
            except Exception as e:
                pass

    class AppLogHook(MethodHook):
        def __init__(self, plugin):
            super().__init__()
            self.plugin = plugin

        def before_hooked_method(self, param: Any):
            try:
                message = str(param.args[0])
                level_int = int(param.args[2])
                level_map = {0: "DEBUG", 1: "INFO", 2: "WARN", 3: "ERROR"}
                level_str = level_map.get(level_int, "LOG OVERLAY")
                self.plugin.log_to_overlay(message, level_str)
            except Exception as e:
                pass

    def on_plugin_load(self):
        self.load_android_classes()
        self._hook_telegram_logs()
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.DRAWER_MENU,
            text="Show Log Overlay",
            icon="msg_log_solar",
            on_click=lambda ctx: self.toggle_overlay()
        ))

    def on_plugin_unload(self):
        self.close_overlay()
        for unhook in self.pi_hooks:
            try:
                unhook.unhook()
            except Exception as e:
                pass
        self.pi_hooks.clear()

    def load_android_classes(self):
        if self.__class__.WindowManager: return
        classes_to_load = {
            "WindowManager": "android.view.WindowManager", "LayoutParams": "android.view.WindowManager$LayoutParams",
            "Gravity": "android.view.Gravity", "View": "android.view.View", "MotionEvent": "android.view.MotionEvent",
            "LinearLayout": "android.widget.LinearLayout", "RelativeLayout": "android.widget.RelativeLayout",
            "ScrollView": "android.widget.ScrollView", "TextView": "android.widget.TextView",
            "Button": "android.widget.Button", "OnClickListener": "android.view.View$OnClickListener",
            "OnTouchListener": "android.view.View$OnTouchListener", "ClipboardManager": "android.content.ClipboardManager",
            "ClipData": "android.content.ClipData", "GradientDrawable": "android.graphics.drawable.GradientDrawable",
            "Point": "android.graphics.Point", "PixelFormat": "android.graphics.PixelFormat",
            "Build_VERSION": "android.os.Build$VERSION", "Settings": "android.provider.Settings",
            "Intent": "android.content.Intent", "Uri": "android.net.Uri",
            "ApplicationLoader": "org.telegram.messenger.ApplicationLoader", "InputMethodManager": "android.view.input.InputMethodManager",
            "Html": "android.text.Html", "AlphaAnimation": "android.view.animation.AlphaAnimation",
            "Animation": "android.view.animation.Animation", "RippleDrawable": "android.graphics.drawable.RippleDrawable",
            "ColorStateList": "android.content.res.ColorStateList", "DecelerateInterpolator": "android.view.animation.DecelerateInterpolator",
            "AccelerateInterpolator": "android.view.animation.AccelerateInterpolator", "OvershootInterpolator": "android.view.animation.OvershootInterpolator",
            "Runnable": "java.lang.Runnable",
            "PluginsController": "com.exteragram.messenger.plugins.PluginsController",
            "PluginSettingsActivity": "com.exteragram.messenger.plugins.ui.PluginSettingsActivity"
        }
        for name, path in classes_to_load.items():
            setattr(self.__class__, name, find_class(path))

    def _hook_telegram_logs(self):
        try:
            AppUtils = find_class("com.exteragram.messenger.utils.AppUtils")
            if not AppUtils:
                return

            IntegerType = find_class("java.lang.Integer").TYPE
            String = find_class("java.lang.String")
            Throwable = find_class("java.lang.Throwable")

            method_to_hook = AppUtils.getClass().getDeclaredMethod("logInternal", String, Throwable, IntegerType)
            method_to_hook.setAccessible(True)

            handler = self.AppLogHook(self)
            unhook = self.hook_method(method_to_hook, handler)
            if unhook: self.pi_hooks.append(unhook)
        except Exception as e:
            pass

    def _is_plugin_log(self, message: str, plugin_source: str) -> bool:
        system_patterns = [
            "Successfully accessed private field",
            "Successfully set private field"
        ]
        
        for pattern in system_patterns:
            if pattern in message:
                return False
        
        if plugin_source and plugin_source not in ["ERROR", "WARN", "DEBUG", "INFO", "LOG"]:
            return True
        
        plugin_indicators = [
            "plugin", "Plugin", "PLUGIN",
            "hook", "Hook", "HOOK", 
            "quanta", "Quanta", "QUANTA",
            "extera", "Extera", "EXTERA"
        ]
        
        for indicator in plugin_indicators:
            if indicator in message:
                return True
        
        if plugin_source in ["ERROR", "WARN", "DEBUG", "INFO", "LOG"]:
            return True
        
        return False

    def log_to_overlay(self, message: str, level: str = "INFO"):
        import re
        match = re.match(r"\[([A-Za-z0-9_\- ]+)\]", message)
        if match:
            plugin_source = match.group(1)
        else:
            plugin_source = level 
        
        plugin_only_filter = self.get_setting("plugin_only_filter", True)
        if plugin_only_filter:
            if not self._is_plugin_log(message, plugin_source):
                return
        
        color_map = {"ERROR": "#F44336", "WARN": "#FFC107", "DEBUG": "#03A9F4", "INFO": "#4CAF50", "LOG": "#FFFFFF"}
        color = color_map.get(level, "#FFFFFF")
        timestamp = time.strftime("%H:%M:%S", time.localtime())
        show_timestamps = self.get_setting("show_timestamps", True)
        safe_message = message.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        if match:
            safe_message = safe_message[match.end():].lstrip()
        self.full_logs.append((timestamp, safe_message, level, plugin_source, color))
        limit = int(self.get_setting("log_limit", "200"))
        if len(self.full_logs) > limit:
            self.full_logs = self.full_logs[-limit:]
        if self.is_overlay_open and not self.is_minimized and not self.logs_paused:
            run_on_ui_thread(self._filter_and_update_logs)

    def _filter_and_update_logs(self):
        if not self.log_text_view: return
        show_timestamps = self.get_setting("show_timestamps", True)
        grouping_mode = int(self.get_setting("log_grouping", 0))
        def format_log(log_tuple):
            timestamp, safe_message, level, plugin_source, color = log_tuple
            if show_timestamps:
                return f'<font color="{color}"><b>[{timestamp}][{plugin_source}]</b></font> {safe_message}'
            else:
                return f'<font color="{color}"><b>[{plugin_source}]</b></font> {safe_message}'
        final_logs = [format_log(log) for log in self.full_logs]
        html_text = ""
        if grouping_mode == 0:
            html_text = self.Html.fromHtml("<br>".join(final_logs), self.Html.FROM_HTML_MODE_LEGACY)
        else:
            import re
            from collections import defaultdict
            grouped = defaultdict(list)
            if grouping_mode == 1:
                for log_tuple in self.full_logs:
                    timestamp, safe_message, level, plugin_source, color = log_tuple
                    key = plugin_source
                    grouped[key].append(format_log(log_tuple))
                html_lines = []
                for plugin, logs in grouped.items():
                    html_lines.append(f'<b>[Plugin: {plugin}]</b>')
                    html_lines.extend(logs)
                html_text = self.Html.fromHtml("<br>".join(html_lines), self.Html.FROM_HTML_MODE_LEGACY)
            elif grouping_mode == 2:
                for log_tuple in self.full_logs:
                    timestamp, safe_message, level, plugin_source, color = log_tuple
                    grouped[level].append(format_log(log_tuple))
                html_lines = []
                for level, logs in grouped.items():
                    html_lines.append(f'<b>[{level}]</b>')
                    html_lines.extend(logs)
                html_text = self.Html.fromHtml("<br>".join(html_lines), self.Html.FROM_HTML_MODE_LEGACY)
            elif grouping_mode == 3:
                for log_tuple in self.full_logs:
                    timestamp, safe_message, level, plugin_source, color = log_tuple
                    time_str = timestamp[:5]
                    grouped[time_str].append(format_log(log_tuple))
                html_lines = []
                for time_period, logs in grouped.items():
                    html_lines.append(f'<b>[{time_period}]</b>')
                    html_lines.extend(logs)
                html_text = self.Html.fromHtml("<br>".join(html_lines), self.Html.FROM_HTML_MODE_LEGACY)
        self.log_text_view.setText(html_text)

    def _create_overlay_view(self, context: Context):
        root_layout = self.RelativeLayout(context)
        root_bg = self._create_rounded_drawable(to_signed_32(0xEE212121), 30, 2, to_signed_32(0xFF555555))
        root_layout.setBackground(root_bg)
        root_layout.setFocusableInTouchMode(True)
        root_layout.setOnTouchListener(self._create_drag_and_resize_listener())
        
        content_container = self.LinearLayout(context)
        content_container.setOrientation(self.LinearLayout.VERTICAL)

        from android.widget import SeekBar

        header_bar = self.LinearLayout(context)
        header_bar.setOrientation(self.LinearLayout.HORIZONTAL)
        header_bar.setGravity(self.Gravity.CENTER_VERTICAL)
        header_bar.setPadding(20, 10, 12, 10)
        header_bar.setMinimumHeight(AndroidUtilities.dp(56))
        header_bar.setLayoutParams(self.LinearLayout.LayoutParams(-1, -2)) 

        drag_handle = self.TextView(context)
        drag_handle.setText("")
        res_id = context.getResources().getIdentifier("etg_settings_solar", "drawable", context.getPackageName())
        if res_id:
            drawable = context.getResources().getDrawable(res_id)
            icon_size = AndroidUtilities.dp(22)
            drawable.setBounds(0, 0, icon_size, icon_size)
            drag_handle.setCompoundDrawables(drawable, None, None, None)
        drag_handle.setTextColor(to_signed_32(0xFFFFFFFF))
        drag_handle.setTextSize(18)
        drag_handle.setGravity(self.Gravity.CENTER_VERTICAL)
        header_bar.addView(drag_handle)

        spacer = self.View(context)
        header_bar.addView(spacer, self.LinearLayout.LayoutParams(0, -1, 1.0))

        btn_settings = self._create_icon_button(context, on_click=self._open_plugin_settings, icon_name="msg_settings_14_solar")
        btn_minimize = self._create_icon_button(context, on_click=self.minimize_overlay, icon_name="msg_remove_solar")
        btn_settings.setPadding(12, 0, 12, 0)
        btn_settings.setLayoutParams(self.LinearLayout.LayoutParams(AndroidUtilities.dp(36), AndroidUtilities.dp(36)))
        btn_minimize.setPadding(12, 0, 12, 0)
        btn_minimize.setLayoutParams(self.LinearLayout.LayoutParams(AndroidUtilities.dp(36), AndroidUtilities.dp(36)))
        btn_close = self._create_icon_button(context, on_click=lambda: self.close_overlay(), icon_name="msg_cancel_solar")
        btn_close.setPadding(12, 0, 12, 0)
        btn_close.setLayoutParams(self.LinearLayout.LayoutParams(AndroidUtilities.dp(36), AndroidUtilities.dp(36)))
        header_bar.addView(btn_settings)
        header_bar.addView(btn_minimize)
        header_bar.addView(btn_close)
        content_container.addView(header_bar)

        self.scroll_view = self.ScrollView(context)
        self.log_text_view = self.TextView(context)
        self.log_text_view.setPadding(25, 5, 25, 25); self.log_text_view.setTextColor(to_signed_32(0xFFFFFFFF))
        self.log_text_view.setTextIsSelectable(True); self.log_text_view.setTextSize(float(self.get_setting("log_font_size", "12")))
        self.scroll_view.addView(self.log_text_view)
        
        self.seekbar = SeekBar(context)
        self.seekbar.setMax(1000)
        self.seekbar.setLayoutParams(self.LinearLayout.LayoutParams(AndroidUtilities.dp(24), -1))
        self.seekbar.setRotation(-90)
        self.seekbar.setPadding(0, 0, 0, 0)
        self.seekbar.setVisibility(self.View.VISIBLE)
        
        try:
            from android.graphics import PorterDuff
            self.seekbar.getProgressDrawable().setColorFilter(to_signed_32(0xFFFFFFFF), PorterDuff.Mode.SRC_IN)
            self.seekbar.getThumb().setColorFilter(to_signed_32(0xFF000000), PorterDuff.Mode.SRC_IN)
        except Exception as e:
            pass
        
        log_area_container = self.LinearLayout(context)
        log_area_container.setOrientation(self.LinearLayout.HORIZONTAL)
        log_area_container.addView(self.scroll_view, self.LinearLayout.LayoutParams(0, -1, 1.0))
        log_area_container.addView(self.seekbar)
        content_container.addView(log_area_container, self.LinearLayout.LayoutParams(-1, 0, 1.0))
        def on_seekbar_changed(seekbar, progress, from_user):
            if from_user and self.log_text_view:
                total_height = self.log_text_view.getHeight() - self.scroll_view.getHeight()
                if total_height > 0:
                    y = int(progress / 1000.0 * total_height)
                    self.scroll_view.scrollTo(0, y)
        class SeekBarChangeListener(dynamic_proxy(self.seekbar.OnSeekBarChangeListener)):
            def onProgressChanged(self, seekbar, progress, from_user):
                on_seekbar_changed(seekbar, progress, from_user)
            def onStartTrackingTouch(self, seekbar):
                pass
            def onStopTrackingTouch(self, seekbar):
                pass
        self.seekbar.setOnSeekBarChangeListener(SeekBarChangeListener())
        def update_seekbar():
            try:
                total_height = self.log_text_view.getHeight() - self.scroll_view.getHeight()
                if total_height > 0:
                    y = self.scroll_view.getScrollY()
                    progress = int(y / total_height * 1000)
                    self.seekbar.setProgress(progress)
                else:
                    self.seekbar.setProgress(0)
            except Exception as e:
                pass
        orig_filter_and_update_logs = self._filter_and_update_logs
        def patched_filter_and_update_logs(*args, **kwargs):
            orig_filter_and_update_logs(*args, **kwargs)
            update_seekbar()
        self._filter_and_update_logs = patched_filter_and_update_logs
        try:
            ScrollViewClass = type(self.scroll_view)
            orig_onScrollChanged = getattr(self.scroll_view, 'onScrollChanged', None)
            def onScrollChanged(*args, **kwargs):
                if orig_onScrollChanged:
                    orig_onScrollChanged(*args, **kwargs)
                update_seekbar()
            self.scroll_view.onScrollChanged = onScrollChanged
        except Exception:
            pass

        bottom_bar = self.LinearLayout(context); bottom_bar.setGravity(self.Gravity.CENTER); bottom_bar.setPadding(10, 10, 10, 10)
        self.pause_button = self._create_icon_button(context, on_click=self._toggle_log_pause, icon_name="msg_played_solar")
        btn_clear = self._create_icon_button(context, on_click=self._clear_logs, icon_name="msg_delete_solar")
        btn_copy = self._create_icon_button(context, on_click=self._copy_all_logs, icon_name="msg_copy_solar")
        btn_copy_selected = self._create_icon_button(context, on_click=self._copy_selected_text, icon_name="menu_select_quote_solar")
        
        self.pause_label = self.TextView(context)
        self.pause_label.setText("Pause")
        self.pause_label.setTextColor(to_signed_32(0xFFCCCCCC))
        self.pause_label.setTextSize(10)
        self.pause_label.setGravity(self.Gravity.CENTER)
        self.pause_label.setSingleLine(False)
        self.pause_label.setMaxLines(2)
        self.pause_label.setEllipsize(None)
        

        clear_label = self.TextView(context)
        clear_label.setText("Clear")
        clear_label.setTextColor(to_signed_32(0xFFCCCCCC))
        clear_label.setTextSize(10)
        clear_label.setGravity(self.Gravity.CENTER)
        clear_label.setSingleLine(False)
        clear_label.setMaxLines(2)
        clear_label.setEllipsize(None)

        copy_label = self.TextView(context)
        copy_label.setText("Copy")
        copy_label.setTextColor(to_signed_32(0xFFCCCCCC))
        copy_label.setTextSize(10)
        copy_label.setGravity(self.Gravity.CENTER)
        copy_label.setSingleLine(False)
        copy_label.setMaxLines(2)
        copy_label.setEllipsize(None)

        copy_selected_label = self.TextView(context)
        copy_selected_label.setText("Copy Selected")
        copy_selected_label.setTextColor(to_signed_32(0xFFCCCCCC))
        copy_selected_label.setTextSize(10)
        copy_selected_label.setGravity(self.Gravity.CENTER)
        copy_selected_label.setSingleLine(False)
        copy_selected_label.setMaxLines(2)
        copy_selected_label.setEllipsize(None)

        self.button_labels = [
            self.pause_label,
            clear_label,
            copy_label,
            copy_selected_label
        ]

        def make_button_with_label(btn, label_view):
            v_layout = self.LinearLayout(context)
            v_layout.setOrientation(self.LinearLayout.VERTICAL)
            v_layout.setGravity(self.Gravity.CENTER)
            v_layout.setPadding(8, 0, 8, 0) 
            min_width = AndroidUtilities.dp(60)
            v_layout.setMinimumWidth(min_width)
            params = self.LinearLayout.LayoutParams(min_width, -2)
            v_layout.setLayoutParams(params)
            v_layout.addView(btn)
            spacer = self.View(context)
            spacer.setLayoutParams(self.LinearLayout.LayoutParams(1, AndroidUtilities.dp(6)))
            show_labels = self.get_setting("show_button_labels", True)
            if show_labels:
                v_layout.addView(spacer)
                v_layout.addView(label_view)
            return v_layout

        def make_label(text):
            label = self.TextView(context)
            label.setText(text)
            label.setTextColor(to_signed_32(0xFFCCCCCC))
            label.setTextSize(10)
            label.setGravity(self.Gravity.CENTER)
            label.setSingleLine(False)
            label.setMaxLines(2)
            label.setEllipsize(None)
            return label

        bottom_bar.addView(make_button_with_label(self.pause_button, self.pause_label))
        bottom_bar.addView(make_button_with_label(btn_clear, clear_label))
        bottom_bar.addView(make_button_with_label(btn_copy, copy_label))
        bottom_bar.addView(make_button_with_label(btn_copy_selected, copy_selected_label))
        content_container.addView(bottom_bar, self.LinearLayout.LayoutParams(-1, -2))
        self.bottom_bar = bottom_bar
        
        root_layout.addView(content_container, self.RelativeLayout.LayoutParams(-1, -1))
        
        resize_handle = self.TextView(context)
        resize_handle.setText("â‡²")
        resize_handle.setTextColor(to_signed_32(0x99FFFFFF))
        resize_handle.setTextSize(24)
        
        resize_params = self.RelativeLayout.LayoutParams(-2, -2)
        resize_params.addRule(self.RelativeLayout.ALIGN_PARENT_RIGHT)
        resize_params.addRule(self.RelativeLayout.ALIGN_PARENT_BOTTOM)
        resize_params.setMargins(0, 0, AndroidUtilities.dp(5), AndroidUtilities.dp(5))
        root_layout.addView(resize_handle, resize_params)

        handle_touch_height = AndroidUtilities.dp(40)
        handle_pill_height = AndroidUtilities.dp(6)
        handle_width = AndroidUtilities.dp(120)
        handle_margin = 0
        handle = self.RelativeLayout(context)
        handle_params = self.RelativeLayout.LayoutParams(handle_width, handle_touch_height)
        handle_params.addRule(self.RelativeLayout.ALIGN_PARENT_BOTTOM)
        handle_params.addRule(self.RelativeLayout.CENTER_HORIZONTAL)
        handle_params.bottomMargin = handle_margin
        handle.setLayoutParams(handle_params)
        handle.setAlpha(0.3)
        handle.setClickable(True)
        handle.setFocusable(True)
        pill = self.View(context)
        pill_bg = self._create_rounded_drawable(to_signed_32(0x80FFFFFF), handle_pill_height // 2)
        pill.setBackground(pill_bg)
        pill.setAlpha(0.0)
        pill_params = self.RelativeLayout.LayoutParams(handle_width, handle_pill_height)
        pill_params.addRule(self.RelativeLayout.CENTER_IN_PARENT)
        pill.setLayoutParams(pill_params)
        handle.addView(pill)

        HandleTouchListener = dynamic_proxy(self.View.OnTouchListener)
        class _HandleTouchListener(HandleTouchListener):
            def __init__(self):
                super().__init__()
                self.plugin = self_outer
                self.start_y = 0
                self.swipe_threshold = AndroidUtilities.dp(40)
                self.swiping = False
            def onTouch(self, v, event):
                action = event.getAction()
                if action == self.plugin.MotionEvent.ACTION_DOWN:
                    self.start_y = event.getRawY()
                    self.swiping = True
                    return True
                elif action == self.plugin.MotionEvent.ACTION_MOVE and self.swiping:
                    dy = self.start_y - event.getRawY()
                    if dy > self.swipe_threshold:
                        self.swiping = False
                        self.plugin.minimize_overlay()
                        return True
                    return True
                elif action in (self.plugin.MotionEvent.ACTION_UP, self.plugin.MotionEvent.ACTION_CANCEL):
                    self.swiping = False
                    return True
                return False
        self_outer = self
        handle.setOnTouchListener(_HandleTouchListener())
        root_layout.addView(handle)

        return root_layout

    def open_overlay(self):
        if self.is_overlay_open: return
        def action():
            try:
                self.logs_paused = False
                app_context = self.ApplicationLoader.applicationContext
                if not app_context: return

                self.window_manager = app_context.getSystemService(Context.WINDOW_SERVICE)
                if self.overlay_view is None: self.overlay_view = self._create_overlay_view(app_context)
                self._filter_and_update_logs()
                
                display = self.window_manager.getDefaultDisplay(); size = self.Point(); display.getSize(size)
                min_width = AndroidUtilities.dp(self.MIN_WIDTH_DP)
                min_height = AndroidUtilities.dp(self.MIN_HEIGHT_DP)
                max_width = size.x
                max_height = size.y
                width = int(self.get_setting("overlay_width", int(size.x * 0.9)))
                height = int(self.get_setting("overlay_height", int(size.y * 0.75)))
                width = max(min_width, min(width, max_width))
                height = max(min_height, min(height, max_height))
                
                flags = (
                    self.LayoutParams.FLAG_NOT_TOUCH_MODAL |
                    self.LayoutParams.FLAG_NOT_FOCUSABLE |
                    self.LayoutParams.FLAG_LAYOUT_NO_LIMITS
                )
                params = self.LayoutParams(width, height, self.LayoutParams.TYPE_APPLICATION_OVERLAY if self.Build_VERSION.SDK_INT >= 26 else self.LayoutParams.TYPE_PHONE,
                                           flags, self.PixelFormat.TRANSLUCENT)
                params.gravity = self.Gravity.CENTER
                params.softInputMode = self.LayoutParams.SOFT_INPUT_ADJUST_RESIZE
                
                try:
                    self.window_manager.addView(self.overlay_view, params)
                except Exception as e:
                    fragment = get_last_fragment()
                    if fragment and fragment.getParentActivity():
                        intent = self.Intent(self.Settings.ACTION_MANAGE_OVERLAY_PERMISSION, self.Uri.parse("package:" + app_context.getPackageName()))
                        fragment.getParentActivity().startActivity(intent)
                    return

                self.overlay_view.animate().alpha(1.0).scaleX(1.0).scaleY(1.0).setDuration(250).setInterpolator(self.OvershootInterpolator(1.0)).start()
                self.is_overlay_open, self.is_minimized = True, False
            except Exception as e:
                self.is_overlay_open = False
                pass
        run_on_ui_thread(action)

    def close_overlay(self):
        def action():
            try:
                if self.window_manager:
                    if self.overlay_view:
                        try:
                            if self.overlay_view.isAttachedToWindow():
                                self.window_manager.removeView(self.overlay_view)
                        except Exception as e:
                            pass
                        self.overlay_view = None
                    if self.minimized_button:
                        try:
                            if self.minimized_button.isAttachedToWindow():
                                self.window_manager.removeView(self.minimized_button)
                        except Exception as e:
                            pass
                        self.minimized_button = None
            except Exception as e:
                pass
            finally:
                self.is_overlay_open = False
                self.is_minimized = False
        run_on_ui_thread(action)

    def _perform_close(self):
        self.close_overlay()

    def minimize_overlay(self):
        if not self.is_overlay_open or self.is_minimized: return
        run_on_ui_thread(lambda: self._perform_minimize())

    def _perform_minimize(self):
        try:
            if not self.window_manager or not self.overlay_view or not self.overlay_view.isAttachedToWindow():
                self.close_overlay(); return

            def on_minimize_end():
                if self.overlay_view:
                    self.overlay_view.setVisibility(self.View.GONE)
                    if self.overlay_view.isAttachedToWindow():
                        self.window_manager.removeView(self.overlay_view)

            app_context = self.ApplicationLoader.applicationContext
            minimized_bg = self._create_rounded_drawable([to_signed_32(0xAA000000), to_signed_32(0xAA222222)], 60)
            self.minimized_button = self._create_icon_button(
                app_context,
                on_click=self.maximize_overlay,
                size=120,
                background=minimized_bg,
                icon_name="etg_settings_solar"
            )
            self.minimized_button.setGravity(self.Gravity.CENTER)
            self.minimized_button.setPadding(AndroidUtilities.dp(9), 0, AndroidUtilities.dp(30), 0)
            self.minimized_button.setOnTouchListener(self._create_drag_and_resize_listener(is_minimized_btn=True))
            
            min_params = self.LayoutParams(120, 120, self.LayoutParams.TYPE_APPLICATION_OVERLAY if self.Build_VERSION.SDK_INT >= 26 else self.LayoutParams.TYPE_PHONE,
                                           self.LayoutParams.FLAG_NOT_FOCUSABLE | self.LayoutParams.FLAG_LAYOUT_NO_LIMITS, self.PixelFormat.TRANSLUCENT)
            min_params.gravity = self.Gravity.TOP | self.Gravity.LEFT
            min_params.x, min_params.y = self.last_minimized_pos
            
            self.minimized_button.setAlpha(0.0); self.minimized_button.setScaleX(0.0); self.minimized_button.setScaleY(0.0)
            self.window_manager.addView(self.minimized_button, min_params)

            self.minimized_button.animate().alpha(1.0).scaleX(1.0).scaleY(1.0).setDuration(300).setInterpolator(self.OvershootInterpolator()).start()
            
            self.overlay_view.animate().alpha(0.0).scaleX(0.0).scaleY(0.0).setDuration(300).setInterpolator(self.AccelerateInterpolator()).withEndAction(
                self.RunnableProxy(on_minimize_end)
            ).start()
            
            self.is_minimized = True
        except Exception as e:
            self.close_overlay()

    def maximize_overlay(self):
        if not self.is_overlay_open or not self.is_minimized: return
        run_on_ui_thread(lambda: self._perform_maximize())

    def _perform_maximize(self):
        try:
            if not all([self.window_manager, self.minimized_button, self.overlay_view]): self.close_overlay(); return
            
            if not self.overlay_view.isAttachedToWindow():
                self.window_manager.addView(self.overlay_view, self.overlay_view.getLayoutParams())

            self.overlay_view.setVisibility(self.View.VISIBLE)
            self.overlay_view.setAlpha(0.0); self.overlay_view.setScaleX(0.0); self.overlay_view.setScaleY(0.0)
            
            self.overlay_view.animate().alpha(1.0).scaleX(1.0).scaleY(1.0).setDuration(300).setInterpolator(self.OvershootInterpolator()).start()
            
            self.minimized_button.animate().alpha(0.0).scaleX(0.0).scaleY(0.0).setDuration(300).setInterpolator(self.AccelerateInterpolator()).withEndAction(
                 self.RunnableProxy(lambda: self.window_manager.removeView(self.minimized_button) if self.minimized_button and self.minimized_button.isAttachedToWindow() else None)
            ).start()
            
            self.minimized_button = None
            self.is_minimized = False

            run_on_ui_thread(self._filter_and_update_logs)
        except Exception as e:
            self.close_overlay()

    def _clear_logs(self):
        self.full_logs.clear()
        self._filter_and_update_logs()

    def _copy_all_logs(self):
        if not self.full_logs:
            return
        plain_logs = "\n".join([re.sub(r'<[^>]+>', '', log[1]) for log in self.full_logs])
        def do_copy():
            try:
                app_context = self.ApplicationLoader.applicationContext
                clipboard = app_context.getSystemService(Context.CLIPBOARD_SERVICE)
                clipboard.setPrimaryClip(self.ClipData.newPlainText("Logs", plain_logs))
            except Exception as e:
                pass
        run_on_ui_thread(do_copy)

    def _copy_selected_text(self):
        try:
            text_view = self.log_text_view
            sel_start = text_view.getSelectionStart() if hasattr(text_view, 'getSelectionStart') else -1
            sel_end = text_view.getSelectionEnd() if hasattr(text_view, 'getSelectionEnd') else -1
            if sel_start != sel_end and sel_start >= 0 and sel_end >= 0:
                selected = str(text_view.getText().subSequence(min(sel_start, sel_end), max(sel_start, sel_end)))
                app_context = self.ApplicationLoader.applicationContext
                clipboard = app_context.getSystemService(Context.CLIPBOARD_SERVICE)
                clipboard.setPrimaryClip(self.ClipData.newPlainText("Selected Text", selected))
        except Exception as e:
            pass

    def _toggle_log_pause(self):
        self.logs_paused = not self.logs_paused
        if self.logs_paused:
            self.pause_label.setText("Start")
        else:
            self.pause_label.setText("Pause")
        if not self.logs_paused: run_on_ui_thread(self._filter_and_update_logs)

    def toggle_overlay(self):
        self.close_overlay() if self.is_overlay_open else self.open_overlay()

    def _open_plugin_settings(self):
        def action():
            try:
                self.minimize_overlay()
                java_plugin = self.PluginsController.getInstance().plugins.get(self.id)
                if java_plugin:
                    fragment = get_last_fragment()
                    if fragment: fragment.presentFragment(self.PluginSettingsActivity(java_plugin))
            except Exception as e:
                pass
        run_on_ui_thread(action)

    def create_settings(self):
        return [
            Input(
                key="log_font_size",
                text="Log font size",
                default="12",
                icon="msg_photo_text2",
                on_change=lambda value: run_on_ui_thread(self._apply_log_settings)
            ),
            Input(
                key="log_limit",
                text="Log memory limit",
                default="200",
                subtext="Max logs in memory. Lower if laggy.",
                icon="menu_clear_cache_solar",
                on_change=lambda value: run_on_ui_thread(self._apply_log_settings)
            ),
            Switch(
                key="show_timestamps",
                text="Show Timestamps",
                default=True,
                subtext="Display time in log entries",
                icon="msg_calendar",
                on_change=lambda value: run_on_ui_thread(self._apply_log_settings)
            ),
            Selector(
                key="log_grouping",
                text="Group Logs By",
                default=0,
                items=["None", "Plugin", "Level", "Time Period"],
                icon="menu_tag_filter_solar",
                on_change=lambda value: run_on_ui_thread(self._filter_and_update_logs)
            ),
            Switch(
                key="show_button_labels",
                text="Show Button Labels",
                default=True,
                subtext="Show or hide text labels under bottom bar buttons",
                icon="msg_photo_text2",
                on_change=lambda value: run_on_ui_thread(self._update_button_labels)
            ),
            Switch(
                key="plugin_only_filter",
                text="Plugin-Only Filter",
                default=True,
                subtext="Only show logs from plugins, filter out system/internal logs",
                icon="menu_tag_filter_solar",
                on_change=lambda value: run_on_ui_thread(self._filter_and_update_logs)
            ),
            Divider(text="Thank you for using Log Overlay! Feedback?\nJoin: @QuantaPlugins")
        ]


    def _create_rounded_drawable(self, color_or_colors: Any, radius: float, stroke_width: int = 0, stroke_color: int = 0):
        d = self.GradientDrawable()
        if isinstance(color_or_colors, list): d.setColors([c for c in color_or_colors]); d.setOrientation(self.GradientDrawable.Orientation.TL_BR)
        else: d.setColor(color_or_colors)
        d.setCornerRadius(radius)
        if stroke_width > 0: d.setStroke(stroke_width, stroke_color)
        return d
        
    def _create_icon_button(self, context: Context, icon_text: str = None, on_click: callable = None, size: int = 100, background: Any = None, icon_name: str = None):
        btn = self.Button(context)
        btn.setText("")
        if icon_name:
            res_id = context.getResources().getIdentifier(icon_name, "drawable", context.getPackageName())
            if res_id:
                drawable = context.getResources().getDrawable(res_id)
                icon_size = AndroidUtilities.dp(24)
                drawable.setBounds(0, 0, icon_size, icon_size)
                btn.setCompoundDrawables(drawable, None, None, None)
            else:
                btn.setText(icon_text or "")
            if background is not None:
                btn.setBackground(background)
            else:
                btn.setBackgroundColor(0x00000000)
        else:
            if icon_text:
                btn.setText(icon_text)
            btn.setTextSize(18)
            btn.setIncludeFontPadding(False)
            btn.setGravity(self.Gravity.CENTER)
            btn.setTextColor(to_signed_32(0xFFFFFFFF))
            content = background or self._create_rounded_drawable(to_signed_32(0x55000000), float(size / 2))
            if self.Build_VERSION.SDK_INT >= 21:
                mask = self.GradientDrawable(); mask.setShape(self.GradientDrawable.OVAL); mask.setColor(to_signed_32(0xFF000000))
                btn.setBackground(self.RippleDrawable(self.ColorStateList.valueOf(to_signed_32(0x40FFFFFF)), content, mask))
            else:
                btn.setBackground(content)
        btn.setPadding(AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4), AndroidUtilities.dp(4))
        btn.setMinimumWidth(size)
        btn.setMinimumHeight(size)
        try:
            btn.setStateListAnimator(None)
            btn.setElevation(0)
        except Exception:
            pass
        class ClickListener(dynamic_proxy(self.OnClickListener)):
            def __init__(self, plg, fn): super().__init__(); self.plugin = plg; self.fn = fn
            def onClick(self, v): self.fn()
        btn.setOnClickListener(ClickListener(self, on_click))
        params = self.LinearLayout.LayoutParams(size, size); params.setMargins(10, 5, 10, 5)
        btn.setLayoutParams(params)
        return btn


    def _create_drag_and_resize_listener(self, is_minimized_btn=False):
        class TouchListener(dynamic_proxy(self.OnTouchListener)):
            def __init__(self, plugin, is_minimized):
                super().__init__(); self.plugin = plugin; self.is_minimized = is_minimized
                self.drag_mode = 0; self.was_dragged = False
                self.DRAG_THRESHOLD = AndroidUtilities.dp(self.plugin.DRAG_THRESHOLD_DP)

            def onTouch(self, v, event):
                view = self.plugin.minimized_button if self.is_minimized else self.plugin.overlay_view
                if not view or not self.plugin.window_manager: return False
                
                params = view.getLayoutParams()
                action = event.getAction()
                handle_size = AndroidUtilities.dp(self.plugin.RESIZE_HANDLE_SIZE_DP)
                
                if action == self.plugin.MotionEvent.ACTION_DOWN:
                    self.plugin.initial_touch_x, self.plugin.initial_touch_y = event.getRawX(), event.getRawY()
                    self.plugin.initial_view_x, self.plugin.initial_view_y = params.x, params.y
                    self.plugin.initial_width, self.plugin.initial_height = params.width, params.height
                    self.was_dragged = False
                    
                    if self.is_minimized: self.drag_mode = 1
                    elif event.getX() > view.getWidth() - handle_size and event.getY() > view.getHeight() - handle_size: self.drag_mode = 2
                    else: self.drag_mode = 1
                    return True
                
                elif action == self.plugin.MotionEvent.ACTION_MOVE:
                    dx = event.getRawX() - self.plugin.initial_touch_x
                    dy = event.getRawY() - self.plugin.initial_touch_y
                    
                    if not self.was_dragged and (abs(dx) > self.DRAG_THRESHOLD or abs(dy) > self.DRAG_THRESHOLD):
                        self.was_dragged = True

                    if self.was_dragged:
                        if self.drag_mode == 1:
                            params.x = self.plugin.initial_view_x + int(dx)
                            params.y = self.plugin.initial_view_y + int(dy)
                            self.plugin.window_manager.updateViewLayout(view, params)
                        elif self.drag_mode == 2:
                            min_w, min_h = AndroidUtilities.dp(self.plugin.MIN_WIDTH_DP), AndroidUtilities.dp(self.plugin.MIN_HEIGHT_DP)
                            params.width = max(min_w, self.plugin.initial_width + int(dx))
                            params.height = max(min_h, self.plugin.initial_height + int(dy))
                            self.plugin.window_manager.updateViewLayout(view, params)
                            self.plugin.set_setting("overlay_width", params.width)
                            self.plugin.set_setting("overlay_height", params.height)
                    return True

                elif action == self.plugin.MotionEvent.ACTION_UP:
                    if not self.was_dragged:
                        if self.is_minimized: self.plugin.maximize_overlay()
                    
                    if self.is_minimized: self.plugin.last_minimized_pos = (params.x, params.y)
                    self.drag_mode = 0
                    return True
                return False
        return TouchListener(self, is_minimized_btn)






    def _update_button_labels(self):
        show_labels = self.get_setting("show_button_labels", True)
        try:
            for label in getattr(self, 'button_labels', []):
                if label:
                    label.setVisibility(0 if show_labels else 8)
        except Exception as e:
            pass

    def _apply_log_settings(self):
        try:
            if self.log_text_view:
                font_size = float(self.get_setting("log_font_size", "12"))
                self.log_text_view.setTextSize(font_size)
        except Exception as e:
            pass
        try:
            limit = int(self.get_setting("log_limit", "200"))
            if len(self.full_logs) > limit:
                self.full_logs = self.full_logs[-limit:]
        except Exception as e:
            pass
        try:
            self._filter_and_update_logs()
        except Exception as e:
            pass
