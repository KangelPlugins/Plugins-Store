import datetime
import math
import os
import hashlib
import binascii
import stat
from typing import Dict, List, Tuple

from android_utils import run_on_ui_thread, log
from base_plugin import BasePlugin, MenuItemData, MenuItemType
from client_utils import get_last_fragment, get_account_instance, run_on_queue, PLUGINS_QUEUE
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch

from org.telegram.messenger import AndroidUtilities, LocaleController, R, MessageObject, FileLoader
from org.telegram.tgnet import TLRPC
from android.media import MediaMetadataRetriever, ExifInterface

__id__ = "metadataviewer"
__name__ = "Metadata Viewer"
__version__ = "1.0"
__icon__ = "Auuuuuuuuugh/2"
__author__ = "@yzewe"
__description__ = "Metadata Inspector. Use button in message. Can extract EXIF."
__min_version__ = "11.12.0"

class MetadataUltimate(BasePlugin):
    def __init__(self):
        super().__init__()
        self.lang = "ru" if LocaleController.getInstance().getCurrentLocaleInfo().shortName == "ru" else "en"
        self.strings = {
            "ru": {
                "btn": "Метаданные",
                "loading": "Сбор данных...",
                "no_data": "Данные отсутствуют",
                "back": "Назад",
                "copy_all": "Копировать всё",
                "close": "Закрыть",
                "sec_tg_basic": "Telegram: Основное",
                "sec_tg_attr": "Telegram: Атрибуты",
                "sec_file": "Файловая система",
                "sec_hash": "Контрольные суммы",
                "sec_exif_ifd0": "1. Изображение (IFD0)",
                "sec_exif_sub": "2. Камера (SubIFD)",
                "sec_exif_gps": "3. Геолокация (GPS)",
                "sec_exif_int": "4. Совместимость",
                "sec_exif_maker": "5. Заметки (MakerNotes)",
                "sec_av_gen": "AV: Общее",
                "sec_av_vid": "AV: Видео поток",
                "sec_av_aud": "AV: Аудио поток",
                "sec_av_meta": "AV: Теги",
                "h_ui": "Интерфейс",
                "h_calc": "Вычисления",
                "h_tg": "Telegram Данные",
                "h_fs": "Файл и Хеши",
                "h_exif": "EXIF Группы",
                "h_av": "Медиа Данные",
                "s_empty": "Показывать пустые поля",
                "s_hash_md5": "Считать MD5",
                "s_hash_sha1": "Считать SHA-1",
                "s_hash_sha256": "Считать SHA-256",
                "s_magic": "Magic Bytes (Hex)",
                "s_tg_basic": "Показывать ID и Даты",
                "s_tg_attr": "Атрибуты документа",
                "s_fs_stat": "Статистика файла",
                "s_ifd0": "IFD0 (Разрешение, модель)",
                "s_subifd": "SubIFD (Выдержка, ISO)",
                "s_gps": "GPS Координаты",
                "s_maker": "MakerNotes (Binary)",
                "s_av_base": "Базовое инфо (MIME, Длит)",
                "s_av_vid": "Детали видео (FPS, Rotate)",
                "s_av_aud": "Детали аудио (Hz, Channels)",
                "s_av_tag": "ID3 Теги (Title, Artist)",
                "lbl_dim": "Размеры",
                "lbl_dur": "Длительность",
                "err_dl": "Файл не загружен"
            },
            "en": {
                "btn": "Metadata",
                "loading": "Collecting data...",
                "no_data": "No data available",
                "back": "Back",
                "copy_all": "Copy All",
                "close": "Close",
                "sec_tg_basic": "Telegram: Basic",
                "sec_tg_attr": "Telegram: Attributes",
                "sec_file": "File System",
                "sec_hash": "Checksums",
                "sec_exif_ifd0": "1. Image (IFD0)",
                "sec_exif_sub": "2. Camera (SubIFD)",
                "sec_exif_gps": "3. Location (GPS)",
                "sec_exif_int": "4. Interop",
                "sec_exif_maker": "5. MakerNotes",
                "sec_av_gen": "AV: General",
                "sec_av_vid": "AV: Video Stream",
                "sec_av_aud": "AV: Audio Stream",
                "sec_av_meta": "AV: Tags",
                "h_ui": "Interface",
                "h_calc": "Calculations",
                "h_tg": "Telegram Data",
                "h_fs": "File & Hashes",
                "h_exif": "EXIF Groups",
                "h_av": "Media Data",
                "s_empty": "Show empty fields",
                "s_hash_md5": "Calc MD5",
                "s_hash_sha1": "Calc SHA-1",
                "s_hash_sha256": "Calc SHA-256",
                "s_magic": "Magic Bytes (Hex)",
                "s_tg_basic": "Show IDs & Dates",
                "s_tg_attr": "Document Attributes",
                "s_fs_stat": "File Statistics",
                "s_ifd0": "IFD0 (Res, Model)",
                "s_subifd": "SubIFD (Exp, ISO)",
                "s_gps": "GPS Coordinates",
                "s_maker": "MakerNotes (Binary)",
                "s_av_base": "Basic Info (MIME, Dur)",
                "s_av_vid": "Video Details (FPS, Rotate)",
                "s_av_aud": "Audio Details (Hz, Channels)",
                "s_av_tag": "ID3 Tags (Title, Artist)",
                "lbl_dim": "Dimensions",
                "lbl_dur": "Duration",
                "err_dl": "File not downloaded"
            }
        }

        self.exif_map = {
            "IFD0": [
                "ImageWidth", "ImageLength", "BitsPerSample", "Compression",
                "PhotometricInterpretation", "ImageDescription", "Make", "Model",
                "StripOffsets", "Orientation", "SamplesPerPixel", "RowsPerStrip",
                "StripByteCounts", "XResolution", "YResolution", "PlanarConfiguration",
                "ResolutionUnit", "TransferFunction", "Software", "DateTime",
                "Artist", "WhitePoint", "PrimaryChromaticities", "YCbCrCoefficients",
                "YCbCrSubSampling", "YCbCrPositioning", "ReferenceBlackWhite", "Copyright"
            ],
            "SubIFD": [
                "ExposureTime", "FNumber", "ExposureProgram", "ISOSpeedRatings",
                "SensitivityType", "ExifVersion", "DateTimeOriginal", "DateTimeDigitized",
                "ComponentsConfiguration", "CompressedBitsPerPixel", "ShutterSpeedValue",
                "ApertureValue", "BrightnessValue", "ExposureBiasValue", "MaxApertureValue",
                "SubjectDistance", "MeteringMode", "LightSource", "Flash",
                "FocalLength", "SubjectArea", "MakerNote", "UserComment",
                "SubSecTime", "SubSecTimeOriginal", "SubSecTimeDigitized",
                "FlashpixVersion", "ColorSpace", "PixelXDimension", "PixelYDimension",
                "RelatedSoundFile", "FlashEnergy", "SpatialFrequencyResponse",
                "FocalPlaneXResolution", "FocalPlaneYResolution", "FocalPlaneResolutionUnit",
                "SubjectLocation", "ExposureIndex", "SensingMethod", "FileSource",
                "SceneType", "CFAPattern", "CustomRendered", "ExposureMode",
                "WhiteBalance", "DigitalZoomRatio", "FocalLengthIn35mmFilm",
                "SceneCaptureType", "GainControl", "Contrast", "Saturation",
                "Sharpness", "DeviceSettingDescription", "SubjectDistanceRange",
                "ImageUniqueID", "LensSpecification", "LensMake", "LensModel", "LensSerialNumber"
            ],
            "GPS": [
                "GPSVersionID", "GPSLatitudeRef", "GPSLatitude", "GPSLongitudeRef",
                "GPSLongitude", "GPSAltitudeRef", "GPSAltitude", "GPSTimeStamp",
                "GPSSatellites", "GPSStatus", "GPSMeasureMode", "GPSDOP",
                "GPSSpeedRef", "GPSSpeed", "GPSTrackRef", "GPSTrack",
                "GPSImgDirectionRef", "GPSImgDirection", "GPSMapDatum",
                "GPSDestLatitudeRef", "GPSDestLatitude", "GPSDestLongitudeRef",
                "GPSDestLongitude", "GPSDestBearingRef", "GPSDestBearing",
                "GPSDestDistanceRef", "GPSDestDistance", "GPSProcessingMethod",
                "GPSAreaInformation", "GPSDateStamp", "GPSDifferential"
            ],
            "Interop": [
                "InteroperabilityIndex", "InteroperabilityVersion"
            ]
        }

        self.av_keys = {
            "General": {
                "Title": 7, "MIME Type": 12, "Date": 8, "Duration": 9, 
                "Bitrate": 20, "Writer": 11, "Year": 8, "Location": 23
            },
            "Audio": {
                "Sample Rate": 38, "Channels": 14, "Audio Codec": 12, 
                "Bits Per Sample": 39, "Disc Number": 14, "CD Track Number": 0,
                "Album": 1, "Artist": 2, "Author": 3, "Composer": 4, 
                "Genre": 6, "Compilation": 15
            },
            "Video": {
                "Width": 18, "Height": 19, "Rotation": 24, "Frame Rate": 25,
                "Capture Framerate": 26, "Num Tracks": 10, "Has Audio": 16, 
                "Has Video": 17, "Video Codec": 12, "Color Standard": 35,
                "Color Transfer": 36, "Color Range": 37
            }
        }

    def t(self, key):
        return self.strings.get(self.lang, self.strings["en"]).get(key, key)

    def on_plugin_load(self):
        self.add_menu_item(MenuItemData(
            menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
            text=self.t("btn"),
            icon="msg_info", 
            on_click=self.on_context_click
        ))

    def create_settings(self):
        return [
            Header(text=self.t("h_ui")),
            Switch(key="show_empty", text=self.t("s_empty"), default=False),
            
            Header(text=self.t("h_calc")),
            Switch(key="calc_md5", text=self.t("s_hash_md5"), default=True),
            Switch(key="calc_sha1", text=self.t("s_hash_sha1"), default=False),
            Switch(key="calc_sha256", text=self.t("s_hash_sha256"), default=False),
            Switch(key="show_magic", text=self.t("s_magic"), default=True),
            
            Header(text=self.t("h_tg")),
            Switch(key="show_tg_basic", text=self.t("s_tg_basic"), default=True),
            Switch(key="show_tg_attr", text=self.t("s_tg_attr"), default=True),
            
            Header(text=self.t("h_fs")),
            Switch(key="show_fs_stat", text=self.t("s_fs_stat"), default=True),
            
            Header(text=self.t("h_exif")),
            Switch(key="show_ifd0", text=self.t("s_ifd0"), default=True),
            Switch(key="show_subifd", text=self.t("s_subifd"), default=True),
            Switch(key="show_gps", text=self.t("s_gps"), default=True),
            Switch(key="show_maker", text=self.t("s_maker"), default=False),
            
            Header(text=self.t("h_av")),
            Switch(key="show_av_base", text=self.t("s_av_base"), default=True),
            Switch(key="show_av_vid", text=self.t("s_av_vid"), default=True),
            Switch(key="show_av_aud", text=self.t("s_av_aud"), default=True),
            Switch(key="show_av_tag", text=self.t("s_av_tag"), default=True)
        ]

    def on_context_click(self, context: dict):
        msg = context.get("message")
        if not msg: return
        BulletinHelper.show_simple(self.t("loading"), R.raw.ic_download)
        run_on_queue(lambda: self._worker(msg), PLUGINS_QUEUE)

    def _worker(self, msg):
        try:
            data = self._collect_data(msg)
            run_on_ui_thread(lambda: self._ui_main(data))
        except Exception as e:
            log(f"MetaUlt Error: {e}")

    def _collect_data(self, msg_obj: MessageObject) -> Dict[str, List[Tuple[str, str]]]:
        report = {}
        msg = msg_obj.messageOwner
        
        path = self._get_path(msg_obj)
        is_exist = path and os.path.exists(path)

        if self.get_setting("show_tg_basic", True):
            tg_basic = []
            tg_basic.append(("Message ID", str(msg.id)))
            tg_basic.append(("Date", self._date(msg.date)))
            if msg.edit_date: tg_basic.append(("Edited", self._date(msg.edit_date)))
            if msg.peer_id: tg_basic.append(("Chat ID", self._peer(msg.peer_id)))
            if msg.from_id: tg_basic.append(("Sender ID", self._peer(msg.from_id)))
            if msg.via_bot_id: tg_basic.append(("Via Bot", str(msg.via_bot_id)))
            if msg.views: tg_basic.append(("Views", str(msg.views)))
            if msg.grouped_id: tg_basic.append(("Group ID", str(msg.grouped_id)))
            
            if hasattr(msg, "media") and msg.media:
                t = msg.media.__class__.__name__.replace("TL_messageMedia", "")
                tg_basic.append(("Media Type", t))
                if isinstance(msg.media, TLRPC.TL_messageMediaPhoto):
                     tg_basic.append(("Photo ID", str(msg.media.photo.id)))
                     tg_basic.append(("Has Stickers", str(msg.media.photo.has_stickers)))
                elif isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                     tg_basic.append(("Doc ID", str(msg.media.document.id)))
                     tg_basic.append(("DC", str(msg.media.document.dc_id)))

            report[self.t("sec_tg_basic")] = tg_basic

        if self.get_setting("show_tg_attr", True) and hasattr(msg, "media"):
             tg_attr = []
             m = msg.media
             if isinstance(m, TLRPC.TL_messageMediaDocument):
                 d = m.document
                 tg_attr.append(("MIME", d.mime_type))
                 tg_attr.append(("Size (Server)", self._size(d.size)))
                 if d.attributes:
                     for i in range(d.attributes.size()):
                         a = d.attributes.get(i)
                         if isinstance(a, TLRPC.TL_documentAttributeImageSize):
                             tg_attr.append((f"{self.t('lbl_dim')} (Img)", f"{a.w}x{a.h}"))
                         elif isinstance(a, TLRPC.TL_documentAttributeVideo):
                             tg_attr.append((f"{self.t('lbl_dim')} (Vid)", f"{a.w}x{a.h}"))
                             tg_attr.append((self.t('lbl_dur'), self._dur(a.duration * 1000)))
                             if a.round_message: tg_attr.append(("Type", "Video Note (Round)"))
                             if a.supports_streaming: tg_attr.append(("Streaming", "Yes"))
                             if a.preload_prefix_size > 0: tg_attr.append(("Preload", f"{a.preload_prefix_size}b"))
                         elif isinstance(a, TLRPC.TL_documentAttributeAudio):
                             tg_attr.append((self.t('lbl_dur'), self._dur(a.duration * 1000)))
                             tg_attr.append(("Performer", a.performer if a.performer else "-"))
                             tg_attr.append(("Title", a.title if a.title else "-"))
                             if a.voice: tg_attr.append(("Type", "Voice Message"))
                             if a.waveform: tg_attr.append(("Waveform", f"{len(a.waveform)} bytes"))
                         elif isinstance(a, TLRPC.TL_documentAttributeSticker):
                             tg_attr.append(("Sticker Emoji", a.alt))
                             if a.stickerset:
                                 tg_attr.append(("Set ID", str(a.stickerset.id)))
                                 tg_attr.append(("Set Hash", str(a.stickerset.access_hash)))
                             if a.mask: tg_attr.append(("Type", "Mask"))
                             if a.mask_coords: tg_attr.append(("Mask Coords", f"n={a.mask_coords.n}, x={a.mask_coords.x}, y={a.mask_coords.y}, zoom={a.mask_coords.zoom}"))
                         elif isinstance(a, TLRPC.TL_documentAttributeFilename):
                             tg_attr.append(("Filename", a.file_name))
                         elif isinstance(a, TLRPC.TL_documentAttributeHasStickers):
                             tg_attr.append(("Attached Stickers", "Yes"))
             
             if isinstance(m, TLRPC.TL_messageMediaGeo):
                 tg_attr.append(("Lat", str(m.geo.lat)))
                 tg_attr.append(("Long", str(m.geo._long)))
                 tg_attr.append(("Access Hash", str(m.geo.access_hash)))

             if isinstance(m, TLRPC.TL_messageMediaContact):
                 tg_attr.append(("Phone", m.phone_number))
                 tg_attr.append(("Name", f"{m.first_name} {m.last_name}"))
                 tg_attr.append(("VCard", "Yes" if m.vcard else "No"))

             if isinstance(m, TLRPC.TL_messageMediaPoll):
                 p = m.poll
                 tg_attr.append(("Poll ID", str(p.id)))
                 tg_attr.append(("Question", p.question))
                 tg_attr.append(("Closed", str(p.closed)))
                 tg_attr.append(("Public Voters", str(p.public_voters)))
                 tg_attr.append(("Multiple Choice", str(p.multiple_choice)))
                 tg_attr.append(("Quiz", str(p.quiz)))
                 if m.results:
                     tg_attr.append(("Total Voters", str(m.results.total_voters)))

             if tg_attr: report[self.t("sec_tg_attr")] = tg_attr

        if is_exist and self.get_setting("show_fs_stat", True):
            fs = []
            try:
                st = os.stat(path)
                fs.append(("Path", path))
                fs.append(("File Size", self._size(st.st_size)))
                fs.append(("Permissions", stat.filemode(st.st_mode)))
                fs.append(("Modified", self._date(st.st_mtime)))
                fs.append(("Created", self._date(st.st_ctime)))
                fs.append(("Accessed", self._date(st.st_atime)))
                fs.append(("UID / GID", f"{st.st_uid} / {st.st_gid}"))
                fs.append(("Inode", str(st.st_ino)))
                fs.append(("Device", str(st.st_dev)))
            except Exception as e: fs.append(("Error", str(e)))
            report[self.t("sec_file")] = fs

        if is_exist:
            hashes = []
            sz = os.path.getsize(path)
            limit = 300 * 1024 * 1024
            if sz < limit:
                if self.get_setting("show_magic", True):
                    try:
                        with open(path, 'rb') as f:
                            h = f.read(24)
                            hashes.append(("Magic Bytes", binascii.hexlify(h).decode('utf-8').upper()))
                    except: pass
                if self.get_setting("calc_md5", True): hashes.append(("MD5", self._hash(path, "md5")))
                if self.get_setting("calc_sha1", False): hashes.append(("SHA-1", self._hash(path, "sha1")))
                if self.get_setting("calc_sha256", False): hashes.append(("SHA-256", self._hash(path, "sha256")))
            elif sz >= limit and (self.get_setting("calc_md5", True) or self.get_setting("calc_sha1", False)):
                hashes.append(("Warning", "File too large for hash"))

            if hashes: report[self.t("sec_hash")] = hashes

        if is_exist:
            mime = "unknown"
            if hasattr(msg, "media"):
                if isinstance(msg.media, TLRPC.TL_messageMediaDocument):
                    mime = msg.media.document.mime_type
                elif isinstance(msg.media, TLRPC.TL_messageMediaPhoto):
                    mime = "image/jpeg"
            
            is_img = any(x in mime for x in ["image", "jpeg", "png", "webp"]) or path.lower().endswith((".jpg", ".png", ".webp", ".heic", ".dng"))
            is_av = any(x in mime for x in ["video", "audio", "mp4", "mp3", "ogg", "m4a", "mkv", "wav", "flac"]) or path.lower().endswith((".mp4", ".mp3", ".mkv", ".mov", ".ogg", ".wav", ".opus", ".m4a"))

            if is_img: self._collect_exif(path, report)
            if is_av: self._collect_av(path, report)

        return report

    def _collect_exif(self, path, report):
        try:
            ef = ExifInterface(path)
            show_empty = self.get_setting("show_empty", False)
            
            map_to_sec = {
                "IFD0": (self.t("sec_exif_ifd0"), "show_ifd0"),
                "SubIFD": (self.t("sec_exif_sub"), "show_subifd"),
                "GPS": (self.t("sec_exif_gps"), "show_gps"),
                "Interop": (self.t("sec_exif_int"), "show_subifd") 
            }

            for grp_key, (sec_title, set_key) in map_to_sec.items():
                if self.get_setting(set_key, True):
                    lst = []
                    tags = self.exif_map.get(grp_key, [])
                    for tag in tags:
                        val = ef.getAttribute(tag)
                        if val or show_empty:
                            if tag == "MakerNote" and val:
                                val = f"Binary Data ({len(val)} bytes)"
                            lst.append((tag, val if val else "-"))
                    if lst: report[sec_title] = lst
            
            if self.get_setting("show_maker", False):
                 pass 

        except Exception as e:
            log(f"EXIF Err: {e}")

    def _collect_av(self, path, report):
        mmr = MediaMetadataRetriever()
        try:
            mmr.setDataSource(path)
            
            cats = {
                "General": (self.t("sec_av_gen"), "show_av_base"),
                "Video": (self.t("sec_av_vid"), "show_av_vid"),
                "Audio": (self.t("sec_av_aud"), "show_av_aud")
            }
            
            tags = (self.t("sec_av_meta"), "show_av_tag")
            
            for cat, (sec_title, set_key) in cats.items():
                if self.get_setting(set_key, True):
                    lst = []
                    keys = self.av_keys.get(cat, {})
                    for label, code in keys.items():
                        val = mmr.extractMetadata(code)
                        if val:
                            if label in ["Duration"]: val = self._dur(float(val))
                            if label in ["Bitrate"]: val = f"{int(val)//1000} kbps"
                            if label in ["Sample Rate"]: val = f"{val} Hz"
                            lst.append((label, val))
                    if lst: report[sec_title] = lst
            
            if self.get_setting("show_av_tag", True):
                lst = []
                # Explicit check for ID3-like tags that might be in Audio group but logically are tags
                for k, c in self.av_keys["Audio"].items():
                    if k in ["Title", "Artist", "Album", "Genre", "Composer", "Author", "Writer", "Year", "Compilation", "Disc Number", "CD Track Number"]:
                         val = mmr.extractMetadata(c)
                         if val: lst.append((k, val))
                if lst: report[tags[0]] = lst

        except Exception as e:
            log(f"AV Err: {e}")
        finally:
            try: mmr.release()
            except: pass

    def _ui_main(self, data):
        frag = get_last_fragment()
        if not frag: return
        
        cats = list(data.keys())
        if not cats:
            BulletinHelper.show(self.t("no_data"))
            return

        b = AlertDialogBuilder(frag.getParentActivity())
        b.set_title(self.t("btn"))
        
        def _clk(d, i):
            k = cats[i]
            self._ui_sec(k, data[k], data)

        b.set_items(cats, _clk)
        b.set_negative_button(self.t("close"), None)
        b.show()

    def _ui_sec(self, title, items, all_data):
        frag = get_last_fragment()
        if not frag: return

        b = AlertDialogBuilder(frag.getParentActivity())
        b.set_title(title)
        
        disp = [f"{k}: {v}" for k, v in items]
        
        def _clk(d, i):
            self._copy(items[i][1])

        b.set_items(disp, _clk)
        b.set_positive_button(self.t("back"), lambda _, __: self._ui_main(all_data))
        b.set_neutral_button(self.t("copy_all"), lambda _, __: self._copy(f"=== {title} ===\n" + "\n".join(disp)))
        b.show()

    def _copy(self, txt):
        AndroidUtilities.addToClipboard(txt)
        BulletinHelper.show_copied_to_clipboard()

    def _get_path(self, msg_obj):
        try:
            m = msg_obj.messageOwner
            if hasattr(m, "attachPath") and m.attachPath and os.path.exists(m.attachPath): return str(m.attachPath)
            f = FileLoader.getInstance(get_account_instance().getCurrentAccount()).getPathToMessage(m)
            if f and f.exists(): return str(f.getAbsolutePath())
        except: pass
        return None

    def _peer(self, p):
        if isinstance(p, TLRPC.TL_peerUser): return f"User({p.user_id})"
        if isinstance(p, TLRPC.TL_peerChat): return f"Chat({p.chat_id})"
        if isinstance(p, TLRPC.TL_peerChannel): return f"Channel({p.channel_id})"
        return "Unknown"

    def _hash(self, path, algo):
        try:
            h = hashlib.new(algo)
            with open(path, "rb") as f:
                for chunk in iter(lambda: f.read(65536), b""): h.update(chunk)
            return h.hexdigest()
        except: return "Error"

    def _date(self, ts):
        return datetime.datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S')

    def _size(self, s):
        for u in ['B', 'KB', 'MB', 'GB']:
            if s < 1024: return f"{s:.2f} {u}"
            s /= 1024
        return f"{s:.2f} TB"

    def _dur(self, ms):
        s = int(ms) // 1000
        m, s = divmod(s, 60)
        h, m = divmod(m, 60)
        return f"{h:02d}:{m:02d}:{s:02d}" if h else f"{m:02d}:{s:02d}"