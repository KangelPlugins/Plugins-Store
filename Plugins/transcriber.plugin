__id__ = "whisper_transcribe"
__name__ = "Transcriber"
__description__ = "Replaces Telegram's transcription service with free state-of-the-art alternatives."
__author__ = "@ginqusPlugins"
__version__ = "2.2.0"
__icon__ = "ginqusExteraPlugins/1"
__min_version__ = "11.12.0"


import concurrent.futures
import requests
import base64
import time
from client_utils import run_on_queue, get_last_fragment, get_messages_controller
from base_plugin import BasePlugin, MethodReplacement, MethodHook, MenuItemData, MenuItemType
from hook_utils import find_class, get_private_field, set_private_field
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity  # type: ignore
from ui.settings import Header, Input, Text, Selector, Switch
from com.exteragram.messenger.plugins import PluginsController  # type: ignore
from android_utils import run_on_ui_thread, log
from java.util import HashMap, Objects, Locale  # type: ignore
from org.telegram.messenger import R as R_tg  # type: ignore
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from typing import Dict, Any, Optional
from android.content import Intent  # type: ignore
from android.net import Uri  # type: ignore

TRANSCRIPTION_EXECUTOR = concurrent.futures.ThreadPoolExecutor()
MODELS = ["Universal-2 (AssemblyAI)", "Nova-3 (Deepgram)", "Voxtral (Mistral)", "Gemini Flash Latest (Google)"]
DEFAULT_PROMPT = """Please produce a verbatim transcript of the audio. Follow these instructions:

1. Transcribe exactly what is spoken, word for word.
2. Include all filler words (e.g., um, uh, you know, like), hesitations, repeated words, and any self-corrections.
3. Do not correct grammar or wording â€” leave speech errors unchanged.
4. If you don't detect any speech, return "..." and nothing else.

Return the transcript as plain, unedited text."""
DEFAULT_PROMPT_DIARIZATION = """Please produce a verbatim transcript of the audio. Follow these instructions:

1. Transcribe exactly what is spoken, word for word.
2. Include all filler words (e.g., um, uh, you know, like), hesitations, repeated words, and any self-corrections.
3. Do not correct grammar or wording â€” leave speech errors unchanged.
4. If you don't detect any speech, return "..." and nothing else.
5. If the audio contains a dialogue between multiple speakers, label each speaker with a letter (A, B, C, etc.) and format each speaker's utterance on a new line like this:
   A: [speaker A's speech]
   B: [speaker B's speech]
   A: [speaker A's speech]

Return the transcript as plain, unedited text."""


class LocalizationManager:  # Credits: Command List plugin by @mihailkotovski
    strings = {
        "en": {
            "header_settings": "Plugin settings",
            "header_warning": "Warning",
            "header_info": "Information",
            "header_other": "Other",
            "header_token": "Token",
            "settings_model": "Model",
            "settings_separate_speakers": "Separate speakers",
            "settings_separate_speakers_subtext": "Labels each speaker in the dialog (A, B, C, etc.)",
            "settings_convert_to_audio": "Send audio only",
            "settings_convert_to_audio_subtext": "Extracts audio from video messages, speeding up the upload process when on slow internet.",
            "settings_custom_prompt": "Prompt",
            "settings_custom_prompt_subtext": "Leave blank to use the default prompt.",
            "settings_thinking_mode": "Thinking mode",
            "settings_thinking_mode_subtext": "The model thinks for a while to improve the quality of the transcription.",
            "warning_mistral_phone": "You need a phone number to get the Mistral token.",
            "warning_gemini_vpn": "Gemini isn't available in Russia. I recommend setting up a DNS server (e.g. xbox-dns.ru or dns.malw.link)",
            "warning_deepgram_vpn": "If you encounter problems with signing up, try enabling VPN.",
            "token_token": "Token",
            "token_get_token": "Get token",
            "info_usage": "Plugin usage",
            "info_model_choice": "Which model do I choose?",
            "info_pricing": "Pricing",
            "pricing_assemblyai": "Free up to 185 hours total, then $0.15/hour.\n\nhttps://www.assemblyai.com/pricing",
            "pricing_deepgram": "Free up to ~300 hours total, then $4.8/hour.\n\nhttps://deepgram.com/pricing",
            "pricing_mistral": "Free.\n\nhttps://mistral.ai/pricing",
            "pricing_gemini": "Free. The limit of free requests per day varies depending on the server load.\n\nhttps://ai.google.dev/gemini-api/docs/pricing",
            "other_open_channel": "Open channel",
            "other_debug_logs": "Enable debugging",
            "alert_close": "Close",
            "alert_cancel": "Cancel",
            "alert_open_pricing_page": "Open pricing",
            "alert_model_choice": """
ð—¨ð—»ð—¶ð˜ƒð—²ð—¿ð˜€ð—®ð—¹-ðŸ® (ð—”ð˜€ð˜€ð—²ð—ºð—¯ð—¹ð˜†ð—”ð—œ):
  - Speed: ðŸ¥‰ 4 sec. average
  - Quality: ðŸ¥‡ excellent
  - Diarization quality: ðŸ¥ˆ average

ð—¡ð—¼ð˜ƒð—®-ðŸ¯ (ð——ð—²ð—²ð—½ð—´ð—¿ð—®ð—º):
  - Speed: ðŸ¥‡ 1 sec. average
  - Quality: ðŸ¥ˆ average
  - Diarization quality: ðŸ¥‰ poor

ð—©ð—¼ð˜…ð˜ð—¿ð—®ð—¹ (ð— ð—¶ð˜€ð˜ð—¿ð—®ð—¹):
  - Speed: ðŸ¥ˆ 2 sec. average
  - Quality: ðŸ¥ˆ average
  - Diarization quality: âŒ none

ð—šð—²ð—ºð—¶ð—»ð—¶ ð—™ð—¹ð—®ð˜€ð—µ ð—Ÿð—®ð˜ð—²ð˜€ð˜ (ð—šð—¼ð—¼ð—´ð—¹ð—²):
  - Speed: ðŸ¥ˆ 2 sec. average
  - Quality: ðŸ¥‡ excellent
  - Diarization quality: ðŸ¥‡ excellent


* Speed results are highly dependent on ISP, internet speed, and your geolocation.

** Speed tests were conducted on Google Colab to rule out the influence of poor internet connection.""",
            "alert_model_choice_title": "Model choice",
            "alert_usage_title": "Usage",
            "alert_usage": "To transcribe an audio/video message, just tap the transcribe button next to it. No commands needed.",
            "alert_title_error": "Error",
            "alert_copy": "Copy",
            "error_get_audio_path": "Failed to get audio path: ",
            "error_transcribing": "Transcription error: ",
            "error_no_token": "Please specify your token in plugin settings.",
            "error_load_file_timeout": "Failed to download file: timed out.",
            "error_audio_not_found": "Video stream doesn't have an audio track.",
            "error_extraction": "Error extracting audio: ",
            "error_upload_file": "Failed to upload file",
            "error_start_transcription": "Failed to start transcription",
            "error_timed_out": "Timed out.",
            "error_message_not_voice": "This isn't an audio/video message!",
            "response": "Response",
            "menu_clear_transcription": "Clear transcription text",
            "menu_transcribe_with_different_model": "Transcribe with a different model",
            "bulletin_reopen_chat": "Transcription text cleared. Please reopen the chat.",
            "bulletin_transcribing": "Transcribing...",
            "bulletin_open_settings": "Open settings",
            "bulletin_view_error": "View error",
            "bulletin_copied_to_clipboard": "Copied to clipboard",
            "bulletin_dns_recommendation": "I recommend setting up a DNS server (e.g. xbox-dns.ru or dns.malw.link)",
        },
        "ru": {
            "header_settings": "ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°",
            "header_warning": "ÐŸÑ€ÐµÐ´ÑƒÐ¿Ñ€ÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ",
            "header_info": "Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ",
            "header_other": "Ð”Ñ€ÑƒÐ³Ð¾Ðµ",
            "header_token": "Ð¢Ð¾ÐºÐµÐ½",
            "settings_model": "ÐœÐ¾Ð´ÐµÐ»ÑŒ",
            "settings_separate_speakers": "Ð Ð°Ð·Ð´ÐµÐ»ÑÑ‚ÑŒ Ð³Ð¾Ð²Ð¾Ñ€ÑÑ‰Ð¸Ñ…",
            "settings_separate_speakers_subtext": "ÐŸÐ¾Ð¼ÐµÑ‡Ð°ÐµÑ‚ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³Ð¾Ð²Ð¾Ñ€ÑÑ‰ÐµÐ³Ð¾ Ð² Ð´Ð¸Ð°Ð»Ð¾Ð³Ðµ (A, B, C Ð¸ Ñ‚.Ð´.)",
            "settings_convert_to_audio": "ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð°ÑƒÐ´Ð¸Ð¾",
            "settings_convert_to_audio_subtext": "ÐšÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² Ð°ÑƒÐ´Ð¸Ð¾, ÑƒÑÐºÐ¾Ñ€ÑÑ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÑƒ Ð¿Ñ€Ð¸ Ð¼ÐµÐ´Ð»ÐµÐ½Ð½Ð¾Ð¼ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ðµ.",
            "settings_custom_prompt": "ÐŸÑ€Ð¾Ð¼Ð¿Ñ‚",
            "settings_custom_prompt_subtext": "ÐžÑÑ‚Ð°Ð²ÑŒÑ‚Ðµ Ð¿ÑƒÑÑ‚Ñ‹Ð¼, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð¼Ð¿Ñ‚ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ.",
            "settings_thinking_mode": "Ð ÐµÐ¶Ð¸Ð¼ Ð¼Ñ‹ÑˆÐ»ÐµÐ½Ð¸Ñ",
            "settings_thinking_mode_subtext": "ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð´ÑƒÐ¼Ð°ÐµÑ‚ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ»ÑƒÑ‡ÑˆÐ¸Ñ‚ÑŒ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸.",
            "warning_mistral_phone": "Ð”Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ñ‚Ð¾ÐºÐµÐ½Ð° Mistral Ð½ÑƒÐ¶ÐµÐ½ Ð½Ð¾Ð¼ÐµÑ€ Ñ‚ÐµÐ»ÐµÑ„Ð¾Ð½Ð°. ÐŸÐ¾Ð´Ð¾Ð¹Ð´ÐµÑ‚ Ð¸ Ñ€Ð¾ÑÑÐ¸Ð¹ÑÐºÐ¸Ð¹.",
            "warning_gemini_vpn": "Gemini Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð² Ð Ð¾ÑÑÐ¸Ð¸. Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÑŽ Ð¿Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ DNS (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, xbox-dns.ru Ð¸Ð»Ð¸ dns.malw.link)",
            "warning_deepgram_vpn": "Ð•ÑÐ»Ð¸ Ð²Ð¾Ð·Ð½Ð¸ÐºÐ½ÑƒÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸ÐµÐ¹, Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ VPN.",
            "token_token": "Ð¢Ð¾ÐºÐµÐ½",
            "token_get_token": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚Ð¾ÐºÐµÐ½",
            "info_usage": "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°",
            "info_model_choice": "ÐšÐ°ÐºÑƒÑŽ Ð¼Ð¾Ð´ÐµÐ»ÑŒ Ð²Ñ‹Ð±Ñ€Ð°Ñ‚ÑŒ?",
            "info_pricing": "Ð¡Ñ‚Ð¾Ð¸Ð¼Ð¾ÑÑ‚ÑŒ",
            "pricing_assemblyai": "Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾ Ð¿ÐµÑ€Ð²Ñ‹Ðµ 185 Ñ‡Ð°ÑÐ¾Ð² Ð°ÑƒÐ´Ð¸Ð¾, Ð·Ð°Ñ‚ÐµÐ¼ 0,15$/Ñ‡Ð°Ñ.\n\nhttps://www.assemblyai.com/pricing",
            "pricing_deepgram": "Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾ Ð¿ÐµÑ€Ð²Ñ‹Ðµ ~300 Ñ‡Ð°ÑÐ¾Ð² Ð°ÑƒÐ´Ð¸Ð¾, Ð·Ð°Ñ‚ÐµÐ¼ 4,8$/Ñ‡Ð°Ñ.\n\nhttps://deepgram.com/pricing",
            "pricing_mistral": "Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾.\n\nhttps://mistral.ai/pricing",
            "pricing_gemini": (
                "Ð‘ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ð¾. Ð›Ð¸Ð¼Ð¸Ñ‚ Ð±ÐµÑÐ¿Ð»Ð°Ñ‚Ð½Ñ‹Ñ… Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð² Ð² Ð´ÐµÐ½ÑŒ Ð¼ÐµÐ½ÑÐµÑ‚ÑÑ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚Ð¸ Ð¾Ñ‚ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ñ‹.\n\nhttps://ai.google.dev/gemini-api/docs/pricing"
            ),
            "other_open_channel": "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÐºÐ°Ð½Ð°Ð»",
            "other_debug_logs": "Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð¾Ñ‚Ð»Ð°Ð´ÐºÑƒ",
            "alert_close": "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ",
            "alert_cancel": "ÐžÑ‚Ð¼ÐµÐ½Ð°",
            "alert_open_pricing_page": "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ",
            "alert_model_choice": """
ð—¨ð—»ð—¶ð˜ƒð—²ð—¿ð˜€ð—®ð—¹-ðŸ® (ð—”ð˜€ð˜€ð—²ð—ºð—¯ð—¹ð˜†ð—”ð—œ):
  â€¢ Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ: ðŸ¥‰ 4 ÑÐµÐº. Ð² ÑÑ€ÐµÐ´Ð½ÐµÐ¼
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾: ðŸ¥‡ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ð¾Ðµ
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð¸Ð°Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: ðŸ¥ˆ ÑÑ€ÐµÐ´Ð½ÐµÐµ

ð—¡ð—¼ð˜ƒð—®-ðŸ¯ (ð——ð—²ð—²ð—½ð—´ð—¿ð—®ð—º):
  â€¢ Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ: ðŸ¥‡ 1 ÑÐµÐº. Ð² ÑÑ€ÐµÐ´Ð½ÐµÐ¼
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾: ðŸ¥ˆ ÑÑ€ÐµÐ´Ð½ÐµÐµ
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð¸Ð°Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: ðŸ¥‰ Ð¿Ð»Ð¾Ñ…Ð¾Ðµ

ð—©ð—¼ð˜…ð˜ð—¿ð—®ð—¹ (ð— ð—¶ð˜€ð˜ð—¿ð—®ð—¹):
  â€¢ Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ: ðŸ¥ˆ 2 ÑÐµÐº. Ð² ÑÑ€ÐµÐ´Ð½ÐµÐ¼
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾: ðŸ¥ˆ ÑÑ€ÐµÐ´Ð½ÐµÐµ
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð¸Ð°Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: âŒ Ð½ÐµÑ‚

ð—šð—²ð—ºð—¶ð—»ð—¶ ð—™ð—¹ð—®ð˜€ð—µ ð—Ÿð—®ð˜ð—²ð˜€ð˜ (ð—šð—¼ð—¼ð—´ð—¹ð—²):
  â€¢ Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ: ðŸ¥ˆ 2 ÑÐµÐº. Ð² ÑÑ€ÐµÐ´Ð½ÐµÐ¼
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾: ðŸ¥‡ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ð¾Ðµ
  â€¢ ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð¸Ð°Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: ðŸ¥‡ Ð¾Ñ‚Ð»Ð¸Ñ‡Ð½Ð¾Ðµ


* Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ ÑÐºÐ¾Ñ€Ð¾ÑÑ‚Ð¸ ÑÐ¸Ð»ÑŒÐ½Ð¾ Ð·Ð°Ð²Ð¸ÑÑÑ‚ Ð¾Ñ‚ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð°, ÑÐºÐ¾Ñ€Ð¾ÑÑ‚Ð¸ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð°, Ð° Ñ‚Ð°ÐºÐ¶Ðµ Ð¼ÐµÑÑ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ (Ñ VPN Deepgram *Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ-Ñ‚Ð¾* Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð±Ñ‹ÑÑ‚Ñ€ÐµÐµ...)

** Ð¢ÐµÑÑ‚Ñ‹ ÑÐºÐ¾Ñ€Ð¾ÑÑ‚Ð¸ Ð¿Ñ€Ð¾Ð²Ð¾Ð´Ð¸Ð»Ð¸ÑÑŒ Ð½Ð° Google Colab, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¸ÑÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð²Ð»Ð¸ÑÐ½Ð¸Ðµ Ð¿Ð»Ð¾Ñ…Ð¾Ð³Ð¾ Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚Ð°.""",
            "alert_model_choice_title": "Ð’Ñ‹Ð±Ð¾Ñ€ Ð¼Ð¾Ð´ÐµÐ»Ð¸",
            "alert_usage_title": "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ",
            "alert_usage": "Ð§Ñ‚Ð¾Ð±Ñ‹ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð°ÑƒÐ´Ð¸Ð¾/Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ, Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÑƒ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸ Ñ€ÑÐ´Ð¾Ð¼ Ñ Ð½Ð¸Ð¼. ÐÐ¸ÐºÐ°ÐºÐ¸Ñ… ÐºÐ¾Ð¼Ð°Ð½Ð´.",
            "alert_title_error": "ÐžÑˆÐ¸Ð±ÐºÐ°",
            "alert_copy": "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ",
            "error_get_audio_path": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ð¸ Ð°ÑƒÐ´Ð¸Ð¾Ñ„Ð°Ð¹Ð»Ð°: ",
            "error_transcribing": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐµ: ",
            "error_no_token": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, ÑƒÐºÐ°Ð¶Ð¸Ñ‚Ðµ Ñ‚Ð¾ÐºÐµÐ½ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ… Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°.",
            "error_load_file_timeout": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð»: Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¸ÑÑ‚ÐµÐºÐ»Ð¾.",
            "error_audio_not_found": "Ð’Ð¸Ð´ÐµÐ¾ Ð½Ðµ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð°ÑƒÐ´Ð¸Ð¾Ð´Ð¾Ñ€Ð¾Ð¶ÐºÐ¸.",
            "error_extraction": "ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÐºÐ¾Ð½Ð²ÐµÑ€Ñ‚Ð°Ñ†Ð¸Ð¸ Ð²Ð¸Ð´ÐµÐ¾ Ð² Ð°ÑƒÐ´Ð¸Ð¾: ",
            "error_upload_file": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ñ„Ð°Ð¹Ð» Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€",
            "error_start_transcription": "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð½Ð°Ñ‡Ð°Ñ‚ÑŒ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÑƒ",
            "error_timed_out": "Ð’Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¸ÑÑ‚ÐµÐºÐ»Ð¾.",
            "error_message_not_voice": "Ð­Ñ‚Ð¾ Ð½Ðµ Ð°ÑƒÐ´Ð¸Ð¾/Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ!",
            "response": "ÐžÑ‚Ð²ÐµÑ‚",
            "menu_clear_transcription": "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ñ‚ÐµÐºÑÑ‚ Ñ€Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ¸",
            "menu_transcribe_with_different_model": "Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð¼Ð¾Ð´ÐµÐ»ÑŒÑŽ",
            "bulletin_reopen_chat": "Ð¢ÐµÐºÑÑ‚ Ð¾Ñ‡Ð¸Ñ‰ÐµÐ½. ÐŸÐµÑ€ÐµÐ·Ð°Ð¹Ð´Ð¸Ñ‚Ðµ Ð² Ñ‡Ð°Ñ‚, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ.",
            "bulletin_transcribing": "Ð Ð°ÑÑˆÐ¸Ñ„Ñ€Ð¾Ð²ÐºÐ°...",
            "bulletin_open_settings": "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸",
            "bulletin_view_error": "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ",
            "bulletin_copied_to_clipboard": "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°",
            "bulletin_dns_recommendation": "Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÑŽ Ð¿Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ DNS (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, xbox-dns.ru Ð¸Ð»Ð¸ dns.malw.link)",
        },
    }

    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.language = self.language if self.language in self.strings else "en"

    def get_string(self, key):
        return self.strings[self.language].get(key, self.strings["en"].get(key, key))


localization = LocalizationManager()


class TestPlugin(BasePlugin):
    def on_plugin_load(self):
        TranscribeButton = find_class("org.telegram.ui.Components.TranscribeButton")
        ChatMessageCell = find_class("org.telegram.ui.Cells.ChatMessageCell")

        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=localization.get_string("menu_clear_transcription"),
                on_click=self.clear_transcription,
                icon="menu_clear_cache",
            )
        )
        self.add_menu_item(
            MenuItemData(
                menu_type=MenuItemType.MESSAGE_CONTEXT_MENU,
                text=localization.get_string("menu_transcribe_with_different_model"),
                on_click=self.transcribe_with_different_model,
                icon="msg_retry",
            )
        )

        if TranscribeButton is not None:
            on_tap_method = TranscribeButton.getClass().getDeclaredMethod("onTap")
            update_waveform_method = ChatMessageCell.getClass().getDeclaredMethod("updateWaveform")
        self.hook_method(on_tap_method, self.CreateTranscribeButtonHook(self))
        self.hook_method(update_waveform_method, self.CreateUpdateWaveformHook())

        return super().on_plugin_load()

    def clear_transcription(self, context: Dict[str, Any]):
        messageObject = context.get("message")

        if not messageObject.type == 2 and not messageObject == 5:
            run_on_ui_thread(lambda: BulletinHelper.show_error(localization.get_string("error_message_not_voice")))
            return

        TranscribeButton = find_class("org.telegram.ui.Components.TranscribeButton")
        NotificationCenter = find_class("org.telegram.messenger.NotificationCenter")

        account = messageObject.currentAccount
        messageId = messageObject.messageOwner.id

        finalId = messageId
        finalText = None

        TranscribeButton.finishTranscription(messageObject, finalId, finalText)
        run_on_ui_thread(
            lambda: NotificationCenter.getInstance(account).postNotificationName(
                NotificationCenter.voiceTranscriptionUpdate, messageObject, finalId, f"[{localization.get_string('bulletin_reopen_chat')}]", False, True
            )
        )
        run_on_ui_thread(lambda: BulletinHelper.show_info(localization.get_string("bulletin_reopen_chat")))

    def transcribe_with_different_model(self, context: Dict[str, Any]):
        messageObject = context.get("message")

        if not messageObject.type == 2 and not messageObject == 5:
            run_on_ui_thread(lambda: BulletinHelper.show_error(localization.get_string("error_message_not_voice")))
            return

        current_fragment = get_last_fragment()
        activity = current_fragment.getParentActivity()

        def on_item_click(bld: AlertDialogBuilder, which: int):
            messageObject = context.get("message")
            if not messageObject:
                return

            model = self.get_setting("model", 0)
            if model == 0:
                token = self.get_setting("token_assemblyai", "")
            elif model == 1:
                token = self.get_setting("token_deepgram", "")
            elif model == 2:
                token = self.get_setting("token_mistral", "")
            elif model == 3:
                token = self.get_setting("token_gemini", "")

            if token == "":
                run_on_ui_thread(lambda: BulletinHelper.show_error(localization.get_string("error_no_token")))
                return

            hook = self.CreateTranscribeButtonHook(self)
            hook.start_transcription_logic(messageObject, None, which)

            run_on_ui_thread(lambda: BulletinHelper.show_info(localization.get_string("bulletin_transcribing")))

            bld.dismiss()

        item_builder = AlertDialogBuilder(activity)
        item_builder.set_title(localization.get_string("alert_model_choice_title"))
        item_builder.set_items(MODELS, on_item_click)
        item_builder.set_negative_button(localization.get_string("alert_cancel"), lambda b, w: b.dismiss())
        item_builder.show()

    def open_pricing_alert(self, view):
        try:
            model = self.get_setting("model", 0)

            if model == 0:
                text = localization.get_string("pricing_assemblyai")
            elif model == 1:
                text = localization.get_string("pricing_deepgram")
            elif model == 2:
                text = localization.get_string("pricing_mistral")
            elif model == 3:
                text = localization.get_string("pricing_gemini")
            title = MODELS[model]

            current_fragment = get_last_fragment()
            if not current_fragment or not current_fragment.getParentActivity():
                return
            context = current_fragment.getParentActivity()
            builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(title)
            builder.set_message(text)
            builder.set_positive_button(localization.get_string("alert_close"), lambda b, w: b.dismiss())
            builder.set_neutral_button(localization.get_string("alert_open_pricing_page"), self.open_pricing_page)
            builder.show()
        except Exception as e:
            log(f"[TRANSCRIBER] Error showing pricing alert: {e}")

    def open_model_choice_alert(self, view):
        try:
            current_fragment = get_last_fragment()
            if not current_fragment or not current_fragment.getParentActivity():
                return
            context = current_fragment.getParentActivity()
            builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(localization.get_string("alert_model_choice_title"))
            builder.set_message(localization.get_string("alert_model_choice"))
            builder.set_positive_button(localization.get_string("alert_close"), lambda b, w: b.dismiss())
            builder.show()
        except Exception as e:
            log(f"[TRANSCRIBER] Error showing model choice alert: {e}")

    def open_usage_alert(self, view):
        try:
            current_fragment = get_last_fragment()
            if not current_fragment or not current_fragment.getParentActivity():
                return
            context = current_fragment.getParentActivity()
            builder = AlertDialogBuilder(context, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title(localization.get_string("alert_usage_title"))
            builder.set_message(localization.get_string("alert_usage"))
            builder.set_positive_button(localization.get_string("alert_close"), lambda b, w: b.dismiss())
            builder.show()
        except Exception as e:
            log(f"[TRANSCRIBER] Error showing usage alert: {e}")

    def open_pricing_page(self, view, idk):
        model = self.get_setting("model", 0)

        current_fragment = get_last_fragment()
        if not current_fragment or not current_fragment.getParentActivity():
            return
        context = current_fragment.getParentActivity()
        if model == 0:
            uri = "https://www.assemblyai.com/pricing"
        elif model == 1:
            uri = "https://deepgram.com/pricing"
        elif model == 2:
            uri = "https://mistral.ai/pricing"
        elif model == 3:
            uri = "https://ai.google.dev/gemini-api/docs/pricing"
        intent = Intent(Intent.ACTION_VIEW, Uri.parse(uri))
        context.startActivity(intent)

    def open_token_page(self, view):
        model = self.get_setting("model", 0)

        current_fragment = get_last_fragment()
        if not current_fragment or not current_fragment.getParentActivity():
            return

        if model == 0:
            uri = "https://t.me/ginqusPlugins/8"
        elif model == 1:
            uri = "https://t.me/ginqusPlugins/9"
        elif model == 2:
            uri = "https://t.me/ginqusPlugins/10"
        elif model == 3:
            uri = "https://t.me/ginqusPlugins/11"

        Browser = find_class("org.telegram.messenger.browser.Browser")
        LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
        activity = LaunchActivity.instance
        if activity:
            Browser.openUrl(activity, Uri.parse(uri))

    def open_channel(self, view):
        mc = get_messages_controller()
        current_fragment = get_last_fragment()
        if not current_fragment or not current_fragment.getParentActivity():
            return
        if mc and hasattr(mc, "openByUserName"):
            mc.openByUserName("ginqusPlugins", current_fragment, 0)

    def create_settings(self):
        model = self.get_setting("model", 0)
        settings = [
            Header(text=localization.get_string("header_settings")),
            Selector(
                key="model",
                text=localization.get_string("settings_model"),
                default=1,
                items=MODELS,
                icon="menu_feature_voice",
            ),
            Switch(
                key="convert_to_audio",
                text=localization.get_string("settings_convert_to_audio"),
                default=True,
                subtext=localization.get_string("settings_convert_to_audio_subtext"),
                icon="msg_speed",
            ),
        ]
        if not model == 2:
            settings.append(
                Switch(
                    key="separate_speakers",
                    text=localization.get_string("settings_separate_speakers"),
                    default=True,
                    subtext=localization.get_string("settings_separate_speakers_subtext"),
                    icon="msg_groups",
                )
            )

        def _set_prompt_to_default_if_empty(text):
            if self.get_setting("custom_prompt") == "":
                self.set_setting("custom_prompt", DEFAULT_PROMPT)
            if self.get_setting("custom_prompt_diarization") == "":
                self.set_setting("custom_prompt_diarization", DEFAULT_PROMPT_DIARIZATION)

        if model == 3:
            if self.get_setting("separate_speakers"):
                settings.extend([
                    Switch(
                        key="thinking_mode",
                        text=localization.get_string("settings_thinking_mode"),
                        default=False,
                        subtext=localization.get_string("settings_thinking_mode_subtext"),
                        icon="msg_emoji_objects",
                    ),
                    Input(
                        key="custom_prompt_diarization",
                        text=localization.get_string("settings_custom_prompt"),
                        default=DEFAULT_PROMPT_DIARIZATION,
                        subtext=localization.get_string("settings_custom_prompt_subtext"),
                        on_change=_set_prompt_to_default_if_empty,
                        icon="msg_message_s",
                    ),
                ])
            else:
                settings.append(
                    Input(
                        key="custom_prompt",
                        text=localization.get_string("settings_custom_prompt"),
                        default=DEFAULT_PROMPT,
                        subtext=localization.get_string("settings_custom_prompt_subtext"),
                        on_change=_set_prompt_to_default_if_empty,
                        icon="msg_message_s",
                    )
                )

        if model == 1 and Locale.getDefault().getLanguage() == "ru":
            settings.extend([
                Header(text=localization.get_string("header_warning")),
                Text(
                    text=localization.get_string("warning_deepgram_vpn"),
                    icon="msg_report",
                    accent=True,
                    on_click=lambda _: run_on_ui_thread(BulletinHelper.show_info(localization.get_string("warning_deepgram_vpn"))),
                ),
            ])
        elif model == 2:
            settings.extend([
                Header(text=localization.get_string("header_warning")),
                Text(
                    text=localization.get_string("warning_mistral_phone"),
                    icon="msg_report",
                    accent=True,
                    on_click=lambda _: run_on_ui_thread(BulletinHelper.show_info(localization.get_string("warning_mistral_phone"))),
                ),
            ])
        elif model == 3 and Locale.getDefault().getLanguage() == "ru":
            settings.extend([
                Header(text=localization.get_string("header_warning")),
                Text(
                    text=localization.get_string("warning_gemini_vpn"),
                    icon="msg_report",
                    accent=True,
                    on_click=lambda _: run_on_ui_thread(BulletinHelper.show_info(localization.get_string("bulletin_dns_recommendation"))),
                ),
            ])

        settings.append(Header(text=localization.get_string("header_token")))
        if model == 0:
            settings.extend([
                Input(
                    key="token_assemblyai",
                    text=localization.get_string("token_token"),
                    icon="menu_privacy" if len(self.get_setting("token_assemblyai", "")) > 0 else "menu_unlock",
                ),
                Text(
                    text=localization.get_string("token_get_token"),
                    icon="msg_openin",
                    on_click=self.open_token_page,
                    red=len(self.get_setting("token_assemblyai", "")) <= 0,
                ),
            ])
        elif model == 1:
            settings.extend([
                Input(
                    key="token_deepgram",
                    text=localization.get_string("token_token"),
                    icon="menu_privacy" if len(self.get_setting("token_deepgram", "")) > 0 else "menu_unlock",
                ),
                Text(
                    text=localization.get_string("token_get_token"),
                    icon="msg_openin",
                    on_click=self.open_token_page,
                    red=len(self.get_setting("token_deepgram", "")) <= 0,
                ),
            ])
        elif model == 2:
            settings.extend([
                Input(
                    key="token_mistral",
                    text=localization.get_string("token_token"),
                    icon="menu_privacy" if len(self.get_setting("token_mistral", "")) > 0 else "menu_unlock",
                ),
                Text(
                    text=localization.get_string("token_get_token"),
                    icon="msg_openin",
                    on_click=self.open_token_page,
                    red=len(self.get_setting("token_mistral", "")) <= 0,
                ),
            ])
        elif model == 3:
            settings.extend([
                Input(
                    key="token_gemini",
                    text=localization.get_string("token_token"),
                    icon="menu_privacy" if len(self.get_setting("token_gemini", "")) > 0 else "menu_unlock",
                ),
                Text(
                    text=localization.get_string("token_get_token"),
                    icon="msg_openin",
                    on_click=self.open_token_page,
                    red=len(self.get_setting("token_gemini", "")) <= 0,
                ),
            ])

        settings.extend([
            Header(text=localization.get_string("header_info")),
            Text(text=localization.get_string("info_model_choice"), icon="msg_replace", on_click=self.open_model_choice_alert),
            Text(text=localization.get_string("info_usage"), icon="msg_help", on_click=self.open_usage_alert),
            Text(text=localization.get_string("info_pricing"), icon="menu_feature_paid", on_click=self.open_pricing_alert),
            Header(text=localization.get_string("header_other")),
            Text(text=localization.get_string("other_open_channel"), icon="msg_discuss", on_click=self.open_channel, accent=True),
            # Switch(key="debugging", text=localization.get_string("other_debug_logs"), icon="msg_log", default=False),
        ])
        return settings

    class CreateTranscribeButtonHook(MethodReplacement):
        def __init__(self, plugin_instance):
            super().__init__()
            self.plugin = plugin_instance

        def replace_hooked_method(self, param):
            self.onTap(param)

        def debug_log(self, text: str):
            if self.plugin.get_setting("debugging"):
                log(f"[DEBUG] {text}")

        # The logic is mostly identical to TranscribeButton.java but with minor changes
        def onTap(self, param):
            self.debug_log("[TRANSCRIBER] onTap() called")

            this = param.thisObject

            parent = get_private_field(this, "parent")

            shouldBeOpen = get_private_field(this, "shouldBeOpen")
            loading = get_private_field(this, "loading")
            selectorDrawable = get_private_field(this, "selectorDrawable")

            RippleDrawable = find_class("android.graphics.drawable.RippleDrawable")
            StateSet = find_class("android.util.StateSet")

            if parent == None:
                return
            set_private_field(this, "clickedToOpen", False)
            processClick = not shouldBeOpen
            toOpen = not shouldBeOpen
            if not shouldBeOpen:
                processClick = not loading
                this.setLoading(True, True)
            else:
                processClick = True
                this.setOpen(False, True)
                this.setLoading(False, True)
            if not RippleDrawable is None and isinstance(selectorDrawable, RippleDrawable):
                try:
                    selectorDrawable.setState(StateSet.NOTHING)
                    parent.invalidate()
                except:
                    pass
            set_private_field(this, "pressed", False)
            if processClick:
                self.debug_log("[TRANSCRIBER] processClick is True")
                if toOpen:
                    set_private_field(this, "clickedToOpen", True)

                self.transcribePressed(param, parent.getMessageObject(), toOpen)

        def open_settings(self):
            # Credits: CactusLib plugin by @chillden4ik
            def _open_settings():
                get_last_fragment().presentFragment(PluginSettingsActivity(PluginsController.getInstance().plugins.get(__id__)))

            run_on_ui_thread(_open_settings)

        def view_error(self, error: str):
            current_fragment = get_last_fragment()
            if not current_fragment:
                self.debug_log("Cannot show dialog, no current fragment.")
                return

            activity = current_fragment.getParentActivity()
            if not activity:
                self.debug_log("Cannot show dialog, no parent activity.")
                return

            builder = AlertDialogBuilder(activity)  # Default is ALERT_TYPE_MESSAGE
            builder.set_title(localization.get_string("alert_title_error"))
            builder.set_message(error)

            def on_positive_click(bld: AlertDialogBuilder, which: int):
                ClipData = find_class("android.content.ClipData")
                Context = find_class("android.content.Context")

                clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE)
                clip = ClipData.newPlainText("error", error)
                clipboard.setPrimaryClip(clip)

                # BulletinHelper.show_copied_to_clipboard doesn't work for some reason??
                run_on_ui_thread(lambda: BulletinHelper.show_info(localization.get_string("bulletin_copied_to_clipboard")))
                bld.dismiss()

            def on_negative_click(bld: AlertDialogBuilder, which: int):
                bld.dismiss()

            builder.set_positive_button(localization.get_string("alert_copy"), on_positive_click)
            builder.set_negative_button(localization.get_string("alert_close"), on_negative_click)

            builder.show()

        # The logic is mostly identical to TranscribeButton.java but with minor changes
        def transcribePressed(self, param, messageObject, open):
            self.debug_log("[TRANSCRIBER] transcribePressed() called")
            model = self.plugin.get_setting("model", 0)
            if model == 0:
                token = self.plugin.get_setting("token_assemblyai", "")
            elif model == 1:
                token = self.plugin.get_setting("token_deepgram", "")
            elif model == 2:
                token = self.plugin.get_setting("token_mistral", "")
            elif model == 3:
                token = self.plugin.get_setting("token_gemini", "")

            TranscribeButton = find_class("org.telegram.ui.Components.TranscribeButton")
            MessagesStorage = find_class("org.telegram.messenger.MessagesStorage")
            DialogObject = find_class("org.telegram.messenger.DialogObject")
            MessagesController = find_class("org.telegram.messenger.MessagesController")
            NotificationCenter = find_class("org.telegram.messenger.NotificationCenter")

            this = param.thisObject
            transcribeOperationsByDialogPosition = get_private_field(this, "transcribeOperationsByDialogPosition")

            if messageObject == None or messageObject.messageOwner == None or not messageObject.isSent():
                return

            account = messageObject.currentAccount
            peer = MessagesController.getInstance(account).getInputPeer(messageObject.messageOwner.peer_id)
            dialogId = DialogObject.getPeerDialogId(peer)
            messageId = messageObject.messageOwner.id

            if token == "":
                run_on_ui_thread(
                    lambda: BulletinHelper.show_with_button(
                        localization.get_string("error_no_token"),
                        R_tg.raw.error,
                        localization.get_string("bulletin_open_settings"),
                        self.open_settings,
                    )
                )
                self.stop_animations(this, messageObject, account, messageId)
                return

            if open:
                self.debug_log("[TRANSCRIBER] open is True")
                if messageObject.messageOwner.voiceTranscription != None and messageObject.messageOwner.voiceTranscriptionFinal:
                    self.debug_log("[TRANSCRIBER] The message already has transcription")
                    TranscribeButton.openVideoTranscription(messageObject)
                    messageObject.messageOwner.voiceTranscriptionOpen = True
                    MessagesStorage.getInstance(account).updateMessageVoiceTranscriptionOpen(dialogId, messageId, messageObject.messageOwner)
                    run_on_ui_thread(
                        lambda: NotificationCenter.getInstance(account).postNotificationName(
                            NotificationCenter.voiceTranscriptionUpdate, messageObject, None, None, True, True
                        )
                    )
                else:
                    self.debug_log("[TRANSCRIBER] Message doesn't have transcription")
                    self.start_transcription_logic(messageObject, this, model=None)
                    self.debug_log("[TRANSCRIBER] Should've started transcription logic by now")
            else:
                if transcribeOperationsByDialogPosition != None:
                    transcribeOperationsByDialogPosition.remove(int(self.reqInfoHash(messageObject)))
                messageObject.messageOwner.voiceTranscriptionOpen = False
                MessagesStorage.getInstance(account).updateMessageVoiceTranscriptionOpen(dialogId, messageId, messageObject.messageOwner)
                run_on_ui_thread(
                    lambda: NotificationCenter.getInstance(account).postNotificationName(
                        NotificationCenter.voiceTranscriptionUpdate, messageObject, None, None, False, None
                    )
                )

        # Identical to TranscribeButton.java
        def reqInfoHash(self, messageObject):
            if messageObject == None:
                return 0
            return Objects.hash(messageObject.currentAccount, messageObject.getDialogId(), messageObject.getId())

        def start_transcription_logic(self, messageObject, this, model: Optional[int] = None):
            self.debug_log("[TRANSCRIBER] start_transcription_logic()")

            MessagesStorage = find_class("org.telegram.messenger.MessagesStorage")
            DialogObject = find_class("org.telegram.messenger.DialogObject")
            MessagesController = find_class("org.telegram.messenger.MessagesController")

            if messageObject == None or messageObject.messageOwner == None or not messageObject.isSent():
                self.debug_log("[TRANSCRIBER] either messageObject is None, messageOwner is None or message isn't sent")
                return

            account = messageObject.currentAccount
            peer = MessagesController.getInstance(account).getInputPeer(messageObject.messageOwner.peer_id)
            dialogId = DialogObject.getPeerDialogId(peer)
            messageId = messageObject.messageOwner.id
            id = messageId

            if this is not None:
                self.debug_log("[TRANSCRIBER] this is NOT None")
                transcribeOperationsByDialogPosition = get_private_field(this, "transcribeOperationsByDialogPosition")
                if transcribeOperationsByDialogPosition == None:
                    set_private_field(this, "transcribeOperationsByDialogPosition", HashMap())
                transcribeOperationsByDialogPosition = get_private_field(this, "transcribeOperationsByDialogPosition")
                transcribeOperationsByDialogPosition.put(int(self.reqInfoHash(messageObject)), messageObject)

                transcribeOperationsById = get_private_field(this, "transcribeOperationsById")
                if transcribeOperationsById == None:
                    set_private_field(this, "transcribeOperationsById", HashMap())
                transcribeOperationsById = get_private_field(this, "transcribeOperationsById")
                transcribeOperationsById.put(id, messageObject)
            else:
                self.debug_log("[TRANSCRIBER] this IS None")

            messageObject.messageOwner.voiceTranscriptionId = id

            # Fixes loading animation not playing when reopening the chat
            MessagesStorage.getInstance(account).updateMessageVoiceTranscription(dialogId, messageId, "", messageObject.messageOwner)

            run_on_queue(lambda: self.transcribe(messageObject, account, dialogId, messageId, id, this, model))

        def transcribe(self, messageObject, account, dialogId, messageId, id, this, model: Optional[int] = None):
            path = self.get_audio_path(messageObject)
            if isinstance(path, Exception):
                log(f"[TRANSCRIBER] Error getting audio path: {path}")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"{localization.get_string('error_get_audio_path')}: {path}"))
                self.stop_animations(this, messageObject, account, messageId)
                return

            TRANSCRIPTION_EXECUTOR.submit(self.perform_transcription, path, messageObject, account, dialogId, messageId, id, this, model)

        def perform_transcription(self, path, messageObject, account, dialogId, messageId, id, this, model: Optional[int] = None):
            try:
                if self.plugin.get_setting("convert_to_audio", True) and messageObject.type == 5:  # TYPE_ROUND_VIDEO
                    path = self.extract_audio_from_mp4(path)
                    if isinstance(path, Exception):
                        raise path

                text = self.send_transcription_request(path, model)
                if isinstance(text, Exception):
                    raise text

                finalText = str(text)

                TranscribeButton = find_class("org.telegram.ui.Components.TranscribeButton")
                MessagesStorage = find_class("org.telegram.messenger.MessagesStorage")

                messageObject.messageOwner.voiceTranscriptionOpen = True
                messageObject.messageOwner.voiceTranscriptionFinal = True
                MessagesStorage.getInstance(account).updateMessageVoiceTranscription(dialogId, messageId, finalText, messageObject.messageOwner)

                transcribeOperationsByDialogPosition = get_private_field(this, "transcribeOperationsByDialogPosition")
                if transcribeOperationsByDialogPosition:
                    transcribeOperationsByDialogPosition.remove(self.reqInfoHash(messageObject))

                run_on_ui_thread(lambda: self.finish_transcription_ui(this, messageObject, id, finalText, TranscribeButton))

            except Exception as e:
                err = str(e)
                log(f"[TRANSCRIBER] Error transcribing: {err}")
                run_on_ui_thread(
                    lambda: BulletinHelper.show_with_button(
                        f"{localization.get_string('error_transcribing')}: {err}",
                        R_tg.raw.error,
                        localization.get_string("bulletin_view_error"),
                        lambda: self.view_error(err),
                    )
                )
                self.stop_animations(this, messageObject, account, messageId)

        def finish_transcription_ui(self, this, messageObject, finalId, finalText, TranscribeButton):
            TranscribeButton.openVideoTranscription(messageObject)
            TranscribeButton.finishTranscription(messageObject, finalId, finalText)
            if this:
                this.showOffTranscribe(messageObject)

        def stop_animations(self, this, messageObject, account, messageId):
            NotificationCenter = find_class("org.telegram.messenger.NotificationCenter")

            if this:
                transcribeOperationsByDialogPosition = get_private_field(this, "transcribeOperationsByDialogPosition")
                transcribeOperationsById = get_private_field(this, "transcribeOperationsById")
                if transcribeOperationsByDialogPosition != None:
                    transcribeOperationsByDialogPosition.remove(int(self.reqInfoHash(messageObject)))
                if transcribeOperationsById != None:
                    transcribeOperationsById.remove(messageId, messageObject)

            run_on_ui_thread(
                lambda: NotificationCenter.getInstance(account).postNotificationName(
                    NotificationCenter.voiceTranscriptionUpdate, messageObject, None, None, False, None
                )
            )

        def get_audio_path(self, msg):
            try:
                UserConfig = find_class("org.telegram.messenger.UserConfig")
                FileLoader = find_class("org.telegram.messenger.FileLoader")

                current_account = UserConfig.selectedAccount
                file_loader = FileLoader.getInstance(current_account)
                file_path_obj = file_loader.getPathToMessage(msg.messageOwner)

                if not file_path_obj.exists():
                    document = msg.messageOwner.media.document
                    file_loader.loadFile(document, msg, 1, 0)

                for _ in range(20):
                    if not file_path_obj.exists():
                        time.sleep(1)
                    else:
                        break
                else:
                    raise TimeoutError(localization.get_string("error_load_file_timeout"))

                return str(file_path_obj.getAbsolutePath())

            except Exception as e:
                return e

        def extract_audio_from_mp4(self, in_path):
            try:
                MediaExtractor = find_class("android.media.MediaExtractor")
                MediaMuxer = find_class("android.media.MediaMuxer")
                MediaFormat = find_class("android.media.MediaFormat")
                ByteBuffer = find_class("java.nio.ByteBuffer")
                BufferInfo = find_class("android.media.MediaCodec$BufferInfo")()

                extractor = MediaExtractor()
                muxer = None

                out_path = in_path.rsplit(".", 1)[0] + ".m4a"

                extractor.setDataSource(in_path)

                audio_track = -1
                for i in range(extractor.getTrackCount()):
                    format = extractor.getTrackFormat(i)
                    mime = format.getString(MediaFormat.KEY_MIME)
                    if mime.startswith("audio/"):
                        audio_track = i
                        break

                if audio_track == -1:
                    raise RuntimeError(localization.get_string("error_audio_not_found"))

                muxer = MediaMuxer(out_path, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4)

                extractor.selectTrack(audio_track)
                audio_format = extractor.getTrackFormat(audio_track)
                audio_track_index = muxer.addTrack(audio_format)

                muxer.start()

                buffer = ByteBuffer.allocate(1024 * 1024)  # 1MB buffer

                while True:
                    sample_size = extractor.readSampleData(buffer, 0)
                    if sample_size < 0:
                        break

                    BufferInfo.offset = 0
                    BufferInfo.size = sample_size
                    BufferInfo.presentationTimeUs = extractor.getSampleTime()
                    BufferInfo.flags = extractor.getSampleFlags()

                    muxer.writeSampleData(audio_track_index, buffer, BufferInfo)
                    extractor.advance()

                return out_path

            except Exception as e:
                return RuntimeError(str(localization.get_string("error_extraction") + str(e)))

            finally:
                if muxer:
                    muxer.stop()
                    muxer.release()
                extractor.release()

        def send_transcription_request(self, path, custom_model: Optional[int] = None):
            if custom_model is None:
                model = self.plugin.get_setting("model", 0)
            else:
                model = custom_model

            if model == 0:
                token = self.plugin.get_setting("token_assemblyai", "")
            elif model == 1:
                token = self.plugin.get_setting("token_deepgram", "")
            elif model == 2:
                token = self.plugin.get_setting("token_mistral", "")
            elif model == 3:
                token = self.plugin.get_setting("token_gemini", "")

            try:
                if model == 0:  # AssemblyAI
                    base_url = "https://api.assemblyai.com"
                    headers = {"authorization": token}

                    with open(path, "rb") as f:
                        response = requests.post(base_url + "/v2/upload", headers=headers, data=f, timeout=60)
                        if response.status_code != 200:
                            raise RuntimeError(
                                f"{localization.get_string('error_upload_file')}: {response.status_code}, {localization.get_string('response')}:"
                                f" {response.text}"
                            )
                        upload_url = response.json()["upload_url"]

                    data = {"audio_url": upload_url, "language_detection": True, "speaker_labels": True}
                    response = requests.post(base_url + "/v2/transcript", headers=headers, json=data, timeout=60)

                    if response.status_code != 200:
                        raise RuntimeError(
                            f"{localization.get_string('error_start_transcription')}: {response.status_code}, {localization.get_string('response')}:"
                            f" {response.text}"
                        )

                    transcript_id = response.json()["id"]
                    polling_endpoint = f"{base_url}/v2/transcript/{transcript_id}"

                    for _ in range(60):
                        transcript = requests.get(polling_endpoint, headers=headers).json()
                        if transcript["status"] == "completed":
                            if self.plugin.get_setting("separate_speakers", True):
                                result = ""
                                utterances = transcript.get("utterances")
                                if len(utterances) > 1:
                                    for utterance in utterances:
                                        speaker = utterance.get("speaker", "Unknown")
                                        text = utterance.get("text", "")
                                        result += f"{speaker}: {text}\n"
                                else:
                                    result = utterances[0].get("text", "") if utterances else ""
                                return result
                            else:
                                return transcript.get("text", "")
                        elif transcript["status"] == "error":
                            raise RuntimeError(f"{transcript['error']}")
                        else:
                            time.sleep(1)
                    else:
                        raise TimeoutError(localization.get_string("error_timed_out"))

                elif model == 1:  # Doxgram â˜ ï¸â˜ ï¸
                    url = "https://api.deepgram.com/v1/listen?model=nova-3-general&punctuate=true&detect_language=true&diarize=true"
                    headers = {
                        "Authorization": f"Token {token}",
                        "Content-Type": "audio/*",
                    }
                    with open(path, "rb") as audio_file:
                        response = requests.post(url, headers=headers, data=audio_file, timeout=60)

                    if response.status_code != 200:
                        raise RuntimeError(f"{response.status_code}, {localization.get_string('response')}: {response.text}")

                    if self.plugin.get_setting("separate_speakers", True):
                        words = response.json()["results"]["channels"][0]["alternatives"][0]["words"]

                        # Determine unique speakers
                        unique_speakers = set()
                        for word_data in words:
                            if "speaker" in word_data:
                                unique_speakers.add(word_data["speaker"])

                        if len(unique_speakers) <= 1:
                            return response.json()["results"]["channels"][0]["alternatives"][0]["transcript"]

                        script_lines = []
                        current_speaker = None
                        current_dialogue_words = []

                        def flush_dialogue(speaker_id, dialogue_words):
                            if dialogue_words:
                                speaker_label = chr(65 + speaker_id)
                                full_line = " ".join(dialogue_words)
                                return f"{speaker_label}: {full_line}"
                            return None

                        for word_data in words:
                            speaker_id = word_data.get("speaker")
                            punctuated_word = word_data.get("punctuated_word")

                            if speaker_id is not None and speaker_id != current_speaker:
                                line = flush_dialogue(current_speaker, current_dialogue_words)
                                if line:
                                    script_lines.append(line)
                                current_speaker = speaker_id
                                current_dialogue_words = [punctuated_word]
                            elif punctuated_word:
                                current_dialogue_words.append(punctuated_word)

                        line = flush_dialogue(current_speaker, current_dialogue_words)
                        if line:
                            script_lines.append(line)

                        result = "\n".join(script_lines)
                    else:
                        result = response.json()["results"]["channels"][0]["alternatives"][0]["transcript"]
                    return str(result)

                elif model == 2:  # Mistral
                    url = "https://api.mistral.ai/v1/audio/transcriptions"
                    headers = {"x-api-key": token}
                    files = {
                        "file": open(path, "rb"),
                        "model": (None, "voxtral-mini-2507"),
                    }
                    response = requests.post(url, headers=headers, files=files, timeout=60)

                    if response.status_code != 200:
                        raise RuntimeError(f"{response.status_code}, {localization.get_string('response')}: {response.text}")

                    transcription = response.json()["text"]
                    return str(transcription)

                elif model == 3:  # Gemini
                    # Credits: Voice to Text plugin by @PESSDES
                    with open(path, "rb") as f:
                        audio64 = base64.b64encode(f.read()).decode("utf-8")

                    url = f"https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key={token}"

                    mime_type = "video/mp4" if path.lower().endswith(".mp4") else "audio/ogg"
                    if self.plugin.get_setting("separate_speakers", True):
                        prompt = DEFAULT_PROMPT_DIARIZATION
                    else:
                        prompt = DEFAULT_PROMPT
                    payload = {
                        "contents": [{"parts": [{"text": prompt}, {"inline_data": {"mimeType": mime_type, "data": audio64}}]}],
                        "generationConfig": {
                            "temperature": 0,
                            "thinkingConfig": {"thinkingBudget": -1 if self.plugin.get_setting("thinking_mode", False) else 0},
                        },
                    }

                    response = requests.post(url, json=payload, timeout=60)

                    if response.status_code != 200:
                        raise RuntimeError(f"{response.status_code}, {localization.get_string('response')}: {response.text}")

                    data = response.json()
                    if "candidates" in data and data["candidates"]:
                        candidate = data["candidates"][0]
                        if "content" in candidate and "parts" in candidate["content"]:
                            parts = candidate["content"]["parts"]
                            if parts and "text" in parts[0]:
                                return parts[0]["text"].strip()

                    if "error" in data:
                        error_msg = data["error"].get("message", "Unknown API error")
                        log(f"[TRANSCRIBER] Gemini API error: {error_msg}")
                        raise RuntimeError(error_msg)

                    log("[TRANSCRIBER] No text found in API response")
                    raise RuntimeError("No text found in API response.")
            except Exception as e:
                return e

    class CreateUpdateWaveformHook(MethodHook):
        def after_hooked_method(self, param):
            try:
                this = param.thisObject
                set_private_field(this, "useTranscribeButton", True)
            except Exception as e:
                BulletinHelper.show_info(str(e))
