from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class
from ui.settings import Switch, Header, Divider

import hashlib
import json
import os
import threading
import time
import urllib.request
import uuid

# === mkStats: embed client start ===
MKSTATS_API_URL = os.getenv("MKSTATS_API_URL", "https://mkstats.mk69.su/api")
MKSTATS_PING_INTERVAL = int(os.getenv("MKSTATS_PING_INTERVAL", "1500"))
MKSTATS_POW_SOLVE_SECONDS = int(os.getenv("MKSTATS_POW_SOLVE_SECONDS", "6"))

def generate_user_hash(device_id: str, plugin_id: str) -> str:
    payload = f"{device_id}:{plugin_id}:mkstats:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def generate_device_fingerprint(device_id: str) -> str:
    payload = f"{device_id}:mkstats:device:v1"
    return hashlib.sha256(payload.encode("utf-8")).hexdigest()

def _normalize_api_base(api_url: str) -> str:
    base = api_url.rstrip("/")
    if base.endswith("/api"):
        return f"{base}/v1"
    return base

def _post_json(url: str, payload: dict) -> dict:
    data = json.dumps(payload).encode("utf-8")
    request = urllib.request.Request(
        url, data=data, headers={"Content-Type": "application/json"}
    )
    with urllib.request.urlopen(request, timeout=10) as response:
        body = response.read().decode("utf-8")
    return json.loads(body)

def _pow_valid(challenge: str, nonce: str, difficulty: int) -> bool:
    if not challenge or not nonce or difficulty <= 0:
        return False
    prefix = "0" * max(1, int(difficulty))
    digest = hashlib.sha256(f"{challenge}:{nonce}".encode("utf-8")).hexdigest()
    return digest.startswith(prefix)

def _solve_pow(challenge: str, difficulty: int, max_seconds: int = MKSTATS_POW_SOLVE_SECONDS) -> str | None:
    difficulty = max(1, int(difficulty or 0))
    deadline = time.time() + max(1, int(max_seconds or 0))
    nonce = 0
    prefix = "0" * difficulty
    while time.time() < deadline:
        candidate = format(nonce, "x")
        digest = hashlib.sha256(f"{challenge}:{candidate}".encode("utf-8")).hexdigest()
        if digest.startswith(prefix):
            return candidate
        nonce += 1
    return None

class MkStatsCoreClient:
    def __init__(self, api_url: str, plugin_id: str, plugin_version: str, user_hash: str, device_fingerprint: str, client_version: str | None = None, client_name: str | None = None) -> None:
        self.api_base = _normalize_api_base(api_url)
        self.plugin_id = plugin_id
        self.plugin_version = plugin_version
        self.client_version = client_version
        self.client_name = client_name
        self.user_hash = user_hash
        self.device_fingerprint = device_fingerprint

    def handshake(self) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
        }
        response = _post_json(f"{self.api_base}/handshake", payload)
        token = (response or {}).get("install_token", "")
        if token:
            return response
        pow_required = bool((response or {}).get("pow_required"))
        pow_challenge = (response or {}).get("pow_challenge")
        if pow_required and pow_challenge:
            difficulty = int((response or {}).get("pow_difficulty") or 0)
            nonce = _solve_pow(pow_challenge, difficulty)
            if nonce and _pow_valid(pow_challenge, nonce, difficulty):
                payload["pow_challenge"] = pow_challenge
                payload["pow_nonce"] = nonce
                response = _post_json(f"{self.api_base}/handshake", payload)
        return response

    def send_ping(self, install_token: str, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/data", payload)

    def send_event(self, install_token: str, event: str, count: int = 1, timestamp=None) -> dict:
        payload = {
            "plugin_id": self.plugin_id,
            "version": self.plugin_version,
            "client_name": self.client_name,
            "client_version": self.client_version,
            "user_hash": self.user_hash,
            "device_fingerprint": self.device_fingerprint,
            "install_token": install_token,
            "event": event,
            "count": count,
            "timestamp": timestamp or int(time.time()),
        }
        return _post_json(f"{self.api_base}/event", payload)
# === mkStats: embed client end ===

__id__ = "fuck_gifts"
__name__ = "No Gifts"
__description__ = "убирает подарки из чатов, профилей и строки ввода (сосать капитализм)"
__icon__ = "feature_plugins/1"
__version__ = "2.1"
__min_version__ = "12.2.3"
__author__ = "@feature_plugins"

STRINGS = {
    "ru": {
        "header_settings": "Настройки скрытия подарков",
        "hide_input_btn": "Скрывать кнопку в чате",
        "hide_input_btn_sub": "Убирает кнопку отправки подарка и блокирует меню отправки",
        "hide_chat_msgs": "Скрывать сообщения о подарках",
        "hide_chat_msgs_sub": "Скрывает сервисные сообщения и блокирует просмотр подарков",
        "hide_profile_row": "Скрывать подарки в профиле",
        "hide_profile_row_sub": "Скрывает раздел 'Подарки' в профиле",
    },
    "en": {
        "header_settings": "Gift Hiding Settings",
        "hide_input_btn": "Hide button in chat",
        "hide_input_btn_sub": "Removes the send gift button and blocks the send menu",
        "hide_chat_msgs": "Hide gift messages",
        "hide_chat_msgs_sub": "Hides service messages and blocks gift viewing",
        "hide_profile_row": "Hide gifts in profile",
        "hide_profile_row_sub": "Hides the 'Gifts' section in profile",
    }
}

def get_language():
    try:
        Locale = find_class("java.util.Locale")
        return "ru" if Locale.getDefault().getLanguage() == "ru" else "en"
    except:
        return "en"

def get_string(key):
    lang = get_language()
    return STRINGS.get(lang, STRINGS["en"]).get(key, STRINGS["en"].get(key, ""))

class HideGiftButtonPlugin(BasePlugin):

    # === mkStats: integration start ===
    def _mkstats_get_setting(self, key: str, default):
        try:
            if hasattr(self, "get_setting"):
                return self.get_setting(key, default)
            if hasattr(self, "getsetting"):
                return self.getsetting(key, default)
        except Exception:
            pass
        return default

    def _mkstats_set_setting(self, key: str, value, reload_settings: bool = False):
        try:
            if hasattr(self, "set_setting"):
                return self.set_setting(key, value, reload_settings=reload_settings)
            if hasattr(self, "setsetting"):
                return self.setsetting(key, value, reloadsettings=reload_settings)
        except Exception:
            pass
        return None

    def _mkstats_get_device_id(self) -> str:
        device_id = self._mkstats_get_setting("mkstats_device_id", "")
        if not device_id:
            device_id = uuid.uuid4().hex
            self._mkstats_set_setting("mkstats_device_id", device_id, reload_settings=False)
        return device_id

    def _mkstats_get_client_version(self) -> str:
        try:
            from org.telegram.messenger import BuildVars
            version = getattr(BuildVars, "BUILD_VERSION_STRING", None) or getattr(BuildVars, "BUILD_VERSION", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import BuildConfig as TgBuildConfig
            version = getattr(TgBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            version = getattr(AyuBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            version = getattr(ExBuildConfig, "VERSION_NAME", None)
            if version:
                return str(version)
        except Exception:
            pass
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pm = ctx.getPackageManager()
                pkg = ctx.getPackageName()
                info = pm.getPackageInfo(pkg, 0)
                version = getattr(info, "versionName", None) or getattr(info, "versionCode", None)
                if version:
                    return str(version)
        except Exception:
            pass
        return "unknown"

    def _mkstats_get_client_name(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            ctx = ApplicationLoader.applicationContext
            if ctx:
                pkg = ctx.getPackageName()
                if pkg == "com.radolyn.ayugram":
                    return "AyuGram"
                if pkg == "com.exteragram.messenger":
                    return "exteraGram"
                if pkg == "org.telegram.messenger":
                    return "Telegram"
                if pkg:
                    return str(pkg)
        except Exception:
            pass
        try:
            from com.radolyn.ayugram import BuildConfig as AyuBuildConfig
            _ = AyuBuildConfig.VERSION_NAME
            return "AyuGram"
        except Exception:
            pass
        try:
            from com.exteragram.messenger import BuildConfig as ExBuildConfig
            _ = ExBuildConfig.VERSION_NAME
            return "exteraGram"
        except Exception:
            pass
        return "unknown"

    def _mkstats_log(self, message: str) -> None:
        if hasattr(self, "log"):
            try:
                self.log(message)
            except Exception:
                pass

    def _mkstats_event(self, event: str, count: int = 1) -> None:
        if not event:
            return

        def _send():
            try:
                if not hasattr(self, "_mkstats_client"):
                    return
                if not getattr(self, "_mkstats_token", ""):
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                if self._mkstats_token:
                    self._mkstats_client.send_event(self._mkstats_token, event, count=count)
            except Exception as exc:
                self._mkstats_log(f"mkStats: event error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)

        try:
            threading.Thread(target=_send, daemon=True).start()
        except Exception:
            pass

    def _mkstats_loop(self):
        while not self._mkstats_stop.is_set():
            try:
                if not self._mkstats_token:
                    self._mkstats_log("mkStats: handshake start")
                    data = self._mkstats_client.handshake()
                    self._mkstats_token = data.get("install_token", "")
                    if self._mkstats_token:
                        self._mkstats_set_setting("mkstats_install_token", self._mkstats_token, reload_settings=False)
                        self._mkstats_log("mkStats: handshake ok, token stored")
                    else:
                        self._mkstats_log("mkStats: handshake response missing token")

                if self._mkstats_token:
                    self._mkstats_log("mkStats: sending ping")
                    self._mkstats_client.send_ping(self._mkstats_token)
                    self._mkstats_log("mkStats: ping sent")
            except Exception as exc:
                self._mkstats_log(f"mkStats: error {exc}")
                self._mkstats_token = ""
                self._mkstats_set_setting("mkstats_install_token", "", reload_settings=False)
            self._mkstats_stop.wait(MKSTATS_PING_INTERVAL)

    def _mkstats_start(self):
        try:
            device_id = self._mkstats_get_device_id()
            user_hash = generate_user_hash(device_id, __id__)
            device_fingerprint = generate_device_fingerprint(device_id)
            client_name = self._mkstats_get_client_name()
            client_version = self._mkstats_get_client_version()
            self._mkstats_client = MkStatsCoreClient(MKSTATS_API_URL, __id__, __version__, user_hash, device_fingerprint, client_version, client_name)
            self._mkstats_stop = threading.Event()
            self._mkstats_token = self._mkstats_get_setting("mkstats_install_token", "")
            self._mkstats_thread = threading.Thread(target=self._mkstats_loop, daemon=True)
            self._mkstats_thread.start()
            self._mkstats_log(f"mkStats: client started ({self._mkstats_client.api_base})")
        except Exception:
            pass
    # === mkStats: integration end ===

    def on_plugin_load(self):

        # === mkStats: integration start ===
        self._mkstats_start()
        # === mkStats: integration end ===

        # Settings
        hide_input_btn = self.get_setting("hide_gifts_enabled", True)
        hide_chat_msgs = self.get_setting("hide_chat_gifts", True)
        hide_profile_row = self.get_setting("hide_profile_gifts", True)
        
        # 1. Hide Input Button & Send Sheets
        if hide_input_btn:
            try:
                cls = find_class("org.telegram.ui.Components.ChatActivityEnterView")
                if cls:
                    self.hook_all_methods(cls, "createGiftButton", GiftBlockHook(), priority=50)
            except:
                pass
            
            try:
                cls = find_class("org.telegram.ui.Components.chat.layouts.ChatActivityChannelButtonsLayout")
                if cls:
                    self.hook_all_methods(cls, "showButton", ChannelGiftBlockHook(), priority=50)
            except:
                pass

            # Block SendGiftSheet (Sending gifts)
            try:
                cls = find_class("org.telegram.ui.Gifts.SendGiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            # Block GiftSheet (Generic/Old gifts)
            try:
                cls = find_class("org.telegram.ui.Gifts.GiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            # Block GiftOfferSheet (Star gifts offers)
            try:
                cls = find_class("org.telegram.ui.Stars.GiftOfferSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

        # 2. Hide Chat Messages & Viewing Sheets
        if hide_chat_msgs:
            try:
                cls = find_class("org.telegram.ui.Cells.ChatMessageCell")
                if cls:
                    # Optimize: Check gift status only when message is set
                    self.hook_all_methods(cls, "setMessageObject", ChatMessageSetMessageHook(), priority=50)
                    # Efficiently hide based on cached status
                    self.hook_all_methods(cls, "onMeasure", ChatMessageMeasureHook(), priority=50)
            except Exception as e:
                pass
            
            # Block StarGiftSheet (Viewing received gifts)
            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

        # 3. Hide Profile Gifts (Rows, Tabs, Views)
        if hide_profile_row:
            # Old/Generic TextCell hook
            try:
                cls = find_class("org.telegram.ui.Cells.TextCell")
                if cls:
                    self.hook_all_methods(cls, "setTextAndIcon", TextCellSetTextHook(), priority=50)
                    self.hook_all_methods(cls, "setText", TextCellSetTextHook(), priority=50)
                    self.hook_all_methods(cls, "onMeasure", TextCellMeasureHook(), priority=50)
            except Exception as e:
                pass

            # ProfileActivity - Header View (ProfileGiftsView)
            try:
                cls = find_class("org.telegram.ui.Stars.ProfileGiftsView")
                if cls:
                    self.hook_all_methods(cls, "onMeasure", ViewMeasureZeroHook(), priority=50)
                    self.hook_all_methods(cls, "setVisibility", ViewVisibilityGoneHook(), priority=50)
            except:
                pass

            # ProfileGiftsContainer (Additional container)
            try:
                cls = find_class("org.telegram.ui.Gifts.ProfileGiftsContainer")
                if cls:
                    self.hook_all_methods(cls, "onMeasure", ViewMeasureZeroHook(), priority=50)
                    self.hook_all_methods(cls, "setVisibility", ViewVisibilityGoneHook(), priority=50)
            except:
                pass
            
            # ProfileActivity - Prevent clicking gift premium button
            try:
                cls = find_class("org.telegram.ui.ProfileActivity")
                if cls:
                    self.hook_all_methods(cls, "onGiftPermiumClicked", BlockMethodHook(), priority=50)
            except:
                pass

            # Block StarGiftSheet (Unique star gifts viewing)
            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            # Block StarGiftPreviewSheet
            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftPreviewSheet")
                if cls:
                    self.hook_all_methods(cls, "show", GiftSheetBlockHook(), priority=50)
            except:
                pass

            # Block ProfileGiftsView (Profile gifts rendering)
            try:
                cls = find_class("org.telegram.ui.Stars.ProfileGiftsView")
                if cls:
                    self.hook_all_methods(cls, "onMeasure", ViewMeasureZeroHook(), priority=50)
                    self.hook_all_methods(cls, "setVisibility", ViewVisibilityGoneHook(), priority=50)
            except:
                pass

            # Block StarGiftUniqueActionLayout (Gift actions in chat)
            try:
                cls = find_class("org.telegram.ui.Stars.StarGiftUniqueActionLayout")
                if cls:
                    self.hook_all_methods(cls, "set", GiftSheetBlockHook(), priority=50)
            except:
                pass

            # Hide 'Gifts' tab in SharedMediaLayout (ID 14)
            try:
                cls = find_class("org.telegram.ui.Components.SharedMediaLayout")
                if cls:
                    # Hook static getTab to return null for Gifts tab (ID 14)
                    self.hook_all_methods(cls, "getTab", SharedMediaGetTabHook(), priority=50)
            except:
                pass

            # Block adding Gifts tab to ScrollSlidingTextTabStrip
            try:
                cls = find_class("org.telegram.ui.Components.ScrollSlidingTextTabStrip")
                if cls:
                    self.hook_all_methods(cls, "addTextTab", TabBlockHook(), priority=50)
            except:
                pass
    
    def create_settings(self):
        settings = [
            Header(text=get_string("header_settings")),
            Switch(
                key="hide_gifts_enabled",
                text=get_string("hide_input_btn"),
                subtext=get_string("hide_input_btn_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_chat_gifts",
                text=get_string("hide_chat_msgs"),
                subtext=get_string("hide_chat_msgs_sub"),
                icon="msg_gift_premium",
                default=True
            ),
            Switch(
                key="hide_profile_gifts",
                text=get_string("hide_profile_row"),
                subtext=get_string("hide_profile_row_sub"),
                icon="msg_contact",
                default=True
            ),
            Divider()
        ]
        return settings

    def on_plugin_unload(self):
        # === mkStats: integration start ===
        if hasattr(self, "_mkstats_stop"):
            self._mkstats_stop.set()
            self._mkstats_log("mkStats: stop requested")
            try:
                if hasattr(self, "_mkstats_thread") and self._mkstats_thread is not None:
                    self._mkstats_thread.join(timeout=1.0)
            except Exception:
                pass
        # === mkStats: integration end ===

# --- Hooks ---

class GiftBlockHook(MethodHook):
    def before_hooked_method(self, param):
        param.setResult(None)

class BlockMethodHook(MethodHook):
    def before_hooked_method(self, param):
        param.setResult(None)

class GiftSheetBlockHook(MethodHook):
    def before_hooked_method(self, param):
        # Prevent sheet from showing
        param.setResult(None)

class ChannelGiftBlockHook(MethodHook):
    def before_hooked_method(self, param):
        if param.args[0] == 1:
            param.setResult(None)

class ChatMessageSetMessageHook(MethodHook):
    def __init__(self):
        self.gift_classes = []
        
        def safe_add(class_name):
            try:
                cls = find_class(class_name)
                if cls:
                    self.gift_classes.append(cls)
            except BaseException:
                pass

        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionGift")
        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionStarGift")
        safe_add("org.telegram.tgnet.TLRPC$TL_messageActionGiftCode")

    def after_hooked_method(self, param):
        try:
            view = param.thisObject
            # args[0] is MessageObject
            if len(param.args) > 0:
                msg = param.args[0]
                is_gift = False
                if msg:
                    # Access messageOwner.action safely
                    try:
                        if hasattr(msg, "messageOwner") and msg.messageOwner:
                             action = getattr(msg.messageOwner, "action", None)
                             if action:
                                 action_class = action.getClass()
                                 for cls in self.gift_classes:
                                     if cls and action_class.isAssignableFrom(cls):
                                         is_gift = True
                                         break
                    except:
                        pass
                
                setattr(view, "_is_gift", is_gift)
        except:
            pass

class ChatMessageMeasureHook(MethodHook):
    def after_hooked_method(self, param):
        try:
            if getattr(param.thisObject, "_is_gift", False):
                param.thisObject.setMeasuredDimension(0, 0)
        except:
            pass

class TextCellSetTextHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            view = param.thisObject
            
            # Optimize: Cache context check to avoid expensive JNI calls on every setText
            is_profile = getattr(view, "_is_profile_context", None)
            if is_profile is None:
                context = view.getContext()
                if not context:
                    return
                # Check class name once and cache result
                ctx_name = context.getClass().getSimpleName()
                is_profile = "ProfileActivity" in ctx_name
                setattr(view, "_is_profile_context", is_profile)
            
            if not is_profile:
                # If not in profile, ensure flag is cleared and exit fast
                setattr(view, "_is_gift_row", False)
                return

            text = ""
            if len(param.args) > 0:
                text = str(param.args[0])
            
            # Check for gift text only if we are in ProfileActivity
            if "Gift" in text or "Подар" in text:
                 setattr(view, "_is_gift_row", True)
            else:
                 setattr(view, "_is_gift_row", False)
        except:
            pass

class TextCellMeasureHook(MethodHook):
    def after_hooked_method(self, param):
        try:
            if getattr(param.thisObject, "_is_gift_row", False):
                param.thisObject.setMeasuredDimension(0, 0)
        except:
            pass

class ViewMeasureZeroHook(MethodHook):
    def after_hooked_method(self, param):
        param.thisObject.setMeasuredDimension(0, 0)

class ViewVisibilityGoneHook(MethodHook):
    def before_hooked_method(self, param):
        # 8 = GONE
        param.args[0] = 8

class SharedMediaGetTabHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            # public static TLRPC.ProfileTab getTab(int i, boolean z)
            # i = 14 is Gifts
            if isinstance(param.args[0], int) and param.args[0] == 14:
                param.setResult(None)
        except:
            pass

class TabBlockHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            # addTextTab(int i, CharSequence text, ...)
            # i = 14 is Gifts
            if isinstance(param.args[0], int) and param.args[0] == 14:
                param.setResult(None)
        except:
            pass