__id__ = "swag_heart_magic"
__name__ = "SwagHeartMagic"
__version__ = "1.0"
__author__ = "MandreAI & Swaga"
__description__ = "Heart animation with single-message edits. Use .mag <text>"
__min_version__ = "11.9.0"
__icon__ = "msg_heart_fill"

import time
import re
from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import send_request, get_messages_controller, run_on_queue
from android_utils import log
from org.telegram.tgnet import TLRPC


class SwagHeartMagicPlugin(BasePlugin):
    EDIT_DELAY = 0.61

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self.log("SwagHeartMagic loaded (edit animation)")

    def on_send_message_hook(self, account, params):
        msg = getattr(params, "message", "").strip()

        match = re.match(r'^\.mag\s+(.+)$', msg, re.IGNORECASE)
        if not match:
            return HookResult()

        user_text = match.group(1)
        peer = params.peer
        reply_to_msg = getattr(params, 'replyToMsg', None)
        reply_to_top = getattr(params, 'replyToTopMsg', None)

        run_on_queue(lambda: self._start_heart_animation(peer, user_text, reply_to_msg, reply_to_top))

        return HookResult(strategy=HookStrategy.CANCEL)

    def _start_heart_animation(self, peer, user_text, reply_to_msg=None, reply_to_top=None):
        try:
            frames = [
                "\u2764\ufe0f",                    # 鉂わ笍
                "\U0001F495",                      # 馃挄
                "\U0001F496",                      # 馃挅
                "\U0001F497",                      # 馃挆
                "\U0001F493",                      # 馃挀
                "\U0001F49B\U0001F497\U0001F49B",  # 馃挍馃挆馃挍
                "\U0001F49A\U0001F495\U0001F49A",  # 馃挌馃挄馃挌
                "\U0001F499\U0001F493\U0001F499",  # 馃挋馃挀馃挋
                "\U0001F49C\U0001F496\U0001F49C",  # 馃挏馃挅馃挏
                "\U0001F9E1\U0001F497\U0001F9E1",  # 馃А馃挆馃А
                "\U0001F496\U0001F49B\U0001F496",  # 馃挅馃挍馃挅
                "\U0001F495\U0001F49A\U0001F495",  # 馃挄馃挌馃挄
                "\U0001F497\U0001F499\U0001F497",  # 馃挆馃挋馃挆
                "\U0001F493\U0001F49C\U0001F493",  # 馃挀馃挏馃挀
                "\U0001F496\U0001F9E1\U0001F496",  # 馃挅馃А馃挅
                "\u2728\U0001F496\u2728",          # 鉁煉栤湪
                "\U0001F31F\U0001F497\U0001F31F",  # 馃専馃挆馃専
                "\u2B50\U0001F495\u2B50",          # 猸愷煉曗瓙
                "\u2728\U0001F493\u2728",          # 鉁煉撯湪
                "\U0001F31F\U0001F496\U0001F31F",  # 馃専馃挅馃専
                "\U0001F497",                      # 馃挆
                "\U0001F496",                      # 馃挅
                "\U0001F495",                      # 馃挄
                "\U0001F493",                      # 馃挀
                "\u2764\ufe0f",                    # 鉂わ笍
            ]

            message_id = self._send_first_message(peer, frames[0], reply_to_msg, reply_to_top)

            if message_id is None:
                log("[SwagHeartMagic] Failed to send first message")
                return

            for frame in frames[1:]:
                self._edit_message(peer, message_id, frame)
                time.sleep(self.EDIT_DELAY)

            final_text = f"{user_text}\n\n" + "@Unsido"
            self._edit_message(peer, message_id, final_text)

        except Exception as e:
            log(f"[SwagHeartMagic] Animation error: {e}")
            import traceback
            log(traceback.format_exc())

    def _send_first_message(self, peer, text, reply_to_msg=None, reply_to_top=None):
        message_ids = [None]

        def on_sent(response, error):
            if error:
                log(f"[SwagHeartMagic] Send error: {getattr(error, 'text', repr(error))}")
                return

            try:
                if hasattr(response, 'updates') and response.updates:
                    iterator = response.updates.iterator()
                    while iterator.hasNext():
                        update = iterator.next()
                        update_type = update.getClass().getSimpleName()
                        if 'NewMessage' in update_type or 'NewChannelMessage' in update_type:
                            if hasattr(update, 'message') and hasattr(update.message, 'id'):
                                message_ids[0] = int(update.message.id)
                                log(f"[SwagHeartMagic] Got message ID: {message_ids[0]}")
                                break
                # process updates for local echo on mobile
                if response is not None:
                    try:
                        get_messages_controller().processUpdates(response, False)
                    except Exception:
                        pass
            except Exception as e:
                log(f"[SwagHeartMagic] ID parse error: {e}")
                import traceback
                log(traceback.format_exc())

        req = TLRPC.TL_messages_sendMessage()
        req.peer = get_messages_controller().getInputPeer(peer)
        req.message = text
        req.random_id = self._get_random_id()
        req.flags = 0
        try:
            req.no_webpage = True
        except Exception:
            pass

        # attach reply_to for comments/threads so mobile shows it
        try:
            if reply_to_msg is not None or reply_to_top is not None:
                r = TLRPC.TL_inputReplyToMessage()
                if reply_to_msg is not None:
                    try:
                        r.reply_to_msg_id = int(getattr(reply_to_msg, 'id', reply_to_msg))
                    except Exception:
                        pass
                if reply_to_top is not None:
                    try:
                        r.top_msg_id = int(getattr(reply_to_top, 'id', reply_to_top))
                        r.flags |= 1
                    except Exception:
                        pass
                req.reply_to = r
                req.flags |= 1
        except Exception as e:
            log(f"[SwagHeartMagic] failed to set reply_to: {e}")

        send_request(req, on_sent)

        max_wait = 20
        waited = 0
        while message_ids[0] is None and waited < max_wait:
            time.sleep(0.1)
            waited += 1

        return message_ids[0]

    def _edit_message(self, peer, message_id, new_text):
        try:
            req = TLRPC.TL_messages_editMessage()
            req.peer = get_messages_controller().getInputPeer(peer)
            req.id = message_id
            req.message = new_text
            req.flags = 2048
            req.no_webpage = True

            def _on_edit(response, error):
                if error:
                    log(f"[SwagHeartMagic] edit error: {getattr(error, 'text', repr(error))}")
                    return
                try:
                    if response is not None:
                        get_messages_controller().processUpdates(response, False)
                except Exception:
                    pass

            send_request(req, _on_edit)

        except Exception as e:
            log(f"[SwagHeartMagic] Edit exception: {e}")

    def _get_random_id(self):
        import random
        return random.randint(1, 9223372036854775807)

