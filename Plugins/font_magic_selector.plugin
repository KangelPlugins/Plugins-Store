__id__ = "font_magic_selector"
__name__ = "Quick Fonts"
__description__ = """
ĞŸĞ¾Ğ·Ğ²Ğ¾Ğ»ÑĞµÑ‚ Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚ Ğ² ÑÑ‚Ñ€Ğ¾ĞºĞµ Ğ²Ğ²Ğ¾dĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² Ñ‡Ğ°Ñ‚Ğµ Ğ²Ğ¾Ğ·Ğ»Ğµ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸ "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ"

!ĞĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑˆÑ€Ğ¸Ñ„Ñ‚Ñ‹ Ğ¼Ğ¾Ğ³ÑƒÑ‚ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶Ğ°Ñ‚ÑŒÑÑ ĞºĞ°Ğº [] Ğ² Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ¼ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğµ Ñ‚ĞµĞ»ĞµĞ³Ñ€Ğ°Ğ¼!
"""
__author__ = "@pl_meow"
__version__ = "1.0.0"
__icon__ = "r7xy27x2y7yfqf_by_fStikBot/0"
__min_version__ = "11.12.1"

import traceback
from typing import Any, Dict, List

# Base Imports
from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook, MenuItemData, MenuItemType
from android_utils import log, run_on_ui_thread
from client_utils import get_last_fragment
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Text, Switch
from ui.settings import Input, Selector

# Reflection & Java Imports
from hook_utils import find_class, get_private_field
from java import dynamic_proxy, jclass, jarray, jint
from java.lang import Integer, Runnable, CharSequence, String as JString, Class as JClass
from java.util import ArrayList

# Telegram Classes
from org.telegram.messenger import R, AndroidUtilities, LocaleController
from org.telegram.ui import ChatActivity, MessageSendPreview
from org.telegram.ui.Components import ItemOptions
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import BottomSheet, Theme
from android.view import View, Gravity, ViewGroup

from android.widget import FrameLayout, LinearLayout, TextView, ScrollView
from android.text import TextWatcher, Editable
from android.widget import EditText
from android.graphics import Color, Typeface
from android.graphics.drawable import GradientDrawable
from android.content.res import ColorStateList
from android.graphics.drawable import RippleDrawable
from android.view.animation import DecelerateInterpolator

# --- Constants ---
MENU_ITEM_ID = 18492
# --- Configuration (Customize layout here) ---
SELECTOR_OFFSET_Y = -44  # Vertical offset for the font bar in dp.
SELECTOR_HEIGHT = 45     # Height of the font bar in dp.

# --- Fonts Data ---
# Mapping standard characters to styled unicode characters
LOWER_ALPHA = "abcdefghijklmnopqrstuvwxyz"
UPPER_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
DIGITS = "0123456789"
RUS_LOWER = "Ğ°Ğ±Ğ²Ğ³Ğ´ĞµÑ‘Ğ¶Ğ·Ğ¸Ğ¹ĞºĞ»Ğ¼Ğ½Ğ¾Ğ¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑÑ"
RUS_UPPER = "ĞĞ‘Ğ’Ğ“Ğ”Ğ•ĞĞ–Ğ—Ğ˜Ğ™ĞšĞ›ĞœĞĞĞŸĞ Ğ¡Ğ¢Ğ£Ğ¤Ğ¥Ğ¦Ğ§Ğ¨Ğ©ĞªĞ«Ğ¬Ğ­Ğ®Ğ¯"

# --- Fonts Data ---
FONTS_EN = [
    ("Normal", None, None),
    ("Alien", "É‘á‘²cá‘¯eáºœgá¨ˆiÇ°Æ™lmâ´ºoâ´ê—rê…ê‡u×˜É¯xÑ‡z", "Aá‘²CDEáº”GHIJÆ˜LMNOPQĞ¯STUVWXYZ"),
    ("Gothic", "ğŒ°ğŒ±ğŒ²ğŒ³ğŒ´ğ†ğŒµğŒ·ğŒ¹ğŒ¾ğŒºğŒ»ğŒ¼ğŒ½ğŒ¾ğ€ğŒµğ‚ğƒğ„ğŒ¿ğ…ğ…ğ‡ğˆğŒ¶", "ğŒ°ğŒ±ğŒ²ğŒ³ğŒ´ğ†ğŒµğŒ·ğŒ¹ğŒ¾ğŒºğŒ»ğŒ¼ğŒ½ğŒ¾ğ€ğŒµğ‚ğƒğ„ğŒ¿ğ…ğ…ğ‡ğˆğŒ¶"),
    ("Fancy", "É‘bcdê¤•fghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Bubbles White", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“â“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©", "â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“â“"),
    ("Small Caps", "á´€Ê™á´„á´…á´‡Ò“É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€sá´›á´œá´ á´¡xÊá´¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Italic Sans", "ğ˜¢ğ˜£ğ˜¤ğ˜¥ğ˜¦ğ˜§ğ˜¨ğ˜©ğ˜ªğ˜«ğ˜¬ğ˜­ğ˜®ğ˜¯ğ˜°ğ˜±ğ˜²ğ˜³ğ˜´ğ˜µğ˜¶ğ˜·ğ˜¸ğ˜¹ğ˜ºğ˜»", "ğ˜ˆğ˜‰ğ˜Šğ˜‹ğ˜Œğ˜ğ˜ğ˜ğ˜ğ˜‘ğ˜’ğ˜“ğ˜”ğ˜•ğ˜–ğ˜—ğ˜˜ğ˜™ğ˜šğ˜›ğ˜œğ˜ğ˜ğ˜Ÿğ˜ ğ˜¡"),
    ("Bold Script", "ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ", "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©"),
    ("Sans", "ğ–ºğ–»ğ–¼ğ–½ğ–¾ğ–¿ğ—€ğ—ğ—‚ğ—ƒğ—„ğ—…ğ—†ğ—‡ğ—ˆğ—‰ğ—Šğ—‹ğ—Œğ—ğ—ğ—ğ—ğ—‘ğ—’ğ—“", "ğ– ğ–¡ğ–¢ğ–£ğ–¤ğ–¥ğ–¦ğ–§ğ–¨ğ–©ğ–ªğ–«ğ–¬ğ–­ğ–®ğ–¯ğ–°ğ–±ğ–²ğ–³ğ–´ğ–µğ–¶ğ–·ğ–¸ğ–¹"),
    ("Italic", "ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“ğ‘”â„ğ‘–ğ‘—ğ‘˜ğ‘™ğ‘šğ‘›ğ‘œğ‘ğ‘ğ‘Ÿğ‘ ğ‘¡ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ğ‘§", "ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğ‘€ğ‘ğ‘‚ğ‘ƒğ‘„ğ‘…ğ‘†ğ‘‡ğ‘ˆğ‘‰ğ‘Šğ‘‹ğ‘Œğ‘"),
    ("Double Struck", "ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«", "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤"),
    ("Monospace", "ğšŠğš‹ğšŒğšğšğšğšğš‘ğš’ğš“ğš”ğš•ğš–ğš—ğš˜ğš™ğššğš›ğšœğšğšğšŸğš ğš¡ğš¢ğš£", "ğ™°ğ™±ğ™²ğ™³ğ™´ğ™µğ™¶ğ™·ğ™¸ğ™¹ğ™ºğ™»ğ™¼ğ™½ğ™¾ğ™¿ğš€ğšğš‚ğšƒğš„ğš…ğš†ğš‡ğšˆğš‰"),
    ("Bubbles Black", "ğŸ…ğŸ…‘ğŸ…’ğŸ…“ğŸ…”ğŸ…•ğŸ…–ğŸ…—ğŸ…˜ğŸ…™ğŸ…šğŸ…›ğŸ…œğŸ…ğŸ…ğŸ…ŸğŸ… ğŸ…¡ğŸ…¢ğŸ…£ğŸ…¤ğŸ…¥ğŸ…¦ğŸ…§ğŸ…¨ğŸ…©", "ğŸ…ğŸ…‘ğŸ…’ğŸ…“ğŸ…”ğŸ…•ğŸ…–ğŸ…—ğŸ…˜ğŸ…™ğŸ…šğŸ…›ğŸ…œğŸ…ğŸ…ğŸ…ŸğŸ… ğŸ…¡ğŸ…¢ğŸ…£ğŸ…¤ğŸ…¥ğŸ…¦ğŸ…§ğŸ…¨ğŸ…©"),
    ("Superscript", "áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°á¶¦Ê²áµË¡áµâ¿áµ’áµ–á‘«Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»", "á´¬á´®á¶œá´°á´±á¶ á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾Qá´¿Ë¢áµ€áµâ±½áµ‚Ë£Ê¸á¶»"),
    ("Greek Mix", "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜QÊ€êœ±á´›á´œá´ á´¡xÊá´¢", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Coptic", "â²â²ƒcdâ²‰fâ„Šhiâ“™kâ„“mâ²›oâ²£qÊ€sâ²§uâ²©â²±xâ²©z", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Phonetic", "É‘bÉ”dÉ›fÉ¡hijklmnÉ”pqrstuvwxjz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Cherokee", "á¯á‘²á£á eá¸á©á‚iá klmnoáµqá¡sá›uá‰á‡xá½z", "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    ("Squares", "ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰", "ğŸ„°ğŸ„±ğŸ„²ğŸ„³ğŸ„´ğŸ„µğŸ„¶ğŸ„·ğŸ„¸ğŸ„¹ğŸ„ºğŸ„»ğŸ„¼ğŸ„½ğŸ„¾ğŸ„¿ğŸ…€ğŸ…ğŸ…‚ğŸ…ƒğŸ…„ğŸ……ğŸ…†ğŸ…‡ğŸ…ˆğŸ…‰"),
    ("Script", "ğ’¶ğ’·ğ’¸ğ’¹â„¯ğ’»â„Šğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒâ„´ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“", "ğ’œâ„¬ğ’ğ’Ÿâ„°â„±ğ’¢â„‹â„ğ’¥ğ’¦â„’â„³ğ’©ğ’ªğ’«ğ’¬â„›ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ"),
    ("Bold Italic", "ğ™–ğ™—ğ™˜ğ™™ğ™šğ™›ğ™œğ™ğ™ğ™Ÿğ™ ğ™¡ğ™¢ğ™£ğ™¤ğ™¥ğ™¦ğ™§ğ™¨ğ™©ğ™ªğ™«ğ™¬ğ™­ğ™®ğ™¯", "ğ˜¼ğ˜½ğ˜¾ğ˜¿ğ™€ğ™ğ™‚ğ™ƒğ™„ğ™…ğ™†ğ™‡ğ™ˆğ™‰ğ™Šğ™‹ğ™Œğ™ğ™ğ™ğ™ğ™‘ğ™’ğ™“ğ™”ğ™•"),
    ("Fraktur", "ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·", "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨"),
    ("Bubbles Small", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“â“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©", "â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“â“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©"),
    ("Bold", "ğ—®ğ—¯ğ—°ğ—±ğ—²ğ—³ğ—´ğ—µğ—¶ğ—·ğ—¸ğ—¹ğ—ºğ—»ğ—¼ğ—½ğ—¾ğ—¿ğ˜€ğ˜ğ˜‚ğ˜ƒğ˜„ğ˜…ğ˜†ğ˜‡", "ğ—”ğ—•ğ—–ğ——ğ—˜ğ—™ğ—šğ—›ğ—œğ—ğ—ğ—Ÿğ— ğ—¡ğ—¢ğ—£ğ—¤ğ—¥ğ—¦ğ—§ğ—¨ğ—©ğ—ªğ—«ğ—¬ğ—­")
]
FONTS_RU = [
    ("Normal", None, None),
    ("ğŒ¿Ïá§á¥´á´›á§á¥”", "Ğá¥² Ğ‘Î´ Ğ’Ê™ ğŒ²á´¦ Ğ”Ğ´ Ğ•á¥± Ã‹Ã« Ğ–Ğ¶ Ğ—á¤‹ Ğ˜á¥™ Ğ™á¥” ğŒºÎº ğŒ¡á§˜ ğŒ‘â²™ ğ‹Ğ½ ğŒá§ ğŒ¿á¥° Ğ Ï ğ‘€á¥´ Ğ¢á´› Ğ£Ñƒ Ğ¤É¸ ğŒ—Ñ… Ğ¦Ñ† Ğ©Ñ‰ Ğ¨É¯ Ô¿Ñ‡ Ğ¬ÑŒ Ğ«Ñ‹ ĞªÑŠ Ğ­Ï¶ Ğ®Ñ Ğ¯Ñ", None),
    ("ğ‹ê¤•ê¤€ê¤’àª–àªªàªàª–ê¤‡", "ğŒ€ê¤Œ à¦šê¤’ ğŒ±ê¤ Ğ“ê¤… ğ‘€¥áƒ› Î£ê¤• Ã‹Ã« ğŒŸğŒŸ áŠ•à¤‰ ğŒµê¤£ ğŒµê¤‡ ğŒºÓ„ ğŒ¡ğŒ» ğŒ‘ğŒ¼ ğ‹àª ğŒê¤€ ğŒ¿ê¤™ á•ˆÑ€ ğ‘€—ê¤ ğŒ•á‰° ğ…Î³ ğŒ˜Ï• ğŒ—ğ‘€‹ Ô±ê¤Ÿ ğŒ¸àµ° ğŒ¸Ï‰ Ô¿àªª áˆ«ğ‘€¨ áˆàª– ĞªÑŠ ğŒ„á¤‹ ğŒğŒàª³ ğŒ“ê¤", None),
    ("Í¶Ó¡ÉÎ¼Î»Î¼Ï²Ï„Æ…É©Ï", "Î‘Î± Ò”Î´ Î’É Ó¶Ó· ğ‘€É  Î¾Îµ Ã‹Ã« ÑªÑ« Ó Ó¡ Í¶Î¼ Ó¢Ï ÓƒÓ„ Î›Î» ÏºÏ» Î—Ï° ÎŸÏƒ Î·Î· Ï·Ï ğ‘€Ï² Í²Ï„ áˆƒÎ³ Î¦Ï• Ó¼Ï‡ ĞÒµ Î¨Ïˆ Î¨Ï‰ Ï¤É¥ áÆ… â„”Æ…É© ĞªÑŠ Ï¿Ï¶ Ñ¤àª¬ ğ‰o", None)
]

ALL_FONTS = [("ğŸ‡¬ğŸ‡§ English", None, None)] + FONTS_EN + [("ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹", None, None)] + FONTS_RU

class RunnableImpl(dynamic_proxy(Runnable)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def run(self):
        try: self.func()
        except Exception as e: log(f"Error in Runnable: {e}")

class ClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def onClick(self, view):
        try: self.func(view)
        except Exception as e: log(f"Click Error: {e}")

class LayoutListener(dynamic_proxy(View.OnLayoutChangeListener)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    
    def onLayoutChange(self, v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom):
        self.callback()
class FontMagicPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.hooks = []
        self.active_font = None # (lower_map, upper_map) or None
        self.is_formatting = False # Recursion guard

    def on_plugin_load(self):
        try:
            self.add_on_send_message_hook()
            self._hook_chat_activity()
            self.log("UI Hooks installed successfully!")
        except Exception as e:
            self.log(f"Error loading plugin: {e}")
            self.log(traceback.format_exc())

    def on_plugin_unload(self):
        self.hooks.clear()

    def create_settings(self):
        idx = self.get_setting("auto_font_style", 0)
        display_name = "Normal"
        if 0 <= idx < len(ALL_FONTS):
            name, l, u = ALL_FONTS[idx]
            if l is None and u is None and name != "Normal":
                display_name = name
            else:
                display_name = self.convert_string(name, l, u)

        ui_modes = ["Ğ¡Ğ¿Ñ€Ğ°ÑˆĞ¸Ğ²Ğ°Ñ‚ÑŒ (ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸)", "ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğµ", "Ğ ÑƒÑÑĞºĞ¸Ğµ", "Ğ’ÑĞµ ÑĞ¿Ğ¸ÑĞºĞ¾Ğ¼"]

        return [
            Header("ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸"),
            Switch(key="enable_auto_font", text="ĞĞ²Ñ‚Ğ¾-Ğ·Ğ°Ğ¼ĞµĞ½Ğ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ", subtext="ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¼ĞµĞ½ÑÑ‚ÑŒ ÑˆÑ€Ğ¸Ñ„Ñ‚ Ğ½Ğ° Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ½Ğ¸Ğ¶Ğµ Ğ¿Ñ€Ğ¸ Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ¸Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ", default=False, icon="msg_send"),
            Text(text=f"Ğ¨Ñ€Ğ¸Ñ„Ñ‚: {display_name}", icon="msg_edit", on_click=self._open_font_selector),
            Header("Ğ˜Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ"),
            Switch(key="persist_font", text="Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑÑ‚ÑŒ Ğ²Ñ‹Ğ±Ğ¾Ñ€", subtext="ĞĞµ ÑĞ±Ñ€Ğ°ÑÑ‹Ğ²Ğ°Ñ‚ÑŒ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ² Ğ¼ĞµĞ½Ñ ÑˆÑ€Ğ¸Ñ„Ñ‚ Ğ¿Ğ¾ÑĞ»Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸", default=False, icon="msg_edit"),
            Selector(key="ui_default_mode", text="Ğ ĞµĞ¶Ğ¸Ğ¼ Ğ¼ĞµĞ½Ñ", items=ui_modes, default=0, icon="msg_list"),
            Text(text="ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ñ‡Ñ‘Ñ€Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¿Ğ¸ÑĞºĞ°", icon="msg_block", on_click=self._open_blacklist_manager)
        ]
    def _open_font_selector(self, view):
        fragment = get_last_fragment()
        context = fragment.getParentActivity() if fragment else None
        if not context: return

        builder = AlertDialogBuilder(context)
        builder.set_title("Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑˆÑ€Ğ¸Ñ„Ñ‚")

        scroll = ScrollView(context)
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        scroll.addView(container)

        def add_header(text):
            tv = TextView(context)
            tv.setText(text)
            tv.setTextSize(14)
            tv.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            tv.setTypeface(Typeface.DEFAULT_BOLD)
            tv.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(15), AndroidUtilities.dp(20), AndroidUtilities.dp(5))
            container.addView(tv)

        dialog_ref = [None]

        def update_ui_text(new_text):
            if not view: return
            def set_text_recursive(v):
                if isinstance(v, TextView):
                    v.setText(new_text)
                elif isinstance(v, ViewGroup):
                    for i in range(v.getChildCount()):
                        set_text_recursive(v.getChildAt(i))
            try:
                set_text_recursive(view)
            except: pass

        def add_font_item(name, lower, upper, global_index):
            styled_name = self.convert_string(name, lower, upper)
            
            tv = TextView(context)
            tv.setTextSize(16)
            tv.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(12), AndroidUtilities.dp(20), AndroidUtilities.dp(12))
            tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            tv.setText(styled_name)
            
            bg = GradientDrawable()
            bg.setColor(0x00000000) 
            pressed = Theme.getColor(Theme.key_listSelector)
            csl = ColorStateList([jarray(jint)([])], jarray(jint)([pressed]))
            ripple = RippleDrawable(csl, bg, None)
            tv.setBackground(ripple)

            def on_item_click(v):
                self.set_setting("auto_font_style", global_index)
                update_ui_text(f"Ğ¨Ñ€Ğ¸Ñ„Ñ‚: {styled_name}")
                if dialog_ref[0]:
                    dialog_ref[0].dismiss()
            
            tv.setOnClickListener(ClickListener(on_item_click))
            container.addView(tv)

        add_header("ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğµ")
        # ALL_FONTS indices: 0=Header, 1..len(EN)=EN, len(EN)+1=Header, len(EN)+2..=RU
        start_en = 1
        for i, (name, lower, upper) in enumerate(FONTS_EN):
            add_font_item(name, lower, upper, start_en + i)

        add_header("Ğ ÑƒÑÑĞºĞ¸Ğµ")
        start_ru = start_en + len(FONTS_EN) + 1
        for i, (name, lower, upper) in enumerate(FONTS_RU):
            add_font_item(name, lower, upper, start_ru + i)

        builder.set_view(scroll)
        builder.set_negative_button("ĞÑ‚Ğ¼ĞµĞ½Ğ°", None)
        dialog_ref[0] = builder.show()

    def _open_blacklist_manager(self, view):
        blacklist_str = self.get_setting("blacklist", "")
        blacklist = set(x.strip().lower() for x in blacklist_str.split(",") if x.strip())

        fragment = get_last_fragment()
        context = fragment.getParentActivity() if fragment else None
        if not context: return

        builder = AlertDialogBuilder(context)
        builder.set_title("Ğ§ĞµÑ€Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ¾Ğ²")

        scroll = ScrollView(context)
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        scroll.addView(container)

        def add_header(text):
            tv = TextView(context)
            tv.setText(text)
            tv.setTextSize(14)
            tv.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            tv.setTypeface(Typeface.DEFAULT_BOLD)
            tv.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(15), AndroidUtilities.dp(20), AndroidUtilities.dp(5))
            container.addView(tv)

        def add_font_item(name, lower, upper):
            is_bl = name.lower() in blacklist
            styled_name = self.convert_string(name, lower, upper)
            
            tv = TextView(context)
            tv.setTextSize(16)
            tv.setPadding(AndroidUtilities.dp(20), AndroidUtilities.dp(12), AndroidUtilities.dp(20), AndroidUtilities.dp(12))
            tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            tv.setText(f"{styled_name} ğŸ’”" if is_bl else styled_name)
            
            # Ripple for touch feedback
            bg = GradientDrawable()
            bg.setColor(0x00000000) 
            pressed = Theme.getColor(Theme.key_listSelector)
            csl = ColorStateList([jarray(jint)([])], jarray(jint)([pressed]))
            ripple = RippleDrawable(csl, bg, None)
            tv.setBackground(ripple)

            def on_item_click(v, n=name):
                # Animation
                v.animate().scaleX(1.02).scaleY(1.02).setDuration(100).setInterpolator(DecelerateInterpolator()).withEndAction(
                    RunnableImpl(lambda: v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).setInterpolator(DecelerateInterpolator()).start())
                ).start()

                l_name = n.lower()
                if l_name in blacklist:
                    blacklist.remove(l_name)
                    v.setText(styled_name)
                else:
                    blacklist.add(l_name)
                    v.setText(f"{styled_name} ğŸ’”")
                
                self.set_setting("blacklist", ",".join(blacklist))
            
            tv.setOnClickListener(ClickListener(on_item_click))
            container.addView(tv)

        add_header("ĞĞ½Ğ³Ğ»Ğ¸Ğ¹ÑĞºĞ¸Ğµ")
        for name, lower, upper in FONTS_EN:
            add_font_item(name, lower, upper)

        add_header("Ğ ÑƒÑÑĞºĞ¸Ğµ")
        for name, lower, upper in FONTS_RU:
            add_font_item(name, lower, upper)

        builder.set_view(scroll)
        builder.set_positive_button("Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾", None)
        builder.show()

    def _hook_chat_activity(self):
        try:
            # Use JClass.forName to get the actual Java class object for reflection
            chat_activity_cls = JClass.forName("org.telegram.ui.ChatActivity")
            if chat_activity_cls:
                resume_method = chat_activity_cls.getDeclaredMethod("onResume")
                resume_method.setAccessible(True)
                self.hook_method(resume_method, self.ChatActivityResumeHook(self))
                self.log("Hooked ChatActivity.onResume")
        except Exception as e:
            self.log(f"Failed to hook ChatActivity: {e}")

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not self.get_setting("enable_auto_font", False):
            return HookResult()
        
        try:
            idx = self.get_setting("auto_font_style", 0)
            if not (0 <= idx < len(ALL_FONTS)):
                return HookResult()
            
            _, lower, upper = ALL_FONTS[idx]
            # Skip headers
            if lower is None and upper is None and " " in ALL_FONTS[idx][0] and "Normal" not in ALL_FONTS[idx][0]:
                return HookResult()

            modified = False

            # Handle standard message text
            if hasattr(params, "message") and isinstance(params.message, str) and params.message:
                new_msg = self.convert_string(params.message, lower, upper)
                if new_msg != params.message:
                    params.message = new_msg
                    modified = True
            
            # Handle caption (for media/files)
            if hasattr(params, "caption") and isinstance(params.caption, str) and params.caption:
                new_cap = self.convert_string(params.caption, lower, upper)
                if new_cap != params.caption:
                    params.caption = new_cap
                    modified = True
            
            if modified:
                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception as e:
            self.log(f"Auto-font error: {e}")
        
        return HookResult()
    def _setup_ui(self, activity):
        try:
            enter_view = get_private_field(activity, "chatActivityEnterView")
            if not enter_view: return
            
            parent_view = enter_view.getParent()
            if not parent_view: return

            # Prevent duplicate injection
            if enter_view.findViewWithTag("font_magic_btn"): return

            edit_text = self._find_edit_text(enter_view)
            if not edit_text: return

            context = activity.getParentActivity() or activity

            # --- 1. The 'A' Button (Inside EnterView) ---
            btn = TextView(context)
            btn.setTag("font_magic_btn")
            btn.setText("A")
            btn.setTextSize(24)
            btn.setTypeface(Typeface.DEFAULT, Typeface.BOLD)
            btn.setTextColor(Theme.getColor(Theme.key_chat_messagePanelIcons))
            btn.setShadowLayer(4.0, 0.0, 0.0, 0x40000000) 
            btn.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
            btn.setVisibility(View.GONE)

            btn_params = FrameLayout.LayoutParams(-2, -2)
            btn_params.gravity = Gravity.RIGHT | Gravity.BOTTOM
            btn_params.rightMargin = AndroidUtilities.dp(62)
            btn_params.bottomMargin = AndroidUtilities.dp(10)
            enter_view.addView(btn, btn_params)

            # --- 2. The Font Bar (Attached to Parent to fix touch events) ---
            font_bar = self._create_font_bar(context, enter_view, edit_text)
            font_bar.setTag("font_magic_bar")
            font_bar.setVisibility(View.GONE)
            
            bar_params = FrameLayout.LayoutParams(-1, AndroidUtilities.dp(SELECTOR_HEIGHT))
            bar_params.gravity = Gravity.BOTTOM | Gravity.LEFT
            
            # Add to parent (SizeNotifierFrameLayout) to ensure it receives touches
            # when positioned above the input field
            parent_view.addView(font_bar, bar_params)

            # --- 3. Positioning Logic ---
            def update_bar_position():
                try:
                    if font_bar.getVisibility() == View.VISIBLE:
                        # Move bar to exactly top of enter_view
                        # The user wants SELECTOR_OFFSET_Y = -44. 
                        # If we assume -44 means "44dp above standard position", we treat it as an offset.
                        # Base position (Gravity.BOTTOM) is 0.
                        # We shift up by enter_view height.
                        
                        # Calculate effective Y translation
                        # If SELECTOR_OFFSET_Y is -44, we want it 44dp *above* the input? 
                        # Or does -44 just mean "Above"?
                        # Let's align it to the TOP of enter_view, then apply offset.
                        
                        h = enter_view.getHeight()
                        # If h is 0 (not laid out), wait.
                        if h == 0: return

                        # Shift up by height of input bar + extra offset
                        # We add 44 to SELECTOR_OFFSET_Y to normalize it if the user intended -44 to be the *total* shift from a "zero" point.
                        # But simplest is: Base = -h. Plus User Offset.
                        offset = AndroidUtilities.dp(SELECTOR_OFFSET_Y)
                        
                        # Correction: User likely wants it *just* above. 
                        # If SELECTOR_OFFSET_Y is -44, and we just use that, it might be inside the view.
                        # Let's assume standard behavior: Sit on top edge.
                        # Y = -height.
                        # + Offset.
                        # To make -44 meaningful as "just above", we probably need to ignore it and use -height,
                        # OR assume the user tweaked it for the previous broken layout.
                        # Let's stick to reliable positioning: Just above EnterView.
                        
                        # USE MARGINS instead of TranslationY to fix touch issues
                        p = font_bar.getLayoutParams()
                        # Base margin is height of enter_view + user offset adjustment
                        # We want it to sit on top of enter_view. 
                        # EnterView is at bottom. FontBar is at bottom.
                        # FontBar bottom margin = EnterView height.
                        
                        new_margin = h + AndroidUtilities.dp(SELECTOR_OFFSET_Y + 44) # Normalize -44 to 0
                        # Wait, user set -44. If we want it "Just above", margin should be `h`.
                        # If user wants to tweak, we add offset.
                        # Let's interpret SELECTOR_OFFSET_Y = -44 as "Standard Position (0)" for this logic correction,
                        # or just apply the raw value relative to the top of input?
                        
                        # Let's trust the margin logic: 
                        # Margin = Height of Input View.
                        # This places it exactly on top edge.
                        # If user wants it higher, they increase margin.
                        
                        p.bottomMargin = h
                        font_bar.setLayoutParams(p)
                except: pass

            # Keep position synced when input grows (multiline)
            enter_view.addOnLayoutChangeListener(LayoutListener(update_bar_position))
            
            # Initial Update
            enter_view.post(RunnableImpl(update_bar_position))

            # --- 4. Logic ---
            def toggle_bar(v):
                if font_bar.getVisibility() == View.VISIBLE:
                    font_bar.setVisibility(View.GONE)
                else:
                    font_bar.setVisibility(View.VISIBLE)
                    update_bar_position()
            btn.setOnClickListener(ClickListener(toggle_bar))

            class TextListener(dynamic_proxy(TextWatcher)):
                def __init__(self, plugin, button, bar, edit_text):
                    super().__init__()
                    self.plugin = plugin
                    self.btn = button
                    self.bar = bar
                    self.edit_text = edit_text
                
                def beforeTextChanged(self, s, start, count, after): pass
                
                def onTextChanged(self, s, start, before, count):
                    # Live Formatting: Replace typed characters
                    if self.plugin.active_font and not self.plugin.is_formatting and count > 0:
                        try:
                            self.plugin.is_formatting = True
                            # Get the newly added text segment
                            # Note: 's' is the CharSequence AFTER the change.
                            # 'start' is where the new text started.
                            # 'count' is how many characters were added.
                            
                            # We only want to process the *new* part to avoid re-processing the whole text constantly
                            # causing lag on long messages.
                            new_text_sub = s.subSequence(start, start + count).toString()
                            
                            lower, upper = self.plugin.active_font
                            converted = self.plugin.convert_string(new_text_sub, lower, upper)
                            
                            if converted != new_text_sub:
                                s.replace(start, start + count, converted)
                        except Exception as e:
                            log(f"Live Format Error: {e}")
                        finally:
                            self.plugin.is_formatting = False
                
                def afterTextChanged(self, s):
                    try:
                        length = s.length() if s else 0
                        has_text = length > 0
                        self.btn.setVisibility(View.VISIBLE if has_text else View.GONE)
                        
                        if has_text:
                            # Transparency for long text (> 8 chars)
                            self.btn.setAlpha(0.25 if length > 8 else 1.0)

                        if not has_text:
                            self.bar.setVisibility(View.GONE)
                            if not self.plugin.get_setting("persist_font", False):
                                self.plugin.active_font = None
                    except Exception as e:
                        log(f"TextWatcher Error: {e}")

            edit_text.addTextChangedListener(TextListener(self, btn, font_bar, edit_text))
            self.log("Font Magic UI initialized")

        except Exception as e:
            log(f"Error setting up UI: {e}")

    def _create_font_bar(self, context, enter_view, edit_text):
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_chat_messagePanelBackground))
        container.setElevation(AndroidUtilities.dp(4))
        container.setClickable(True)
        container.setFocusable(True)
        
        # Scroll wrapper
        HorizontalScrollViewCls = find_class("android.widget.HorizontalScrollView")
        scroll = HorizontalScrollViewCls(context)
        scroll.setHorizontalScrollBarEnabled(False)
        
        # Content Layout (holds fonts or categories)
        content_layout = LinearLayout(context)
        content_layout.setOrientation(LinearLayout.HORIZONTAL)
        content_layout.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0)
        scroll.addView(content_layout)
        
        # Top bar for scroll
        scroll_container = LinearLayout(context)
        scroll_container.setOrientation(LinearLayout.HORIZONTAL)
        scroll_container.addView(scroll, LinearLayout.LayoutParams(0, -2, 1.0))
        
        # Close Button
        close_btn = TextView(context)
        close_btn.setText("âœ•")
        close_btn.setTextSize(16)
        close_btn.setTextColor(Theme.getColor(Theme.key_chat_messagePanelIcons))
        close_btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(6), AndroidUtilities.dp(12), AndroidUtilities.dp(6))
        close_btn.setOnClickListener(ClickListener(lambda v: (self.reset_font(), container.setVisibility(View.GONE))))
        scroll_container.addView(close_btn)
        
        container.addView(scroll_container)
        
        # Render Logic
        def render_content(mode=None):
            content_layout.removeAllViews()
            
            # Determine mode if not set
            if mode is None:
                setting_mode = self.get_setting("ui_default_mode", 0)
                if setting_mode == 0: mode = "CATEGORIES"
                elif setting_mode == 1: mode = "EN"
                elif setting_mode == 2: mode = "RU"
                else: mode = "ALL"

            # Render Categories
            if mode == "CATEGORIES":
                for cat_name, target_mode in [("ğŸ‡¬ğŸ‡§ English", "EN"), ("ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹", "RU")]:
                    btn = TextView(context)
                    btn.setText(cat_name)
                    btn.setTextSize(14)
                    btn.setTextColor(Theme.getColor(Theme.key_chat_messagePanelText))
                    btn.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                    bg = GradientDrawable()
                    bg.setCornerRadius(AndroidUtilities.dp(16))
                    bg.setColor(Theme.getColor(Theme.key_chat_inBubble))
                    btn.setBackground(bg)
                    
                    params = LinearLayout.LayoutParams(-2, -2)
                    params.rightMargin = AndroidUtilities.dp(8)
                    btn.setLayoutParams(params)
                    btn.setOnClickListener(ClickListener(lambda v, m=target_mode: render_content(m)))
                    content_layout.addView(btn)
                return

            # Render Fonts
            font_list = []
            if mode == "EN": font_list = FONTS_EN
            elif mode == "RU": font_list = FONTS_RU
            elif mode == "ALL": font_list = ALL_FONTS
            
            # Blacklist filter
            blacklist_str = self.get_setting("blacklist", "")
            blacklist = [x.strip().lower() for x in blacklist_str.split(",") if x.strip()]
            
            # Back button if we came from categories
            if self.get_setting("ui_default_mode", 0) == 0:
                back = TextView(context)
                back.setText("â¬…")
                back.setTextSize(16)
                back.setTextColor(Theme.getColor(Theme.key_chat_messagePanelText))
                back.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(6), AndroidUtilities.dp(8), AndroidUtilities.dp(6))
                back.setOnClickListener(ClickListener(lambda v: render_content("CATEGORIES")))
                content_layout.addView(back)

            for name, lower_map, upper_map in font_list:
                if lower_map is None and upper_map is None and name != "Normal": continue # Skip headers in UI
                if name.lower() in blacklist: continue
                
                chip = TextView(context)
                preview = self.convert_string(name, lower_map, upper_map)
                chip.setText(preview)
                chip.setTextSize(14)
                chip.setTextColor(Theme.getColor(Theme.key_chat_messagePanelText))
                chip.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(6), AndroidUtilities.dp(12), AndroidUtilities.dp(6))
                
                bg = GradientDrawable()
                bg.setCornerRadius(AndroidUtilities.dp(16))
                bg.setColor(Theme.getColor(Theme.key_chat_inBubble))
                pressed_color = Theme.getColor(Theme.key_featuredStickers_addButton)
                csl = ColorStateList([jarray(jint)([])], jarray(jint)([pressed_color]))
                ripple = RippleDrawable(csl, bg, None)
                chip.setBackground(ripple)
                
                params = LinearLayout.LayoutParams(-2, -2)
                params.rightMargin = AndroidUtilities.dp(8)
                chip.setLayoutParams(params)
                
                def on_font_click(v, l=lower_map, u=upper_map):
                    self.active_font = (l, u)
                    v.animate().scaleX(1.1).scaleY(1.1).setDuration(100).withEndAction(
                        RunnableImpl(lambda: v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start())
                    ).start()
                    
                    if edit_text and edit_text.getText():
                        self.is_formatting = True
                        try:
                            editable = edit_text.getText()
                            raw_text = editable.toString()
                            if raw_text:
                                converted = self.convert_string(raw_text, l, u)
                                if converted != raw_text:
                                    editable.replace(0, editable.length(), converted)
                        finally:
                            self.is_formatting = False

                chip.setOnClickListener(ClickListener(on_font_click))
                content_layout.addView(chip)

        # Initial Render
        render_content()
        return container

    class ChatActivityResumeHook(MethodHook):
        def __init__(self, plugin):
            self.plugin = plugin
        
        def after_hooked_method(self, param):
            activity = param.thisObject
            run_on_ui_thread(lambda: self.plugin._setup_ui(activity))


    def reset_font(self):
        self.active_font = None

    def _find_edit_text(self, view):
        if not view: return None
        
        # 1. Try direct accessor (best for Telegram components)
        try:
            if hasattr(view, "getEditField"):
                f = view.getEditField()
                if f: return f
        except: pass

        # 2. Check class name
        try:
            cls_name = str(view.getClass().getName())
            if "EditText" in cls_name:
                return view
            
            # 3. Traverse children (Duck typing for ViewGroup)
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    child = view.getChildAt(i)
                    res = self._find_edit_text(child)
                    if res: return res
        except: pass
        
        return None

    def _find_enter_view(self, fragment):
        try:
            v = get_private_field(fragment, "chatActivityEnterView")
            if v: return v
        except: pass
        try:
            return self._find_view_by_class_name(fragment.getFragmentView(), "ChatActivityEnterView")
        except: return None

    def _find_view_by_class_name(self, view, class_name_part):
        if not view: return None
        try:
            if class_name_part in str(view.getClass().getName()):
                return view
            
            if hasattr(view, "getChildCount") and hasattr(view, "getChildAt"):
                count = view.getChildCount()
                for i in range(count):
                    res = self._find_view_by_class_name(view.getChildAt(i), class_name_part)
                    if res: return res
        except: pass
        return None
    def convert_string(self, text, lower_map, upper_map):
        if not lower_map and not upper_map:
            return text

        # Lazy parsing of Cyrillic font strings
        rus_dict = None
        if isinstance(lower_map, str) and upper_map is None and " " in lower_map:
            # Treat as Cyrillic mapping string
            rus_dict = self._parse_rus_map(lower_map)

        # Standard Transliteration Map
        rus_translit = {
            'Ğ°':'a','Ğ±':'b','Ğ²':'v','Ğ³':'g','Ğ´':'d','Ğµ':'e','Ñ‘':'e','Ğ¶':'zh','Ğ·':'z','Ğ¸':'i',
            'Ğ¹':'y','Ğº':'k','Ğ»':'l','Ğ¼':'m','Ğ½':'n','Ğ¾':'o','Ğ¿':'p','Ñ€':'r','Ñ':'s','Ñ‚':'t',
            'Ñƒ':'u','Ñ„':'f','Ñ…':'h','Ñ†':'c','Ñ‡':'ch','Ñˆ':'sh','Ñ‰':'sh','ÑŠ':'','Ñ‹':'y','ÑŒ':'',
            'Ñ':'e','Ñ':'yu','Ñ':'ya',
            'Ğ':'A','Ğ‘':'B','Ğ’':'V','Ğ“':'G','Ğ”':'D','Ğ•':'E','Ğ':'E','Ğ–':'ZH','Ğ—':'Z','Ğ˜':'I',
            'Ğ™':'Y','Ğš':'K','Ğ›':'L','Ğœ':'M','Ğ':'N','Ğ':'O','ĞŸ':'P','Ğ ':'R','Ğ¡':'S','Ğ¢':'T',
            'Ğ£':'U','Ğ¤':'F','Ğ¥':'H','Ğ¦':'C','Ğ§':'CH','Ğ¨':'SH','Ğ©':'SH','Ğª':'','Ğ«':'Y','Ğ¬':'',
            'Ğ­':'E','Ğ®':'YU','Ğ¯':'YA'
        }

        result = []
        for char in text:
            # 1. Check direct Cyrillic Map first (if active)
            if rus_dict and char in rus_dict:
                result.append(rus_dict[char])
                continue
            
            # 2. Transliterate for Latin fonts
            # Only transliterate if we have Latin maps and NO custom dict found for this char
            if not rus_dict:
                char_to_process = rus_translit.get(char, char)
            else:
                char_to_process = char

            # 3. Apply Latin Maps
            c = char_to_process
            processed = False
            
            if 'a' <= c <= 'z' and lower_map and not rus_dict:
                index = ord(c) - ord('a')
                if index < len(lower_map):
                    result.append(lower_map[index])
                    processed = True
            
            elif 'A' <= c <= 'Z' and upper_map and not rus_dict:
                index = ord(c) - ord('A')
                if index < len(upper_map):
                    result.append(upper_map[index])
                    processed = True

            if not processed:
                result.append(c)
        
        return "".join(result)

    def _parse_rus_map(self, map_str):
        # Parses "Ğá¥² Ğ‘Î´ ..." into dict
        # Assumes standard alphabet order for missing chars or explicit mapping?
        # The user provided string seems to contain explicit pairs or mapped chars.
        # Strategy: Split by space. For each chunk, map to RUS_UPPER[i] and RUS_LOWER[i].
        
        mapping = {}
        parts = [p for p in map_str.split(" ") if p]
        
        # Map to standard alphabet
        # Note: The user provided strings vary in length. 
        # We will iterate through available parts and map them to standard RUS chars.
        for i, part in enumerate(parts):
            if i >= len(RUS_UPPER): break
            
            std_u = RUS_UPPER[i]
            std_l = RUS_LOWER[i]
            
            # Part is like "Ğá¥²" (Upper+Lower) or just chars.
            # We blindly split the part in half if length is even, or just take chars.
            # Let's assume char 0 is Upper replacement, char 1 is Lower replacement.
            if len(part) >= 2:
                # First char is replacement for Upper, remaining for Lower?
                # Actually some parts are 3 chars? "ğŒºÎº" (2). "ğŒ¡á§˜" (2).
                # Let's handle 2 chars.
                mapping[std_u] = part[0]
                mapping[std_l] = part[1:]
            else:
                # Fallback
                mapping[std_u] = part
                mapping[std_l] = part
        
        return mapping
