"""
 _____                                                             _____ 
( ___ )-----------------------------------------------------------( ___ )
 |   |                                                             |   | 
 |   | _ _ _ _ ___ _  _    _    ____ _  _ ____    ___  _   _       |   | 
 |   | | | | |  |  |__|    |    |  | |  | |___    |__]  \_/        |   | 
 |   | |_|_| |  |  |  |    |___ |__|  \/  |___    |__]   |         |   | 
 |   |                                                             |   | 
 |   | _  _ _ _  _ ____ _ _    _  _ ____ ___ ____ _  _ ____ _  _ _ |   | 
 |   | |\/| | |__| |__| | |    |_/  |  |  |  |  | |  | [__  |_/  | |   | 
 |   | |  | | |  | |  | | |___ | \_ |__|  |  |__|  \/  ___] | \_ | |   | 
 |___|                                                             |___| 
(_____)-----------------------------------------------------------(_____)

Копирование кода без указания авторства является публичным неуважением к работе @mihailkotovski
"""

__id__ = "inlinetools"
__name__ = "Inline Tools"
__description__ = "Локальная админ-панель с inline-кнопками"
__author__ = "@mihailkotovski & @mishabotov"
__version__ = "2.0.0"
__icon__ = "DateRegBot_by_MoiStikiBot/19"

import random
import threading
import time
import json
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from base_plugin import BasePlugin, HookResult, HookStrategy, MethodHook
from android_utils import OnClickListener, run_on_ui_thread, R as Runnable
from client_utils import (
    RequestCallback,
    get_last_fragment,
    get_messages_controller,
    get_user_config,
    run_on_queue,
    send_request,
)
from hook_utils import find_class, get_private_field
from markdown_utils import parse_markdown
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Header, Divider, Switch, Input, Selector

from java.util import ArrayList
from java import jclass
from java.lang import Class as JClass, Float as JFloat, Integer as JInt

from org.telegram.messenger import AndroidUtilities, ChatObject, MessageObject, UserObject
from org.telegram.tgnet import TLRPC


_CALLBACK_PREFIX = "exadm:"

_PAGE_MAIN = "main"
_PAGE_BAN = "ban"
_PAGE_MUTE = "mute"
_PAGE_WARN = "warn"
_PAGE_DELETE = "delete"

_WARNS_STATE_KEY = "warns_state_v1"
_WARNS_MAX_ENTRIES = 2000
_INT32_MAX = 2_147_483_647
_CUSTOM_TIME_MAX_SECONDS = 365 * 24 * 60 * 60


@dataclass
class _PanelContext:
    dialog_id: int
    user_ids: List[int]
    page: str
    created_at: float


class _InlineButtonHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin", is_long: bool = False):
        self._plugin = plugin
        self._is_long = is_long

    def before_hooked_method(self, param):
        try:
            cell = param.args[0] if param.args and len(param.args) > 0 else None
            btn = param.args[1] if param.args and len(param.args) > 1 else None
            self._plugin._handle_inline_button_click(cell, btn, param, is_long=self._is_long)
        except Exception as e:
            try:
                self._plugin.log(f"[inlinetools] inline hook error: {e}")
            except Exception:
                pass


class _UserAvatarLongPressHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        try:
            self._plugin._handle_user_avatar_long_press(param)
        except Exception:
            pass

    def after_hooked_method(self, param):
        try:
            self._plugin._after_user_avatar_long_press(param)
        except Exception:
            pass


class _ItemOptionsMakeOptionsHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        return

    def after_hooked_method(self, param):
        try:
            self._plugin._maybe_inject_inline_menu_into_item_options(param)
        except Exception:
            pass


class _AvatarPreviewerLayoutSetDataHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        return

    def after_hooked_method(self, param):
        try:
            self._plugin._maybe_inject_inline_menu_into_avatar_previewer_layout(param)
        except Exception:
            pass


class _AvatarPreviewerLayoutSetShowingHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        return

    def after_hooked_method(self, param):
        try:
            self._plugin._maybe_clear_avatar_previewer_ctx(param)
        except Exception:
            pass


class _ChatMessageCellTouchHook(MethodHook):
    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if param.args and len(param.args) > 0 else None
            if motion_event is None:
                return
            self._plugin._record_touch(param.thisObject, motion_event)
        except Exception:
            pass

    def after_hooked_method(self, param):
        return


class _InlineToolsSettingsHeaderHook(MethodHook):
    """
    Вставляет кастомный хедер.

    Основано на подходе из FocusMode.plugin (hook PluginSettingsActivity.fillItems + custom header view)
    спасибо: t.me/exteraDevPlugins
    """

    def __init__(self, plugin: "InlineToolsPlugin"):
        self._plugin = plugin

    def before_hooked_method(self, param):
        return

    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0]
            if not items or items.size() == 0:
                return

            plugin_obj = get_private_field(activity, "plugin")
            if not plugin_obj or str(plugin_obj.getId()) != __id__:
                return

            callback = get_private_field(activity, "createSubFragmentCallback")
            if callback is not None:
                return

            header = self._plugin._create_settings_header_view(activity.getContext())
            if not header:
                return

            from org.telegram.ui.Components import UItem

            try:
                from com.exteragram.messenger.plugins.models import HeaderSetting
                item = UItem.asCustom(header)
                item.settingItem = HeaderSetting(f"{__id__}_header")
            except Exception:
                item = UItem.asCustom(header)

            try:
                item.setTransparent(True)
            except Exception:
                pass

            items.add(0, item)
        except Exception:
            pass


class InlineToolsPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._unhooks: List[Any] = []
        self._panels: Dict[str, _PanelContext] = {}
        self._touch_unhook: Optional[Any] = None
        self._last_touch: Optional[Tuple[float, float, float, float]] = None
        self._last_touch_cell: Optional[Any] = None
        self._launch_activity_jclass = None
        self._make_ripple_static = None
        self._make_ripple_method = None
        self._avatar_menu_hooks_installed: bool = False
        self._avatar_menu_pending_ctx: Optional[Tuple[Any, Any, float]] = None
        self._avatar_previewer_layout: Optional[Any] = None
        self._avatar_previewer_ctx: Optional[Tuple[Any, Any, float]] = None
        self._warns: Dict[str, int] = {}
        try:
            self._warns = self._load_warns_state()
        except Exception:
            self._warns = {}


    def on_plugin_load(self):
        self.add_on_send_message_hook(priority=50)
        self._install_settings_header_hook()
        self._init_ripple()
        self._install_touch_hook()
        self._install_inline_button_hooks()

    def on_plugin_unload(self):
        for unhook in list(self._unhooks):
            try:
                self.unhook_method(unhook)
            except Exception:
                pass
        self._unhooks.clear()
        if self._touch_unhook:
            try:
                self.unhook_method(self._touch_unhook)
            except Exception:
                pass
        self._touch_unhook = None
        self._panels.clear()

    def _install_settings_header_hook(self):
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if not PSA:
                return
            method = PSA.getClass().getDeclaredMethod(
                "fillItems",
                find_class("java.util.ArrayList"),
                find_class("org.telegram.ui.Components.UniversalAdapter"),
            )
            method.setAccessible(True)
            unhook = self.hook_method(method, _InlineToolsSettingsHeaderHook(self))
            if unhook:
                self._unhooks.append(unhook)
        except Exception:
            pass

    def _open_extera_dev_plugins(self):
        try:
            run_on_ui_thread(lambda: get_messages_controller().openByUserName("mishabotov", get_last_fragment(), 1))
        except Exception:
            pass

    def _create_settings_header_view(self, context):
        try:
            from android.util import TypedValue
            from android.view import Gravity
            from android.widget import FrameLayout, LinearLayout, TextView

            from org.telegram.messenger import AndroidUtilities, MessagesController, UserConfig
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.ui.Components import AvatarDrawable, BackupImageView, LayoutHelper

            container = FrameLayout(context)
            content = LinearLayout(context)
            content.setOrientation(LinearLayout.VERTICAL)

            user = None
            try:
                account = int(getattr(UserConfig, "selectedAccount", 0))
                mc = MessagesController.getInstance(account)
                uc = UserConfig.getInstance(account)
                if mc and uc:
                    user = mc.getUser(uc.getClientUserId())
            except Exception:
                user = None

            if user:
                img = BackupImageView(context)
                img.setRoundRadius(AndroidUtilities.dp(40))
                img.setForUserOrChat(user, AvatarDrawable(user))
                try:
                    img.setOnClickListener(OnClickListener(lambda v: self._open_extera_dev_plugins()))
                except Exception:
                    pass
                content.addView(img, LayoutHelper.createLinear(100, 100, Gravity.CENTER_HORIZONTAL, 0, 24, 0, 16))

            first = getattr(user, "first_name", None) if user else None
            last = getattr(user, "last_name", None) if user else None
            full_name = " ".join([p for p in (first, last) if p]) or "User"
            username = getattr(user, "username", None) if user else None
            user_id = getattr(user, "id", None) if user else None

            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
            try:
                title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            except Exception:
                pass
            title.setGravity(Gravity.CENTER)
            title.setText(f"Привет, {full_name}")
            content.addView(title, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_HORIZONTAL, 16, 0, 16, 4))

            subtitle = TextView(context)
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitle.setGravity(Gravity.CENTER)
            subtitle.setText("Администрирование: локальная панель (мут/бан/варны/кик/удаление)")
            content.addView(subtitle, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_HORIZONTAL, 24, 0, 24, 8))

            if username or user_id:
                acc = TextView(context)
                acc.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                acc.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
                acc.setGravity(Gravity.CENTER)
                parts = []
                if username:
                    parts.append(f"@{username}")
                if user_id:
                    parts.append(f"id {int(user_id)}")
                acc.setText("Аккаунт: " + " • ".join(parts))
                content.addView(acc, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_HORIZONTAL, 24, 0, 24, 12))

            link = TextView(context)
            link.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueText))
            link.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            link.setGravity(Gravity.CENTER)
            link.setText("@mishabotov")
            try:
                link.setOnClickListener(OnClickListener(lambda v: self._open_extera_dev_plugins()))
            except Exception:
                pass
            content.addView(link, LayoutHelper.createLinear(-2, -2, Gravity.CENTER_HORIZONTAL, 24, 0, 24, 20))

            container.addView(content, LayoutHelper.createFrame(-1, -2, Gravity.CENTER))
            return container
        except Exception:
            return None

    def create_settings(self):
        enabled_val = self.get_setting("effects_enabled", True)
        if isinstance(enabled_val, bool):
            enabled = enabled_val
        else:
            enabled = str(enabled_val).strip().lower() in ("1", "true", "yes", "on")
        return [
            Header(text="Настройки плагина"),
            Switch(
                key="effects_enabled",
                text="Эффекты",
                default=enabled,
                icon="msg_settings",
            ),
            Switch(
                key="avatar_context_menu",
                text="Кнопка в меню аватара",
                default=True,
                icon="msg_folders",
            ),
            Header(text="Варны"),
            Input(
                key="warn_limit",
                text="Порог варнов",
                default="3",
                subtext="При достижении порога может выдаваться наказание",
            ),
            Selector(
                key="warn_punish_action",
                text="Наказание за порог",
                default=1,
                items=["Нет", "Мут", "Бан", "Кик"],
            ),
            Input(
                key="warn_punish_seconds",
                text="Срок наказания (сек)",
                default="3600",
                subtext="Для мута/бана. 0 для бана = навсегда",
            ),
            Switch(
                key="warn_reset_on_punish",
                text="Сбрасывать варны после наказания",
                default=True,
            ),
            Divider(text="Если выключить — переключения будут без анимации и без ripple-эффекта."),
        ]

    def _effects_enabled(self) -> bool:
        val = self.get_setting("effects_enabled", True)
        if isinstance(val, bool):
            return val
        return str(val).strip().lower() in ("1", "true", "yes", "on")

    def _avatar_context_menu_enabled(self) -> bool:
        val = self.get_setting("avatar_context_menu", True)
        if isinstance(val, bool):
            return val
        return str(val).strip().lower() in ("1", "true", "yes", "on")

    def _warn_limit(self) -> int:
        val = self.get_setting("warn_limit", "3")
        try:
            n = int(val)
        except Exception:
            n = 3
        if n < 1:
            n = 1
        if n > 20:
            n = 20
        return n

    def _warn_punish_action(self) -> int:
        val = self.get_setting("warn_punish_action", 1)
        try:
            n = int(val)
        except Exception:
            n = 1
        if n < 0 or n > 3:
            n = 1
        return n

    def _warn_punish_seconds(self) -> int:
        val = self.get_setting("warn_punish_seconds", "3600")
        try:
            n = int(val)
        except Exception:
            n = 3600
        if n < 0:
            n = 0
        if n > _CUSTOM_TIME_MAX_SECONDS:
            n = _CUSTOM_TIME_MAX_SECONDS
        return n

    def _warn_reset_on_punish(self) -> bool:
        val = self.get_setting("warn_reset_on_punish", True)
        if isinstance(val, bool):
            return val
        return str(val).strip().lower() in ("1", "true", "yes", "on")

    def _warn_punish_label(self) -> str:
        a = self._warn_punish_action()
        if a == 1:
            return "мут"
        if a == 2:
            return "бан"
        if a == 3:
            return "кик"
        return "нет"

    def _warn_key(self, dialog_id: int, user_id: int) -> str:
        return f"{int(dialog_id)}:{int(user_id)}"

    def _load_warns_state(self) -> Dict[str, int]:
        raw = self.get_setting(_WARNS_STATE_KEY, "")
        if raw is None:
            return {}
        if isinstance(raw, dict):
            data = raw
        else:
            try:
                s = raw if isinstance(raw, str) else str(raw)
                s = s.strip()
                if not s:
                    return {}
                data = json.loads(s)
            except Exception:
                return {}
        if not isinstance(data, dict):
            return {}
        res: Dict[str, int] = {}
        for k, v in data.items():
            try:
                res[str(k)] = int(v)
            except Exception:
                continue
        return res

    def _save_warns_state(self):
        try:
            self._warns_prune()
            self.set_setting(_WARNS_STATE_KEY, json.dumps(self._warns, ensure_ascii=False, separators=(",", ":")))
        except Exception:
            pass

    def _warns_prune(self):
        try:
            if len(self._warns) <= _WARNS_MAX_ENTRIES:
                return
            items = list(self._warns.items())[-_WARNS_MAX_ENTRIES:]
            self._warns = dict(items)
        except Exception:
            pass

    def _get_warns(self, dialog_id: int, user_id: int) -> int:
        try:
            return int(self._warns.get(self._warn_key(dialog_id, user_id), 0) or 0)
        except Exception:
            return 0

    def _set_warns(self, dialog_id: int, user_id: int, count: int):
        key = self._warn_key(dialog_id, user_id)
        try:
            count = int(count)
        except Exception:
            count = 0
        if count <= 0:
            self._warns.pop(key, None)
            self._save_warns_state()
            return
        if count > 99:
            count = 99
        if key in self._warns:
            try:
                self._warns.pop(key, None)
            except Exception:
                pass
        self._warns[key] = int(count)
        self._save_warns_state()

    def _add_warns(self, dialog_id: int, user_ids: List[int], delta: int) -> Dict[int, int]:
        out: Dict[int, int] = {}
        for uid in user_ids:
            old = self._get_warns(dialog_id, uid)
            new = old + int(delta)
            if new < 0:
                new = 0
            if new > 99:
                new = 99
            key = self._warn_key(dialog_id, uid)
            if new <= 0:
                self._warns.pop(key, None)
            else:
                if key in self._warns:
                    try:
                        self._warns.pop(key, None)
                    except Exception:
                        pass
                self._warns[key] = int(new)
            out[int(uid)] = int(new)
        self._save_warns_state()
        return out

    def _maybe_apply_warn_punishment(self, dialog_id: int, counts: Dict[int, int]):
        try:
            limit = self._warn_limit()
            action = self._warn_punish_action()
            if action == 0 or limit <= 0:
                return
            offenders = [uid for uid, c in counts.items() if int(c) >= int(limit)]
            if not offenders:
                return

            sec = self._warn_punish_seconds()
            now = int(time.time())
            max_until = self._max_until_seconds()

            if action == 1:
                if sec <= 0:
                    sec = 60
                if sec > _CUSTOM_TIME_MAX_SECONDS:
                    sec = _CUSTOM_TIME_MAX_SECONDS
                if max_until > 0 and sec > max_until:
                    sec = max_until
                until_date = now + int(sec)
                try:
                    if until_date > _INT32_MAX:
                        until_date = _INT32_MAX
                except Exception:
                    pass
                run_on_queue(lambda: self._mute_users(dialog_id, offenders, until_date))
            elif action == 2:
                if sec > _CUSTOM_TIME_MAX_SECONDS:
                    sec = _CUSTOM_TIME_MAX_SECONDS
                if max_until > 0 and sec > max_until:
                    sec = max_until
                until_date = 0 if sec <= 0 else now + int(sec)
                try:
                    if until_date != 0 and until_date > _INT32_MAX:
                        until_date = _INT32_MAX
                except Exception:
                    pass
                run_on_queue(lambda: self._ban_users(dialog_id, offenders, until_date))
            elif action == 3:
                run_on_queue(lambda: self._kick_users(dialog_id, offenders))

            if self._warn_reset_on_punish():
                for uid in offenders:
                    self._warns.pop(self._warn_key(dialog_id, uid), None)
                self._save_warns_state()
        except Exception:
            pass

    def _max_until_seconds(self) -> int:
        try:
            now = int(time.time())
        except Exception:
            now = 0
        try:
            sec = int(_INT32_MAX) - int(now)
        except Exception:
            sec = 0
        if sec < 0:
            sec = 0
        return sec

    def _parse_duration_seconds(self, text: str, *, allow_zero: bool) -> Optional[int]:
        if text is None:
            return None
        s = str(text).strip().lower()
        if not s:
            return None
        if s in ("0", "forever", "навсегда", "вечн", "permanent"):
            return 0 if allow_zero else None

        s = s.replace(" ", "")
        mult = 1

        suffixes = {
            "s": 1,
            "сек": 1,
            "с": 1,
            "m": 60,
            "мин": 60,
            "м": 60,
            "h": 60 * 60,
            "час": 60 * 60,
            "ч": 60 * 60,
            "d": 24 * 60 * 60,
            "д": 24 * 60 * 60,
            "w": 7 * 24 * 60 * 60,
            "н": 7 * 24 * 60 * 60,
        }

        num_part = s
        for suf, m in sorted(suffixes.items(), key=lambda kv: -len(kv[0])):
            if s.endswith(suf):
                mult = m
                num_part = s[: -len(suf)]
                break

        try:
            value = int(num_part)
        except Exception:
            return None

        if value < 0:
            return None

        seconds = int(value) * int(mult)
        if seconds == 0 and not allow_zero:
            return None
        return seconds

    def _parse_int(self, text: Any, *, default: int, min_value: int, max_value: int) -> int:
        try:
            n = int(str(text).strip())
        except Exception:
            n = int(default)
        if n < int(min_value):
            n = int(min_value)
        if n > int(max_value):
            n = int(max_value)
        return n

    def _show_custom_time_dialog(self, *, kind: str, dialog_id: int, user_ids: List[int], token: str, cell, msg_obj):
        try:
            frag = get_last_fragment()
            if frag is None or not frag.getParentActivity():
                BulletinHelper.show_error("Не удалось открыть ввод времени: нет активного окна.")
                return
            ctx = frag.getParentActivity()
            resources_provider = None
            try:
                if hasattr(frag, "getResourceProvider"):
                    resources_provider = frag.getResourceProvider()
            except Exception:
                resources_provider = None

            Theme = jclass("org.telegram.ui.ActionBar.Theme")

            def _theme_color(key: int) -> int:
                try:
                    if resources_provider is not None:
                        return int(Theme.getColor(int(key), resources_provider))
                except Exception:
                    pass
                try:
                    return int(Theme.getColor(int(key)))
                except Exception:
                    return 0

            InputType = jclass("android.text.InputType")
            LayoutParams = jclass("android.widget.FrameLayout$LayoutParams")
            FrameLayout = jclass("android.widget.FrameLayout")

            container = FrameLayout(ctx)
            try:
                pad = int(AndroidUtilities.dp(16))
                container.setPadding(pad, pad, pad, pad)
            except Exception:
                pass

            et = None
            try:
                EditTextBoldCursor = jclass("org.telegram.ui.Components.EditTextBoldCursor")
                et = EditTextBoldCursor(ctx)
                try:
                    et.setBackground(None)
                except Exception:
                    pass
                try:
                    et.setLineColors(
                        _theme_color(getattr(Theme, "key_dialogInputField")),
                        _theme_color(getattr(Theme, "key_dialogInputFieldActivated")),
                        _theme_color(getattr(Theme, "key_text_RedBold")),
                    )
                except Exception:
                    pass
            except Exception:
                et = None

            if et is None:
                EditText = jclass("android.widget.EditText")
                et = EditText(ctx)

            try:
                et.setHint("Напр.: 3600 / 10м / 2ч / 3д")
            except Exception:
                pass
            try:
                et.setSingleLine(True)
            except Exception:
                pass
            try:
                et.setInputType(int(InputType.TYPE_CLASS_TEXT))
            except Exception:
                pass
            try:
                et.setTextColor(_theme_color(getattr(Theme, "key_dialogTextBlack")))
            except Exception:
                pass
            try:
                et.setHintTextColor(_theme_color(getattr(Theme, "key_dialogTextHint")))
            except Exception:
                pass
            try:
                if hasattr(et, "setCursorColor"):
                    et.setCursorColor(_theme_color(getattr(Theme, "key_windowBackgroundWhiteBlackText")))
            except Exception:
                pass

            try:
                lp = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT)
                container.addView(et, lp)
            except Exception:
                container.addView(et)

            title = "Свой срок"
            if kind == "ban":
                title = "Свой срок бана"
            if kind == "mute":
                title = "Свой срок мута"

            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE, resources_provider)
            builder.set_title(title)
            builder.set_message("Введи число в секундах или с суффиксом: с/м/ч/д/н.\nДля бана можно: 0 или «навсегда».")
            builder.set_view(container)

            def _apply(_dlg, _which):
                try:
                    raw = None
                    try:
                        raw = et.getText().toString()
                    except Exception:
                        raw = str(et.getText())

                    allow_zero = kind == "ban"
                    seconds = self._parse_duration_seconds(raw, allow_zero=allow_zero)
                    if seconds is None:
                        BulletinHelper.show_error("Неверный формат. Примеры: 3600, 10м, 2ч, 3д.")
                        return
                    if seconds > _CUSTOM_TIME_MAX_SECONDS:
                        max_days = int(_CUSTOM_TIME_MAX_SECONDS // (24 * 60 * 60))
                        BulletinHelper.show_error(f"Максимальный срок — {max_days} дней.")
                        return

                    now = int(time.time())
                    if kind == "mute":
                        if seconds <= 0:
                            BulletinHelper.show_error("Срок мута должен быть больше 0.")
                            return
                        until_date = now + int(seconds)
                        try:
                            if until_date > _INT32_MAX:
                                until_date = _INT32_MAX
                        except Exception:
                            pass
                        run_on_queue(lambda: self._mute_users(dialog_id, user_ids, until_date))
                    elif kind == "ban":
                        until_date = 0 if int(seconds) == 0 else now + int(seconds)
                        try:
                            if until_date != 0 and until_date > _INT32_MAX:
                                until_date = _INT32_MAX
                        except Exception:
                            pass
                        run_on_queue(lambda: self._ban_users(dialog_id, user_ids, until_date))
                    else:
                        return

                    try:
                        BulletinHelper.show_success("Готово.")
                    except Exception:
                        pass

                    try:
                        run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=kind))
                    except Exception:
                        pass

                    try:
                        _dlg.dismiss()
                    except Exception:
                        pass
                except Exception:
                    try:
                        BulletinHelper.show_error("Не удалось применить срок.")
                    except Exception:
                        pass

            builder.set_positive_button("Применить", _apply)
            builder.set_negative_button("Отмена", lambda d, _w: d.dismiss())
            builder.set_cancelable(True)
            builder.set_canceled_on_touch_outside(True)
            builder.show()
        except Exception:
            try:
                BulletinHelper.show_error("Не удалось открыть ввод срока.")
            except Exception:
                pass

    def _show_custom_delete_count_dialog(self, *, dialog_id: int, user_ids: List[int], token: str, cell, msg_obj):
        try:
            frag = get_last_fragment()
            if frag is None or not frag.getParentActivity():
                BulletinHelper.show_error("Не удалось открыть ввод числа: нет активного окна.")
                return
            ctx = frag.getParentActivity()
            resources_provider = None
            try:
                if hasattr(frag, "getResourceProvider"):
                    resources_provider = frag.getResourceProvider()
            except Exception:
                resources_provider = None

            Theme = jclass("org.telegram.ui.ActionBar.Theme")

            def _theme_color(key: int) -> int:
                try:
                    if resources_provider is not None:
                        return int(Theme.getColor(int(key), resources_provider))
                except Exception:
                    pass
                try:
                    return int(Theme.getColor(int(key)))
                except Exception:
                    return 0

            InputType = jclass("android.text.InputType")
            LayoutParams = jclass("android.widget.FrameLayout$LayoutParams")
            FrameLayout = jclass("android.widget.FrameLayout")

            container = FrameLayout(ctx)
            try:
                pad = int(AndroidUtilities.dp(16))
                container.setPadding(pad, pad, pad, pad)
            except Exception:
                pass

            et = None
            try:
                EditTextBoldCursor = jclass("org.telegram.ui.Components.EditTextBoldCursor")
                et = EditTextBoldCursor(ctx)
                try:
                    et.setBackground(None)
                except Exception:
                    pass
                try:
                    et.setLineColors(
                        _theme_color(getattr(Theme, "key_dialogInputField")),
                        _theme_color(getattr(Theme, "key_dialogInputFieldActivated")),
                        _theme_color(getattr(Theme, "key_text_RedBold")),
                    )
                except Exception:
                    pass
            except Exception:
                et = None

            if et is None:
                EditText = jclass("android.widget.EditText")
                et = EditText(ctx)

            try:
                et.setHint("Напр.: 25")
            except Exception:
                pass
            try:
                et.setSingleLine(True)
            except Exception:
                pass
            try:
                et.setInputType(int(InputType.TYPE_CLASS_NUMBER))
            except Exception:
                pass
            try:
                et.setTextColor(_theme_color(getattr(Theme, "key_dialogTextBlack")))
            except Exception:
                pass
            try:
                et.setHintTextColor(_theme_color(getattr(Theme, "key_dialogTextHint")))
            except Exception:
                pass

            try:
                lp = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT)
                container.addView(et, lp)
            except Exception:
                container.addView(et)

            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE, resources_provider)
            builder.set_title("Удалить сообщения")
            builder.set_message("Сколько последних сообщений выбранных пользователей удалить (из загруженной истории чата).")
            builder.set_view(container)

            def _apply(_dlg, _which):
                try:
                    raw = None
                    try:
                        raw = et.getText().toString()
                    except Exception:
                        raw = str(et.getText())

                    n = self._parse_int(raw, default=10, min_value=1, max_value=500)
                    self._delete_last_messages_from_users(dialog_id, list(user_ids), n)

                    try:
                        run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=_PAGE_DELETE))
                    except Exception:
                        pass

                    try:
                        _dlg.dismiss()
                    except Exception:
                        pass
                except Exception:
                    try:
                        BulletinHelper.show_error("Не удалось удалить сообщения.")
                    except Exception:
                        pass

            builder.set_positive_button("Удалить", _apply)
            builder.set_negative_button("Отмена", lambda d, _w: d.dismiss())
            builder.set_cancelable(True)
            builder.set_canceled_on_touch_outside(True)
            builder.show()
        except Exception:
            try:
                BulletinHelper.show_error("Не удалось открыть ввод числа.")
            except Exception:
                pass

    def _delete_last_messages_from_users_loaded(self, dialog_id: int, user_ids: List[int], count_per_user: int):
        try:
            chat_activity = self._get_current_chat_activity(dialog_id)
            if chat_activity is None:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Открой нужный чат и попробуй снова."))
                return

            try:
                topic_id = int(chat_activity.getTopicId() or 0)
            except Exception:
                topic_id = 0

            targets = set(int(x) for x in user_ids if int(x) != 0)
            if not targets:
                return

            per_left: Dict[int, int] = {uid: int(count_per_user) for uid in targets}
            total_left = sum(per_left.values())

            msgs = None
            try:
                adapter = getattr(chat_activity, "chatAdapter", None)
                if adapter is not None and hasattr(adapter, "getMessages"):
                    msgs = adapter.getMessages()
            except Exception:
                msgs = None
            if msgs is None:
                msgs = getattr(chat_activity, "messages", None)
            if msgs is None:
                run_on_ui_thread(lambda: BulletinHelper.show_error("История сообщений недоступна."))
                return

            size = 0
            try:
                size = int(msgs.size())
            except Exception:
                try:
                    size = len(msgs)
                except Exception:
                    size = 0

            def _get_key(idx: int):
                try:
                    m = msgs.get(idx)
                except Exception:
                    try:
                        m = msgs[idx]
                    except Exception:
                        return (0, 0)
                if m is None:
                    return (0, 0)
                try:
                    mo = getattr(m, "messageOwner", None)
                    d = int(getattr(mo, "date", 0) or 0) if mo is not None else 0
                    mid = int(getattr(mo, "id", 0) or 0) if mo is not None else 0
                except Exception:
                    d, mid = 0, 0
                if mid <= 0:
                    try:
                        if hasattr(m, "getId"):
                            mid = int(m.getId())
                    except Exception:
                        pass
                return (d, mid)

            newest_at_end = True
            try:
                if size >= 2:
                    k0 = _get_key(0)
                    k1 = _get_key(size - 1)
                    if k0 != (0, 0) and k1 != (0, 0):
                        newest_at_end = k0 <= k1
            except Exception:
                newest_at_end = True

            ids = ArrayList()
            picked = 0

            if newest_at_end:
                index_iter = range(size - 1, -1, -1)
            else:
                index_iter = range(0, size, 1)

            for i in index_iter:
                if total_left <= 0:
                    break
                try:
                    mobj = msgs.get(i)
                except Exception:
                    try:
                        mobj = msgs[i]
                    except Exception:
                        continue
                if mobj is None:
                    continue
                try:
                    sender = int(mobj.getFromChatId())
                except Exception:
                    sender = 0
                if sender not in per_left or per_left.get(sender, 0) <= 0:
                    continue
                mid = 0
                try:
                    if hasattr(mobj, "getId"):
                        mid = int(mobj.getId())
                except Exception:
                    mid = 0
                if mid <= 0:
                    try:
                        mo = getattr(mobj, "messageOwner", None)
                        mid = int(getattr(mo, "id", 0) or 0) if mo is not None else 0
                    except Exception:
                        mid = 0
                if mid <= 0:
                    continue

                ids.add(JInt(int(mid)))
                picked += 1
                per_left[sender] = int(per_left.get(sender, 0) - 1)
                total_left -= 1

            if picked <= 0:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не нашёл сообщений для удаления (в загруженной истории)."))
                return

            mc = get_messages_controller()
            try:
                mc.deleteMessages(ids, None, None, int(dialog_id), int(topic_id), True, 0)
            except Exception as e:
                try:
                    self.log(f"[inlinetools] deleteMessages failed: {e}")
                except Exception:
                    pass
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось удалить сообщения."))
                return

            run_on_ui_thread(lambda: BulletinHelper.show_success(f"Удалено сообщений: {picked}"))
        except Exception:
            try:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось удалить сообщения."))
            except Exception:
                pass

    def _delete_last_messages_from_users_server(self, dialog_id: int, user_ids: List[int], count_per_user: int):
        mc = get_messages_controller()

        chat_activity = self._get_current_chat_activity(dialog_id)
        try:
            topic_id = int(chat_activity.getTopicId() or 0) if chat_activity is not None else 0
        except Exception:
            topic_id = 0
        topic_id = self._safe_int32(topic_id, default=0)

        targets = [int(x) for x in user_ids if int(x) != 0]
        if not targets:
            return

        try:
            per_user = int(count_per_user)
        except Exception:
            per_user = 10
        if per_user < 1:
            per_user = 1
        if per_user > 500:
            per_user = 500

        collected: List[int] = []
        seen: set = set()
        started_at = float(time.time())

        def _delete_collected():
            if not collected:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не нашёл сообщений для удаления."))
                return

            def _do_delete_chunks():
                try:
                    total = 0
                    chunk_size = 100
                    for pos in range(0, len(collected), chunk_size):
                        mids = collected[pos : pos + chunk_size]
                        arr = ArrayList()
                        for mid in mids:
                            try:
                                if int(mid) > 0:
                                    arr.add(JInt(int(mid)))
                            except Exception:
                                continue
                        if arr.size() <= 0:
                            continue
                        mc.deleteMessages(arr, None, None, int(dialog_id), int(topic_id), True, 0)
                        total += int(arr.size())

                    dt = 0.0
                    try:
                        dt = float(time.time()) - float(started_at)
                    except Exception:
                        dt = 0.0
                    BulletinHelper.show_success(f"Удалено сообщений: {total} за {dt:.1f}с")
                except Exception as e:
                    try:
                        self.log(f"[inlinetools] deleteMessages(server) failed: {e}")
                    except Exception:
                        pass
                    BulletinHelper.show_error("Не удалось удалить сообщения.")

            run_on_ui_thread(_do_delete_chunks)

        def _add_mid(mid: int):
            try:
                mid = int(mid)
            except Exception:
                return
            if mid <= 0:
                return
            if mid in seen:
                return
            seen.add(mid)
            collected.append(mid)

        def _collect_from_history(uid: int, need: int, on_done):
            max_pages = 2
            page_limit = 100

            state = {"pages": 0, "offset_id": 0, "need": int(need)}

            def _next_page():
                if state["need"] <= 0 or state["pages"] >= max_pages:
                    on_done()
                    return

                state["pages"] += 1
                offset_id = int(state.get("offset_id", 0) or 0)

                try:
                    if int(topic_id) != 0:
                        req = TLRPC.TL_messages_getReplies()
                        req.peer = mc.getInputPeer(int(dialog_id))
                        req.msg_id = int(topic_id)
                    else:
                        req = TLRPC.TL_messages_getHistory()
                        req.peer = mc.getInputPeer(int(dialog_id))
                    req.offset_id = int(offset_id)
                    req.offset_date = 0
                    req.add_offset = 0
                    req.limit = int(page_limit)
                    req.max_id = 0
                    req.min_id = 0
                    req.hash = 0
                except Exception:
                    on_done()
                    return

                def _cb(response, error):
                    try:
                        if error or response is None:
                            on_done()
                            return
                        msgs = getattr(response, "messages", None)
                        if msgs is None:
                            on_done()
                            return
                        try:
                            sz = int(msgs.size())
                        except Exception:
                            try:
                                sz = len(msgs)
                            except Exception:
                                sz = 0
                        if sz <= 0:
                            on_done()
                            return

                        min_mid = None
                        for j in range(0, sz):
                            try:
                                m = msgs.get(j)
                            except Exception:
                                try:
                                    m = msgs[j]
                                except Exception:
                                    continue
                            if m is None:
                                continue
                            try:
                                mid = int(getattr(m, "id", 0) or 0)
                            except Exception:
                                mid = 0
                            if mid <= 0:
                                continue
                            if min_mid is None or mid < min_mid:
                                min_mid = mid

                            sender = 0
                            try:
                                peer = getattr(m, "from_id", None)
                                sender = int(MessageObject.getPeerId(peer))
                            except Exception:
                                sender = 0
                            if sender != int(uid):
                                continue

                            _add_mid(mid)
                            state["need"] -= 1
                            if state["need"] <= 0:
                                break

                        if min_mid is None:
                            on_done()
                            return
                        state["offset_id"] = max(int(min_mid) - 1, 0)
                    finally:
                        _next_page()

                try:
                    send_request(req, _cb)
                except Exception:
                    on_done()

            _next_page()

        def _collect_from_search(uid: int, need: int, on_done):
            limit_per_req = 50
            max_iters = 20
            state = {"need": int(need), "offset_id": 0, "iters": 0}

            def _next():
                if state["need"] <= 0 or state["iters"] >= max_iters:
                    on_done()
                    return
                state["iters"] += 1

                try:
                    req = TLRPC.TL_messages_search()
                    req.flags = 0
                    req.peer = mc.getInputPeer(int(dialog_id))
                    req.q = ""
                    req.from_id = mc.getInputPeer(int(uid))
                    req.flags |= 1
                    if int(topic_id) != 0:
                        req.top_msg_id = int(topic_id)
                        req.flags |= 2
                    req.filter = TLRPC.TL_inputMessagesFilterEmpty()
                    req.min_date = 0
                    req.max_date = 0
                    req.offset_id = int(state.get("offset_id", 0) or 0)
                    req.add_offset = 0
                    req.limit = int(min(limit_per_req, max(state["need"], 1)))
                    req.max_id = 0
                    req.min_id = 0
                    req.hash = 0
                except Exception:
                    on_done()
                    return

                def _cb(response, error):
                    try:
                        if error or response is None:
                            on_done()
                            return
                        msgs = getattr(response, "messages", None)
                        if msgs is None:
                            on_done()
                            return

                        try:
                            sz = int(msgs.size())
                        except Exception:
                            try:
                                sz = len(msgs)
                            except Exception:
                                sz = 0
                        if sz <= 0:
                            on_done()
                            return

                        found: List[Tuple[int, int]] = []
                        for j in range(0, sz):
                            try:
                                m = msgs.get(j)
                            except Exception:
                                try:
                                    m = msgs[j]
                                except Exception:
                                    continue
                            if m is None:
                                continue
                            try:
                                mid = int(getattr(m, "id", 0) or 0)
                            except Exception:
                                mid = 0
                            if mid <= 0:
                                continue
                            try:
                                date = int(getattr(m, "date", 0) or 0)
                            except Exception:
                                date = 0
                            found.append((date, mid))

                        if not found:
                            on_done()
                            return

                        found.sort(key=lambda x: (x[0], x[1]), reverse=True)

                        min_mid = None
                        for _d, mid in found:
                            _add_mid(mid)
                            state["need"] -= 1
                            if min_mid is None or int(mid) < int(min_mid):
                                min_mid = int(mid)
                            if state["need"] <= 0:
                                break

                        if min_mid is None:
                            on_done()
                            return
                        state["offset_id"] = max(int(min_mid) - 1, 0)
                    finally:
                        _next()

                try:
                    send_request(req, _cb)
                except Exception:
                    on_done()

            _next()

        def _process_user(idx: int):
            if idx >= len(targets):
                _delete_collected()
                return
            uid = int(targets[idx])

            def _after_history():
                need = per_user
                need = per_user

                def _after_search():
                    _process_user(idx + 1)

                _collect_from_search(uid, need, _after_search)

            _collect_from_history(uid, min(per_user, 50), _after_history)

        _process_user(0)

    def _delete_last_messages_from_users(self, dialog_id: int, user_ids: List[int], count_per_user: int):
        try:
            self._delete_last_messages_from_users_server(dialog_id, user_ids, count_per_user)
        except Exception:
            self._delete_last_messages_from_users_loaded(dialog_id, user_ids, count_per_user)

    def _init_ripple(self):
        try:
            self._launch_activity_jclass = JClass.forName("org.telegram.ui.LaunchActivity")
            try:
                self._make_ripple_static = getattr(self._launch_activity_jclass, "makeRipple")
            except Exception:
                self._make_ripple_static = None
        except Exception:
            self._launch_activity_jclass = None
            self._make_ripple_static = None
            self._make_ripple_method = None

    def _invoke_ripple(self, x: float, y: float, intensity: float):
        try:
            if self._launch_activity_jclass is None:
                self._init_ripple()

            try:
                if getattr(self, "_make_ripple_static", None):
                    self._make_ripple_static(float(x), float(y), float(intensity))
                    return
            except Exception:
                pass

            if self._launch_activity_jclass is None:
                return

            if not self._make_ripple_method:
                method = None
                try:
                    method = self._launch_activity_jclass.getDeclaredMethod("makeRipple", JFloat.TYPE, JFloat.TYPE, JFloat.TYPE)
                except Exception:
                    try:
                        methods = self._launch_activity_jclass.getDeclaredMethods()
                        for m in methods:
                            try:
                                if m.getName() != "makeRipple":
                                    continue
                                if len(m.getParameterTypes()) == 3:
                                    method = m
                                    break
                            except Exception:
                                method = m
                                break
                    except Exception:
                        method = None
                if method:
                    try:
                        method.setAccessible(True)
                    except Exception:
                        pass
                    self._make_ripple_method = method

            if self._make_ripple_method:
                self._make_ripple_method.invoke(None, JFloat(x), JFloat(y), JFloat(intensity))
        except Exception:
            pass

    def _install_touch_hook(self):
        try:
            cell_cls = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if cell_cls is None:
                return

            motion_event_cls = None
            try:
                motion_event_cls = JClass.forName("android.view.MotionEvent")
            except Exception:
                motion_event_cls = None

            method = None
            try:
                if motion_event_cls is not None:
                    method = cell_cls.getClass().getDeclaredMethod("onTouchEvent", motion_event_cls)
            except Exception:
                method = None

            if method is None:
                try:
                    for m in cell_cls.getClass().getDeclaredMethods():
                        try:
                            if m.getName() == "onTouchEvent" and len(m.getParameterTypes()) == 1:
                                method = m
                                break
                        except Exception:
                            continue
                except Exception:
                    method = None

            if method is None:
                return
            try:
                method.setAccessible(True)
            except Exception:
                pass

            self._touch_unhook = self.hook_method(method, _ChatMessageCellTouchHook(self), priority=0)
        except Exception:
            self._touch_unhook = None

    def _record_touch(self, cell, motion_event):
        try:
            if not self._effects_enabled():
                return
            action = int(motion_event.getActionMasked())
            if action != 0:
                return
            try:
                rx = float(motion_event.getRawX())
                ry = float(motion_event.getRawY())
            except Exception:
                rx = float(motion_event.getX())
                ry = float(motion_event.getY())
            try:
                pressure = float(motion_event.getPressure())
            except Exception:
                pressure = 0.55
            self._last_touch = (rx, ry, pressure, float(time.time()))
            self._last_touch_cell = cell
        except Exception:
            pass

    def _get_view_center(self, view) -> Optional[Tuple[float, float]]:
        if view is None:
            return None
        try:
            coords = view.getLocationOnScreen()
            w = float(view.getWidth() or view.getMeasuredWidth() or 0)
            h = float(view.getHeight() or view.getMeasuredHeight() or 0)
            if not coords or len(coords) < 2:
                return None
            x = float(coords[0]) + (w / 2.0 if w > 0 else 0.0)
            y = float(coords[1]) + (h / 2.0 if h > 0 else 0.0)
            return (x, y)
        except Exception:
            return None

    def _maybe_ripple_on_inline_click(self, cell):
        try:
            if not self._effects_enabled():
                return
            now = float(time.time())
            x = None
            y = None
            pressure = 0.55
            if self._last_touch and (self._last_touch_cell is cell) and (now - self._last_touch[3] <= 1.0):
                x, y, pressure, _ts = self._last_touch
            else:
                center = self._get_view_center(cell)
                if not center:
                    return
                x, y = center
            try:
                p = float(pressure)
                if p < 0.2:
                    p = 0.2
                if p > 1.0:
                    p = 1.0
            except Exception:
                p = 0.55
            self._invoke_ripple(float(x), float(y), float(p))
        except Exception:
            pass


    def on_send_message_hook(self, account, params):
        try:
            raw = getattr(params, "message", None)
            if not isinstance(raw, str):
                return HookResult()

            text = raw.strip()
            if not text:
                return HookResult()

            low = text.lower()
            if not (low == ".admin" or low.startswith(".admin ")):
                return HookResult()

            dialog_id = getattr(params, "peer", None)
            if not isinstance(dialog_id, int):
                BulletinHelper.show_error("Не удалось определить чат.")
                return HookResult(strategy=HookStrategy.CANCEL)

            user_ids = self._extract_target_user_ids(params, text)
            if not user_ids:
                run_on_ui_thread(self._show_usage_dialog)
                return HookResult(strategy=HookStrategy.CANCEL)

            run_on_ui_thread(lambda: self._show_ban_panel(dialog_id, user_ids))
            return HookResult(strategy=HookStrategy.CANCEL)

        except Exception as e:
            try:
                    self.log(f"[inlinetools] on_send_message_hook error: {e}")
            except Exception:
                pass
            return HookResult()

    def _show_usage_dialog(self):
        try:
            frag = get_last_fragment()
            if not frag or not frag.getParentActivity():
                BulletinHelper.show_error("Использование: ответь на сообщение и напиши .admin")
                return

            ctx = frag.getParentActivity()
            msg = (
                "Как использовать:\n\n"
                "• Ответь на сообщение пользователя и напиши .admin\n"
                "• Или укажи ID: .admin 123456\n\n"
                "Далее выбирай нужное действие и срок в меню."
            )

            builder = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
            builder.set_title("Inline Tools")
            builder.set_message(msg)
            builder.set_positive_button("OK", lambda d, _w: d.dismiss())
            builder.set_cancelable(True)
            builder.set_canceled_on_touch_outside(True)
            builder.show()
        except Exception:
            try:
                BulletinHelper.show_error("Использование: ответь на сообщение пользователя и напиши .admin")
            except Exception:
                pass


    def _show_ban_panel(self, dialog_id: int, user_ids: List[int]):
        chat_activity = self._get_current_chat_activity(dialog_id)
        if chat_activity is None:
            BulletinHelper.show_error("Открой нужный чат и попробуй снова.")
            return

        topic_id = 0
        try:
            topic_id = self._safe_int32(chat_activity.getTopicId() or 0, default=0)
        except Exception:
            topic_id = 0

        token = self._new_token()
        self._panels[token] = _PanelContext(
            dialog_id=dialog_id,
            user_ids=list(user_ids),
            page=_PAGE_MAIN,
            created_at=time.time(),
        )

        panel_text = self._format_panel_text(dialog_id, user_ids, page=_PAGE_MAIN)
        markup = self._build_markup(token, page=_PAGE_MAIN)

        msg_obj = self._build_local_message(dialog_id, topic_id, panel_text, markup)
        if msg_obj is None:
            BulletinHelper.show_error("Не удалось создать локальное сообщение.")
            self._panels.pop(token, None)
            return

        if not self._insert_local_message(chat_activity, msg_obj):
            BulletinHelper.show_error("Не удалось вставить локальное сообщение в чат.")
            self._panels.pop(token, None)

    def _format_panel_text(self, dialog_id: int, user_ids: List[int], *, page: str) -> str:
        mc = get_messages_controller()
        lines = ["**Админ-панель**", ""]
        lines.append(f"**Чат:** `{dialog_id}`")
        if page == _PAGE_MAIN:
            section = "Главное меню"
        elif page == _PAGE_BAN:
            section = "Бан: выбрать срок"
        elif page == _PAGE_MUTE:
            section = "Мут: выбрать срок"
        elif page == _PAGE_WARN:
            section = "Варны"
        elif page == _PAGE_DELETE:
            section = "Удаление сообщений"
        else:
            section = page
        lines.append(f"**Раздел:** {section}")
        lines.append("**Цели:**")
        limit = self._warn_limit()
        for uid in user_ids:
            name = str(uid)
            try:
                user = mc.getUser(uid)
                if user is not None:
                    name = UserObject.getUserName(user)
            except Exception:
                pass
            try:
                w = self._get_warns(dialog_id, int(uid))
            except Exception:
                w = 0
            safe_name = str(name).replace("\n", " ").replace("`", "ˋ")
            lines.append(f"• `{safe_name}` (`{uid}`) — варны: `{w}/{limit}`")
        if page == _PAGE_WARN:
            a = self._warn_punish_action()
            sec = self._warn_punish_seconds()
            if a == 2 and sec == 0:
                dur = "навсегда"
            elif a in (1, 2):
                dur = f"{sec} сек"
            else:
                dur = "-"
            lines.append("")
            lines.append(f"**Порог:** `{limit}`")
            lines.append(f"**Автонаказание:** `{self._warn_punish_label()}` (`{dur}`)")
        if page == _PAGE_DELETE:
            lines.append("")
            lines.append("_Удаляются последние сообщения пользователя с сервера (история подгружается автоматически)._")
        lines.append("")
        lines.append("_Нажатия обрабатываются локально (сообщение не отправляется в чат)_")
        return "\n".join(lines)

    def _build_markup(self, token: str, *, page: str):
        def cb(action: str, arg: Optional[str] = None) -> bytes:
            tail = action if arg is None else f"{action}:{arg}"
            return f"{_CALLBACK_PREFIX}{token}:{tail}".encode("utf-8")

        markup = TLRPC.TL_replyInlineMarkup()

        if page == _PAGE_MAIN:
            row1 = TLRPC.TL_keyboardButtonRow()
            row1.buttons.add(self._kb_cb("Мут", cb("nav", _PAGE_MUTE)))
            row1.buttons.add(self._kb_cb("Бан", cb("nav", _PAGE_BAN)))
            row1.buttons.add(self._kb_cb("Варны", cb("nav", _PAGE_WARN)))
            markup.rows.add(row1)

            row2 = TLRPC.TL_keyboardButtonRow()
            row2.buttons.add(self._kb_cb("Кик", cb("kick")))
            row2.buttons.add(self._kb_cb("Удалить", cb("nav", _PAGE_DELETE)))
            row2.buttons.add(self._kb_cb("Разбан", cb("unban")))
            markup.rows.add(row2)

            row3 = TLRPC.TL_keyboardButtonRow()
            row3.buttons.add(self._kb_cb("Размут", cb("unmute")))
            row3.buttons.add(self._kb_cb("Закрыть", cb("close")))
            markup.rows.add(row3)
            return markup

        if page == _PAGE_BAN:
            row1 = TLRPC.TL_keyboardButtonRow()
            row1.buttons.add(self._kb_cb("Навсегда", cb("ban", "0")))
            row1.buttons.add(self._kb_cb("1ч", cb("ban", str(60 * 60))))
            row1.buttons.add(self._kb_cb("1д", cb("ban", str(24 * 60 * 60))))
            markup.rows.add(row1)

            row2 = TLRPC.TL_keyboardButtonRow()
            row2.buttons.add(self._kb_cb("7д", cb("ban", str(7 * 24 * 60 * 60))))
            row2.buttons.add(self._kb_cb("30д", cb("ban", str(30 * 24 * 60 * 60))))
            row2.buttons.add(self._kb_cb("Свой…", cb("custom_time", _PAGE_BAN)))
            markup.rows.add(row2)

            row3 = TLRPC.TL_keyboardButtonRow()
            row3.buttons.add(self._kb_cb("Назад", cb("nav", _PAGE_MAIN)))
            row3.buttons.add(self._kb_cb("Закрыть", cb("close")))
            markup.rows.add(row3)
            return markup

        if page == _PAGE_MUTE:
            row1 = TLRPC.TL_keyboardButtonRow()
            row1.buttons.add(self._kb_cb("5м", cb("mute", str(5 * 60))))
            row1.buttons.add(self._kb_cb("1ч", cb("mute", str(60 * 60))))
            row1.buttons.add(self._kb_cb("1д", cb("mute", str(24 * 60 * 60))))
            markup.rows.add(row1)

            row2 = TLRPC.TL_keyboardButtonRow()
            row2.buttons.add(self._kb_cb("7д", cb("mute", str(7 * 24 * 60 * 60))))
            row2.buttons.add(self._kb_cb("Свой…", cb("custom_time", _PAGE_MUTE)))
            markup.rows.add(row2)

            row3 = TLRPC.TL_keyboardButtonRow()
            row3.buttons.add(self._kb_cb("Назад", cb("nav", _PAGE_MAIN)))
            row3.buttons.add(self._kb_cb("Закрыть", cb("close")))
            markup.rows.add(row3)
            return markup

        if page == _PAGE_WARN:
            row1 = TLRPC.TL_keyboardButtonRow()
            row1.buttons.add(self._kb_cb("+1", cb("warn_add", "1")))
            row1.buttons.add(self._kb_cb("-1", cb("warn_add", "-1")))
            row1.buttons.add(self._kb_cb("Сброс", cb("warn_reset")))
            markup.rows.add(row1)

            row2 = TLRPC.TL_keyboardButtonRow()
            row2.buttons.add(self._kb_cb("Назад", cb("nav", _PAGE_MAIN)))
            row2.buttons.add(self._kb_cb("Закрыть", cb("close")))
            markup.rows.add(row2)
            return markup

        if page == _PAGE_DELETE:
            row1 = TLRPC.TL_keyboardButtonRow()
            row1.buttons.add(self._kb_cb("1", cb("del_n", "1")))
            row1.buttons.add(self._kb_cb("5", cb("del_n", "5")))
            row1.buttons.add(self._kb_cb("10", cb("del_n", "10")))
            markup.rows.add(row1)

            row2 = TLRPC.TL_keyboardButtonRow()
            row2.buttons.add(self._kb_cb("25", cb("del_n", "25")))
            row2.buttons.add(self._kb_cb("50", cb("del_n", "50")))
            row2.buttons.add(self._kb_cb("100", cb("del_n", "100")))
            markup.rows.add(row2)

            row3 = TLRPC.TL_keyboardButtonRow()
            row3.buttons.add(self._kb_cb("Свой…", cb("del_custom")))
            row3.buttons.add(self._kb_cb("Назад", cb("nav", _PAGE_MAIN)))
            row3.buttons.add(self._kb_cb("Закрыть", cb("close")))
            markup.rows.add(row3)
            return markup

        row = TLRPC.TL_keyboardButtonRow()
        row.buttons.add(self._kb_cb("Назад", cb("nav", _PAGE_MAIN)))
        markup.rows.add(row)
        return markup

    def _kb_cb(self, text: str, data: bytes):
        b = TLRPC.TL_keyboardButtonCallback()
        b.text = text
        b.data = data
        b.requires_password = False
        return b

    def _build_local_message(self, dialog_id: int, topic_id: int, text: str, markup):
        try:
            mc = get_messages_controller()
            uc = get_user_config()
            account = int(getattr(uc, "selectedAccount", 0))
            my_id = int(uc.getClientUserId())

            msg = TLRPC.TL_message()
            msg.id = -random.randint(1, 2_000_000_000)
            msg.date = self._safe_int32(int(time.time()), default=0)
            parsed = parse_markdown(text)
            msg.message = parsed.text
            if parsed.entities:
                entities = ArrayList()
                for ent in parsed.entities:
                    entities.add(ent.to_tlrpc_object())
                msg.entities = entities
                msg.flags |= 128

            msg.peer_id = mc.getPeer(dialog_id)

            from_peer = TLRPC.TL_peerUser()
            from_peer.user_id = my_id
            msg.from_id = from_peer

            msg.out = True
            msg.flags |= 2
            msg.flags |= 256

            if topic_id:
                reply = TLRPC.TL_messageReplyHeader()
                reply.reply_to_top_id = self._safe_int32(topic_id, default=0)
                msg.reply_to = reply
                msg.flags |= 8

            if markup is not None:
                msg.reply_markup = markup
                msg.flags |= 64

            msg_obj = MessageObject(account, msg, False, False)
            return msg_obj
        except Exception as e:
            try:
                self.log(f"[inlinetools] build_local_message error: {e}")
            except Exception:
                pass
            return None

    def _update_local_panel_message(self, cell, msg_obj, *, token: str, page: str):
        try:
            ctx = self._panels.get(token)
            if ctx is None:
                return

            ctx.page = page

            try:
                mo = getattr(msg_obj, "messageOwner", None)
                if mo is None:
                    return

                text = self._format_panel_text(ctx.dialog_id, ctx.user_ids, page=page)
                parsed = parse_markdown(text)

                mo.message = parsed.text
                if parsed.entities:
                    entities = ArrayList()
                    for ent in parsed.entities:
                        entities.add(ent.to_tlrpc_object())
                    mo.entities = entities
                    try:
                        mo.flags |= 128
                    except Exception:
                        pass
                else:
                    try:
                        mo.entities = None
                        mo.flags &= ~128
                    except Exception:
                        pass

                markup = self._build_markup(token, page=page)
                mo.reply_markup = markup
                try:
                    mo.flags |= 64
                except Exception:
                    pass

                try:
                    uc = get_user_config()
                    account = int(getattr(uc, "selectedAccount", 0))
                    refreshed = MessageObject(account, mo, False, False)
                    if hasattr(refreshed, "messageText"):
                        msg_obj.messageText = refreshed.messageText
                    if hasattr(refreshed, "messageTextShort"):
                        msg_obj.messageTextShort = refreshed.messageTextShort
                    if hasattr(refreshed, "messageTextForReply"):
                        msg_obj.messageTextForReply = refreshed.messageTextForReply
                    if hasattr(refreshed, "type"):
                        msg_obj.type = refreshed.type
                except Exception as e:
                    try:
                        self.log(f"[inlinetools] MessageObject refresh failed: {e}")
                    except Exception:
                        pass

                try:
                    if hasattr(msg_obj, "measureInlineBotButtons"):
                        msg_obj.measureInlineBotButtons()
                except Exception as e:
                    try:
                        self.log(f"[inlinetools] measureInlineBotButtons failed: {e}")
                    except Exception:
                        pass

                try:
                    msg_obj.forceUpdate = True
                except Exception:
                    pass
                try:
                    if hasattr(msg_obj, "resetLayout"):
                        msg_obj.resetLayout()
                except Exception:
                    pass

                if cell is None:
                    return

                def _apply_update():
                    cell.setMessageObject(
                        msg_obj,
                        cell.getCurrentMessagesGroup(),
                        cell.isPinnedBottom(),
                        cell.isPinnedTop(),
                        cell.isFirstInChat(),
                    )
                    try:
                        cell.requestLayout()
                    except Exception:
                        pass
                    try:
                        cell.invalidate()
                    except Exception:
                        pass

                self._animate_panel_switch(cell, _apply_update)
            except Exception as e:
                try:
                    self.log(f"[inlinetools] update panel failed: {e}")
                except Exception:
                    pass
        except Exception:
            pass

    def _animate_panel_switch(self, cell, apply_update):
        try:
            if not self._effects_enabled():
                try:
                    a = cell.animate() if hasattr(cell, "animate") else None
                    if a is not None:
                        a.cancel()
                except Exception:
                    pass
                try:
                    cell.setAlpha(1.0)
                except Exception:
                    pass
                try:
                    cell.setScaleX(1.0)
                    cell.setScaleY(1.0)
                except Exception:
                    pass
                try:
                    cell.setTranslationY(0.0)
                except Exception:
                    pass
                apply_update()
                return

            interp = None
            try:
                interp = jclass("android.view.animation.DecelerateInterpolator")(1.5)
            except Exception:
                interp = None
            try:
                dy = float(AndroidUtilities.dp(6))
            except Exception:
                dy = 0.0

            animator = cell.animate() if hasattr(cell, "animate") else None
            if animator is None:
                apply_update()
                return

            try:
                animator.cancel()
            except Exception:
                pass

            def _after_fade_out():
                try:
                    apply_update()
                finally:
                    try:
                        try:
                            cell.setAlpha(0.0)
                        except Exception:
                            pass
                        try:
                            cell.setScaleX(0.94)
                            cell.setScaleY(0.94)
                        except Exception:
                            pass
                        try:
                            cell.setTranslationY(dy)
                        except Exception:
                            pass

                        a = cell.animate().alpha(1.0).scaleX(1.0).scaleY(1.0).translationY(0.0).setDuration(280)
                        try:
                            if interp is not None:
                                a.setInterpolator(interp)
                        except Exception:
                            pass
                        a.start()
                    except Exception:
                        pass

            try:
                cell.setAlpha(1.0)
            except Exception:
                pass
            try:
                cell.setScaleX(1.0)
                cell.setScaleY(1.0)
            except Exception:
                pass
            try:
                cell.setTranslationY(0.0)
            except Exception:
                pass

            try:
                a = animator.alpha(0.0).scaleX(0.94).scaleY(0.94).translationY(dy).setDuration(200)
                try:
                    if interp is not None:
                        a.setInterpolator(interp)
                except Exception:
                    pass
                a.withEndAction(Runnable(_after_fade_out)).start()
            except Exception:
                _after_fade_out()
        except Exception:
            try:
                apply_update()
            except Exception:
                pass

    def _insert_local_message(self, chat_activity, msg_obj) -> bool:
        try:
            method = chat_activity.getClass().getDeclaredMethod("processNewMessages", ArrayList)
            method.setAccessible(True)
            arr = ArrayList()
            arr.add(msg_obj)
            method.invoke(chat_activity, arr)
            return True
        except Exception as e:
            try:
                self.log(f"[inlinetools] insert_local_message error: {e}")
            except Exception:
                pass
            return False

    def _remove_local_message(self, chat_activity, msg_obj) -> bool:
        try:
            method = chat_activity.getClass().getDeclaredMethod("removeMessageObject", MessageObject)
            method.setAccessible(True)
            method.invoke(chat_activity, msg_obj)
            return True
        except Exception:
            return False

    def _get_current_chat_activity(self, dialog_id: int):
        frag = get_last_fragment()
        if frag is None:
            return None
        try:
            if hasattr(frag, "getDialogId") and int(frag.getDialogId()) != int(dialog_id):
                return None
        except Exception:
            return None
        try:
            chat_activity_cls = find_class("org.telegram.ui.ChatActivity")
            if chat_activity_cls is None:
                return frag
            return frag if isinstance(frag, chat_activity_cls) else None
        except Exception:
            return frag


    def _install_inline_button_hooks(self):
        try:
            delegate_cls = find_class("org.telegram.ui.ChatActivity$ChatMessageCellDelegate")
            if delegate_cls is None:
                self.log("[inlinetools] ChatMessageCellDelegate not found; inline buttons disabled")
                return

            methods = {}
            try:
                try:
                    declared = delegate_cls.getClass().getDeclaredMethods()
                except Exception:
                    declared = delegate_cls.getDeclaredMethods()
                methods = {repr(m): m for m in declared}
            except Exception as e:
                self.log(f"[inlinetools] failed to enumerate delegate methods: {e}")
                return

            press = (
                methods.get(
                    "<java.lang.reflect.Method 'public void org.telegram.ui.ChatActivity$ChatMessageCellDelegate."
                    "didPressBotButton(org.telegram.ui.Cells.ChatMessageCell,org.telegram.tgnet.TLRPC$KeyboardButton)'>"
                )
                or next((m for s, m in methods.items() if "didPressBotButton" in s), None)
            )
            long_press = (
                methods.get(
                    "<java.lang.reflect.Method 'public void org.telegram.ui.ChatActivity$ChatMessageCellDelegate."
                    "didLongPressBotButton(org.telegram.ui.Cells.ChatMessageCell,org.telegram.tgnet.TLRPC$KeyboardButton)'>"
                )
                or next((m for s, m in methods.items() if "didLongPressBotButton" in s), None)
            )

            if not press:
                self.log("[inlinetools] didPressBotButton method not found; inline buttons disabled")
                return

            try:
                unhook = self.hook_method(press, _InlineButtonHook(self, is_long=False), priority=2147483647)
                if unhook:
                    self._unhooks.append(unhook)
            except Exception as e:
                self.log(f"[inlinetools] hook didPressBotButton failed: {e}")

            if long_press:
                try:
                    unhook2 = self.hook_method(long_press, _InlineButtonHook(self, is_long=True), priority=2147483647)
                    if unhook2:
                        self._unhooks.append(unhook2)
                except Exception as e:
                    self.log(f"[inlinetools] hook didLongPressBotButton failed: {e}")
            else:
                self.log("[inlinetools] didLongPressBotButton not found (ok)")

            long_press_avatar = next((m for s, m in methods.items() if "didLongPressUserAvatar" in s), None)
            if long_press_avatar:
                try:
                    unhook3 = self.hook_method(long_press_avatar, _UserAvatarLongPressHook(self), priority=2147483647)
                    if unhook3:
                        self._unhooks.append(unhook3)
                    self._install_avatar_menu_injection_hooks()
                except Exception as e:
                    self.log(f"[inlinetools] hook didLongPressUserAvatar failed: {e}")
            else:
                self.log("[inlinetools] didLongPressUserAvatar not found (ok)")

            self.log("[inlinetools] inline buttons hooks installed")

        except Exception as e:
            try:
                self.log(f"[inlinetools] install hooks error: {e}")
            except Exception:
                pass

    def _install_avatar_menu_injection_hooks(self):
        if self._avatar_menu_hooks_installed:
            return
        self._avatar_menu_hooks_installed = True

        try:
            item_opts_cls = find_class("org.telegram.ui.Components.ItemOptions")
            if item_opts_cls is not None:
                method = None
                try:
                    try:
                        declared = item_opts_cls.getClass().getDeclaredMethods()
                    except Exception:
                        declared = item_opts_cls.getDeclaredMethods()
                    for m in declared:
                        if m.getName() != "makeOptions":
                            continue
                        try:
                            p = m.getParameterTypes()
                            if len(p) == 2 and "BaseFragment" in str(p[0]) and "android.view.View" in str(p[1]):
                                method = m
                                break
                        except Exception:
                            continue
                except Exception:
                    method = None

                if method is not None:
                    try:
                        method.setAccessible(True)
                    except Exception:
                        pass
                    unhook = self.hook_method(method, _ItemOptionsMakeOptionsHook(self), priority=2147483647)
                    if unhook:
                        self._unhooks.append(unhook)
                else:
                    self.log("[inlinetools] ItemOptions.makeOptions(fragment, view) not found; fallback injection disabled")
        except Exception as e:
            try:
                self.log(f"[inlinetools] install ItemOptions hook error: {e}")
            except Exception:
                pass

        try:
            layout_cls = find_class("org.telegram.ui.AvatarPreviewer$Layout")
            if layout_cls is None:
                self.log("[inlinetools] AvatarPreviewer$Layout not found; previewer injection disabled")
                return

            set_data = None
            try:
                try:
                    declared = layout_cls.getClass().getDeclaredMethods()
                except Exception:
                    declared = layout_cls.getDeclaredMethods()
                for m in declared:
                    if m.getName() == "setData":
                        try:
                            p = m.getParameterTypes()
                            if len(p) != 1:
                                continue
                        except Exception:
                            pass
                        set_data = m
                        break
            except Exception:
                set_data = None

            if set_data is not None:
                try:
                    set_data.setAccessible(True)
                except Exception:
                    pass
                unhook2 = self.hook_method(set_data, _AvatarPreviewerLayoutSetDataHook(self), priority=2147483647)
                if unhook2:
                    self._unhooks.append(unhook2)

            set_showing = None
            try:
                try:
                    declared2 = layout_cls.getClass().getDeclaredMethods()
                except Exception:
                    declared2 = layout_cls.getDeclaredMethods()
                for m in declared2:
                    if m.getName() != "setShowing":
                        continue
                    try:
                        p = m.getParameterTypes()
                        if len(p) == 1 and "boolean" in str(p[0]).lower():
                            set_showing = m
                            break
                    except Exception:
                        continue
            except Exception:
                set_showing = None

            if set_showing is not None:
                try:
                    set_showing.setAccessible(True)
                except Exception:
                    pass
                unhook3 = self.hook_method(set_showing, _AvatarPreviewerLayoutSetShowingHook(self), priority=2147483647)
                if unhook3:
                    self._unhooks.append(unhook3)
        except Exception as e:
            try:
                self.log(f"[inlinetools] install AvatarPreviewer hooks error: {e}")
            except Exception:
                pass

    def _handle_user_avatar_long_press(self, hook_param):
        try:
            if not self._avatar_context_menu_enabled():
                return

            delegate = getattr(hook_param, "thisObject", None)
            cell = hook_param.args[0] if hook_param.args and len(hook_param.args) > 0 else None
            user = hook_param.args[1] if hook_param.args and len(hook_param.args) > 1 else None
            if cell is None or user is None:
                return

            outer = None
            try:
                outer = getattr(delegate, "this$0", None) if delegate is not None else None
            except Exception:
                outer = None

            if outer is None:
                try:
                    msg_obj = cell.getMessageObject() if hasattr(cell, "getMessageObject") else None
                    if msg_obj is not None:
                        outer = self._get_current_chat_activity(int(msg_obj.getDialogId()))
                except Exception:
                    outer = None

            try:
                ab = getattr(outer, "actionBar", None) if outer is not None else None
                if ab is not None and hasattr(ab, "isActionModeShowed") and bool(ab.isActionModeShowed()):
                    return
            except Exception:
                pass

            self._avatar_menu_pending_ctx = (cell, user, float(time.time()))
        except Exception:
            pass

    def _after_user_avatar_long_press(self, hook_param):
        try:
            self._avatar_menu_pending_ctx = None
        except Exception:
            pass

    def _open_inline_menu_for_user(self, cell, user):
        try:
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is None:
                return
            dialog_id = int(msg_obj.getDialogId())
            uid = int(getattr(user, "id", 0) or 0)
            if uid == 0:
                return
            self._show_ban_panel(dialog_id, [uid])
        except Exception:
            pass

    def _maybe_inject_inline_menu_into_item_options(self, hook_param):
        ctx = self._avatar_menu_pending_ctx
        if ctx is None:
            return
        try:
            cell, user, _ts = ctx
            try:
                if float(time.time()) - float(_ts) > 5.0:
                    return
            except Exception:
                pass

            try:
                scrim_view = hook_param.args[1] if hook_param.args and len(hook_param.args) > 1 else None
                if scrim_view is not None and cell is not None and scrim_view != cell:
                    return
            except Exception:
                pass

            opts = None
            try:
                opts = hook_param.getResult()
            except Exception:
                opts = getattr(hook_param, "result", None)
            if opts is None:
                return

            label = "\u0418\u043d\u043b\u0430\u0439\u043d-\u043c\u0435\u043d\u044e"
            icon_id = 0
            try:
                R = jclass("org.telegram.messenger.R")
                icon_id = int(getattr(getattr(R, "drawable", None), "msg_folders", 0) or 0)
            except Exception:
                icon_id = 0

            try:
                if icon_id:
                    opts.add(icon_id, label, Runnable(lambda: self._open_inline_menu_for_user(cell, user)))
                else:
                    opts.add(label, Runnable(lambda: self._open_inline_menu_for_user(cell, user)))
            except Exception:
                pass
        finally:
            self._avatar_menu_pending_ctx = None

    def _maybe_inject_inline_menu_into_avatar_previewer_layout(self, hook_param):
        try:
            layout = getattr(hook_param, "thisObject", None)
            if layout is None:
                return

            ctx = None
            if self._avatar_previewer_layout is not None and layout == self._avatar_previewer_layout:
                ctx = self._avatar_previewer_ctx
            if ctx is None and self._avatar_menu_pending_ctx is not None:
                self._avatar_previewer_layout = layout
                self._avatar_previewer_ctx = self._avatar_menu_pending_ctx
                ctx = self._avatar_previewer_ctx
                self._avatar_menu_pending_ctx = None
            if ctx is None:
                return

            cell, user, _ts = ctx
            try:
                if float(time.time()) - float(_ts) > 30.0:
                    self._avatar_previewer_layout = None
                    self._avatar_previewer_ctx = None
                    return
            except Exception:
                pass

            try:
                AvatarPreviewer = jclass("org.telegram.ui.AvatarPreviewer")
                if not bool(AvatarPreviewer.getInstance().isVisible()):
                    self._avatar_previewer_layout = None
                    self._avatar_previewer_ctx = None
                    return
            except Exception:
                pass
            menu = get_private_field(layout, "menu")
            if menu is None:
                return

            try:
                child_count = int(menu.getChildCount())
                if child_count > 0:
                    last_view = menu.getChildAt(child_count - 1)
                    if last_view is not None and hasattr(last_view, "updateSelectorBackground"):
                        if child_count == 1:
                            last_view.updateSelectorBackground(True, False)
                        else:
                            last_view.updateSelectorBackground(False, False)
            except Exception:
                pass

            ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
            resources_provider = get_private_field(layout, "resourcesProvider")

            label = "\u0418\u043d\u043b\u0430\u0439\u043d-\u043c\u0435\u043d\u044e"
            icon_id = 0
            try:
                R = jclass("org.telegram.messenger.R")
                icon_id = int(getattr(getattr(R, "drawable", None), "msg_folders", 0) or 0)
            except Exception:
                icon_id = 0

            item = ActionBarMenuItem.addItem(False, True, menu, icon_id, label, False, resources_provider)
            if item is None:
                return

            def _click(_view=None):
                try:
                    AvatarPreviewer = jclass("org.telegram.ui.AvatarPreviewer")
                    AvatarPreviewer.getInstance().close()
                except Exception:
                    pass
                self._open_inline_menu_for_user(cell, user)

            try:
                item.setOnClickListener(OnClickListener(_click))
            except Exception:
                pass
        except Exception:
            pass

    def _maybe_clear_avatar_previewer_ctx(self, hook_param):
        try:
            if self._avatar_previewer_layout is None:
                return
            layout = getattr(hook_param, "thisObject", None)
            if layout is None or layout != self._avatar_previewer_layout:
                return
            showing = None
            try:
                showing = bool(hook_param.args[0]) if hook_param.args and len(hook_param.args) > 0 else None
            except Exception:
                showing = None
            if showing is False:
                self._avatar_previewer_layout = None
                self._avatar_previewer_ctx = None
        except Exception:
            pass

    def _show_user_avatar_context_menu(self, delegate, chat_activity, cell, user):
        try:
            from org.telegram.ui.Components import ItemOptions

            fragment = chat_activity or self._get_current_chat_activity(
                int(cell.getMessageObject().getDialogId()) if cell and cell.getMessageObject() else 0
            )
            if fragment is None:
                return

            opts = ItemOptions.makeOptions(fragment, cell)

            def _open_inline_menu():
                try:
                    msg_obj = cell.getMessageObject() if cell else None
                    if msg_obj is None:
                        return
                    dialog_id = int(msg_obj.getDialogId())
                    uid = int(getattr(user, "id", 0) or 0)
                    if uid == 0:
                        return
                    self._show_ban_panel(dialog_id, [uid])
                except Exception:
                    pass

            opts.add("Инлайн-меню", Runnable(_open_inline_menu))

            def _invoke_delegate(method_name: str, *args):
                try:
                    if delegate is None:
                        return
                    m = None
                    try:
                        for cand in delegate.getClass().getDeclaredMethods():
                            try:
                                if cand.getName() == method_name and len(cand.getParameterTypes()) == len(args):
                                    m = cand
                                    break
                            except Exception:
                                continue
                    except Exception:
                        m = None
                    if m is None:
                        return
                    try:
                        m.setAccessible(True)
                    except Exception:
                        pass
                    try:
                        m.invoke(delegate, *args)
                    except Exception:
                        try:
                            m.invoke(delegate, args)
                        except Exception:
                            pass
                except Exception:
                    pass

            opts.add("Открыть профиль", Runnable(lambda: _invoke_delegate("openProfile", user)))
            opts.add("Написать", Runnable(lambda: _invoke_delegate("openDialog", cell, user)))
            try:
                current_chat = getattr(fragment, "currentChat", None)
                if current_chat is not None:
                    opts.add("Упомянуть", Runnable(lambda: _invoke_delegate("appendMention", user)))

                    def _invoke_fragment(method_name: str, *args):
                        try:
                            m = None
                            try:
                                for cand in fragment.getClass().getDeclaredMethods():
                                    try:
                                        if cand.getName() == method_name and len(cand.getParameterTypes()) == len(args):
                                            m = cand
                                            break
                                    except Exception:
                                        continue
                            except Exception:
                                m = None
                            if m is None:
                                return
                            try:
                                m.setAccessible(True)
                            except Exception:
                                pass
                            try:
                                m.invoke(fragment, *args)
                            except Exception:
                                try:
                                    m.invoke(fragment, args)
                                except Exception:
                                    pass
                        except Exception:
                            pass

                    opts.add("Поиск сообщений", Runnable(lambda: _invoke_fragment("openSearchWithUser", user)))
            except Exception:
                pass

            try:
                opts.setDrawScrim(False)
            except Exception:
                pass
            try:
                Gravity = jclass("android.view.Gravity")
                opts.setGravity(int(getattr(Gravity, "LEFT", 3)))
            except Exception:
                pass
            try:
                opts.forceBottom(True)
            except Exception:
                pass
            try:
                opts.translate(0, -float(AndroidUtilities.dp(48)))
            except Exception:
                pass

            opts.show()
        except Exception as e:
            try:
                self.log(f"[inlinetools] avatar context menu error: {e}")
            except Exception:
                pass

    def _handle_inline_button_click(self, cell, btn, hook_param, *, is_long: bool):
        try:
            if btn is None:
                return

            if not hasattr(btn, "data"):
                return

            data_raw = getattr(btn, "data", None)
            if data_raw is None:
                return

            data = bytes(data_raw).decode("utf-8", errors="ignore")
            if not data.startswith(_CALLBACK_PREFIX):
                return

            self._maybe_ripple_on_inline_click(cell)
            hook_param.setResult(None)
            self._dispatch_panel_action(cell, data)
        except Exception as e:
            try:
                self.log(f"[inlinetools] handle_inline_button_click error: {e}")
            except Exception:
                pass

    def _dispatch_panel_action(self, cell, data: str):
        parts = data.split(":")
        if len(parts) < 3:
            return

        token = parts[1]
        action = parts[2]
        arg = parts[3] if len(parts) > 3 else None

        ctx = self._panels.get(token)
        if ctx is None:
            BulletinHelper.show_error("Контекст панели не найден (перезагрузи плагин).")
            return

        if action == "nav":
            page = (arg or "").strip().lower()
            if page not in (_PAGE_MAIN, _PAGE_BAN, _PAGE_MUTE, _PAGE_WARN, _PAGE_DELETE):
                page = _PAGE_MAIN
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is None:
                return
            run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=page))
            return

        if action == "close":
            self._panels.pop(token, None)
            self._close_panel(cell)
            return

        if action == "custom_time":
            kind = (arg or "").strip().lower()
            if kind not in (_PAGE_BAN, _PAGE_MUTE):
                return
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is None:
                return
            run_on_ui_thread(lambda: self._show_custom_time_dialog(kind=kind, dialog_id=ctx.dialog_id, user_ids=list(ctx.user_ids), token=token, cell=cell, msg_obj=msg_obj))
            return

        if action == "del_n":
            n = 0
            try:
                n = int(arg or "0")
            except Exception:
                n = 0
            if n <= 0:
                return
            n = self._parse_int(n, default=10, min_value=1, max_value=500)
            self._delete_last_messages_from_users(ctx.dialog_id, list(ctx.user_ids), n)
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is not None:
                run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=ctx.page))
            return

        if action == "del_custom":
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is None:
                return
            run_on_ui_thread(lambda: self._show_custom_delete_count_dialog(dialog_id=ctx.dialog_id, user_ids=list(ctx.user_ids), token=token, cell=cell, msg_obj=msg_obj))
            return

        if action == "warn_add":
            delta = 1
            try:
                delta = int(arg or "1")
            except Exception:
                delta = 1
            counts = self._add_warns(ctx.dialog_id, ctx.user_ids, delta)
            if delta > 0:
                self._maybe_apply_warn_punishment(ctx.dialog_id, counts)
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is not None:
                run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=ctx.page))
            return

        if action == "warn_reset":
            self._add_warns(ctx.dialog_id, ctx.user_ids, -99)
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is not None:
                run_on_ui_thread(lambda: self._update_local_panel_message(cell, msg_obj, token=token, page=ctx.page))
            return

        if action == "ban":
            seconds = 0
            try:
                seconds = int(arg or "0")
            except Exception:
                seconds = 0
            until_date = 0 if seconds <= 0 else int(time.time()) + seconds
            run_on_queue(lambda: self._ban_users(ctx.dialog_id, ctx.user_ids, until_date))
            return

        if action == "mute":
            seconds = 0
            try:
                seconds = int(arg or "0")
            except Exception:
                seconds = 0
            until_date = 0 if seconds <= 0 else int(time.time()) + seconds
            run_on_queue(lambda: self._mute_users(ctx.dialog_id, ctx.user_ids, until_date))
            return

        if action == "unban":
            run_on_queue(lambda: self._unban_users(ctx.dialog_id, ctx.user_ids))
            return

        if action == "unmute":
            run_on_queue(lambda: self._unmute_users(ctx.dialog_id, ctx.user_ids))
            return

        if action == "kick":
            run_on_queue(lambda: self._kick_users(ctx.dialog_id, ctx.user_ids))
            return

    def _close_panel(self, cell):
        try:
            msg_obj = cell.getMessageObject() if cell else None
            if msg_obj is None:
                return
            chat_activity = self._get_current_chat_activity(int(msg_obj.getDialogId()))
            if chat_activity is None:
                return
            self._remove_local_message(chat_activity, msg_obj)
        except Exception:
            pass


    def _ban_users(self, dialog_id: int, user_ids: List[int], until_date: int):
        self._edit_banned_rights(dialog_id, user_ids, until_date=until_date, ban=True)

    def _unban_users(self, dialog_id: int, user_ids: List[int]):
        self._edit_banned_rights(dialog_id, user_ids, until_date=0, ban=False)

    def _mute_users(self, dialog_id: int, user_ids: List[int], until_date: int):
        self._edit_muted_rights(dialog_id, user_ids, until_date=until_date, mute=True)

    def _unmute_users(self, dialog_id: int, user_ids: List[int]):
        self._edit_muted_rights(dialog_id, user_ids, until_date=0, mute=False)

    def _kick_users(self, dialog_id: int, user_ids: List[int]):
        mc = get_messages_controller()
        chat_id = int(-dialog_id) if dialog_id < 0 else 0
        chat = mc.getChat(chat_id) if chat_id else None
        if not chat_id or chat is None:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Команда доступна только в группах/каналах."))
            return

        if ChatObject.isChannel(chat):
            self._kick_users_channel(chat_id, user_ids)
        else:
            self._kick_users_basic_group(chat_id, user_ids)

    def _kick_users_basic_group(self, chat_id: int, user_ids: List[int]):
        self._run_requests_grouped(
            user_ids,
            start_text=f"Кик: {len(user_ids)}",
            success_text="Кик выполнен.",
            error_prefix="Кик: ошибка",
            build_request=lambda uid: self._req_delete_chat_user(chat_id, uid),
        )

    def _kick_users_channel(self, chat_id: int, user_ids: List[int]):
        mc = get_messages_controller()

        lock = threading.Lock()
        state = {"pending": len(user_ids), "ok": 0, "errors": []}

        def finish_one(ok: bool, err: Optional[str] = None):
            with lock:
                if ok:
                    state["ok"] += 1
                elif err:
                    state["errors"].append(err)
                state["pending"] -= 1
                done = state["pending"] <= 0

            if done:
                if state["errors"]:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"Кик: {state['ok']}/{len(user_ids)} ок\n" + "\n".join(state["errors"][:3])))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(f"Кик: {state['ok']}/{len(user_ids)} ок"))

        for uid in user_ids:
            ban_req = self._req_edit_banned(chat_id, uid, until_date=int(time.time()) + 60, ban=True)

            def ban_cb(response, error, _uid=uid):
                if error:
                    finish_one(False, f"{_uid}: {getattr(error, 'text', 'error')}")
                    return

                unban_req = self._req_edit_banned(chat_id, _uid, until_date=0, ban=False)

                def unban_cb(response2, error2, __uid=_uid):
                    if error2:
                        finish_one(False, f"{__uid}: {getattr(error2, 'text', 'unban error')}")
                    else:
                        finish_one(True, None)

                send_request(unban_req, RequestCallback(unban_cb))

            send_request(ban_req, RequestCallback(ban_cb))

    def _edit_banned_rights(self, dialog_id: int, user_ids: List[int], *, until_date: int, ban: bool):
        mc = get_messages_controller()
        chat_id = int(-dialog_id) if dialog_id < 0 else 0
        chat = mc.getChat(chat_id) if chat_id else None
        if not chat_id or chat is None:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Команда доступна только в группах/каналах."))
            return

        if ChatObject.isChannel(chat):
            self._run_requests_grouped(
                user_ids,
                start_text=("Бан" if ban else "Разбан") + f": {len(user_ids)}",
                success_text=("Бан выполнен." if ban else "Разбан выполнен."),
                error_prefix=("Бан: ошибка" if ban else "Разбан: ошибка"),
                build_request=lambda uid: self._req_edit_banned(chat_id, uid, until_date=until_date, ban=ban),
            )
        else:
            if ban:
                self._kick_users_basic_group(chat_id, user_ids)
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error("Разбан недоступен в обычных группах (только супер-группы/каналы)."))

    def _edit_muted_rights(self, dialog_id: int, user_ids: List[int], *, until_date: int, mute: bool):
        mc = get_messages_controller()
        chat_id = int(-dialog_id) if dialog_id < 0 else 0
        chat = mc.getChat(chat_id) if chat_id else None
        if not chat_id or chat is None:
            run_on_ui_thread(lambda: BulletinHelper.show_error("Команда доступна только в группах/каналах."))
            return

        if not ChatObject.isChannel(chat):
            run_on_ui_thread(lambda: BulletinHelper.show_error("Мут доступен только в супер-группах/каналах."))
            return

        self._run_requests_grouped(
            user_ids,
            start_text=("Мут" if mute else "Размут") + f": {len(user_ids)}",
            success_text=("Мут выполнен." if mute else "Размут выполнен."),
            error_prefix=("Мут: ошибка" if mute else "Размут: ошибка"),
            build_request=lambda uid: self._req_mute(chat_id, uid, until_date=until_date, mute=mute),
        )

    def _run_requests_grouped(
        self,
        user_ids: List[int],
        *,
        start_text: str,
        success_text: str,
        error_prefix: str,
        build_request,
    ):
        if not user_ids:
            return

        lock = threading.Lock()
        state = {"pending": len(user_ids), "ok": 0, "errors": []}

        def finish_one(ok: bool, err: Optional[str] = None):
            with lock:
                if ok:
                    state["ok"] += 1
                elif err:
                    state["errors"].append(err)
                state["pending"] -= 1
                done = state["pending"] <= 0

            if done:
                if state["errors"]:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(f"{error_prefix}: {state['ok']}/{len(user_ids)} ок\n" + "\n".join(state["errors"][:3])))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(success_text))

        for uid in user_ids:
            try:
                req = build_request(uid)
            except Exception as e:
                finish_one(False, f"{uid}: {e}")
                continue

            def cb(response, error, _uid=uid):
                if error:
                    finish_one(False, f"{_uid}: {getattr(error, 'text', 'error')}")
                else:
                    finish_one(True, None)

            send_request(req, RequestCallback(cb))

    def _req_edit_banned(self, chat_id: int, user_id: int, *, until_date: int, ban: bool):
        mc = get_messages_controller()
        req = TLRPC.TL_channels_editBanned()
        req.channel = mc.getInputChannel(chat_id)
        req.participant = mc.getInputPeer(user_id)

        rights = TLRPC.TL_chatBannedRights()
        if ban:
            for attr in dir(rights):
                try:
                    if isinstance(getattr(rights, attr), bool):
                        setattr(rights, attr, True)
                except Exception:
                    pass
        rights.until_date = int(until_date or 0)
        req.banned_rights = rights
        return req

    def _req_mute(self, chat_id: int, user_id: int, *, until_date: int, mute: bool):
        mc = get_messages_controller()
        req = TLRPC.TL_channels_editBanned()
        req.channel = mc.getInputChannel(chat_id)
        req.participant = mc.getInputPeer(user_id)

        rights = TLRPC.TL_chatBannedRights()
        if mute:
            for name in (
                "send_messages",
                "send_media",
                "send_stickers",
                "send_gifs",
                "send_games",
                "send_inline",
                "embed_links",
                "send_polls",
                "send_photos",
                "send_videos",
                "send_roundvideos",
                "send_audios",
                "send_voices",
                "send_docs",
                "send_plain",
            ):
                if hasattr(rights, name):
                    try:
                        setattr(rights, name, True)
                    except Exception:
                        pass
            rights.until_date = int(until_date or 0)
        else:
            rights.until_date = 0

        req.banned_rights = rights
        return req

    def _req_delete_chat_user(self, chat_id: int, user_id: int):
        mc = get_messages_controller()
        req = TLRPC.TL_messages_deleteChatUser()
        req.chat_id = int(chat_id)
        req.user_id = mc.getInputUser(int(user_id))
        return req


    def _extract_target_user_ids(self, params, text: str) -> List[int]:
        ids: List[int] = []

        reply = getattr(params, "replyToMsg", None)
        if reply is not None:
            uid = self._get_user_id_from_reply(reply)
            if uid:
                ids.append(uid)

        parts = text.split()
        for tok in parts[1:]:
            tok = tok.strip()
            if not tok:
                continue
            if tok.isdigit():
                try:
                    ids.append(int(tok))
                except Exception:
                    pass

        out: List[int] = []
        seen = set()
        for uid in ids:
            if uid and uid not in seen:
                out.append(uid)
                seen.add(uid)
        return out

    def _get_user_id_from_reply(self, reply_msg) -> Optional[int]:
        try:
            if hasattr(reply_msg, "messageOwner") and reply_msg.messageOwner:
                mo = reply_msg.messageOwner
                if hasattr(mo, "from_id") and mo.from_id and hasattr(mo.from_id, "user_id"):
                    return int(mo.from_id.user_id)
            if hasattr(reply_msg, "replyMessageObject") and reply_msg.replyMessageObject:
                mo = reply_msg.replyMessageObject.messageOwner
                if hasattr(mo, "from_id") and mo.from_id and hasattr(mo.from_id, "user_id"):
                    return int(mo.from_id.user_id)
        except Exception:
            return None
        return None

    def _new_token(self) -> str:
        alphabet = "abcdefghijklmnopqrstuvwxyz0123456789"
        return "".join(random.choice(alphabet) for _ in range(8))

    def _safe_int32(self, value: Any, *, default: int = 0) -> int:
        try:
            x = int(value)
            if x > 2_147_483_647 or x < -2_147_483_648:
                return int(default)
            return x
        except Exception:
            return int(default)
