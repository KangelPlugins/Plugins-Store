__id__ = "text_toolbar"
__name__ = "Text Toolbar"
__description__ = 'Adds a customizable text toolbar to the message input field, providing quick access to formatting, text management, and message control tools.'
__author__ = "@PESSDES_Plugins"
__min_version__ = "11.12.1"
__icon__ = "VoiceToText7/14"
__version__ = "2.0" 

from base_plugin import MethodHook, BasePlugin
from org.telegram.ui.Components import ChatActivityEnterView, LayoutHelper, AnimatedEmojiDrawable
from org.telegram.ui.Stories.recorder import CaptionContainerView
from android.view import View
from org.telegram.messenger import AndroidUtilities, UserConfig, Emoji
from android_utils import log as logcat
from android.widget import TextView, LinearLayout, ImageView, FrameLayout, HorizontalScrollView
from client_utils import get_last_fragment
from org.telegram.ui.ActionBar import Theme, ThemeColors
from android.text import SpannableStringBuilder
from android.graphics import Typeface
from android.util import TypedValue
from android.graphics import PorterDuffColorFilter, PorterDuff
from android.view import Gravity
from hook_utils import get_private_field, get_static_private_field
from android.content import Context
from typing import Dict, Optional, List
from android.widget import FrameLayout
from ui.settings import Selector
from ui.bulletin import BulletinHelper
from java.lang import Boolean, Integer, Long
from org.telegram.ui.Components import AnimatedEmojiSpan
from typing import Union, Callable
from java import dynamic_proxy

BounceableImageView = CaptionContainerView.BounceableImageView

def log(m):
    logcat(f'[{__id__}] {m}')

HIDDEN = 0
COLLAPSED = 1
EXPANDED = 2
VISIBLE = 2

SINGLE_SET = [HIDDEN, VISIBLE]
SET = [HIDDEN, COLLAPSED, VISIBLE]
class Plugin(BasePlugin):
    buttons = {
        30: ("Растянуть на весь экран", SINGLE_SET),
        0: ("Упомянуть", SINGLE_SET),
        10: ("Форматирование", SET),
        20: ("Управление текстом", SET),
        60: ("Недавние эмодзи", SET),
        40: ("Повторить сообщение", SINGLE_SET),
        50: ("Скрыть клавиатуру", SINGLE_SET)
    }

    sets = {
        HIDDEN: "Скрыть",
        COLLAPSED: "Свернуть",
        VISIBLE: "Показать"
    }

    def create_settings(self):
        try:
            res = [Selector(f'set_{num}', name, COLLAPSED, [self.sets[n] for n in set]) for num, (name, set) in self.buttons.items()]
            return res
        except Exception as e:
            log(f"Failed to create settings: {e}")
            return []

    def on_plugin_load(self):
        self.hook_method(ChatActivityEnterView.getClass().getDeclaredConstructors()[1], EnterViewHook(self))
        self.hook_method(ChatActivityEnterView.getClass().getDeclaredMethod("sendMessageInternal", Boolean.TYPE, Integer.TYPE, Long.TYPE, Boolean.TYPE), OnSend())
    
    _collapse_states: Dict[int, bool] = {}

    def is_collapsed(self, id) -> bool:
        state = self._collapse_states.get(id, True)
        return state

    def set_collapsed(self, id, value: bool):
        self._collapse_states[id] = value
    
    def update_collapsed(self, id) -> bool:
        val = self.is_collapsed(id)
        self.set_collapsed(id, not val)
        return not val
    
    def get_set(self, id):
        i = self.get_setting(f"set_{id}", COLLAPSED)
        if i == VISIBLE and self.buttons[id][1] == SINGLE_SET:
            return COLLAPSED
        return i

LAST_TEXT = None

class OnSend(MethodHook):
    def before_hooked_method(self, param):
        try:
            messageEditText = get_private_field(param.thisObject, "messageEditText")
            text = None if messageEditText == None else messageEditText.getText()
            if not EnterViewHook.items_layout or text is None or not text.toString().strip():
                return
            global LAST_TEXT
            LAST_TEXT = text
            resend = EnterViewHook.items_layout.findViewWithTag(40)
            resend.setVisibility(View.VISIBLE)
            index = EnterViewHook.items_layout.indexOfChild(resend)
            if (index != -1 and index + 1 < EnterViewHook.items_layout.getChildCount()):
                EnterViewHook.items_layout.getChildAt(index + 1).setVisibility(View.VISIBLE)
        except Exception as e:
            log(f"Failed to update text: {e}")

class EnterViewHook(MethodHook):
    items_layout = None
    def __init__(self, plugin: Plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.input_expanded = False
            self.chat_activity_enter_view: ChatActivityEnterView = param.thisObject

            if not get_private_field(param.thisObject, "messageEditText").isEnabled():
                return

            self.ly = ly = LinearLayout(param.args[0])
            ly.setOrientation(LinearLayout.VERTICAL)

            tfc = get_private_field(param.thisObject, "textFieldContainer")
            tfc.getParent().removeView(tfc)
            tfc_wrap = FrameLayout(param.args[0])
            tfc_wrap.addView(tfc)
            ly.addView(tfc_wrap)

            self.items_layout = items_layout = LinearLayout(param.args[0])
            items_layout.setOrientation(LinearLayout.HORIZONTAL)

            items_layout_wrap = HorizontalScrollView(param.args[0])
            items_layout_wrap.addView(items_layout)
            ly.addView(items_layout_wrap, LayoutHelper.createLinear(-1, 36, Gravity.BOTTOM, 8, 0, 8, 0))
            EnterViewHook.items_layout = items_layout
            
            param.thisObject.addView(ly, LayoutHelper.createFrame(-1, -2, Gravity.BOTTOM))

            self._add_new_item(30, "pip_video_expand")
            self._add_new_item(0, "mentionbutton")
            self._add_new_item(10, "msg_text_outlined", [
                "msg_clear",
                self._create_text_icon("B", Typeface.BOLD), 
                self._create_text_icon("I", Typeface.ITALIC),
                self._create_text_icon("M", Typeface.NORMAL), 
                self._create_text_icon("S", Typeface.NORMAL), 
                self._create_text_icon("U", Typeface.NORMAL), 
                "menu_link_create",
                self._create_emoji_icon(5886437972647088483), 
                "msg_spoiler",])
            self._add_new_item(20, "msg_edit", [
                "menu_select_quote",
                "attach_arrow_left",
                "attach_arrow_right",
                "msg_copy",
                self._create_emoji_icon(5877597667231534929)
            ])

            Emoji.loadRecentEmoji()
            recent_emojis = [self._parse_emoji(x) for x in Emoji.recentEmoji.toArray()[:5]]
            if len(recent_emojis) == 0:
                recent_emojis = get_static_private_field(Emoji.getClass(), "DEFAULT_RECENT")[:5]
            if recent_emojis is not None and len(recent_emojis) > 0:
                self._add_new_item(60, "input_smile", [self._create_emoji_icon(emoji_id) for emoji_id in recent_emojis])

            resend = self._add_new_item(40, "msg_retry")
            if resend is not None and LAST_TEXT is None:
                resend.setVisibility(View.GONE)
                index = self.items_layout.indexOfChild(resend)
                if (index != -1 and index + 1 < self.items_layout.getChildCount()):
                    self.items_layout.getChildAt(index + 1).setVisibility(View.GONE)
            self._add_new_item(50, "input_keyboard")

            if self.items_layout.getChildCount() == 0:
                self.items_layout.setVisibility(View.GONE)
            
            self.max_lines = self.chat_activity_enter_view.getEditField().getMaxLines()
        except Exception as e:
            log(e)

    def _parse_emoji(self, str: str) -> Union[int, str]:
        if str.startswith("animated_"):
            return int(str[len("animated_"):])
        return str
    
    def on_item_click(self, view):
        try:
            id: int = view.getTag()
            text_field = self.chat_activity_enter_view.getEditField()
            if not text_field:
                return

            if id % 10 == 0 and Plugin.buttons[id][1] == SET:
                is_visible = self.plugin.update_collapsed(id)
                for i in range(id + 1, id + 10):
                    item = self.items_layout.findViewWithTag(i)
                    if item != None:
                        item.setVisibility(View.GONE if is_visible else View.VISIBLE)
                    else:
                        break
                return
            
            if id >= 0 and id < 10:
                text: SpannableStringBuilder = text_field.getText()
                str_text = text.toString()
                add_text = ""
                if str_text and not str_text.endswith(" "):
                    add_text += " "
                add_text += "@"
                text.append(add_text)
            elif id >= 10 and id < 20:    
                start_selection = text_field.getSelectionStart()
                end_selection = text_field.getSelectionEnd()
                if start_selection == end_selection:
                    return

                text_field.setSelectionOverride(start_selection, end_selection)

                if id == 11:
                    text_field.makeSelectedRegular()
                if id == 12:
                    text_field.makeSelectedBold()
                elif id == 13:
                    text_field.makeSelectedItalic()
                elif id == 14:
                    text_field.makeSelectedMono()
                elif id == 15:
                    text_field.makeSelectedStrike()
                elif id == 16:
                    text_field.makeSelectedUnderline()
                elif id == 17:
                    text_field.makeSelectedUrl()
                elif id == 18:
                    text_field.makeSelectedQuote(True)
                elif id == 19:
                    text_field.makeSelectedSpoiler()
            elif id >= 20 and id < 30:
                if id == 21: text_field.selectAll()
                elif id == 22: text_field.setSelection(0)
                elif id == 23: text_field.setSelection(text_field.getText().length())
                elif id == 24: 
                    start_selection = text_field.getSelectionStart()
                    end_selection = text_field.getSelectionEnd()
                    if start_selection == end_selection:
                        return
                    AndroidUtilities.addToClipboard(text_field.getText().subSequence(start_selection, end_selection).toString())
                    BulletinHelper.show_copied_to_clipboard()
                elif id == 25:
                    context = get_last_fragment().getContext()
                    clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
                    if clipboard.hasPrimaryClip():
                        clip_data = clipboard.getPrimaryClip()
                        if clip_data.getItemCount() > 0:
                            pasted_text = clip_data.getItemAt(0).coerceToText(context)
                            if pasted_text:
                                start_selection = text_field.getSelectionStart()
                                end_selection = text_field.getSelectionEnd()
                                text_field.getText().replace(start_selection, end_selection, pasted_text)
                                text_field.setSelection(start_selection + len(pasted_text))
            elif id == 30:
                content_view = self.chat_activity_enter_view.getParent()
                if not self.input_expanded:
                    self.original_height = self.chat_activity_enter_view.getLayoutParams().height
                self.input_expanded = not self.input_expanded
                if content_view:
                    lp = self.chat_activity_enter_view.getLayoutParams()
                    if self.input_expanded:
                        text_field.setMaxLines(2**31-1)
                        lp.height = content_view.getHeight() - AndroidUtilities.getStatusBarHeight(get_last_fragment().getContext()) - self.chat_activity_enter_view.getParentFragment().getActionBar().getCurrentActionBarHeight()
                    else:
                        text_field.setMaxLines(self.max_lines)
                        lp.height = self.original_height
                    self.chat_activity_enter_view.setLayoutParams(lp)
            elif id == 40:
                if LAST_TEXT is None:
                    AndroidUtilities.shakeView(view)
                    return
                text_field.setText(LAST_TEXT)
                text_field.setSelection(text_field.getText().length())
            elif id == 50:
                if self.chat_activity_enter_view.getParentFragment().isKeyboardVisible():
                    AndroidUtilities.hideKeyboard(self.chat_activity_enter_view.getParentFragment().getParentActivity().getCurrentFocus())
                else:
                    self.chat_activity_enter_view.openKeyboard()

                if self.input_expanded:
                    self.on_item_click(self.items_layout.findViewWithTag(30))
            elif id >= 60 and id < 70:
                start_selection = text_field.getSelectionStart()
                end_selection = text_field.getSelectionEnd()

                emoji_data = self._parse_emoji(Emoji.recentEmoji.toArray()[id - 61])
                if isinstance(emoji_data, str):
                    if start_selection == end_selection:
                        text_field.getText().insert(start_selection, emoji_data)
                    else:
                        text_field.getText().replace(start_selection, end_selection, emoji_data)
                else:
                    span = AnimatedEmojiSpan(emoji_data, text_field.getPaint().getFontMetricsInt())
                    text = text_field.getText()
                    text.replace(start_selection, end_selection, "😀")
                    text.setSpan(span, start_selection, start_selection + 2, 33)
                
        except Exception as e:
            log(e)
    
    def _create_text_icon(self, symbol: str, style: int) -> View:
        ic = TextView(get_last_fragment().getContext())
        ic.setText(symbol)
        ic.setTypeface(None, style)
        ic.setTextColor(TelegramUtils.get_color("chat_messagePanelIcons"))
        ic.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM)
        ic.setAutoSizeTextTypeUniformWithConfiguration(
                10,
                100,
                1,
                TypedValue.COMPLEX_UNIT_SP
        )
        ic.setGravity(Gravity.CENTER)
        ic.setScaleX(0.9)
        ic.setScaleY(0.9)
        return ic

    def _create_emoji_icon(self, emoji: Union[int, str]) -> View:    
        ic = self._create_image_view_icon()
        
        if isinstance(emoji, int):
            drawable = AnimatedEmojiDrawable.make(UserConfig.selectedAccount, AnimatedEmojiDrawable.getCacheTypeForEnterView(), emoji)
            drawable.addView(ic)
        else:
            drawable = Emoji.getEmojiDrawable(emoji)
            
        ic.setImageDrawable(drawable) 
        ic.setScaleX(0.85)
        ic.setScaleY(0.85)
        return ic

    def _create_image_view_icon(self) -> BounceableImageView:
        ic = BounceableImageView(self.ly.getContext(), 0.1)
        ic.setColorFilter(PorterDuffColorFilter(TelegramUtils.get_color("chat_messagePanelIcons"), PorterDuff.Mode.MULTIPLY))
        ic.setScaleType(ImageView.ScaleType.CENTER)
        ic.setBackground(Theme.createSelectorDrawable(TelegramUtils.get_color_id("listSelectorSDK21")))
        return ic

    def _add_new_item(self, item_id: int, icon: Union[str,View], sub_items: Optional[List[Union[str, View]]] = None, divider: bool = True):
        set = VISIBLE if item_id % 10 != 0 else self.plugin.get_set(item_id)
        collapsed = False if set == VISIBLE else self.plugin.is_collapsed(item_id)
        ic = None

        if set == HIDDEN:
            return ic
        
        if set != VISIBLE or (item_id % 10 != 0):
            if isinstance(icon, str):
                ic = self._create_image_view_icon()
                ic.setImageResource(TelegramUtils.get_icon_id(icon))
            else:
                ic = icon
            ic.setOnClickListener(OnClickListener(self.on_item_click))
            ic.setTag(item_id)
            self.items_layout.addView(ic, LayoutHelper.createLinear(36, 36))

        if sub_items is not None:
            for i, sub_item in enumerate(sub_items):
                new_item = self._add_new_item(item_id + i + 1, sub_item, None, False)
                if new_item:
                    if collapsed:
                        new_item.setVisibility(View.GONE)

        if divider:
            divider_view = View(self.items_layout.getContext())
            divider_view.setBackgroundColor(TelegramUtils.get_color("divider"))
            self.items_layout.addView(divider_view, LayoutHelper.createLinear(2, -1, Gravity.CENTER_VERTICAL, 4, 8, 4, 8))
        
        return ic

class OnClickListener(dynamic_proxy(View.OnClickListener)):
    def __init__(self, fn: Callable[[View], None]):
        super().__init__()
        self.fn = fn
    
    def onClick(self, view):
        self.fn(view)

class TelegramUtils:
    @staticmethod
    def get_icon_id(name: str) -> int:
        context = get_last_fragment().getContext()
        return context.getResources().getIdentifier(name, "drawable", context.getPackageName())

    _colors_key_map: Dict[str, int] = None

    @classmethod
    def _init_colors_key_map(cls):
        if cls._colors_key_map is None:
            method = ThemeColors.getClass().getDeclaredMethod("createColorKeysStringMap")
            method.setAccessible(True)
            cls._colors_key_map = method.invoke(None)
    
    @classmethod
    def get_color_id(cls, name: str) -> int:
        cls._init_colors_key_map()
        return cls._colors_key_map.get(name)
    
    @classmethod
    def get_color(cls, name: str) -> int:
        return Theme.getColor(cls.get_color_id(name))