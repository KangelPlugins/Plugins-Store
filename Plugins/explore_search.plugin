import math
from typing import Any, Dict, List, Optional

from base_plugin import BasePlugin
from client_utils import RequestCallback, get_last_fragment, get_messages_controller, send_request
from android_utils import OnClickListener, run_on_ui_thread, log
from hook_utils import find_class, get_private_field

from java import dynamic_proxy, jclass

from android.graphics import Typeface
from android.graphics.drawable import GradientDrawable
from android.os import Bundle
from android.text import InputType
from android.util import TypedValue
from android.view import Gravity, View, ViewGroup
from android.widget import FrameLayout, LinearLayout, TextView, EditText, ImageView, ScrollView, HorizontalScrollView

from org.telegram.messenger import AndroidUtilities, ChatObject, UserObject, R
from org.telegram.tgnet import TLRPC
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import Theme
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, RLottieImageView

__id__ = "explore_search"
__name__ = "Explore Search"
__description__ = "Adds an Explore button with a beautiful content search UI and ranked results."
__author__ = "@mishabotov"
__version__ = "1.0.0 [beta]"
__icon__ = "alegquin33/81"


class ExploreSearchPlugin(BasePlugin):
    _DEBOUNCE_MS = 260
    _REQUEST_LIMIT = 80
    _GLOBAL_REQUEST_LIMIT = 36

    _COLOR_BG = 0xFF13233A
    _COLOR_BG_SOFT = 0xFF1A2F49
    _COLOR_CARD = 0xFF1A304C
    _COLOR_CARD_STROKE = 0x554D6F99
    _COLOR_TEXT = 0xFFF3F8FF
    _COLOR_TEXT_SOFT = 0xFF9FB4CF
    _COLOR_TEXT_MUTED = 0xFF7F96B5
    _COLOR_CHIP = 0xFF203955
    _COLOR_CHIP_ACTIVE = 0xFF2D4E79
    _COLOR_CHIP_ACTIVE_STROKE = 0xFF7FAEFA
    _COLOR_ACCENT = 0xFF6E9BFF
    _COLOR_EXPLORE_BUTTON = 0xFF405874

    def __init__(self):
        super().__init__()
        self._hook_create_view_ref = None
        self._hook_show_search_ref = None
        self._hook_show_search_short_ref = None
        self._hook_toggle_search_ref = None
        self._hook_destroy_ref = None
        self._hook_resume_ref = None
        self._states: Dict[int, Dict[str, Any]] = {}

    def on_plugin_load(self):
        self._safe_log("[ExploreSearch] loading plugin")
        self._hook_dialogs_create_view()
        self._hook_dialogs_show_search()
        self._hook_actionbar_toggle_search()
        self._hook_dialogs_destroy()
        self._hook_dialogs_resume()
        self._safe_log(
            "[ExploreSearch] hooks: createView=%s showSearch4=%s showSearch3=%s toggleSearch=%s onDestroy=%s onResume=%s"
            % (
                "ok" if self._hook_create_view_ref is not None else "no",
                "ok" if self._hook_show_search_ref is not None else "no",
                "ok" if self._hook_show_search_short_ref is not None else "no",
                "ok" if self._hook_toggle_search_ref is not None else "no",
                "ok" if self._hook_destroy_ref is not None else "no",
                "ok" if self._hook_resume_ref is not None else "no",
            )
        )

    def on_plugin_unload(self):
        for ref in (
            self._hook_create_view_ref,
            self._hook_show_search_ref,
            self._hook_show_search_short_ref,
            self._hook_toggle_search_ref,
            self._hook_destroy_ref,
            self._hook_resume_ref,
        ):
            if ref is not None:
                try:
                    self.unhook_method(ref)
                except Exception:
                    pass

        for key in list(self._states.keys()):
            self._cleanup_state(key)
        self._states.clear()


    def _hook_dialogs_create_view(self):
        try:
            if self._hook_create_view_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            context_cls = jclass("android.content.Context")
            try:
                method = cls.getClass().getDeclaredMethod("createView", context_cls.getClass())
            except Exception:
                method = cls.getClass().getDeclaredMethod("createView", context_cls)
            method.setAccessible(True)
            self._hook_create_view_ref = self.hook_method(method, _DialogsCreateViewHook(self))
        except Exception:
            self._hook_create_view_ref = None

    def _hook_dialogs_show_search(self):
        try:
            if self._hook_show_search_ref is not None or self._hook_show_search_short_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            bool_type = jclass("java.lang.Boolean").TYPE
            try:
                method = cls.getClass().getDeclaredMethod("showSearch", bool_type, bool_type, bool_type, bool_type)
                method.setAccessible(True)
                self._hook_show_search_ref = self.hook_method(method, _DialogsShowSearchHook(self))
            except Exception:
                method = cls.getClass().getDeclaredMethod("showSearch", bool_type, bool_type, bool_type)
                method.setAccessible(True)
                self._hook_show_search_short_ref = self.hook_method(method, _DialogsShowSearchHook(self))
        except Exception:
            self._hook_show_search_ref = None
            self._hook_show_search_short_ref = None

    def _hook_dialogs_destroy(self):
        try:
            if self._hook_destroy_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            method = cls.getClass().getDeclaredMethod("onFragmentDestroy")
            method.setAccessible(True)
            self._hook_destroy_ref = self.hook_method(method, _DialogsDestroyHook(self))
        except Exception:
            self._hook_destroy_ref = None

    def _hook_actionbar_toggle_search(self):
        try:
            if self._hook_toggle_search_ref is not None:
                return
            cls = find_class("org.telegram.ui.ActionBar.ActionBarMenuItem")
            if cls is None:
                return
            bool_type = jclass("java.lang.Boolean").TYPE
            method = cls.getClass().getDeclaredMethod("toggleSearch", bool_type)
            method.setAccessible(True)
            self._hook_toggle_search_ref = self.hook_method(method, _ToggleSearchHook(self))
        except Exception:
            self._hook_toggle_search_ref = None

    def _hook_dialogs_resume(self):
        try:
            if self._hook_resume_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            method = cls.getClass().getDeclaredMethod("onResume")
            method.setAccessible(True)
            self._hook_resume_ref = self.hook_method(method, _DialogsResumeHook(self))
        except Exception:
            self._hook_resume_ref = None


    def _identity_hash(self, obj: Any) -> int:
        try:
            return int(jclass("java.lang.System").identityHashCode(obj))
        except Exception:
            try:
                return int(id(obj))
            except Exception:
                return 0

    def _ensure_state(self, dialogs_activity: Any) -> Dict[str, Any]:
        key = self._identity_hash(dialogs_activity)
        state = self._states.get(key)
        if state is None:
            state = {
                "key": key,
                "activity": dialogs_activity,
                "root_view": None,
                "search_container": None,
                "explore_button": None,
                "floating_button": None,
                "overlay": None,
                "overlay_open": False,
                "search_input": None,
                "results_container": None,
                "tab_buttons": {},
                "verified_chip": None,
                "tab": "all",
                "verified_only": False,
                "query": "",
                "loading": False,
                "error": "",
                "request_token": 0,
                "debounce_token": 0,
                "status_mode": "",
                "status_shell": None,
                "status_title_view": None,
                "status_subtitle_view": None,
                "status_lottie_view": None,
                "all_results": [],
                "contacts_results": [],
                "global_results": [],
                "hashtag_results": [],
                "resolved_results": [],
                "filtered_results": [],
                "pending_sources": 0,
                "source_errors": [],
                "searching_more_sources": False,
                "visibility_update_token": 0,
                "suppress_show_until_ms": 0,
                "watcher": None,
            }
            self._states[key] = state
        else:
            state["activity"] = dialogs_activity
        return state

    def _cleanup_state(self, key: int):
        state = self._states.get(key)
        if state is None:
            return

        button = state.get("explore_button")
        if button is not None:
            try:
                parent = button.getParent()
                if parent is not None:
                    parent.removeView(button)
            except Exception:
                pass

        floating_button = state.get("floating_button")
        if floating_button is not None:
            try:
                parent = floating_button.getParent()
                if parent is not None:
                    parent.removeView(floating_button)
            except Exception:
                pass

        overlay = state.get("overlay")
        if overlay is not None:
            try:
                parent = overlay.getParent()
                if parent is not None:
                    parent.removeView(overlay)
            except Exception:
                pass

        self._states.pop(key, None)


    def _next_visibility_update_token(self, dialogs_activity: Any) -> int:
        state = self._ensure_state(dialogs_activity)
        token = int(state.get("visibility_update_token", 0)) + 1
        state["visibility_update_token"] = token
        return token

    def _now_ms(self) -> int:
        try:
            return int(jclass("java.lang.System").currentTimeMillis())
        except Exception:
            return 0

    def _schedule_visibility_update(
        self,
        dialogs_activity: Any,
        token: int,
        delay: int = 0,
        force_visible: Optional[bool] = None,
    ):
        run_on_ui_thread(
            lambda act=dialogs_activity, t=token, fv=force_visible: self._apply_visibility_update(act, t, fv),
            delay=delay,
        )

    def _apply_visibility_update(self, dialogs_activity: Any, token: int, force_visible: Optional[bool] = None):
        state = self._states.get(self._identity_hash(dialogs_activity))
        if state is None:
            return
        if int(state.get("visibility_update_token", 0)) != int(token):
            return

        visible = bool(force_visible) if force_visible is not None else bool(self._is_search_visible(dialogs_activity))
        self._ensure_explore_button(dialogs_activity, visible)

    def _on_create_view(self, dialogs_activity: Any, root_view: Any):
        state = self._ensure_state(dialogs_activity)
        state["root_view"] = root_view
        token = self._next_visibility_update_token(dialogs_activity)
        self._schedule_visibility_update(dialogs_activity, token, delay=120)

    def _on_resume(self, dialogs_activity: Any):
        token = self._next_visibility_update_token(dialogs_activity)
        self._schedule_visibility_update(dialogs_activity, token)
        state = self._ensure_state(dialogs_activity)
        if state.get("overlay") is not None:
            self._refresh_chip_styles(state)
            self._render_results(state, animate=False)

    def _on_destroy(self, dialogs_activity: Any):
        self._cleanup_state(self._identity_hash(dialogs_activity))

    def _on_show_search(self, dialogs_activity: Any, show: bool):
        state = self._ensure_state(dialogs_activity)
        if show:
            state["suppress_show_until_ms"] = 0
        else:
            state["suppress_show_until_ms"] = self._now_ms() + 900

        token = self._next_visibility_update_token(dialogs_activity)
        if show:
            self._schedule_visibility_update(dialogs_activity, token, delay=40, force_visible=True)
            self._schedule_visibility_update(dialogs_activity, token, delay=220, force_visible=True)
            self._schedule_visibility_update(dialogs_activity, token, delay=420, force_visible=True)
        else:
            self._schedule_visibility_update(dialogs_activity, token, force_visible=False)
            run_on_ui_thread(lambda act=dialogs_activity: self._close_overlay(act, clear_focus=True))

    def _on_toggle_search(self):
        if self._hook_show_search_ref is not None or self._hook_show_search_short_ref is not None:
            return
        frag = None
        try:
            frag = get_last_fragment()
        except Exception:
            frag = None
        if frag is None:
            return
        try:
            cls_name = str(frag.getClass().getName() or "")
        except Exception:
            cls_name = ""
        if cls_name != "org.telegram.ui.DialogsActivity":
            return

        visible = bool(self._is_search_visible(frag))
        token = self._next_visibility_update_token(frag)
        self._schedule_visibility_update(frag, token, delay=30, force_visible=visible)
        self._schedule_visibility_update(frag, token, delay=180, force_visible=visible)
        self._schedule_visibility_update(frag, token, delay=420, force_visible=visible)


    def _is_search_visible(self, dialogs_activity: Any) -> bool:
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            return bool(search_item is not None and search_item.isSearchFieldVisible())
        except Exception:
            return False

    def _set_explore_visible(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        suppress_until = int(state.get("suppress_show_until_ms", 0) or 0)
        if visible and suppress_until > self._now_ms():
            visible = False
        button = state.get("explore_button")
        if button is None:
            self._ensure_floating_button(dialogs_activity, visible and self._is_search_visible(dialogs_activity))
        else:
            try:
                button.setVisibility(View.VISIBLE if visible else View.GONE)
            except Exception:
                pass
            show_floating = False
            if visible and self._is_search_visible(dialogs_activity):
                show_floating = not self._is_view_visible_on_screen(button)
            self._ensure_floating_button(dialogs_activity, show_floating)

    def _ensure_explore_button(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        suppress_until = int(state.get("suppress_show_until_ms", 0) or 0)
        if visible and suppress_until > self._now_ms():
            visible = False
        if not visible:
            button = state.get("explore_button")
            if button is not None:
                try:
                    button.setVisibility(View.GONE)
                except Exception:
                    pass
            self._ensure_floating_button(dialogs_activity, False)
            return
        self._ensure_root_view(state, dialogs_activity)
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            if search_item is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
            search_container = None
            try:
                if hasattr(search_item, "getSearchContainer"):
                    search_container = search_item.getSearchContainer()
            except Exception:
                search_container = None
            if search_container is None:
                clear_button = search_item.getSearchClearButton()
                if clear_button is not None:
                    search_container = clear_button.getParent()
            if search_container is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
        except Exception:
            self._ensure_floating_button(dialogs_activity, visible)
            return

        state["search_container"] = search_container
        button = state.get("explore_button")
        if button is None:
            button = self._create_explore_button(search_container.getContext(), dialogs_activity)
            if button is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
            state["explore_button"] = button

        attached = False
        try:
            parent = button.getParent()
            if parent is not search_container:
                if parent is not None:
                    parent.removeView(button)
                params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.RIGHT | Gravity.CENTER_VERTICAL
                params.rightMargin = AndroidUtilities.dp(56)
                search_container.addView(button, params)
            attached = True
            try:
                button.bringToFront()
            except Exception:
                pass
        except Exception:
            attached = False

        try:
            button.setVisibility(View.VISIBLE if visible else View.GONE)
        except Exception:
            pass

        if attached:
            show_floating = bool(visible and (not self._is_view_visible_on_screen(button)))
            self._ensure_floating_button(dialogs_activity, show_floating)
        else:
            self._ensure_floating_button(dialogs_activity, visible and self._is_search_visible(dialogs_activity))

    def _is_view_visible_on_screen(self, view: Any) -> bool:
        if view is None:
            return False
        try:
            if int(view.getVisibility()) != int(View.VISIBLE):
                return False
        except Exception:
            pass
        try:
            if int(view.getWidth()) <= 0 or int(view.getHeight()) <= 0:
                return False
        except Exception:
            pass
        try:
            Rect = jclass("android.graphics.Rect")
            rect = Rect()
            ok = bool(view.getGlobalVisibleRect(rect))
            if not ok:
                return False
            return int(rect.width()) > 0 and int(rect.height()) > 0
        except Exception:
            pass
        try:
            return bool(view.isShown())
        except Exception:
            return True

    def _create_explore_button(self, context: Any, dialogs_activity: Any):
        try:
            p = self._palette()
            button = TextView(context)
            button.setText("Explore")
            button.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            button.setTypeface(Typeface.DEFAULT_BOLD)
            button.setPadding(AndroidUtilities.dp(14), AndroidUtilities.dp(6), AndroidUtilities.dp(14), AndroidUtilities.dp(6))
            button.setTextColor(self._color(p["action_title"]))

            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(16))
            bg.setColor(self._color(p["explore_button"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(p["explore_button_stroke"]))
            button.setBackground(bg)

            button.setOnClickListener(OnClickListener(lambda _v=None, act=dialogs_activity: self._open_overlay(act)))
            return button
        except Exception:
            return None

    def _ensure_root_view(self, state: Dict[str, Any], dialogs_activity: Any):
        if state.get("root_view") is not None:
            return
        root = None
        try:
            root = get_private_field(dialogs_activity, "fragmentView")
        except Exception:
            root = None
        if root is None:
            try:
                root = dialogs_activity.getFragmentView()
            except Exception:
                root = None
        if root is None:
            try:
                root = getattr(dialogs_activity, "fragmentView", None)
            except Exception:
                root = None
        state["root_view"] = root

    def _ensure_floating_button(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        self._ensure_root_view(state, dialogs_activity)
        root_view = state.get("root_view")
        if root_view is None or not hasattr(root_view, "addView"):
            if visible:
                self._safe_log("[ExploreSearch] floating fallback skipped: no root_view")
            return

        floating = state.get("floating_button")
        if floating is None and not visible:
            return
        if floating is None:
            context = None
            try:
                context = root_view.getContext()
            except Exception:
                context = None
            if context is None:
                return
            floating = self._create_explore_button(context, dialogs_activity)
            if floating is None:
                return
            state["floating_button"] = floating
            self._safe_log("[ExploreSearch] using floating Explore button fallback")

        try:
            parent = floating.getParent()
            top_margin = self._calc_floating_top_margin(dialogs_activity, root_view)
            if parent is not root_view:
                if parent is not None:
                    parent.removeView(floating)
                params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.TOP | Gravity.RIGHT
                params.topMargin = top_margin
                params.rightMargin = AndroidUtilities.dp(12)
                root_view.addView(floating, params)
            else:
                params = None
                try:
                    params = floating.getLayoutParams()
                except Exception:
                    params = None
                if params is None:
                    params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.TOP | Gravity.RIGHT
                params.topMargin = top_margin
                params.rightMargin = AndroidUtilities.dp(12)
                try:
                    floating.setLayoutParams(params)
                except Exception:
                    pass
            floating.bringToFront()
            floating.setVisibility(View.VISIBLE if visible else View.GONE)
        except Exception:
            pass

    def _calc_floating_top_margin(self, dialogs_activity: Any, root_view: Any) -> int:
        fallback = AndroidUtilities.dp(8)
        search_item = None
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
        except Exception:
            search_item = None
        if search_item is None:
            return fallback

        anchor = None
        try:
            anchor = search_item.getSearchField()
        except Exception:
            anchor = None
        if anchor is None:
            try:
                anchor = search_item.getSearchContainer()
            except Exception:
                anchor = None
        if anchor is None:
            try:
                clear_button = search_item.getSearchClearButton()
                anchor = clear_button.getParent() if clear_button is not None else None
            except Exception:
                anchor = None
        if anchor is None:
            return fallback

        top = self._view_top_relative_to_root(anchor, root_view)
        if top < 0:
            return fallback

        try:
            anchor_h = int(anchor.getHeight())
        except Exception:
            anchor_h = AndroidUtilities.dp(36)
        if anchor_h <= 0:
            anchor_h = AndroidUtilities.dp(36)

        btn_h = AndroidUtilities.dp(32)
        centered = top + max(0, int((anchor_h - btn_h) / 2))
        return max(AndroidUtilities.dp(2), centered)

    def _view_top_relative_to_root(self, view: Any, root_view: Any) -> int:
        total = 0.0
        current = view
        for _ in range(24):
            if current is None or current == root_view:
                break
            try:
                total += float(current.getY())
            except Exception:
                try:
                    total += float(current.getTop())
                except Exception:
                    pass
            try:
                parent = current.getParent()
            except Exception:
                parent = None
            if parent is None or not hasattr(parent, "getY"):
                break
            current = parent
        if total < 0:
            return -1
        return int(total)


    def _open_overlay(self, dialogs_activity: Any):
        state = self._ensure_state(dialogs_activity)
        overlay = self._ensure_overlay(dialogs_activity)
        if overlay is None:
            return

        state["overlay_open"] = True
        self._hide_explore_views(state)
        self._set_explore_visible(dialogs_activity, False)

        state["tab"] = "all"
        state["verified_only"] = False
        self._refresh_chip_styles(state)

        try:
            overlay.setVisibility(View.VISIBLE)
            overlay.setAlpha(0.0)
            overlay.animate().alpha(1.0).setDuration(180).start()
        except Exception:
            try:
                overlay.setVisibility(View.VISIBLE)
            except Exception:
                pass

        query = self._extract_current_query(dialogs_activity)
        search_input = state.get("search_input")
        if search_input is not None:
            try:
                old_query = str(search_input.getText().toString())
            except Exception:
                old_query = ""
            if old_query != query:
                try:
                    search_input.setText(query)
                    search_input.setSelection(search_input.length())
                except Exception:
                    pass
        state["query"] = query
        self._on_query_changed(state["key"], query)

        def _focus():
            field = state.get("search_input")
            if field is None:
                return
            try:
                field.requestFocus()
                AndroidUtilities.showKeyboard(field)
            except Exception:
                pass

        run_on_ui_thread(_focus, delay=90)

    def _close_overlay(self, dialogs_activity: Any, clear_focus: bool = False):
        state = self._ensure_state(dialogs_activity)
        overlay = state.get("overlay")
        if overlay is not None:
            try:
                overlay.animate().alpha(0.0).setDuration(150).start()
                run_on_ui_thread(lambda ov=overlay: ov.setVisibility(View.GONE), delay=160)
            except Exception:
                try:
                    overlay.setVisibility(View.GONE)
                except Exception:
                    pass

        def _restore():
            st = self._ensure_state(dialogs_activity)
            st["overlay_open"] = False
            self._set_explore_visible(dialogs_activity, self._is_search_visible(dialogs_activity))

        run_on_ui_thread(_restore, delay=170)

        if clear_focus:
            field = state.get("search_input")
            if field is not None:
                try:
                    AndroidUtilities.hideKeyboard(field)
                except Exception:
                    pass
                try:
                    field.clearFocus()
                except Exception:
                    pass

    def _hide_explore_views(self, state: Dict[str, Any]):
        for key in ("explore_button", "floating_button"):
            view = state.get(key)
            if view is None:
                continue
            try:
                view.setVisibility(View.GONE)
            except Exception:
                pass

    def _get_overlay_top_padding(self, context: Any) -> int:
        base = AndroidUtilities.dp(12)
        try:
            status = int(AndroidUtilities.getStatusBarHeight(context))
            if status > 0:
                return base + status
        except Exception:
            pass
        try:
            status = int(getattr(AndroidUtilities, "statusBarHeight", 0) or 0)
            if status > 0:
                return base + status
        except Exception:
            pass
        return AndroidUtilities.dp(30)

    def _ensure_overlay(self, dialogs_activity: Any):
        state = self._ensure_state(dialogs_activity)
        overlay = state.get("overlay")
        if overlay is not None:
            try:
                if overlay.getParent() is not None:
                    return overlay
            except Exception:
                pass

        root_view = state.get("root_view")
        if root_view is None:
            try:
                root_view = get_private_field(dialogs_activity, "fragmentView")
            except Exception:
                root_view = None
            state["root_view"] = root_view
        if root_view is None or not hasattr(root_view, "addView"):
            return None

        context = None
        try:
            context = root_view.getContext()
        except Exception:
            pass
        if context is None:
            return None

        p = self._palette()

        overlay = FrameLayout(context)
        overlay.setVisibility(View.GONE)
        overlay.setAlpha(0.0)
        overlay.setClickable(True)
        bg = GradientDrawable()
        bg.setColor(self._color(p["bg"]))
        overlay.setBackground(bg)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setPadding(AndroidUtilities.dp(16), self._get_overlay_top_padding(context), AndroidUtilities.dp(16), AndroidUtilities.dp(14))
        overlay.addView(content, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))

        top_row = LinearLayout(context)
        top_row.setOrientation(LinearLayout.HORIZONTAL)
        top_row.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top_row, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        back = ImageView(context)
        back.setImageResource(R.drawable.ic_ab_back)
        back.setColorFilter(self._color(p["action_icon"]))
        back.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        back.setOnClickListener(OnClickListener(lambda _v=None, act=dialogs_activity: self._close_overlay(act, clear_focus=True)))
        top_row.addView(back, LinearLayout.LayoutParams(AndroidUtilities.dp(40), AndroidUtilities.dp(40)))

        title = TextView(context)
        title.setText("Content search")
        title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 21)
        title.setTypeface(Typeface.DEFAULT_BOLD)
        title.setTextColor(self._color(p["action_title"]))
        title_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        title_lp.leftMargin = AndroidUtilities.dp(8)
        top_row.addView(title, title_lp)

        search_wrap = LinearLayout(context)
        search_wrap.setOrientation(LinearLayout.HORIZONTAL)
        search_wrap.setGravity(Gravity.CENTER_VERTICAL)
        search_wrap.setPadding(AndroidUtilities.dp(14), AndroidUtilities.dp(2), AndroidUtilities.dp(12), AndroidUtilities.dp(2))
        search_bg = GradientDrawable()
        search_bg.setCornerRadius(AndroidUtilities.dp(16))
        search_bg.setColor(self._color(p["input_bg"]))
        search_bg.setStroke(AndroidUtilities.dp(1), self._color(p["input_stroke"]))
        search_wrap.setBackground(search_bg)
        search_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(54))
        search_lp.topMargin = AndroidUtilities.dp(16)
        content.addView(search_wrap, search_lp)

        icon = ImageView(context)
        icon.setImageResource(R.drawable.msg_search)
        icon.setColorFilter(self._color(p["text_muted"]))
        search_wrap.addView(icon, LinearLayout.LayoutParams(AndroidUtilities.dp(24), AndroidUtilities.dp(24)))

        search_input = EditText(context)
        search_input.setBackgroundColor(self._color(0x00000000))
        search_input.setHint("Search groups, channels, bots or #hashtags")
        search_input.setHintTextColor(self._color(p["text_muted"]))
        search_input.setTextColor(self._color(p["text"]))
        search_input.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        search_input.setInputType(InputType.TYPE_CLASS_TEXT)
        search_input.setSingleLine(True)
        input_lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        input_lp.leftMargin = AndroidUtilities.dp(10)
        search_wrap.addView(search_input, input_lp)

        tabs_scroll = HorizontalScrollView(context)
        tabs_scroll.setHorizontalScrollBarEnabled(False)
        tabs_row = LinearLayout(context)
        tabs_row.setOrientation(LinearLayout.HORIZONTAL)
        tabs_scroll.addView(tabs_row, FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        tabs_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        tabs_lp.topMargin = AndroidUtilities.dp(12)
        content.addView(tabs_scroll, tabs_lp)

        self._add_tab_chip(state, tabs_row, "all", "All")
        self._add_tab_chip(state, tabs_row, "channels", "Channels")
        self._add_tab_chip(state, tabs_row, "groups", "Groups")
        self._add_tab_chip(state, tabs_row, "bots", "Bots")

        verified_row = LinearLayout(context)
        verified_row.setOrientation(LinearLayout.HORIZONTAL)
        verified_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        verified_lp.topMargin = AndroidUtilities.dp(8)
        content.addView(verified_row, verified_lp)

        verified_chip = self._create_chip(context, "Verified only")
        verified_chip.setOnClickListener(
            OnClickListener(lambda _v=None, key=state["key"], chip=verified_chip: self._on_verified_chip_click(key, chip))
        )
        verified_row.addView(verified_chip, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        scroll = ScrollView(context)
        scroll.setFillViewport(True)
        scroll.setVerticalScrollBarEnabled(False)
        results_container = LinearLayout(context)
        results_container.setOrientation(LinearLayout.VERTICAL)
        results_container.setPadding(0, AndroidUtilities.dp(10), 0, AndroidUtilities.dp(10))
        scroll.addView(results_container, ScrollView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        content.addView(scroll, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))

        watcher_cls = find_class("android.text.TextWatcher")
        if watcher_cls is not None:
            plugin_self = self
            state_key = state["key"]

            class _Watcher(dynamic_proxy(watcher_cls)):
                def beforeTextChanged(self, _s, _start, _count, _after):
                    pass

                def onTextChanged(self, _s, _start, _before, _count):
                    pass

                def afterTextChanged(self, editable):
                    text = ""
                    try:
                        text = str(editable.toString())
                    except Exception:
                        try:
                            text = str(editable)
                        except Exception:
                            text = ""
                    plugin_self._on_query_changed(state_key, text)

            watcher = _Watcher()
            try:
                search_input.addTextChangedListener(watcher)
                state["watcher"] = watcher
            except Exception:
                pass

        try:
            root_view.addView(overlay, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        except Exception:
            return None

        state["overlay"] = overlay
        state["search_input"] = search_input
        state["results_container"] = results_container
        state["verified_chip"] = verified_chip

        self._refresh_chip_styles(state)
        self._render_results(state, animate=False)
        return overlay


    def _create_chip(self, context: Any, text: str):
        chip = TextView(context)
        chip.setText(text)
        chip.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        chip.setTypeface(Typeface.DEFAULT_BOLD)
        chip.setPadding(AndroidUtilities.dp(14), AndroidUtilities.dp(8), AndroidUtilities.dp(14), AndroidUtilities.dp(8))
        return chip

    def _add_tab_chip(self, state: Dict[str, Any], parent: Any, tab_id: str, text: str):
        chip = self._create_chip(parent.getContext(), text)
        chip.setOnClickListener(
            OnClickListener(lambda _v=None, key=state["key"], tab=tab_id, target=chip: self._on_tab_chip_click(key, tab, target))
        )
        lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp.rightMargin = AndroidUtilities.dp(8)
        parent.addView(chip, lp)
        state["tab_buttons"][tab_id] = chip

    def _on_tab_chip_click(self, state_key: int, tab_id: str, chip: Any):
        self._animate_chip_tap(chip)
        self._select_tab(state_key, tab_id)

    def _on_verified_chip_click(self, state_key: int, chip: Any):
        self._animate_chip_tap(chip)
        self._toggle_verified(state_key)

    def _animate_chip_tap(self, chip: Any):
        if chip is None:
            return
        try:
            chip.animate().cancel()
        except Exception:
            pass
        try:
            chip.animate().scaleX(0.96).scaleY(0.96).setDuration(115).start()
            run_on_ui_thread(lambda target=chip: self._restore_chip_scale(target), delay=120)
        except Exception:
            try:
                chip.setScaleX(0.96)
                chip.setScaleY(0.96)
            except Exception:
                pass
            run_on_ui_thread(lambda target=chip: self._restore_chip_scale(target), delay=120)

    def _restore_chip_scale(self, chip: Any):
        if chip is None:
            return
        try:
            chip.animate().cancel()
        except Exception:
            pass
        try:
            chip.animate().scaleX(1.0).scaleY(1.0).setDuration(210).start()
        except Exception:
            try:
                chip.setScaleX(1.0)
                chip.setScaleY(1.0)
            except Exception:
                pass

    def _style_chip(self, chip: Any, selected: bool, accent: bool = False):
        if chip is None:
            return
        p = self._palette()
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(16))
        if selected:
            bg.setColor(self._color(p["chip_active_accent"] if accent else p["chip_active"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(p["chip_active_stroke"]))
            chip.setTextColor(self._color(p["text"]))
        else:
            bg.setColor(self._color(p["chip"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(p["chip_stroke"]))
            chip.setTextColor(self._color(p["text_soft"]))
        chip.setBackground(bg)

    def _refresh_chip_styles(self, state: Dict[str, Any]):
        selected_tab = state.get("tab", "all")
        for tab_id, chip in state.get("tab_buttons", {}).items():
            self._style_chip(chip, tab_id == selected_tab, accent=False)
        self._style_chip(state.get("verified_chip"), bool(state.get("verified_only", False)), accent=True)

    def _select_tab(self, state_key: int, tab_id: str):
        state = self._states.get(state_key)
        if state is None:
            return
        state["tab"] = tab_id
        self._refresh_chip_styles(state)
        self._render_results(state, animate=True)

    def _toggle_verified(self, state_key: int):
        state = self._states.get(state_key)
        if state is None:
            return
        state["verified_only"] = not bool(state.get("verified_only", False))
        self._refresh_chip_styles(state)
        self._render_results(state, animate=True)


    def _extract_current_query(self, dialogs_activity: Any) -> str:
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            if search_item is None:
                return ""
            field = search_item.getSearchField()
            if field is None:
                return ""
            return str(field.getText().toString() or "")
        except Exception:
            return ""

    def _on_query_changed(self, state_key: int, text: str):
        state = self._states.get(state_key)
        if state is None:
            return

        query = str(text or "")
        state["query"] = query
        state["error"] = ""
        state["debounce_token"] = int(state.get("debounce_token", 0)) + 1
        debounce_token = state["debounce_token"]

        if not query.strip():
            state["loading"] = False
            state["request_token"] = int(state.get("request_token", 0)) + 1
            state["all_results"] = []
            state["contacts_results"] = []
            state["global_results"] = []
            state["hashtag_results"] = []
            state["resolved_results"] = []
            state["pending_sources"] = 0
            state["source_errors"] = []
            state["searching_more_sources"] = False
            state["error"] = ""
            self._render_results(state, animate=False)
            return

        state["loading"] = True
        self._render_results(state, animate=False)

        def _run():
            current_state = self._states.get(state_key)
            if current_state is None:
                return
            if int(current_state.get("debounce_token", 0)) != debounce_token:
                return
            self._perform_search(state_key, query)

        run_on_ui_thread(_run, delay=self._DEBOUNCE_MS)

    def _perform_search(self, state_key: int, query: str):
        state = self._states.get(state_key)
        if state is None:
            return

        query = str(query or "").strip()
        if not query:
            state["loading"] = False
            state["all_results"] = []
            state["contacts_results"] = []
            state["global_results"] = []
            state["hashtag_results"] = []
            state["resolved_results"] = []
            state["pending_sources"] = 0
            state["source_errors"] = []
            state["searching_more_sources"] = False
            self._render_results(state, animate=False)
            return

        state["request_token"] = int(state.get("request_token", 0)) + 1
        request_token = int(state["request_token"])
        state["loading"] = True
        state["error"] = ""
        state["all_results"] = []
        state["contacts_results"] = []
        state["global_results"] = []
        state["hashtag_results"] = []
        state["resolved_results"] = []
        state["source_errors"] = []

        username_query = self._extract_username_query(query)
        hashtag_query = self._extract_hashtag_query(query)
        source_count = 2 + (1 if username_query else 0) + (1 if hashtag_query else 0)
        state["pending_sources"] = source_count
        state["searching_more_sources"] = bool(source_count > 1)
        self._render_results(state, animate=False)

        self._request_contacts_source(state_key, request_token, query)
        self._request_global_source(state_key, request_token, query)
        if hashtag_query:
            self._request_hashtag_source(state_key, request_token, query, hashtag_query)
        if username_query:
            self._request_resolve_source(state_key, request_token, query, username_query)

    def _request_contacts_source(self, state_key: int, request_token: int, query: str):
        req = TLRPC.TL_contacts_search()
        req.q = query
        req.limit = int(self._REQUEST_LIMIT)

        def _on_response(response, error, key=state_key, token=request_token, q=query):
            run_on_ui_thread(lambda: self._apply_contacts_source_response(key, token, q, response, error))

        try:
            send_request(req, RequestCallback(_on_response))
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] contacts request failed: {e}")
                self._finalize_source_response(state, "Contacts search failed")

    def _request_global_source(self, state_key: int, request_token: int, query: str):
        req = TLRPC.TL_messages_searchGlobal()
        req.q = query
        req.limit = int(self._GLOBAL_REQUEST_LIMIT)
        req.filter = TLRPC.TL_inputMessagesFilterEmpty()
        req.min_date = 0
        req.max_date = 0
        req.offset_rate = 0
        req.offset_id = 0
        req.offset_peer = TLRPC.TL_inputPeerEmpty()
        req.broadcasts_only = False
        req.groups_only = False
        req.users_only = False

        def _on_response(response, error, key=state_key, token=request_token, q=query):
            run_on_ui_thread(lambda: self._apply_global_source_response(key, token, q, response, error))

        try:
            send_request(req, RequestCallback(_on_response))
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] global request failed: {e}")
                self._finalize_source_response(state, "Global search failed")

    def _request_hashtag_source(self, state_key: int, request_token: int, query: str, hashtag_query: str):
        req = TLRPC.TL_channels_searchPosts()
        req.flags = int(getattr(req, "flags", 0) or 0) | 1
        req.hashtag = hashtag_query
        req.limit = int(self._GLOBAL_REQUEST_LIMIT)
        req.offset_rate = 0
        req.offset_id = 0
        req.offset_peer = TLRPC.TL_inputPeerEmpty()

        def _on_response(response, error, key=state_key, token=request_token, q=query, tag=hashtag_query):
            run_on_ui_thread(lambda: self._apply_hashtag_source_response(key, token, q, tag, response, error))

        try:
            send_request(req, RequestCallback(_on_response))
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] hashtag request failed: {e}")
                self._finalize_source_response(state, "Hashtag search failed")

    def _request_resolve_source(self, state_key: int, request_token: int, query: str, username_query: str):
        req = TLRPC.TL_contacts_resolveUsername()
        req.flags = 0
        req.username = username_query

        def _on_response(response, error, key=state_key, token=request_token, q=query, uname=username_query):
            run_on_ui_thread(lambda: self._apply_resolve_source_response(key, token, q, uname, response, error))

        try:
            send_request(req, RequestCallback(_on_response))
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] resolve request failed: {e}")
                self._finalize_source_response(state, "Resolve username failed")

    def _apply_contacts_source_response(self, state_key: int, request_token: int, query: str, response: Any, error: Any):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Contacts search failed")
            state["contacts_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["contacts_results"] = self._build_ranked_results(response, query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] contacts parse failed: {e}")
                state["contacts_results"] = []
                source_error = "Contacts parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_global_source_response(self, state_key: int, request_token: int, query: str, response: Any, error: Any):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Global search failed")
            state["global_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["global_results"] = self._build_global_ranked_results(response, query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] global parse failed: {e}")
                state["global_results"] = []
                source_error = "Global parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_hashtag_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        hashtag_query: str,
        response: Any,
        error: Any,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Hashtag search failed")
            state["hashtag_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["hashtag_results"] = self._build_global_ranked_results(response, hashtag_query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] hashtag parse failed: {e}")
                state["hashtag_results"] = []
                source_error = "Hashtag parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_resolve_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        username_query: str,
        response: Any,
        error: Any,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Resolve username failed")
            state["resolved_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["resolved_results"] = self._build_resolve_ranked_results(response, query, username_query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] resolve parse failed: {e}")
                state["resolved_results"] = []
                source_error = "Resolve parse failed"

        self._finalize_source_response(state, source_error)

    def _is_stale_source_response(self, state: Dict[str, Any], request_token: int, query: str) -> bool:
        if int(state.get("request_token", 0)) != int(request_token):
            return True
        current_query = str(state.get("query", "") or "").strip()
        return self._normalize(current_query) != self._normalize(query)

    def _finalize_source_response(self, state: Dict[str, Any], source_error: str):
        if source_error:
            errors = state.get("source_errors")
            if isinstance(errors, list):
                errors.append(source_error)
            else:
                state["source_errors"] = [source_error]

        pending = max(0, int(state.get("pending_sources", 0)) - 1)
        state["pending_sources"] = pending
        state["all_results"] = self._merge_collected_results(state)

        has_items = bool(state.get("all_results"))
        state["loading"] = bool(pending > 0 and not has_items)
        state["searching_more_sources"] = bool(pending > 0)

        if pending == 0:
            if has_items:
                state["error"] = ""
            else:
                errors = state.get("source_errors", [])
                state["error"] = str(errors[0]) if errors else "Search failed"

        self._render_results(state, animate=True)

    def _merge_collected_results(self, state: Dict[str, Any]) -> List[Dict[str, Any]]:
        merged: Dict[int, Dict[str, Any]] = {}
        source_specs = (
            ("resolved_results", 22),
            ("hashtag_results", 13),
            ("contacts_results", 9),
            ("global_results", 6),
        )

        for source_name, source_boost in source_specs:
            for item in self._java_list(state.get(source_name, [])):
                did = int(item.get("did", 0) or 0)
                if did == 0:
                    continue

                candidate = dict(item)
                candidate["score"] = int(candidate.get("score", 0)) + int(source_boost)
                existing = merged.get(did)
                if existing is None:
                    candidate["_sources"] = 1
                    merged[did] = candidate
                    continue

                existing["score"] = max(int(existing.get("score", 0)), int(candidate.get("score", 0))) + 6
                existing["_sources"] = int(existing.get("_sources", 1)) + 1
                existing["verified"] = bool(existing.get("verified", False) or candidate.get("verified", False))
                existing["members"] = max(int(existing.get("members", 0) or 0), int(candidate.get("members", 0) or 0))
                if not str(existing.get("description", "") or "").strip() and str(candidate.get("description", "") or "").strip():
                    existing["description"] = candidate.get("description", "")
                if not str(existing.get("username", "") or "").strip() and str(candidate.get("username", "") or "").strip():
                    existing["username"] = candidate.get("username", "")
                if str(existing.get("kind", "")) == "user" and str(candidate.get("kind", "")) != "user":
                    existing["kind"] = candidate.get("kind", "")
                    existing["obj"] = candidate.get("obj")

        out = list(merged.values())
        for item in out:
            sources = max(1, int(item.pop("_sources", 1)))
            if sources > 1:
                item["score"] = int(item.get("score", 0)) + (sources - 1) * 7

        out.sort(key=lambda it: (-int(it.get("score", 0)), -int(it.get("members", 0)), self._normalize(it.get("title", ""))))
        return out

    def _extract_username_query(self, query: str) -> str:
        text = str(query or "").strip()
        if not text:
            return ""

        lower = text.lower()
        candidate = ""
        if text.startswith("@"):
            candidate = text[1:]
        elif "t.me/" in lower:
            idx = lower.find("t.me/")
            candidate = text[idx + 5 :]
        elif "telegram.me/" in lower:
            idx = lower.find("telegram.me/")
            candidate = text[idx + 11 :]
        else:
            return ""

        candidate = candidate.strip().lstrip("@")
        for sep in ("/", "?", "#", " "):
            if sep in candidate:
                candidate = candidate.split(sep, 1)[0]

        clean_chars = []
        for ch in candidate:
            if ch.isalnum() or ch == "_":
                clean_chars.append(ch)
            else:
                break
        username = "".join(clean_chars)
        if len(username) < 3:
            return ""
        return username

    def _extract_hashtag_query(self, query: str) -> str:
        text = str(query or "").strip()
        if len(text) < 2:
            return ""

        token = text.split(" ", 1)[0].strip()
        if len(token) < 2 or token[0] not in ("#", "$"):
            return ""

        prefix = token[0]
        body = token[1:]
        if not body:
            return ""

        username = ""
        if "@" in body:
            body, raw_username = body.split("@", 1)
            clean_username = []
            for ch in raw_username:
                if ch.isalnum() or ch == "_":
                    clean_username.append(ch)
                else:
                    break
            username = "".join(clean_username)
            if len(username) < 3:
                return ""

        clean_tag = []
        for ch in body:
            if ch.isalnum() or ch == "_":
                clean_tag.append(ch)
            else:
                break

        tag = "".join(clean_tag)
        if len(tag) < 2:
            return ""

        if username:
            return f"{prefix}{tag}@{username}"
        return f"{prefix}{tag}"

    def _build_ranked_results(self, response: Any, query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        out: List[Dict[str, Any]] = []
        seen = set()

        for source, boost in (("my_results", 8), ("results", 0)):
            for peer in self._java_list(getattr(response, source, None)):
                item = self._peer_to_item(peer, users_map, chats_map)
                if item is None:
                    continue
                did = int(item.get("did", 0))
                if did == 0 or did in seen:
                    continue
                seen.add(did)
                item["score"] = int(item.get("score", 0)) + int(boost)
                out.append(item)

        q = self._normalize(query)
        q_t = self._translit(q)
        for item in out:
            item["score"] = int(item.get("score", 0)) + self._rank_item(item, q, q_t)

        out.sort(key=lambda it: (-int(it.get("score", 0)), -int(it.get("members", 0)), self._normalize(it.get("title", ""))))
        return out

    def _build_global_ranked_results(self, response: Any, query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        messages = self._java_list(getattr(response, "messages", None))
        grouped: Dict[int, Dict[str, Any]] = {}
        for idx, msg in enumerate(messages):
            try:
                peer = getattr(msg, "peer_id", None)
            except Exception:
                peer = None
            item = self._peer_to_item(peer, users_map, chats_map)
            if item is None:
                continue

            did = int(item.get("did", 0) or 0)
            if did == 0:
                continue

            snippet = self._extract_message_snippet(msg)
            entry = grouped.get(did)
            if entry is None:
                grouped[did] = {
                    "item": item,
                    "hits": 1,
                    "best_idx": idx,
                    "snippet": snippet,
                }
            else:
                entry["hits"] = int(entry.get("hits", 0)) + 1
                if idx < int(entry.get("best_idx", idx)):
                    entry["best_idx"] = idx
                if not str(entry.get("snippet", "") or "") and snippet:
                    entry["snippet"] = snippet

        out: List[Dict[str, Any]] = []
        q = self._normalize(query)
        q_t = self._translit(q)
        for entry in grouped.values():
            item = dict(entry.get("item", {}))
            snippet = str(entry.get("snippet", "") or "")
            if snippet:
                description = str(item.get("description", "") or "")
                if not description or description.startswith("@"):
                    item["description"] = snippet

            hits = int(entry.get("hits", 0) or 0)
            best_idx = int(entry.get("best_idx", 0) or 0)
            score = self._rank_item(item, q, q_t)
            score += 12 + min(34, hits * 6)
            score += max(0, 14 - min(14, best_idx))
            item["score"] = int(item.get("score", 0)) + score
            out.append(item)

        out.sort(key=lambda it: (-int(it.get("score", 0)), -int(it.get("members", 0)), self._normalize(it.get("title", ""))))
        return out

    def _build_resolve_ranked_results(self, response: Any, query: str, username_query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        peer = getattr(response, "peer", None)
        item = self._peer_to_item(peer, users_map, chats_map)
        if item is None:
            return []

        q = self._normalize(query)
        q_t = self._translit(q)
        score = self._rank_item(item, q, q_t) + 110

        uname = self._normalize(item.get("username", ""))
        wanted = self._normalize(username_query)
        if uname and wanted and uname == wanted:
            score += 55

        item["score"] = int(item.get("score", 0)) + score
        return [item]

    def _extract_message_snippet(self, message: Any) -> str:
        text = ""
        try:
            text = str(getattr(message, "message", "") or "")
        except Exception:
            text = ""
        text = " ".join(text.replace("\n", " ").replace("\r", " ").split())
        if not text:
            return ""
        if len(text) > 120:
            return text[:117] + "..."
        return text

    def _error_text(self, error: Any, fallback: str) -> str:
        if error is None:
            return fallback
        try:
            text = str(error.text or "")
        except Exception:
            text = ""
        if not text:
            try:
                text = str(error)
            except Exception:
                text = ""
        text = text.strip()
        return text or fallback

    def _cache_response_entities(self, response: Any):
        if response is None:
            return
        mc = get_messages_controller()
        if mc is None:
            return

        try:
            users = getattr(response, "users", None)
            if users is not None and hasattr(mc, "putUsers"):
                mc.putUsers(users, False)
        except Exception:
            pass

        try:
            chats = getattr(response, "chats", None)
            if chats is not None and hasattr(mc, "putChats"):
                mc.putChats(chats, False)
        except Exception:
            pass

    def _peer_to_item(self, peer: Any, users_map: Dict[int, Any], chats_map: Dict[int, Any]) -> Optional[Dict[str, Any]]:
        if peer is None:
            return None

        try:
            user_id = int(getattr(peer, "user_id", 0) or 0)
        except Exception:
            user_id = 0

        if user_id != 0:
            user = users_map.get(user_id)
            if user is None:
                return None

            try:
                title = str(UserObject.getUserName(user) or "")
            except Exception:
                first = str(getattr(user, "first_name", "") or "")
                last = str(getattr(user, "last_name", "") or "")
                title = (first + " " + last).strip()

            username = str(getattr(user, "username", "") or "")
            return {
                "did": int(user_id),
                "kind": "bot" if bool(getattr(user, "bot", False)) else "user",
                "title": title,
                "username": username,
                "verified": bool(getattr(user, "verified", False)),
                "members": 0,
                "description": "",
                "obj": user,
                "score": 0,
            }

        chat_id = 0
        try:
            chat_id = int(getattr(peer, "channel_id", 0) or 0)
        except Exception:
            chat_id = 0
        if chat_id == 0:
            try:
                chat_id = int(getattr(peer, "chat_id", 0) or 0)
            except Exception:
                chat_id = 0
        if chat_id == 0:
            return None

        chat = chats_map.get(chat_id)
        if chat is None:
            return None

        try:
            is_channel = bool(ChatObject.isChannelAndNotMegaGroup(chat))
        except Exception:
            is_channel = bool(getattr(chat, "broadcast", False))

        username = str(getattr(chat, "username", "") or "")
        description = ""
        try:
            description = str(getattr(chat, "about", "") or "")
        except Exception:
            description = ""
        if not description and username:
            description = "@" + username

        return {
            "did": -int(chat_id),
            "kind": "channel" if is_channel else "group",
            "title": str(getattr(chat, "title", "") or ""),
            "username": username,
            "verified": bool(getattr(chat, "verified", False)),
            "members": int(getattr(chat, "participants_count", 0) or 0),
            "description": description,
            "obj": chat,
            "score": 0,
        }

    def _rank_item(self, item: Dict[str, Any], query: str, query_t: str) -> int:
        score = 0
        title = self._normalize(item.get("title", ""))
        username = self._normalize(item.get("username", ""))
        description = self._normalize(item.get("description", ""))

        score += self._match_score(title, query, 95, 62, 42)
        score += self._match_score(username, query, 74, 52, 34)
        score += self._match_score(description, query, 22, 12, 8)

        if query_t and query_t != query:
            score += self._match_score(self._translit(title), query_t, 40, 24, 14)
            score += self._match_score(self._translit(username), query_t, 26, 15, 10)

        tokens = self._query_tokens(query)
        if len(tokens) > 1:
            covered = 0
            for token in tokens[:5]:
                token_score = 0
                token_score += self._match_score(title, token, 30, 20, 12)
                token_score += self._match_score(username, token, 20, 14, 9)
                token_score += self._match_score(description, token, 12, 8, 5)
                if token_score > 0:
                    covered += 1
                score += min(20, int(token_score / 4))
            if covered >= min(len(tokens), 5):
                score += 16

        if bool(item.get("verified", False)):
            score += 7

        members = int(item.get("members", 0) or 0)
        if members > 0:
            score += min(26, int(math.log10(members + 10) * 10))

        kind = str(item.get("kind", ""))
        if kind == "channel":
            score += 6
        elif kind == "group":
            score += 5
        elif kind == "bot":
            score += 4

        return score

    def _match_score(self, text: str, query: str, exact_prefix: int, mid_word: int, anywhere: int) -> int:
        if not text or not query:
            return 0
        if text == query:
            return exact_prefix + 18
        if text.startswith(query):
            return exact_prefix
        idx = text.find(query)
        if idx < 0:
            return 0
        if idx > 0 and text[idx - 1] in (" ", "_", "-", "."):
            return mid_word
        return anywhere

    def _query_tokens(self, query: str) -> List[str]:
        tokens = []
        seen = set()
        for token in self._normalize(query).split(" "):
            if len(token) < 2:
                continue
            if token in seen:
                continue
            seen.add(token)
            tokens.append(token)
        return tokens


    def _apply_filters(self, state: Dict[str, Any]) -> List[Dict[str, Any]]:
        tab = str(state.get("tab", "all"))
        verified_only = bool(state.get("verified_only", False))
        items = list(state.get("all_results", []))

        out = []
        for item in items:
            kind = str(item.get("kind", ""))
            if tab == "channels" and kind != "channel":
                continue
            if tab == "groups" and kind != "group":
                continue
            if tab == "bots" and kind != "bot":
                continue
            if verified_only and not bool(item.get("verified", False)):
                continue
            out.append(item)
        return out

    def _reset_status_state(self, state: Dict[str, Any]):
        state["status_mode"] = ""
        state["status_shell"] = None
        state["status_title_view"] = None
        state["status_subtitle_view"] = None
        state["status_lottie_view"] = None

    def _clear_results_container(self, state: Dict[str, Any], container: Any) -> bool:
        try:
            container.removeAllViews()
        except Exception:
            return False
        self._reset_status_state(state)
        return True

    def _try_reuse_status(self, state: Dict[str, Any], container: Any, mode: str, title: str, subtitle: str) -> bool:
        shell = state.get("status_shell")
        if shell is None:
            return False
        if str(state.get("status_mode", "")) != str(mode):
            return False
        try:
            if shell.getParent() is not container:
                return False
        except Exception:
            return False

        title_view = state.get("status_title_view")
        subtitle_view = state.get("status_subtitle_view")
        if title_view is not None:
            try:
                title_view.setText(title)
            except Exception:
                pass
        if subtitle_view is not None:
            try:
                subtitle_view.setText(subtitle)
            except Exception:
                pass

        if str(mode) == "loading":
            lottie_view = state.get("status_lottie_view")
            if lottie_view is not None and hasattr(lottie_view, "playAnimation"):
                try:
                    lottie_view.playAnimation()
                except Exception:
                    pass
        return True

    def _render_results(self, state: Dict[str, Any], animate: bool):
        container = state.get("results_container")
        if container is None:
            return

        query = str(state.get("query", "") or "").strip()
        error = str(state.get("error", "") or "")
        loading = bool(state.get("loading", False))

        if loading:
            title = "Searching"
            subtitle = "Looking for channels, groups, bots and hashtag posts."
            if self._try_reuse_status(state, container, mode="loading", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(
                state,
                container,
                title,
                subtitle,
                mode="loading",
            )
            return
        if error:
            if self._try_reuse_status(state, container, mode="error", title="Search error", subtitle=error):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(state, container, "Search error", error, mode="error")
            return
        if not query:
            title = "Type your query"
            subtitle = "Search groups, channels, bots and hashtag posts."
            if self._try_reuse_status(state, container, mode="idle", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(
                state,
                container,
                title,
                subtitle,
                mode="idle",
            )
            return

        filtered = self._apply_filters(state)
        state["filtered_results"] = filtered
        if not filtered:
            title = "No results"
            subtitle = "Try another query or disable filters."
            if self._try_reuse_status(state, container, mode="empty", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(state, container, "No results", "Try another query or disable filters.", mode="empty")
            return

        if not self._clear_results_container(state, container):
            return
        summary = TextView(container.getContext())
        summary_text = f"Found {len(filtered)} results"
        if bool(state.get("searching_more_sources", False)):
            summary_text += "  searching deeper..."
        summary.setText(summary_text)
        summary.setTextColor(self._color(self._palette()["text_soft"]))
        summary.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        summary_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        summary_lp.bottomMargin = AndroidUtilities.dp(8)
        container.addView(summary, summary_lp)

        max_items = min(len(filtered), 80)
        for i in range(max_items):
            item = filtered[i]
            card = self._create_card(state, item)
            lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp.bottomMargin = AndroidUtilities.dp(10)
            container.addView(card, lp)
            if animate:
                try:
                    card.setAlpha(0.0)
                    card.setTranslationY(AndroidUtilities.dp(10))
                    card.animate().alpha(1.0).translationY(0).setDuration(180).setStartDelay(min(260, i * 16)).start()
                except Exception:
                    pass

    def _add_status(self, state: Dict[str, Any], container: Any, title: str, subtitle: str, mode: str = "info"):
        context = container.getContext()
        p = self._palette()
        loading_mode = mode == "loading"

        shell = LinearLayout(context)
        shell.setOrientation(LinearLayout.VERTICAL)
        shell.setPadding(AndroidUtilities.dp(1), AndroidUtilities.dp(1), AndroidUtilities.dp(1), AndroidUtilities.dp(1))
        shell_bg = GradientDrawable()
        shell_bg.setCornerRadius(AndroidUtilities.dp(20))
        shell_bg.setColor(self._color(p["status_glow"] if loading_mode else p["status_bg_soft"]))
        shell_bg.setStroke(AndroidUtilities.dp(1), self._color(p["status_accent"] if loading_mode else p["status_stroke"]))
        shell.setBackground(shell_bg)

        wrap = LinearLayout(context)
        wrap.setOrientation(LinearLayout.VERTICAL)
        wrap.setGravity(Gravity.CENTER_HORIZONTAL)
        wrap.setPadding(AndroidUtilities.dp(18), AndroidUtilities.dp(22), AndroidUtilities.dp(18), AndroidUtilities.dp(20))
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(19))
        bg.setColor(self._color(p["status_bg"]))
        bg.setStroke(AndroidUtilities.dp(1), self._color(p["status_stroke"]))
        wrap.setBackground(bg)
        shell.addView(
            wrap,
            LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT),
        )

        header = LinearLayout(context)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER)
        wrap.addView(header, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        icon_shell = FrameLayout(context)
        icon_shell.setPadding(AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6))
        icon_bg = GradientDrawable()
        icon_bg.setCornerRadius(AndroidUtilities.dp(14))
        icon_bg.setColor(self._color(p["status_icon_bg"] if loading_mode else p["status_bg_soft"]))
        icon_bg.setStroke(AndroidUtilities.dp(1), self._color(p["status_icon_stroke"] if loading_mode else p["status_stroke"]))
        icon_shell.setBackground(icon_bg)

        icon_view = self._create_loading_lottie_icon(context, p) if loading_mode else None
        if icon_view is None:
            icon_view = ImageView(context)
            icon_view.setImageResource(R.drawable.msg_search)
            icon_view.setColorFilter(self._color(p["status_icon_tint"] if loading_mode else p["text_soft"]))
        icon_shell.addView(icon_view, FrameLayout.LayoutParams(AndroidUtilities.dp(18), AndroidUtilities.dp(18), Gravity.CENTER))
        icon_lp = LinearLayout.LayoutParams(AndroidUtilities.dp(30), AndroidUtilities.dp(30))
        icon_lp.rightMargin = AndroidUtilities.dp(10)
        header.addView(icon_shell, icon_lp)

        t = TextView(context)
        t.setText(title)
        t.setTextColor(self._color(p["text"]))
        t.setTypeface(Typeface.DEFAULT_BOLD)
        t.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22 if loading_mode else 19)
        t.setGravity(Gravity.CENTER_HORIZONTAL)
        header.addView(t, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        s = TextView(context)
        s.setText(subtitle)
        s.setTextColor(self._color(p["text_soft"]))
        s.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        s.setGravity(Gravity.CENTER_HORIZONTAL)
        try:
            s.setMaxWidth(AndroidUtilities.dp(360))
        except Exception:
            pass
        slp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        slp.topMargin = AndroidUtilities.dp(10)
        wrap.addView(s, slp)

        lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        lp.topMargin = AndroidUtilities.dp(16)
        container.addView(shell, lp)

        state["status_mode"] = mode
        state["status_shell"] = shell
        state["status_title_view"] = t
        state["status_subtitle_view"] = s
        state["status_lottie_view"] = icon_view if loading_mode else None

        self._animate_status_entry(shell)

    def _create_loading_lottie_icon(self, context: Any, palette: Dict[str, int]):
        try:
            anim = RLottieImageView(context)
            anim.setAutoRepeat(True)
            try:
                anim.setScaleType(ImageView.ScaleType.CENTER_INSIDE)
            except Exception:
                pass

            anim_res = None
            try:
                anim_res = getattr(R.raw, "options_to_search")
            except Exception:
                try:
                    anim_res = getattr(R.raw, "dots_loading")
                except Exception:
                    anim_res = None
            if anim_res is None:
                return None

            anim.setAnimation(anim_res, 18, 18)
            anim.setColorFilter(self._color(palette["status_icon_tint"]))
            try:
                drawable = anim.getAnimatedDrawable()
                if drawable is not None:
                    drawable.multiplySpeed(1.25)
            except Exception:
                pass
            anim.playAnimation()
            return anim
        except Exception:
            return None

    def _animate_status_entry(self, view: Any):
        if view is None:
            return
        try:
            view.animate().cancel()
        except Exception:
            pass
        try:
            view.setAlpha(0.0)
            view.setTranslationY(AndroidUtilities.dp(12))
            view.setScaleX(0.985)
            view.setScaleY(0.985)
            view.animate().alpha(1.0).translationY(0).scaleX(1.0).scaleY(1.0).setDuration(270).start()
        except Exception:
            pass

    def _create_card(self, state: Dict[str, Any], item: Dict[str, Any]):
        context = state["results_container"].getContext()
        p = self._palette()

        card = LinearLayout(context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(16))
        bg.setColor(self._color(p["card"]))
        bg.setStroke(AndroidUtilities.dp(1), self._color(p["card_stroke"]))
        card.setBackground(bg)

        top = LinearLayout(context)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        card.addView(top, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        avatar = BackupImageView(context)
        avatar.setRoundRadius(AndroidUtilities.dp(22))
        alp = LinearLayout.LayoutParams(AndroidUtilities.dp(44), AndroidUtilities.dp(44))
        alp.rightMargin = AndroidUtilities.dp(10)
        top.addView(avatar, alp)

        obj = item.get("obj")
        if obj is not None:
            try:
                ad = AvatarDrawable()
                ad.setInfo(obj)
                avatar.setForUserOrChat(obj, ad)
            except Exception:
                pass

        col = LinearLayout(context)
        col.setOrientation(LinearLayout.VERTICAL)
        top.addView(col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        title = TextView(context)
        title.setText(str(item.get("title", "") or ""))
        title.setTextColor(self._color(p["text"]))
        title.setTypeface(Typeface.DEFAULT_BOLD)
        title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        title.setMaxLines(1)
        col.addView(title)

        subtitle = TextView(context)
        subtitle.setText(self._subtitle(item))
        subtitle.setTextColor(self._color(p["text_soft"]))
        subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        subtitle.setMaxLines(1)
        slp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        slp.topMargin = AndroidUtilities.dp(2)
        col.addView(subtitle, slp)

        members = int(item.get("members", 0) or 0)
        if members > 0:
            right = TextView(context)
            right.setText(self._format_members(members))
            right.setTextColor(self._color(p["text_soft"]))
            right.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
            right.setTypeface(Typeface.DEFAULT_BOLD)
            top.addView(right, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        description = str(item.get("description", "") or "")
        if not description:
            description = self._kind_label(str(item.get("kind", "")))
        desc = TextView(context)
        desc.setText(description)
        desc.setTextColor(self._color(p["text_muted"]))
        desc.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        desc.setMaxLines(2)
        dlp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        dlp.topMargin = AndroidUtilities.dp(8)
        card.addView(desc, dlp)

        card.setOnClickListener(OnClickListener(lambda _v=None, key=state["key"], result=item: self._open_result(key, result)))
        return card

    def _open_result(self, state_key: int, item: Dict[str, Any]):
        state = self._states.get(state_key)
        if state is None:
            return
        activity = state.get("activity")
        if activity is None:
            return

        username = str(item.get("username", "") or "").strip()
        did = int(item.get("did", 0) or 0)
        if did == 0:
            self._open_by_username(activity, username)
            return

        args = Bundle()
        if did > 0:
            args.putLong("user_id", did)
        else:
            args.putLong("chat_id", -did)

        try:
            mc = get_messages_controller()
            if mc is not None and hasattr(mc, "checkCanOpenChat"):
                if not mc.checkCanOpenChat(args, activity):
                    self._open_by_username(activity, username)
                    return
        except Exception:
            pass

        try:
            activity.presentFragment(ChatActivity(args))
            self._close_overlay(activity, clear_focus=True)
        except Exception as e:
            self._safe_log(f"[ExploreSearch] failed to open chat: {e}")
            self._open_by_username(activity, username)

    def _open_by_username(self, activity: Any, username: str) -> bool:
        name = str(username or "").strip().lstrip("@")
        if not name:
            return False
        try:
            mc = get_messages_controller()
            if mc is None or not hasattr(mc, "openByUserName"):
                return False
            mc.openByUserName(name, activity, 1)
            self._close_overlay(activity, clear_focus=True)
            return True
        except Exception as e:
            self._safe_log(f"[ExploreSearch] openByUserName failed: {e}")
            return False


    def _normalize(self, value: Any) -> str:
        try:
            text = str(value or "").strip().lower()
            text = " ".join(text.split())
            text = text.replace("", "")
            return text
        except Exception:
            return ""

    def _translit(self, value: Any) -> str:
        text = self._normalize(value)
        if not text:
            return ""
        try:
            return self._normalize(AndroidUtilities.translitSafe(text))
        except Exception:
            return text

    def _java_list(self, value: Any) -> List[Any]:
        if value is None:
            return []
        out = []
        try:
            size = int(value.size())
            for i in range(size):
                out.append(value.get(i))
            return out
        except Exception:
            pass
        try:
            return list(value)
        except Exception:
            return []

    def _format_members(self, count: int) -> str:
        if count >= 1000000:
            return f"{count / 1000000.0:.1f}M"
        if count >= 1000:
            return f"{count / 1000.0:.1f}K"
        return str(count)

    def _kind_label(self, kind: str) -> str:
        if kind == "channel":
            return "Channel"
        if kind == "group":
            return "Group"
        if kind == "bot":
            return "Bot"
        return "Chat"

    def _subtitle(self, item: Dict[str, Any]) -> str:
        parts = []
        username = str(item.get("username", "") or "")
        if username:
            parts.append("@" + username)
        parts.append(self._kind_label(str(item.get("kind", ""))))
        if bool(item.get("verified", False)):
            parts.append("Verified")
        return "  ".join(parts)

    def _to_java_color_int(self, value: int) -> int:
        v = int(value) & 0xFFFFFFFF
        if v >= 0x80000000:
            v -= 0x100000000
        return v

    def _theme_color(self, key_name: str, fallback: int) -> int:
        try:
            key = getattr(Theme, key_name)
            return self._to_java_color_int(int(Theme.getColor(key)))
        except Exception:
            return self._to_java_color_int(fallback)

    def _alpha_color(self, color: int, alpha: int) -> int:
        argb = ((int(alpha) & 0xFF) << 24) | (int(color) & 0x00FFFFFF)
        return self._to_java_color_int(argb)

    def _palette(self) -> Dict[str, int]:
        bg = self._theme_color("key_dialogBackground", self._COLOR_BG)
        card = self._theme_color("key_windowBackgroundWhite", self._COLOR_CARD)
        text = self._theme_color("key_windowBackgroundWhiteBlackText", self._COLOR_TEXT)
        text_soft = self._theme_color("key_windowBackgroundWhiteGrayText", self._COLOR_TEXT_SOFT)
        text_muted = self._theme_color("key_windowBackgroundWhiteHintText", self._COLOR_TEXT_MUTED)
        accent = self._theme_color("key_featuredStickers_addButton", self._COLOR_ACCENT)
        divider = self._theme_color("key_divider", self._COLOR_CARD_STROKE)
        input_bg = self._theme_color("key_dialogInputField", self._COLOR_BG_SOFT)
        action_bar_bg = self._theme_color("key_actionBarDefault", self._COLOR_EXPLORE_BUTTON)
        action_bar_title = self._theme_color("key_actionBarDefaultTitle", text)
        action_bar_icon = self._theme_color("key_actionBarDefaultIcon", text)

        chip_active = self._alpha_color(accent, 72)
        chip_active_accent = self._alpha_color(accent, 104)
        chip_active_stroke = self._alpha_color(accent, 218)

        return {
            "bg": bg,
            "card": card,
            "card_stroke": self._alpha_color(divider, 170),
            "text": text,
            "text_soft": text_soft,
            "text_muted": text_muted,
            "accent": accent,
            "chip": input_bg,
            "chip_active": chip_active,
            "chip_active_accent": chip_active_accent,
            "chip_active_stroke": chip_active_stroke,
            "chip_stroke": self._alpha_color(divider, 132),
            "input_bg": input_bg,
            "input_stroke": self._alpha_color(divider, 156),
            "status_bg": self._alpha_color(card, 238),
            "status_bg_soft": self._alpha_color(card, 210),
            "status_stroke": self._alpha_color(divider, 170),
            "status_accent": self._alpha_color(accent, 198),
            "status_glow": self._alpha_color(accent, 40),
            "status_icon_bg": self._alpha_color(accent, 58),
            "status_icon_stroke": self._alpha_color(accent, 132),
            "status_icon_tint": self._alpha_color(text, 252),
            "explore_button": action_bar_bg,
            "explore_button_stroke": self._alpha_color(divider, 162),
            "action_title": action_bar_title,
            "action_icon": action_bar_icon,
        }

    def _color(self, value: int) -> int:
        return self._to_java_color_int(value)

    def _safe_log(self, text: str):
        try:
            log(text)
        except Exception:
            pass


class _DialogsCreateViewHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_create_view(param.thisObject, param.getResult())
        except Exception:
            pass


class _DialogsShowSearchHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            show = bool(param.args[0]) if param.args and len(param.args) > 0 else False
            self.plugin._on_show_search(param.thisObject, show)
        except Exception:
            pass


class _DialogsDestroyHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_destroy(param.thisObject)
        except Exception:
            pass


class _DialogsResumeHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_resume(param.thisObject)
        except Exception:
            pass


class _ToggleSearchHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_toggle_search()
        except Exception:
            pass


plugin = ExploreSearchPlugin()
