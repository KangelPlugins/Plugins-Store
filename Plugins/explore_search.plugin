"""
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⡿⠟⠋⠉⠉⠉⠉⠛⠿⣿⣿⣿⣿⡿⠛⠉⠉⠄⠈⠉⠙⠿⣿⣿⣿⣿
⣿⣿⡿⠋⠄⣠⣶⣿⣿⣿⣷⣦⣄⠈⠛⢟⢁⣠⣤⣴⣶⣤⣄⠄⠄⠄⠈⢿⣿⣿
⣿⡿⠁⢠⣾⣿⣿⣿⣿⣿⣿⣿⡿⣿⣦⣀⠈⠛⠛⠋⣸⣿⣿⣷⡄⠄⠄⠄⢻⣿
⣿⠁⢀⣿⣿⣿⣿⣿⣿⣿⠋⠄⠄⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣧⠄⠄⠄⠄⣿
⣿⠄⢸⣿⣿⣿⣿⣿⠟⠁⠄⠄⠄⠄⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠘⣿⣿⣿⣿⡏⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⠄⣿
⣿⠄⠄⢻⣿⣿⣿⠁⠄⠄⠄⠄⠄⠄⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⠄⠄⠄⢀⣿
⣿⡆⠄⠈⠿⠿⠋⠄⠄⠄⠄⠄⠄⢰⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠄⠄⠄⣸⣿
⣿⣿⡀⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⠄⣰⣿⣿
⣿⣿⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠄⠄⣰⣿⣿⣿
⣿⣿⣿⣿⣄⠄⠄⠄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⣿⠏⠄⢀⣴⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣿⡿⠃⠄⣠⣾⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⢿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣀⠄⠙⢿⣿⠟⠋⣠⣶⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣄⣨⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿
 Кража кода без указания авторства является публичным неуважением к работе автора.
  Уважайте чужой труд: если используете этот код, пожалуйста, указывайте @mihailkotovski и источник (@mishabotov)
   Берёте — но делайте это с уважением :)

Увижу что спизженно, не спросив меня/не указав - публично ОБОССУ
"""

import math
import re
from typing import Any, Dict, List, Optional

from base_plugin import BasePlugin
from client_utils import (
    RequestCallback,
    SEARCH_QUEUE,
    get_connections_manager,
    get_last_fragment,
    get_messages_controller,
    get_messages_storage,
    run_on_queue,
    send_request,
)
from android_utils import OnClickListener, run_on_ui_thread, log
from hook_utils import find_class, get_private_field

from java import dynamic_proxy, jclass

from android.graphics import Typeface
from android.graphics.drawable import GradientDrawable
from android.os import Bundle
from android.text import InputType
from android.util import TypedValue
from android.view import Gravity, View, ViewGroup
from android.widget import FrameLayout, LinearLayout, TextView, EditText, ImageView, ScrollView, HorizontalScrollView

from org.telegram.messenger import AndroidUtilities, ChatObject, DialogObject, UserObject, FileLoader, ImageLocation, WebFile, R
from org.telegram.tgnet import TLRPC
from org.telegram.ui import ChatActivity
from org.telegram.ui.ActionBar import Theme
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, RLottieImageView, CubicBezierInterpolator

try:
    from org.telegram.messenger import DocumentObject
except Exception:
    DocumentObject = None

__id__ = "explore_search"
__name__ = "Explore Search"
__description__ = "Adds an Explore button with a beautiful content search UI and ranked results."
__author__ = "@mishabotov"
__version__ = "3.0 [remake + bug fixes]"
__icon__ = "alegquin33/81"


class ExploreSearchPlugin(BasePlugin):
    _DEBOUNCE_MS = 260
    _REQUEST_LIMIT = 80
    _GLOBAL_REQUEST_LIMIT = 36
    _LOCAL_RESULT_LIMIT = 120
    _GLOBAL_MAX_PAGES = 2
    _CHAT_TAB = "in_chats"
    _CHAT_SEARCH_REQUEST_LIMIT = 12
    _CHAT_SEARCH_MAX_DIALOGS = 180
    _CHAT_SEARCH_CONCURRENCY = 6
    _INLINE_REQUEST_LIMIT = 36
    _INLINE_MAX_PAGES = 2
    _INLINE_BOT_USERNAMES = ("SearcheeBot", "MotherSearchBot")
    _INLINE_TAB_ALL = "inline"
    _INLINE_TAB_SEARCHEE = "inline_searchee"
    _INLINE_TAB_MOTHER = "inline_mother"
    _NO_RESULTS_STICKER_SET = "DMJDuckX2"
    _NO_RESULTS_STICKER_INDEX = 9

    _COLOR_BG = 0xFF111221
    _COLOR_BG_SOFT = 0xFF2A2440
    _COLOR_CARD = 0xFF242039
    _COLOR_CARD_STROKE = 0x807A6AA8
    _COLOR_TEXT = 0xFFF4F2FF
    _COLOR_TEXT_SOFT = 0xFFB8AFCF
    _COLOR_TEXT_MUTED = 0xFF8E87A8
    _COLOR_CHIP = 0xFF231F36
    _COLOR_CHIP_ACTIVE = 0xFF5E4A8E
    _COLOR_CHIP_ACTIVE_STROKE = 0xFF9D85DF
    _COLOR_ACCENT = 0xFFB59BFF
    _COLOR_EXPLORE_BUTTON = 0xFF353049

    def __init__(self):
        super().__init__()
        self._hook_create_view_ref = None
        self._hook_show_search_ref = None
        self._hook_show_search_short_ref = None
        self._hook_toggle_search_ref = None
        self._hook_destroy_ref = None
        self._hook_resume_ref = None
        self._states: Dict[int, Dict[str, Any]] = {}
        self._inline_bot_user_ids: Dict[str, int] = {}
        self._no_results_sticker_doc: Any = None
        self._no_results_sticker_loading = False
        self._no_results_sticker_failed = False
        self._no_results_sticker_retry_after_ms = 0

    def _setting_bool(self, key: str, default: bool = False) -> bool:
        try:
            value = self.get_setting(key, default)
        except Exception:
            return bool(default)
        if isinstance(value, bool):
            return value
        text = str(value or "").strip().lower()
        if text in ("1", "true", "yes", "on"):
            return True
        if text in ("0", "false", "no", "off"):
            return False
        return bool(default)

    def on_plugin_load(self):
        self._safe_log("[ExploreSearch] loading plugin")
        self._hook_dialogs_create_view()
        self._hook_dialogs_show_search()
        self._hook_actionbar_toggle_search()
        self._hook_dialogs_destroy()
        self._hook_dialogs_resume()
        self._safe_log(
            "[ExploreSearch] hooks: createView=%s showSearch4=%s showSearch3=%s toggleSearch=%s onDestroy=%s onResume=%s"
            % (
                "ok" if self._hook_create_view_ref is not None else "no",
                "ok" if self._hook_show_search_ref is not None else "no",
                "ok" if self._hook_show_search_short_ref is not None else "no",
                "ok" if self._hook_toggle_search_ref is not None else "no",
                "ok" if self._hook_destroy_ref is not None else "no",
                "ok" if self._hook_resume_ref is not None else "no",
            )
        )

    def on_plugin_unload(self):
        for ref in (
            self._hook_create_view_ref,
            self._hook_show_search_ref,
            self._hook_show_search_short_ref,
            self._hook_toggle_search_ref,
            self._hook_destroy_ref,
            self._hook_resume_ref,
        ):
            if ref is not None:
                try:
                    self.unhook_method(ref)
                except Exception:
                    pass

        for key in list(self._states.keys()):
            self._cleanup_state(key)
        self._states.clear()
        self._no_results_sticker_doc = None
        self._no_results_sticker_loading = False
        self._no_results_sticker_failed = False
        self._no_results_sticker_retry_after_ms = 0


    def _hook_dialogs_create_view(self):
        try:
            if self._hook_create_view_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            context_cls = jclass("android.content.Context")
            try:
                method = cls.getClass().getDeclaredMethod("createView", context_cls.getClass())
            except Exception:
                method = cls.getClass().getDeclaredMethod("createView", context_cls)
            method.setAccessible(True)
            self._hook_create_view_ref = self.hook_method(method, _DialogsCreateViewHook(self))
        except Exception:
            self._hook_create_view_ref = None

    def _hook_dialogs_show_search(self):
        try:
            if self._hook_show_search_ref is not None or self._hook_show_search_short_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            bool_type = jclass("java.lang.Boolean").TYPE
            try:
                method = cls.getClass().getDeclaredMethod("showSearch", bool_type, bool_type, bool_type, bool_type)
                method.setAccessible(True)
                self._hook_show_search_ref = self.hook_method(method, _DialogsShowSearchHook(self))
            except Exception:
                method = cls.getClass().getDeclaredMethod("showSearch", bool_type, bool_type, bool_type)
                method.setAccessible(True)
                self._hook_show_search_short_ref = self.hook_method(method, _DialogsShowSearchHook(self))
        except Exception:
            self._hook_show_search_ref = None
            self._hook_show_search_short_ref = None

    def _hook_dialogs_destroy(self):
        try:
            if self._hook_destroy_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            method = cls.getClass().getDeclaredMethod("onFragmentDestroy")
            method.setAccessible(True)
            self._hook_destroy_ref = self.hook_method(method, _DialogsDestroyHook(self))
        except Exception:
            self._hook_destroy_ref = None

    def _hook_actionbar_toggle_search(self):
        try:
            if self._hook_toggle_search_ref is not None:
                return
            cls = find_class("org.telegram.ui.ActionBar.ActionBarMenuItem")
            if cls is None:
                return
            bool_type = jclass("java.lang.Boolean").TYPE
            method = cls.getClass().getDeclaredMethod("toggleSearch", bool_type)
            method.setAccessible(True)
            self._hook_toggle_search_ref = self.hook_method(method, _ToggleSearchHook(self))
        except Exception:
            self._hook_toggle_search_ref = None

    def _hook_dialogs_resume(self):
        try:
            if self._hook_resume_ref is not None:
                return
            cls = find_class("org.telegram.ui.DialogsActivity")
            if cls is None:
                return
            method = cls.getClass().getDeclaredMethod("onResume")
            method.setAccessible(True)
            self._hook_resume_ref = self.hook_method(method, _DialogsResumeHook(self))
        except Exception:
            self._hook_resume_ref = None


    def _identity_hash(self, obj: Any) -> int:
        try:
            return int(jclass("java.lang.System").identityHashCode(obj))
        except Exception:
            try:
                return int(id(obj))
            except Exception:
                return 0

    def _ensure_state(self, dialogs_activity: Any) -> Dict[str, Any]:
        key = self._identity_hash(dialogs_activity)
        state = self._states.get(key)
        if state is None:
            state = {
                "key": key,
                "activity": dialogs_activity,
                "root_view": None,
                "search_container": None,
                "explore_button": None,
                "floating_button": None,
                "overlay": None,
                "overlay_open": False,
                "search_input": None,
                "search_clear_button": None,
                "results_container": None,
                "tab_buttons": {},
                "tabs_indicator": None,
                "tabs_scroll": None,
                "filters_row": None,
                "verified_chip": None,
                "verified_chip_text": None,
                "verified_chip_icon": None,
                "inline_default_chip": None,
                "inline_default_chip_text": None,
                "inline_default_chip_icon": None,
                "tab": "all",
                "verified_only": False,
                "inline_default_enabled": self._setting_bool("inline_in_default_search", False),
                "query": "",
                "loading": False,
                "error": "",
                "request_token": 0,
                "debounce_token": 0,
                "status_mode": "",
                "status_shell": None,
                "status_title_view": None,
                "status_subtitle_view": None,
                "status_lottie_view": None,
                "status_sticker_view": None,
                "all_results": [],
                "local_results": [],
                "contacts_results": [],
                "global_results": [],
                "chat_results": [],
                "hashtag_results": [],
                "resolved_results": [],
                "inline_results": [],
                "filtered_results": [],
                "pending_sources": 0,
                "source_errors": [],
                "searching_more_sources": False,
                "active_request_ids": [],
                "visibility_update_token": 0,
                "suppress_show_until_ms": 0,
                "watcher": None,
            }
            self._states[key] = state
        else:
            state["activity"] = dialogs_activity
        return state

    def _cleanup_state(self, key: int):
        state = self._states.get(key)
        if state is None:
            return
        self._cancel_active_requests(state)
        self._detach_search_watcher(state)

        button = state.get("explore_button")
        if button is not None:
            try:
                parent = button.getParent()
                if parent is not None:
                    parent.removeView(button)
            except Exception:
                pass

        floating_button = state.get("floating_button")
        if floating_button is not None:
            try:
                parent = floating_button.getParent()
                if parent is not None:
                    parent.removeView(floating_button)
            except Exception:
                pass

        overlay = state.get("overlay")
        if overlay is not None:
            try:
                parent = overlay.getParent()
                if parent is not None:
                    parent.removeView(overlay)
            except Exception:
                pass

        self._states.pop(key, None)

    def _cancel_active_requests(self, state: Dict[str, Any]):
        request_ids = list(state.get("active_request_ids", []))
        if not request_ids:
            return
        state["active_request_ids"] = []

        try:
            cm = get_connections_manager()
        except Exception:
            cm = None
        if cm is None or not hasattr(cm, "cancelRequest"):
            return

        for rid in request_ids:
            try:
                cm.cancelRequest(int(rid), True)
            except Exception:
                pass

    def _detach_search_watcher(self, state: Dict[str, Any]):
        watcher = state.get("watcher")
        search_input = state.get("search_input")
        if watcher is not None and search_input is not None:
            try:
                if hasattr(search_input, "removeTextChangedListener"):
                    search_input.removeTextChangedListener(watcher)
            except Exception:
                pass
        state["watcher"] = None

    def _remember_request_id(self, state_key: int, request_token: int, request_id: int):
        rid = int(request_id or 0)
        if rid <= 0:
            return
        state = self._states.get(state_key)
        if state is None:
            return
        if int(state.get("request_token", 0)) != int(request_token):
            try:
                cm = get_connections_manager()
                if cm is not None and hasattr(cm, "cancelRequest"):
                    cm.cancelRequest(rid, True)
            except Exception:
                pass
            return

        ids = state.get("active_request_ids")
        if not isinstance(ids, list):
            ids = []
            state["active_request_ids"] = ids
        ids.append(rid)


    def _next_visibility_update_token(self, dialogs_activity: Any) -> int:
        state = self._ensure_state(dialogs_activity)
        token = int(state.get("visibility_update_token", 0)) + 1
        state["visibility_update_token"] = token
        return token

    def _now_ms(self) -> int:
        try:
            return int(jclass("java.lang.System").currentTimeMillis())
        except Exception:
            return 0

    def _schedule_visibility_update(
        self,
        dialogs_activity: Any,
        token: int,
        delay: int = 0,
        force_visible: Optional[bool] = None,
    ):
        run_on_ui_thread(
            lambda act=dialogs_activity, t=token, fv=force_visible: self._apply_visibility_update(act, t, fv),
            delay=delay,
        )

    def _apply_visibility_update(self, dialogs_activity: Any, token: int, force_visible: Optional[bool] = None):
        state = self._states.get(self._identity_hash(dialogs_activity))
        if state is None:
            return
        if int(state.get("visibility_update_token", 0)) != int(token):
            return

        visible = bool(force_visible) if force_visible is not None else bool(self._is_search_visible(dialogs_activity))
        self._ensure_explore_button(dialogs_activity, visible)

    def _on_create_view(self, dialogs_activity: Any, root_view: Any):
        state = self._ensure_state(dialogs_activity)
        old_root_view = state.get("root_view")
        if old_root_view is not None and root_view is not None and old_root_view is not root_view:
            self._reset_overlay_state(state)
        state["root_view"] = root_view
        state["search_container"] = None
        token = self._next_visibility_update_token(dialogs_activity)
        self._schedule_visibility_update(dialogs_activity, token, delay=120)

    def _on_resume(self, dialogs_activity: Any):
        token = self._next_visibility_update_token(dialogs_activity)
        self._schedule_visibility_update(dialogs_activity, token)
        state = self._ensure_state(dialogs_activity)
        if state.get("overlay") is not None:
            self._refresh_chip_styles(state)
            self._render_results(state, animate=False)

    def _on_destroy(self, dialogs_activity: Any):
        self._cleanup_state(self._identity_hash(dialogs_activity))

    def _on_show_search(self, dialogs_activity: Any, show: bool):
        state = self._ensure_state(dialogs_activity)
        if show:
            state["suppress_show_until_ms"] = 0
        else:
            state["suppress_show_until_ms"] = self._now_ms() + 900

        token = self._next_visibility_update_token(dialogs_activity)
        if show:
            self._schedule_visibility_update(dialogs_activity, token, delay=40, force_visible=True)
            self._schedule_visibility_update(dialogs_activity, token, delay=220, force_visible=True)
            self._schedule_visibility_update(dialogs_activity, token, delay=420, force_visible=True)
        else:
            self._schedule_visibility_update(dialogs_activity, token, force_visible=False)
            run_on_ui_thread(lambda act=dialogs_activity: self._close_overlay(act, clear_focus=True))

    def _on_toggle_search(self):
        if self._hook_show_search_ref is not None or self._hook_show_search_short_ref is not None:
            return
        frag = None
        try:
            frag = get_last_fragment()
        except Exception:
            frag = None
        if frag is None:
            return
        try:
            cls_name = str(frag.getClass().getName() or "")
        except Exception:
            cls_name = ""
        if cls_name != "org.telegram.ui.DialogsActivity":
            return

        visible = bool(self._is_search_visible(frag))
        token = self._next_visibility_update_token(frag)
        self._schedule_visibility_update(frag, token, delay=30, force_visible=visible)
        self._schedule_visibility_update(frag, token, delay=180, force_visible=visible)
        self._schedule_visibility_update(frag, token, delay=420, force_visible=visible)
        if not visible:
            run_on_ui_thread(lambda act=frag: self._close_overlay(act, clear_focus=True))


    def _is_search_visible(self, dialogs_activity: Any) -> bool:
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            return bool(search_item is not None and search_item.isSearchFieldVisible())
        except Exception:
            return False

    def _set_explore_visible(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        suppress_until = int(state.get("suppress_show_until_ms", 0) or 0)
        if visible and suppress_until > self._now_ms():
            visible = False
        button = state.get("explore_button")
        if button is None:
            self._ensure_floating_button(dialogs_activity, visible and self._is_search_visible(dialogs_activity))
        else:
            try:
                button.setVisibility(View.VISIBLE if visible else View.GONE)
            except Exception:
                pass
            show_floating = False
            if visible and self._is_search_visible(dialogs_activity):
                show_floating = not self._is_view_visible_on_screen(button)
            self._ensure_floating_button(dialogs_activity, show_floating)

    def _ensure_explore_button(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        suppress_until = int(state.get("suppress_show_until_ms", 0) or 0)
        if visible and suppress_until > self._now_ms():
            visible = False
        if not visible:
            button = state.get("explore_button")
            if button is not None:
                try:
                    button.setVisibility(View.GONE)
                except Exception:
                    pass
            self._ensure_floating_button(dialogs_activity, False)
            return
        self._ensure_root_view(state, dialogs_activity)
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            if search_item is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
            search_container = None
            try:
                if hasattr(search_item, "getSearchContainer"):
                    search_container = search_item.getSearchContainer()
            except Exception:
                search_container = None
            if search_container is None:
                clear_button = search_item.getSearchClearButton()
                if clear_button is not None:
                    search_container = clear_button.getParent()
            if search_container is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
        except Exception:
            self._ensure_floating_button(dialogs_activity, visible)
            return

        state["search_container"] = search_container
        button = state.get("explore_button")
        if button is None:
            button = self._create_explore_button(search_container.getContext(), dialogs_activity)
            if button is None:
                self._ensure_floating_button(dialogs_activity, visible)
                return
            state["explore_button"] = button

        attached = False
        try:
            parent = button.getParent()
            if parent is not search_container:
                if parent is not None:
                    parent.removeView(button)
                params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.RIGHT | Gravity.CENTER_VERTICAL
                params.rightMargin = AndroidUtilities.dp(56)
                search_container.addView(button, params)
            attached = True
            try:
                button.bringToFront()
            except Exception:
                pass
        except Exception:
            attached = False

        try:
            button.setVisibility(View.VISIBLE if visible else View.GONE)
        except Exception:
            pass

        if attached:
            show_floating = bool(visible and (not self._is_view_visible_on_screen(button)))
            self._ensure_floating_button(dialogs_activity, show_floating)
        else:
            self._ensure_floating_button(dialogs_activity, visible and self._is_search_visible(dialogs_activity))

    def _is_view_visible_on_screen(self, view: Any) -> bool:
        if view is None:
            return False
        try:
            if int(view.getVisibility()) != int(View.VISIBLE):
                return False
        except Exception:
            pass
        try:
            if int(view.getWidth()) <= 0 or int(view.getHeight()) <= 0:
                return False
        except Exception:
            pass
        try:
            Rect = jclass("android.graphics.Rect")
            rect = Rect()
            ok = bool(view.getGlobalVisibleRect(rect))
            if not ok:
                return False
            return int(rect.width()) > 0 and int(rect.height()) > 0
        except Exception:
            pass
        try:
            return bool(view.isShown())
        except Exception:
            return True

    def _create_explore_button(self, context: Any, dialogs_activity: Any):
        try:
            p = self._palette()
            button = TextView(context)
            button.setText("Explore")
            button.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            button.setTypeface(Typeface.DEFAULT_BOLD)
            button.setPadding(AndroidUtilities.dp(14), AndroidUtilities.dp(6), AndroidUtilities.dp(14), AndroidUtilities.dp(6))
            button.setTextColor(self._color(p["action_title"]))

            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(16))
            bg.setColor(self._color(p["explore_button"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(p["explore_button_stroke"]))
            button.setBackground(bg)
            self._apply_round_ripple(button, p["ripple"], radius_dp=16)

            button.setOnClickListener(OnClickListener(lambda _v=None, act=dialogs_activity: self._open_overlay(act)))
            return button
        except Exception:
            return None

    def _apply_round_ripple(self, view: Any, ripple_color: int, radius_dp: int = 16):
        if view is None:
            return
        try:
            mask = int(getattr(Theme, "RIPPLE_MASK_ROUNDRECT_6DP", 7))
            ripple = Theme.createSelectorDrawable(self._color(ripple_color), mask, AndroidUtilities.dp(radius_dp))
        except Exception:
            return
        try:
            if hasattr(view, "setForeground"):
                view.setForeground(ripple)
        except Exception:
            pass

    def _set_icon_ripple(self, view: Any, ripple_color: int, radius_dp: int = 20):
        if view is None:
            return
        try:
            mask = int(getattr(Theme, "RIPPLE_MASK_CIRCLE_20DP", 1))
            ripple = Theme.createSelectorDrawable(self._color(ripple_color), mask, AndroidUtilities.dp(radius_dp))
            view.setBackground(ripple)
        except Exception:
            pass

    def _ensure_root_view(self, state: Dict[str, Any], dialogs_activity: Any):
        if state.get("root_view") is not None:
            return
        root = None
        try:
            root = get_private_field(dialogs_activity, "fragmentView")
        except Exception:
            root = None
        if root is None:
            try:
                root = dialogs_activity.getFragmentView()
            except Exception:
                root = None
        if root is None:
            try:
                root = getattr(dialogs_activity, "fragmentView", None)
            except Exception:
                root = None
        state["root_view"] = root

    def _ensure_floating_button(self, dialogs_activity: Any, visible: bool):
        state = self._ensure_state(dialogs_activity)
        if bool(state.get("overlay_open", False)):
            visible = False
        self._ensure_root_view(state, dialogs_activity)
        root_view = state.get("root_view")
        if root_view is None or not hasattr(root_view, "addView"):
            if visible:
                self._safe_log("[ExploreSearch] floating fallback skipped: no root_view")
            return

        floating = state.get("floating_button")
        if floating is None and not visible:
            return
        if floating is None:
            context = None
            try:
                context = root_view.getContext()
            except Exception:
                context = None
            if context is None:
                return
            floating = self._create_explore_button(context, dialogs_activity)
            if floating is None:
                return
            state["floating_button"] = floating
            self._safe_log("[ExploreSearch] using floating Explore button fallback")

        try:
            parent = floating.getParent()
            top_margin = self._calc_floating_top_margin(dialogs_activity, root_view)
            if parent is not root_view:
                if parent is not None:
                    parent.removeView(floating)
                params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.TOP | Gravity.RIGHT
                params.topMargin = top_margin
                params.rightMargin = AndroidUtilities.dp(12)
                root_view.addView(floating, params)
            else:
                params = None
                try:
                    params = floating.getLayoutParams()
                except Exception:
                    params = None
                if params is None:
                    params = FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(32))
                params.gravity = Gravity.TOP | Gravity.RIGHT
                params.topMargin = top_margin
                params.rightMargin = AndroidUtilities.dp(12)
                try:
                    floating.setLayoutParams(params)
                except Exception:
                    pass
            floating.bringToFront()
            floating.setVisibility(View.VISIBLE if visible else View.GONE)
        except Exception:
            pass

    def _calc_floating_top_margin(self, dialogs_activity: Any, root_view: Any) -> int:
        fallback = AndroidUtilities.dp(8)
        search_item = None
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
        except Exception:
            search_item = None
        if search_item is None:
            return fallback

        anchor = None
        try:
            anchor = search_item.getSearchField()
        except Exception:
            anchor = None
        if anchor is None:
            try:
                anchor = search_item.getSearchContainer()
            except Exception:
                anchor = None
        if anchor is None:
            try:
                clear_button = search_item.getSearchClearButton()
                anchor = clear_button.getParent() if clear_button is not None else None
            except Exception:
                anchor = None
        if anchor is None:
            return fallback

        top = self._view_top_relative_to_root(anchor, root_view)
        if top < 0:
            return fallback

        try:
            anchor_h = int(anchor.getHeight())
        except Exception:
            anchor_h = AndroidUtilities.dp(36)
        if anchor_h <= 0:
            anchor_h = AndroidUtilities.dp(36)

        btn_h = AndroidUtilities.dp(32)
        centered = top + max(0, int((anchor_h - btn_h) / 2))
        return max(AndroidUtilities.dp(2), centered)

    def _view_top_relative_to_root(self, view: Any, root_view: Any) -> int:
        total = 0.0
        current = view
        for _ in range(24):
            if current is None or current == root_view:
                break
            try:
                total += float(current.getY())
            except Exception:
                try:
                    total += float(current.getTop())
                except Exception:
                    pass
            try:
                parent = current.getParent()
            except Exception:
                parent = None
            if parent is None or not hasattr(parent, "getY"):
                break
            current = parent
        if total < 0:
            return -1
        return int(total)


    def _open_overlay(self, dialogs_activity: Any):
        state = self._ensure_state(dialogs_activity)
        overlay = self._ensure_overlay(dialogs_activity)
        if overlay is None:
            return

        state["overlay_open"] = True
        self._hide_explore_views(state)
        self._set_explore_visible(dialogs_activity, False)

        state["tab"] = "all"
        state["verified_only"] = False
        self._refresh_chip_styles(state)

        try:
            overlay.setVisibility(View.VISIBLE)
            overlay.setAlpha(0.0)
            overlay.animate().alpha(1.0).setDuration(180).start()
        except Exception:
            try:
                overlay.setVisibility(View.VISIBLE)
            except Exception:
                pass

        query = self._extract_current_query(dialogs_activity)
        search_input = state.get("search_input")
        if search_input is not None:
            try:
                old_query = str(search_input.getText().toString())
            except Exception:
                old_query = ""
            if old_query != query:
                try:
                    search_input.setText(query)
                    search_input.setSelection(search_input.length())
                except Exception:
                    pass
        state["query"] = query
        self._update_search_clear_visibility(state, query)
        self._on_query_changed(state["key"], query)

        def _focus():
            field = state.get("search_input")
            if field is None:
                return
            try:
                field.requestFocus()
                AndroidUtilities.showKeyboard(field)
            except Exception:
                pass

        run_on_ui_thread(_focus, delay=90)

    def _close_overlay(self, dialogs_activity: Any, clear_focus: bool = False):
        state = self._ensure_state(dialogs_activity)
        state["debounce_token"] = int(state.get("debounce_token", 0)) + 1
        state["request_token"] = int(state.get("request_token", 0)) + 1
        state["query"] = ""
        state["pending_sources"] = 0
        state["searching_more_sources"] = False
        state["loading"] = False
        self._cancel_active_requests(state)
        overlay = state.get("overlay")
        if overlay is not None:
            try:
                overlay.animate().alpha(0.0).setDuration(150).start()
                run_on_ui_thread(lambda ov=overlay: ov.setVisibility(View.GONE), delay=160)
            except Exception:
                try:
                    overlay.setVisibility(View.GONE)
                except Exception:
                    pass

        def _restore():
            st = self._ensure_state(dialogs_activity)
            st["overlay_open"] = False
            self._set_explore_visible(dialogs_activity, self._is_search_visible(dialogs_activity))

        run_on_ui_thread(_restore, delay=170)

        if clear_focus:
            field = state.get("search_input")
            if field is not None:
                try:
                    AndroidUtilities.hideKeyboard(field)
                except Exception:
                    pass
                try:
                    field.clearFocus()
                except Exception:
                    pass

    def _hide_explore_views(self, state: Dict[str, Any]):
        for key in ("explore_button", "floating_button"):
            view = state.get(key)
            if view is None:
                continue
            try:
                view.setVisibility(View.GONE)
            except Exception:
                pass

    def _reset_overlay_state(self, state: Dict[str, Any]):
        self._cancel_active_requests(state)
        self._detach_search_watcher(state)
        overlay = state.get("overlay")
        if overlay is not None:
            try:
                parent = overlay.getParent()
                if parent is not None:
                    parent.removeView(overlay)
            except Exception:
                pass
        state["overlay_open"] = False
        state["overlay"] = None
        state["search_input"] = None
        state["search_clear_button"] = None
        state["results_container"] = None
        state["tab_buttons"] = {}
        state["tabs_indicator"] = None
        state["tabs_scroll"] = None
        state["filters_row"] = None
        state["verified_chip"] = None
        state["verified_chip_text"] = None
        state["verified_chip_icon"] = None
        state["inline_default_chip"] = None
        state["inline_default_chip_text"] = None
        state["inline_default_chip_icon"] = None
        state["status_mode"] = ""
        state["status_shell"] = None
        state["status_title_view"] = None
        state["status_subtitle_view"] = None
        state["status_lottie_view"] = None
        state["status_sticker_view"] = None
        state["local_results"] = []
        state["contacts_results"] = []
        state["global_results"] = []
        state["chat_results"] = []
        state["hashtag_results"] = []
        state["resolved_results"] = []
        state["inline_results"] = []
        state["all_results"] = []
        state["filtered_results"] = []

    def _get_overlay_top_padding(self, context: Any) -> int:
        base = AndroidUtilities.dp(12)
        try:
            status = int(AndroidUtilities.getStatusBarHeight(context))
            if status > 0:
                return base + status
        except Exception:
            pass
        try:
            status = int(getattr(AndroidUtilities, "statusBarHeight", 0) or 0)
            if status > 0:
                return base + status
        except Exception:
            pass
        return AndroidUtilities.dp(30)

    def _ensure_overlay(self, dialogs_activity: Any):
        state = self._ensure_state(dialogs_activity)
        root_view = state.get("root_view")
        if root_view is None:
            try:
                root_view = get_private_field(dialogs_activity, "fragmentView")
            except Exception:
                root_view = None
            state["root_view"] = root_view
        if root_view is None or not hasattr(root_view, "addView"):
            return None

        overlay = state.get("overlay")
        if overlay is not None:
            try:
                if overlay.getParent() is root_view:
                    return overlay
            except Exception:
                pass
            self._reset_overlay_state(state)
            overlay = None

        context = None
        try:
            context = root_view.getContext()
        except Exception:
            pass
        if context is None:
            return None

        p = self._palette()

        overlay = FrameLayout(context)
        overlay.setVisibility(View.GONE)
        overlay.setAlpha(0.0)
        overlay.setClickable(True)
        bg = GradientDrawable()
        bg.setColor(self._color(p["bg"]))
        overlay.setBackground(bg)

        content = LinearLayout(context)
        content.setOrientation(LinearLayout.VERTICAL)
        content.setPadding(AndroidUtilities.dp(16), self._get_overlay_top_padding(context), AndroidUtilities.dp(16), AndroidUtilities.dp(14))
        overlay.addView(content, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))

        top_row = LinearLayout(context)
        top_row.setOrientation(LinearLayout.HORIZONTAL)
        top_row.setGravity(Gravity.CENTER_VERTICAL)
        content.addView(top_row, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        back = ImageView(context)
        back.setImageResource(R.drawable.ic_ab_back)
        back.setColorFilter(self._color(p["overlay_icon"]))
        back.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        self._set_icon_ripple(back, p["ripple"], radius_dp=20)
        back.setOnClickListener(OnClickListener(lambda _v=None, act=dialogs_activity: self._close_overlay(act, clear_focus=True)))
        top_row.addView(back, LinearLayout.LayoutParams(AndroidUtilities.dp(40), AndroidUtilities.dp(40)))

        title = TextView(context)
        title.setText("Content search")
        title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 21)
        title.setTypeface(Typeface.DEFAULT_BOLD)
        title.setTextColor(self._color(p["overlay_title"]))
        title_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        title_lp.leftMargin = AndroidUtilities.dp(8)
        top_row.addView(title, title_lp)

        search_wrap = LinearLayout(context)
        search_wrap.setOrientation(LinearLayout.HORIZONTAL)
        search_wrap.setGravity(Gravity.CENTER_VERTICAL)
        search_wrap.setPadding(AndroidUtilities.dp(16), 0, AndroidUtilities.dp(14), 0)
        search_bg = GradientDrawable()
        search_bg.setCornerRadius(AndroidUtilities.dp(26))
        search_bg.setColor(self._color(p["input_bg"]))
        search_bg.setStroke(AndroidUtilities.dp(1), self._color(p["input_stroke_soft"]))
        search_wrap.setBackground(search_bg)
        search_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(56))
        search_lp.topMargin = AndroidUtilities.dp(18)
        content.addView(search_wrap, search_lp)

        icon = ImageView(context)
        icon.setImageResource(R.drawable.msg_search)
        icon.setColorFilter(self._color(p["input_hint"]))
        search_wrap.addView(icon, LinearLayout.LayoutParams(AndroidUtilities.dp(24), AndroidUtilities.dp(24)))

        search_input = EditText(context)
        search_input.setBackgroundColor(self._color(0x00000000))
        search_input.setHint("Search all dialogs by keyword (#hashtags supported)")
        search_input.setHintTextColor(self._color(p["input_hint"]))
        search_input.setTextColor(self._color(p["input_text"]))
        search_input.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 17)
        search_input.setInputType(InputType.TYPE_CLASS_TEXT)
        search_input.setSingleLine(True)
        input_lp = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0)
        input_lp.leftMargin = AndroidUtilities.dp(12)
        search_wrap.addView(search_input, input_lp)

        clear_button = ImageView(context)
        clear_button.setImageResource(R.drawable.msg_close)
        clear_button.setColorFilter(self._color(p["input_hint"]))
        clear_button.setPadding(AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6), AndroidUtilities.dp(6))
        clear_button.setVisibility(View.GONE)
        self._set_icon_ripple(clear_button, p["ripple"], radius_dp=18)
        clear_button.setOnClickListener(OnClickListener(lambda _v=None, key=state["key"]: self._on_search_clear_click(key)))
        search_wrap.addView(clear_button, LinearLayout.LayoutParams(AndroidUtilities.dp(32), AndroidUtilities.dp(32)))

        tabs_shell = FrameLayout(context)
        tabs_shell_bg = GradientDrawable()
        tabs_shell_bg.setCornerRadius(AndroidUtilities.dp(21))
        tabs_shell_bg.setColor(self._color(p["tabs_shell_bg"]))
        tabs_shell_bg.setStroke(AndroidUtilities.dp(1), self._color(p["tabs_shell_stroke"]))
        tabs_shell.setBackground(tabs_shell_bg)
        tabs_shell.setPadding(AndroidUtilities.dp(4), AndroidUtilities.dp(2), AndroidUtilities.dp(4), AndroidUtilities.dp(2))
        try:
            tabs_shell.setClipChildren(True)
            tabs_shell.setClipToPadding(True)
        except Exception:
            pass
        try:
            if hasattr(tabs_shell, "setClipToOutline"):
                tabs_shell.setClipToOutline(True)
        except Exception:
            pass
        tabs_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, AndroidUtilities.dp(46))
        tabs_lp.topMargin = AndroidUtilities.dp(10)
        content.addView(tabs_shell, tabs_lp)

        tabs_scroll = HorizontalScrollView(context)
        tabs_scroll.setHorizontalScrollBarEnabled(False)
        try:
            tabs_scroll.setOverScrollMode(View.OVER_SCROLL_NEVER)
        except Exception:
            pass
        try:
            tabs_scroll.setClipToPadding(True)
        except Exception:
            pass
        tabs_scroll.setPadding(0, 0, 0, 0)
        tabs_shell.addView(
            tabs_scroll,
            FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT),
        )

        tabs_content = FrameLayout(context)
        tabs_scroll.addView(
            tabs_content,
            HorizontalScrollView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT),
        )

        tabs_indicator = View(context)
        tabs_indicator_bg = GradientDrawable()
        tabs_indicator_bg.setCornerRadius(AndroidUtilities.dp(16))
        tabs_indicator_bg.setColor(self._color(p["tab_active_bg"]))
        tabs_indicator_bg.setStroke(AndroidUtilities.dp(1), self._color(p["tab_active_stroke"]))
        tabs_indicator.setBackground(tabs_indicator_bg)
        tabs_indicator.setAlpha(0.0)
        tabs_content.addView(
            tabs_indicator,
            FrameLayout.LayoutParams(AndroidUtilities.dp(82), AndroidUtilities.dp(38), Gravity.START | Gravity.CENTER_VERTICAL),
        )

        tabs_row = LinearLayout(context)
        tabs_row.setOrientation(LinearLayout.HORIZONTAL)
        tabs_row.setGravity(Gravity.CENTER_VERTICAL)
        tabs_content.addView(
            tabs_row,
            FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.MATCH_PARENT),
        )

        state["tab_buttons"] = {}
        self._add_tab_button(state, tabs_row, "all", "All")
        self._add_tab_button(state, tabs_row, "channels", "Channels")
        self._add_tab_button(state, tabs_row, "groups", "Groups")
        self._add_tab_button(state, tabs_row, "bots", "Bots")
        self._add_tab_button(state, tabs_row, self._CHAT_TAB, "In Chats")
        self._add_tab_button(state, tabs_row, self._INLINE_TAB_ALL, "Inline")
        self._add_tab_button(state, tabs_row, self._INLINE_TAB_SEARCHEE, "Searchee")
        self._add_tab_button(state, tabs_row, self._INLINE_TAB_MOTHER, "MotherSearch")

        inline_default_enabled = bool(state.get("inline_default_enabled", self._setting_bool("inline_in_default_search", False)))
        state["inline_default_enabled"] = inline_default_enabled

        filters_row = LinearLayout(context)
        filters_row.setOrientation(LinearLayout.HORIZONTAL)
        filters_row.setGravity(Gravity.START | Gravity.CENTER_VERTICAL)
        filters_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        filters_lp.topMargin = AndroidUtilities.dp(8)
        content.addView(filters_row, filters_lp)

        verified_chip, verified_chip_icon, verified_chip_text = self._create_filter_chip(
            context,
            "Verified",
            lambda _v=None, key=state["key"]: self._toggle_verified(key),
        )
        verified_chip_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        verified_chip_lp.rightMargin = AndroidUtilities.dp(6)
        filters_row.addView(verified_chip, verified_chip_lp)

        inline_default_chip, inline_default_chip_icon, inline_default_chip_text = self._create_filter_chip(
            context,
            "Inline",
            lambda _v=None, key=state["key"]: self._toggle_inline_default_source(key),
        )
        inline_default_chip_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        filters_row.addView(inline_default_chip, inline_default_chip_lp)

        scroll = ScrollView(context)
        scroll.setFillViewport(True)
        scroll.setVerticalScrollBarEnabled(False)
        results_container = LinearLayout(context)
        results_container.setOrientation(LinearLayout.VERTICAL)
        results_container.setPadding(0, AndroidUtilities.dp(12), 0, AndroidUtilities.dp(10))
        scroll.addView(results_container, ScrollView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))
        content.addView(scroll, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0))

        watcher_cls = find_class("android.text.TextWatcher")
        if watcher_cls is not None:
            plugin_self = self
            state_key = state["key"]

            class _Watcher(dynamic_proxy(watcher_cls)):
                def beforeTextChanged(self, _s, _start, _count, _after):
                    pass

                def onTextChanged(self, _s, _start, _before, _count):
                    pass

                def afterTextChanged(self, editable):
                    text = ""
                    try:
                        text = str(editable.toString())
                    except Exception:
                        try:
                            text = str(editable)
                        except Exception:
                            text = ""
                    plugin_self._on_query_changed(state_key, text)

            watcher = _Watcher()
            try:
                search_input.addTextChangedListener(watcher)
                state["watcher"] = watcher
            except Exception:
                pass

        try:
            root_view.addView(overlay, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
        except Exception:
            return None

        state["overlay"] = overlay
        state["search_input"] = search_input
        state["search_clear_button"] = clear_button
        state["results_container"] = results_container
        state["tabs_indicator"] = tabs_indicator
        state["tabs_scroll"] = tabs_scroll
        state["filters_row"] = filters_row
        state["verified_chip"] = verified_chip
        state["verified_chip_text"] = verified_chip_text
        state["verified_chip_icon"] = verified_chip_icon
        state["inline_default_chip"] = inline_default_chip
        state["inline_default_chip_text"] = inline_default_chip_text
        state["inline_default_chip_icon"] = inline_default_chip_icon

        self._update_search_clear_visibility(state, "")
        self._refresh_chip_styles(state)
        run_on_ui_thread(lambda key=state["key"]: self._sync_tabs_indicator(key, animate=False), delay=40)
        self._render_results(state, animate=False)
        return overlay


    def _create_tab_button(self, context: Any, text: str):
        tab = TextView(context)
        tab.setText(text)
        tab.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
        tab.setTypeface(Typeface.DEFAULT)
        tab.setGravity(Gravity.CENTER)
        tab.setSingleLine(True)
        tab.setPadding(AndroidUtilities.dp(12), 0, AndroidUtilities.dp(12), 0)
        try:
            tab.setIncludeFontPadding(False)
        except Exception:
            pass
        try:
            tab.setMinWidth(AndroidUtilities.dp(70))
        except Exception:
            pass
        try:
            tab.setMaxWidth(AndroidUtilities.dp(150))
        except Exception:
            pass
        try:
            truncate_cls = jclass("android.text.TextUtils$TruncateAt")
            tab.setEllipsize(getattr(truncate_cls, "END"))
        except Exception:
            pass
        self._apply_round_ripple(tab, self._palette()["tab_selector"], radius_dp=16)
        return tab

    def _add_tab_button(self, state: Dict[str, Any], parent: Any, tab_id: str, text: str):
        tab = self._create_tab_button(parent.getContext(), text)
        tab.setOnClickListener(OnClickListener(lambda _v=None, key=state["key"], target=tab_id: self._select_tab(key, target)))
        lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, AndroidUtilities.dp(38))
        lp.rightMargin = AndroidUtilities.dp(2)
        parent.addView(tab, lp)
        state["tab_buttons"][tab_id] = tab

    def _create_filter_chip(self, context: Any, title: str, on_click):
        p = self._palette()
        chip = LinearLayout(context)
        chip.setOrientation(LinearLayout.HORIZONTAL)
        chip.setGravity(Gravity.CENTER_VERTICAL)
        chip.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(5), AndroidUtilities.dp(9), AndroidUtilities.dp(5))
        try:
            chip.setMinimumHeight(AndroidUtilities.dp(30))
        except Exception:
            pass
        try:
            chip.setClipChildren(False)
            chip.setClipToPadding(False)
        except Exception:
            pass
        self._apply_round_ripple(chip, p["ripple"], radius_dp=14)
        try:
            chip.setOnClickListener(OnClickListener(on_click))
        except Exception:
            pass

        icon_view = self._create_filter_lottie_icon(context, p)
        icon_size = AndroidUtilities.dp(13)
        chip.addView(icon_view, LinearLayout.LayoutParams(icon_size, icon_size))

        title_view = TextView(context)
        title_view.setText(str(title))
        title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
        title_view.setTypeface(Typeface.DEFAULT)
        title_view.setSingleLine(True)
        try:
            title_view.setMaxWidth(AndroidUtilities.dp(88))
        except Exception:
            pass
        try:
            truncate_cls = jclass("android.text.TextUtils$TruncateAt")
            title_view.setEllipsize(getattr(truncate_cls, "END"))
        except Exception:
            pass
        text_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        text_lp.leftMargin = AndroidUtilities.dp(5)
        chip.addView(title_view, text_lp)
        return chip, icon_view, title_view

    def _create_filter_lottie_icon(self, context: Any, palette: Dict[str, int]):
        icon_size_dp = 13
        try:
            icon = RLottieImageView(context)
            icon.setAutoRepeat(False)
            try:
                icon.setScaleType(ImageView.ScaleType.CENTER_INSIDE)
            except Exception:
                pass
            try:
                icon.setColorFilter(self._color(palette["chip_text"]))
            except Exception:
                pass
            return icon
        except Exception:
            icon = ImageView(context)
            icon.setImageResource(R.drawable.verified_check)
            icon_size = AndroidUtilities.dp(icon_size_dp)
            icon.setMinimumWidth(icon_size)
            icon.setMinimumHeight(icon_size)
            try:
                icon.setColorFilter(self._color(palette["chip_text"]))
            except Exception:
                pass
            return icon

    def _pick_raw_res(self, names: tuple):
        for name in names:
            try:
                value = getattr(R.raw, name)
                if value is not None:
                    return value
            except Exception:
                continue
        return None

    def _pick_drawable_res(self, names: tuple):
        for name in names:
            try:
                value = getattr(R.drawable, name)
                if value is not None:
                    return value
            except Exception:
                continue
        return None

    def _status_icon_res(self, mode: str):
        mode_value = str(mode or "")
        if mode_value == "error":
            return self._pick_drawable_res(("msg_error", "msg_warning", "msg_close", "msg_report"))
        if mode_value == "empty":
            return self._pick_drawable_res(("msg_filters", "msg_folder", "msg_search"))
        return self._pick_drawable_res(("msg_search",))

    def _status_style_profile(self, mode: str, palette: Dict[str, int]) -> Dict[str, Any]:
        mode_value = str(mode or "")
        base_bg = self._mix_color(palette["status_bg_soft"], palette["bg"], 0.18)
        base_stroke = self._alpha_color(self._mix_color(palette["row_stroke"], palette["accent"], 0.12), 136)
        base_title = self._ensure_contrast(palette["text_soft"], base_bg, 2.8)
        base_subtitle = self._ensure_contrast(self._mix_color(palette["text_soft"], palette["text_muted"], 0.36), base_bg, 2.2)
        base_icon = self._ensure_contrast(self._mix_color(palette["text_soft"], palette["accent"], 0.12), base_bg, 2.2)
        profile = {
            "padding_h": 14,
            "padding_top": 12,
            "padding_bottom": 12,
            "radius": 16,
            "bg": base_bg,
            "stroke": base_stroke,
            "elevation": 2,
            "accent": self._alpha_color(palette["accent"], 166),
            "accent_width": 24,
            "accent_height": 3,
            "accent_margin_bottom": 8,
            "icon_tint": base_icon,
            "icon_alpha": 0.86,
            "icon_size": 20,
            "icon_margin": 8,
            "title_color": base_title,
            "title_size": 17,
            "title_bold": False,
            "subtitle_color": base_subtitle,
            "subtitle_size": 13,
            "subtitle_max_width": 320,
            "subtitle_margin_top": 6,
            "sticker_size": 148,
            "sticker_margin_top": 12,
            "top_margin": 14,
            "subtle_anim": True,
        }

        if mode_value == "loading":
            loading_bg = self._mix_color(base_bg, palette["tabs_shell_bg"], 0.42)
            loading_accent = self._alpha_color(palette["accent"], 214)
            profile.update(
                {
                    "bg": loading_bg,
                    "stroke": self._alpha_color(self._mix_color(palette["accent"], palette["text_soft"], 0.30), 146),
                    "accent": loading_accent,
                    "accent_width": 34,
                    "icon_tint": self._ensure_contrast(self._mix_color(palette["accent"], palette["text"], 0.22), loading_bg, 2.5),
                    "icon_alpha": 0.98,
                    "icon_size": 22,
                    "title_color": self._ensure_contrast(self._mix_color(palette["text"], palette["text_soft"], 0.24), loading_bg, 3.0),
                    "title_bold": True,
                    "subtitle_color": self._ensure_contrast(self._mix_color(palette["text_soft"], palette["text_muted"], 0.30), loading_bg, 2.2),
                }
            )
        elif mode_value == "empty":
            empty_accent = self._mix_color(palette["accent"], palette["text_soft"], 0.52)
            empty_bg = self._mix_color(base_bg, palette["bg"], 0.24)
            profile.update(
                {
                    "bg": empty_bg,
                    "stroke": self._alpha_color(self._mix_color(empty_accent, palette["row_stroke"], 0.34), 140),
                    "accent": self._alpha_color(empty_accent, 176),
                    "accent_width": 28,
                    "icon_tint": self._ensure_contrast(self._mix_color(empty_accent, palette["text_soft"], 0.34), empty_bg, 2.2),
                    "sticker_size": 144,
                }
            )
        elif mode_value == "error":
            danger = self._mix_color(palette["accent"], 0xFFFF6F6F, 0.74)
            error_bg = self._mix_color(base_bg, palette["bg"], 0.12)
            profile.update(
                {
                    "bg": error_bg,
                    "stroke": self._alpha_color(danger, 176),
                    "accent": self._alpha_color(danger, 210),
                    "accent_width": 42,
                    "icon_tint": self._ensure_contrast(self._mix_color(danger, palette["text"], 0.18), error_bg, 2.6),
                    "title_color": self._ensure_contrast(self._mix_color(danger, palette["text"], 0.26), error_bg, 2.9),
                    "title_bold": True,
                    "subtitle_color": self._ensure_contrast(self._mix_color(palette["text_soft"], palette["text_muted"], 0.30), error_bg, 2.2),
                }
            )
        return profile

    def _set_no_results_sticker_placeholder(self, sticker_view: Any):
        if sticker_view is None:
            return
        try:
            if hasattr(sticker_view, "setImageDrawable"):
                sticker_view.setImageDrawable(None)
        except Exception:
            pass
        try:
            sticker_view.setAlpha(0.0)
        except Exception:
            pass

    def _bind_no_results_sticker_view(self, sticker_view: Any):
        if sticker_view is None:
            return
        doc = self._no_results_sticker_doc
        if doc is None:
            self._set_no_results_sticker_placeholder(sticker_view)
            return
        thumb_drawable = None
        if DocumentObject is not None:
            try:
                thumb_drawable = DocumentObject.getSvgThumb(doc, Theme.key_windowBackgroundWhiteGrayIcon, 0.2, 1.0, None)
            except Exception:
                thumb_drawable = None
        try:
            image_location = ImageLocation.getForDocument(doc)
            if image_location is None:
                self._set_no_results_sticker_placeholder(sticker_view)
                return
            bound = False
            try:
                sticker_view.setImage(image_location, "160_160", thumb_drawable, 0, doc)
                bound = True
            except Exception:
                pass
            if not bound:
                try:
                    sticker_view.setImage(image_location, "160_160", thumb_drawable, doc)
                    bound = True
                except Exception:
                    pass
            if not bound:
                sticker_view.setImage(image_location, "160_160", thumb_drawable, None)
            sticker_view.setAlpha(1.0)
            try:
                sticker_view.invalidate()
            except Exception:
                pass
        except Exception:
            self._safe_log("[ExploreSearch] no-results sticker bind failed")
            self._set_no_results_sticker_placeholder(sticker_view)

    def _refresh_no_results_sticker_views(self):
        for state in list(self._states.values()):
            if str(state.get("status_mode", "")) != "empty":
                continue
            self._bind_no_results_sticker_view(state.get("status_sticker_view"))

    def _apply_no_results_sticker_response(self, response: Any, error: Any):
        self._no_results_sticker_loading = False
        if error is not None:
            self._no_results_sticker_failed = True
            self._no_results_sticker_retry_after_ms = self._now_ms() + 30000
            try:
                self._safe_log(self._error_text(error, "[ExploreSearch] no-results sticker request failed"))
            except Exception:
                pass
            self._refresh_no_results_sticker_views()
            return

        doc = None
        try:
            documents = self._java_list(getattr(response, "documents", None))
            if documents:
                index = int(self._NO_RESULTS_STICKER_INDEX)
                if index < 0:
                    index = 0
                if index >= len(documents):
                    index = len(documents) - 1
                doc = documents[index]
        except Exception:
            doc = None

        if doc is None:
            self._no_results_sticker_failed = True
            self._no_results_sticker_retry_after_ms = self._now_ms() + 30000
            self._safe_log("[ExploreSearch] no-results sticker is unavailable in sticker set")
            self._refresh_no_results_sticker_views()
            return

        self._no_results_sticker_doc = doc
        self._no_results_sticker_failed = False
        self._no_results_sticker_retry_after_ms = 0
        self._refresh_no_results_sticker_views()

    def _ensure_no_results_sticker_loaded(self):
        if self._no_results_sticker_doc is not None:
            return
        if self._no_results_sticker_loading:
            return
        if self._no_results_sticker_failed and self._now_ms() < int(self._no_results_sticker_retry_after_ms or 0):
            return
        if self._no_results_sticker_failed:
            self._no_results_sticker_failed = False

        try:
            request = TLRPC.TL_messages_getStickerSet()
            input_set = TLRPC.TL_inputStickerSetShortName()
            input_set.short_name = str(self._NO_RESULTS_STICKER_SET)
            request.stickerset = input_set
            request.hash = 0
        except Exception as e:
            self._no_results_sticker_failed = True
            self._safe_log(f"[ExploreSearch] no-results sticker request build failed: {e}")
            return

        self._no_results_sticker_loading = True

        def _on_response(response, error):
            run_on_ui_thread(lambda r=response, err=error: self._apply_no_results_sticker_response(r, err))

        try:
            send_request(request, RequestCallback(_on_response))
        except Exception as e:
            self._no_results_sticker_loading = False
            self._no_results_sticker_failed = True
            self._safe_log(f"[ExploreSearch] no-results sticker request send failed: {e}")
            self._refresh_no_results_sticker_views()

    def _apply_filter_chip_state(
        self,
        chip: Any,
        title_view: Any,
        icon_view: Any,
        enabled: bool,
        animate_icon: bool,
        palette: Dict[str, int],
    ):
        if chip is None:
            return
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(12))
        if enabled:
            bg.setColor(self._color(palette["chip_active_accent"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(palette["chip_active_stroke"]))
        else:
            bg.setColor(self._color(palette["chip"]))
            bg.setStroke(AndroidUtilities.dp(1), self._color(palette["chip_stroke"]))
        try:
            chip.setBackground(bg)
        except Exception:
            pass
        try:
            chip.setAlpha(1.0 if enabled else 0.95)
        except Exception:
            pass

        text_color = palette["chip_active_accent_text"] if enabled else palette["chip_text"]
        if title_view is not None:
            try:
                title_view.setTextColor(self._color(text_color))
                title_view.setTypeface(Typeface.DEFAULT_BOLD if enabled else Typeface.DEFAULT)
                title_view.setAlpha(1.0 if enabled else 0.82)
            except Exception:
                pass
        self._update_filter_lottie_state(icon_view, enabled, animate_icon, self._color(text_color))

    def _update_filter_lottie_state(self, icon_view: Any, enabled: bool, animate_icon: bool, tint: int):
        if icon_view is None:
            return
        try:
            icon_view.setColorFilter(tint)
        except Exception:
            pass
        if not hasattr(icon_view, "setAnimation"):
            return

        on_res = self._pick_raw_res(("todo_attach", "done", "import_check"))
        off_res = self._pick_raw_res(("stories_intro_go_forward", "filter_no_chats", "filters"))
        target_res = on_res if enabled else (off_res if off_res is not None else on_res)
        if target_res is None:
            return

        try:
            icon_view.setAnimation(target_res, 13, 13)
        except Exception:
            return

        drawable = None
        try:
            drawable = icon_view.getAnimatedDrawable()
        except Exception:
            drawable = None
        if drawable is None:
            if animate_icon and hasattr(icon_view, "playAnimation"):
                try:
                    icon_view.playAnimation()
                except Exception:
                    pass
            return

        try:
            drawable.setPlayInDirectionOfCustomEndFrame(False)
        except Exception:
            pass

        if not enabled and off_res is None:
            try:
                drawable.setProgress(0.0)
            except Exception:
                try:
                    drawable.setCurrentFrame(0, False)
                except Exception:
                    pass
            return

        if animate_icon:
            try:
                drawable.setCurrentFrame(0, False)
            except Exception:
                try:
                    icon_view.setProgress(0.0)
                except Exception:
                    pass
            try:
                icon_view.playAnimation()
            except Exception:
                pass
            return

        try:
            drawable.setProgress(0.99)
        except Exception:
            try:
                frames = int(drawable.getFramesCount())
                if frames > 0:
                    drawable.setCurrentFrame(frames - 1, False)
            except Exception:
                pass

    def _style_tab_button(self, tab: Any, selected: bool, use_indicator: bool = False):
        if tab is None:
            return
        p = self._palette()
        prev_selected = False
        try:
            prev_selected = bool(tab.getTag() == "selected")
        except Exception:
            prev_selected = False
        try:
            tab.setTypeface(Typeface.DEFAULT_BOLD if selected else Typeface.DEFAULT)
            tab.setTextColor(self._color(p["tab_active_text"] if selected else p["tab_inactive_text"]))
            tab.setAlpha(1.0 if selected else 0.86)
            tab.setTag("selected" if selected else "normal")
        except Exception:
            pass
        try:
            bg = GradientDrawable()
            bg.setCornerRadius(AndroidUtilities.dp(16))
            if use_indicator:
                bg.setColor(self._color(0x00000000))
                bg.setStroke(AndroidUtilities.dp(1), self._color(0x00000000))
            elif selected:
                bg.setColor(self._color(p["tab_active_bg"]))
                bg.setStroke(AndroidUtilities.dp(1), self._color(p["tab_active_stroke"]))
            else:
                bg.setColor(self._color(p["tab_bg"]))
                bg.setStroke(AndroidUtilities.dp(1), self._color(p["tab_bg_stroke"]))
            tab.setBackground(bg)
            self._apply_round_ripple(tab, p["tab_selector"], radius_dp=16)
        except Exception:
            pass
        if prev_selected != selected:
            try:
                tab.animate().cancel()
            except Exception:
                pass
            try:
                if selected:
                    tab.setScaleX(0.97)
                    tab.setScaleY(0.97)
                    anim = tab.animate().scaleX(1.0).scaleY(1.0).alpha(1.0).setDuration(200)
                else:
                    anim = tab.animate().scaleX(1.0).scaleY(1.0).alpha(0.86).setDuration(150)
                try:
                    anim.setInterpolator(getattr(CubicBezierInterpolator, "EASE_OUT"))
                except Exception:
                    pass
                anim.start()
            except Exception:
                pass

    def _sync_tabs_indicator(self, state_key: int, animate: bool):
        state = self._states.get(state_key)
        if state is None:
            return
        indicator = state.get("tabs_indicator")
        selected_tab = str(state.get("tab", "all"))
        tab = state.get("tab_buttons", {}).get(selected_tab)
        if tab is None:
            return
        if indicator is None:
            self._scroll_tab_into_view(state, tab, animate)
            return

        width = 0
        left = 0
        try:
            width = int(tab.getWidth())
            left = int(tab.getLeft())
        except Exception:
            return
        if width <= 0:
            run_on_ui_thread(lambda key=state_key: self._sync_tabs_indicator(key, animate=False), delay=40)
            return

        target_width = max(AndroidUtilities.dp(70), width)
        target_width = min(target_width, AndroidUtilities.dp(188))
        target_x = float(left + int((width - target_width) / 2))

        content_width = 0
        try:
            parent = indicator.getParent()
            if parent is not None:
                content_width = int(parent.getWidth())
        except Exception:
            content_width = 0
        if content_width > 0:
            max_x = float(max(0, content_width - target_width))
            if target_x < 0.0:
                target_x = 0.0
            elif target_x > max_x:
                target_x = max_x

        previous_width = 0
        try:
            lp = indicator.getLayoutParams()
            if lp is not None:
                previous_width = int(getattr(lp, "width", 0))
                if previous_width != int(target_width):
                    lp.width = int(target_width)
                    indicator.setLayoutParams(lp)
        except Exception:
            previous_width = 0

        self._scroll_tab_into_view(state, tab, animate)

        try:
            indicator.animate().cancel()
        except Exception:
            pass

        try:
            if animate:
                indicator.setAlpha(0.84)
                indicator.setScaleY(0.94)
                if previous_width > 0 and int(target_width) > 0:
                    indicator.setScaleX(max(0.82, min(1.22, float(previous_width) / float(target_width))))
                else:
                    indicator.setScaleX(0.94)
                anim = indicator.animate().translationX(target_x).alpha(1.0).scaleX(1.0).scaleY(1.0).setDuration(260)
                try:
                    anim.setInterpolator(getattr(CubicBezierInterpolator, "EASE_OUT_QUINT"))
                except Exception:
                    pass
                anim.start()
            else:
                indicator.setTranslationX(target_x)
                indicator.setAlpha(1.0)
                indicator.setScaleX(1.0)
                indicator.setScaleY(1.0)
        except Exception:
            try:
                indicator.setTranslationX(target_x)
                indicator.setAlpha(1.0)
                indicator.setScaleX(1.0)
                indicator.setScaleY(1.0)
            except Exception:
                pass

    def _scroll_tab_into_view(self, state: Dict[str, Any], tab: Any, animate: bool):
        tabs_scroll = state.get("tabs_scroll")
        if tabs_scroll is None or tab is None:
            return
        try:
            viewport = int(tabs_scroll.getWidth()) - int(tabs_scroll.getPaddingLeft()) - int(tabs_scroll.getPaddingRight())
        except Exception:
            viewport = 0
        if viewport <= 0:
            return

        try:
            current_x = int(tabs_scroll.getScrollX())
        except Exception:
            current_x = 0

        try:
            tab_left = int(tab.getLeft())
            tab_right = int(tab.getRight())
        except Exception:
            return

        tab_center = int((tab_left + tab_right) / 2)
        target_x = int(tab_center - viewport / 2)

        target_x = max(0, int(target_x))
        if abs(target_x - current_x) <= 1:
            return

        try:
            if animate and hasattr(tabs_scroll, "smoothScrollTo"):
                tabs_scroll.smoothScrollTo(target_x, 0)
            else:
                tabs_scroll.scrollTo(target_x, 0)
        except Exception:
            pass

    def _refresh_chip_styles(self, state: Dict[str, Any], animate_tabs: bool = False, animate_filter: str = ""):
        selected_tab = str(state.get("tab", "all"))
        p = self._palette()
        use_indicator = state.get("tabs_indicator") is not None
        for tab_id, tab in state.get("tab_buttons", {}).items():
            self._style_tab_button(tab, tab_id == selected_tab, use_indicator=use_indicator)

        verified_value = bool(state.get("verified_only", False))
        self._apply_filter_chip_state(
            state.get("verified_chip"),
            state.get("verified_chip_text"),
            state.get("verified_chip_icon"),
            verified_value,
            animate_filter == "verified",
            p,
        )

        inline_enabled = bool(state.get("inline_default_enabled", False))
        self._apply_filter_chip_state(
            state.get("inline_default_chip"),
            state.get("inline_default_chip_text"),
            state.get("inline_default_chip_icon"),
            inline_enabled,
            animate_filter == "inline",
            p,
        )

        inline_default_chip = state.get("inline_default_chip")
        if inline_default_chip is not None:
            try:
                hide_inline_chip = self._is_inline_tab(selected_tab) or selected_tab == self._CHAT_TAB
                inline_default_chip.setVisibility(View.GONE if hide_inline_chip else View.VISIBLE)
            except Exception:
                pass

        self._sync_tabs_indicator(int(state.get("key", 0) or 0), animate_tabs)

    def _tab_order(self, tab_id: str) -> int:
        tab_value = str(tab_id or "")
        order = (
            "all",
            "channels",
            "groups",
            "bots",
            self._INLINE_TAB_ALL,
            self._INLINE_TAB_SEARCHEE,
            self._INLINE_TAB_MOTHER,
        )
        try:
            return int(order.index(tab_value))
        except Exception:
            return -1

    def _tab_switch_direction(self, prev_tab: str, next_tab: str) -> int:
        prev_index = self._tab_order(prev_tab)
        next_index = self._tab_order(next_tab)
        if prev_index >= 0 and next_index >= 0 and prev_index != next_index:
            return 1 if next_index > prev_index else -1
        return 1

    def _animate_results_tab_switch(self, state: Dict[str, Any], direction: int):
        container = state.get("results_container")
        if container is None:
            return
        shift = AndroidUtilities.dp(10) * (1 if int(direction) >= 0 else -1)
        try:
            container.animate().cancel()
        except Exception:
            pass
        try:
            container.setAlpha(0.76)
            container.setTranslationX(float(shift))
            anim = container.animate().alpha(1.0).translationX(0.0).setDuration(220)
            try:
                anim.setInterpolator(getattr(CubicBezierInterpolator, "EASE_OUT_QUINT"))
            except Exception:
                pass
            anim.start()
        except Exception:
            try:
                container.setAlpha(1.0)
                container.setTranslationX(0.0)
            except Exception:
                pass

    def _select_tab(self, state_key: int, tab_id: str):
        state = self._states.get(state_key)
        if state is None:
            return
        previous_tab = str(state.get("tab", "all"))
        if previous_tab == str(tab_id):
            return
        switch_direction = self._tab_switch_direction(previous_tab, str(tab_id))
        state["tab"] = tab_id
        self._animate_results_tab_switch(state, switch_direction)
        self._refresh_chip_styles(state, animate_tabs=True)
        query = str(state.get("query", "") or "").strip()
        if query:
            self._on_query_changed(state_key, query)
        else:
            self._render_results(state, animate=True)

    def _toggle_verified(self, state_key: int):
        state = self._states.get(state_key)
        if state is None:
            return
        state["verified_only"] = not bool(state.get("verified_only", False))
        self._refresh_chip_styles(state, animate_filter="verified")
        self._render_results(state, animate=True)

    def _toggle_inline_default_source(self, state_key: int):
        state = self._states.get(state_key)
        if state is None:
            return
        enabled = not bool(state.get("inline_default_enabled", False))
        state["inline_default_enabled"] = enabled
        try:
            self.set_setting("inline_in_default_search", bool(enabled))
        except Exception:
            pass

        self._refresh_chip_styles(state, animate_filter="inline")
        query = str(state.get("query", "") or "").strip()
        if query:
            self._on_query_changed(state_key, query)
        else:
            self._render_results(state, animate=True)


    def _extract_current_query(self, dialogs_activity: Any) -> str:
        try:
            search_item = get_private_field(dialogs_activity, "searchItem")
            if search_item is None:
                return ""
            field = search_item.getSearchField()
            if field is None:
                return ""
            return str(field.getText().toString() or "")
        except Exception:
            return ""

    def _on_search_clear_click(self, state_key: int):
        state = self._states.get(state_key)
        if state is None:
            return
        field = state.get("search_input")
        if field is None:
            return
        try:
            field.setText("")
        except Exception:
            return
        self._update_search_clear_visibility(state, "")
        try:
            field.requestFocus()
            AndroidUtilities.showKeyboard(field)
        except Exception:
            pass

    def _update_search_clear_visibility(self, state: Dict[str, Any], query: str):
        clear_button = state.get("search_clear_button")
        if clear_button is None:
            return
        visible = bool(str(query or "").strip())
        try:
            clear_button.setVisibility(View.VISIBLE if visible else View.GONE)
        except Exception:
            pass

    def _on_query_changed(self, state_key: int, text: str):
        state = self._states.get(state_key)
        if state is None:
            return

        query = str(text or "")
        state["query"] = query
        self._update_search_clear_visibility(state, query)
        state["error"] = ""
        state["debounce_token"] = int(state.get("debounce_token", 0)) + 1
        debounce_token = state["debounce_token"]

        if not query.strip():
            state["loading"] = False
            state["request_token"] = int(state.get("request_token", 0)) + 1
            self._cancel_active_requests(state)
            state["all_results"] = []
            state["local_results"] = []
            state["contacts_results"] = []
            state["global_results"] = []
            state["chat_results"] = []
            state["hashtag_results"] = []
            state["resolved_results"] = []
            state["inline_results"] = []
            state["pending_sources"] = 0
            state["source_errors"] = []
            state["searching_more_sources"] = False
            state["error"] = ""
            self._render_results(state, animate=False)
            return

        state["loading"] = True
        self._render_results(state, animate=False)

        def _run():
            current_state = self._states.get(state_key)
            if current_state is None:
                return
            if int(current_state.get("debounce_token", 0)) != debounce_token:
                return
            self._perform_search(state_key, query)

        run_on_ui_thread(_run, delay=self._DEBOUNCE_MS)

    def _perform_search(self, state_key: int, query: str):
        state = self._states.get(state_key)
        if state is None:
            return

        query = str(query or "").strip()
        if not query:
            state["loading"] = False
            self._cancel_active_requests(state)
            state["all_results"] = []
            state["local_results"] = []
            state["contacts_results"] = []
            state["global_results"] = []
            state["chat_results"] = []
            state["hashtag_results"] = []
            state["resolved_results"] = []
            state["inline_results"] = []
            state["pending_sources"] = 0
            state["source_errors"] = []
            state["searching_more_sources"] = False
            self._render_results(state, animate=False)
            return

        state["request_token"] = int(state.get("request_token", 0)) + 1
        request_token = int(state["request_token"])
        self._cancel_active_requests(state)
        state["loading"] = True
        state["error"] = ""
        state["all_results"] = []
        state["local_results"] = []
        state["contacts_results"] = []
        state["global_results"] = []
        state["chat_results"] = []
        state["hashtag_results"] = []
        state["resolved_results"] = []
        state["inline_results"] = []
        state["source_errors"] = []

        tab = str(state.get("tab", "all"))
        default_inline_usernames = self._inline_bot_usernames()
        if self._is_inline_tab(tab):
            inline_usernames = self._inline_usernames_for_tab(tab)
            inline_source_count = len(inline_usernames)
            state["pending_sources"] = inline_source_count
            state["searching_more_sources"] = bool(inline_source_count > 1)
            if inline_source_count <= 0:
                state["loading"] = False
                state["error"] = "Inline bots are not configured"
                self._render_results(state, animate=False)
                return
            self._render_results(state, animate=False)
            for bot_username in inline_usernames:
                self._request_inline_source(
                    state_key,
                    request_token,
                    query,
                    bot_username=bot_username,
                    page=1,
                    offset="",
                )
            return

        if tab == self._CHAT_TAB:
            state["pending_sources"] = 1
            state["searching_more_sources"] = False
            self._render_results(state, animate=False)
            self._request_chat_source(state_key, request_token, query)
            return

        username_query = self._extract_username_query(query)
        hashtag_query = self._extract_hashtag_query(query)
        inline_in_default = bool(state.get("inline_default_enabled", False)) and tab in ("all", "channels")
        source_count = (
            3
            + (1 if username_query else 0)
            + (1 if hashtag_query else 0)
            + (len(default_inline_usernames) if inline_in_default else 0)
        )
        state["pending_sources"] = source_count
        state["searching_more_sources"] = bool(source_count > 1)
        self._render_results(state, animate=False)

        self._request_local_source(state_key, request_token, query)
        self._request_contacts_source(state_key, request_token, query)
        self._request_global_source(state_key, request_token, query, page=1)
        if inline_in_default:
            for bot_username in default_inline_usernames:
                self._request_inline_source(
                    state_key,
                    request_token,
                    query,
                    bot_username=bot_username,
                    page=1,
                    offset="",
                )
        if hashtag_query:
            self._request_hashtag_source(state_key, request_token, query, hashtag_query, page=1)
        if username_query:
            self._request_resolve_source(state_key, request_token, query, username_query)

    def _dialogs_type_for_tab(self, tab: str) -> int:
        if tab == "channels":
            return 5
        if tab == "groups":
            return 6
        if tab == "bots":
            return 4
        return 0

    def _current_folder_id(self, dialogs_activity: Any) -> int:
        if dialogs_activity is None:
            return 0
        try:
            return int(get_private_field(dialogs_activity, "folderId") or 0)
        except Exception:
            return 0

    def _request_local_source(self, state_key: int, request_token: int, query: str):
        state = self._states.get(state_key)
        if state is None:
            return

        tab = str(state.get("tab", "all"))
        dialogs_type = self._dialogs_type_for_tab(tab)
        folder_id = self._current_folder_id(state.get("activity"))
        search_query = self._normalize(query)

        def _run_local(key=state_key, token=request_token, q=query, d_type=dialogs_type, f_id=folder_id, sq=search_query):
            result_items = []
            source_error = ""
            try:
                storage = get_messages_storage()
                if storage is None or not hasattr(storage, "localSearch"):
                    raise RuntimeError("local search unavailable")

                ArrayList = jclass("java.util.ArrayList")
                result_array = ArrayList()
                result_names = ArrayList()
                enc_users = ArrayList()

                storage.localSearch(int(d_type), sq, result_array, result_names, enc_users, None, int(f_id))
                result_items = self._build_local_ranked_results(result_array, q)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] local search failed: {e}")
                source_error = ""

            run_on_ui_thread(
                lambda k=key, t=token, text=q, items=result_items, err=source_error: self._apply_local_source_response(
                    k, t, text, items, err
                )
            )

        try:
            run_on_queue(_run_local, queue_name=SEARCH_QUEUE)
        except Exception:
            _run_local()

    def _request_contacts_source(self, state_key: int, request_token: int, query: str):
        req = TLRPC.TL_contacts_search()
        req.q = query
        req.limit = int(self._REQUEST_LIMIT)

        def _on_response(response, error, key=state_key, token=request_token, q=query):
            run_on_ui_thread(lambda: self._apply_contacts_source_response(key, token, q, response, error))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] contacts request failed: {e}")
                self._finalize_source_response(state, "Contacts search failed")

    def _request_chat_source(self, state_key: int, request_token: int, query: str):
        state = self._states.get(state_key)
        if state is None:
            return

        dialog_ids = self._collect_chat_source_dialog_ids(state)
        if not dialog_ids:
            self._apply_chat_source_response(state_key, request_token, query, [], "")
            return

        session: Dict[str, Any] = {
            "state_key": int(state_key),
            "request_token": int(request_token),
            "query": str(query or ""),
            "dialog_ids": dialog_ids,
            "next_index": 0,
            "active": 0,
            "remaining": len(dialog_ids),
            "results": [],
            "errors": [],
            "stopped": False,
        }
        self._dispatch_chat_source_requests(session)

    def _collect_chat_source_dialog_ids(self, state: Dict[str, Any]) -> List[int]:
        mc = get_messages_controller()
        if mc is None or not hasattr(mc, "getDialogs"):
            return []

        folder_id = self._current_folder_id(state.get("activity"))
        tab = str(state.get("tab", "all"))
        try:
            dialogs = mc.getDialogs(int(folder_id))
        except Exception:
            dialogs = []

        out: List[int] = []
        seen = set()
        for dialog in self._java_list(dialogs):
            try:
                did = int(getattr(dialog, "id", 0) or 0)
            except Exception:
                did = 0
            if did == 0 or did in seen:
                continue

            try:
                if DialogObject.isFolderDialogId(did) or DialogObject.isEncryptedDialog(did):
                    continue
            except Exception:
                pass

            if tab != self._CHAT_TAB:
                kind = self._dialog_kind_for_did(did)
                if not self._tab_allows_kind(tab, kind):
                    continue
            if self._input_peer_from_did(did) is None:
                continue

            seen.add(did)
            out.append(did)
            if len(out) >= int(self._CHAT_SEARCH_MAX_DIALOGS):
                break
        return out

    def _dialog_kind_for_did(self, did: int) -> str:
        dialog_id = int(did or 0)
        if dialog_id == 0:
            return ""

        mc = get_messages_controller()
        if mc is None:
            return ""

        if dialog_id > 0:
            if not hasattr(mc, "getUser"):
                return ""
            try:
                user = mc.getUser(dialog_id)
            except Exception:
                user = None
            if user is None:
                return ""

            try:
                if hasattr(UserObject, "isUserSelf") and bool(UserObject.isUserSelf(user)):
                    return ""
            except Exception:
                pass
            try:
                if hasattr(UserObject, "isReplyUser") and bool(UserObject.isReplyUser(user)):
                    return ""
            except Exception:
                pass

            try:
                is_bot = bool(UserObject.isBot(user))
            except Exception:
                is_bot = bool(getattr(user, "bot", False))
            return "bot" if is_bot else "user"

        if not hasattr(mc, "getChat"):
            return ""
        try:
            chat = mc.getChat(-dialog_id)
        except Exception:
            chat = None
        if chat is None:
            return ""

        try:
            if hasattr(ChatObject, "isNotInChat") and bool(ChatObject.isNotInChat(chat)):
                return ""
        except Exception:
            pass

        try:
            is_channel = bool(ChatObject.isChannelAndNotMegaGroup(chat))
        except Exception:
            try:
                is_channel = bool(ChatObject.isChannel(chat) and not ChatObject.isMegagroup(chat))
            except Exception:
                is_channel = bool(getattr(chat, "broadcast", False))
        return "channel" if is_channel else "group"

    def _tab_allows_kind(self, tab: str, kind: str) -> bool:
        kind_value = str(kind or "")
        if not kind_value:
            return False
        tab_value = str(tab or "all")
        if tab_value == "channels":
            return kind_value == "channel"
        if tab_value == "groups":
            return kind_value == "group"
        if tab_value == "bots":
            return kind_value == "bot"
        if tab_value == self._CHAT_TAB:
            return kind_value in ("channel", "group", "bot", "user")
        return kind_value in ("channel", "group", "bot", "user")

    def _dispatch_chat_source_requests(self, session: Dict[str, Any]):
        if bool(session.get("stopped", False)):
            return

        state_key = int(session.get("state_key", 0) or 0)
        request_token = int(session.get("request_token", 0) or 0)
        query = str(session.get("query", "") or "")

        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            session["stopped"] = True
            return

        dialog_ids = self._java_list(session.get("dialog_ids", []))
        total = len(dialog_ids)
        while (
            int(session.get("active", 0) or 0) < int(self._CHAT_SEARCH_CONCURRENCY)
            and int(session.get("next_index", 0) or 0) < total
        ):
            index = int(session.get("next_index", 0) or 0)
            try:
                did = int(dialog_ids[index] or 0)
            except Exception:
                did = 0
            session["next_index"] = index + 1
            if did == 0:
                session["remaining"] = max(0, int(session.get("remaining", 0) or 0) - 1)
                continue

            session["active"] = int(session.get("active", 0) or 0) + 1
            self._send_chat_source_request(session, did)

        if int(session.get("remaining", 0) or 0) <= 0 and int(session.get("active", 0) or 0) <= 0:
            self._finish_chat_source_session(session)

    def _send_chat_source_request(self, session: Dict[str, Any], did: int):
        state_key = int(session.get("state_key", 0) or 0)
        request_token = int(session.get("request_token", 0) or 0)
        query = str(session.get("query", "") or "")

        input_peer = self._input_peer_from_did(did)
        if input_peer is None:
            run_on_ui_thread(lambda s=session, dialog_id=did: self._on_chat_source_dialog_response(s, dialog_id, None, None))
            return

        req = TLRPC.TL_messages_search()
        req.peer = input_peer
        req.q = query
        req.filter = TLRPC.TL_inputMessagesFilterEmpty()
        req.min_date = 0
        req.max_date = 0
        req.offset_id = 0
        req.add_offset = 0
        req.limit = int(self._CHAT_SEARCH_REQUEST_LIMIT)
        req.max_id = 0
        req.min_id = 0
        req.hash = 0

        def _on_response(response, error, s=session, dialog_id=did):
            run_on_ui_thread(lambda: self._on_chat_source_dialog_response(s, dialog_id, response, error))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            self._safe_log(f"[ExploreSearch] chat search request failed ({did}): {e}")
            run_on_ui_thread(
                lambda s=session, dialog_id=did, err=e: self._on_chat_source_dialog_response(s, dialog_id, None, err)
            )

    def _on_chat_source_dialog_response(self, session: Dict[str, Any], did: int, response: Any, error: Any):
        if bool(session.get("stopped", False)):
            return

        session["active"] = max(0, int(session.get("active", 0) or 0) - 1)
        session["remaining"] = max(0, int(session.get("remaining", 0) or 0) - 1)

        state_key = int(session.get("state_key", 0) or 0)
        request_token = int(session.get("request_token", 0) or 0)
        query = str(session.get("query", "") or "")

        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            session["stopped"] = True
            return

        if error is None and response is not None:
            self._cache_response_entities(response)
            try:
                parsed = self._build_global_ranked_results(response, query)
                session["results"] = self._merge_source_results(list(session.get("results", []) or []), parsed)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] chat search parse failed ({did}): {e}")
                errors = session.get("errors")
                if isinstance(errors, list) and len(errors) < 4:
                    errors.append(f"Chat search parse failed ({did})")
        elif error is not None:
            errors = session.get("errors")
            if isinstance(errors, list) and len(errors) < 4:
                errors.append(self._error_text(error, f"Chat search failed ({did})"))

        if int(session.get("remaining", 0) or 0) <= 0 and int(session.get("active", 0) or 0) <= 0:
            self._finish_chat_source_session(session)
            return

        self._dispatch_chat_source_requests(session)

    def _finish_chat_source_session(self, session: Dict[str, Any]):
        if bool(session.get("stopped", False)):
            return
        session["stopped"] = True

        state_key = int(session.get("state_key", 0) or 0)
        request_token = int(session.get("request_token", 0) or 0)
        query = str(session.get("query", "") or "")

        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        items = list(session.get("results", []) or [])
        source_error = ""
        if not items:
            errors = session.get("errors", [])
            if isinstance(errors, list) and errors:
                source_error = str(errors[0])

        self._apply_chat_source_response(state_key, request_token, query, items, source_error)

    def _request_global_source(
        self,
        state_key: int,
        request_token: int,
        query: str,
        page: int = 1,
        offset_rate: int = 0,
        offset_id: int = 0,
        offset_peer: Any = None,
    ):
        state = self._states.get(state_key)
        if state is None:
            return
        req = TLRPC.TL_messages_searchGlobal()
        req.q = query
        req.limit = int(self._GLOBAL_REQUEST_LIMIT)
        req.filter = TLRPC.TL_inputMessagesFilterEmpty()
        req.min_date = 0
        req.max_date = 0
        req.offset_rate = int(offset_rate or 0)
        req.offset_id = int(offset_id or 0)
        req.offset_peer = offset_peer if offset_peer is not None else TLRPC.TL_inputPeerEmpty()

        tab = str(state.get("tab", "all"))
        req.broadcasts_only = tab == "channels"
        req.groups_only = tab == "groups"
        req.users_only = tab == "bots"

        def _on_response(response, error, key=state_key, token=request_token, q=query, p=page):
            run_on_ui_thread(lambda: self._apply_global_source_response(key, token, q, response, error, p))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] global request failed: {e}")
                self._finalize_source_response(state, "Global search failed")

    def _request_hashtag_source(
        self,
        state_key: int,
        request_token: int,
        query: str,
        hashtag_query: str,
        page: int = 1,
        offset_rate: int = 0,
        offset_id: int = 0,
        offset_peer: Any = None,
    ):
        req = TLRPC.TL_channels_searchPosts()
        req.flags = int(getattr(req, "flags", 0) or 0) | 1
        req.hashtag = hashtag_query
        req.limit = int(self._GLOBAL_REQUEST_LIMIT)
        req.offset_rate = int(offset_rate or 0)
        req.offset_id = int(offset_id or 0)
        req.offset_peer = offset_peer if offset_peer is not None else TLRPC.TL_inputPeerEmpty()

        def _on_response(response, error, key=state_key, token=request_token, q=query, tag=hashtag_query, p=page):
            run_on_ui_thread(lambda: self._apply_hashtag_source_response(key, token, q, tag, response, error, p))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] hashtag request failed: {e}")
                self._finalize_source_response(state, "Hashtag search failed")

    def _request_resolve_source(self, state_key: int, request_token: int, query: str, username_query: str):
        req = TLRPC.TL_contacts_resolveUsername()
        req.flags = 0
        req.username = username_query

        def _on_response(response, error, key=state_key, token=request_token, q=query, uname=username_query):
            run_on_ui_thread(lambda: self._apply_resolve_source_response(key, token, q, uname, response, error))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] resolve request failed: {e}")
                self._finalize_source_response(state, "Resolve username failed")

    def _normalize_inline_bot_username(self, value: str) -> str:
        return str(value or "").strip().lstrip("@")

    def _inline_bot_usernames(self) -> List[str]:
        out: List[str] = []
        seen = set()
        for raw in self._INLINE_BOT_USERNAMES:
            name = self._normalize_inline_bot_username(raw)
            if not name:
                continue
            key = name.lower()
            if key in seen:
                continue
            seen.add(key)
            out.append(name)
        return out

    def _inline_bots_label(self) -> str:
        names = self._inline_bot_usernames()
        if not names:
            return "@inline"
        return ", ".join("@" + name for name in names)

    def _is_inline_tab(self, tab: str) -> bool:
        return str(tab or "") in (
            self._INLINE_TAB_ALL,
            self._INLINE_TAB_SEARCHEE,
            self._INLINE_TAB_MOTHER,
        )

    def _inline_bot_for_tab(self, tab: str) -> str:
        tab_value = str(tab or "")
        if tab_value == self._INLINE_TAB_SEARCHEE:
            return "SearcheeBot"
        if tab_value == self._INLINE_TAB_MOTHER:
            return "MotherSearchBot"
        return ""

    def _inline_usernames_for_tab(self, tab: str) -> List[str]:
        tab_value = str(tab or "")
        if tab_value == self._INLINE_TAB_ALL:
            return self._inline_bot_usernames()
        bot_name = self._inline_bot_for_tab(tab_value)
        if not bot_name:
            return []
        return [bot_name]

    def _inline_label_for_tab(self, tab: str) -> str:
        tab_value = str(tab or "")
        if tab_value == self._INLINE_TAB_ALL:
            return self._inline_bots_label()
        bot_name = self._inline_bot_for_tab(tab_value)
        if not bot_name:
            return self._inline_bots_label()
        return "@" + self._normalize_inline_bot_username(bot_name)

    def _inline_source_key(self, value: str) -> str:
        return self._normalize_inline_bot_username(value).lower()

    def _inline_sources_from_item(self, item: Dict[str, Any]) -> List[str]:
        out: List[str] = []
        seen = set()
        for source in self._java_list(item.get("inline_sources", [])):
            key = self._inline_source_key(str(source or ""))
            if not key or key in seen:
                continue
            seen.add(key)
            out.append(key)

        primary = self._inline_source_key(str(item.get("inline_source", "") or ""))
        if primary and primary not in seen:
            out.insert(0, primary)
        return out

    def _item_has_inline_source(self, item: Dict[str, Any], source_key: str) -> bool:
        lookup = self._inline_source_key(source_key)
        if not lookup:
            return False
        return lookup in self._inline_sources_from_item(item)

    def _mark_inline_item_source(self, item: Dict[str, Any], bot_username: str):
        source_key = self._inline_source_key(bot_username)
        if not source_key:
            return
        sources = self._inline_sources_from_item(item)
        if source_key not in sources:
            sources.append(source_key)
        item["inline_sources"] = sources
        item["inline_source"] = sources[0] if sources else source_key

    def _merge_inline_item_sources(self, target: Dict[str, Any], source: Dict[str, Any]):
        merged = self._inline_sources_from_item(target)
        for source_key in self._inline_sources_from_item(source):
            if source_key not in merged:
                merged.append(source_key)
        if not merged:
            return
        target["inline_sources"] = merged
        target["inline_source"] = merged[0]

    def _cached_inline_bot_user(self, bot_username: str):
        mc = get_messages_controller()
        if mc is None:
            return None

        bot_username = self._normalize_inline_bot_username(bot_username)
        if not bot_username:
            return None

        cache_key = bot_username.lower()
        uid = int(self._inline_bot_user_ids.get(cache_key, 0) or 0)
        if uid > 0 and hasattr(mc, "getUser"):
            try:
                user = mc.getUser(uid)
                if user is not None:
                    return user
            except Exception:
                pass

        obj = None
        if hasattr(mc, "getUserOrChat"):
            try:
                obj = mc.getUserOrChat(bot_username)
            except Exception:
                obj = None
            if obj is None:
                try:
                    obj = mc.getUserOrChat("@" + bot_username)
                except Exception:
                    obj = None

        if obj is not None and hasattr(obj, "bot"):
            try:
                self._inline_bot_user_ids[cache_key] = int(getattr(obj, "id", 0) or 0)
            except Exception:
                self._inline_bot_user_ids[cache_key] = 0
            return obj
        return None

    def _request_inline_source(
        self,
        state_key: int,
        request_token: int,
        query: str,
        bot_username: str,
        page: int = 1,
        offset: str = "",
    ):
        state = self._states.get(state_key)
        if state is None:
            return

        bot_username = self._normalize_inline_bot_username(bot_username)
        if not bot_username:
            self._finalize_source_response(state, "Inline bot username is empty")
            return

        bot_user = self._cached_inline_bot_user(bot_username)
        if bot_user is not None:
            self._send_inline_source_request(
                state_key,
                request_token,
                query,
                bot_username,
                bot_user,
                page=page,
                offset=offset,
            )
            return

        req = TLRPC.TL_contacts_resolveUsername()
        req.flags = 0
        req.username = bot_username

        def _on_response(response, error, key=state_key, token=request_token, q=query, bot=bot_username, p=page, off=offset):
            run_on_ui_thread(lambda: self._apply_inline_bot_resolve_response(key, token, q, bot, p, off, response, error))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] inline bot resolve failed: {e}")
                self._finalize_source_response(state, f"Inline bot @{bot_username} resolve failed")

    def _apply_inline_bot_resolve_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        bot_username: str,
        page: int,
        offset: str,
        response: Any,
        error: Any,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        bot_username = self._normalize_inline_bot_username(bot_username)
        if error is not None:
            self._finalize_source_response(
                state,
                self._error_text(error, f"Inline bot @{bot_username} resolve failed"),
            )
            return

        self._cache_response_entities(response)
        bot_user = None
        users = self._java_list(getattr(response, "users", None))
        if users:
            bot_user = users[0]
        if bot_user is None:
            self._finalize_source_response(state, f"Inline bot @{bot_username} not found")
            return

        cache_key = bot_username.lower()
        try:
            self._inline_bot_user_ids[cache_key] = int(getattr(bot_user, "id", 0) or 0)
        except Exception:
            self._inline_bot_user_ids[cache_key] = 0

        self._send_inline_source_request(
            state_key,
            request_token,
            query,
            bot_username,
            bot_user,
            page=page,
            offset=offset,
        )

    def _send_inline_source_request(
        self,
        state_key: int,
        request_token: int,
        query: str,
        bot_username: str,
        bot_user: Any,
        page: int = 1,
        offset: str = "",
    ):
        state = self._states.get(state_key)
        if state is None:
            return

        mc = get_messages_controller()
        if mc is None or not hasattr(mc, "getInputUser"):
            self._finalize_source_response(state, "Inline bot request unavailable")
            return

        try:
            input_user = mc.getInputUser(bot_user)
        except Exception:
            input_user = None
        if input_user is None:
            self._finalize_source_response(state, "Inline bot request unavailable")
            return

        req = TLRPC.TL_messages_getInlineBotResults()
        req.bot = input_user
        req.query = query
        req.offset = str(offset or "")
        req.peer = TLRPC.TL_inputPeerEmpty()

        def _on_response(response, error, key=state_key, token=request_token, q=query, bot=bot_username, p=page):
            run_on_ui_thread(lambda: self._apply_inline_source_response(key, token, q, bot, response, error, p))

        try:
            req_id = send_request(req, RequestCallback(_on_response))
            self._remember_request_id(state_key, request_token, req_id)
        except Exception as e:
            state = self._states.get(state_key)
            if state is not None:
                self._safe_log(f"[ExploreSearch] inline request failed: {e}")
                self._finalize_source_response(state, f"Inline bot @{bot_username} request failed")

    def _apply_local_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        items: List[Dict[str, Any]],
        source_error: str,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        state["local_results"] = list(items or [])
        self._finalize_source_response(state, source_error)

    def _apply_chat_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        items: List[Dict[str, Any]],
        source_error: str,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        state["chat_results"] = list(items or [])
        self._finalize_source_response(state, source_error)

    def _apply_contacts_source_response(self, state_key: int, request_token: int, query: str, response: Any, error: Any):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Contacts search failed")
            state["contacts_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["contacts_results"] = self._build_ranked_results(response, query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] contacts parse failed: {e}")
                state["contacts_results"] = []
                source_error = "Contacts parse failed"

        self._finalize_source_response(state, source_error)

    def _result_did(self, item: Dict[str, Any]) -> int:
        try:
            return int(item.get("did", 0) or 0)
        except Exception:
            return 0

    def _result_alt_key(self, item: Dict[str, Any]) -> str:
        username = self._normalize(str(item.get("username", "") or "").lstrip("@"))
        if username:
            return "u:" + username

        url = self._normalize(item.get("url", ""))
        if url:
            return "url:" + url

        title = self._normalize(item.get("title", ""))
        description = self._normalize(item.get("description", ""))
        if title or description:
            return "txt:" + title + "|" + description
        return ""

    def _merge_inline_results(self, existing: List[Dict[str, Any]], incoming: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        merged: Dict[str, Dict[str, Any]] = {}
        for item in self._java_list(existing):
            key = self._result_alt_key(item)
            if key:
                cached = dict(item)
                cached_sources = self._inline_sources_from_item(cached)
                if cached_sources:
                    cached["inline_sources"] = cached_sources
                    cached["inline_source"] = cached_sources[0]
                merged[key] = cached

        for item in self._java_list(incoming):
            key = self._result_alt_key(item)
            if not key:
                continue
            candidate = dict(item)
            candidate_sources = self._inline_sources_from_item(candidate)
            if candidate_sources:
                candidate["inline_sources"] = candidate_sources
                candidate["inline_source"] = candidate_sources[0]
            current = merged.get(key)
            if current is None:
                merged[key] = candidate
                continue

            current["score"] = max(int(current.get("score", 0)), int(candidate.get("score", 0)))
            current["verified"] = bool(current.get("verified", False) or candidate.get("verified", False))
            current["members"] = max(int(current.get("members", 0) or 0), int(candidate.get("members", 0) or 0))
            current["dialog_date"] = max(
                int(current.get("dialog_date", 0) or 0),
                int(candidate.get("dialog_date", 0) or 0),
            )
            if not str(current.get("description", "") or "").strip() and str(candidate.get("description", "") or "").strip():
                current["description"] = candidate.get("description", "")
            if not str(current.get("title", "") or "").strip() and str(candidate.get("title", "") or "").strip():
                current["title"] = candidate.get("title", "")
            if not str(current.get("username", "") or "").strip() and str(candidate.get("username", "") or "").strip():
                current["username"] = candidate.get("username", "")
            if not str(current.get("url", "") or "").strip() and str(candidate.get("url", "") or "").strip():
                current["url"] = candidate.get("url", "")
            self._merge_inline_item_sources(current, candidate)

        return list(merged.values())

    def _merge_source_results(self, existing: List[Dict[str, Any]], incoming: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        merged: Dict[int, Dict[str, Any]] = {}
        for item in self._java_list(existing):
            did = self._result_did(item)
            if did != 0:
                merged[did] = dict(item)

        for item in self._java_list(incoming):
            did = self._result_did(item)
            if did == 0:
                continue
            candidate = dict(item)
            current = merged.get(did)
            if current is None:
                merged[did] = candidate
                continue

            current["score"] = max(int(current.get("score", 0)), int(candidate.get("score", 0)))
            current["members"] = max(int(current.get("members", 0) or 0), int(candidate.get("members", 0) or 0))
            current["verified"] = bool(current.get("verified", False) or candidate.get("verified", False))
            current["dialog_date"] = max(
                int(current.get("dialog_date", 0) or 0),
                int(candidate.get("dialog_date", 0) or 0),
            )
            if not str(current.get("description", "") or "").strip() and str(candidate.get("description", "") or "").strip():
                current["description"] = candidate.get("description", "")
            if not str(current.get("username", "") or "").strip() and str(candidate.get("username", "") or "").strip():
                current["username"] = candidate.get("username", "")
            if str(current.get("kind", "")) == "user" and str(candidate.get("kind", "")) != "user":
                current["kind"] = candidate.get("kind", "")
                current["obj"] = candidate.get("obj")

        return list(merged.values())

    def _peer_to_did(self, peer: Any) -> int:
        if peer is None:
            return 0
        try:
            user_id = int(getattr(peer, "user_id", 0) or 0)
        except Exception:
            user_id = 0
        if user_id != 0:
            return user_id

        try:
            channel_id = int(getattr(peer, "channel_id", 0) or 0)
        except Exception:
            channel_id = 0
        if channel_id != 0:
            return -channel_id

        try:
            chat_id = int(getattr(peer, "chat_id", 0) or 0)
        except Exception:
            chat_id = 0
        if chat_id != 0:
            return -chat_id
        return 0

    def _input_peer_from_did(self, did: int):
        if int(did or 0) == 0:
            return None
        try:
            mc = get_messages_controller()
            if mc is None or not hasattr(mc, "getInputPeer"):
                return None
            peer = mc.getInputPeer(int(did))
            if peer is None:
                return None
            try:
                name = str(peer.getClass().getName() or "")
                if name.endswith("TL_inputPeerEmpty"):
                    return None
            except Exception:
                pass
            return peer
        except Exception:
            return None

    def _extract_response_cursor(self, response: Any) -> Optional[Dict[str, Any]]:
        messages = self._java_list(getattr(response, "messages", None))
        if not messages:
            return None

        last = messages[-1]
        offset_id = int(getattr(last, "id", 0) or 0)
        if offset_id <= 0:
            return None

        did = self._peer_to_did(getattr(last, "peer_id", None))
        offset_peer = self._input_peer_from_did(did)
        if offset_peer is None:
            return None

        return {
            "offset_rate": int(getattr(response, "next_rate", 0) or 0),
            "offset_id": offset_id,
            "offset_peer": offset_peer,
            "message_count": len(messages),
        }

    def _apply_global_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        response: Any,
        error: Any,
        page: int = 1,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Global search failed")
            if int(page) <= 1:
                state["global_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                parsed = self._build_global_ranked_results(response, query)
                if int(page) > 1:
                    state["global_results"] = self._merge_source_results(state.get("global_results", []), parsed)
                else:
                    state["global_results"] = parsed

                cursor = self._extract_response_cursor(response)
                can_page = (
                    int(page) < int(self._GLOBAL_MAX_PAGES)
                    and cursor is not None
                    and int(cursor.get("message_count", 0)) >= int(self._GLOBAL_REQUEST_LIMIT)
                )
                if can_page:
                    state["pending_sources"] = int(state.get("pending_sources", 0)) + 1
                    state["searching_more_sources"] = True
                    self._request_global_source(
                        state_key,
                        request_token,
                        query,
                        page=int(page) + 1,
                        offset_rate=int(cursor.get("offset_rate", 0) or 0),
                        offset_id=int(cursor.get("offset_id", 0) or 0),
                        offset_peer=cursor.get("offset_peer"),
                    )
            except Exception as e:
                self._safe_log(f"[ExploreSearch] global parse failed: {e}")
                if int(page) <= 1:
                    state["global_results"] = []
                source_error = "Global parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_hashtag_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        hashtag_query: str,
        response: Any,
        error: Any,
        page: int = 1,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Hashtag search failed")
            if int(page) <= 1:
                state["hashtag_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                parsed = self._build_global_ranked_results(response, hashtag_query)
                if int(page) > 1:
                    state["hashtag_results"] = self._merge_source_results(state.get("hashtag_results", []), parsed)
                else:
                    state["hashtag_results"] = parsed

                cursor = self._extract_response_cursor(response)
                can_page = (
                    int(page) < int(self._GLOBAL_MAX_PAGES)
                    and cursor is not None
                    and int(cursor.get("message_count", 0)) >= int(self._GLOBAL_REQUEST_LIMIT)
                )
                if can_page:
                    state["pending_sources"] = int(state.get("pending_sources", 0)) + 1
                    state["searching_more_sources"] = True
                    self._request_hashtag_source(
                        state_key,
                        request_token,
                        query,
                        hashtag_query,
                        page=int(page) + 1,
                        offset_rate=int(cursor.get("offset_rate", 0) or 0),
                        offset_id=int(cursor.get("offset_id", 0) or 0),
                        offset_peer=cursor.get("offset_peer"),
                    )
            except Exception as e:
                self._safe_log(f"[ExploreSearch] hashtag parse failed: {e}")
                if int(page) <= 1:
                    state["hashtag_results"] = []
                source_error = "Hashtag parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_resolve_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        username_query: str,
        response: Any,
        error: Any,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        source_error = ""
        if error is not None:
            source_error = self._error_text(error, "Resolve username failed")
            state["resolved_results"] = []
        else:
            self._cache_response_entities(response)
            try:
                state["resolved_results"] = self._build_resolve_ranked_results(response, query, username_query)
            except Exception as e:
                self._safe_log(f"[ExploreSearch] resolve parse failed: {e}")
                state["resolved_results"] = []
                source_error = "Resolve parse failed"

        self._finalize_source_response(state, source_error)

    def _apply_inline_source_response(
        self,
        state_key: int,
        request_token: int,
        query: str,
        bot_username: str,
        response: Any,
        error: Any,
        page: int = 1,
    ):
        state = self._states.get(state_key)
        if state is None or self._is_stale_source_response(state, request_token, query):
            return

        bot_username = self._normalize_inline_bot_username(bot_username)
        source_error = ""
        if error is not None:
            source_error = self._error_text(error, f"Inline bot @{bot_username} search failed")
        else:
            self._cache_response_entities(response)
            try:
                parsed = self._build_inline_ranked_results(response, query)
                for inline_item in parsed:
                    self._mark_inline_item_source(inline_item, bot_username)
                existing_inline = list(state.get("inline_results", []) or [])
                if int(page) > 1 or existing_inline:
                    state["inline_results"] = self._merge_inline_results(existing_inline, parsed)
                else:
                    state["inline_results"] = parsed

                next_offset = str(getattr(response, "next_offset", "") or "")
                can_page = bool(
                    int(page) < int(self._INLINE_MAX_PAGES)
                    and next_offset
                )
                if can_page:
                    state["pending_sources"] = int(state.get("pending_sources", 0)) + 1
                    state["searching_more_sources"] = True
                    self._request_inline_source(
                        state_key,
                        request_token,
                        query,
                        bot_username=bot_username,
                        page=int(page) + 1,
                        offset=next_offset,
                    )
            except Exception as e:
                self._safe_log(f"[ExploreSearch] inline parse failed: {e}")
                source_error = f"Inline parse failed (@{bot_username})"

        self._finalize_source_response(state, source_error)

    def _is_stale_source_response(self, state: Dict[str, Any], request_token: int, query: str) -> bool:
        if int(state.get("request_token", 0)) != int(request_token):
            return True
        current_query = str(state.get("query", "") or "").strip()
        return self._normalize(current_query) != self._normalize(query)

    def _finalize_source_response(self, state: Dict[str, Any], source_error: str):
        if source_error:
            errors = state.get("source_errors")
            if isinstance(errors, list):
                errors.append(source_error)
            else:
                state["source_errors"] = [source_error]

        pending = max(0, int(state.get("pending_sources", 0)) - 1)
        state["pending_sources"] = pending
        state["all_results"] = self._merge_collected_results(state)

        has_items = bool(state.get("all_results"))
        state["loading"] = bool(pending > 0 and not has_items)
        state["searching_more_sources"] = bool(pending > 0)

        if pending == 0:
            state["active_request_ids"] = []
            if has_items:
                state["error"] = ""
            else:
                errors = state.get("source_errors", [])
                state["error"] = str(errors[0]) if errors else ""

        self._render_results(state, animate=True)

    def _merge_collected_results(self, state: Dict[str, Any]) -> List[Dict[str, Any]]:
        current_tab = str(state.get("tab", "all"))
        inline_boost = 18 if self._is_inline_tab(current_tab) else 8
        chat_boost = 36 if current_tab == self._CHAT_TAB else 12
        merged: Dict[int, Dict[str, Any]] = {}
        merged_alt: Dict[str, Dict[str, Any]] = {}
        source_specs = [
            ("local_results", 27),
            ("resolved_results", 22),
            ("chat_results", chat_boost),
            ("hashtag_results", 13),
            ("contacts_results", 9),
            ("global_results", 6),
        ]
        if current_tab != self._CHAT_TAB:
            source_specs.insert(2, ("inline_results", inline_boost))

        for source_name, source_boost in source_specs:
            for item in self._java_list(state.get(source_name, [])):
                candidate = dict(item)
                candidate["score"] = int(candidate.get("score", 0)) + int(source_boost)
                candidate_inline_sources = self._inline_sources_from_item(candidate)
                if candidate_inline_sources:
                    candidate["inline_sources"] = candidate_inline_sources
                    candidate["inline_source"] = candidate_inline_sources[0]
                did = int(candidate.get("did", 0) or 0)
                if did == 0:
                    alt_key = self._result_alt_key(candidate)
                    if not alt_key:
                        continue
                    existing = merged_alt.get(alt_key)
                    if existing is None:
                        candidate["_sources"] = 1
                        merged_alt[alt_key] = candidate
                        continue

                    existing["score"] = max(int(existing.get("score", 0)), int(candidate.get("score", 0))) + 6
                    existing["_sources"] = int(existing.get("_sources", 1)) + 1
                    existing["verified"] = bool(existing.get("verified", False) or candidate.get("verified", False))
                    existing["members"] = max(int(existing.get("members", 0) or 0), int(candidate.get("members", 0) or 0))
                    existing["dialog_date"] = max(
                        int(existing.get("dialog_date", 0) or 0),
                        int(candidate.get("dialog_date", 0) or 0),
                    )
                    if not str(existing.get("description", "") or "").strip() and str(candidate.get("description", "") or "").strip():
                        existing["description"] = candidate.get("description", "")
                    if not str(existing.get("username", "") or "").strip() and str(candidate.get("username", "") or "").strip():
                        existing["username"] = candidate.get("username", "")
                    if not str(existing.get("title", "") or "").strip() and str(candidate.get("title", "") or "").strip():
                        existing["title"] = candidate.get("title", "")
                    if not str(existing.get("url", "") or "").strip() and str(candidate.get("url", "") or "").strip():
                        existing["url"] = candidate.get("url", "")
                    if bool(candidate.get("local_hit", False)):
                        existing["local_hit"] = True
                    self._merge_inline_item_sources(existing, candidate)
                    continue

                existing = merged.get(did)
                if existing is None:
                    candidate["_sources"] = 1
                    merged[did] = candidate
                    continue

                existing["score"] = max(int(existing.get("score", 0)), int(candidate.get("score", 0))) + 6
                existing["_sources"] = int(existing.get("_sources", 1)) + 1
                existing["verified"] = bool(existing.get("verified", False) or candidate.get("verified", False))
                existing["members"] = max(int(existing.get("members", 0) or 0), int(candidate.get("members", 0) or 0))
                existing["dialog_date"] = max(
                    int(existing.get("dialog_date", 0) or 0),
                    int(candidate.get("dialog_date", 0) or 0),
                )
                if not str(existing.get("description", "") or "").strip() and str(candidate.get("description", "") or "").strip():
                    existing["description"] = candidate.get("description", "")
                if not str(existing.get("username", "") or "").strip() and str(candidate.get("username", "") or "").strip():
                    existing["username"] = candidate.get("username", "")
                if str(existing.get("kind", "")) == "user" and str(candidate.get("kind", "")) != "user":
                    existing["kind"] = candidate.get("kind", "")
                    existing["obj"] = candidate.get("obj")
                if bool(candidate.get("local_hit", False)):
                    existing["local_hit"] = True
                self._merge_inline_item_sources(existing, candidate)

        out = list(merged.values()) + list(merged_alt.values())
        for item in out:
            sources = max(1, int(item.pop("_sources", 1)))
            if sources > 1:
                item["score"] = int(item.get("score", 0)) + (sources - 1) * 7
            if bool(item.get("local_hit", False)):
                item["score"] = int(item.get("score", 0)) + 8

        out.sort(
            key=lambda it: (
                -int(it.get("score", 0)),
                -int(it.get("dialog_date", 0) or 0),
                -int(it.get("members", 0)),
                self._normalize(it.get("title", "")),
            )
        )
        return out

    def _extract_username_query(self, query: str) -> str:
        text = str(query or "").strip()
        if not text:
            return ""

        lower = text.lower()
        candidate = ""
        if text.startswith("@"):
            candidate = text[1:]
        elif "t.me/" in lower:
            idx = lower.find("t.me/")
            candidate = text[idx + 5 :]
        elif "telegram.me/" in lower:
            idx = lower.find("telegram.me/")
            candidate = text[idx + 11 :]
        else:
            return ""

        candidate = candidate.strip().lstrip("@")
        for sep in ("/", "?", "#", " "):
            if sep in candidate:
                candidate = candidate.split(sep, 1)[0]

        clean_chars = []
        for ch in candidate:
            if ch.isalnum() or ch == "_":
                clean_chars.append(ch)
            else:
                break
        username = "".join(clean_chars)
        if len(username) < 3:
            return ""
        return username

    def _extract_hashtag_query(self, query: str) -> str:
        text = str(query or "").strip()
        if len(text) < 2:
            return ""

        token = text.split(" ", 1)[0].strip()
        if len(token) < 2 or token[0] not in ("#", "$"):
            return ""

        prefix = token[0]
        body = token[1:]
        if not body:
            return ""

        username = ""
        if "@" in body:
            body, raw_username = body.split("@", 1)
            clean_username = []
            for ch in raw_username:
                if ch.isalnum() or ch == "_":
                    clean_username.append(ch)
                else:
                    break
            username = "".join(clean_username)
            if len(username) < 3:
                return ""

        clean_tag = []
        for ch in body:
            if ch.isalnum() or ch == "_":
                clean_tag.append(ch)
            else:
                break

        tag = "".join(clean_tag)
        if len(tag) < 2:
            return ""

        if username:
            return f"{prefix}{tag}@{username}"
        return f"{prefix}{tag}"

    def _build_local_ranked_results(self, local_objects: Any, query: str) -> List[Dict[str, Any]]:
        out: List[Dict[str, Any]] = []
        seen = set()

        for obj in self._java_list(local_objects):
            item = self._local_object_to_item(obj)
            if item is None:
                continue
            did = int(item.get("did", 0) or 0)
            if did == 0 or did in seen:
                continue
            seen.add(did)
            out.append(item)
            if len(out) >= int(self._LOCAL_RESULT_LIMIT):
                break

        q = self._normalize(query)
        q_t = self._translit(q)
        for item in out:
            item["score"] = int(item.get("score", 0)) + self._rank_item(item, q, q_t) + 14
            item["local_hit"] = True

        out.sort(
            key=lambda it: (
                -int(it.get("score", 0)),
                -int(it.get("dialog_date", 0) or 0),
                -int(it.get("members", 0)),
                self._normalize(it.get("title", "")),
            )
        )
        return out

    def _local_object_to_item(self, obj: Any) -> Optional[Dict[str, Any]]:
        if obj is None:
            return None
        try:
            class_name = str(obj.getClass().getName() or "")
        except Exception:
            class_name = ""

        if "EncryptedChat" in class_name:
            return None

        if hasattr(obj, "bot") and hasattr(obj, "id"):
            try:
                user_id = int(getattr(obj, "id", 0) or 0)
            except Exception:
                user_id = 0
            if user_id <= 0:
                return None
            try:
                title = str(UserObject.getUserName(obj) or "")
            except Exception:
                first = str(getattr(obj, "first_name", "") or "")
                last = str(getattr(obj, "last_name", "") or "")
                title = (first + " " + last).strip()
            username = str(getattr(obj, "username", "") or "")
            return {
                "did": int(user_id),
                "kind": "bot" if bool(getattr(obj, "bot", False)) else "user",
                "title": title,
                "username": username,
                "verified": bool(getattr(obj, "verified", False)),
                "members": 0,
                "description": "",
                "obj": obj,
                "score": 0,
                "dialog_date": self._dialog_last_date(int(user_id)),
            }

        if hasattr(obj, "title") and hasattr(obj, "id"):
            try:
                chat_id = int(getattr(obj, "id", 0) or 0)
            except Exception:
                chat_id = 0
            if chat_id <= 0:
                return None
            try:
                is_channel = bool(ChatObject.isChannelAndNotMegaGroup(obj))
            except Exception:
                is_channel = bool(getattr(obj, "broadcast", False))

            username = str(getattr(obj, "username", "") or "")
            description = ""
            try:
                description = str(getattr(obj, "about", "") or "")
            except Exception:
                description = ""
            if not description and username:
                description = "@" + username

            did = -int(chat_id)
            return {
                "did": did,
                "kind": "channel" if is_channel else "group",
                "title": str(getattr(obj, "title", "") or ""),
                "username": username,
                "verified": bool(getattr(obj, "verified", False)),
                "members": int(getattr(obj, "participants_count", 0) or 0),
                "description": description,
                "obj": obj,
                "score": 0,
                "dialog_date": self._dialog_last_date(did),
            }
        return None

    def _build_ranked_results(self, response: Any, query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        out: List[Dict[str, Any]] = []
        seen = set()

        for source, boost in (("my_results", 8), ("results", 0)):
            for peer in self._java_list(getattr(response, source, None)):
                item = self._peer_to_item(peer, users_map, chats_map)
                if item is None:
                    continue
                did = int(item.get("did", 0))
                if did == 0 or did in seen:
                    continue
                seen.add(did)
                item["score"] = int(item.get("score", 0)) + int(boost)
                out.append(item)

        q = self._normalize(query)
        q_t = self._translit(q)
        for item in out:
            item["score"] = int(item.get("score", 0)) + self._rank_item(item, q, q_t)

        out.sort(
            key=lambda it: (
                -int(it.get("score", 0)),
                -int(it.get("dialog_date", 0) or 0),
                -int(it.get("members", 0)),
                self._normalize(it.get("title", "")),
            )
        )
        return out

    def _build_global_ranked_results(self, response: Any, query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        messages = self._java_list(getattr(response, "messages", None))
        grouped: Dict[int, Dict[str, Any]] = {}
        for idx, msg in enumerate(messages):
            try:
                peer = getattr(msg, "peer_id", None)
            except Exception:
                peer = None
            item = self._peer_to_item(peer, users_map, chats_map)
            if item is None:
                continue

            did = int(item.get("did", 0) or 0)
            if did == 0:
                continue

            snippet = self._extract_message_snippet(msg)
            entry = grouped.get(did)
            if entry is None:
                grouped[did] = {
                    "item": item,
                    "hits": 1,
                    "best_idx": idx,
                    "snippet": snippet,
                    "recent_date": int(getattr(msg, "date", 0) or 0),
                }
            else:
                entry["hits"] = int(entry.get("hits", 0)) + 1
                if idx < int(entry.get("best_idx", idx)):
                    entry["best_idx"] = idx
                if not str(entry.get("snippet", "") or "") and snippet:
                    entry["snippet"] = snippet
                entry["recent_date"] = max(
                    int(entry.get("recent_date", 0) or 0),
                    int(getattr(msg, "date", 0) or 0),
                )

        out: List[Dict[str, Any]] = []
        q = self._normalize(query)
        q_t = self._translit(q)
        for entry in grouped.values():
            item = dict(entry.get("item", {}))
            snippet = str(entry.get("snippet", "") or "")
            if snippet:
                description = str(item.get("description", "") or "")
                if not description or description.startswith("@"):
                    item["description"] = snippet

            hits = int(entry.get("hits", 0) or 0)
            best_idx = int(entry.get("best_idx", 0) or 0)
            item["dialog_date"] = max(
                int(item.get("dialog_date", 0) or 0),
                int(entry.get("recent_date", 0) or 0),
            )
            score = self._rank_item(item, q, q_t)
            score += 12 + min(34, hits * 6)
            score += max(0, 14 - min(14, best_idx))
            item["score"] = int(item.get("score", 0)) + score
            out.append(item)

        out.sort(
            key=lambda it: (
                -int(it.get("score", 0)),
                -int(it.get("dialog_date", 0) or 0),
                -int(it.get("members", 0)),
                self._normalize(it.get("title", "")),
            )
        )
        return out

    def _build_inline_ranked_results(self, response: Any, query: str) -> List[Dict[str, Any]]:
        out: List[Dict[str, Any]] = []
        seen = set()
        q = self._normalize(query)
        q_t = self._translit(q)

        for result in self._java_list(getattr(response, "results", None)):
            item = self._inline_result_to_item(result)
            if item is None:
                continue
            key = self._result_alt_key(item)
            if not key or key in seen:
                continue
            seen.add(key)

            score = self._rank_item(item, q, q_t) + 28
            username = self._normalize(item.get("username", ""))
            if username and q:
                if username == q:
                    score += 34
                elif username.startswith(q):
                    score += 20
            item["score"] = int(item.get("score", 0)) + score
            out.append(item)

        out.sort(
            key=lambda it: (
                -int(it.get("score", 0)),
                self._normalize(it.get("title", "")),
            )
        )
        return out

    def _inline_result_to_item(self, result: Any) -> Optional[Dict[str, Any]]:
        if result is None:
            return None

        title = str(getattr(result, "title", "") or "").strip()
        description = str(getattr(result, "description", "") or "").strip()
        url = str(getattr(result, "url", "") or "").strip()
        send_message = getattr(result, "send_message", None)
        message = str(getattr(send_message, "message", "") or "").strip() if send_message is not None else ""
        entities = getattr(send_message, "entities", None) if send_message is not None else None

        username = self._extract_username_from_url(url)
        if not username:
            username = self._extract_username_from_entities(message, entities)
        if not username:
            username = self._extract_username_from_text(message)
        if not username:
            username = self._extract_username_from_text(title)
        if not username:
            username = self._extract_username_from_text(description)
        if not username:
            return None

        if not title:
            title = "@" + username
        if not description:
            snippet = " ".join(str(message or "").replace("\n", " ").replace("\r", " ").split())
            if snippet:
                description = snippet[:117] + "..." if len(snippet) > 120 else snippet
            else:
                description = "Inline channel result"

        return {
            "did": 0,
            "kind": "channel",
            "title": title,
            "username": username,
            "verified": False,
            "members": 0,
            "description": description,
            "url": url,
            "obj": result,
            "score": 0,
            "dialog_date": 0,
        }

    def _extract_entity_substring(self, message: str, entity: Any) -> str:
        text = str(message or "")
        if not text or entity is None:
            return ""
        try:
            offset = int(getattr(entity, "offset", 0) or 0)
            length = int(getattr(entity, "length", 0) or 0)
        except Exception:
            return ""
        if offset < 0 or length <= 0:
            return ""
        end = min(len(text), offset + length)
        if end <= offset:
            return ""
        try:
            return text[offset:end]
        except Exception:
            return ""

    def _extract_username_from_entities(self, message: str, entities: Any) -> str:
        for entity in self._java_list(entities):
            if entity is None:
                continue
            try:
                class_name = str(entity.getClass().getName() or "")
            except Exception:
                class_name = ""
            part = self._extract_entity_substring(message, entity)

            if class_name.endswith("TL_messageEntityTextUrl"):
                username = self._extract_username_from_url(str(getattr(entity, "url", "") or ""))
                if username:
                    return username
                username = self._extract_username_from_text(part)
                if username:
                    return username
                continue

            if class_name.endswith("TL_messageEntityUrl"):
                username = self._extract_username_from_url(part)
                if username:
                    return username
                continue

            if class_name.endswith("TL_messageEntityMention"):
                username = self._extract_username_from_text(part)
                if username:
                    return username
                continue
        return ""

    def _clean_username_candidate(self, value: str) -> str:
        username = str(value or "").strip().lstrip("@")
        if not username:
            return ""

        clean_chars = []
        for ch in username:
            if ch.isalnum() or ch == "_":
                clean_chars.append(ch)
            else:
                break
        username = "".join(clean_chars)
        if len(username) < 3:
            return ""
        if not any(ch.isalpha() for ch in username):
            return ""

        reserved = {
            "joinchat",
            "addlist",
            "addstickers",
            "share",
            "iv",
            "s",
            "c",
        }
        if username.lower() in reserved:
            return ""
        return username

    def _extract_username_from_url(self, url: str) -> str:
        text = str(url or "").strip()
        if not text:
            return ""
        if text.startswith("@"):
            username = self._clean_username_candidate(text[1:])
            if username:
                return username
        if " " not in text and "/" not in text and ":" not in text and "@" not in text:
            username = self._clean_username_candidate(text)
            if username:
                return username

        match = re.search(
            r"(?:https?://)?(?:t\.me|telegram\.me|telegram\.dog)/(?:(?:s|c)/)?([A-Za-z0-9_]{3,})",
            text,
            flags=re.IGNORECASE,
        )
        if match:
            return self._clean_username_candidate(match.group(1))
        return ""

    def _extract_username_from_text(self, text: str) -> str:
        value = str(text or "")
        if not value:
            return ""
        username = self._extract_username_from_url(value)
        if username:
            return username

        match = re.search(r"@([A-Za-z0-9_]{3,})", value)
        if match:
            return self._clean_username_candidate(match.group(1))
        return ""

    def _build_resolve_ranked_results(self, response: Any, query: str, username_query: str) -> List[Dict[str, Any]]:
        users_map: Dict[int, Any] = {}
        chats_map: Dict[int, Any] = {}

        for user in self._java_list(getattr(response, "users", None)):
            try:
                users_map[int(user.id)] = user
            except Exception:
                pass
        for chat in self._java_list(getattr(response, "chats", None)):
            try:
                chats_map[int(chat.id)] = chat
            except Exception:
                pass

        peer = getattr(response, "peer", None)
        item = self._peer_to_item(peer, users_map, chats_map)
        if item is None:
            return []

        q = self._normalize(query)
        q_t = self._translit(q)
        score = self._rank_item(item, q, q_t) + 110

        uname = self._normalize(item.get("username", ""))
        wanted = self._normalize(username_query)
        if uname and wanted and uname == wanted:
            score += 55

        item["score"] = int(item.get("score", 0)) + score
        return [item]

    def _extract_message_snippet(self, message: Any) -> str:
        text = ""
        try:
            text = str(getattr(message, "message", "") or "")
        except Exception:
            text = ""
        text = " ".join(text.replace("\n", " ").replace("\r", " ").split())
        if not text:
            return ""
        if len(text) > 120:
            return text[:117] + "..."
        return text

    def _error_text(self, error: Any, fallback: str) -> str:
        if error is None:
            return fallback
        try:
            text = str(error.text or "")
        except Exception:
            text = ""
        if not text:
            try:
                text = str(error)
            except Exception:
                text = ""
        text = text.strip()
        return text or fallback

    def _cache_response_entities(self, response: Any):
        if response is None:
            return
        mc = get_messages_controller()
        if mc is None:
            return

        try:
            users = getattr(response, "users", None)
            if users is not None and hasattr(mc, "putUsers"):
                mc.putUsers(users, False)
        except Exception:
            pass

        try:
            chats = getattr(response, "chats", None)
            if chats is not None and hasattr(mc, "putChats"):
                mc.putChats(chats, False)
        except Exception:
            pass

    def _dialog_last_date(self, did: int) -> int:
        dialog_id = int(did or 0)
        if dialog_id == 0:
            return 0
        try:
            mc = get_messages_controller()
            if mc is None:
                return 0
            dialogs_dict = getattr(mc, "dialogs_dict", None)
            if dialogs_dict is None or not hasattr(dialogs_dict, "get"):
                return 0
            dialog = dialogs_dict.get(dialog_id)
            if dialog is None:
                return 0
            return int(getattr(dialog, "last_message_date", 0) or 0)
        except Exception:
            return 0

    def _peer_to_item(self, peer: Any, users_map: Dict[int, Any], chats_map: Dict[int, Any]) -> Optional[Dict[str, Any]]:
        if peer is None:
            return None

        try:
            user_id = int(getattr(peer, "user_id", 0) or 0)
        except Exception:
            user_id = 0

        if user_id != 0:
            user = users_map.get(user_id)
            if user is None:
                return None

            try:
                title = str(UserObject.getUserName(user) or "")
            except Exception:
                first = str(getattr(user, "first_name", "") or "")
                last = str(getattr(user, "last_name", "") or "")
                title = (first + " " + last).strip()

            username = str(getattr(user, "username", "") or "")
            return {
                "did": int(user_id),
                "kind": "bot" if bool(getattr(user, "bot", False)) else "user",
                "title": title,
                "username": username,
                "verified": bool(getattr(user, "verified", False)),
                "members": 0,
                "description": "",
                "obj": user,
                "score": 0,
                "dialog_date": self._dialog_last_date(int(user_id)),
            }

        chat_id = 0
        try:
            chat_id = int(getattr(peer, "channel_id", 0) or 0)
        except Exception:
            chat_id = 0
        if chat_id == 0:
            try:
                chat_id = int(getattr(peer, "chat_id", 0) or 0)
            except Exception:
                chat_id = 0
        if chat_id == 0:
            return None

        chat = chats_map.get(chat_id)
        if chat is None:
            return None

        try:
            is_channel = bool(ChatObject.isChannelAndNotMegaGroup(chat))
        except Exception:
            is_channel = bool(getattr(chat, "broadcast", False))

        username = str(getattr(chat, "username", "") or "")
        description = ""
        try:
            description = str(getattr(chat, "about", "") or "")
        except Exception:
            description = ""
        if not description and username:
            description = "@" + username

        return {
            "did": -int(chat_id),
            "kind": "channel" if is_channel else "group",
            "title": str(getattr(chat, "title", "") or ""),
            "username": username,
            "verified": bool(getattr(chat, "verified", False)),
            "members": int(getattr(chat, "participants_count", 0) or 0),
            "description": description,
            "obj": chat,
            "score": 0,
            "dialog_date": self._dialog_last_date(-int(chat_id)),
        }

    def _rank_item(self, item: Dict[str, Any], query: str, query_t: str) -> int:
        score = 0
        title = self._normalize(item.get("title", ""))
        username = self._normalize(item.get("username", ""))
        description = self._normalize(item.get("description", ""))

        score += self._match_score(title, query, 95, 62, 42)
        score += self._match_score(username, query, 74, 52, 34)
        score += self._match_score(description, query, 22, 12, 8)

        if query_t and query_t != query:
            score += self._match_score(self._translit(title), query_t, 40, 24, 14)
            score += self._match_score(self._translit(username), query_t, 26, 15, 10)

        tokens = self._query_tokens(query)
        if len(tokens) > 1:
            covered = 0
            for token in tokens[:5]:
                token_score = 0
                token_score += self._match_score(title, token, 30, 20, 12)
                token_score += self._match_score(username, token, 20, 14, 9)
                token_score += self._match_score(description, token, 12, 8, 5)
                if token_score > 0:
                    covered += 1
                score += min(20, int(token_score / 4))
            if covered >= min(len(tokens), 5):
                score += 16

        if bool(item.get("verified", False)):
            score += 7

        members = int(item.get("members", 0) or 0)
        if members > 0:
            score += min(26, int(math.log10(members + 10) * 10))

        kind = str(item.get("kind", ""))
        if kind == "channel":
            score += 6
        elif kind == "group":
            score += 5
        elif kind == "bot":
            score += 4

        score += self._dialog_date_boost(int(item.get("dialog_date", 0) or 0))

        return score

    def _dialog_date_boost(self, dialog_date: int) -> int:
        date_value = int(dialog_date or 0)
        if date_value <= 0:
            return 0

        now_sec = int(self._now_ms() / 1000)
        if now_sec <= 0:
            return 0
        age = max(0, now_sec - date_value)
        if age <= 86400:
            return 28
        if age <= 7 * 86400:
            return 20
        if age <= 30 * 86400:
            return 13
        if age <= 180 * 86400:
            return 8
        return 3

    def _match_score(self, text: str, query: str, exact_prefix: int, mid_word: int, anywhere: int) -> int:
        if not text or not query:
            return 0
        if text == query:
            return exact_prefix + 18
        if text.startswith(query):
            return exact_prefix
        idx = text.find(query)
        if idx < 0:
            return 0
        if idx > 0 and text[idx - 1] in (" ", "_", "-", "."):
            return mid_word
        return anywhere

    def _query_tokens(self, query: str) -> List[str]:
        tokens = []
        seen = set()
        for token in self._normalize(query).split(" "):
            if len(token) < 2:
                continue
            if token in seen:
                continue
            seen.add(token)
            tokens.append(token)
        return tokens


    def _apply_filters(self, state: Dict[str, Any]) -> List[Dict[str, Any]]:
        tab = str(state.get("tab", "all"))
        verified_only = bool(state.get("verified_only", False))
        items = list(state.get("all_results", []))

        out = []
        inline_source_for_tab = self._inline_source_key(self._inline_bot_for_tab(tab))
        for item in items:
            kind = str(item.get("kind", ""))
            if tab == self._CHAT_TAB and kind not in ("channel", "group", "bot", "user"):
                continue
            if tab == self._CHAT_TAB and self._inline_sources_from_item(item):
                continue
            if tab == "channels" and kind != "channel":
                continue
            if tab == "groups" and kind != "group":
                continue
            if tab == "bots" and kind != "bot":
                continue
            if self._is_inline_tab(tab):
                if kind not in ("channel", "group", "bot", "user"):
                    continue
                if tab != self._INLINE_TAB_ALL and not self._item_has_inline_source(item, inline_source_for_tab):
                    continue
            if verified_only and not bool(item.get("verified", False)):
                continue
            out.append(item)
        return out

    def _reset_status_state(self, state: Dict[str, Any]):
        state["status_mode"] = ""
        state["status_shell"] = None
        state["status_title_view"] = None
        state["status_subtitle_view"] = None
        state["status_lottie_view"] = None
        state["status_sticker_view"] = None

    def _clear_results_container(self, state: Dict[str, Any], container: Any) -> bool:
        try:
            container.removeAllViews()
        except Exception:
            return False
        self._reset_status_state(state)
        return True

    def _try_reuse_status(self, state: Dict[str, Any], container: Any, mode: str, title: str, subtitle: str) -> bool:
        shell = state.get("status_shell")
        if shell is None:
            return False
        if str(state.get("status_mode", "")) != str(mode):
            return False
        try:
            if shell.getParent() is not container:
                return False
        except Exception:
            return False

        title_view = state.get("status_title_view")
        subtitle_view = state.get("status_subtitle_view")
        if title_view is not None:
            try:
                title_view.setText(title)
            except Exception:
                pass
        if subtitle_view is not None:
            try:
                subtitle_view.setText(subtitle)
            except Exception:
                pass

        if str(mode) == "loading":
            lottie_view = state.get("status_lottie_view")
            if lottie_view is not None and hasattr(lottie_view, "playAnimation"):
                try:
                    lottie_view.playAnimation()
                except Exception:
                    pass
        if str(mode) == "empty":
            self._bind_no_results_sticker_view(state.get("status_sticker_view"))
            self._ensure_no_results_sticker_loaded()
        return True

    def _render_results(self, state: Dict[str, Any], animate: bool):
        container = state.get("results_container")
        if container is None:
            return

        query = str(state.get("query", "") or "").strip()
        error = str(state.get("error", "") or "")
        loading = bool(state.get("loading", False))
        tab = str(state.get("tab", "all"))

        if loading:
            title = "Searching"
            if self._is_inline_tab(tab):
                subtitle = f"Looking via {self._inline_label_for_tab(tab)}."
            elif tab == self._CHAT_TAB:
                subtitle = "Searching in each dialog and collecting matches."
            else:
                subtitle = "Looking for channels, groups, bots and hashtag posts."
            if self._try_reuse_status(state, container, mode="loading", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(
                state,
                container,
                title,
                subtitle,
                mode="loading",
            )
            return
        if error:
            if self._try_reuse_status(state, container, mode="error", title="Search error", subtitle=error):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(state, container, "Search error", error, mode="error")
            return
        if not query:
            title = "Type your query"
            if self._is_inline_tab(tab):
                subtitle = f"Search via {self._inline_label_for_tab(tab)} inline results."
            elif tab == self._CHAT_TAB:
                subtitle = "Search messages across your dialogs by keyword."
            else:
                subtitle = "Search all chats, groups, channels and bots."
            if self._try_reuse_status(state, container, mode="idle", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(
                state,
                container,
                title,
                subtitle,
                mode="idle",
            )
            return

        filtered = self._apply_filters(state)
        state["filtered_results"] = filtered
        if not filtered:
            title = "No results"
            subtitle = "Try another query or disable filters."
            if self._try_reuse_status(state, container, mode="empty", title=title, subtitle=subtitle):
                return
            if not self._clear_results_container(state, container):
                return
            self._add_status(state, container, "No results", "Try another query or disable filters.", mode="empty")
            return

        if not self._clear_results_container(state, container):
            return
        summary = TextView(container.getContext())
        if self._is_inline_tab(tab):
            summary_text = f"Found {len(filtered)} results from {self._inline_label_for_tab(tab)}"
        elif tab == self._CHAT_TAB:
            summary_text = f"Found {len(filtered)} results in dialogs"
        else:
            summary_text = f"Found {len(filtered)} results"
        if bool(state.get("searching_more_sources", False)):
            summary_text += " | searching deeper..."
        summary.setText(summary_text)
        summary.setTextColor(self._color(self._palette()["text_soft"]))
        summary.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        summary_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        summary_lp.bottomMargin = AndroidUtilities.dp(8)
        container.addView(summary, summary_lp)

        max_items = min(len(filtered), 80)
        for i in range(max_items):
            item = filtered[i]
            card = self._create_card(state, item)
            lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            lp.bottomMargin = AndroidUtilities.dp(10)
            container.addView(card, lp)
            if animate:
                try:
                    card.setAlpha(0.0)
                    card.setTranslationY(AndroidUtilities.dp(10))
                    card.animate().alpha(1.0).translationY(0).setDuration(180).setStartDelay(min(260, i * 16)).start()
                except Exception:
                    pass

    def _add_status(self, state: Dict[str, Any], container: Any, title: str, subtitle: str, mode: str = "info"):
        context = container.getContext()
        p = self._palette()
        loading_mode = mode == "loading"
        style = self._status_style_profile(mode, p)

        shell = LinearLayout(context)
        shell.setOrientation(LinearLayout.VERTICAL)
        shell.setGravity(Gravity.CENTER_HORIZONTAL)
        shell.setPadding(
            AndroidUtilities.dp(int(style.get("padding_h", 14))),
            AndroidUtilities.dp(int(style.get("padding_top", 12))),
            AndroidUtilities.dp(int(style.get("padding_h", 14))),
            AndroidUtilities.dp(int(style.get("padding_bottom", 12))),
        )
        shell_bg = GradientDrawable()
        shell_bg.setCornerRadius(AndroidUtilities.dp(int(style.get("radius", 16))))
        shell_bg.setColor(self._color(int(style.get("bg", p["status_bg_soft"]))))
        shell_bg.setStroke(AndroidUtilities.dp(1), self._color(int(style.get("stroke", p["status_stroke"]))))
        shell.setBackground(shell_bg)
        try:
            shell.setElevation(float(AndroidUtilities.dp(int(style.get("elevation", 2)))))
        except Exception:
            pass

        accent = View(context)
        accent_bg = GradientDrawable()
        accent_bg.setCornerRadius(AndroidUtilities.dp(2))
        accent_bg.setColor(self._color(int(style.get("accent", p["accent"]))))
        accent.setBackground(accent_bg)
        accent_lp = LinearLayout.LayoutParams(
            AndroidUtilities.dp(int(style.get("accent_width", 24))),
            AndroidUtilities.dp(int(style.get("accent_height", 3))),
        )
        accent_lp.bottomMargin = AndroidUtilities.dp(int(style.get("accent_margin_bottom", 8)))
        shell.addView(accent, accent_lp)

        header = LinearLayout(context)
        header.setOrientation(LinearLayout.HORIZONTAL)
        header.setGravity(Gravity.CENTER)
        shell.addView(header, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        icon_view = self._create_loading_lottie_icon(context, p) if loading_mode else None
        if icon_view is None:
            icon_view = ImageView(context)
            try:
                icon_res = self._status_icon_res(mode)
                if icon_res is not None:
                    icon_view.setImageResource(icon_res)
                else:
                    icon_view.setImageResource(R.drawable.msg_search)
            except Exception:
                icon_view.setImageResource(R.drawable.msg_search)
        try:
            icon_view.setColorFilter(self._color(int(style.get("icon_tint", p["status_icon_tint"]))))
        except Exception:
            pass
        try:
            icon_view.setAlpha(float(style.get("icon_alpha", 0.9)))
        except Exception:
            pass
        icon_size = AndroidUtilities.dp(int(style.get("icon_size", 20)))
        icon_lp = LinearLayout.LayoutParams(icon_size, icon_size)
        icon_lp.rightMargin = AndroidUtilities.dp(int(style.get("icon_margin", 8)))
        header.addView(icon_view, icon_lp)

        t = TextView(context)
        t.setText(title)
        t.setTextColor(self._color(int(style.get("title_color", p["text_soft"]))))
        t.setTypeface(Typeface.DEFAULT_BOLD if bool(style.get("title_bold", False)) else Typeface.DEFAULT)
        t.setTextSize(TypedValue.COMPLEX_UNIT_DIP, int(style.get("title_size", 17)))
        t.setGravity(Gravity.CENTER_HORIZONTAL)
        header.addView(t, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        s = TextView(context)
        s.setText(subtitle)
        s.setTextColor(self._color(int(style.get("subtitle_color", p["status_subtitle"]))))
        s.setTextSize(TypedValue.COMPLEX_UNIT_DIP, int(style.get("subtitle_size", 13)))
        s.setGravity(Gravity.CENTER_HORIZONTAL)
        try:
            s.setMaxWidth(AndroidUtilities.dp(int(style.get("subtitle_max_width", 320))))
        except Exception:
            pass
        slp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        slp.topMargin = AndroidUtilities.dp(int(style.get("subtitle_margin_top", 6)))
        shell.addView(s, slp)

        sticker_view = None
        if str(mode) == "empty":
            sticker_view = BackupImageView(context)
            try:
                sticker_view.setRoundRadius(AndroidUtilities.dp(10))
            except Exception:
                pass
            try:
                if hasattr(sticker_view, "setAspectFit"):
                    sticker_view.setAspectFit(True)
            except Exception:
                pass
            sticker_size = AndroidUtilities.dp(int(style.get("sticker_size", 148)))
            sticker_lp = LinearLayout.LayoutParams(sticker_size, sticker_size)
            sticker_lp.topMargin = AndroidUtilities.dp(int(style.get("sticker_margin_top", 12)))
            sticker_lp.gravity = Gravity.CENTER_HORIZONTAL
            shell.addView(sticker_view, sticker_lp)

            self._bind_no_results_sticker_view(sticker_view)
            self._ensure_no_results_sticker_loaded()

        lp = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT,
            ViewGroup.LayoutParams.WRAP_CONTENT,
        )
        lp.gravity = Gravity.CENTER_HORIZONTAL
        lp.topMargin = AndroidUtilities.dp(int(style.get("top_margin", 14)))
        container.addView(shell, lp)

        state["status_mode"] = mode
        state["status_shell"] = shell
        state["status_title_view"] = t
        state["status_subtitle_view"] = s
        state["status_lottie_view"] = icon_view if loading_mode else None
        state["status_sticker_view"] = sticker_view

        self._animate_status_entry(shell, subtle=bool(style.get("subtle_anim", True)))

    def _create_loading_lottie_icon(self, context: Any, palette: Dict[str, int]):
        try:
            anim = RLottieImageView(context)
            anim.setAutoRepeat(True)
            try:
                anim.setScaleType(ImageView.ScaleType.CENTER_INSIDE)
            except Exception:
                pass

            anim_res = None
            try:
                anim_res = getattr(R.raw, "options_to_search")
            except Exception:
                try:
                    anim_res = getattr(R.raw, "dots_loading")
                except Exception:
                    anim_res = None
            if anim_res is None:
                return None

            anim.setAnimation(anim_res, 18, 18)
            anim.setColorFilter(self._color(palette["status_icon_tint"]))
            try:
                drawable = anim.getAnimatedDrawable()
                if drawable is not None:
                    drawable.multiplySpeed(1.25)
            except Exception:
                pass
            anim.playAnimation()
            return anim
        except Exception:
            return None

    def _animate_status_entry(self, view: Any, subtle: bool = False):
        if view is None:
            return
        try:
            view.animate().cancel()
        except Exception:
            pass
        try:
            if subtle:
                view.setAlpha(0.0)
                view.setTranslationY(AndroidUtilities.dp(6))
                view.setScaleX(1.0)
                view.setScaleY(1.0)
                view.animate().alpha(1.0).translationY(0).setDuration(210).start()
            else:
                view.setAlpha(0.0)
                view.setTranslationY(AndroidUtilities.dp(12))
                view.setScaleX(0.985)
                view.setScaleY(0.985)
                view.animate().alpha(1.0).translationY(0).scaleX(1.0).scaleY(1.0).setDuration(270).start()
        except Exception:
            pass

    def _create_card(self, state: Dict[str, Any], item: Dict[str, Any]):
        context = state["results_container"].getContext()
        p = self._palette()
        query = str(state.get("query", "") or "")

        card = LinearLayout(context)
        card.setOrientation(LinearLayout.VERTICAL)
        card.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(16))
        bg.setColor(self._color(p["card"]))
        bg.setStroke(AndroidUtilities.dp(1), self._color(p["card_stroke"]))
        card.setBackground(bg)
        self._apply_round_ripple(card, p["ripple"], radius_dp=16)

        top = LinearLayout(context)
        top.setOrientation(LinearLayout.HORIZONTAL)
        top.setGravity(Gravity.CENTER_VERTICAL)
        card.addView(top, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        avatar = BackupImageView(context)
        avatar.setRoundRadius(AndroidUtilities.dp(22))
        alp = LinearLayout.LayoutParams(AndroidUtilities.dp(44), AndroidUtilities.dp(44))
        alp.rightMargin = AndroidUtilities.dp(10)
        top.addView(avatar, alp)
        self._bind_card_avatar(avatar, item)

        col = LinearLayout(context)
        col.setOrientation(LinearLayout.VERTICAL)
        top.addView(col, LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1.0))

        title_row = LinearLayout(context)
        title_row.setOrientation(LinearLayout.HORIZONTAL)
        title_row.setGravity(Gravity.CENTER_VERTICAL)
        col.addView(title_row, LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        title = TextView(context)
        title.setText(self._highlight_text(str(item.get("title", "") or ""), query, p["match"]))
        title.setTextColor(self._color(p["text"]))
        title.setTypeface(Typeface.DEFAULT_BOLD)
        title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        title.setMaxLines(1)
        title_row.addView(title, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        if bool(item.get("verified", False)):
            verified_icon = self._create_verified_icon(context, p)
            if verified_icon is not None:
                vlp = LinearLayout.LayoutParams(AndroidUtilities.dp(14), AndroidUtilities.dp(14))
                vlp.leftMargin = AndroidUtilities.dp(6)
                title_row.addView(verified_icon, vlp)

        subtitle_text = self._subtitle(item)
        if subtitle_text:
            subtitle = TextView(context)
            subtitle.setText(self._highlight_text(subtitle_text, query, p["text_soft"]))
            subtitle.setTextColor(self._color(p["text_soft"]))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
            subtitle.setMaxLines(1)
            slp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            slp.topMargin = AndroidUtilities.dp(2)
            col.addView(subtitle, slp)

        kind_label = self._kind_label(str(item.get("kind", "")))
        is_verified = bool(item.get("verified", False))
        if kind_label or is_verified:
            meta_row = LinearLayout(context)
            meta_row.setOrientation(LinearLayout.HORIZONTAL)
            meta_row.setGravity(Gravity.CENTER_VERTICAL)
            mlp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
            mlp.topMargin = AndroidUtilities.dp(6 if subtitle_text else 4)
            col.addView(meta_row, mlp)

            if kind_label:
                type_chip = self._create_meta_chip(
                    context,
                    kind_label,
                    p["chip"],
                    p["chip_stroke"],
                    p["chip_text"],
                )
                type_lp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT)
                type_lp.rightMargin = AndroidUtilities.dp(6)
                meta_row.addView(type_chip, type_lp)

        members = int(item.get("members", 0) or 0)
        if members > 0:
            right_wrap = LinearLayout(context)
            right_wrap.setOrientation(LinearLayout.HORIZONTAL)
            right_wrap.setGravity(Gravity.CENTER_VERTICAL)

            type_icon_res = self._kind_icon_res(str(item.get("kind", "")))
            if type_icon_res is not None:
                type_icon = ImageView(context)
                type_icon.setImageResource(type_icon_res)
                type_icon.setColorFilter(self._color(p["text_soft"]))
                ilp = LinearLayout.LayoutParams(AndroidUtilities.dp(14), AndroidUtilities.dp(14))
                ilp.rightMargin = AndroidUtilities.dp(4)
                right_wrap.addView(type_icon, ilp)

            right = TextView(context)
            right.setText(self._format_members(members))
            right.setTextColor(self._color(p["text_soft"]))
            right.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 12)
            right.setTypeface(Typeface.DEFAULT_BOLD)
            right_wrap.addView(right, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))
            top.addView(right_wrap, LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT))

        description = str(item.get("description", "") or "")
        if not description:
            description = self._kind_label(str(item.get("kind", "")))
        desc = TextView(context)
        desc.setText(self._highlight_text(description, query, p["match"]))
        desc.setTextColor(self._color(p["text_muted"]))
        desc.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 13)
        desc.setMaxLines(2)
        dlp = LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT)
        dlp.topMargin = AndroidUtilities.dp(8)
        card.addView(desc, dlp)

        card.setOnClickListener(OnClickListener(lambda _v=None, key=state["key"], result=item: self._open_result(key, result)))
        return card

    def _bind_card_avatar(self, avatar: Any, item: Dict[str, Any]):
        obj = item.get("obj")
        resolved_obj = self._resolve_avatar_object(item, obj)
        avatar_drawable = self._build_avatar_drawable(item, resolved_obj)

        if resolved_obj is not None:
            try:
                avatar.setForUserOrChat(resolved_obj, avatar_drawable)
                return
            except Exception:
                pass

        if self._is_inline_result_object(obj):
            if self._set_inline_result_avatar_image(avatar, obj, avatar_drawable):
                return

        try:
            avatar.setForUserOrChat(None, avatar_drawable)
        except Exception:
            try:
                avatar.setImageDrawable(avatar_drawable)
            except Exception:
                pass

    def _resolve_avatar_object(self, item: Dict[str, Any], obj: Any):
        if self._is_user_or_chat_object(obj):
            return obj

        mc = get_messages_controller()
        if mc is None:
            return None

        did = int(item.get("did", 0) or 0)
        if did > 0 and hasattr(mc, "getUser"):
            try:
                user = mc.getUser(int(did))
                if self._is_user_or_chat_object(user):
                    return user
            except Exception:
                pass
        elif did < 0 and hasattr(mc, "getChat"):
            try:
                chat = mc.getChat(int(-did))
                if self._is_user_or_chat_object(chat):
                    return chat
            except Exception:
                pass

        username = str(item.get("username", "") or "").strip().lstrip("@")
        if username and hasattr(mc, "getUserOrChat"):
            for key in (username, "@" + username):
                try:
                    candidate = mc.getUserOrChat(key)
                except Exception:
                    candidate = None
                if self._is_user_or_chat_object(candidate):
                    return candidate
        return None

    def _is_user_or_chat_object(self, obj: Any) -> bool:
        if obj is None:
            return False
        try:
            class_name = str(obj.getClass().getName() or "")
        except Exception:
            class_name = ""
        if "TLRPC$User" in class_name or "TLRPC$Chat" in class_name:
            return True

        if hasattr(obj, "first_name") or hasattr(obj, "last_name"):
            return True
        if hasattr(obj, "title") and (hasattr(obj, "participants_count") or hasattr(obj, "broadcast")):
            return True
        return False

    def _is_inline_result_object(self, obj: Any) -> bool:
        if obj is None:
            return False
        try:
            class_name = str(obj.getClass().getName() or "")
            return class_name.endswith("TL_botInlineResult") or class_name.endswith("TL_botInlineMediaResult")
        except Exception:
            return False

    def _build_avatar_drawable(self, item: Dict[str, Any], obj: Any):
        avatar_drawable = AvatarDrawable()
        if obj is not None:
            try:
                avatar_drawable.setInfo(obj)
                return avatar_drawable
            except Exception:
                pass

        title = str(item.get("title", "") or "").strip()
        username = str(item.get("username", "") or "").strip().lstrip("@")
        url = str(item.get("url", "") or "").strip()
        seed_base = username or title or url or "explore"

        seed = 1
        for ch in seed_base[:96]:
            seed = ((seed * 33) + ord(ch)) & 0x7FFFFFFF
        seed = max(1, int(seed))

        if not title:
            title = "@" + username if username else self._kind_label(str(item.get("kind", "")))

        try:
            avatar_drawable.setInfo(seed, title, None)
        except Exception:
            pass
        return avatar_drawable

    def _set_inline_result_avatar_image(self, avatar: Any, inline_obj: Any, fallback_drawable: Any) -> bool:
        try:
            photo = getattr(inline_obj, "photo", None)
        except Exception:
            photo = None
        if photo is not None:
            photo_size = None
            try:
                photo_size = FileLoader.getClosestPhotoSizeWithSize(photo.sizes, AndroidUtilities.getPhotoSize(), True)
            except Exception:
                photo_size = None
            if photo_size is None:
                try:
                    sizes = self._java_list(getattr(photo, "sizes", None))
                    if sizes:
                        photo_size = sizes[-1]
                except Exception:
                    photo_size = None
            if photo_size is not None:
                try:
                    image_location = ImageLocation.getForPhoto(photo_size, photo)
                    if image_location is not None:
                        avatar.setImage(image_location, "52_52", fallback_drawable, inline_obj)
                        return True
                except Exception:
                    pass

        for attr_name in ("thumb", "content"):
            try:
                web_doc = getattr(inline_obj, attr_name, None)
            except Exception:
                web_doc = None
            if web_doc is None:
                continue
            try:
                web_file = WebFile.createWithWebDocument(web_doc)
                if web_file is None:
                    continue
                image_location = ImageLocation.getForWebFile(web_file)
                if image_location is None:
                    continue
                avatar.setImage(image_location, "52_52", fallback_drawable, inline_obj)
                return True
            except Exception:
                continue

        return False

    def _create_meta_chip(self, context: Any, text: str, bg_color: int, stroke_color: int, text_color: int):
        chip = TextView(context)
        chip.setText(text)
        chip.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 11)
        chip.setTypeface(Typeface.DEFAULT_BOLD)
        chip.setTextColor(self._color(text_color))
        chip.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(3), AndroidUtilities.dp(8), AndroidUtilities.dp(3))
        bg = GradientDrawable()
        bg.setCornerRadius(AndroidUtilities.dp(10))
        bg.setColor(self._color(bg_color))
        bg.setStroke(AndroidUtilities.dp(1), self._color(stroke_color))
        chip.setBackground(bg)
        return chip

    def _create_verified_icon(self, context: Any, palette: Dict[str, int]):
        try:
            shell = FrameLayout(context)
            area = ImageView(context)
            area.setImageResource(R.drawable.verified_area)
            area.setColorFilter(self._color(palette["verified_bg"]))
            shell.addView(area, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))

            check = ImageView(context)
            check.setImageResource(R.drawable.verified_check)
            check.setColorFilter(self._color(palette["verified_check"]))
            shell.addView(check, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
            return shell
        except Exception:
            return None

    def _kind_icon_res(self, kind: str):
        if kind == "channel":
            try:
                return getattr(R.drawable, "msg_channel")
            except Exception:
                return None
        if kind == "group":
            try:
                return getattr(R.drawable, "msg_groups")
            except Exception:
                return None
        if kind == "bot":
            try:
                return getattr(R.drawable, "msg_bot")
            except Exception:
                return None
        return None

    def _highlight_query_tokens(self, query: str) -> List[str]:
        raw = str(query or "").strip().lower()
        if not raw:
            return []

        tokens = []
        seen = set()
        for part in raw.replace("\n", " ").replace("\r", " ").split(" "):
            token = part.strip().lstrip("@#$")
            if len(token) < 2:
                continue
            cleaned = []
            for ch in token:
                if ch.isalnum() or ch == "_":
                    cleaned.append(ch)
                else:
                    break
            value = "".join(cleaned)
            if len(value) < 2 or value in seen:
                continue
            seen.add(value)
            tokens.append(value)
        return tokens[:6]

    def _merge_ranges(self, ranges: List[tuple]) -> List[tuple]:
        if not ranges:
            return []
        sorted_ranges = sorted(ranges, key=lambda r: (r[0], r[1]))
        merged: List[tuple] = [sorted_ranges[0]]
        for start, end in sorted_ranges[1:]:
            last_start, last_end = merged[-1]
            if start <= last_end:
                merged[-1] = (last_start, max(last_end, end))
            else:
                merged.append((start, end))
        return merged

    def _highlight_text(self, text: str, query: str, accent_color: int):
        value = str(text or "")
        if not value:
            return value
        tokens = self._highlight_query_tokens(query)
        if not tokens:
            return value

        source = value.lower()
        ranges = []
        for token in tokens:
            pos = 0
            while True:
                idx = source.find(token, pos)
                if idx < 0:
                    break
                ranges.append((idx, idx + len(token)))
                pos = idx + len(token)
        merged_ranges = self._merge_ranges(ranges)
        if not merged_ranges:
            return value

        try:
            SpannableString = jclass("android.text.SpannableString")
            ForegroundColorSpan = jclass("android.text.style.ForegroundColorSpan")
            StyleSpan = jclass("android.text.style.StyleSpan")
            span = SpannableString(value)
            flag = 33
            for start, end in merged_ranges:
                try:
                    span.setSpan(ForegroundColorSpan(self._color(accent_color)), int(start), int(end), flag)
                except Exception:
                    pass
                try:
                    span.setSpan(StyleSpan(int(Typeface.BOLD)), int(start), int(end), flag)
                except Exception:
                    pass
            return span
        except Exception:
            return value

    def _open_result(self, state_key: int, item: Dict[str, Any]):
        state = self._states.get(state_key)
        if state is None:
            return
        activity = state.get("activity")
        if activity is None:
            return

        username = str(item.get("username", "") or "").strip()
        did = int(item.get("did", 0) or 0)
        if did == 0:
            self._open_by_username(activity, username)
            return

        args = Bundle()
        if did > 0:
            args.putLong("user_id", did)
        else:
            args.putLong("chat_id", -did)

        try:
            mc = get_messages_controller()
            if mc is not None and hasattr(mc, "checkCanOpenChat"):
                if not mc.checkCanOpenChat(args, activity):
                    self._open_by_username(activity, username)
                    return
        except Exception:
            pass

        try:
            activity.presentFragment(ChatActivity(args))
        except Exception as e:
            self._safe_log(f"[ExploreSearch] failed to open chat: {e}")
            self._open_by_username(activity, username)

    def _open_by_username(self, activity: Any, username: str) -> bool:
        name = str(username or "").strip().lstrip("@")
        if not name:
            return False
        try:
            mc = get_messages_controller()
            if mc is None or not hasattr(mc, "openByUserName"):
                return False
            mc.openByUserName(name, activity, 1)
            return True
        except Exception as e:
            self._safe_log(f"[ExploreSearch] openByUserName failed: {e}")
            return False


    def _normalize(self, value: Any) -> str:
        try:
            text = str(value or "").strip().lower()
            text = " ".join(text.split())
            text = text.replace("С‘", "Рµ")
            return text
        except Exception:
            return ""

    def _translit(self, value: Any) -> str:
        text = self._normalize(value)
        if not text:
            return ""
        try:
            return self._normalize(AndroidUtilities.translitSafe(text))
        except Exception:
            return text

    def _java_list(self, value: Any) -> List[Any]:
        if value is None:
            return []
        out = []
        try:
            size = int(value.size())
            for i in range(size):
                out.append(value.get(i))
            return out
        except Exception:
            pass
        try:
            return list(value)
        except Exception:
            return []

    def _format_members(self, count: int) -> str:
        if count >= 1000000:
            return f"{count / 1000000.0:.1f}M"
        if count >= 1000:
            return f"{count / 1000.0:.1f}K"
        return str(count)

    def _kind_label(self, kind: str) -> str:
        if kind == "channel":
            return "Channel"
        if kind == "group":
            return "Group"
        if kind == "bot":
            return "Bot"
        return "Chat"

    def _subtitle(self, item: Dict[str, Any]) -> str:
        username = str(item.get("username", "") or "")
        if username:
            return "@" + username
        return ""

    def _to_java_color_int(self, value: int) -> int:
        v = int(value) & 0xFFFFFFFF
        if v >= 0x80000000:
            v -= 0x100000000
        return v

    def _theme_color(self, key_name: str, fallback: int) -> int:
        try:
            key = getattr(Theme, key_name)
            return self._to_java_color_int(int(Theme.getColor(key)))
        except Exception:
            return self._to_java_color_int(fallback)

    def _alpha_color(self, color: int, alpha: int) -> int:
        argb = ((int(alpha) & 0xFF) << 24) | (int(color) & 0x00FFFFFF)
        return self._to_java_color_int(argb)

    def _luminance(self, color: int) -> float:
        rgb = int(color) & 0x00FFFFFF
        r = ((rgb >> 16) & 0xFF) / 255.0
        g = ((rgb >> 8) & 0xFF) / 255.0
        b = (rgb & 0xFF) / 255.0
        return (0.2126 * r) + (0.7152 * g) + (0.0722 * b)

    def _mix_color(self, from_color: int, to_color: int, amount: float) -> int:
        t = max(0.0, min(1.0, float(amount)))
        a = int(from_color) & 0x00FFFFFF
        b = int(to_color) & 0x00FFFFFF

        ar = (a >> 16) & 0xFF
        ag = (a >> 8) & 0xFF
        ab = a & 0xFF

        br = (b >> 16) & 0xFF
        bg = (b >> 8) & 0xFF
        bb = b & 0xFF

        rr = int(ar + (br - ar) * t)
        rg = int(ag + (bg - ag) * t)
        rb = int(ab + (bb - ab) * t)
        return self._to_java_color_int((0xFF << 24) | (rr << 16) | (rg << 8) | rb)

    def _contrast_ratio(self, color_a: int, color_b: int) -> float:
        la = self._luminance(color_a)
        lb = self._luminance(color_b)
        hi = la if la >= lb else lb
        lo = lb if la >= lb else la
        return (hi + 0.05) / (lo + 0.05)

    def _ensure_contrast(self, color: int, background: int, min_ratio: float) -> int:
        if self._contrast_ratio(color, background) >= float(min_ratio):
            return self._to_java_color_int(color)

        white = self._to_java_color_int(0xFFFFFFFF)
        black = self._to_java_color_int(0xFF000000)
        white_ratio = self._contrast_ratio(white, background)
        black_ratio = self._contrast_ratio(black, background)
        target = white if white_ratio >= black_ratio else black

        base_ratio = self._contrast_ratio(color, background)
        target_ratio = self._contrast_ratio(target, background)
        if target_ratio <= base_ratio:
            return self._to_java_color_int(color)

        for step in range(1, 13):
            mixed = self._mix_color(color, target, step / 12.0)
            if self._contrast_ratio(mixed, background) >= float(min_ratio):
                return mixed
        return target

    def _palette(self) -> Dict[str, int]:
        raw_bg = self._theme_color("key_dialogBackground", self._COLOR_BG)
        raw_card = self._theme_color("key_windowBackgroundWhite", self._COLOR_CARD)
        raw_text = self._theme_color("key_windowBackgroundWhiteBlackText", self._COLOR_TEXT)
        raw_text_soft = self._theme_color("key_windowBackgroundWhiteGrayText", self._COLOR_TEXT_SOFT)
        raw_text_muted = self._theme_color("key_windowBackgroundWhiteHintText", self._COLOR_TEXT_MUTED)
        raw_accent = self._theme_color("key_featuredStickers_addButton", self._COLOR_ACCENT)
        raw_divider = self._theme_color("key_divider", self._COLOR_CARD_STROKE)
        raw_input = self._theme_color("key_dialogInputField", self._COLOR_BG_SOFT)
        raw_action_bar = self._theme_color("key_actionBarDefault", self._COLOR_EXPLORE_BUTTON)

        bg = self._mix_color(raw_bg, self._COLOR_BG, 0.78)
        card = self._mix_color(raw_card, self._COLOR_CARD, 0.72)
        accent = self._mix_color(raw_accent, self._COLOR_ACCENT, 0.80)
        divider = self._mix_color(raw_divider, self._COLOR_CARD_STROKE, 0.78)
        input_bg = self._mix_color(raw_input, self._COLOR_BG_SOFT, 0.84)
        action_bar_bg = self._mix_color(raw_action_bar, self._COLOR_EXPLORE_BUTTON, 0.62)

        text = self._ensure_contrast(self._mix_color(raw_text, self._COLOR_TEXT, 0.38), bg, 4.8)
        text_soft = self._ensure_contrast(self._mix_color(raw_text_soft, self._COLOR_TEXT_SOFT, 0.56), bg, 2.9)
        text_muted = self._ensure_contrast(self._mix_color(raw_text_muted, self._COLOR_TEXT_MUTED, 0.64), bg, 2.3)

        input_text = self._ensure_contrast(text, input_bg, 4.3)
        input_hint = self._ensure_contrast(self._mix_color(text_soft, text_muted, 0.30), input_bg, 2.6)
        input_stroke = self._alpha_color(self._mix_color(accent, text_soft, 0.12), 152)
        input_stroke_soft = self._alpha_color(self._mix_color(accent, divider, 0.26), 108)

        tabs_shell_bg = self._mix_color(bg, input_bg, 0.44)
        tabs_shell_stroke = self._alpha_color(self._mix_color(accent, text_soft, 0.20), 172)
        tab_active_bg = self._mix_color(input_bg, accent, 0.50)
        tab_active_stroke = self._alpha_color(accent, 228)
        tab_active_text = self._ensure_contrast(text, tab_active_bg, 3.2)
        tab_inactive_text = self._ensure_contrast(text_soft, tabs_shell_bg, 2.7)
        tab_bg = 0x00000000
        tab_bg_stroke = 0x00000000
        tab_line = 0x00000000
        tab_selector = self._alpha_color(accent, 54)

        row_bg = self._mix_color(card, bg, 0.32)
        row_stroke = self._alpha_color(self._mix_color(text_soft, accent, 0.16), 146)

        chip = self._mix_color(input_bg, card, 0.24)
        chip_stroke = self._alpha_color(self._mix_color(row_stroke, accent, 0.15), 168)
        chip_text = self._ensure_contrast(text_soft, chip, 2.8)
        chip_active = self._mix_color(chip, accent, 0.34)
        chip_active_accent = self._mix_color(chip, accent, 0.48)
        chip_active_stroke = self._alpha_color(accent, 220)
        chip_active_text = self._ensure_contrast(text, chip_active, 3.2)
        chip_active_accent_text = self._ensure_contrast(text, chip_active_accent, 3.2)

        card_stroke = self._alpha_color(self._mix_color(divider, text_soft, 0.18), 170)
        status_bg = self._mix_color(card, input_bg, 0.56)
        status_bg_soft = self._mix_color(status_bg, bg, 0.20)
        status_stroke = self._alpha_color(self._mix_color(accent, text_soft, 0.28), 152)
        status_icon_bg = self._alpha_color(accent, 72)
        status_icon_stroke = self._alpha_color(accent, 148)
        status_icon_tint = self._ensure_contrast(self._mix_color(accent, text, 0.22), status_bg, 2.8)
        status_subtitle = self._ensure_contrast(self._mix_color(text_soft, text_muted, 0.46), status_bg, 2.2)

        overlay_title = self._ensure_contrast(text, bg, 4.8)
        overlay_icon = self._ensure_contrast(self._mix_color(text_soft, text, 0.25), bg, 3.0)
        match = self._ensure_contrast(self._mix_color(accent, text, 0.30), card, 3.2)
        verified_bg = self._theme_color("key_chats_verifiedBackground", accent)
        verified_check = self._theme_color("key_chats_verifiedCheck", 0xFFFFFFFF)

        action_title = self._theme_color("key_actionBarDefaultTitle", text)
        action_icon = self._theme_color("key_actionBarDefaultIcon", text)

        return {
            "bg": bg,
            "card": card,
            "card_stroke": card_stroke,
            "text": text,
            "text_soft": text_soft,
            "text_muted": text_muted,
            "accent": accent,
            "ripple": self._alpha_color(accent, 44),
            "tab_line": tab_line,
            "tab_active_text": tab_active_text,
            "tab_inactive_text": tab_inactive_text,
            "tab_selector": tab_selector,
            "tab_active_bg": tab_active_bg,
            "tab_active_stroke": tab_active_stroke,
            "tab_bg": tab_bg,
            "tab_bg_stroke": tab_bg_stroke,
            "tabs_shell_bg": tabs_shell_bg,
            "tabs_shell_stroke": tabs_shell_stroke,
            "row_bg": row_bg,
            "row_stroke": row_stroke,
            "match": match,
            "chip": chip,
            "chip_active": chip_active,
            "chip_active_accent": chip_active_accent,
            "chip_active_stroke": chip_active_stroke,
            "chip_text": chip_text,
            "chip_active_text": chip_active_text,
            "chip_active_accent_text": chip_active_accent_text,
            "chip_stroke": chip_stroke,
            "input_bg": input_bg,
            "input_stroke": input_stroke,
            "input_stroke_soft": input_stroke_soft,
            "input_text": input_text,
            "input_hint": input_hint,
            "status_bg": status_bg,
            "status_bg_soft": status_bg_soft,
            "status_stroke": status_stroke,
            "status_accent": self._alpha_color(accent, 204),
            "status_glow": self._alpha_color(accent, 52),
            "status_icon_bg": status_icon_bg,
            "status_icon_stroke": status_icon_stroke,
            "status_icon_tint": status_icon_tint,
            "status_subtitle": status_subtitle,
            "explore_button": action_bar_bg,
            "explore_button_stroke": self._alpha_color(accent, 130),
            "action_title": action_title,
            "action_icon": action_icon,
            "overlay_title": overlay_title,
            "overlay_icon": overlay_icon,
            "verified_bg": verified_bg,
            "verified_check": verified_check,
        }

    def _color(self, value: int) -> int:
        return self._to_java_color_int(value)

    def _safe_log(self, text: str):
        try:
            log(text)
        except Exception:
            pass


class _DialogsCreateViewHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_create_view(param.thisObject, param.getResult())
        except Exception:
            pass


class _DialogsShowSearchHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            show = bool(param.args[0]) if param.args and len(param.args) > 0 else False
            self.plugin._on_show_search(param.thisObject, show)
        except Exception:
            pass


class _DialogsDestroyHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            self.plugin._on_destroy(param.thisObject)
        except Exception:
            pass


class _DialogsResumeHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_resume(param.thisObject)
        except Exception:
            pass


class _ToggleSearchHook:
    def __init__(self, plugin: ExploreSearchPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._on_toggle_search()
        except Exception:
            pass


plugin = ExploreSearchPlugin()
