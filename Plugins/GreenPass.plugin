__id__ = "GreenPass"
__name__ = "GreenPass"
__description__ = "Пытается быть хорошим прокси плагином"
__author__ = "@Altyplugins / Codex"
__version__ = "1.1.6.5"
__icon__ = "Broit_d_by_fStikBot/37"
__min_version__ = "12.1.1"


import json
import threading
import urllib.request
import urllib.error
import time
import ssl
import random
import re
import os
import socket
from base_plugin import BasePlugin, AppEvent, MethodHook, MenuItemData, MenuItemType
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Text, Divider, Selector, Switch, EditText
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment
from hook_utils import find_class
from org.telegram.messenger import NotificationCenter, SharedConfig, MessagesController, UserConfig, ApplicationLoader
from org.telegram.messenger.browser import Browser
from org.telegram.tgnet import ConnectionsManager

# ================== CONFIGURATION ==================
GITHUB_PROXY_URL = "https://raw.githubusercontent.com/Argh94/Proxy-List/refs/heads/main/MTProto.txt"
SUBSCRIBE_CHANNEL = "AltyPlugins"

PROXY_PROVIDER_ITEMS = [
    "GreenPass (GitHub + fallback)",
    "exitFy Shrimp",
    "exitFy VPNET",
    "exitFy Sworkle",
]

PROXY_PROVIDER_URLS = {
    0: [GITHUB_PROXY_URL],
    1: ["https://exitfy.ishrimp.xyz/proxy/single/de/experimental"],
    2: ["https://exitfy.vpnetproxy.xyz/proxy/latest"],
    3: ["https://a.stemstep.cloud/proxy/socks"],
}

PROXY_PROVIDER_FALLBACK_TEXT = {
    1: """
tg://proxy?server=exitfy-ru.ishrimp.xyz&port=443&secret=4a680bdd1865bd48cd632ab79877beea
tg://proxy?server=exitfy-de.ishrimp.xyz&port=443&secret=2b26d3b302ad0e8b497964668c970f4a
""",
    2: """
tg://proxy?server=exitfy-ru.vpnetproxy.xyz&port=443&secret=62e5e5a3df7ed76238a279f7974938cc
""",
    3: """
tg://socks?server=exitfy-lvc.sworkle.net&port=443&user=SworklebzbVVfsZLxLlVqEEnZUmu4&pass=ProxydDI2m36gCN46ZrNVJs8J
tg://socks?server=exitfy-rua.sworkle.net&port=443&user=SworklebzbVVfsZLxLlVqEEnZUmu4&pass=ProxydDI2m36gCN46ZrNVJs8J
""",
}

# Proxy cleanup / health policy
MAX_TRACKED_PROXY_STATE = 200
PROXY_STATE_TTL_SEC = 7 * 24 * 60 * 60
PROXY_FAIL_TTL_SEC = 6 * 60 * 60
PROXY_FAIL_THRESHOLD = 2

# Auto-provider scoring policy
AUTO_PROVIDER_MAX_SAMPLES_PER_PROVIDER = 6
AUTO_PROVIDER_PING_TIMEOUT_SEC = 0.7
AUTO_PROVIDER_SELECT_DEADLINE_SEC = 6.0
PROXY_CONNECT_VERIFY_WAIT_SEC = 2.0

# Fallback chain and background precheck
PRECHECK_INTERVAL_SEC = 5 * 60
PRECHECK_SAMPLE_LIMIT = 10
PRECHECK_PING_TIMEOUT_SEC = 0.7
HOT_CACHE_TTL_SEC = 30 * 60
HOT_CACHE_MAX_ITEMS = 12

FALLBACK_PROXIES_TEXT = """
https://t.me/proxy?server=146.185.208.135&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.93.104&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.77.95&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.216.171&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=185.130.115.156&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=185.130.113.138&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.213.38&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.213.122&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.255&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.200&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.253.198&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.85&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.78&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.26&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=185.241.194.130&port=2443&secret=9c4a7e2d1f5086b3a9d2e4f607182c5a
"""


def _is_tg_proxy_enabled():
    try:
        return bool(MessagesController.getGlobalMainSettings().getBoolean("proxy_enabled", False))
    except:
        return False


def _set_tg_proxy_enabled(enabled):
    try:
        val = bool(enabled)
    except:
        val = False

    try:
        prefs = MessagesController.getGlobalMainSettings()
        ed = prefs.edit()
        ed.putBoolean("proxy_enabled", val)
        ed.commit()
    except:
        pass

    try:
        SharedConfig.proxyEnabled = val
        if hasattr(SharedConfig, "saveConfig"):
            SharedConfig.saveConfig()
    except:
        pass

    try:
        if val and SharedConfig.currentProxy is not None:
            p = SharedConfig.currentProxy
            ConnectionsManager.setProxySettings(True, str(p.address), int(p.port), str(getattr(p, "username", "") or ""), str(getattr(p, "password", "") or ""), str(getattr(p, "secret", "") or ""))
        else:
            ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
    except:
        pass

    try:
        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
    except:
        pass


def _force_show_dialogs_proxy_button(da):
    try:
        if da is None:
            return

        cls = None
        try:
            cls = da.getClass()
        except:
            cls = None

        proxy_item = None
        if cls is not None:
            try:
                f = cls.getDeclaredField("proxyItem")
                f.setAccessible(True)
                proxy_item = f.get(da)
            except:
                proxy_item = None

        if proxy_item is not None:
            try:
                from android.view import View
                proxy_item.setVisibility(View.VISIBLE)
            except:
                pass

        if cls is not None:
            try:
                vf = cls.getDeclaredField("proxyItemVisible")
                vf.setAccessible(True)
                try:
                    vf.setBoolean(da, True)
                except:
                    vf.set(da, True)
            except:
                pass

        proxy_drawable = None
        if cls is not None:
            try:
                df = cls.getDeclaredField("proxyDrawable")
                df.setAccessible(True)
                proxy_drawable = df.get(da)
            except:
                proxy_drawable = None

        if proxy_drawable is not None:
            state = None
            try:
                sf = cls.getDeclaredField("currentConnectionState")
                sf.setAccessible(True)
                state = sf.getInt(da)
            except:
                state = None

            enabled = _is_tg_proxy_enabled()
            connected = False
            try:
                connected = (
                    state == ConnectionsManager.ConnectionStateConnected
                    or state == ConnectionsManager.ConnectionStateUpdating
                )
            except:
                connected = False

            try:
                proxy_drawable.setConnected(bool(enabled), bool(connected), False)
            except:
                pass
    except:
        pass

class HideProxySponsorDialogHook(MethodHook):
    _last_hide = {}

    def after_hooked_method(self, param):
        try:
            mc = param.thisObject
            if not mc:
                return

            proxy_type = 0
            try:
                proxy_type = int(getattr(MessagesController, "PROMO_TYPE_PROXY", 0))
            except:
                proxy_type = 0

            promo_type = None
            try:
                promo_type = int(mc.promoDialogType)
            except:
                promo_type = None

            promo_id = 0
            promo_type_pref = None
            try:
                prefs = MessagesController.getGlobalMainSettings()
                promo_id = int(prefs.getLong("proxy_dialog", 0))
                promo_type_pref = int(prefs.getInt("promo_dialog_type", -1))
            except:
                promo_id = 0
                promo_type_pref = None

            is_proxy_promo = False
            if promo_id != 0 and promo_type_pref is not None and promo_type_pref == proxy_type:
                is_proxy_promo = True
            elif promo_type is not None and promo_type == proxy_type:
                is_proxy_promo = True

            if not is_proxy_promo:
                return

            now = int(time.time())
            key = id(mc)
            last = int(HideProxySponsorDialogHook._last_hide.get(key, 0) or 0)
            if now - last < 30:
                return
            HideProxySponsorDialogHook._last_hide[key] = now

            def _hide():
                try:
                    from hook_utils import get_private_field, set_private_field

                    promo_dialog = None
                    try:
                        promo_dialog = get_private_field(mc, "promoDialog")
                    except:
                        promo_dialog = None

                    if promo_dialog is None and promo_id != 0:
                        try:
                            promo_dialog = mc.dialogs_dict.get(promo_id)
                        except:
                            promo_dialog = None
                        if promo_dialog is not None:
                            try:
                                set_private_field(mc, "promoDialog", promo_dialog)
                            except:
                                pass

                    if hasattr(mc, "hidePromoDialog"):
                        mc.hidePromoDialog()
                except:
                    pass

            run_on_ui_thread(_hide)
        except:
            pass


class _ForceDialogsProxyButtonHook(MethodHook):
    def __init__(self, plugin):
        self._plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self._plugin._active:
                return
            _force_show_dialogs_proxy_button(param.thisObject)
        except:
            pass


class _DialogsShowSearchForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self._plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self._plugin._active:
                return
            _force_show_dialogs_proxy_button(param.thisObject)
        except:
            pass


class _DialogsShowDoneItemForceProxyHook(MethodHook):
    def __init__(self, plugin):
        self._plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self._plugin._active:
                return
            _force_show_dialogs_proxy_button(param.thisObject)
        except:
            pass


class _ProxySettingsChangedNotifyHook(MethodHook):
    def __init__(self, plugin):
        self._plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self._plugin._active:
                return
            if not param.args or len(param.args) < 1:
                return

            try:
                event_id = int(param.args[0])
                proxy_changed_id = int(NotificationCenter.proxySettingsChanged)
            except:
                return

            if event_id != proxy_changed_id:
                return

            self._plugin._refresh_settings_without_reopen()
            self._plugin._refresh_current_dialogs_proxy_button()
        except:
            pass


class _DialogsPresentFragmentRedirectHook(MethodHook):
    def __init__(self, plugin):
        self._plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self._plugin._active:
                return
            if not param.args or len(param.args) < 1:
                return

            frag_to_present = param.args[0]
            if frag_to_present is None:
                return

            is_proxy_screen = False
            try:
                ProxyListActivity = find_class("org.telegram.ui.ProxyListActivity")
            except:
                ProxyListActivity = None

            try:
                if ProxyListActivity and isinstance(frag_to_present, ProxyListActivity):
                    is_proxy_screen = True
            except:
                is_proxy_screen = False

            if not is_proxy_screen:
                try:
                    name = str(frag_to_present.getClass().getName() or "")
                except:
                    name = ""
                if name == "org.telegram.ui.ProxyListActivity":
                    is_proxy_screen = True

            if is_proxy_screen:
                self._plugin._open_plugin_settings(None)
                try:
                    param.setResult(False)
                except:
                    pass
                try:
                    param.result = False
                except:
                    pass
        except:
            pass

class SafeBypassPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._active = False
        self._thread = None
        self._redirect_hook_installed = False
        self._proxy_button_hooks_installed = False
        self._sync_hooks_installed = False

        self._last_proxy_sponsor_hide = 0
        self._last_provider_name = ""
        
        # Current proxy state
        self._current_server = ""
        self._current_port = 0
        self._current_secret = ""
        self._sub_dialog_shown = False
        self._finding_proxy = False
        # Proxies added/managed by this plugin.
        # Stored as a dict keyed by "server:port:secret".
        # Value schema: {"owned": bool, "last_used": int, "failures": int, "fail_ts": int}
        self._proxy_state = {}
        self._hot_proxy_cache = []
        self._last_working_proxy = None
        
        # Config path
        try:
            ctx = ApplicationLoader.applicationContext
            self._config_file = os.path.join(ctx.getFilesDir().getAbsolutePath(), "safebypass_v2_config.json")
        except:
            self._config_file = "safebypass_v2_config.json"
            
        self._load_config()

    def _load_config(self):
        try:
            if os.path.exists(self._config_file):
                with open(self._config_file, 'r') as f:
                    data = json.load(f)
                    self._current_server = data.get("server", "")
                    self._current_port = data.get("port", 0)
                    self._current_secret = data.get("secret", "")
                    self._last_provider_name = data.get("last_provider_name", "")
                    self._sub_dialog_shown = data.get("sub_dialog_shown", False)
                    hot_cache = data.get("hot_proxy_cache", [])
                    if isinstance(hot_cache, list):
                        self._hot_proxy_cache = hot_cache
                    else:
                        self._hot_proxy_cache = []
                    last_working = data.get("last_working_proxy", None)
                    if isinstance(last_working, dict):
                        self._last_working_proxy = last_working
                    else:
                        self._last_working_proxy = None

                    # Backward compatible: older versions stored a list under plugin_proxies.
                    legacy_list = data.get("plugin_proxies", [])
                    state = data.get("plugin_proxy_state", None)
                    if isinstance(state, dict):
                        self._proxy_state = state
                    else:
                        self._proxy_state = {}

                    if isinstance(legacy_list, list):
                        for k in legacy_list:
                            if not isinstance(k, str):
                                continue
                            self._proxy_state.setdefault(k, {"owned": True, "last_used": 0, "failures": 0, "fail_ts": 0})

                    self._prune_proxy_state(now=int(time.time()))
                    self._hot_proxy_cache = self._sanitize_hot_proxy_cache(self._hot_proxy_cache)
        except Exception as e:
            print(f"Error loading config: {e}")

    def _save_config(self):
        try:
            data = {
                "server": self._current_server,
                "port": self._current_port,
                "secret": self._current_secret,
                "last_provider_name": self._last_provider_name,
                "sub_dialog_shown": self._sub_dialog_shown,
                # Backward compatible key (list of keys). Keep small.
                "plugin_proxies": list(self._proxy_state.keys())[:MAX_TRACKED_PROXY_STATE],
                "plugin_proxy_state": self._proxy_state,
                "hot_proxy_cache": self._sanitize_hot_proxy_cache(self._hot_proxy_cache),
                "last_working_proxy": self._normalize_proxy_dict(self._last_working_proxy),
            }
            with open(self._config_file, 'w') as f:
                json.dump(data, f)
        except Exception as e:
            print(f"Error saving config: {e}")

    def _proxy_key(self, server, port, secret, username="", password=""):
        try:
            srv = str(server or "")
        except:
            srv = ""
        try:
            prt = int(port or 0)
        except:
            prt = 0
        try:
            sec = str(secret or "")
        except:
            sec = ""
        try:
            usr = str(username or "")
        except:
            usr = ""
        try:
            pwd = str(password or "")
        except:
            pwd = ""
        if usr or pwd:
            return f"{srv}:{prt}:{sec}:{usr}:{pwd}"
        return f"{srv}:{prt}:{sec}"

    def _provider_count(self):
        try:
            return len(PROXY_PROVIDER_ITEMS)
        except:
            return 0

    def _get_selected_provider(self):
        default_idx = 0
        try:
            idx = int(self.get_setting("proxy_provider", default_idx))
        except:
            idx = default_idx
        if idx < 0 or idx >= self._provider_count():
            idx = default_idx
        return idx

    def _get_provider_auto(self):
        try:
            return bool(self.get_setting("proxy_provider_auto", True))
        except:
            return True

    def _set_selected_provider(self, idx):
        try:
            self.set_setting("proxy_provider", int(idx), reload_settings=True)
        except:
            pass

    def _set_provider_auto(self, enabled):
        try:
            self.set_setting("proxy_provider_auto", bool(enabled), reload_settings=True)
        except:
            pass

    def _reload_settings_ui(self):
        def _run():
            try:
                PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                if PC:
                    inst = None
                    try:
                        inst = PC.getInstance()
                    except:
                        inst = None
                    if inst is not None:
                        try:
                            inst.loadPluginSettings(__id__)
                        except:
                            pass
            except:
                pass

        try:
            run_on_ui_thread(_run)
        except:
            _run()

    def _refresh_settings_without_reopen(self):
        try:
            self.set_setting("ui_refresh_nonce", int(time.time() * 1000), reload_settings=True)
            return
        except:
            pass
        self._reload_settings_ui()

    def _provider_name(self, idx):
        try:
            i = int(idx)
        except:
            i = 0
        if i < 0 or i >= self._provider_count():
            i = 0
        try:
            return str(PROXY_PROVIDER_ITEMS[i])
        except:
            return ""

    def _normalize_proxy_dict(self, proxy):
        if not isinstance(proxy, dict):
            return None
        try:
            server = str(proxy.get("server", "") or "")
        except:
            server = ""
        try:
            port = int(proxy.get("port", 0) or 0)
        except:
            port = 0
        try:
            secret = str(proxy.get("secret", "") or "")
        except:
            secret = ""
        try:
            username = str(proxy.get("username", "") or "")
        except:
            username = ""
        try:
            password = str(proxy.get("password", "") or "")
        except:
            password = ""
        try:
            kind = str(proxy.get("kind", "mtproto") or "mtproto")
        except:
            kind = "mtproto"
        try:
            provider_idx = int(proxy.get("provider_idx", -1))
        except:
            provider_idx = -1
        try:
            provider_name = str(proxy.get("provider_name", "") or "")
        except:
            provider_name = ""
        try:
            latency = float(proxy.get("latency", 0.0) or 0.0)
        except:
            latency = 0.0
        try:
            checked_at = int(proxy.get("checked_at", int(time.time())) or int(time.time()))
        except:
            checked_at = int(time.time())

        if not server or port <= 0:
            return None
        if kind != "socks" and not secret:
            return None

        return {
            "server": server,
            "port": int(port),
            "secret": secret,
            "username": username,
            "password": password,
            "kind": kind,
            "provider_idx": int(provider_idx),
            "provider_name": provider_name,
            "latency": float(latency),
            "checked_at": int(checked_at),
        }

    def _merge_unique_proxies(self, proxy_lists):
        merged = {}
        for items in proxy_lists:
            for proxy in list(items or []):
                p = self._normalize_proxy_dict(proxy)
                if not p:
                    continue
                key = self._proxy_key(
                    p.get("server"),
                    p.get("port"),
                    p.get("secret"),
                    p.get("username"),
                    p.get("password"),
                )
                if key not in merged:
                    merged[key] = p
        return list(merged.values())

    def _sanitize_hot_proxy_cache(self, items):
        now = int(time.time())
        dedup = {}
        for proxy in list(items or []):
            p = self._normalize_proxy_dict(proxy)
            if not p:
                continue
            checked_at = int(p.get("checked_at", now) or now)
            if (now - checked_at) > int(HOT_CACHE_TTL_SEC):
                continue
            key = self._proxy_key(
                p.get("server"),
                p.get("port"),
                p.get("secret"),
                p.get("username"),
                p.get("password"),
            )
            prev = dedup.get(key)
            if prev is None or float(p.get("latency", 999999.0)) < float(prev.get("latency", 999999.0)):
                dedup[key] = p

        out = list(dedup.values())
        out.sort(key=lambda x: float(x.get("latency", 999999.0)))
        return out[: int(HOT_CACHE_MAX_ITEMS)]

    def _build_safe_fallback_chain(self, selected_provider_proxies, merged_provider_proxies):
        selected_list = self._merge_unique_proxies([selected_provider_proxies])
        merged_list = self._merge_unique_proxies([merged_provider_proxies])
        hot_list = self._sanitize_hot_proxy_cache(self._hot_proxy_cache)
        last_list = self._merge_unique_proxies([[self._last_working_proxy] if self._last_working_proxy else []])

        return [
            ("selected_provider", selected_list),
            ("all_providers", merged_list),
            ("hot_cache", hot_list),
            ("last_working", last_list),
        ]

    def _refresh_hot_proxy_cache(self, candidates):
        now = int(time.time())
        sample = self._build_probe_subset(list(candidates or []), limit=int(PRECHECK_SAMPLE_LIMIT))
        if not sample:
            self._hot_proxy_cache = self._sanitize_hot_proxy_cache(self._hot_proxy_cache)
            return

        checked = []
        for p in sample:
            dt = self._probe_proxy_latency(p, timeout_sec=float(PRECHECK_PING_TIMEOUT_SEC))
            if dt is None:
                continue
            item = self._normalize_proxy_dict(p)
            if not item:
                continue
            item["latency"] = float(dt)
            item["checked_at"] = int(now)
            checked.append(item)

        merged = self._merge_unique_proxies([checked, self._hot_proxy_cache])
        for p in merged:
            if "checked_at" not in p:
                p["checked_at"] = int(now)
        self._hot_proxy_cache = self._sanitize_hot_proxy_cache(merged)

    def _background_precheck(self):
        if not self._active:
            return
        if self._finding_proxy:
            return

        try:
            provider_auto = self._get_provider_auto()
            selected_provider = self._get_selected_provider()

            if provider_auto:
                provider_proxy_map = self._collect_provider_proxy_map_sync(timeout_sec=2.0)
                selected = list(provider_proxy_map.get(selected_provider, []) or [])
                merged = self._merge_unique_proxies([provider_proxy_map.get(i, []) or [] for i in range(self._provider_count())])
                candidates = self._merge_unique_proxies([selected, merged])
            else:
                selected = self._collect_proxies_for_provider(selected_provider, timeout_sec=3.5)
                candidates = self._merge_unique_proxies([selected])

            self._refresh_hot_proxy_cache(candidates)
            self._save_config()
        except Exception as e:
            print(f"Precheck Error: {e}")

    def _get_hardcoded_proxies_text(self):
        try:
            value = self.get_setting("hardcoded_proxies_text", FALLBACK_PROXIES_TEXT)
        except:
            value = FALLBACK_PROXIES_TEXT
        try:
            return str(value or "")
        except:
            return str(FALLBACK_PROXIES_TEXT)

    def _create_hardcoded_proxies_subpage(self):
        return [
            Header(text="Редактор встроенных прокси"),
            Text(text="Одна ссылка в строке (tg://proxy или https://t.me/proxy...)"),
            EditText(
                key="hardcoded_proxies_text",
                hint="Вставьте список прокси",
                default=self._get_hardcoded_proxies_text(),
                multiline=True,
                max_length=30000,
            ),
            Divider(),
            Text(
                text="Сбросить к стандартным",
                red=True,
                on_click=lambda *a: self._reset_hardcoded_proxies_to_default(),
            ),
            Text(
                text="Применить и найти прокси",
                accent=True,
                on_click=lambda *a: self._force_update(),
            ),
        ]

    def _reset_hardcoded_proxies_to_default(self):
        try:
            self.set_setting("hardcoded_proxies_text", str(FALLBACK_PROXIES_TEXT), reload_settings=True)
        except:
            pass
        BulletinHelper.show_success("Стандартные прокси восстановлены")

    def _collect_provider_proxy_map_sync(self, timeout_sec=2.5):
        out = {}
        for i in range(self._provider_count()):
            try:
                out[int(i)] = self._collect_proxies_for_provider(i, timeout_sec=timeout_sec)
            except:
                out[int(i)] = []
        return out

    def _choose_best_provider_auto_sync(self, provider_proxy_map, preferred_idx):
        best_idx = None
        best_score = None
        provider_scores = {}
        lock = threading.Lock()
        threads = []

        def _worker(provider_idx):
            proxies = list(provider_proxy_map.get(provider_idx, []) or [])
            if not proxies:
                try:
                    lock.acquire()
                    provider_scores[int(provider_idx)] = None
                finally:
                    try:
                        lock.release()
                    except:
                        pass
                return

            score_values = []
            random.shuffle(proxies)
            sample_cap = min(int(AUTO_PROVIDER_MAX_SAMPLES_PER_PROVIDER), len(proxies))
            for proxy in proxies[:sample_cap]:
                dt = self._probe_proxy_latency(proxy, timeout_sec=float(AUTO_PROVIDER_PING_TIMEOUT_SEC))
                if dt is not None:
                    score_values.append(float(dt))

            score = self._provider_latency_score(score_values)
            if score is None:
                score = 999999.0

            try:
                lock.acquire()
                provider_scores[int(provider_idx)] = float(score)
            finally:
                try:
                    lock.release()
                except:
                    pass

        for idx in range(self._provider_count()):
            try:
                t = threading.Thread(target=_worker, args=(int(idx),), daemon=True)
                t.start()
                threads.append(t)
            except:
                try:
                    provider_scores[int(idx)] = None
                except:
                    pass

        deadline = time.time() + float(AUTO_PROVIDER_SELECT_DEADLINE_SEC)
        for t in threads:
            try:
                remain = float(deadline - time.time())
                if remain <= 0:
                    break
                t.join(timeout=remain)
            except:
                pass

        for idx in range(self._provider_count()):
            try:
                score = provider_scores.get(int(idx), None)
            except:
                score = None
            if score is None:
                continue
            if best_score is None or float(score) < float(best_score):
                best_score = float(score)
                best_idx = int(idx)

        if best_idx is not None:
            return int(best_idx)
        if provider_proxy_map.get(preferred_idx):
            return int(preferred_idx)
        for idx in range(self._provider_count()):
            if provider_proxy_map.get(idx):
                return int(idx)
        return int(preferred_idx)

    def _build_probe_subset(self, proxies, limit=12):
        try:
            max_items = int(limit)
        except:
            max_items = 12
        if max_items <= 0:
            return []

        items = list(proxies or [])
        if not items:
            return []

        random.shuffle(items)

        grouped = {}
        for p in items:
            try:
                idx = int(p.get("provider_idx"))
            except:
                idx = None
            if idx is None:
                continue
            if idx not in grouped:
                grouped[idx] = []
            grouped[idx].append(p)

        if len(grouped) <= 1:
            return items[:max_items]

        provider_order = list(grouped.keys())
        random.shuffle(provider_order)
        subset = []

        for idx in provider_order:
            if len(subset) >= max_items:
                break
            arr = grouped.get(idx, [])
            if not arr:
                continue
            random.shuffle(arr)
            subset.append(arr.pop())

        leftovers = []
        for idx in provider_order:
            leftovers.extend(grouped.get(idx, []))
        random.shuffle(leftovers)

        used = set(id(x) for x in subset)
        for p in leftovers:
            if len(subset) >= max_items:
                break
            if id(p) in used:
                continue
            subset.append(p)
            used.add(id(p))

        if len(subset) < max_items:
            for p in items:
                if len(subset) >= max_items:
                    break
                if id(p) in used:
                    continue
                subset.append(p)
                used.add(id(p))

        return subset

    def _collect_proxies_for_provider(self, provider_idx, timeout_sec=5.0):
        try:
            idx = int(provider_idx)
        except:
            idx = 0

        urls = list(PROXY_PROVIDER_URLS.get(idx, []) or [])
        provider_name = self._provider_name(idx)
        proxies = []

        for url in urls:
            fetched = self._fetch_proxies_from_url(url, timeout_sec=timeout_sec)
            if fetched:
                for proxy in fetched:
                    try:
                        item = {
                            "server": str(proxy.get("server", "")),
                            "port": int(proxy.get("port", 0)),
                            "username": str(proxy.get("username", "")),
                            "password": str(proxy.get("password", "")),
                            "secret": str(proxy.get("secret", "")),
                            "kind": str(proxy.get("kind", "mtproto")),
                            "provider_idx": idx,
                            "provider_name": provider_name,
                        }
                        if item["server"] and item["port"] > 0 and (item["secret"] or item["kind"] == "socks"):
                            proxies.append(item)
                    except:
                        pass

        try:
            provider_fallback = str(PROXY_PROVIDER_FALLBACK_TEXT.get(idx, "") or "")
        except:
            provider_fallback = ""

        if provider_fallback:
            fallback_from_provider = self._parse_proxies(provider_fallback)
            for proxy in fallback_from_provider:
                try:
                    item = {
                        "server": str(proxy.get("server", "")),
                        "port": int(proxy.get("port", 0)),
                        "username": str(proxy.get("username", "")),
                        "password": str(proxy.get("password", "")),
                        "secret": str(proxy.get("secret", "")),
                        "kind": str(proxy.get("kind", "mtproto")),
                        "provider_idx": idx,
                        "provider_name": provider_name,
                    }
                    if item["server"] and item["port"] > 0 and (item["secret"] or item["kind"] == "socks"):
                        proxies.append(item)
                except:
                    pass

        if idx == 0:
            fallback_proxies = self._parse_proxies(self._get_hardcoded_proxies_text())
            if fallback_proxies:
                for proxy in fallback_proxies:
                    try:
                        item = {
                            "server": str(proxy.get("server", "")),
                            "port": int(proxy.get("port", 0)),
                            "username": str(proxy.get("username", "")),
                            "password": str(proxy.get("password", "")),
                            "secret": str(proxy.get("secret", "")),
                            "kind": str(proxy.get("kind", "mtproto")),
                            "provider_idx": idx,
                            "provider_name": provider_name,
                        }
                        if item["server"] and item["port"] > 0 and (item["secret"] or item["kind"] == "socks"):
                            proxies.append(item)
                    except:
                        pass

        dedup = {}
        for proxy in proxies:
            key = self._proxy_key(
                proxy.get("server"),
                proxy.get("port"),
                proxy.get("secret"),
                proxy.get("username"),
                proxy.get("password"),
            )
            if key not in dedup:
                dedup[key] = proxy

        return list(dedup.values())

    def _collect_providers_parallel(self, timeout_sec=3.5):
        out = {}
        lock = threading.Lock()
        threads = []

        def _worker(i):
            prox = self._collect_proxies_for_provider(i, timeout_sec=timeout_sec)
            try:
                lock.acquire()
                out[int(i)] = prox
            finally:
                try:
                    lock.release()
                except:
                    pass

        for i in range(self._provider_count()):
            t = threading.Thread(target=_worker, args=(i,))
            t.start()
            threads.append(t)

        for t in threads:
            try:
                t.join()
            except:
                pass

        return out

    def _probe_proxy_latency(self, proxy, timeout_sec=2.0):
        try:
            host = str(proxy.get("server", ""))
            port = int(proxy.get("port", 0))
            if not host or port <= 0:
                return None

            start = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(float(timeout_sec))
            res = sock.connect_ex((host, port))
            sock.close()
            if res != 0:
                return None
            return (time.time() - start) * 1000.0
        except:
            return None

    def _measure_provider_stats_async(self, provider_proxy_map):
        stats = {}
        lock = threading.Lock()
        index_lock = threading.Lock()
        threads = []
        tasks = []

        for _, proxies in provider_proxy_map.items():
            for proxy in proxies or []:
                tasks.append(proxy)

        if not tasks:
            return stats

        cursor = {"i": 0}

        def _worker():
            while True:
                proxy = None
                try:
                    index_lock.acquire()
                    i = int(cursor["i"])
                    if i >= len(tasks):
                        return
                    proxy = tasks[i]
                    cursor["i"] = i + 1
                finally:
                    try:
                        index_lock.release()
                    except:
                        pass

                dt = self._probe_proxy_latency(proxy, timeout_sec=0.9)
                if dt is None:
                    continue

                try:
                    idx = int(proxy.get("provider_idx", 0))
                except:
                    idx = 0

                try:
                    lock.acquire()
                    if idx not in stats:
                        stats[idx] = []
                    stats[idx].append(float(dt))
                finally:
                    try:
                        lock.release()
                    except:
                        pass

        worker_count = min(24, len(tasks))
        if worker_count <= 0:
            return stats
        for _ in range(worker_count):
            t = threading.Thread(target=_worker)
            t.start()
            threads.append(t)

        for t in threads:
            try:
                t.join()
            except:
                pass

        return stats

    def _provider_latency_score(self, samples):
        if not samples:
            return None
        try:
            ordered = sorted(float(x) for x in samples)
        except:
            return None
        if not ordered:
            return None

        take = min(7, len(ordered))
        if take <= 0:
            return None
        best_chunk = ordered[:take]
        avg = sum(best_chunk) / float(len(best_chunk))
        reliability_bonus = min(12, len(ordered))
        return avg - (0.5 * float(reliability_bonus))

    def _choose_best_provider_auto(self, provider_proxy_map, preferred_idx):
        stats = self._measure_provider_stats_async(provider_proxy_map)

        best_idx = None
        best_score = None
        for idx in range(self._provider_count()):
            samples = stats.get(idx, [])
            score = self._provider_latency_score(samples)
            if score is None:
                continue
            if best_score is None or score < best_score:
                best_score = score
                best_idx = idx

        if best_idx is not None:
            return int(best_idx), stats

        # Fallbacks if latency probing failed everywhere.
        if provider_proxy_map.get(preferred_idx):
            return int(preferred_idx), stats
        for idx in range(self._provider_count()):
            if provider_proxy_map.get(idx):
                return int(idx), stats
        return int(preferred_idx), stats

    def _prune_proxy_state(self, now=None, valid_keys=None):
        if now is None:
            now = int(time.time())
        try:
            keys = list(self._proxy_state.keys())
        except:
            keys = []

        for k in keys:
            v = self._proxy_state.get(k, {})
            if not isinstance(v, dict):
                self._proxy_state.pop(k, None)
                continue
            last_used = int(v.get("last_used", 0) or 0)
            if last_used and (now - last_used) > PROXY_STATE_TTL_SEC:
                self._proxy_state.pop(k, None)
                continue
            if valid_keys is not None and k not in valid_keys:
                # If it's not in the current fetched list and hasn't been used recently, drop it.
                # Keep owned entries longer so we can always clean up remembered proxies.
                owned = False
                try:
                    owned = bool(v.get("owned", True))
                except:
                    owned = True
                if not owned:
                    if last_used == 0 or (now - last_used) > 24 * 60 * 60:
                        self._proxy_state.pop(k, None)

        # Cap size deterministically (oldest last_used first)
        try:
            if len(self._proxy_state) > MAX_TRACKED_PROXY_STATE:
                ordered = sorted(self._proxy_state.items(), key=lambda kv: int((kv[1] or {}).get("last_used", 0) or 0))
                for k, _ in ordered[: max(0, len(self._proxy_state) - MAX_TRACKED_PROXY_STATE)]:
                    self._proxy_state.pop(k, None)
        except:
            pass

    def _should_skip_proxy_due_to_failures(self, key, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            return False
        failures = int(v.get("failures", 0) or 0)
        fail_ts = int(v.get("fail_ts", 0) or 0)
        if failures >= PROXY_FAIL_THRESHOLD and fail_ts and (now - fail_ts) < PROXY_FAIL_TTL_SEC:
            return True
        return False

    def _mark_proxy_failed(self, key, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            v = {"owned": True, "last_used": 0, "failures": 0, "fail_ts": 0}
            self._proxy_state[key] = v
        try:
            v["failures"] = int(v.get("failures", 0) or 0) + 1
        except:
            v["failures"] = 1
        v["fail_ts"] = now

    def _mark_proxy_success(self, key, owned, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            v = {}
            self._proxy_state[key] = v
        v["owned"] = bool(owned)
        v["last_used"] = now
        v["failures"] = 0
        v["fail_ts"] = 0

    def _load_proxy_list_safe(self):
        try:
            if hasattr(SharedConfig, "loadProxyList"):
                SharedConfig.loadProxyList()
        except:
            pass

    def _shared_proxy_list_snapshot(self):
        try:
            self._load_proxy_list_safe()
        except:
            pass

        try:
            pl = SharedConfig.proxyList
        except:
            return []

        out = []

        try:
            size = pl.size()
        except:
            size = None

        if size is not None:
            for i in range(int(size)):
                try:
                    out.append(pl.get(i))
                except:
                    pass
            return out

        try:
            for p in pl:
                out.append(p)
        except:
            pass

        return out

    def _find_proxy_in_shared_list(self, key):
        for p in self._shared_proxy_list_snapshot():
            try:
                k = self._proxy_key(
                    p.address,
                    p.port,
                    p.secret,
                    getattr(p, "username", ""),
                    getattr(p, "password", ""),
                )
                if k == key:
                    return p
            except:
                continue
        return None

    def _cleanup_plugin_proxies_from_shared_list(self, keep_current=True):
        try:
            self._load_proxy_list_safe()

            current = None
            try:
                current = SharedConfig.currentProxy
            except:
                current = None

            removed_any = False
            for p in self._shared_proxy_list_snapshot():
                try:
                    if keep_current and current is not None and p == current:
                        continue
                    key = self._proxy_key(
                        p.address,
                        p.port,
                        p.secret,
                        getattr(p, "username", ""),
                        getattr(p, "password", ""),
                    )
                    v = self._proxy_state.get(key)
                    if not isinstance(v, dict):
                        continue
                    if not bool(v.get("owned", True)):
                        continue
                    try:
                        if hasattr(SharedConfig, "deleteProxy"):
                            SharedConfig.deleteProxy(p)
                        else:
                            SharedConfig.proxyList.remove(p)
                            if hasattr(SharedConfig, "saveProxyList"):
                                SharedConfig.saveProxyList()
                    except:
                        continue
                    removed_any = True
                except:
                    continue

            # Keep the state map in sync: drop keys that no longer exist in list and are not current.
            if removed_any:
                try:
                    existing = set()
                    for p in self._shared_proxy_list_snapshot():
                        try:
                            existing.add(
                                self._proxy_key(
                                    p.address,
                                    p.port,
                                    p.secret,
                                    getattr(p, "username", ""),
                                    getattr(p, "password", ""),
                                )
                            )
                        except:
                            pass
                    if keep_current and current is not None:
                        try:
                            existing.add(
                                self._proxy_key(
                                    current.address,
                                    current.port,
                                    current.secret,
                                    getattr(current, "username", ""),
                                    getattr(current, "password", ""),
                                )
                            )
                        except:
                            pass
                    for k in list(self._proxy_state.keys()):
                        if k not in existing:
                            # Keep non-owned entries (they might refer to user proxies)
                            v = self._proxy_state.get(k)
                            if isinstance(v, dict) and bool(v.get("owned", True)):
                                self._proxy_state.pop(k, None)
                except:
                    pass

            try:
                if removed_any:
                    self._save_config()
            except:
                pass
        except:
            pass

    def on_plugin_load(self):
        self._active = True

        try:
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.CHAT_ACTION_MENU,
                    item_id="greenpass_settings_open",
                    text="Настройки GreenPass",
                    icon="msg_settings",
                    priority=1000,
                    on_click=self._open_plugin_settings,
                )
            )
        except:
            pass

        self._install_proxy_button_hooks()
        self._install_sync_hooks()
        self._refresh_current_dialogs_proxy_button()
        self._start_thread()
        
        try:
            mc_class = find_class("org.telegram.messenger.MessagesController")
            if mc_class:
                self.hook_all_methods(mc_class, "sortDialogs", HideProxySponsorDialogHook())

            for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                run_on_ui_thread(lambda i=i: NotificationCenter.getInstance(i).postNotificationName(NotificationCenter.dialogsNeedReload))

            self._maybe_hide_proxy_sponsor_dialog()
        except Exception as e:
            print(f"Hook Error: {e}")

    def _install_redirect_hooks(self):
        return

    def _install_sync_hooks(self):
        if self._sync_hooks_installed:
            return
        try:
            NC = find_class("org.telegram.messenger.NotificationCenter")
            if NC:
                try:
                    self.hook_all_methods(NC, "postNotificationName", _ProxySettingsChangedNotifyHook(self))
                except:
                    pass
            self._sync_hooks_installed = True
        except:
            pass

    def _install_proxy_button_hooks(self):
        if self._proxy_button_hooks_installed:
            return
        try:
            DA = find_class("org.telegram.ui.DialogsActivity")
            if not DA:
                return
            try:
                self.hook_all_methods(DA, "updateProxyButton", _ForceDialogsProxyButtonHook(self))
            except:
                pass
            try:
                self.hook_all_methods(DA, "showSearch", _DialogsShowSearchForceProxyHook(self))
            except:
                pass
            try:
                self.hook_all_methods(DA, "showDoneItem", _DialogsShowDoneItemForceProxyHook(self))
            except:
                pass
            self._proxy_button_hooks_installed = True
        except:
            pass

    def _open_plugin_settings(self, context):
        def _run():
            try:
                PC = find_class("com.exteragram.messenger.plugins.PluginsController")
                if not PC:
                    return

                ids = ["greenpass", "GreenPass"]
                try:
                    ids.append(str(__id__))
                except:
                    pass
                try:
                    ids.append(str(__name__))
                except:
                    pass

                seen = set()
                for pid in ids:
                    try:
                        x = str(pid or "")
                    except:
                        x = ""
                    if not x or x in seen:
                        continue
                    seen.add(x)
                    try:
                        r = PC.openPluginSettings(x)
                        if bool(r):
                            return
                    except:
                        pass
            except:
                pass

        try:
            run_on_ui_thread(_run)
        except:
            _run()

    def _refresh_current_dialogs_proxy_button(self):
        try:
            frag = get_last_fragment()
            if frag is None:
                return
            try:
                n = str(frag.getClass().getName() or "")
            except:
                n = ""
            if n == "org.telegram.ui.DialogsActivity":
                _force_show_dialogs_proxy_button(frag)
        except:
            pass

    def _on_provider_changed(self, idx):
        try:
            i = int(idx)
        except:
            i = 0
        if i < 0 or i >= self._provider_count():
            i = 0
        self._set_selected_provider(i)
        self._set_provider_auto(False)
        self._last_provider_name = self._provider_name(i)
        self._refresh_settings_without_reopen()
        self._force_update()

    def _on_provider_auto_changed(self, enabled):
        self._set_provider_auto(bool(enabled))
        self._refresh_settings_without_reopen()
        self._force_update()

    def _on_use_proxy_changed(self, enabled):
        val = bool(enabled)
        _set_tg_proxy_enabled(val)
        try:
            self.set_setting("use_proxy", val, reload_settings=True)
        except:
            pass

        if val:
            try:
                if SharedConfig.currentProxy is None:
                    self._force_update()
            except:
                self._force_update()

        self._refresh_settings_without_reopen()
        self._refresh_current_dialogs_proxy_button()

    def on_plugin_unload(self):
        self._active = False
        # Remove remembered proxies created by this plugin (keep current to avoid surprising users).
        try:
            self._cleanup_plugin_proxies_from_shared_list(keep_current=True)
        except:
            pass
        run_on_ui_thread(lambda: BulletinHelper.show_info("🔴 GreenPass остановлен"))

    def on_app_event(self, event):
        # Показываем диалог при открытии приложения/плагина, если еще не показывали
        if event == AppEvent.RESUME or event == AppEvent.START:
            self._install_proxy_button_hooks()
            self._install_sync_hooks()
            self._refresh_current_dialogs_proxy_button()

            if not self._sub_dialog_shown:
                # Небольшая задержка, чтобы Activity успела появиться
                threading.Thread(target=self._delayed_show_dialog, daemon=True).start()

            self._maybe_hide_proxy_sponsor_dialog()

    def _maybe_hide_proxy_sponsor_dialog(self):
        try:
            now = int(time.time())
            if now - int(self._last_proxy_sponsor_hide or 0) < 30:
                return

            prefs = MessagesController.getGlobalMainSettings()
            promo_id = int(prefs.getLong("proxy_dialog", 0))
            promo_type = int(prefs.getInt("promo_dialog_type", -1))
            proxy_type = int(getattr(MessagesController, "PROMO_TYPE_PROXY", 0))
            if promo_id == 0 or promo_type != proxy_type:
                return

            self._last_proxy_sponsor_hide = now

            def _hide_all():
                for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                    try:
                        mc = MessagesController.getInstance(i)
                        if not mc:
                            continue

                        try:
                            from hook_utils import get_private_field, set_private_field
                            promo_dialog = None
                            try:
                                promo_dialog = get_private_field(mc, "promoDialog")
                            except:
                                promo_dialog = None
                            if promo_dialog is None:
                                try:
                                    promo_dialog = mc.dialogs_dict.get(promo_id)
                                except:
                                    promo_dialog = None
                                if promo_dialog is not None:
                                    try:
                                        set_private_field(mc, "promoDialog", promo_dialog)
                                    except:
                                        pass
                        except:
                            pass

                        try:
                            if hasattr(mc, "hidePromoDialog"):
                                mc.hidePromoDialog()
                        except:
                            pass
                    except:
                        pass

            run_on_ui_thread(_hide_all)
        except:
            pass

    def _delayed_show_dialog(self):
        time.sleep(2)
        run_on_ui_thread(self._show_subscription_dialog)

    def _show_subscription_dialog(self):
        if self._sub_dialog_shown: 
            return
        
        try:
            # Получаем контекст правильным способом по документации Exteragram
            fragment = get_last_fragment()
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return

            # Используем AlertDialogBuilder из ui.alert
            builder = AlertDialogBuilder(activity)
            builder.set_title("Подписка на разработчика")
            builder.set_message("Для поддержки разработки плагина, пожалуйста, подпишитесь на канал @AltyPlugins.")
            
            def on_subscribe(bld, which):
                try:
                    # Открываем канал внутри приложения через deep link
                    self._open_channel_internal(activity)
                    BulletinHelper.show_success("Спасибо за подписку!")
                except Exception as e:
                    BulletinHelper.show_error(f"Ошибка: {e}")
                
                self._sub_dialog_shown = True
                self._save_config()
                bld.dismiss()

            def on_cancel(bld, which):
                self._sub_dialog_shown = True
                self._save_config()
                bld.dismiss()

            builder.set_positive_button("Подписаться", on_subscribe)
            builder.set_negative_button("Позже", on_cancel)
            builder.set_cancelable(False)
            builder.show()
            
        except Exception as e:
            print(f"Dialog Error: {e}")
            import traceback
            traceback.print_exc()

    def _start_thread(self):
        if self._thread and self._thread.is_alive():
            return
        self._thread = threading.Thread(target=self._worker, daemon=True)
        self._thread.start()

    def _worker(self):
        time.sleep(2)
        self._update_proxy_logic()

        last_refresh = time.time()
        last_health_check = time.time()
        last_precheck = 0

        while self._active:
            try:
                time.sleep(30)

                now = time.time()

                if now - last_health_check >= 180:
                    last_health_check = now
                    try:
                        preferences = MessagesController.getGlobalMainSettings()
                        enabled = preferences.getBoolean("proxy_enabled", False)
                        if not enabled:
                            continue
                        if enabled and SharedConfig.currentProxy is not None:
                            state = ConnectionsManager.getInstance(UserConfig.selectedAccount).getConnectionState()
                            if state != 3:
                                self._update_proxy_logic(force=True)
                    except Exception as e:
                        print(f"HealthCheck Error: {e}")

                if now - last_refresh >= 1800:
                    last_refresh = now
                    self._update_proxy_logic()

                if now - last_precheck >= float(PRECHECK_INTERVAL_SEC):
                    last_precheck = now
                    self._background_precheck()

            except Exception as e:
                print(f"Worker Error: {e}")
                time.sleep(60)

    def _update_proxy_logic(self, force=False):
        if self._finding_proxy:
            if not force:
                return
            wait_left = 2.0
            while self._finding_proxy and wait_left > 0 and self._active:
                time.sleep(0.2)
                wait_left -= 0.2
            if self._finding_proxy:
                return
        self._finding_proxy = True
        
        try:
            provider_auto = self._get_provider_auto()
            selected_provider = self._get_selected_provider()

            provider_proxy_map = {}
            merged_provider_proxies = []
            selected_provider_proxies = []

            if provider_auto:
                provider_proxy_map = self._collect_provider_proxy_map_sync(timeout_sec=2.5)
                chosen_provider = self._choose_best_provider_auto_sync(provider_proxy_map, selected_provider)
                selected_provider = chosen_provider
                self._set_selected_provider(chosen_provider)
                selected_provider_proxies = list(provider_proxy_map.get(chosen_provider, []) or [])
                merged_provider_proxies = self._merge_unique_proxies([provider_proxy_map.get(idx, []) or [] for idx in range(self._provider_count())])
            else:
                selected_provider_proxies = self._collect_proxies_for_provider(selected_provider, timeout_sec=5.0)
                merged_provider_proxies = self._merge_unique_proxies([selected_provider_proxies])

            fallback_chain = self._build_safe_fallback_chain(selected_provider_proxies, merged_provider_proxies)
            chain_for_prune = self._merge_unique_proxies([items for _, items in fallback_chain])

            # Prune plugin state based on current fetched list.
            try:
                now_ts = int(time.time())
                valid_keys = set()
                for p in chain_for_prune:
                    try:
                        valid_keys.add(
                            self._proxy_key(
                                p.get("server"),
                                p.get("port"),
                                p.get("secret"),
                                p.get("username"),
                                p.get("password"),
                            )
                        )
                    except:
                        pass
                self._prune_proxy_state(now=now_ts, valid_keys=valid_keys)
                self._save_config()
            except:
                pass

            if not chain_for_prune:
                self._refresh_settings_without_reopen()
                run_on_ui_thread(lambda: BulletinHelper.show_error("Не удалось найти прокси"))
                return

            working_proxy = None
            for _, candidate_list in fallback_chain:
                if not candidate_list:
                    continue
                working_proxy = self._find_fastest_proxy(candidate_list)
                if working_proxy:
                    break

            if working_proxy:
                self._current_server = working_proxy['server']
                self._current_port = working_proxy['port']
                self._current_secret = working_proxy['secret']
                try:
                    selected_provider = int(working_proxy.get("provider_idx", selected_provider))
                except:
                    pass
                self._set_selected_provider(selected_provider)
                self._last_provider_name = str(working_proxy.get("provider_name", self._provider_name(selected_provider)))
                self._last_working_proxy = self._normalize_proxy_dict(working_proxy)
                try:
                    self._refresh_hot_proxy_cache([working_proxy])
                except:
                    pass
                self._save_config()

                provider_name = self._last_provider_name or self._provider_name(selected_provider)
                self._refresh_settings_without_reopen()
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"Прокси установлен: {self._current_server} ({provider_name}, Ping: {int(working_proxy.get('latency', 0))}ms)"))
            else:
                self._refresh_settings_without_reopen()
                run_on_ui_thread(lambda: BulletinHelper.show_error("Нет доступных рабочих прокси"))
                
        finally:
            self._finding_proxy = False

    def _fetch_proxies_from_url(self, url, timeout_sec=5.0):
        try:
            req = urllib.request.Request(url)
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            
            with urllib.request.urlopen(req, timeout=float(timeout_sec), context=ctx) as resp:
                content = resp.read().decode('utf-8')
                return self._parse_proxies(content)
        except Exception as e:
            print(f"Fetch Error (urllib): {e}")

        # Fallback to requests (some hosts are flaky with urllib on Android builds).
        try:
            import requests
            r = requests.get(url, timeout=float(timeout_sec), verify=False)
            if int(getattr(r, "status_code", 0)) == 200:
                return self._parse_proxies(getattr(r, "text", "") or "")
        except Exception as e:
            print(f"Fetch Error (requests): {e}")

        return []

    def _parse_proxies(self, text):
        results = []

        try:
            from urllib.parse import urlparse, parse_qs
        except:
            return results

        if not text:
            return results

        tokens = []
        try:
            blob = str(text)
        except:
            blob = ""

        try:
            blob = blob.replace("\\/", "/").replace("\\u0026", "&").replace("&amp;", "&")
        except:
            pass

        if not blob:
            return results

        try:
            tokens.extend(re.findall(r"(?:tg://(?:proxy|socks)\?[^\s]+|https?://t\.me/(?:proxy|socks)\?[^\s]+)", blob))
        except:
            pass

        try:
            raw_queries = re.findall(r"(server=[^\s\"']+?&port=\d+[^\s\"']*)", blob)
        except:
            raw_queries = []
        for q in raw_queries:
            try:
                qq = str(q or "").strip().strip("\"'`")
                if not qq:
                    continue
                if "secret=" in qq:
                    tokens.append("tg://proxy?" + qq.lstrip("?"))
                else:
                    tokens.append("tg://socks?" + qq.lstrip("?"))
            except:
                pass

        for raw in blob.splitlines():
            try:
                s = str(raw or "").strip()
                if not s:
                    continue

                if "server=" in s and "port=" in s and ("secret=" in s or "user=" in s or "pass=" in s):
                    if "://" not in s:
                        if "secret=" in s:
                            s = "tg://proxy?" + s.lstrip("?")
                        else:
                            s = "tg://socks?" + s.lstrip("?")
                    tokens.append(s)
            except:
                pass

        dedup = set()
        for token in tokens:
            t = str(token or "").strip().rstrip('.,;)]')
            if not t or t in dedup:
                continue
            dedup.add(t)

            try:
                parsed = urlparse(t)
                target = ""
                if str(parsed.scheme).lower() == "tg":
                    target = str(parsed.netloc or parsed.path or "").strip("/").lower()
                else:
                    target = str(parsed.path or "").strip("/").lower()

                q = parse_qs(parsed.query)
                server = str((q.get("server") or [""])[0] or "")
                port_s = str((q.get("port") or [""])[0] or "")
                secret = str((q.get("secret") or [""])[0] or "")
                user = str((q.get("user") or [""])[0] or "")
                password = str((q.get("pass") or q.get("password") or [""])[0] or "")

                if not server or not port_s:
                    continue

                try:
                    port = int(port_s)
                except:
                    continue

                kind = "socks" if "socks" in target else "mtproto"
                if kind == "mtproto" and not secret:
                    continue

                results.append({
                    "server": server,
                    "port": int(port),
                    "secret": secret,
                    "username": user,
                    "password": password,
                    "kind": kind,
                })
            except:
                pass

        return results

    def _check_latency(self, proxy, results):
        host = proxy['server']
        port = proxy['port']
        try:
            start = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1.2)
            res = sock.connect_ex((host, port))
            sock.close()
            end = time.time()
            if res == 0:
                proxy['latency'] = (end - start) * 1000 # ms
                results.append(proxy)
        except:
            pass

    def _find_fastest_proxy(self, proxies):
        working_proxies = []

        subset = self._build_probe_subset(proxies, limit=12)

        for proxy in subset:
            if not self._active:
                break
            dt = self._probe_proxy_latency(proxy, timeout_sec=0.8)
            if dt is None:
                continue
            try:
                proxy["latency"] = float(dt)
            except:
                proxy["latency"] = 999999.0
            working_proxies.append(proxy)

        working_proxies.sort(key=lambda x: x['latency'])

        now_ts = int(time.time())
        max_verify = min(6, len(working_proxies))
        for proxy in working_proxies[:max_verify]:
            key = self._proxy_key(
                proxy.get("server"),
                proxy.get("port"),
                proxy.get("secret"),
                proxy.get("username"),
                proxy.get("password"),
            )
            if self._should_skip_proxy_due_to_failures(key, now=now_ts):
                continue
            if self._apply_and_verify(proxy, key=key):
                return proxy
                 
        return None

    def _apply_and_verify(self, proxy, key=None):
        if key is None:
            key = self._proxy_key(
                proxy.get("server"),
                proxy.get("port"),
                proxy.get("secret"),
                proxy.get("username"),
                proxy.get("password"),
            )

        ok = self._apply_proxy_settings(proxy, key=key)
        if ok:
            try:
                # Если за 2с не вышли в CONNECTED, считаем прокси нерабочим
                # и переходим к следующему кандидату.
                time.sleep(float(PROXY_CONNECT_VERIFY_WAIT_SEC))
            except:
                pass

            state = None
            try:
                cm = ConnectionsManager.getInstance(UserConfig.selectedAccount)
                if cm is not None:
                    state = int(cm.getConnectionState())
            except:
                state = None

            connected_state = 3
            try:
                connected_state = int(getattr(ConnectionsManager, "ConnectionStateConnected", 3))
            except:
                connected_state = 3

            if state == connected_state or state == 3:
                return True

        try:
            self._mark_proxy_failed(key, now=int(time.time()))
            self._save_config()
        except:
            pass
        return False

    def _apply_proxy_settings(self, pd, key=None):
        srv = pd.get("server")
        prt = int(pd.get("port", 0))
        usr = str(pd.get("username", "") or "")
        pwd = str(pd.get("password", "") or "")
        sec = pd.get("secret", "")

        if key is None:
            key = self._proxy_key(srv, prt, sec, usr, pwd)
        
        try:
            pi = None

            # Ensure we don't accumulate remembered proxies across verification attempts.
            # Remove previously created plugin proxies before adding a new one.
            try:
                self._cleanup_plugin_proxies_from_shared_list(keep_current=False)
            except:
                pass

            existed_before = False
            try:
                existed_before = self._find_proxy_in_shared_list(key) is not None
            except:
                existed_before = False
            try:
                from hook_utils import find_class
                PC = find_class("org.telegram.messenger.SharedConfig$ProxyInfo")
                if PC:
                    ctor_getter = getattr(PC, "getConstructor", None) or getattr(PC, "getDeclaredConstructor", None)
                    if ctor_getter:
                        ct = ctor_getter(str, int, str, str, str)
                        pi_candidate = ct.newInstance(srv, prt, usr, pwd, sec)
                        try:
                            pi = SharedConfig.addProxy(pi_candidate)
                        except:
                            pi = pi_candidate
            except:
                pi = None

            if not pi:
                try:
                    pi_candidate = SharedConfig.ProxyInfo(srv, prt, usr, pwd, sec)
                    pi = SharedConfig.addProxy(pi_candidate)
                except:
                    pi = None

            if not pi:
                return False

            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    cm = ConnectionsManager.getInstance(ac)
                    if cm: cm.setProxySettings(True, srv, prt, usr, pwd, sec)
                except: pass
            
            # Обновляем SharedConfig
            if pi:
                SharedConfig.currentProxy = pi
                try:
                    if hasattr(SharedConfig, "saveProxyList"):
                        SharedConfig.saveProxyList()
                except:
                    pass

                try:
                    owned = not bool(existed_before)
                    self._mark_proxy_success(key, owned=owned, now=int(time.time()))
                    self._prune_proxy_state(now=int(time.time()))
                    self._save_config()
                except:
                    pass
            
            SharedConfig.proxyEnabled = True

            try:
                pr = MessagesController.getGlobalMainSettings()
                ed = pr.edit()
                ed.putBoolean("proxy_enabled", True)
                ed.putBoolean("proxy_enabled_calls", not bool(sec))
                ed.putString("proxy_ip", srv)
                ed.putString("proxy_user", usr)
                ed.putString("proxy_pass", pwd)
                ed.putInt("proxy_port", prt)
                ed.putString("proxy_secret", sec)
                ed.commit()
            except: pass

            try:
                ConnectionsManager.setProxySettings(True, srv, prt, usr, pwd, sec)
            except: pass

            try: NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except: pass

            return True
            
        except Exception as e:
            print(f"Apply Error: {e}")
            return False

    def create_settings(self):
        try:
            settings = [Header(text="Статус")]

            tg_proxy_enabled = bool(_is_tg_proxy_enabled())
            settings.append(Switch(
                key="use_proxy",
                text="Использовать прокси",
                default=bool(tg_proxy_enabled),
                subtext=None,
                icon="msg2_proxy_on" if bool(tg_proxy_enabled) else "msg2_proxy_off",
                on_change=self._on_use_proxy_changed,
            ))

            settings.append(Divider())

            enabled = False
            active_server = ""
            active_port = 0
            active_user = ""
            active_pass = ""
            active_secret = ""

            try:
                try:
                    enabled = bool(SharedConfig.isProxyEnabled())
                except:
                    prefs = MessagesController.getGlobalMainSettings()
                    enabled = prefs.getBoolean("proxy_enabled", False) and SharedConfig.currentProxy is not None

                if enabled and SharedConfig.currentProxy is not None:
                    active_server = str(SharedConfig.currentProxy.address)
                    active_port = int(SharedConfig.currentProxy.port)
                    active_user = str(getattr(SharedConfig.currentProxy, "username", "") or "")
                    active_pass = str(getattr(SharedConfig.currentProxy, "password", "") or "")
                    active_secret = str(SharedConfig.currentProxy.secret)
                else:
                    prefs = MessagesController.getGlobalMainSettings()
                    active_server = prefs.getString("proxy_ip", "")
                    active_port = prefs.getInt("proxy_port", 0)
                    active_user = prefs.getString("proxy_user", "")
                    active_pass = prefs.getString("proxy_pass", "")
                    active_secret = prefs.getString("proxy_secret", "")
            except:
                enabled = False

            if enabled and active_server:
                settings.append(Text(text=f"🟢 Активен: {active_server}:{active_port}"))
            else:
                settings.append(Text(text="🔴 Прокси не установлен"))

            provider_auto = self._get_provider_auto()
            selected_provider = self._get_selected_provider()

            settings.append(Divider())

            settings.append(Header(text="Провайдер прокси"))
            settings.append(Switch(
                key="proxy_provider_auto",
                text="Автовыбор провайдера",
                default=bool(provider_auto),
                subtext=None,
                icon="media_flip",
                on_change=self._on_provider_auto_changed,
            ))
            settings.append(Selector(
                key="proxy_provider",
                text="Выбор провайдера",
                default=int(selected_provider),
                items=list(PROXY_PROVIDER_ITEMS),
                icon="msg_list",
                on_change=self._on_provider_changed,
            ))
            settings.append(Text(
                text="Sponsored by @invisibleshrimp",
                on_click=lambda *a: self._open_sponsor_channel(),
            ))

            settings.append(Divider())

            settings.append(Header(text="Действия"))

            settings.append(Text(
                text="Редактировать встроенные прокси",
                icon="msg_settings",
                create_sub_fragment=self._create_hardcoded_proxies_subpage,
            ))

            settings.append(Text(
                text="Найти новый прокси",
                on_click=lambda *a: self._force_update()
            ))

            settings.append(Text(
                text="Очистить все прокси",
                on_click=lambda *a: self._confirm_clear_all_proxies()
            ))

            if enabled and active_server:
                if active_secret:
                    link = f"https://t.me/proxy?server={active_server}&port={active_port}&secret={active_secret}"
                else:
                    try:
                        from urllib.parse import quote
                        q_user = quote(str(active_user or ""), safe="")
                        q_pass = quote(str(active_pass or ""), safe="")
                    except:
                        q_user = str(active_user or "")
                        q_pass = str(active_pass or "")
                    link = f"tg://socks?server={active_server}&port={active_port}&user={q_user}&pass={q_pass}"
                settings.append(Text(
                    text="Скопировать текущий",
                    on_click=lambda *a: self._copy_link(link)
                ))

            settings.append(Divider())
            settings.append(Text(
                text="Подписаться на канал", 
                on_click=lambda *a: self._open_channel()
            ))
            
            return settings
        except Exception as e:
            return [Header(text="Ошибка"), Text(text=str(e))]

    def _force_update(self):
        BulletinHelper.show_info("Поиск прокси...")
        threading.Thread(target=lambda: self._update_proxy_logic(force=True), daemon=True).start()

    def _confirm_clear_all_proxies(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_error("Не удалось открыть диалог")
                return

            activity = fragment.getParentActivity()
            if not activity:
                BulletinHelper.show_error("Не удалось открыть диалог")
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title("Очистить все прокси?")
            builder.set_message("Будут удалены все сохраненные прокси в Telegram (включая добавленные вручную). Прокси будет выключен. Действие необратимо.")

            def on_yes(bld, which):
                try:
                    bld.dismiss()
                except:
                    pass
                BulletinHelper.show_info("Очистка прокси...")
                threading.Thread(target=self._clear_all_proxies, daemon=True).start()

            def on_no(bld, which):
                try:
                    bld.dismiss()
                except:
                    pass

            builder.set_positive_button("Очистить", on_yes)
            builder.set_negative_button("Отмена", on_no)
            builder.set_cancelable(True)
            builder.show()
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка: {e}")

    def _clear_all_proxies(self):
        deleted = 0
        try:
            self._load_proxy_list_safe()

            # Mirror Telegram's logic (ProxyListActivity delete-all): iterate over a snapshot.
            proxies = self._shared_proxy_list_snapshot()
            for p in proxies:
                try:
                    if hasattr(SharedConfig, "deleteProxy"):
                        SharedConfig.deleteProxy(p)
                        deleted += 1
                except:
                    pass

            # Hard reset (in case deleteProxy is missing or iteration bridges fail)
            try:
                if hasattr(SharedConfig, "proxyList"):
                    try:
                        SharedConfig.proxyList.clear()
                    except:
                        pass
                try:
                    SharedConfig.currentProxy = None
                except:
                    pass
                try:
                    if hasattr(SharedConfig, "saveProxyList"):
                        SharedConfig.saveProxyList()
                except:
                    pass
            except:
                pass

            # Ensure proxy is disabled and persisted list is cleared.
            try:
                pr = MessagesController.getGlobalMainSettings()
                ed = pr.edit()
                try:
                    ed.remove("proxy_list")
                except:
                    pass
                ed.putString("proxy_ip", "")
                ed.putString("proxy_pass", "")
                ed.putString("proxy_user", "")
                ed.putString("proxy_secret", "")
                ed.putInt("proxy_port", 1080)
                ed.putBoolean("proxy_enabled", False)
                ed.putBoolean("proxy_enabled_calls", False)
                ed.commit()
            except:
                pass
            try:
                SharedConfig.proxyEnabled = False
            except:
                pass

            try:
                ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
            except:
                pass

            try:
                self._proxy_state = {}
                self._save_config()
            except:
                pass

            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except:
                pass

            self._refresh_settings_without_reopen()

            run_on_ui_thread(lambda: BulletinHelper.show_success(f"Прокси очищены: {deleted}"))
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка очистки: {e}"))

    def _copy_link(self, link):
        try:
            from android.content import ClipData, Context
            ctx = ApplicationLoader.applicationContext
            clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
            clip = ClipData.newPlainText("Proxy Link", link)
            clipboard.setPrimaryClip(clip)
            BulletinHelper.show_success("Ссылка скопирована")
        except: pass
        
    def _open_channel(self):
        try:
            from android.content import Intent
            from android.net import Uri
            
            fragment = get_last_fragment()
            activity = None
            if fragment:
                activity = fragment.getParentActivity()
                
            if not activity:
                # Попытка получить LaunchActivity напрямую
                try:
                    from org.telegram.ui import LaunchActivity
                    activity = LaunchActivity.instance
                except: pass
                
            if activity:
                self._open_channel_internal(activity)
            else:
                # Fallback с использованием контекста приложения
                ctx = ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(intent)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка открытия: {e}")

    def _open_sponsor_channel(self):
        try:
            from android.content import Intent
            from android.net import Uri

            url = "https://t.me/invisibleshrimp"
            fragment = get_last_fragment()
            activity = None
            if fragment:
                activity = fragment.getParentActivity()

            if activity:
                Browser.openUrl(activity, Uri.parse(url))
                return

            ctx = ApplicationLoader.applicationContext
            intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            ctx.startActivity(intent)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка открытия: {e}")
    
    def _open_channel_internal(self, activity):
        try:
            from android.net import Uri
            deep_link = f"tg://resolve?domain={SUBSCRIBE_CHANNEL}"
            Browser.openUrl(activity, Uri.parse(deep_link))
        except Exception as e:
            from android.net import Uri
            # Пробуем через Intent напрямую если Browser.openUrl подвел
            try:
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
                activity.startActivity(intent)
            except:
                Browser.openUrl(activity, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
