__id__ = "GreenPass"
__name__ = "GreenPass"
__description__ = "–ü—ã—Ç–∞–µ—Ç—Å—è –±—ã—Ç—å —Ö–æ—Ä–æ—à–∏–º –ø—Ä–æ–∫—Å–∏ –ø–ª–∞–≥–∏–Ω–æ–º"
__author__ = "@Altyplugins / Antigravity"
__version__ = "1.1.5.9"
__icon__ = "Broit_d_by_fStikBot/37"
__min_version__ = "12.1.1"


import json
import threading
import urllib.request
import urllib.error
import time
import ssl
import random
import re
import os
import socket
from base_plugin import BasePlugin, AppEvent, MethodHook
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Text, Divider
from android_utils import run_on_ui_thread
from client_utils import get_last_fragment
from org.telegram.messenger import NotificationCenter, SharedConfig, MessagesController, UserConfig, ApplicationLoader
from org.telegram.messenger.browser import Browser
from org.telegram.tgnet import ConnectionsManager

# ================== CONFIGURATION ==================
GITHUB_PROXY_URL = "https://raw.githubusercontent.com/Argh94/Proxy-List/refs/heads/main/MTProto.txt"
SUBSCRIBE_CHANNEL = "AltyPlugins"

# Proxy cleanup / health policy
MAX_TRACKED_PROXY_STATE = 200
PROXY_STATE_TTL_SEC = 7 * 24 * 60 * 60
PROXY_FAIL_TTL_SEC = 6 * 60 * 60
PROXY_FAIL_THRESHOLD = 2

# Fallback proxies provided by user
FALLBACK_PROXIES_TEXT = """
https://t.me/proxy?server=146.185.210.204&port=443&secret=dd6b3fb04414dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.79.131&port=443&secret=dd6b3fb04444dbac55fef2da67c8c949
https://t.me/proxy?server=185.241.193.240&port=443&secret=dd6b3fb04414dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.79.120&port=443&secret=dd6b3fb04444dbac55fef2da67c8c949
https://t.me/proxy?server=146.185.208.135&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.93.104&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=212.233.77.95&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.216.171&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=185.130.115.156&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=185.130.113.138&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.213.38&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=90.156.213.122&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.255&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
https://t.me/proxy?server=83.166.254.200&port=443&secret=dd6b3fb02424dbac55fef2da67c8c949
"""

class HideProxySponsorDialogHook(MethodHook):
    _last_hide = {}

    def after_hooked_method(self, param):
        try:
            mc = param.thisObject
            if not mc:
                return

            proxy_type = 0
            try:
                proxy_type = int(getattr(MessagesController, "PROMO_TYPE_PROXY", 0))
            except:
                proxy_type = 0

            promo_type = None
            try:
                promo_type = int(mc.promoDialogType)
            except:
                promo_type = None

            promo_id = 0
            promo_type_pref = None
            try:
                prefs = MessagesController.getGlobalMainSettings()
                promo_id = int(prefs.getLong("proxy_dialog", 0))
                promo_type_pref = int(prefs.getInt("promo_dialog_type", -1))
            except:
                promo_id = 0
                promo_type_pref = None

            is_proxy_promo = False
            if promo_id != 0 and promo_type_pref is not None and promo_type_pref == proxy_type:
                is_proxy_promo = True
            elif promo_type is not None and promo_type == proxy_type:
                is_proxy_promo = True

            if not is_proxy_promo:
                return

            now = int(time.time())
            key = id(mc)
            last = int(HideProxySponsorDialogHook._last_hide.get(key, 0) or 0)
            if now - last < 30:
                return
            HideProxySponsorDialogHook._last_hide[key] = now

            def _hide():
                try:
                    from hook_utils import get_private_field, set_private_field

                    promo_dialog = None
                    try:
                        promo_dialog = get_private_field(mc, "promoDialog")
                    except:
                        promo_dialog = None

                    if promo_dialog is None and promo_id != 0:
                        try:
                            promo_dialog = mc.dialogs_dict.get(promo_id)
                        except:
                            promo_dialog = None
                        if promo_dialog is not None:
                            try:
                                set_private_field(mc, "promoDialog", promo_dialog)
                            except:
                                pass

                    if hasattr(mc, "hidePromoDialog"):
                        mc.hidePromoDialog()
                except:
                    pass

            run_on_ui_thread(_hide)
        except:
            pass

class SafeBypassPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._active = False
        self._thread = None

        self._last_proxy_sponsor_hide = 0
        
        # Current proxy state
        self._current_server = ""
        self._current_port = 0
        self._current_secret = ""
        self._sub_dialog_shown = False
        self._finding_proxy = False
        # Proxies added/managed by this plugin.
        # Stored as a dict keyed by "server:port:secret".
        # Value schema: {"owned": bool, "last_used": int, "failures": int, "fail_ts": int}
        self._proxy_state = {}
        
        # Config path
        try:
            ctx = ApplicationLoader.applicationContext
            self._config_file = os.path.join(ctx.getFilesDir().getAbsolutePath(), "safebypass_v2_config.json")
        except:
            self._config_file = "safebypass_v2_config.json"
            
        self._load_config()

    def _load_config(self):
        try:
            if os.path.exists(self._config_file):
                with open(self._config_file, 'r') as f:
                    data = json.load(f)
                    self._current_server = data.get("server", "")
                    self._current_port = data.get("port", 0)
                    self._current_secret = data.get("secret", "")
                    self._sub_dialog_shown = data.get("sub_dialog_shown", False)

                    # Backward compatible: older versions stored a list under plugin_proxies.
                    legacy_list = data.get("plugin_proxies", [])
                    state = data.get("plugin_proxy_state", None)
                    if isinstance(state, dict):
                        self._proxy_state = state
                    else:
                        self._proxy_state = {}

                    if isinstance(legacy_list, list):
                        for k in legacy_list:
                            if not isinstance(k, str):
                                continue
                            self._proxy_state.setdefault(k, {"owned": True, "last_used": 0, "failures": 0, "fail_ts": 0})

                    self._prune_proxy_state(now=int(time.time()))
        except Exception as e:
            print(f"Error loading config: {e}")

    def _save_config(self):
        try:
            data = {
                "server": self._current_server,
                "port": self._current_port,
                "secret": self._current_secret,
                "sub_dialog_shown": self._sub_dialog_shown,
                # Backward compatible key (list of keys). Keep small.
                "plugin_proxies": list(self._proxy_state.keys())[:MAX_TRACKED_PROXY_STATE],
                "plugin_proxy_state": self._proxy_state
            }
            with open(self._config_file, 'w') as f:
                json.dump(data, f)
        except Exception as e:
            print(f"Error saving config: {e}")

    def _proxy_key(self, server, port, secret):
        try:
            srv = str(server or "")
        except:
            srv = ""
        try:
            prt = int(port or 0)
        except:
            prt = 0
        try:
            sec = str(secret or "")
        except:
            sec = ""
        return f"{srv}:{prt}:{sec}"

    def _prune_proxy_state(self, now=None, valid_keys=None):
        if now is None:
            now = int(time.time())
        try:
            keys = list(self._proxy_state.keys())
        except:
            keys = []

        for k in keys:
            v = self._proxy_state.get(k, {})
            if not isinstance(v, dict):
                self._proxy_state.pop(k, None)
                continue
            last_used = int(v.get("last_used", 0) or 0)
            if last_used and (now - last_used) > PROXY_STATE_TTL_SEC:
                self._proxy_state.pop(k, None)
                continue
            if valid_keys is not None and k not in valid_keys:
                # If it's not in the current fetched list and hasn't been used recently, drop it.
                # Keep owned entries longer so we can always clean up remembered proxies.
                owned = False
                try:
                    owned = bool(v.get("owned", True))
                except:
                    owned = True
                if not owned:
                    if last_used == 0 or (now - last_used) > 24 * 60 * 60:
                        self._proxy_state.pop(k, None)

        # Cap size deterministically (oldest last_used first)
        try:
            if len(self._proxy_state) > MAX_TRACKED_PROXY_STATE:
                ordered = sorted(self._proxy_state.items(), key=lambda kv: int((kv[1] or {}).get("last_used", 0) or 0))
                for k, _ in ordered[: max(0, len(self._proxy_state) - MAX_TRACKED_PROXY_STATE)]:
                    self._proxy_state.pop(k, None)
        except:
            pass

    def _should_skip_proxy_due_to_failures(self, key, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            return False
        failures = int(v.get("failures", 0) or 0)
        fail_ts = int(v.get("fail_ts", 0) or 0)
        if failures >= PROXY_FAIL_THRESHOLD and fail_ts and (now - fail_ts) < PROXY_FAIL_TTL_SEC:
            return True
        return False

    def _mark_proxy_failed(self, key, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            v = {"owned": True, "last_used": 0, "failures": 0, "fail_ts": 0}
            self._proxy_state[key] = v
        try:
            v["failures"] = int(v.get("failures", 0) or 0) + 1
        except:
            v["failures"] = 1
        v["fail_ts"] = now

    def _mark_proxy_success(self, key, owned, now=None):
        if now is None:
            now = int(time.time())
        v = self._proxy_state.get(key)
        if not isinstance(v, dict):
            v = {}
            self._proxy_state[key] = v
        v["owned"] = bool(owned)
        v["last_used"] = now
        v["failures"] = 0
        v["fail_ts"] = 0

    def _load_proxy_list_safe(self):
        try:
            if hasattr(SharedConfig, "loadProxyList"):
                SharedConfig.loadProxyList()
        except:
            pass

    def _shared_proxy_list_snapshot(self):
        try:
            self._load_proxy_list_safe()
        except:
            pass

        try:
            pl = SharedConfig.proxyList
        except:
            return []

        out = []

        try:
            size = pl.size()
        except:
            size = None

        if size is not None:
            for i in range(int(size)):
                try:
                    out.append(pl.get(i))
                except:
                    pass
            return out

        try:
            for p in pl:
                out.append(p)
        except:
            pass

        return out

    def _find_proxy_in_shared_list(self, key):
        for p in self._shared_proxy_list_snapshot():
            try:
                k = self._proxy_key(p.address, p.port, p.secret)
                if k == key:
                    return p
            except:
                continue
        return None

    def _cleanup_plugin_proxies_from_shared_list(self, keep_current=True):
        try:
            self._load_proxy_list_safe()

            current = None
            try:
                current = SharedConfig.currentProxy
            except:
                current = None

            removed_any = False
            for p in self._shared_proxy_list_snapshot():
                try:
                    if keep_current and current is not None and p == current:
                        continue
                    key = self._proxy_key(p.address, p.port, p.secret)
                    v = self._proxy_state.get(key)
                    if not isinstance(v, dict):
                        continue
                    if not bool(v.get("owned", True)):
                        continue
                    try:
                        if hasattr(SharedConfig, "deleteProxy"):
                            SharedConfig.deleteProxy(p)
                        else:
                            SharedConfig.proxyList.remove(p)
                            if hasattr(SharedConfig, "saveProxyList"):
                                SharedConfig.saveProxyList()
                    except:
                        continue
                    removed_any = True
                except:
                    continue

            # Keep the state map in sync: drop keys that no longer exist in list and are not current.
            if removed_any:
                try:
                    existing = set()
                    for p in self._shared_proxy_list_snapshot():
                        try:
                            existing.add(self._proxy_key(p.address, p.port, p.secret))
                        except:
                            pass
                    if keep_current and current is not None:
                        try:
                            existing.add(self._proxy_key(current.address, current.port, current.secret))
                        except:
                            pass
                    for k in list(self._proxy_state.keys()):
                        if k not in existing:
                            # Keep non-owned entries (they might refer to user proxies)
                            v = self._proxy_state.get(k)
                            if isinstance(v, dict) and bool(v.get("owned", True)):
                                self._proxy_state.pop(k, None)
                except:
                    pass

            try:
                if removed_any:
                    self._save_config()
            except:
                pass
        except:
            pass

    def on_plugin_load(self):
        self._active = True
        self._start_thread()
        
        try:
            from hook_utils import find_class
            mc_class = find_class("org.telegram.messenger.MessagesController")
            if mc_class:
                self.hook_all_methods(mc_class, "sortDialogs", HideProxySponsorDialogHook())

            for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                run_on_ui_thread(lambda i=i: NotificationCenter.getInstance(i).postNotificationName(NotificationCenter.dialogsNeedReload))

            self._maybe_hide_proxy_sponsor_dialog()
        except Exception as e:
            print(f"Hook Error: {e}")

    def on_plugin_unload(self):
        self._active = False
        # Remove remembered proxies created by this plugin (keep current to avoid surprising users).
        try:
            self._cleanup_plugin_proxies_from_shared_list(keep_current=True)
        except:
            pass
        run_on_ui_thread(lambda: BulletinHelper.show_info("üî¥ GreenPass –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"))

    def on_app_event(self, event):
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è/–ø–ª–∞–≥–∏–Ω–∞, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–ª–∏
        if event == AppEvent.RESUME or event == AppEvent.START:
            if not self._sub_dialog_shown:
                # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞, —á—Ç–æ–±—ã Activity —É—Å–ø–µ–ª–∞ –ø–æ—è–≤–∏—Ç—å—Å—è
                threading.Thread(target=self._delayed_show_dialog, daemon=True).start()

            self._maybe_hide_proxy_sponsor_dialog()

    def _maybe_hide_proxy_sponsor_dialog(self):
        try:
            now = int(time.time())
            if now - int(self._last_proxy_sponsor_hide or 0) < 30:
                return

            prefs = MessagesController.getGlobalMainSettings()
            promo_id = int(prefs.getLong("proxy_dialog", 0))
            promo_type = int(prefs.getInt("promo_dialog_type", -1))
            proxy_type = int(getattr(MessagesController, "PROMO_TYPE_PROXY", 0))
            if promo_id == 0 or promo_type != proxy_type:
                return

            self._last_proxy_sponsor_hide = now

            def _hide_all():
                for i in range(UserConfig.MAX_ACCOUNT_COUNT):
                    try:
                        mc = MessagesController.getInstance(i)
                        if not mc:
                            continue

                        try:
                            from hook_utils import get_private_field, set_private_field
                            promo_dialog = None
                            try:
                                promo_dialog = get_private_field(mc, "promoDialog")
                            except:
                                promo_dialog = None
                            if promo_dialog is None:
                                try:
                                    promo_dialog = mc.dialogs_dict.get(promo_id)
                                except:
                                    promo_dialog = None
                                if promo_dialog is not None:
                                    try:
                                        set_private_field(mc, "promoDialog", promo_dialog)
                                    except:
                                        pass
                        except:
                            pass

                        try:
                            if hasattr(mc, "hidePromoDialog"):
                                mc.hidePromoDialog()
                        except:
                            pass
                    except:
                        pass

            run_on_ui_thread(_hide_all)
        except:
            pass

    def _delayed_show_dialog(self):
        time.sleep(2)
        run_on_ui_thread(self._show_subscription_dialog)

    def _show_subscription_dialog(self):
        if self._sub_dialog_shown: 
            return
        
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Exteragram
            fragment = get_last_fragment()
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º AlertDialogBuilder –∏–∑ ui.alert
            builder = AlertDialogBuilder(activity)
            builder.set_title("–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞")
            builder.set_message("–î–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø–ª–∞–≥–∏–Ω–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ –∫–∞–Ω–∞–ª @AltyPlugins.")
            
            def on_subscribe(bld, which):
                try:
                    # –û—Ç–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª –≤–Ω—É—Ç—Ä–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ deep link
                    self._open_channel_internal(activity)
                    BulletinHelper.show_success("–°–ø–∞—Å–∏–±–æ –∑–∞ –ø–æ–¥–ø–∏—Å–∫—É!")
                except Exception as e:
                    BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}")
                
                self._sub_dialog_shown = True
                self._save_config()
                bld.dismiss()

            def on_cancel(bld, which):
                self._sub_dialog_shown = True
                self._save_config()
                bld.dismiss()

            builder.set_positive_button("–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", on_subscribe)
            builder.set_negative_button("–ü–æ–∑–∂–µ", on_cancel)
            builder.set_cancelable(False)
            builder.show()
            
        except Exception as e:
            print(f"Dialog Error: {e}")
            import traceback
            traceback.print_exc()

    def _start_thread(self):
        if self._thread and self._thread.is_alive():
            return
        self._thread = threading.Thread(target=self._worker, daemon=True)
        self._thread.start()

    def _worker(self):
        time.sleep(2)
        self._update_proxy_logic()

        last_refresh = time.time()
        last_health_check = time.time()

        while self._active:
            try:
                time.sleep(30)

                now = time.time()

                if now - last_health_check >= 180:
                    last_health_check = now
                    try:
                        preferences = MessagesController.getGlobalMainSettings()
                        enabled = preferences.getBoolean("proxy_enabled", False)
                        if not enabled:
                            continue
                        if enabled and SharedConfig.currentProxy is not None:
                            state = ConnectionsManager.getInstance(UserConfig.selectedAccount).getConnectionState()
                            if state != 3:
                                self._update_proxy_logic(force=True)
                    except Exception as e:
                        print(f"HealthCheck Error: {e}")

                if now - last_refresh >= 1800:
                    last_refresh = now
                    self._update_proxy_logic()

            except Exception as e:
                print(f"Worker Error: {e}")
                time.sleep(60)

    def _update_proxy_logic(self, force=False):
        if self._finding_proxy: return
        self._finding_proxy = True
        
        try:
            proxies = []
            
            # 1. Fetch from GitHub
            github_proxies = self._fetch_proxies_from_url(GITHUB_PROXY_URL)
            if github_proxies:
                proxies.extend(github_proxies)
            
            # 2. Add Fallback proxies
            fallback_proxies = self._parse_proxies(FALLBACK_PROXIES_TEXT)
            if fallback_proxies:
                proxies.extend(fallback_proxies)

            # Prune plugin state based on current fetched list.
            try:
                now_ts = int(time.time())
                valid_keys = set()
                for p in proxies:
                    try:
                        valid_keys.add(self._proxy_key(p.get("server"), p.get("port"), p.get("secret")))
                    except:
                        pass
                self._prune_proxy_state(now=now_ts, valid_keys=valid_keys)
                self._save_config()
            except:
                pass
                
            if not proxies:
                run_on_ui_thread(lambda: BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø—Ä–æ–∫—Å–∏"))
                return

            # 3. Find FASTEST working proxy
            working_proxy = self._find_fastest_proxy(proxies)
            
            if working_proxy:
                self._current_server = working_proxy['server']
                self._current_port = working_proxy['port']
                self._current_secret = working_proxy['secret']
                self._save_config()

                def _reload_settings():
                    try:
                        self.set_setting("last_proxy_update", int(time.time()), reload_settings=True)
                    except:
                        pass

                run_on_ui_thread(_reload_settings)
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"–ü—Ä–æ–∫—Å–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {self._current_server} (Ping: {int(working_proxy.get('latency', 0))}ms)"))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_error("–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ä–∞–±–æ—á–∏—Ö –ø—Ä–æ–∫—Å–∏"))
                
        finally:
            self._finding_proxy = False

    def _fetch_proxies_from_url(self, url):
        try:
            req = urllib.request.Request(url)
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            
            with urllib.request.urlopen(req, timeout=10, context=ctx) as resp:
                content = resp.read().decode('utf-8')
                return self._parse_proxies(content)
        except Exception as e:
            print(f"Fetch Error: {e}")
            return []

    def _parse_proxies(self, text):
        regex = r"(?:server|server)=([^&]+)&(?:port|port)=(\d+)&(?:secret|secret)=([^&\s]+)"
        matches = re.findall(regex, text)
        results = []
        for match in matches:
            try:
                server, port, secret = match
                results.append({
                    "server": server,
                    "port": int(port),
                    "secret": secret
                })
            except: pass
        return results

    def _check_latency(self, proxy, results):
        host = proxy['server']
        port = proxy['port']
        try:
            start = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            res = sock.connect_ex((host, port))
            sock.close()
            end = time.time()
            if res == 0:
                proxy['latency'] = (end - start) * 1000 # ms
                results.append(proxy)
        except:
            pass

    def _find_fastest_proxy(self, proxies):
        threads = []
        working_proxies = []
        
        # Limit to 30 random proxies to avoid overload/timeouts
        random.shuffle(proxies)
        subset = proxies[:30]
        
        # Parallel ping
        for proxy in subset:
            if not self._active: break
            t = threading.Thread(target=self._check_latency, args=(proxy, working_proxies))
            t.start()
            threads.append(t)
            
        for t in threads:
            t.join()
            
        # Sort by latency (lowest first)
        working_proxies.sort(key=lambda x: x['latency'])
        
        # Verify connection with Telegram for the best ones
        now_ts = int(time.time())
        for proxy in working_proxies:
            key = self._proxy_key(proxy.get("server"), proxy.get("port"), proxy.get("secret"))
            if self._should_skip_proxy_due_to_failures(key, now=now_ts):
                continue
            if self._apply_and_verify(proxy, key=key):
                return proxy
                 
        return None

    def _apply_and_verify(self, proxy, key=None):
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–æ–∫—Å–∏
        if key is None:
            key = self._proxy_key(proxy.get("server"), proxy.get("port"), proxy.get("secret"))

        self._apply_proxy_settings(proxy, key=key)
        
        # –ñ–¥–µ–º 3 —Å–µ–∫—É–Ω–¥—ã –¥–ª—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
        for _ in range(6): # 6 * 0.5s = 3s
            if not self._active: return False
            time.sleep(0.5)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è Telegram
            # ConnectionState: 3 = CONNECTED
            state = ConnectionsManager.getInstance(UserConfig.selectedAccount).getConnectionState()
            if state == 3:
                return True
                 
        # Proxy didn't connect: mark as failing and remove it from remembered list if we created it.
        try:
            self._mark_proxy_failed(key, now=int(time.time()))
            self._save_config()
        except:
            pass

        try:
            v = self._proxy_state.get(key)
            if isinstance(v, dict) and bool(v.get("owned", True)):
                p = self._find_proxy_in_shared_list(key)
                if p is not None and hasattr(SharedConfig, "deleteProxy"):
                    SharedConfig.deleteProxy(p)
        except:
            pass

        return False

    def _apply_proxy_settings(self, pd, key=None):
        srv = pd.get("server")
        prt = int(pd.get("port", 0))
        sec = pd.get("secret", "")

        if key is None:
            key = self._proxy_key(srv, prt, sec)
        
        try:
            pi = None

            # Ensure we don't accumulate remembered proxies across verification attempts.
            # Remove previously created plugin proxies before adding a new one.
            try:
                self._cleanup_plugin_proxies_from_shared_list(keep_current=False)
            except:
                pass

            existed_before = False
            try:
                existed_before = self._find_proxy_in_shared_list(key) is not None
            except:
                existed_before = False
            try:
                from hook_utils import find_class
                PC = find_class("org.telegram.messenger.SharedConfig$ProxyInfo")
                if PC:
                    ctor_getter = getattr(PC, "getConstructor", None) or getattr(PC, "getDeclaredConstructor", None)
                    if ctor_getter:
                        ct = ctor_getter(str, int, str, str, str)
                        pi_candidate = ct.newInstance(srv, prt, "", "", sec)
                        try:
                            pi = SharedConfig.addProxy(pi_candidate)
                        except:
                            pi = pi_candidate
            except:
                pi = None

            if not pi:
                try:
                    pi_candidate = SharedConfig.ProxyInfo(srv, prt, "", "", sec)
                    pi = SharedConfig.addProxy(pi_candidate)
                except:
                    pi = None

            if not pi:
                return

            for ac in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    cm = ConnectionsManager.getInstance(ac)
                    if cm: cm.setProxySettings(True, srv, prt, "", "", sec)
                except: pass
            
            # –û–±–Ω–æ–≤–ª—è–µ–º SharedConfig
            if pi:
                SharedConfig.currentProxy = pi
                try:
                    if hasattr(SharedConfig, "saveProxyList"):
                        SharedConfig.saveProxyList()
                except:
                    pass

                try:
                    owned = not bool(existed_before)
                    self._mark_proxy_success(key, owned=owned, now=int(time.time()))
                    self._prune_proxy_state(now=int(time.time()))
                    self._save_config()
                except:
                    pass
            
            SharedConfig.proxyEnabled = True

            try:
                pr = MessagesController.getGlobalMainSettings()
                ed = pr.edit()
                ed.putBoolean("proxy_enabled", True)
                ed.putBoolean("proxy_enabled_calls", False)
                ed.putString("proxy_ip", srv)
                ed.putString("proxy_user", "")
                ed.putString("proxy_pass", "")
                ed.putInt("proxy_port", prt)
                ed.putString("proxy_secret", sec)
                ed.commit()
            except: pass

            try:
                ConnectionsManager.setProxySettings(True, srv, prt, "", "", sec)
            except: pass

            try: NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except: pass
            
        except Exception as e:
            print(f"Apply Error: {e}")

    def create_settings(self):
        try:
            settings = [Header(text="–°—Ç–∞—Ç—É—Å")]

            enabled = False
            active_server = ""
            active_port = 0
            active_secret = ""

            try:
                try:
                    enabled = bool(SharedConfig.isProxyEnabled())
                except:
                    prefs = MessagesController.getGlobalMainSettings()
                    enabled = prefs.getBoolean("proxy_enabled", False) and SharedConfig.currentProxy is not None

                if enabled and SharedConfig.currentProxy is not None:
                    active_server = str(SharedConfig.currentProxy.address)
                    active_port = int(SharedConfig.currentProxy.port)
                    active_secret = str(SharedConfig.currentProxy.secret)
                else:
                    prefs = MessagesController.getGlobalMainSettings()
                    active_server = prefs.getString("proxy_ip", "")
                    active_port = prefs.getInt("proxy_port", 0)
                    active_secret = prefs.getString("proxy_secret", "")
            except:
                enabled = False

            if enabled and active_server:
                settings.append(Text(text=f"üü¢ –ê–∫—Ç–∏–≤–µ–Ω: {active_server}:{active_port}"))
            else:
                settings.append(Text(text="üî¥ –ü—Ä–æ–∫—Å–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"))

            settings.append(Divider())

            settings.append(Header(text="–î–µ–π—Å—Ç–≤–∏—è"))

            settings.append(Text(
                text="–ù–∞–π—Ç–∏ –Ω–æ–≤—ã–π –ø—Ä–æ–∫—Å–∏",
                on_click=lambda *a: self._force_update()
            ))

            settings.append(Text(
                text="–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –ø—Ä–æ–∫—Å–∏",
                on_click=lambda *a: self._confirm_clear_all_proxies()
            ))

            if enabled and active_server:
                link = f"https://t.me/proxy?server={active_server}&port={active_port}&secret={active_secret}"
                settings.append(Text(
                    text="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–π",
                    on_click=lambda *a: self._copy_link(link)
                ))

            settings.append(Divider())
            settings.append(Text(
                text="–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª", 
                on_click=lambda *a: self._open_channel()
            ))
            
            return settings
        except Exception as e:
            return [Header(text="–û—à–∏–±–∫–∞"), Text(text=str(e))]

    def _force_update(self):
        BulletinHelper.show_info("–ü–æ–∏—Å–∫ –ø—Ä–æ–∫—Å–∏...")
        threading.Thread(target=lambda: self._update_proxy_logic(force=True), daemon=True).start()

    def _confirm_clear_all_proxies(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥")
                return

            activity = fragment.getParentActivity()
            if not activity:
                BulletinHelper.show_error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –¥–∏–∞–ª–æ–≥")
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title("–û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –ø—Ä–æ–∫—Å–∏?")
            builder.set_message("–ë—É–¥—É—Ç —É–¥–∞–ª–µ–Ω—ã –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø—Ä–æ–∫—Å–∏ –≤ Telegram (–≤–∫–ª—é—á–∞—è –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –≤—Ä—É—á–Ω—É—é). –ü—Ä–æ–∫—Å–∏ –±—É–¥–µ—Ç –≤—ã–∫–ª—é—á–µ–Ω. –î–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.")

            def on_yes(bld, which):
                try:
                    bld.dismiss()
                except:
                    pass
                BulletinHelper.show_info("–û—á–∏—Å—Ç–∫–∞ –ø—Ä–æ–∫—Å–∏...")
                threading.Thread(target=self._clear_all_proxies, daemon=True).start()

            def on_no(bld, which):
                try:
                    bld.dismiss()
                except:
                    pass

            builder.set_positive_button("–û—á–∏—Å—Ç–∏—Ç—å", on_yes)
            builder.set_negative_button("–û—Ç–º–µ–Ω–∞", on_no)
            builder.set_cancelable(True)
            builder.show()
        except Exception as e:
            BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}")

    def _clear_all_proxies(self):
        deleted = 0
        try:
            self._load_proxy_list_safe()

            # Mirror Telegram's logic (ProxyListActivity delete-all): iterate over a snapshot.
            proxies = self._shared_proxy_list_snapshot()
            for p in proxies:
                try:
                    if hasattr(SharedConfig, "deleteProxy"):
                        SharedConfig.deleteProxy(p)
                        deleted += 1
                except:
                    pass

            # Hard reset (in case deleteProxy is missing or iteration bridges fail)
            try:
                if hasattr(SharedConfig, "proxyList"):
                    try:
                        SharedConfig.proxyList.clear()
                    except:
                        pass
                try:
                    SharedConfig.currentProxy = None
                except:
                    pass
                try:
                    if hasattr(SharedConfig, "saveProxyList"):
                        SharedConfig.saveProxyList()
                except:
                    pass
            except:
                pass

            # Ensure proxy is disabled and persisted list is cleared.
            try:
                pr = MessagesController.getGlobalMainSettings()
                ed = pr.edit()
                try:
                    ed.remove("proxy_list")
                except:
                    pass
                ed.putString("proxy_ip", "")
                ed.putString("proxy_pass", "")
                ed.putString("proxy_user", "")
                ed.putString("proxy_secret", "")
                ed.putInt("proxy_port", 1080)
                ed.putBoolean("proxy_enabled", False)
                ed.putBoolean("proxy_enabled_calls", False)
                ed.commit()
            except:
                pass
            try:
                SharedConfig.proxyEnabled = False
            except:
                pass

            try:
                ConnectionsManager.setProxySettings(False, "", 0, "", "", "")
            except:
                pass

            try:
                self._proxy_state = {}
                self._save_config()
            except:
                pass

            try:
                NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.proxySettingsChanged)
            except:
                pass

            run_on_ui_thread(lambda: BulletinHelper.show_success(f"–ü—Ä–æ–∫—Å–∏ –æ—á–∏—â–µ–Ω—ã: {deleted}"))
        except Exception as e:
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏: {e}"))

    def _copy_link(self, link):
        try:
            from android.content import ClipData, Context
            ctx = ApplicationLoader.applicationContext
            clipboard = ctx.getSystemService(Context.CLIPBOARD_SERVICE)
            clip = ClipData.newPlainText("Proxy Link", link)
            clipboard.setPrimaryClip(clip)
            BulletinHelper.show_success("–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞")
        except: pass
        
    def _open_channel(self):
        try:
            from android.content import Intent
            from android.net import Uri
            
            fragment = get_last_fragment()
            activity = None
            if fragment:
                activity = fragment.getParentActivity()
                
            if not activity:
                # –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å LaunchActivity –Ω–∞–ø—Ä—è–º—É—é
                try:
                    from org.telegram.ui import LaunchActivity
                    activity = LaunchActivity.instance
                except: pass
                
            if activity:
                self._open_channel_internal(activity)
            else:
                # Fallback —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
                ctx = ApplicationLoader.applicationContext
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                ctx.startActivity(intent)
        except Exception as e:
            BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è: {e}")
    
    def _open_channel_internal(self, activity):
        try:
            from android.net import Uri
            deep_link = f"tg://resolve?domain={SUBSCRIBE_CHANNEL}"
            Browser.openUrl(activity, Uri.parse(deep_link))
        except Exception as e:
            from android.net import Uri
            # –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ Intent –Ω–∞–ø—Ä—è–º—É—é –µ—Å–ª–∏ Browser.openUrl –ø–æ–¥–≤–µ–ª
            try:
                intent = Intent(Intent.ACTION_VIEW, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
                activity.startActivity(intent)
            except:
                Browser.openUrl(activity, Uri.parse(f"https://t.me/{SUBSCRIBE_CHANNEL}"))
