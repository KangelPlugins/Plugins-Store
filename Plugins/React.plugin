__id__ = "React_neko"
__name__ = "Reactüêæ"
__description__ = """–í–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã—Ö —Ä–µ–∞–∫—Ü–∏–π :3"""
__author__ = "@pl_meow"
__version__ = "1.0.0"
__icon__ = "wtvy21cx1xcv22yct_by_fStikBot/2"
__min_version__ = "11.12.1"

# --- –ò–º–ø–æ—Ä—Ç—ã ---
import traceback
import json
from typing import Any

from ui.settings import Switch, Selector
from base_plugin import BasePlugin
from ui.settings import Header, Text, Divider
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from android_utils import log, run_on_ui_thread
from client_utils import send_request, get_last_fragment
from hook_utils import find_class, set_private_field

# --- –ö–ª–∞—Å—Å—ã Android/Telegram ---
try:
    # UI
    LinearLayout = find_class("android.widget.LinearLayout")
    ScrollView = find_class("android.widget.ScrollView")
    HorizontalScrollView = find_class("android.widget.HorizontalScrollView")
    FrameLayout = find_class("android.widget.FrameLayout")
    TextView = find_class("android.widget.TextView")
    GridLayout = find_class("android.widget.GridLayout")
    View = find_class("android.view.View")
    Gravity = find_class("android.view.Gravity")
    Theme = find_class("org.telegram.ui.ActionBar.Theme")
    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
    SeekBar = find_class("android.widget.SeekBar")
    PorterDuff = find_class("android.graphics.PorterDuff")
    Color = find_class("android.graphics.Color")

    # Drag & Drop
    DragEvent = find_class("android.view.DragEvent")
    ClipData = find_class("android.content.ClipData")
    ClipDescription = find_class("android.content.ClipDescription")
    MotionEvent = find_class("android.view.MotionEvent")
    DragShadowBuilder = find_class("android.view.View$DragShadowBuilder")
    
    # Components
    BackupImageView = find_class("org.telegram.ui.Components.BackupImageView")
    LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
    
    # Core
    MediaDataController = find_class("org.telegram.messenger.MediaDataController")
    R = find_class("org.telegram.messenger.R")
    UserConfig = find_class("org.telegram.messenger.UserConfig")
    ImageLocation = find_class("org.telegram.messenger.ImageLocation")
    TLRPC = find_class("org.telegram.tgnet.TLRPC")
    ArrayList = find_class("java.util.ArrayList")
    Emoji = find_class("org.telegram.messenger.Emoji")
    SpannableStringBuilder = find_class("android.text.SpannableStringBuilder")
    Paint = find_class("android.graphics.Paint")
    
    # Proxies
    from java import dynamic_proxy
    OnLongClickListener = find_class("android.view.View$OnLongClickListener")
    OnDragListener = find_class("android.view.View$OnDragListener")
    OnTouchListener = find_class("android.view.View$OnTouchListener")

    CLASSES_LOADED = True
except Exception as e:
    log(f"[{__name__}] Critical Error: Could not load Java/Android classes. {e}")
    CLASSES_LOADED = False

# --- Proxies --- 
class OnLongClick(dynamic_proxy(OnLongClickListener)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    def onLongClick(self, view):
        try:
            return self.callback(view)
        except Exception:
            log(f"[{__name__}] Long Click Error:\n{traceback.format_exc()}")
            return False

class OnDrag(dynamic_proxy(OnDragListener)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    def onDrag(self, view, event):
        try:
            return self.callback(view, event)
        except Exception:
            log(f"[{__name__}] Drag Error:\n{traceback.format_exc()}")
            return False
class OnTouch(dynamic_proxy(OnTouchListener)):
    def __init__(self, callback):
        super().__init__()
        self.callback = callback
    def onTouch(self, view, event):
        try:
            return self.callback(view, event)
        except Exception:
            return False


class EditPinnedReactionsPlugin(BasePlugin):
    def on_plugin_load(self):
        if not CLASSES_LOADED:
            log(f"[{__name__}] Plugin disabled due to missing classes.")
            return
        
        self.temp_reactions_list = []
        self.available_reactions_cache = None
        self.editor_dialog = None
        self.document_cache = {}
        try:
            MediaDataController.getInstance(UserConfig.selectedAccount).loadRecents(5, False, False, True)
        except Exception:
            pass


    def create_settings(self):
        custom_style = self.get_setting("custom_emoji_style", False)
        style_type = self.get_setting("emoji_style_type", 1)
        
        settings = [
            Header(text="–†–µ–¥–∞–∫—Ç–æ—Ä —Ä–µ–∞–∫—Ü–∏–π"),
            Text(
                text="–û—Ç–∫—Ä—ã—Ç—å —Ä–µ–¥–∞–∫—Ç–æ—Ä",
                icon="msg_reactions",
                on_click=lambda v: run_on_ui_thread(self._show_reactions_editor_dialog)
            ),
            Divider(),
            Switch(
                key="custom_emoji_style",
                text="–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —ç–º–æ–¥–∑–∏ –≤ –∫–∞—Å—Ç–æ–º–Ω–æ–º —Å—Ç–∏–ª–µ",
                default=False,
                icon="msg_emoji_recent",
                on_change=lambda v: self.rebuild_settings()
            )
        ]
        
        if custom_style:
            settings.append(Selector(
                key="emoji_style_type",
                text="–°—Ç–∏–ª—å —ç–º–æ–¥–∑–∏",
                items=["System", "Telegram"],
                default=1,
                icon="msg_customize",
                on_change=lambda v: self.rebuild_settings()
            ))
            
            if style_type == 1:
                settings.append(Switch(
                    key="animate_emoji_pg",
                    text="–ê–Ω–∏–º–∏—Ä–æ–≤–∞—Ç—å",
                    default=True,
                    icon="msg_gif"
                ))
        
        settings.append(Switch(
            key="show_premium_pg",
            text="–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –ø—Ä–µ–º–∏—É–º",
            subtext="–ù–µ–¥–∞–≤–Ω–∏–µ –ø—Ä–µ–º–∏—É–º —ç–º–æ–¥–∑–∏",
            default=False,
            icon="msg_premium_gift",
            on_change=lambda v: self._refresh_ui()
        ))
        
        return settings

    def rebuild_settings(self):
        fragment = get_last_fragment()
        if fragment and hasattr(fragment, "rebuildAllFragments"):
            run_on_ui_thread(lambda: fragment.rebuildAllFragments(True))

    # --- Data Fetching/Saving ---
    def _get_current_reactions(self) -> ArrayList:
        try:
            account = UserConfig.selectedAccount
            mdc = MediaDataController.getInstance(account)
            reactions = mdc.getTopReactions()
            return reactions if reactions else ArrayList()
        except Exception as e:
            log(f"Error getting current reactions: {e}")
            return ArrayList()

    def _get_available_reactions(self) -> ArrayList:
        if self.available_reactions_cache and not self.available_reactions_cache.isEmpty():
            return self.available_reactions_cache
        try:
            account = UserConfig.selectedAccount
            mdc = MediaDataController.getInstance(account)
            self.available_reactions_cache = mdc.getReactionsList()
            return self.available_reactions_cache
        except Exception as e:
            log(f"Error getting available reactions: {e}")
            return ArrayList()

    def _save_reactions_list(self):
        try:
            final_list = ArrayList()
            for reaction in self.temp_reactions_list:
                if reaction is not None:
                    final_list.add(reaction)

            account = UserConfig.selectedAccount
            mdc = MediaDataController.getInstance(account)
            set_private_field(mdc, "topReactions", final_list)
            
            ReqClass = find_class("org.telegram.tgnet.TLRPC$TL_messages_setSavedReactions")
            if ReqClass:
                req = ReqClass()
                req.reactions = final_list
                
                def cb(result, error):
                    if error:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {error.text}"))
                    else:
                        mdc.loadRecents(MediaDataController.TYPE_FAVE, False, True, False)
                        run_on_ui_thread(lambda: BulletinHelper.show_success("–†–µ–∞–∫—Ü–∏–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!"))
                
                send_request(req, cb)
        except Exception as e:
            log(f"Error saving reactions: {e}")
            BulletinHelper.show_error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏")

    # --- UI Creation ---
    def _show_reactions_editor_dialog(self):
        try:
            if not CLASSES_LOADED:
                BulletinHelper.show_error("–û—à–∏–±–∫–∞: –ö–ª–∞—Å—Å—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã")
                return

            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None
            if not activity:
                return

            initial_reactions = list(self._get_current_reactions().toArray())
            self.temp_reactions_list = (initial_reactions + [None] * 7)[:7]

            builder = AlertDialogBuilder(activity)
            builder.set_title("–†–µ–¥–∞–∫—Ç–æ—Ä —Ä–µ–∞–∫—Ü–∏–π")

            # Root: Vertical LinearLayout
            self.root_layout = LinearLayout(activity)
            self.root_layout.setOrientation(LinearLayout.VERTICAL)
            self.root_layout.setPadding(0, AndroidUtilities.dp(8), 0, 0)
            self.root_layout.setOnDragListener(OnDrag(self._handle_drag_event))

            # 1. Fixed Header (Pinned Slots) - RED PART
            header_container = LinearLayout(activity)
            header_container.setOrientation(LinearLayout.VERTICAL)
            header_container.setPadding(AndroidUtilities.dp(8), 0, AndroidUtilities.dp(8), 0)
            
            label = TextView(activity)
            label.setText("–ó–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ —Ä–µ–∞–∫—Ü–∏–∏")
            label.setTextSize(14)
            label.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            label.setGravity(Gravity.CENTER_HORIZONTAL)
            header_container.addView(label, LayoutHelper.createLinear(-1, -2, 0, 0, 0, 8))

            self.pinned_slots_layout = LinearLayout(activity)
            self.pinned_slots_layout.setOrientation(LinearLayout.HORIZONTAL)
            self.pinned_slots_layout.setGravity(Gravity.CENTER)
            header_container.addView(self.pinned_slots_layout, LayoutHelper.createLinear(-1, -2))
            
            self.root_layout.addView(header_container)

            # Divider
            divider = View(activity)
            divider.setBackgroundColor(Theme.getColor(Theme.key_divider))
            self.root_layout.addView(divider, LayoutHelper.createLinear(-1, 1, 0, 12, 0, 0))

            # 2. Body: Viewport + Scrollbar
            body_container = LinearLayout(activity)
            body_container.setOrientation(LinearLayout.HORIZONTAL)
            
            # Viewport (Green Part) - FrameLayout acts as a static container
            self.viewport = ScrollView(activity)
            self.viewport.setVerticalScrollBarEnabled(False)
            self.viewport.setOnTouchListener(OnTouch(lambda v, e: True))
            
            self.available_reactions_grid = GridLayout(activity)
            self.available_reactions_grid.setColumnCount(6)
            self.available_reactions_grid.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            # FIX: WRAP_CONTENT height to allow scrolling calculation
            self.available_reactions_grid.setLayoutParams(FrameLayout.LayoutParams(-1, -2))
            
            self.viewport.addView(self.available_reactions_grid)
            body_container.addView(self.viewport, LinearLayout.LayoutParams(0, -1, 1.0))
            
            # Scrollbar Track (Blue Part)
            self.scrollbar_track = FrameLayout(activity)
            self.scrollbar_track.setBackgroundColor(0x00000000) # Transparent bg to catch clicks
            sb_params = LinearLayout.LayoutParams(AndroidUtilities.dp(24), -1)
            sb_params.leftMargin = AndroidUtilities.dp(4)
            self.scrollbar_track.setLayoutParams(sb_params)

            # Scrollbar Thumb
            self.scrollbar_thumb = View(activity)
            thumb_bg = GradientDrawable()
            thumb_bg.setShape(GradientDrawable.RECTANGLE)
            thumb_bg.setCornerRadius(AndroidUtilities.dp(12))
            thumb_bg.setColor(Color.parseColor("#2196F3"))
            self.scrollbar_thumb.setBackground(thumb_bg)

            self.thumb_height_px = AndroidUtilities.dp(40)
            thumb_params = FrameLayout.LayoutParams(AndroidUtilities.dp(6), self.thumb_height_px)
            thumb_params.gravity = Gravity.TOP | Gravity.CENTER_HORIZONTAL
            self.scrollbar_thumb.setLayoutParams(thumb_params)
            
            self.scrollbar_track.addView(self.scrollbar_thumb)
            body_container.addView(self.scrollbar_track)

            self.root_layout.addView(body_container, LinearLayout.LayoutParams(-1, AndroidUtilities.dp(360)))

            # Scrolling Logic
            self.is_dragging_scrollbar = False
            self.sb_start_y = 0
            self.sb_start_thumb_y = 0
            # Scrolling Logic
            self.is_dragging_scrollbar = False
            self.sb_start_y = 0
            self.sb_start_thumb_y = 0

            def on_scrollbar_touch(v, event):
                action = event.getAction()
                if action == MotionEvent.ACTION_DOWN:
                    v.getParent().requestDisallowInterceptTouchEvent(True)
                    self.is_dragging_scrollbar = True
                    self.sb_start_y = event.getRawY()
                    self.sb_start_thumb_y = self.scrollbar_thumb.getTranslationY()
                    return True
                elif action == MotionEvent.ACTION_MOVE:
                    if not self.is_dragging_scrollbar: return False
                    
                    delta = event.getRawY() - self.sb_start_y
                    new_thumb_y = self.sb_start_thumb_y + delta
                    
                    track_h = self.scrollbar_track.getHeight()
                    thumb_h = self.thumb_height_px
                    max_y = track_h - thumb_h
                    
                    if max_y <= 0: return True
                    
                    new_thumb_y = max(0.0, min(new_thumb_y, float(max_y)))
                    self.scrollbar_thumb.setTranslationY(new_thumb_y)
                    
                    ratio = new_thumb_y / max_y
                    
                    content_h = self.available_reactions_grid.getHeight()
                    viewport_h = self.viewport.getHeight()
                    scroll_range = content_h - viewport_h
                    
                    if scroll_range > 0:
                        self.viewport.scrollTo(0, int(ratio * scroll_range))
                    
                    return True
                elif action == MotionEvent.ACTION_UP or action == MotionEvent.ACTION_CANCEL:
                    self.is_dragging_scrollbar = False
                    return True
                return False

            self.scrollbar_track.setOnTouchListener(OnTouch(on_scrollbar_touch))

            builder.set_view(self.root_layout)

            def on_save(b, w):
                self._save_reactions_list()
                b.dismiss()
                self.editor_dialog = None

            builder.set_positive_button("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", on_save)
            builder.set_negative_button("–û—Ç–º–µ–Ω–∞", lambda b, w: (b.dismiss(), setattr(self, 'editor_dialog', None)))
            
            self.editor_dialog = builder.show()
            
            # Initial population
            self._populate_available_reactions_grid()
            self._refresh_ui()
            
        except Exception as e:
            log(f"[{__name__}] Error showing dialog: {e}\n{traceback.format_exc()}")
            log(f"[{__name__}] Interface error: {e}")

    # --- UI Population & Refreshing ---
    def _refresh_ui(self):
        self._populate_pinned_slots_view()
        self._update_available_grid_state()

    def _populate_pinned_slots_view(self):
        if not hasattr(self, 'pinned_slots_layout') or not self.pinned_slots_layout: return
        self.pinned_slots_layout.removeAllViews()

        for i in range(7):
            slot = self._create_slot_view(i)
            reaction = self.temp_reactions_list[i]
            if reaction:
                reaction_view = self._create_reaction_view(reaction, for_picker=False)
                # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö –≤ setTag
                reaction_view.setTag(json.dumps({"type": "pinned", "index": i, "id": self._get_reaction_id(reaction)}))
                reaction_view.setOnTouchListener(OnTouch(self._handle_item_touch))
                slot.addView(reaction_view)
            self.pinned_slots_layout.addView(slot)

    def _get_all_selectable_items(self) -> list:
        items_list = list(self._get_available_reactions().toArray())
        if self.get_setting("show_premium_pg", False):
            try:
                account = UserConfig.selectedAccount
                mdc = MediaDataController.getInstance(account)
                recents = mdc.getRecentStickers(5) # TYPE_EMOJI
                if recents and not recents.isEmpty():
                    recent_docs = list(recents.toArray())
                    for doc in recent_docs:
                        if isinstance(doc, TLRPC.Document):
                            is_emoji = False
                            for attr in doc.attributes:
                                if isinstance(attr, TLRPC.TL_documentAttributeCustomEmoji):
                                    is_emoji = True
                                    break
                            if is_emoji:
                                r = TLRPC.TL_reactionCustomEmoji()
                                r.document_id = doc.id
                                self.document_cache[doc.id] = doc
                                items_list.append(r)
            except Exception as e:
                log(f"Error loading recents: {e}")
        return items_list

    def _populate_available_reactions_grid(self):
        if not hasattr(self, 'available_reactions_grid') or not self.available_reactions_grid: return
        self.available_reactions_grid.removeAllViews()

        items_list = self._get_all_selectable_items()
        if not items_list: return

        seen_ids = set()

        for item in items_list:
            reaction_id = self._get_reaction_id(item)
            if reaction_id in seen_ids: continue
            seen_ids.add(reaction_id)
            
            wrapper = FrameLayout(self.available_reactions_grid.getContext())
            size_px = AndroidUtilities.dp(40)
            params = GridLayout.LayoutParams()
            params.width, params.height = size_px, size_px
            params.setMargins(AndroidUtilities.dp(2), AndroidUtilities.dp(2), AndroidUtilities.dp(2), AndroidUtilities.dp(2))
            wrapper.setLayoutParams(params)

            view = self._create_reaction_view(item, for_picker=True)
            
            wrapper.setTag(json.dumps({"type": "available", "id": reaction_id}))
            wrapper.setOnTouchListener(OnTouch(self._handle_item_touch))
            
            # Border
            bg = GradientDrawable()
            bg.setShape(GradientDrawable.RECTANGLE)
            bg.setCornerRadius(AndroidUtilities.dp(12))
            bg.setStroke(AndroidUtilities.dp(3), Theme.getColor(Theme.key_featuredStickers_addButton))
            wrapper.setBackground(bg)
            
            wrapper.addView(view)
            self.available_reactions_grid.addView(wrapper)
    def _update_available_grid_state(self):
        if not hasattr(self, 'available_reactions_grid') or not self.available_reactions_grid: return
        
        current_reaction_ids = {self._get_reaction_id(r) for r in self.temp_reactions_list if r}
        
        count = self.available_reactions_grid.getChildCount()
        for i in range(count):
            try:
                wrapper = self.available_reactions_grid.getChildAt(i)
                tag_raw = wrapper.getTag()
                if isinstance(tag_raw, str):
                    data = json.loads(tag_raw)
                    rid = data.get("id")
                    
                    bg = wrapper.getBackground()
                    
                    if rid in current_reaction_ids:
                        if wrapper.getChildCount() > 0:
                            wrapper.getChildAt(0).setAlpha(0.5)
                        if isinstance(bg, GradientDrawable):
                            bg.setStroke(0, 0)
                        wrapper.setOnTouchListener(None)
                    else:
                        if wrapper.getChildCount() > 0:
                            wrapper.getChildAt(0).setAlpha(1.0)
                        if isinstance(bg, GradientDrawable):
                            bg.setStroke(AndroidUtilities.dp(3), Theme.getColor(Theme.key_featuredStickers_addButton))
                        wrapper.setOnTouchListener(OnTouch(self._handle_item_touch))
            except Exception as e:
                log(f"[{__name__}] Grid state update error: {e}")

    # --- View Creation Helpers ---
    def _create_slot_view(self, index: int) -> FrameLayout:
        context = get_last_fragment().getParentActivity()
        slot = FrameLayout(context)
        slot.setTag(json.dumps({"type": "slot", "index": index}))
        size = AndroidUtilities.dp(36) # –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä —Å–ª–æ—Ç–∞
        params = LinearLayout.LayoutParams(0, size, 1.0)
        params.setMargins(AndroidUtilities.dp(2), 0, AndroidUtilities.dp(2), 0)
        slot.setLayoutParams(params)
        slot.setOnDragListener(OnDrag(self._handle_drag_event))
        
        bg = GradientDrawable()
        bg.setShape(GradientDrawable.RECTANGLE)
        bg.setCornerRadius(AndroidUtilities.dp(16)) # MD3 –∑–∞–∫—Ä—É–≥–ª–µ–Ω–∏–µ
        bg.setColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))
        slot.setBackground(bg)
        return slot

    def _create_reaction_view(self, reaction: Any, for_picker: bool = False) -> View:
        context = get_last_fragment().getParentActivity()
        
        # –†–∞–∑–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        container_size_dp = 36 if for_picker else 32
        container_size_px = AndroidUtilities.dp(container_size_dp)
        
        # –†–∞–∑–º–µ—Ä—ã —Å–∞–º–æ–≥–æ —ç–º–æ–¥–∑–∏ (–º–µ–Ω—å—à–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞)
        image_size_dp = 28 if for_picker else 24
        image_size_px = AndroidUtilities.dp(image_size_dp)

        container = FrameLayout(context)
        params = FrameLayout.LayoutParams(-1, -1, Gravity.CENTER)
        container.setLayoutParams(params)

        is_custom, emoji_str, doc = False, "", None
        
        custom_style = self.get_setting("custom_emoji_style", False)
        style_type = self.get_setting("emoji_style_type", 1) # 0: System, 1: Telegram
        animate = self.get_setting("animate_emoji_pg", True)

        if isinstance(reaction, TLRPC.TL_reactionEmoji): 
            emoji_str = reaction.emoticon
            if custom_style and style_type == 1: # Telegram (Animated)
                try:
                    anim_doc = MediaDataController.getInstance(UserConfig.selectedAccount).getEmojiAnimatedSticker(emoji_str)
                    if anim_doc:
                        is_custom, doc = True, anim_doc
                except Exception:
                    pass
        elif isinstance(reaction, TLRPC.TL_reactionCustomEmoji):
            is_custom = True
            doc = self.document_cache.get(reaction.document_id)
            if not doc:
                doc = MediaDataController.getInstance(UserConfig.selectedAccount).getCustomEmoji(reaction.document_id)
        elif isinstance(reaction, TLRPC.TL_availableReaction):
            if reaction.reaction: emoji_str = reaction.reaction
            elif reaction.static_icon: is_custom, doc = True, reaction.select_animation or reaction.static_icon
        
        if is_custom and doc:
            biv = BackupImageView(context)
            biv.setAspectFit(True)
            
            if not animate:
                 biv.getImageReceiver().setAllowStartAnimation(False)
                 biv.getImageReceiver().setAllowDecodeSingleFrame(True)
                 biv.getImageReceiver().setAutoRepeat(0)
                 biv.getImageReceiver().stopAnimation()

            biv = BackupImageView(context)
            biv.setAspectFit(True)
            
            if not animate:
                 biv.getImageReceiver().setAllowStartAnimation(False)
                 biv.getImageReceiver().setAutoRepeat(0)
            
            biv.getImageReceiver().setImage(ImageLocation.getForDocument(doc), f"{image_size_dp}_{image_size_dp}", None, None, None, 0)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö —Ç–µ–∫—Å—Ç–∞
            container.addView(biv, FrameLayout.LayoutParams(image_size_px, image_size_px, Gravity.CENTER))
            
        elif emoji_str:
            tv = TextView(context)
            final_text = emoji_str
            
            if custom_style and style_type == 1:
                try:
                    sb = SpannableStringBuilder(emoji_str)
                    textSize = 18 if for_picker else 16
                    p = Paint()
                    p.setTextSize(AndroidUtilities.dp(textSize))
                    Emoji.replaceEmoji(sb, p.getFontMetricsInt(), False)
                    final_text = sb
                except Exception as e:
                    log(f"[{__name__}] Emoji replace error: {e}")
            
            tv.setText(final_text)
            tv.setTextSize(18 if for_picker else 16)
            tv.setGravity(Gravity.CENTER)
            try:
                 tv.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except:
                 pass
            container.addView(tv, LayoutHelper.createFrame(-1, -1, Gravity.CENTER))
        
        return container
    def _handle_item_touch(self, view: View, event: MotionEvent) -> bool:
        action = event.getAction()
        if action == MotionEvent.ACTION_DOWN:
            self.active_touch_data = (event.getRawX(), event.getRawY())
            return True
        elif action == MotionEvent.ACTION_MOVE:
            if hasattr(self, 'active_touch_data') and self.active_touch_data:
                start_x, start_y = self.active_touch_data
                dx = abs(event.getRawX() - start_x)
                dy = abs(event.getRawY() - start_y)
                if dx > AndroidUtilities.dp(2) or dy > AndroidUtilities.dp(2):
                    self._start_drag(view)
                    self.active_touch_data = None # Reset
            return True
        elif action in [MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL]:
            self.active_touch_data = None
            return False
        return False


    # --- Drag and Drop Logic ---
    def _start_drag(self, view: View) -> bool:
        tag_str = view.getTag()
        if not isinstance(tag_str, str):
            log(f"[{__name__}] Invalid tag data type: {type(tag_str)}")
            return False
        try:
            tag_data = json.loads(tag_str)
        except json.JSONDecodeError:
            log(f"[{__name__}] Failed to parse tag JSON: {tag_str}")
            return False

        clip_item = ClipData.Item(tag_str)
        clip_data = ClipData("reaction", [ClipDescription.MIMETYPE_TEXT_PLAIN], clip_item)
        
        shadow = DragShadowBuilder(view)
        view.startDragAndDrop(clip_data, shadow, view, 0)
        view.setVisibility(View.INVISIBLE)
        return True

    def _handle_drag_event(self, view: View, event: DragEvent) -> bool:
        action = event.getAction()
        
        if action == DragEvent.ACTION_DRAG_STARTED:
            return event.getClipDescription().hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)

        target_tag = None
        try:
            tag_obj = view.getTag()
            if isinstance(tag_obj, str):
                target_tag = json.loads(tag_obj)
        except Exception:
            pass

        target_bg = view.getBackground()
        
        if action == DragEvent.ACTION_DRAG_ENTERED:
            if target_tag and isinstance(target_tag, dict) and target_tag.get("type") == "slot" and isinstance(target_bg, GradientDrawable):
                target_bg.setColor(Theme.getColor(Theme.key_chat_attachAudioBackground))
            return True

        elif action == DragEvent.ACTION_DRAG_EXITED:
            if target_tag and isinstance(target_tag, dict) and target_tag.get("type") == "slot" and isinstance(target_bg, GradientDrawable):
                target_bg.setColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))
            return True

        elif action == DragEvent.ACTION_DROP:
            try:
                clip_data = event.getClipData()
                if not clip_data or clip_data.getItemCount() == 0: return False
                
                drag_data_json = clip_data.getItemAt(0).getText()
                source_data = json.loads(str(drag_data_json))
                
                source_id = source_data.get("id")
                source_type = source_data.get("type")
                source_index = source_data.get("index")

                target_type = target_tag.get("type") if isinstance(target_tag, dict) else None

                refresh_needed = False

                if source_type == "available" and target_type == "slot":
                    reaction_obj = self._find_reaction_by_id(source_id)
                    if reaction_obj:
                        self.temp_reactions_list[target_tag["index"]] = self._convert_available_to_tlrpc(reaction_obj)
                        refresh_needed = True
                
                elif source_type == "pinned" and target_type == "slot":
                    target_index = target_tag["index"]
                    if source_index is not None:
                        self.temp_reactions_list[source_index], self.temp_reactions_list[target_index] = \
                            self.temp_reactions_list[target_index], self.temp_reactions_list[source_index]
                        refresh_needed = True
                
                elif source_type == "pinned" and view == self.root_layout:
                    if source_index is not None:
                        self.temp_reactions_list[source_index] = None
                        refresh_needed = True
                
                if refresh_needed:
                    self._refresh_ui()
                
                if target_tag and isinstance(target_tag, dict) and target_tag.get("type") == "slot" and isinstance(target_bg, GradientDrawable):
                    target_bg.setColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))

            except Exception as e:
                log(f"[{__name__}] Drop error: {e}")
            return True

        elif action == DragEvent.ACTION_DRAG_ENDED:
            dragged_view = event.getLocalState()
            if dragged_view and isinstance(dragged_view, View):
                run_on_ui_thread(lambda: dragged_view.setVisibility(View.VISIBLE))
            
            if target_tag and isinstance(target_tag, dict) and target_tag.get("type") == "slot" and isinstance(target_bg, GradientDrawable):
                target_bg.setColor(Theme.getColor(Theme.key_chat_attachPhotoBackground))
            return True
            
        return True

    # --- Utility Methods ---
    def _convert_available_to_tlrpc(self, item: Any) -> Any:
        if isinstance(item, TLRPC.TL_reactionEmoji): return item
        if isinstance(item, TLRPC.TL_reactionCustomEmoji): return item
        if isinstance(item, TLRPC.TL_availableReaction):
            if item.reaction: 
                r = TLRPC.TL_reactionEmoji()
                r.emoticon = item.reaction
                return r
            elif item.static_icon: 
                r = TLRPC.TL_reactionCustomEmoji()
                r.document_id = item.static_icon.id
                return r
        return None

    def _get_reaction_id(self, reaction: Any) -> str:
        if isinstance(reaction, TLRPC.TL_reactionEmoji): return f"emoji_{reaction.emoticon}"
        elif isinstance(reaction, TLRPC.TL_reactionCustomEmoji): return f"custom_{reaction.document_id}"
        elif isinstance(reaction, TLRPC.TL_availableReaction):
            if reaction.reaction: return f"emoji_{reaction.reaction}"
            elif reaction.static_icon: return f"custom_{reaction.static_icon.id}"
        return ""
    
    def _find_reaction_by_id(self, reaction_id: str) -> Any:
        for react in self._get_all_selectable_items():
            if self._get_reaction_id(react) == reaction_id:
                return react
        return None

#–°–æ–∑–¥–∞–Ω–æ —Å –ª—é–±–æ–≤—å—é –∫ –∫–æ—Ç–∏–∫–∞–º >^ w ^<