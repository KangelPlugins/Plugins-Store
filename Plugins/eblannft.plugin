from base_plugin import BasePlugin, MenuItemData, MenuItemType, MethodHook
from android_utils import log as logcat, run_on_ui_thread
from client_utils import get_last_fragment, get_user_config, get_connections_manager
from java import dynamic_proxy, jclass, cast
from java.util import ArrayList
from java.lang.reflect import Modifier
from org.telegram.tgnet import RequestDelegate
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder
from ui.settings import Header, Text, Divider, Switch
from file_utils import write_file, read_file, get_plugins_dir, ensure_dir_exists

from android.view import View, Gravity, ViewGroup, ViewTreeObserver, WindowManager
from android.widget import FrameLayout, LinearLayout, ScrollView, TextView, EditText
from android.text import SpannableString, Spanned
from android.text.style import ImageSpan, ForegroundColorSpan
from android.graphics.drawable import GradientDrawable, BitmapDrawable
from android.graphics import BitmapFactory, Bitmap, Color
from android.util import TypedValue
from android.net import Uri
from org.telegram.ui.ActionBar import BottomSheet, Theme, AlertDialog
from org.telegram.ui.Components import LayoutHelper, UniversalRecyclerView, UItem
from org.telegram.messenger import AndroidUtilities, FileLoader, ImageLocation, ApplicationLoader, SvgHelper

import traceback
import time
import random
import threading
import json
import os
import base64
import re
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP

def _gen(java_class, method_name):
    def _run(instance, *java_args):
        try:
            return instance._fn(*java_args)
        except:
            pass
    def __init__(self, fn, *args, **kwargs):
        self._fn = fn
        super(type(self), self).__init__()
    return type('Proxy_' + java_class.__name__.replace('$', '_'),
                (dynamic_proxy(java_class),),
                {'__init__': __init__, method_name: _run})

JRunnable = _gen(jclass("java.lang.Runnable"), "run")

__id__ = "eblannft"
__name__ = "eblanNFT"
__description__ = "**Eblan Corp.** представляет вам совершенно инновационный проект - eblanNFT. Данный плагин позволяет вам **визуально** (пока что без сервера) добовлять себе подарки или NFT юзернеймы. **Очень ранняя версия, пока что многое что мы хотели сделать не было реализовано**, возможно по интерфейсу не очень красиво. Но мы будем развиваться."
__author__ = "@oodze, @xarmaq"
__version__ = "0.1 Preview hotfix"
__icon__ = "VCPlugins/0"

def _log(msg):
    logcat(f"[NFT_ARCH] {msg}")

def to_java_int(val):
    val = val & 0xFFFFFFFF
    if val > 0x7FFFFFFF:
        val -= 0x100000000
    return val

def get_val(obj, name, default=None):
    if obj is None:
        return default
    try:
        return getattr(obj, name)
    except:
        pass
    try:
        return obj.getClass().getField(name).get(obj)
    except:
        pass
    try:
        f = obj.getClass().getDeclaredField(name)
        f.setAccessible(True)
        return f.get(obj)
    except:
        pass
    return default

def find_document_recursive(obj, depth=0):
    if obj is None or depth > 2:
        return None
    try:
        if "Document" in obj.getClass().getSimpleName():
            return obj
    except:
        return None
    doc = get_val(obj, "document")
    if doc:
        return doc
    try:
        for f in obj.getClass().getFields():
            if "Document" in f.getType().getSimpleName():
                val = f.get(obj)
                if val:
                    return val
    except:
        pass
    gift = get_val(obj, "gift")
    if gift:
        found = find_document_recursive(gift, depth + 1)
        if found:
            return found
    return None

def serialize_tl_object(obj):
    """Serialize a TLObject to base64 string using Telegram's built-in serialization."""
    try:
        SerializedData = jclass("org.telegram.tgnet.SerializedData")

        size = obj.getObjectSize()
        data = SerializedData(size + 8) 

        constructor = obj.constructor
        data.writeInt32(constructor)

        obj.serializeToStream(data)

        byte_arr = data.toByteArray()
        data.cleanup()

        py_bytes = bytes(byte_arr)
        return base64.b64encode(py_bytes).decode('utf-8')
    except Exception as e:
        _log(f"Serialize error: {e}\n{traceback.format_exc()}")
        return None

def deserialize_tl_saved_gift(b64_str):
    """Deserialize a TL_savedStarGift from base64 string."""
    try:
        SerializedData = jclass("org.telegram.tgnet.SerializedData")
        TL_stars = jclass("org.telegram.tgnet.tl.TL_stars")

        raw = base64.b64decode(b64_str)

        JByte = jclass("java.lang.Byte").TYPE
        JArray = jclass("java.lang.reflect.Array")
        arr = JArray.newInstance(JByte, len(raw))
        for i, b in enumerate(raw):
            if b > 127:
                b = b - 256
            JArray.setByte(arr, i, b)

        data = SerializedData(arr)

        constructor = data.readInt32(False)

        try:
            Saved = jclass("org.telegram.tgnet.tl.TL_stars$TL_savedStarGift")
            obj = Saved()
            obj.readParams(data, False)
            data.cleanup()
            return obj
        except Exception as e1:
            _log(f"Direct deserialize failed: {e1}")

        data.cleanup()
        return None
    except Exception as e:
        _log(f"Deserialize error: {e}\n{traceback.format_exc()}")
        return None

def gen(java_class, method_name, return_value=False, default_value=None):
    def _run(instance, *java_args):
        try:
            return instance._fn(*java_args)
        except Exception:
            return default_value

    def __init__(self, fn, *args, **kwargs):
        self._fn = fn
        super(type(self), self).__init__()

    NewClass = type(
        'Proxy_' + java_class.__name__.replace('$', '_'),
        (dynamic_proxy(java_class),),
        {'__init__': __init__, method_name: _run},
    )
    return NewClass

JCallback2 = gen(jclass("org.telegram.messenger.Utilities$Callback2"), "run")
JCallback5 = gen(jclass("org.telegram.messenger.Utilities$Callback5"), "run")
JRequestDelegate = gen(RequestDelegate, "run")
JOnClickListener = gen(jclass("android.view.View$OnClickListener"), "onClick")
JRunnable = gen(jclass("java.lang.Runnable"), "run")
JOnTouchListener = gen(jclass("android.view.View$OnTouchListener"), "onTouch", default_value=False)
JOnGlobalLayoutListener = gen(jclass("android.view.ViewTreeObserver$OnGlobalLayoutListener"), "onGlobalLayout")
JOnShowListener = gen(jclass("android.content.DialogInterface$OnShowListener"), "onShow")
JOnDismissListener = gen(jclass("android.content.DialogInterface$OnDismissListener"), "onDismiss")
try:
    TextWatcherClass = jclass("android.text.TextWatcher")

    def _tw_before(self, s, start, count, after):
        return None

    def _tw_on(self, s, start, before, count):
        try:
            return self._fn(str(s))
        except:
            return None

    def _tw_after(self, s):
        return None

    def _tw_init(self, fn, *args, **kwargs):
        self._fn = fn
        super(type(self), self).__init__()

    JTextWatcher = type(
        "Proxy_TextWatcher",
        (dynamic_proxy(TextWatcherClass),),
        {
            "__init__": _tw_init,
            "beforeTextChanged": _tw_before,
            "onTextChanged": _tw_on,
            "afterTextChanged": _tw_after,
        },
    )
except:
    JTextWatcher = None

try:
    TgListenerClass = jclass("org.telegram.ui.ActionBar.AlertDialog$OnButtonClickListener")
    JTelegramListener = gen(TgListenerClass, "onClick")
except:
    JTelegramListener = gen(jclass("android.content.DialogInterface$OnClickListener"), "onClick")

def _cache_dir():
    base = get_plugins_dir()
    new_dir = os.path.join(base, f"{__id__}_data")
    old_dir = os.path.join(base, "nft_architect_data")
    # Backward-compatible: keep using old folder if it exists and new one doesn't.
    d = old_dir if (os.path.exists(old_dir) and not os.path.exists(new_dir)) else new_dir
    ensure_dir_exists(d)
    return d

def _cache_path(uid=None):
    """
    Per-user cache file.
    Backward-compatible: when uid is falsy, returns legacy shared path.
    """
    try:
        uid_i = int(uid) if uid is not None else 0
    except:
        uid_i = 0
    if uid_i > 0:
        return os.path.join(_cache_dir(), f"stolen_cache_{uid_i}.json")
    return os.path.join(_cache_dir(), "stolen_cache.json")

def _injection_cache_path(uid=None):
    try:
        uid_i = int(uid) if uid is not None else 0
    except:
        uid_i = 0
    if uid_i > 0:
        return os.path.join(_cache_dir(), f"injection_{uid_i}.bin")
    return os.path.join(_cache_dir(), "injection.bin")

class NftClonerPlugin(BasePlugin):
    def __init__(self):
        super().__init__()

        self.stolen_gift_wrapper = None
        self.stolen_gift_inner = None
        self.cls_saved = None
        self.cls_unique = None

        self.injection_payload = None
        self.injection_payloads = []
        self.inject_active = False

        self.gift_library = []
        self.gift_objects = {}
        self._gift_objects_order = []
        self._gift_objects_max = 12
        self.editing_gift_key = None
        self._cache_file_user_id = 0
        self._library_dirty = False
        self._library_last_save_ts = 0.0

        self.wear_active = False
        self.wear_collectible_id = 0
        self.wear_ignore_clear_once = False
        self.wear_last_collectible_ts = 0.0
        self.wear_status_data = {}
        self._pending_wear_override = None

        self.build_config = {"model": 0, "pattern": 0, "backdrop": 0, "num": 1}

        self.cached_gift_id = None

        self.nft_username_enabled = False
        self.nft_usernames = []
        self.nft_username = ""
        self.nft_username_price_ton = "10.8"
        self.nft_username_price_usd = "14.68"
        self.nft_username_purchase_date = ""
        self.nft_collectible_template = None

        # Collectible anonymous phone number (+888...) spoof (local-only).
        self.nft_number_enabled = False
        self.nft_numbers = []
        self.nft_number = ""
        self.nft_number_price_ton = "10.8"
        self.nft_number_price_usd = "14.68"
        self.nft_number_purchase_date = ""
        self.nft_number_collectible_template = None

        self.hooks_refs = []
        self._profile_fastpatch_last_ts = 0.0
        self._market_floor_cache = {}
        self._market_floor_method = None
        self._market_floor_method_checked = False
        self._stars_drawable_res_id = 0
        self._context_user_id = 0

        # Gift (three dots) menu integration on StarGiftSheet.
        self._inside_gift_menu = False
        self._gift_menu_entry_key = None
        self._gift_menu_injected_once = False
        self._gift_menu_token = 0
        self._gift_menu_sheet_ref = None

        # Background workers (avoid UI jank): cache IO + some heavy polling.
        self._bg_exec = None
        self._bg_timeunit = None
        self._cache_save_future = None
        self._cache_pending = None
        self._inj_save_future = None

        # StarsController catalog list field caching (reflection scan is expensive).
        self._stars_catalog_list_field = None
        self._stars_catalog_list_candidates = None
        self._stars_catalog_last_scan_ts = 0.0

    def _ensure_bg_executor(self):
        if getattr(self, "_bg_exec", None) is not None:
            return True
        try:
            Executors = jclass("java.util.concurrent.Executors")
            try:
                self._bg_timeunit = jclass("java.util.concurrent.TimeUnit")
            except:
                self._bg_timeunit = None
            try:
                self._bg_exec = Executors.newSingleThreadScheduledExecutor()
            except:
                self._bg_exec = Executors.newSingleThreadExecutor()
            return True
        except:
            self._bg_exec = None
            self._bg_timeunit = None
            return False

    def _bg_submit(self, fn, delay_ms=0):
        """
        Best-effort: run fn off the UI thread.
        Returns a Future when scheduled, otherwise None.
        """
        try:
            delay_ms = int(delay_ms or 0)
        except:
            delay_ms = 0
        try:
            if not self._ensure_bg_executor():
                return None
        except:
            return None
        try:
            if delay_ms > 0 and self._bg_timeunit is not None and hasattr(self._bg_exec, "schedule"):
                return self._bg_exec.schedule(JRunnable(fn), int(delay_ms), self._bg_timeunit.MILLISECONDS)
        except:
            pass
        try:
            self._bg_exec.execute(JRunnable(fn))
        except:
            pass
        return None

    def on_plugin_load(self):
        try:
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.PROFILE_ACTION_MENU,
                    item_id="edit_nft_btn",
                    text="Конструктор NFT",
                    icon="msg_edit",
                    on_click=self._open_constructor,
                    condition="user != null"
                )
            )
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.PROFILE_ACTION_MENU,
                    item_id="my_nft_library_btn",
                    text="Мои NFT",
                    icon="msg_emoji_gem",
                    on_click=self._open_gift_library_menu,
                    condition="user != null"
                )
            )
            self.add_menu_item(
                MenuItemData(
                    menu_type=MenuItemType.PROFILE_ACTION_MENU,
                    item_id="nft_username_btn",
                    text="NFT Username",
                    icon="msg_edit",
                    on_click=self._open_nft_username_menu,
                    condition="user != null"
                )
            )
            self._hook_network()
            self._hook_wear_user_cache()
            self._hook_updates_wear()
            self._hook_userconfig_wear()
            self._hook_profile_activity_fastpatch()
            self._hook_gift_three_dots_menu()
            self._hook_drawer_phone_ui()
            self._ensure_user_context(force=True)

            if (self.wear_active and self.wear_collectible_id > 0) or self._is_nft_username_active() or self._is_nft_number_active():
                self._patch_my_cached_user()
                for delay_ms in [100, 500, 1000, 2000]:
                    try:
                        AndroidUtilities.runOnUIThread(JRunnable(self._patch_my_cached_user), delay_ms)
                    except:
                        pass

            _log(f"Plugin loaded v{__version__}")
        except Exception as e:
            _log(f"Load Error: {e}")

    def on_plugin_unload(self):
        for ref in self.hooks_refs:
            try:
                self.unhook_method(ref)
            except:
                pass
        self.hooks_refs.clear()

    def create_settings(self):
        try:
            status = "Есть" if (self._resolve_active_gift() is not None or (self.gift_library and len(self.gift_library) > 0)) else "Нет"
        except:
            status = "Нет" if not self.stolen_gift_inner else "Есть"
        inject_status = "Активно" if self.inject_active else "Выключено"
        wear_status = "Активно" if (self.wear_active and self.wear_collectible_id > 0) else "Выключено"
        username_status = self._display_nft_username() if self._is_nft_username_active() else "Выключено"
        number_status = self._display_nft_number() if self._is_nft_number_active() else "Выключено"
        lib_count = 0
        inj_count = 0
        try:
            lib_count = len(self.gift_library or [])
            inj_count = len(self.injection_payloads or [])
        except:
            pass
        return [
            Header(text="Статус"),
            Text(text=f"Текущий NFT: {status}", icon="msg_emoji_gem"),
            Text(text=f"Внедрение: {inject_status} (x{inj_count})", icon="msg_link"),
            Text(text=f"Носить (статус): {wear_status}", icon="msg_emoji_gem"),
            Text(text=f"NFT Username: {username_status}", icon="msg_edit", on_click=lambda _: self._open_nft_username_menu()),
            Text(text=f"NFT Number: {number_status}", icon="msg_link", on_click=lambda _: self._open_nft_number_menu()),
            Text(text=f"Мои NFT: {lib_count}", icon="msg_emoji_gem", on_click=lambda _: self._open_gift_library_menu()),
            Divider(),
            Header(text="Действия"),
            Text(text="NFT Username", icon="msg_edit", on_click=lambda _: self._open_nft_username_menu()),
            Text(text="NFT Number", icon="msg_link", on_click=lambda _: self._open_nft_number_menu()),
            Text(text="Мои NFT", icon="msg_emoji_gem", on_click=lambda _: self._open_gift_library_menu()),
            Text(text="Сброс кэша", icon="msg_delete", on_click=lambda _: self._clear_cache(), red=True),
        ]

    def _new_gift_key(self):
        return f"{int(time.time() * 1000)}-{random.randint(1000, 9999)}"

    def _get_cache_uid(self):
        """
        Stable cache namespace per Telegram account slot.
        Avoid switching between fallback/user_id while app is booting, which resets runtime state.
        """
        try:
            acc = int(get_user_config().selectedAccount or 0)
        except:
            acc = 0
        return int(10000000000 + acc)

    def _ensure_user_context(self, force=False):
        """
        Reload per-user cache when Telegram account changes.
        This prevents cross-account gift libraries and reduces leaked references.
        """
        uid = self._get_cache_uid()
        prev = int(getattr(self, "_context_user_id", 0) or 0)
        if not force and prev == uid and uid > 0:
            return False

        self._context_user_id = uid

        # Drop runtime objects; they often hold heavy Java references.
        self.stolen_gift_wrapper = None
        self.stolen_gift_inner = None
        self.injection_payload = None
        self.injection_payloads = []
        self.inject_active = False
        self.gift_library = []
        self.gift_objects = {}
        self._gift_objects_order = []
        self.editing_gift_key = None
        self.cached_gift_id = None

        self.wear_active = False
        self.wear_collectible_id = 0
        self.wear_status_data = {}
        self._pending_wear_override = None

        self.nft_username_enabled = False
        self.nft_usernames = []
        self.nft_username = ""
        self.nft_username_price_ton = "10.8"
        self.nft_username_price_usd = "14.68"
        self.nft_username_purchase_date = ""
        self.nft_collectible_template = None

        self.nft_number_enabled = False
        self.nft_numbers = []
        self.nft_number = ""
        self.nft_number_price_ton = "10.8"
        self.nft_number_price_usd = "14.68"
        self.nft_number_purchase_date = ""
        self.nft_number_collectible_template = None

        self.build_config = {"model": 0, "pattern": 0, "backdrop": 0, "num": 1}

        self._load_cache(uid=uid)
        self._load_injection_cache(uid=uid)
        try:
            my_id = int(self._get_my_user_id() or 0)
        except:
            my_id = 0
        try:
            cached_uid = int(getattr(self, "_cache_file_user_id", 0) or 0)
        except:
            cached_uid = 0
        if my_id > 0 and cached_uid > 0 and cached_uid != my_id:
            _log(f"Cache user mismatch: file_user_id={cached_uid} current_user_id={my_id}; resetting per-slot cache")
            # Keep the same uid namespace (account slot), but reset data for new user.
            self._cache_file_user_id = 0
            self.stolen_gift_wrapper = None
            self.stolen_gift_inner = None
            self.injection_payload = None
            self.injection_payloads = []
            self.inject_active = False
            self.gift_library = []
            self.gift_objects = {}
            self._gift_objects_order = []
            self.editing_gift_key = None
            self.cached_gift_id = None
            self.wear_active = False
            self.wear_collectible_id = 0
            self.wear_status_data = {}
            self._pending_wear_override = None
            self._save_cache()

        _log(f"User context: {prev} -> {uid}")
        return True

    def _extract_wrapper_gift(self, wrapper):
        if wrapper is None:
            return None
        try:
            return get_val(wrapper, "gift", None) or wrapper.getClass().getField("gift").get(wrapper)
        except:
            return None

    def _extract_gift_meta(self, wrapper, base_gift_id=0):
        gift = self._extract_wrapper_gift(wrapper)
        title = str(get_val(gift, "title", "NFT")) if gift else "NFT"
        slug = str(get_val(gift, "slug", "")) if gift else ""
        num = self._to_int(get_val(gift, "num", 0), 0) if gift else 0
        unique_id = self._to_int(get_val(gift, "id", 0), 0) if gift else 0
        bg = self._to_int(base_gift_id, 0)
        if bg <= 0 and gift is not None:
            bg = self._to_int(get_val(gift, "gift_id", 0), 0)
        return title, slug, num, bg, unique_id

    def _compute_wear_status_data_from_gift(self, gift):
        """Compute wearable collectible status fields from a TL_starGiftUnique gift."""
        if gift is None:
            return {}
        wear_data = {}
        try:
            wear_data["title"] = str(get_val(gift, "title", "NFT"))
            wear_data["slug"] = str(get_val(gift, "slug", ""))
            wear_data["collectible_id"] = int(self._to_int(get_val(gift, "id", 0), 0))
        except:
            pass

        try:
            doc_choice = self._pick_best_doc_for_collectible_status([
                get_val(gift, "sticker", None),
                get_val(gift, "document", None),
            ])
            doc_id = self._extract_doc_id(doc_choice)
            if doc_id > 0:
                wear_data["document_id"] = int(doc_id)
        except:
            pass

        attrs = get_val(gift, "attributes", None)
        if attrs is None:
            return wear_data

        model_doc_id = 0
        pattern_doc_id = 0

        try:
            size = attrs.size()
        except:
            size = 0

        for i in range(size):
            try:
                a = attrs.get(i)
            except:
                continue
            if a is None:
                continue

            for color_field in ["center_color", "edge_color", "pattern_color", "text_color"]:
                try:
                    val = get_val(a, color_field, None)
                    if val is not None and int(val) != 0:
                        wear_data[color_field] = int(val)
                except:
                    pass

            try:
                doc = get_val(a, "document", None)
                if not doc:
                    continue
                doc_id = self._to_int(get_val(doc, "id", 0), 0)
                if doc_id <= 0:
                    continue
                cls = ""
                try:
                    cls = a.getClass().getSimpleName().lower()
                except:
                    cls = ""
                if "pattern" in cls and pattern_doc_id <= 0:
                    pattern_doc_id = doc_id
                elif model_doc_id <= 0:
                    model_doc_id = doc_id
            except:
                pass

        if model_doc_id > 0 and not wear_data.get("document_id", 0):
            wear_data["document_id"] = int(model_doc_id)
        if pattern_doc_id > 0:
            wear_data["pattern_document_id"] = int(pattern_doc_id)

        return wear_data

    def _sync_wear_status_data_from_library(self, collectible_id):
        """Ensure wear_status_data matches currently worn collectible_id."""
        cid = self._to_int(collectible_id, 0)
        if cid <= 0:
            return False

        for e in (self.gift_library or []):
            try:
                if self._to_int(e.get("unique_id", 0), 0) != cid:
                    continue
                wd = e.get("wear_status_data", None)
                if isinstance(wd, dict) and wd:
                    try:
                        w = self._library_get_wrapper(e.get("key"))
                        g = self._extract_wrapper_gift(w) if w else None
                        wd2 = self._compute_wear_status_data_from_gift(g)
                        if isinstance(wd2, dict) and wd2:
                            d1 = self._to_int(wd.get("document_id", 0), 0)
                            d2 = self._to_int(wd2.get("document_id", 0), 0)
                            if d2 > 0 and d2 != d1:
                                wd["document_id"] = d2
                                e["wear_status_data"] = wd
                            if self._to_int(wd.get("pattern_document_id", 0), 0) <= 0 and self._to_int(wd2.get("pattern_document_id", 0), 0) > 0:
                                wd["pattern_document_id"] = int(wd2.get("pattern_document_id"))
                                e["wear_status_data"] = wd
                    except:
                        pass
                    self.wear_status_data = wd
                    return True
            except:
                pass

        for w in list(self.injection_payloads or []):
            try:
                g = self._extract_wrapper_gift(w)
                gid = self._to_int(get_val(g, "id", 0), 0) if g else 0
                if gid == cid:
                    wd = self._compute_wear_status_data_from_gift(g)
                    if wd:
                        self.wear_status_data = wd
                        return True
            except:
                pass

        for e in (self.gift_library or []):
            try:
                if self._to_int(e.get("unique_id", 0), 0) == cid:
                    wd = e.get("wear_status_data", None)
                    if isinstance(wd, dict) and wd:
                        self.wear_status_data = wd
                        return True
                    w = self._library_get_wrapper(e.get("key"))
                    g = self._extract_wrapper_gift(w) if w else None
                    wd2 = self._compute_wear_status_data_from_gift(g)
                    if wd2:
                        e["wear_status_data"] = wd2
                        e["unique_id"] = cid
                        self.wear_status_data = wd2
                        return True
            except:
                pass

        try:
            g = self.stolen_gift_inner
            gid = self._to_int(get_val(g, "id", 0), 0) if g else 0
            if gid == cid:
                wd = self._compute_wear_status_data_from_gift(g)
                if wd:
                    self.wear_status_data = wd
                    return True
        except:
            pass

        return False

    def _library_find_entry(self, key):
        if not key:
            return None
        for e in (self.gift_library or []):
            if str(e.get("key", "")) == str(key):
                return e
        return None

    def _library_find_entry_by_unique_id(self, unique_id):
        try:
            target = int(unique_id or 0)
        except:
            target = 0
        if target <= 0:
            return None
        for e in (self.gift_library or []):
            try:
                if int(e.get("unique_id", 0) or 0) == target:
                    return e
            except:
                continue
        return None

    def _library_find_entry_by_slug(self, slug):
        s = str(slug or "")
        if not s:
            return None
        for e in (self.gift_library or []):
            try:
                if str(e.get("slug", "")) == s:
                    return e
            except:
                continue
        return None

    def _library_find_entry_by_saved_id(self, saved_id):
        try:
            target = int(saved_id or 0)
        except:
            target = 0
        if target <= 0:
            return None
        for e in (self.gift_library or []):
            try:
                if int(e.get("saved_id", 0) or 0) == target:
                    return e
            except:
                continue
        return None

    def _extract_saved_id_from_wrapper(self, wrapper):
        gift_uid = 0
        try:
            g = get_val(wrapper, "gift", None)
            gift_uid = self._to_int(get_val(g, "id", 0), 0) if g is not None else 0
        except:
            gift_uid = 0

        for name in ["saved_id", "savedId", "savedID", "saved_gift_id", "savedGiftId", "savedStarGiftId"]:
            try:
                v = self._to_int(get_val(wrapper, name, 0), 0)
                if v > 0:
                    return int(v)
            except:
                continue
        # Some builds use plain "id" on TL_savedStarGift as the saved gift id. Avoid confusing it with gift.id.
        try:
            v = self._to_int(get_val(wrapper, "id", 0), 0)
            if v > 0 and (gift_uid <= 0 or v != gift_uid):
                return int(v)
        except:
            pass
        return 0

    def _set_saved_id_on_wrapper(self, wrapper, saved_id):
        try:
            sid = int(saved_id or 0)
        except:
            sid = 0
        if sid <= 0 or wrapper is None:
            return False
        ok = False
        for name in ["saved_id", "savedId", "savedID", "saved_gift_id", "savedGiftId", "savedStarGiftId"]:
            try:
                if self._set_field(wrapper, name, sid):
                    ok = True
            except:
                pass
        # Also try "id" field if it looks like it's the saved gift id (not gift.id).
        try:
            gift_uid = 0
            try:
                g = get_val(wrapper, "gift", None)
                gift_uid = self._to_int(get_val(g, "id", 0), 0) if g is not None else 0
            except:
                gift_uid = 0
            cur_id = self._to_int(get_val(wrapper, "id", 0), 0)
            if cur_id <= 0 or (gift_uid <= 0 or cur_id != gift_uid):
                if self._set_field(wrapper, "id", sid):
                    ok = True
        except:
            pass
        return ok

    def _new_saved_id(self):
        used = set()
        try:
            for e in (self.gift_library or []):
                try:
                    v = int(e.get("saved_id", 0) or 0)
                    if v > 0:
                        used.add(v)
                except:
                    pass
        except:
            pass
        # Use a high 32-bit range to reduce collisions and stay compatible with int/long fields.
        for _ in range(20):
            sid = random.randint(1600000000, 2147483647)
            if sid not in used:
                return sid
        return (int(time.time() * 1000) % 2147483647) or 1600000000

    def _ensure_saved_id_for_entry(self, entry, wrapper=None):
        if entry is None:
            return 0
        try:
            sid = int(entry.get("saved_id", 0) or 0)
        except:
            sid = 0
        if sid <= 0 and wrapper is not None:
            sid = self._extract_saved_id_from_wrapper(wrapper)
        if sid <= 0:
            sid = self._new_saved_id()
        try:
            entry["saved_id"] = int(sid)
        except:
            pass
        if wrapper is not None:
            self._set_saved_id_on_wrapper(wrapper, sid)
        return int(sid)

    def _remember_wrapper(self, key, wrapper):
        if not key or wrapper is None:
            return
        try:
            k = str(key)
        except:
            k = key
        try:
            # LRU order
            try:
                if k in self._gift_objects_order:
                    self._gift_objects_order.remove(k)
            except:
                pass
            self._gift_objects_order.append(k)
            self.gift_objects[k] = wrapper
            max_n = int(getattr(self, "_gift_objects_max", 12) or 12)
            while len(self._gift_objects_order) > max_n:
                old = self._gift_objects_order.pop(0)
                try:
                    if old in self.gift_objects:
                        del self.gift_objects[old]
                except:
                    pass
        except:
            # Best-effort; never break core flow.
            self.gift_objects[k] = wrapper

    def _library_get_wrapper(self, key):
        if not key:
            return None
        if key in self.gift_objects:
            obj = self.gift_objects.get(key)
            # Touch LRU.
            try:
                self._remember_wrapper(key, obj)
            except:
                pass
            return obj
        e = self._library_find_entry(key)
        if not e:
            return None
        b64 = e.get("b64", "")
        if not b64:
            return None
        try:
            obj = deserialize_tl_saved_gift(str(b64))
            if obj:
                # Ensure saved_id is non-empty and stable (needed for hide/reorder actions).
                try:
                    self._ensure_saved_id_for_entry(e, obj)
                except:
                    pass
                # Re-apply persisted UI overrides (pin/hide/order) so injected gifts don't reset
                # when re-entering profile or after restart.
                try:
                    pv = e.get("pinned_override", None)
                    if pv is not None:
                        for fn in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
                            try:
                                self._set_field(obj, fn, bool(pv))
                            except:
                                pass
                except:
                    pass
                try:
                    hv = e.get("hidden_override", None)
                    if hv is not None:
                        for fn in ["hidden", "is_hidden", "isHidden", "hidden_to_top", "isHiddenToTop"]:
                            try:
                                self._set_field(obj, fn, bool(hv))
                            except:
                                pass
                except:
                    pass
                try:
                    oh = self._to_int(e.get("order_hint", 0), 0)
                    if oh != 0:
                        for fn in ["order", "position", "sort", "sort_id", "sortId", "rank", "pinned_order", "pinnedOrder", "pinned_index", "pinnedIndex"]:
                            try:
                                self._set_field(obj, fn, int(oh))
                            except:
                                pass
                except:
                    pass
                # Fix bogus availability totals (prevents "1 из 0" ribbons in UI).
                try:
                    gift = self._extract_wrapper_gift(obj)
                    if gift is not None:
                        if self._ensure_unique_gift_availability(gift, base_gift_id=int(e.get("base_gift_id", 0) or 0)):
                            # Persist patched wrapper snapshot so it stays consistent across restarts.
                            try:
                                new_b64 = serialize_tl_object(obj)
                                if new_b64 and len(new_b64) > 10:
                                    e["b64"] = new_b64
                                    self._library_dirty = True
                            except:
                                pass
                except:
                    pass
                self._remember_wrapper(key, obj)
            return obj
        except Exception as ex:
            _log(f"Library deserialize error: {ex}")
            return None

    def _rebuild_injection_payloads(self):
        payloads = []
        my_id = self._get_my_user_id()
        for e in (self.gift_library or []):
            if not e.get("inject", False):
                continue
            try:
                owner_id = int(e.get("owner_user_id", 0) or 0)
                if owner_id > 0 and my_id > 0 and owner_id != my_id:
                    continue
            except:
                pass
            w = self._library_get_wrapper(e.get("key"))
            if w:
                payloads.append(w)
        self.injection_payloads = payloads
        self.inject_active = bool(payloads)
        self.injection_payload = payloads[0] if payloads else None

    def _library_upsert_wrapper(self, wrapper, base_gift_id=0, key=None, inject=True, make_active=True, wear_override=None, build_config=None):
        if wrapper is None:
            return None
        k = key or self._new_gift_key()
        e = self._library_find_entry(k)
        # saved_id must exist and be unique/stable for official TG actions (hide/reorder).
        try:
            self._ensure_saved_id_for_entry(e, wrapper) if e else None
        except:
            pass
        if e is None:
            # For new entries, assign a saved_id now so it gets serialized into b64.
            e_tmp = {"key": k}
            self._ensure_saved_id_for_entry(e_tmp, wrapper)
            e = None

        try:
            b64 = serialize_tl_object(wrapper)
        except:
            b64 = None
        if not b64:
            BulletinHelper.show_error("Ошибка сериализации подарка")
            return None

        title, slug, num, bg, unique_id = self._extract_gift_meta(wrapper, base_gift_id)
        gift = self._extract_wrapper_gift(wrapper)
        wd = self._compute_wear_status_data_from_gift(gift)
        try:
            if wear_override and isinstance(wear_override, dict):
                ocid = self._to_int(wear_override.get("collectible_id", 0), 0)
                if ocid > 0 and (unique_id == 0 or ocid == unique_id):
                    wd = wear_override
                    unique_id = ocid
        except:
            pass
        e = self._library_find_entry(k)
        my_id = self._get_my_user_id()
        cfg = build_config if isinstance(build_config, dict) else (self.build_config if isinstance(self.build_config, dict) else {})
        cfg_slim = {
            "model": int(cfg.get("model", 0) or 0),
            "pattern": int(cfg.get("pattern", 0) or 0),
            "backdrop": int(cfg.get("backdrop", 0) or 0),
            "num": int(cfg.get("num", 1) or 1),
        }
        try:
            sid2 = self._extract_saved_id_from_wrapper(wrapper)
        except:
            sid2 = 0
        if not e:
            e = {
                "key": k,
                "b64": b64,
                "title": title,
                "slug": slug,
                "num": int(num),
                "base_gift_id": int(bg),
                "unique_id": int(unique_id or 0),
                "saved_id": int(sid2 or 0),
                "wear_status_data": wd or {},
                "inject": bool(inject),
                "created_at": int(time.time()),
                "owner_user_id": int(my_id or 0),
                "build_config": cfg_slim,
            }
            try:
                has_pin, pin_val = self._saved_gift_pinned_value(wrapper)
                if has_pin:
                    e["pinned_override"] = bool(pin_val)
            except:
                pass
            try:
                e["hidden_override"] = bool(self._saved_gift_is_hidden(wrapper))
            except:
                pass
            try:
                e["order_hint"] = int(self._saved_gift_order_hint(wrapper) or 0)
            except:
                pass
            # Ensure saved_id exists for new entry and keep it on wrapper.
            self._ensure_saved_id_for_entry(e, wrapper)
            self.gift_library.append(e)
        else:
            e["b64"] = b64
            e["title"] = title
            e["slug"] = slug
            e["num"] = int(num)
            if bg:
                e["base_gift_id"] = int(bg)
            if unique_id:
                e["unique_id"] = int(unique_id)
            if wd:
                e["wear_status_data"] = wd
            e["inject"] = bool(inject)
            try:
                e["owner_user_id"] = int(e.get("owner_user_id", 0) or my_id or 0)
            except:
                pass
            e["build_config"] = cfg_slim
            try:
                has_pin, pin_val = self._saved_gift_pinned_value(wrapper)
                if has_pin:
                    e["pinned_override"] = bool(pin_val)
            except:
                pass
            try:
                e["hidden_override"] = bool(self._saved_gift_is_hidden(wrapper))
            except:
                pass
            try:
                e["order_hint"] = int(self._saved_gift_order_hint(wrapper) or 0)
            except:
                pass
            # Preserve existing saved_id; if missing, generate one.
            self._ensure_saved_id_for_entry(e, wrapper)

        self._remember_wrapper(k, wrapper)
        self._rebuild_injection_payloads()

        if make_active:
            gift = self._extract_wrapper_gift(wrapper)
            if gift:
                self.stolen_gift_inner = gift
                self.stolen_gift_wrapper = wrapper
                self.cached_gift_id = int(bg or 0)
                try:
                    self.cls_saved = wrapper.getClass()
                    self.cls_unique = gift.getClass()
                except:
                    pass
        return k

    def _library_remove(self, key):
        if not key:
            return
        self.gift_library = [e for e in (self.gift_library or []) if str(e.get("key", "")) != str(key)]
        try:
            if key in self.gift_objects:
                del self.gift_objects[key]
        except:
            pass
        if self.editing_gift_key == key:
            self.editing_gift_key = None
        self._rebuild_injection_payloads()

    def _open_gift_library_menu(self, context=None):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            entries = list(self.gift_library or [])
            items = ["Каталог NFT (из магазина)"]
            for e in entries:
                t = str(e.get("title", "NFT"))
                n = int(e.get("num", 0) or 0)
                inj = "ON" if e.get("inject", False) else "OFF"
                items.append(f"[{inj}] {t} #{n}")

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass
                if index == 0:
                    self._open_catalog_nft_sheet()
                    return
                idx = index - 1
                if idx < 0 or idx >= len(entries):
                    return
                self._open_gift_actions_menu(entries[idx].get("key"))

            builder = AlertDialogBuilder(ctx)
            builder.set_title("Мои NFT")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Закрыть", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка библиотеки: {e}")

    def _force_load_catalog(self):
        try:
            account = get_user_config().selectedAccount
            Ctrl = jclass("org.telegram.ui.Stars.StarsController")
            ctrl = Ctrl.getInstance(to_java_int(account))
            ctrl.loadStarGifts()
            try:
                self._market_floor_cache = {}
            except:
                pass
            BulletinHelper.show_info("Обновляю каталог...")
            return True
        except Exception as e:
            BulletinHelper.show_error(f"Каталог: {e}")
            return False

    def _load_catalog_silent(self):
        """Trigger StarsController.loadStarGifts() without UI bulletin (best-effort)."""
        try:
            account = get_user_config().selectedAccount
            Ctrl = jclass("org.telegram.ui.Stars.StarsController")
            ctrl = Ctrl.getInstance(to_java_int(account))
            ctrl.loadStarGifts()
            # Catalog data arrives asynchronously; schedule a few UI refresh attempts.
            try:
                for delay in [150, 450, 900, 1600, 2400]:
                    AndroidUtilities.runOnUIThread(JRunnable(self._refresh_profile_gifts_ui), delay)
            except:
                pass
            return True
        except:
            return False

    def _refresh_profile_gifts_ui(self):
        """Patch visible gifts list objects and notify adapters (best-effort, no user action required)."""
        try:
            frag = get_last_fragment()
        except:
            frag = None
        if frag is None:
            return 0
        patched = 0
        try:
            patched += int(self._scan_object_and_patch_gift_availability(frag, max_depth=2) or 0)
        except:
            pass
        try:
            self._scan_object_and_notify_adapters(frag, max_depth=2)
        except:
            pass
        return int(patched or 0)

    def _scan_object_and_patch_gift_availability(self, root, max_depth=2):
        """Walk object graph, find saved gift lists and patch gift availability totals in-place."""
        if root is None:
            return 0

        visited = set()
        patched = 0

        def looks_like_list(obj):
            if obj is None:
                return False
            try:
                _ = obj.size()
                _ = obj.get
                return True
            except:
                return False

        def iter_fields(obj):
            out = []
            try:
                cls = obj.getClass()
            except:
                return out
            try:
                for f in cls.getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    out.append(f)
            except:
                pass
            try:
                for f in cls.getFields():
                    out.append(f)
            except:
                pass
            return out

        def patch_list(lst):
            nonlocal patched
            try:
                size = int(lst.size() or 0)
            except:
                return
            if size <= 0:
                return
            sample = None
            try:
                sample = lst.get(0)
            except:
                sample = None

            is_saved = self._looks_like_saved_gift_wrapper(sample)
            is_unique = False
            if not is_saved:
                try:
                    n = str(sample.getClass().getName() or "").lower()
                    if "stargift" in n and "unique" in n:
                        is_unique = True
                except:
                    is_unique = False

            if not is_saved and not is_unique:
                return

            lim = min(size, 60)
            for i in range(lim):
                try:
                    it = lst.get(i)
                except:
                    continue
                try:
                    g = get_val(it, "gift", None) if is_saved else it
                    if g is None:
                        continue
                    if self._ensure_unique_gift_availability(g, base_gift_id=0):
                        patched += 1
                except:
                    continue

        def walk(obj, depth):
            if obj is None or depth > max_depth:
                return
            try:
                oid = int(obj.hashCode())
            except:
                oid = id(obj)
            if oid in visited:
                return
            visited.add(oid)

            if looks_like_list(obj):
                patch_list(obj)
                return

            # If it's a View (e.g. RecyclerView), don't recurse through the whole tree.
            # Just try to reach its adapter and patch data there.
            try:
                cn = str(obj.getClass().getName() or "")
            except:
                cn = ""
            try:
                if ("android.view" in cn) or ("android.widget" in cn) or ("androidx.recyclerview" in cn):
                    try:
                        if hasattr(obj, "getAdapter") and callable(getattr(obj, "getAdapter", None)):
                            ad = obj.getAdapter()
                            if ad is not None:
                                walk(ad, depth + 1)
                    except:
                        pass
                    return
            except:
                pass

            for f in iter_fields(obj):
                try:
                    v = f.get(obj)
                except:
                    continue
                if v is None:
                    continue
                if looks_like_list(v):
                    patch_list(v)
                else:
                    walk(v, depth + 1)

        walk(root, 0)
        return int(patched or 0)

    def _get_catalog_gifts_from_memory(self):
        """Returns raw TL_starGift list from StarsController memory (best-effort)."""
        try:
            account = get_user_config().selectedAccount
            CtrlClass = jclass("org.telegram.ui.Stars.StarsController")
            ctrl = CtrlClass.getInstance(to_java_int(account))
            # Fast path: cached field.
            try:
                f0 = getattr(self, "_stars_catalog_list_field", None)
            except:
                f0 = None
            if f0 is not None:
                try:
                    try:
                        f0.setAccessible(True)
                    except:
                        pass
                    val = f0.get(ctrl)
                    if val is not None and "ArrayList" in str(val.getClass().getName() or ""):
                        return val
                except:
                    pass

            # Try cached candidates (cheap, avoids full reflection scan).
            try:
                cand = getattr(self, "_stars_catalog_list_candidates", None)
            except:
                cand = None
            if cand:
                fallback_val = None
                for f in list(cand):
                    try:
                        try:
                            f.setAccessible(True)
                        except:
                            pass
                        val = f.get(ctrl)
                        if val is None:
                            continue
                        if "ArrayList" not in str(val.getClass().getName() or ""):
                            continue
                        if fallback_val is None:
                            fallback_val = val
                        try:
                            if val.size() <= 0:
                                continue
                            first = val.get(0)
                            first_name_l = str(first.getClass().getName() or "").lower()
                            if ("stargift" in first_name_l) and ("saved" not in first_name_l):
                                try:
                                    self._stars_catalog_list_field = f
                                except:
                                    pass
                                return val
                        except:
                            continue
                    except:
                        continue
                # If everything is empty, still return the likely list to avoid re-scanning repeatedly.
                if fallback_val is not None:
                    return fallback_val

            # Throttle full scans while catalog is empty/loading.
            try:
                now_ts = time.time()
                last = float(getattr(self, "_stars_catalog_last_scan_ts", 0.0) or 0.0)
                if (now_ts - last) < 1.2:
                    return None
                self._stars_catalog_last_scan_ts = now_ts
            except:
                pass

            gifts_list = None
            candidates = []
            real_cls = ctrl.getClass()
            for f in real_cls.getDeclaredFields():
                try:
                    f.setAccessible(True)
                except:
                    pass
                try:
                    val = f.get(ctrl)
                except:
                    continue
                if val is None:
                    continue
                try:
                    if "ArrayList" not in val.getClass().getName():
                        continue
                except:
                    continue
                try:
                    fname_l = str(f.getName() or "").lower()
                    if ("gift" in fname_l) and ("saved" not in fname_l):
                        candidates.append(f)
                except:
                    pass
                try:
                    if val.size() <= 0:
                        continue
                    first = val.get(0)
                    first_name_l = str(first.getClass().getName() or "").lower()
                    if ("stargift" in first_name_l) and ("saved" not in first_name_l):
                        gifts_list = val
                        try:
                            self._stars_catalog_list_field = f
                        except:
                            pass
                        break
                except:
                    continue

            try:
                if candidates:
                    self._stars_catalog_list_candidates = candidates
            except:
                pass

            if gifts_list is not None:
                return gifts_list
            # If we only have candidates, return the first one (likely empty) to avoid constant rescans.
            try:
                if candidates:
                    return candidates[0].get(ctrl)
            except:
                pass
            return None
        except:
            return None

    def _get_catalog_gift_by_id(self, gift_id):
        """Return TL_starGift from StarsController cache by id (best-effort)."""
        try:
            gid = int(gift_id or 0)
        except:
            gid = 0
        if gid <= 0:
            return None

        # Prefer StarsController getter method when available (more reliable than scanning fields).
        try:
            account = get_user_config().selectedAccount
            CtrlClass = jclass("org.telegram.ui.Stars.StarsController")
            ctrl = CtrlClass.getInstance(to_java_int(account))
        except:
            ctrl = None

        if ctrl is not None:
            try:
                checked = bool(getattr(self, "_stars_get_gift_method_checked", False))
            except:
                checked = False
            if not checked:
                try:
                    self._stars_get_gift_method_checked = True
                except:
                    pass
                best = None
                best_score = -1
                try:
                    for m in ctrl.getClass().getDeclaredMethods():
                        try:
                            ret = str(m.getReturnType().getName() or "").lower()
                            if "stargift" not in ret:
                                continue
                            params = m.getParameterTypes()
                            if len(params) != 1:
                                continue
                            p0 = str(params[0].getName() or "")
                            if p0 not in ["int", "long", "java.lang.Integer", "java.lang.Long"]:
                                continue
                            name_l = str(m.getName() or "").lower()
                            if "gift" not in name_l:
                                continue
                            score = 0
                            if "get" in name_l:
                                score += 3
                            if "find" in name_l:
                                score += 2
                            if "by" in name_l or "id" in name_l:
                                score += 1
                            if score > best_score:
                                best_score = score
                                best = m
                        except:
                            continue
                except:
                    best = None
                if best is not None:
                    try:
                        best.setAccessible(True)
                    except:
                        pass
                try:
                    self._stars_get_gift_method = best
                except:
                    pass

            m = getattr(self, "_stars_get_gift_method", None)
            if m is not None:
                try:
                    p0 = str(m.getParameterTypes()[0].getName() or "")
                except:
                    p0 = "int"
                try:
                    if p0 in ["long", "java.lang.Long"]:
                        res = m.invoke(ctrl, int(gid))
                    else:
                        res = m.invoke(ctrl, to_java_int(int(gid)))
                    if res is not None:
                        return res
                except:
                    pass

        lst = self._get_catalog_gifts_from_memory()
        if not lst:
            return None
        try:
            size = int(lst.size() or 0)
        except:
            return None
        for i in range(size):
            try:
                g = lst.get(i)
            except:
                continue
            try:
                for name in ["id", "gift_id", "giftId", "giftID"]:
                    if self._to_int(get_val(g, name, 0), 0) == gid:
                        return g
                continue
            except:
                continue
        return None

    def _get_gift_base_id(self, gift, fallback=0):
        """Best-effort resolve base gift id for a unique gift instance."""
        if gift is None:
            return int(fallback or 0)
        for name in ["gift_id", "giftId", "giftID", "base_gift_id", "baseGiftId"]:
            try:
                v = self._to_int(get_val(gift, name, 0), 0)
                if v > 0:
                    return int(v)
            except:
                pass
        return int(fallback or 0)

    def _ensure_unique_gift_availability(self, gift, base_gift_id=0):
        """
        Fix "X из 0" ribbons by ensuring availability_total / limited_count are filled from catalog.
        If we can't resolve totals, disable 'limited' flag so Telegram doesn't render bogus data.
        """
        if gift is None:
            return False

        changed = False
        try:
            bg = int(base_gift_id or 0)
        except:
            bg = 0
        if bg <= 0:
            try:
                bg = self._get_gift_base_id(gift, fallback=0)
            except:
                bg = 0
        if bg <= 0:
            return False

        def _get_any_int(obj, names):
            for n in names:
                try:
                    v = self._to_int(get_val(obj, n, 0), 0)
                    if v > 0:
                        return int(v)
                except:
                    pass
            return 0

        def _set_any_int(obj, names, value):
            ok = False
            for n in names:
                try:
                    if self._set_field(obj, n, int(value)):
                        ok = True
                except:
                    pass
            return ok

        def _set_any_bool(obj, names, value):
            ok = False
            for n in names:
                try:
                    if self._set_field(obj, n, bool(value)):
                        ok = True
                except:
                    pass
            return ok

        # Read current values.
        cur_total = _get_any_int(gift, ["availability_total", "availabilityTotal", "total", "total_count", "totalCount"])
        cur_issued = _get_any_int(gift, ["availability_issued", "availabilityIssued", "issued", "issued_count", "issuedCount"])
        cur_limited_count = _get_any_int(gift, ["limited_count", "limitedCount", "limit", "max", "max_count", "maxCount"])

        # Resolve from catalog.
        total = 0
        issued = 0
        limited_count = 0
        cat = self._get_catalog_gift_by_id(bg)
        if cat is None and (cur_total <= 0 and cur_limited_count <= 0):
            # Catalog may not be loaded yet. Request it once, then try again.
            try:
                if not bool(getattr(self, "_catalog_load_requested", False)):
                    self._catalog_load_requested = True
                    self._load_catalog_silent()
            except:
                pass
            cat = self._get_catalog_gift_by_id(bg)
        if cat is not None:
            total = _get_any_int(cat, ["availability_total", "availabilityTotal", "total", "total_count", "totalCount", "limited_count", "limitedCount", "max", "max_count", "maxCount"])
            issued = _get_any_int(cat, ["availability_issued", "availabilityIssued", "issued", "issued_count", "issuedCount"])
            limited_count = _get_any_int(cat, ["limited_count", "limitedCount", "limit", "max", "max_count", "maxCount", "availability_total", "availabilityTotal", "totalCount", "total"])

            # Fallback: scan numeric fields by name if fork renamed them.
            try:
                for f in cat.getClass().getFields():
                    try:
                        name = str(f.getName() or "")
                        low = name.lower()
                        typ = f.getType().getName()
                    except:
                        continue
                    if typ not in ["int", "long"]:
                        continue
                    try:
                        v = int(f.getLong(cat) if typ == "long" else f.getInt(cat))
                    except:
                        continue
                    if v <= 0:
                        continue
                    if ("avail" in low or "availability" in low) and ("total" in low or low.endswith("total")) and total <= 0:
                        total = v
                    if ("avail" in low or "availability" in low) and ("issued" in low or "sold" in low) and issued <= 0:
                        issued = v
                    if ("limited" in low or "limit" in low) and ("count" in low or "total" in low or "max" in low) and limited_count <= 0:
                        limited_count = v
            except:
                pass

        if total <= 0 and limited_count > 0:
            total = limited_count
        if limited_count <= 0 and total > 0:
            limited_count = total

        # Fallback: some forks keep availability info in a nested object.
        if (total <= 0 and limited_count <= 0) or (issued <= 0):
            try:
                for f in gift.getClass().getFields():
                    try:
                        fname = str(f.getName() or "")
                        low = fname.lower()
                    except:
                        continue
                    if ("avail" not in low) and ("limit" not in low):
                        continue
                    try:
                        v = f.get(gift)
                    except:
                        continue
                    if v is None:
                        continue
                    try:
                        if total <= 0:
                            total = _get_any_int(v, ["total", "totalCount", "availability_total", "availabilityTotal", "limited_count", "limitedCount", "max", "maxCount"]) or total
                        if issued <= 0:
                            issued = _get_any_int(v, ["issued", "issuedCount", "availability_issued", "availabilityIssued"]) or issued
                        if limited_count <= 0:
                            limited_count = _get_any_int(v, ["limited_count", "limitedCount", "max", "maxCount", "total", "totalCount"]) or limited_count
                    except:
                        pass
            except:
                pass

        # Apply onto unique gift object.
        if cur_total <= 0 and total > 0:
            if _set_any_int(gift, ["availability_total", "availabilityTotal", "total", "total_count", "totalCount"], int(total)):
                changed = True
                cur_total = total
        if cur_issued <= 0 and issued > 0:
            if _set_any_int(gift, ["availability_issued", "availabilityIssued", "issued", "issued_count", "issuedCount"], int(issued)):
                changed = True
                cur_issued = issued
        if cur_limited_count <= 0 and limited_count > 0:
            if _set_any_int(gift, ["limited_count", "limitedCount", "limit", "max", "max_count", "maxCount"], int(limited_count)):
                changed = True
                cur_limited_count = limited_count

        # If we have a total, make sure 'limited' is true so Telegram renders ribbon correctly.
        if (cur_limited_count > 0 or cur_total > 0):
            _set_any_bool(gift, ["limited", "is_limited", "isLimited"], True)
        else:
            # Prevent "1 из 0" if we couldn't resolve totals.
            _set_any_bool(gift, ["limited", "is_limited", "isLimited"], False)

        # Debug: if still unresolved, log once per base gift id.
        try:
            if (cur_total <= 0 and cur_limited_count <= 0):
                seen = getattr(self, "_availability_warned_ids", None)
                if seen is None:
                    seen = set()
                    self._availability_warned_ids = seen
                if bg not in seen:
                    seen.add(bg)
                    try:
                        cls_n = str(gift.getClass().getName() or "")
                    except:
                        cls_n = "?"
                    _log(f"Availability unresolved for base_gift_id={bg} gift_cls={cls_n}")
        except:
            pass

        return bool(changed)

    def _get_catalog_nft_gifts(self):
        """Filter only NFT gifts from StarsController list."""
        out = []
        lst = self._get_catalog_gifts_from_memory()
        if not lst:
            return out
        try:
            size = lst.size()
        except:
            return out
        for i in range(size):
            try:
                g = lst.get(i)
            except:
                continue
            try:
                upg = get_val(g, "upgrade_stars", 0)
                if upg is None:
                    upg = 0
                if int(upg) > 0:
                    out.append(g)
                    continue
                if "unique" in g.getClass().getName().lower():
                    out.append(g)
            except:
                pass
        try:
            out.sort(key=lambda gg: -int(self._get_gift_floor_stars(gg) or 0))
        except:
            try:
                out.sort(key=lambda gg: -int(get_val(gg, "stars", 0) or 0))
            except:
                pass
        return out

    def _get_gift_title(self, gift):
        try:
            t = str(get_val(gift, "title", "") or "")
            if t and t != "N/A":
                return t
        except:
            pass
        try:
            slug = str(get_val(gift, "slug", "") or "")
            if slug:
                return slug.replace("gift-", "").replace("_", " ").strip().title()
        except:
            pass
        try:
            gid = int(get_val(gift, "id", 0) or 0)
            return f"Gift {gid}"
        except:
            return "NFT"

    def _get_gift_floor_stars(self, gift):
        """Best-effort: try to resolve current floor/min resale price in stars for a catalog gift."""
        if gift is None:
            return 0

        candidates = [
            "resell_min_stars",
            "min_resell_stars",
            "floor_stars",
            "floor_price_stars",
            "min_floor_stars",
            "min_resale_stars",
            "resellMinStars",
            "floorStars",
            "floorPriceStars",
        ]
        for name in candidates:
            try:
                v = get_val(gift, name, None)
                n = self._to_int(v, 0)
                if n > 0:
                    return n
            except:
                pass

        try:
            for f in gift.getClass().getFields():
                try:
                    tn = f.getType().getName()
                    if tn not in ["int", "long"]:
                        continue
                    n = f.getName().lower()
                    if ("floor" not in n) and ("resell" not in n):
                        continue
                    if ("min" not in n) and ("floor" not in n):
                        continue
                    try:
                        val = f.getLong(gift) if tn == "long" else f.getInt(gift)
                    except:
                        try:
                            val = self._to_int(f.get(gift), 0)
                        except:
                            continue
                    if int(val) > 0:
                        return int(val)
                except:
                    continue
        except:
            pass

        try:
            gid = self._to_int(get_val(gift, "id", 0), 0)
            if gid > 0:
                cached = None
                try:
                    cached = self._market_floor_cache.get(int(gid))
                except:
                    cached = None
                if cached and int(cached) > 0:
                    return int(cached)
                floor2 = self._get_floor_from_stars_controller(int(gid))
                if floor2 > 0:
                    try:
                        self._market_floor_cache[int(gid)] = int(floor2)
                    except:
                        pass
                    return int(floor2)
        except:
            pass

        try:
            return self._to_int(get_val(gift, "stars", 0), 0)
        except:
            return 0

    def _get_floor_from_stars_controller(self, gift_id):
        """Try to call a StarsController method which returns floor/min resale stars."""
        try:
            gid = int(gift_id or 0)
        except:
            return 0
        if gid <= 0:
            return 0
        try:
            account = get_user_config().selectedAccount
            Ctrl = jclass("org.telegram.ui.Stars.StarsController")
            ctrl = Ctrl.getInstance(to_java_int(account))
        except:
            return 0

        if not self._market_floor_method_checked:
            self._market_floor_method_checked = True
            best = None
            best_score = -1
            try:
                for m in ctrl.getClass().getDeclaredMethods():
                    try:
                        ret = m.getReturnType().getName()
                        if ret not in ["int", "long"]:
                            continue
                        params = m.getParameterTypes()
                        if len(params) != 1:
                            continue
                        p0 = params[0].getName()
                        if p0 not in ["int", "long", "java.lang.Integer", "java.lang.Long"]:
                            continue
                        name = m.getName().lower()
                        if ("floor" not in name) and ("resell" not in name) and ("resale" not in name):
                            continue
                        score = 0
                        if "floor" in name:
                            score += 3
                        if "resell" in name or "resale" in name:
                            score += 2
                        if "min" in name:
                            score += 2
                        if "stars" in name:
                            score += 1
                        if score > best_score:
                            best_score = score
                            best = m
                    except:
                        continue
            except:
                best = None
            if best is not None:
                try:
                    best.setAccessible(True)
                except:
                    pass
            self._market_floor_method = best
            if best is not None:
                _log(f"StarsController floor method: {best.getName()}")

        m = self._market_floor_method
        if m is None:
            return 0
        try:
            params = m.getParameterTypes()
            p0 = params[0].getName() if params and len(params) else "int"
            if p0 in ["long", "java.lang.Long"]:
                res = m.invoke(ctrl, int(gid))
            else:
                res = m.invoke(ctrl, to_java_int(int(gid)))
            return self._to_int(res, 0)
        except:
            return 0

    def _get_stars_drawable(self, size_px):
        """Return a Drawable for Stars icon (used in market price). No emoji."""
        try:
            size_px = int(size_px or 0)
        except:
            size_px = 0

        res_id = int(getattr(self, "_stars_drawable_res_id", 0) or 0)
        if res_id <= 0:
            res_id = self._find_stars_drawable_res_id()
            try:
                self._stars_drawable_res_id = int(res_id or 0)
            except:
                pass
        if res_id <= 0:
            return None

        try:
            ctx = ApplicationLoader.applicationContext
            try:
                ContextCompat = jclass("androidx.core.content.ContextCompat")
                d = ContextCompat.getDrawable(ctx, res_id)
            except:
                d = ctx.getResources().getDrawable(res_id)
            if d is not None and size_px > 0:
                try:
                    d.setBounds(0, 0, size_px, size_px)
                except:
                    pass
            return d
        except:
            return None

    def _find_stars_drawable_res_id(self):
        """Scan Telegram R.drawable for a suitable star/stars icon."""
        try:
            R = jclass("org.telegram.messenger.R$drawable")
        except:
            return 0

        best_id = 0
        best_score = -1
        try:
            fields = R.getFields()
        except:
            fields = []

        for f in fields:
            try:
                name = str(f.getName() or "").lower()
            except:
                continue
            if "star" not in name and "stars" not in name:
                continue
            score = 0
            if "stars" in name:
                score += 3
            if "star" in name:
                score += 1
            if "msg" in name or "menu" in name or "ic" in name:
                score += 2
            if "small" in name or "mini" in name:
                score += 1
            if "outline" in name:
                score -= 1
            if "premium" in name or "gradient" in name or "gift" in name:
                score -= 1
            try:
                val = int(f.getInt(None))
            except:
                try:
                    val = int(f.get(None))
                except:
                    continue
            if val <= 0:
                continue
            if score > best_score:
                best_score = score
                best_id = val

        return int(best_id or 0)

    def _ensure_gift_classes(self):
        """Ensure TL_savedStarGift and TL_starGiftUnique classes exist even without stealing."""
        if self.cls_saved and self.cls_unique:
            return True
        try:
            self.cls_saved = jclass("org.telegram.tgnet.tl.TL_stars$TL_savedStarGift")
        except:
            self.cls_saved = None
        try:
            self.cls_unique = jclass("org.telegram.tgnet.tl.TL_stars$TL_starGiftUnique")
        except:
            self.cls_unique = None
        return bool(self.cls_saved and self.cls_unique)

    def _open_catalog_nft_sheet(self):
        try:
            sheet = CatalogNftSheet(self)
            sheet.show()
        except Exception as e:
            BulletinHelper.show_error(f"Каталог: {e}")

    def _open_gift_actions_menu(self, key):
        e = self._library_find_entry(key)
        if not e:
            BulletinHelper.show_error("Подарок не найден")
            return
        inj = bool(e.get("inject", False))
        t = str(e.get("title", "NFT"))
        n = int(e.get("num", 0) or 0)
        items = [
            "Открыть в конструкторе",
            ("Включить внедрение" if not inj else "Выключить внедрение"),
            "Удалить из библиотеки",
        ]

        def _on_click(dialog, index):
            try:
                dialog.dismiss()
            except:
                pass
            if index == 0:
                self._open_constructor_for_library_key(key)
            elif index == 1:
                e["inject"] = not inj
                self._rebuild_injection_payloads()
                self._save_cache()
                BulletinHelper.show_success("Внедрение обновлено")
            elif index == 2:
                self._delete_library_gift_key(key)

        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else None
        if not ctx:
            return
        builder = AlertDialogBuilder(ctx)
        builder.set_title(f"{t} #{n}")
        builder.set_items(items, _on_click)
        builder.set_negative_button("Назад", None)
        run_on_ui_thread(builder.show)

    def _open_constructor(self, context):
        try:
            self._ensure_user_context(force=False)
        except:
            pass

        if not self.stolen_gift_inner:
            def _prepare_from_library_default():
                try:
                    entries = list(self.gift_library or [])
                except:
                    entries = []
                if not entries:
                    return False

                chosen = None
                try:
                    if self.wear_collectible_id and int(self.wear_collectible_id) > 0:
                        chosen = self._library_find_entry_by_unique_id(int(self.wear_collectible_id))
                except:
                    chosen = None

                if not chosen:
                    try:
                        g0 = self._extract_wrapper_gift(self.injection_payload) if self.injection_payload else None
                        slug0 = str(get_val(g0, "slug", "")) if g0 else ""
                        uid0 = self._to_int(get_val(g0, "id", 0), 0) if g0 else 0
                        chosen = self._library_find_entry_by_unique_id(uid0) or self._library_find_entry_by_slug(slug0)
                    except:
                        chosen = None

                if not chosen:
                    try:
                        entries.sort(key=lambda ee: int(ee.get("created_at", 0) or 0), reverse=True)
                    except:
                        pass
                    chosen = entries[0] if entries else None

                if not chosen:
                    return False

                key = chosen.get("key")
                w = self._library_get_wrapper(key)
                g = self._extract_wrapper_gift(w) if w else None
                if not (w and g):
                    return False

                self.editing_gift_key = str(key)
                try:
                    self.cached_gift_id = int(chosen.get("base_gift_id", 0) or 0)
                except:
                    self.cached_gift_id = None

                try:
                    cfg = chosen.get("build_config", None)
                    if isinstance(cfg, dict):
                        self.build_config = {
                            "model": int(cfg.get("model", 0) or 0),
                            "pattern": int(cfg.get("pattern", 0) or 0),
                            "backdrop": int(cfg.get("backdrop", 0) or 0),
                            "num": int(cfg.get("num", chosen.get("num", 1) or 1) or 1),
                        }
                    else:
                        # At least keep number stable.
                        self.build_config["num"] = int(chosen.get("num", 1) or 1)
                except:
                    pass

                self.stolen_gift_wrapper = w
                self.stolen_gift_inner = g
                try:
                    self.cls_saved = w.getClass()
                    self.cls_unique = g.getClass()
                except:
                    pass
                return True

            if not _prepare_from_library_default():
                if self.gift_library:
                    self._open_gift_library_menu()
                    return
                BulletinHelper.show_error("Сначала украдите подарок!")
                return
        gift_id = 0
        try:
            gift_id = int(get_val(self.stolen_gift_inner, "gift_id", 0))
        except:
            pass
        if gift_id == 0:
            try:
                gift_id = int(get_val(self.stolen_gift_inner, "id", 0))
            except:
                pass
        if gift_id == 0 and self.cached_gift_id:
            gift_id = self.cached_gift_id
        if gift_id == 0:
            BulletinHelper.show_error("Невозможно определить gift_id")
            return
        _log(f"Opening constructor for gift_id={gift_id}")
        AttrLoader(self, gift_id).start()

    def _normalize_nft_username(self, raw):
        s = str(raw or "").strip()
        if s.startswith("@"):
            s = s[1:]
        s = re.sub(r"[^A-Za-z0-9_]+", "", s)
        return s[:32]

    def _get_nft_username_tokens(self):
        unique = []
        seen = set()
        src = []
        try:
            if isinstance(self.nft_usernames, list):
                src.extend(self.nft_usernames)
        except:
            pass
        if self.nft_username:
            src.append(self.nft_username)

        for raw in src:
            token = self._normalize_nft_username(raw)
            if not token:
                continue
            low = token.lower()
            if low in seen:
                continue
            seen.add(low)
            unique.append(token)
        return unique

    def _set_nft_username_tokens(self, tokens):
        clean = []
        seen = set()
        for raw in tokens or []:
            token = self._normalize_nft_username(raw)
            if not token:
                continue
            low = token.lower()
            if low in seen:
                continue
            seen.add(low)
            clean.append(token)
        self.nft_usernames = clean
        self.nft_username = clean[0] if clean else ""

    def _display_nft_username(self):
        tokens = self._get_nft_username_tokens()
        if not tokens:
            return "не заданы"
        if len(tokens) == 1:
            return f"@{tokens[0]}"
        if len(tokens) == 2:
            return f"@{tokens[0]}, @{tokens[1]}"
        return f"@{tokens[0]}, @{tokens[1]} +{len(tokens)-2}"

    def _is_nft_username_active(self):
        return bool(self.nft_username_enabled and len(self._get_nft_username_tokens()) > 0)

    def _get_primary_nft_username(self):
        tokens = self._get_nft_username_tokens()
        return tokens[0] if tokens else ""

    def _is_managed_nft_username(self, token):
        t = self._normalize_nft_username(token)
        if not t:
            return False
        for item in self._get_nft_username_tokens():
            if item.lower() == t.lower():
                return True
        return False

    def _show_text_input_dialog(self, title, prefill, on_submit, numeric=False):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            container = FrameLayout(ctx)
            et = EditText(ctx)
            et.setText(str(prefill or ""))
            if numeric:
                et.setInputType(2)

            params = FrameLayout.LayoutParams(-1, -2)
            margin = AndroidUtilities.dp(20)
            params.leftMargin = margin
            params.rightMargin = margin
            et.setLayoutParams(params)
            container.addView(et)

            builder = AlertDialogBuilder(ctx)
            builder.set_title(title)
            builder.set_view(container)

            def _ok(dialog, which):
                try:
                    on_submit(str(et.getText()))
                except Exception as e:
                    BulletinHelper.show_error(f"Ошибка ввода: {e}")

            builder.set_positive_button("Сохранить", _ok)
            builder.set_negative_button("Отмена", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Dialog Err: {e}")

    def _open_remove_nft_username_menu(self):
        tokens = self._get_nft_username_tokens()
        if not tokens:
            BulletinHelper.show_error("Список юзернеймов пуст")
            return
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            items = [f"@{token}" for token in tokens]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass
                if index < 0 or index >= len(tokens):
                    return
                selected = tokens[index]
                new_tokens = [t for t in tokens if t.lower() != selected.lower()]
                self._set_nft_username_tokens(new_tokens)
                self._save_cache()
                self._patch_my_cached_user()
                BulletinHelper.show_success(f"Удален: @{selected}")

            builder = AlertDialogBuilder(ctx)
            builder.set_title("Удалить NFT Username")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Отмена", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка удаления: {e}")

    def _open_nft_username_menu(self, context=None):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            enabled = "Включено" if self.nft_username_enabled else "Выключено"
            tokens = self._get_nft_username_tokens()
            items = [
                "Добавить юзернейм",
                f"Список: {self._display_nft_username()}",
                f"Отображение: {enabled}",
                "Детали покупки (цена/дата)",
                "Удалить один юзернейм",
                "Очистить все NFT Username"
            ]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass

                if index == 0:
                    self._show_text_input_dialog(
                        "NFT Username (без @)",
                        "",
                        self._add_nft_username
                    )
                elif index == 1:
                    if tokens:
                        BulletinHelper.show_info("NFT Username:\n" + ", ".join([f"@{t}" for t in tokens]))
                    else:
                        BulletinHelper.show_info("NFT Username не добавлены")
                elif index == 2:
                    self.nft_username_enabled = not self.nft_username_enabled
                    self._save_cache()
                    self._patch_my_cached_user()
                    state_text = "включено" if self.nft_username_enabled else "выключено"
                    BulletinHelper.show_success(f"NFT Username: {state_text}")
                elif index == 3:
                    self._open_nft_username_details_menu()
                elif index == 4:
                    self._open_remove_nft_username_menu()
                elif index == 5:
                    self._set_nft_username_tokens([])
                    self.nft_username_enabled = False
                    self._save_cache()
                    self._patch_my_cached_user()
                    BulletinHelper.show_success("Все NFT Username очищены")

            builder = AlertDialogBuilder(ctx)
            builder.set_title("NFT Username")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Закрыть", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка меню: {e}")

    def _add_nft_username(self, value):
        uname = self._normalize_nft_username(value)
        if not uname:
            BulletinHelper.show_error("Некорректный юзернейм")
            return
        tokens = self._get_nft_username_tokens()
        if uname.lower() in [t.lower() for t in tokens]:
            BulletinHelper.show_info(f"Уже добавлен: @{uname}")
            return
        tokens.append(uname)
        self._set_nft_username_tokens(tokens)
        self.nft_username_enabled = True
        self._save_cache()
        self._patch_my_cached_user()
        BulletinHelper.show_success(f"NFT Username добавлен: @{uname}")

    def _open_nft_username_details_menu(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            date_text = self.nft_username_purchase_date if self.nft_username_purchase_date else "не задана"
            items = [
                f"Цена TON: {self.nft_username_price_ton}",
                f"Цена USD: {self.nft_username_price_usd}",
                f"Дата покупки: {date_text}",
            ]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass

                if index == 0:
                    self._show_text_input_dialog(
                        "Цена покупки в TON",
                        self.nft_username_price_ton,
                        lambda text: self._save_nft_username_detail("ton", text)
                    )
                elif index == 1:
                    self._show_text_input_dialog(
                        "Цена покупки в USD",
                        self.nft_username_price_usd,
                        lambda text: self._save_nft_username_detail("usd", text)
                    )
                elif index == 2:
                    self._show_text_input_dialog(
                        "Дата покупки (например 27.05.2025 02:25)",
                        self.nft_username_purchase_date,
                        lambda text: self._save_nft_username_detail("date", text)
                    )

            builder = AlertDialogBuilder(ctx)
            builder.set_title("NFT Username • Детали")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Закрыть", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка деталей: {e}")

    def _save_nft_username_detail(self, key, value):
        text = str(value or "").strip().replace(",", ".")
        # Keep it numeric-ish for stable parsing.
        if key in ["ton", "usd"]:
            text = re.sub(r"[^0-9.\\-]+", "", text)
            if text in ["", "-", "."]:
                text = "0"
        if key == "ton":
            self.nft_username_price_ton = text if text else "0"
        elif key == "usd":
            self.nft_username_price_usd = text if text else "0"
        elif key == "date":
            self.nft_username_purchase_date = text
        self._save_cache()
        BulletinHelper.show_success("Детали NFT Username сохранены")

    # ---- Collectible phone number (+888...) spoof ----

    def _normalize_nft_number(self, raw, allow_missing_prefix=False):
        """
        Normalize user input for a collectible anonymous number.
        Store digits only, must start with 888 (Fragment collectible numbers).
        """
        s = str(raw or "").strip()
        digits = re.sub(r"[^0-9]+", "", s)
        if not digits:
            return ""
        if allow_missing_prefix and (not digits.startswith("888")):
            digits = "888" + digits
        # Only accept +888 numbers (collectible / anonymous numbers).
        if not digits.startswith("888"):
            return ""
        # E.164 max length is 15 digits.
        if len(digits) < 7 or len(digits) > 15:
            return ""
        return digits

    def _format_nft_number(self, digits):
        d = self._normalize_nft_number(digits)
        if not d:
            return ""
        rest = d[3:]
        groups = []
        for i in range(0, len(rest), 4):
            groups.append(rest[i:i+4])
        return "+888" + ((" " + " ".join(groups)) if groups else "")

    def _get_nft_number_tokens(self):
        unique = []
        seen = set()
        src = []
        try:
            if isinstance(self.nft_numbers, list):
                src.extend(self.nft_numbers)
        except:
            pass
        if self.nft_number:
            src.append(self.nft_number)

        for raw in src:
            token = self._normalize_nft_number(raw)
            if not token:
                continue
            if token in seen:
                continue
            seen.add(token)
            unique.append(token)
        return unique

    def _set_nft_number_tokens(self, tokens):
        clean = []
        seen = set()
        for raw in tokens or []:
            token = self._normalize_nft_number(raw)
            if not token:
                continue
            if token in seen:
                continue
            seen.add(token)
            clean.append(token)
        self.nft_numbers = clean
        self.nft_number = clean[0] if clean else ""

    def _display_nft_number(self):
        tokens = self._get_nft_number_tokens()
        if not tokens:
            return "не задан"
        if len(tokens) == 1:
            return self._format_nft_number(tokens[0]) or "не задан"
        if len(tokens) == 2:
            return f"{self._format_nft_number(tokens[0])}, {self._format_nft_number(tokens[1])}"
        return f"{self._format_nft_number(tokens[0])}, {self._format_nft_number(tokens[1])} +{len(tokens)-2}"

    def _is_nft_number_active(self):
        return bool(self.nft_number_enabled and len(self._get_nft_number_tokens()) > 0)

    def _get_primary_nft_number(self):
        tokens = self._get_nft_number_tokens()
        return tokens[0] if tokens else ""

    def _is_managed_nft_number(self, token):
        t = self._normalize_nft_number(token)
        if not t:
            return False
        for item in self._get_nft_number_tokens():
            if item == t:
                return True
        return False

    def _open_remove_nft_number_menu(self):
        tokens = self._get_nft_number_tokens()
        if not tokens:
            BulletinHelper.show_error("Список номеров пуст")
            return
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            items = [self._format_nft_number(token) for token in tokens]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass
                if index < 0 or index >= len(tokens):
                    return
                selected = tokens[index]
                new_tokens = [t for t in tokens if t != selected]
                self._set_nft_number_tokens(new_tokens)
                self._save_cache()
                self._patch_my_cached_user()
                BulletinHelper.show_success(f"Удален: {self._format_nft_number(selected)}")

            builder = AlertDialogBuilder(ctx)
            builder.set_title("Удалить NFT Number")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Отмена", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка удаления: {e}")

    def _open_nft_number_menu(self, context=None):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            enabled = "Включено" if self.nft_number_enabled else "Выключено"
            tokens = self._get_nft_number_tokens()
            items = [
                "Добавить номер (+888...)",
                f"Список: {self._display_nft_number()}",
                f"Отображение: {enabled}",
                "Детали покупки (цена/дата)",
                "Удалить один номер",
                "Очистить все NFT Number"
            ]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass

                if index == 0:
                    self._show_text_input_dialog(
                        "NFT Number (например +888 0413 6929)",
                        "",
                        self._add_nft_number
                    )
                elif index == 1:
                    if tokens:
                        BulletinHelper.show_info("NFT Number:\n" + ", ".join([self._format_nft_number(t) for t in tokens]))
                    else:
                        BulletinHelper.show_info("NFT Number не задан")
                elif index == 2:
                    self.nft_number_enabled = not self.nft_number_enabled
                    self._save_cache()
                    self._patch_my_cached_user()
                    state_text = "включено" if self.nft_number_enabled else "выключено"
                    BulletinHelper.show_success(f"NFT Number: {state_text}")
                elif index == 3:
                    self._open_nft_number_details_menu()
                elif index == 4:
                    self._open_remove_nft_number_menu()
                elif index == 5:
                    self._set_nft_number_tokens([])
                    self.nft_number_enabled = False
                    self._save_cache()
                    self._patch_my_cached_user()
                    BulletinHelper.show_success("Все NFT Number очищены")

            builder = AlertDialogBuilder(ctx)
            builder.set_title("NFT Number (+888)")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Закрыть", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка меню: {e}")

    def _add_nft_number(self, value):
        num = self._normalize_nft_number(value, allow_missing_prefix=True)
        if not num:
            BulletinHelper.show_error("Некорректный номер (нужен +888...)")
            return
        tokens = self._get_nft_number_tokens()
        if num in tokens:
            BulletinHelper.show_info("Номер уже в списке")
            return
        tokens.append(num)
        self._set_nft_number_tokens(tokens)
        self.nft_number_enabled = True
        self._save_cache()
        self._patch_my_cached_user()
        BulletinHelper.show_success("NFT Number добавлен")

    def _open_nft_number_details_menu(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            ctx = fragment.getParentActivity()
            if not ctx:
                return

            date_text = self.nft_number_purchase_date if self.nft_number_purchase_date else "не задана"
            items = [
                f"Цена TON: {self.nft_number_price_ton}",
                f"Цена USD: {self.nft_number_price_usd}",
                f"Дата покупки: {date_text}",
            ]

            def _on_click(dialog, index):
                try:
                    dialog.dismiss()
                except:
                    pass
                if index == 0:
                    self._show_text_input_dialog(
                        "Цена TON (например 10.8)",
                        self.nft_number_price_ton,
                        lambda text: self._save_nft_number_detail("ton", text)
                    )
                elif index == 1:
                    self._show_text_input_dialog(
                        "Цена USD (например 14.68)",
                        self.nft_number_price_usd,
                        lambda text: self._save_nft_number_detail("usd", text)
                    )
                elif index == 2:
                    self._show_text_input_dialog(
                        "Дата покупки (например 27.05.2025 02:25)",
                        self.nft_number_purchase_date,
                        lambda text: self._save_nft_number_detail("date", text)
                    )

            builder = AlertDialogBuilder(ctx)
            builder.set_title("NFT Number • Детали")
            builder.set_items(items, _on_click)
            builder.set_negative_button("Закрыть", None)
            run_on_ui_thread(builder.show)
        except Exception as e:
            BulletinHelper.show_error(f"Ошибка деталей: {e}")

    def _save_nft_number_detail(self, key, value):
        text = str(value or "").strip().replace(",", ".")
        if key in ["ton", "usd"]:
            text = re.sub(r"[^0-9.\\-]+", "", text)
            if text in ["", "-", "."]:
                text = "0"
        if key == "ton":
            self.nft_number_price_ton = text if text else "0"
        elif key == "usd":
            self.nft_number_price_usd = text if text else "0"
        elif key == "date":
            self.nft_number_purchase_date = text
        self._save_cache()
        BulletinHelper.show_success("Детали NFT Number сохранены")

    def _save_cache(self, delay_ms=180):
        try:
            uid = self._get_cache_uid()
            data = {}
            data["cache_user_id"] = int(self._get_my_user_id() or 0)
            if self.stolen_gift_inner:
                data["gift_id"] = int(get_val(self.stolen_gift_inner, "gift_id", 0))
                data["title"] = str(get_val(self.stolen_gift_inner, "title", ""))
                data["slug"] = str(get_val(self.stolen_gift_inner, "slug", ""))
                data["num"] = int(get_val(self.stolen_gift_inner, "num", 1))
            if self.build_config:
                data["build_config"] = self.build_config
            data["inject_active"] = self.inject_active
            data["wear_active"] = bool(self.wear_active)
            data["wear_collectible_id"] = int(self.wear_collectible_id or 0)
            data["wear_status_data"] = self.wear_status_data if self.wear_status_data else {}
            data["nft_username_enabled"] = bool(self.nft_username_enabled)
            data["nft_usernames"] = self._get_nft_username_tokens()
            data["nft_username"] = self.nft_username or ""
            data["nft_username_price_ton"] = self.nft_username_price_ton or "0"
            data["nft_username_price_usd"] = self.nft_username_price_usd or "0"
            data["nft_username_purchase_date"] = self.nft_username_purchase_date or ""
            data["nft_number_enabled"] = bool(self.nft_number_enabled)
            data["nft_numbers"] = self._get_nft_number_tokens()
            data["nft_number"] = self.nft_number or ""
            data["nft_number_price_ton"] = self.nft_number_price_ton or "0"
            data["nft_number_price_usd"] = self.nft_number_price_usd or "0"
            data["nft_number_purchase_date"] = self.nft_number_purchase_date or ""
            data["gift_library"] = self.gift_library or []

            try:
                self._cache_pending = (uid, data)
            except:
                pass

            # Cancel prior scheduled write (coalesce frequent saves).
            try:
                fut = getattr(self, "_cache_save_future", None)
                if fut is not None:
                    try:
                        fut.cancel(False)
                    except:
                        pass
            except:
                pass

            def _write():
                try:
                    # Drain latest snapshot; if more snapshots arrive during IO, write again.
                    while True:
                        pending = getattr(self, "_cache_pending", None)
                        try:
                            self._cache_pending = None
                        except:
                            pass
                        if not pending:
                            break
                        uid2, data2 = pending
                        write_file(_cache_path(uid2), json.dumps(data2))
                        _log("Cache saved")
                except Exception as e:
                    _log(f"Cache save error: {e}")

            try:
                d = int(delay_ms or 0)
            except:
                d = 0
            if d <= 0:
                self._cache_save_future = None
                self._bg_submit(_write, delay_ms=0)
            else:
                self._cache_save_future = self._bg_submit(_write, delay_ms=d)
        except Exception as e:
            _log(f"Cache save error: {e}")

    def _load_cache(self, uid=None):
        try:
            uid = self._get_cache_uid() if uid is None else uid
            raw = read_file(_cache_path(uid))
            loaded_legacy = False
            if (not raw) and uid:
                # Backward-compatible: import shared cache once into user-specific file.
                raw = read_file(_cache_path())
                loaded_legacy = bool(raw)
            if raw:
                data = json.loads(raw)
                try:
                    self._cache_file_user_id = int(data.get("cache_user_id", 0) or 0)
                except:
                    self._cache_file_user_id = 0
                self.cached_gift_id = data.get("gift_id", None)
                cfg = data.get("build_config", None)
                if cfg:
                    self.build_config = cfg
                self.inject_active = data.get("inject_active", False)
                self.wear_active = bool(data.get("wear_active", False))
                self.wear_collectible_id = self._to_int(data.get("wear_collectible_id", 0), 0)
                self.wear_status_data = data.get("wear_status_data", {})
                self.nft_username_enabled = bool(data.get("nft_username_enabled", False))
                cached_tokens = data.get("nft_usernames", [])
                if not isinstance(cached_tokens, list):
                    cached_tokens = []
                legacy_token = self._normalize_nft_username(data.get("nft_username", ""))
                if legacy_token:
                    cached_tokens.append(legacy_token)
                self._set_nft_username_tokens(cached_tokens)
                self.nft_username_price_ton = str(data.get("nft_username_price_ton", "10.8"))
                self.nft_username_price_usd = str(data.get("nft_username_price_usd", "14.68"))
                self.nft_username_purchase_date = str(data.get("nft_username_purchase_date", ""))

                self.nft_number_enabled = bool(data.get("nft_number_enabled", False))
                cached_nums = data.get("nft_numbers", [])
                if not isinstance(cached_nums, list):
                    cached_nums = []
                legacy_num = self._normalize_nft_number(data.get("nft_number", ""))
                if legacy_num:
                    cached_nums.append(legacy_num)
                self._set_nft_number_tokens(cached_nums)
                self.nft_number_price_ton = str(data.get("nft_number_price_ton", "10.8"))
                self.nft_number_price_usd = str(data.get("nft_number_price_usd", "14.68"))
                self.nft_number_purchase_date = str(data.get("nft_number_purchase_date", ""))

                lib = data.get("gift_library", [])
                if isinstance(lib, list):
                    self.gift_library = lib
                else:
                    self.gift_library = []
                self.gift_objects = {}
                self._rebuild_injection_payloads()
                if self.wear_active and self.wear_collectible_id > 0:
                    try:
                        if self._sync_wear_status_data_from_library(self.wear_collectible_id):
                            pass
                    except:
                        pass
                _log(f"Cache loaded: gift_id={self.cached_gift_id}, inject_active={self.inject_active}, wear_active={self.wear_active}, wear_collectible_id={self.wear_collectible_id}, wear_status_data_keys={list(self.wear_status_data.keys())}")
                if loaded_legacy and uid:
                    try:
                        write_file(_cache_path(uid), json.dumps(data))
                        _log(f"Legacy cache imported -> {_cache_path(uid)}")
                    except:
                        pass
        except Exception as e:
            _log(f"Cache load error: {e}")

    def _save_injection_cache(self):
        """Serialize the injection payload (TL_savedStarGift) to disk."""
        try:
            uid = self._get_cache_uid()
        except:
            uid = 0
        payload = self.injection_payload
        path = _injection_cache_path(uid)

        # Cancel prior scheduled write (coalesce).
        try:
            fut = getattr(self, "_inj_save_future", None)
            if fut is not None:
                try:
                    fut.cancel(False)
                except:
                    pass
        except:
            pass

        def _write():
            try:
                if not payload:
                    # Avoid resurrecting deleted gifts via legacy injection cache import.
                    try:
                        if os.path.exists(path):
                            os.remove(path)
                    except:
                        pass
                    return
                b64 = serialize_tl_object(payload)
                if b64:
                    write_file(path, b64)
                    _log(f"Injection cache saved ({len(b64)} chars)")
            except Exception as e:
                _log(f"Injection cache save error: {e}")

        # Injection cache is written rarely; do it ASAP in background.
        self._inj_save_future = self._bg_submit(_write, delay_ms=0)

    def _load_injection_cache(self, uid=None):
        """Deserialize the injection payload from disk on startup."""
        try:
            uid = self._get_cache_uid() if uid is None else uid
            raw = read_file(_injection_cache_path(uid))
            loaded_legacy = False
            if (not raw) and uid:
                raw = read_file(_injection_cache_path())
                loaded_legacy = bool(raw)
            if raw and len(raw) > 10:
                obj = deserialize_tl_saved_gift(raw.strip())
                if obj:
                    gift = self._extract_wrapper_gift(obj)
                    slug = str(get_val(gift, "slug", "")) if gift else ""
                    exists = False
                    for e in (self.gift_library or []):
                        if slug and str(e.get("slug", "")) == slug:
                            exists = True
                            break
                    if not exists:
                        self._normalize_saved_gift_for_actions(obj, force_pin=True, update_date=False)
                        self._library_upsert_wrapper(obj, base_gift_id=self.cached_gift_id or 0, key=None, inject=True, make_active=False)
                        self._save_cache()
                        _log("Legacy injection imported to library")
                    if loaded_legacy and uid:
                        try:
                            write_file(_injection_cache_path(uid), raw)
                            _log(f"Legacy injection imported -> {_injection_cache_path(uid)}")
                        except:
                            pass
                else:
                    _log("Injection cache: deserialization returned None")
        except Exception as e:
            _log(f"Injection cache load error: {e}")

    def _clear_cache(self):
        self.stolen_gift_wrapper = None
        self.stolen_gift_inner = None
        self.cls_saved = None
        self.cls_unique = None
        self.injection_payload = None
        self.injection_payloads = []
        self.inject_active = False
        self.gift_library = []
        self.gift_objects = {}
        self.editing_gift_key = None
        self.wear_active = False
        self.wear_collectible_id = 0
        self.wear_status_data = {}
        self.cached_gift_id = None
        self.nft_username_enabled = False
        self.nft_usernames = []
        self.nft_username = ""
        self.nft_username_price_ton = "10.8"
        self.nft_username_price_usd = "14.68"
        self.nft_username_purchase_date = ""
        self.nft_collectible_template = None
        self.nft_number_enabled = False
        self.nft_numbers = []
        self.nft_number = ""
        self.nft_number_price_ton = "10.8"
        self.nft_number_price_usd = "14.68"
        self.nft_number_purchase_date = ""
        self.nft_number_collectible_template = None
        self.build_config = {"model": 0, "pattern": 0, "backdrop": 0, "num": 1}
        try:
            uid = self._get_cache_uid()
            for p in [_cache_path(uid), _injection_cache_path(uid)]:
                if os.path.exists(p):
                    os.remove(p)
        except:
            pass
        BulletinHelper.show_success("Кэш сброшен")

    def _to_float(self, value, default=0.0):
        try:
            if value is None:
                return default
            return float(str(value).replace(",", "."))
        except:
            return default

    def _to_decimal(self, value):
        try:
            s = str(value or "").strip().replace(",", ".")
            if not s:
                return Decimal("0")
            # Keep only digits/dot/minus.
            s = re.sub(r"[^0-9.\\-]+", "", s)
            if not s or s == "-" or s == ".":
                return Decimal("0")
            return Decimal(s)
        except (InvalidOperation, Exception):
            return Decimal("0")

    def _dec_to_str(self, dec):
        try:
            s = format(dec.normalize(), "f")
        except:
            try:
                s = str(dec)
            except:
                return "0"
        # Trim trailing zeros and dot.
        if "." in s:
            s = s.rstrip("0").rstrip(".")
        return s if s else "0"

    def _ton_to_nano(self, ton_dec):
        try:
            if ton_dec <= 0:
                return 0
            return int((ton_dec * Decimal("1000000000")).to_integral_value(rounding=ROUND_HALF_UP))
        except:
            return 0

    def _usd_to_cents(self, usd_dec):
        try:
            if usd_dec <= 0:
                return 0
            return int((usd_dec * Decimal("100")).to_integral_value(rounding=ROUND_HALF_UP))
        except:
            return 0

    def _parse_nft_username_date_ts(self):
        txt = str(self.nft_username_purchase_date or "").strip()
        if not txt:
            return 0
        if txt.isdigit():
            return self._to_int(txt, 0)
        for fmt in [
            "%d.%m.%Y %H:%M",
            "%d.%m.%Y",
            "%Y-%m-%d %H:%M",
            "%Y-%m-%d",
            "%d/%m/%Y %H:%M",
            "%d/%m/%Y",
        ]:
            try:
                parsed = time.strptime(txt, fmt)
                return int(time.mktime(parsed))
            except:
                pass
        return 0

    def _parse_nft_number_date_ts(self):
        txt = str(self.nft_number_purchase_date or "").strip()
        if not txt:
            return 0
        if txt.isdigit():
            return self._to_int(txt, 0)
        for fmt in [
            "%d.%m.%Y %H:%M",
            "%d.%m.%Y",
            "%Y-%m-%d %H:%M",
            "%Y-%m-%d",
            "%d/%m/%Y %H:%M",
            "%d/%m/%Y",
        ]:
            try:
                parsed = time.strptime(txt, fmt)
                return int(time.mktime(parsed))
            except:
                pass
        return 0

    def _create_tl_username_entry(self, token):
        token = self._normalize_nft_username(token)
        if not token:
            return None
        try:
            UsernameCls = jclass("org.telegram.tgnet.TLRPC$TL_username")
            entry = UsernameCls()
            self._set_field(entry, "username", token)
            self._set_field(entry, "active", True)
            self._set_field(entry, "editable", False)
            self._set_field(entry, "flags", 2)
            return entry
        except Exception as e:
            _log(f"TL_username create failed: {e}")
            return None

    def _ensure_string_in_list(self, lst, value):
        if lst is None or not value:
            return False
        try:
            size = lst.size()
        except:
            return False
        for i in range(size):
            try:
                if str(lst.get(i)).lower() == str(value).lower():
                    return False
            except:
                pass
        try:
            lst.add(value)
            return True
        except:
            return False

    def _ensure_username_in_list(self, lst, token):
        token = self._normalize_nft_username(token)
        if lst is None or not token:
            return False
        changed = False
        found = False
        try:
            size = lst.size()
        except:
            return False

        for i in range(size):
            item = None
            try:
                item = lst.get(i)
            except:
                continue

            uname = self._normalize_nft_username(get_val(item, "username", item))
            if uname.lower() != token.lower():
                continue
            found = True
            try:
                if self._set_field(item, "active", True):
                    changed = True
                if self._set_field(item, "editable", False):
                    changed = True
                self._set_field(item, "flags", 2)
            except:
                pass

        if found:
            return changed

        entry = self._create_tl_username_entry(token)
        try:
            if entry is not None:
                lst.add(0, entry)
                return True
            lst.add(token)
            return True
        except:
            return False

    def _apply_nft_username_to_user(self, user_obj):
        if user_obj is None or not self._is_nft_username_active():
            return False

        my_id = self._get_my_user_id()
        uid = self._extract_user_id_from_obj(user_obj)
        # Only apply to self; if we can't resolve uid, do not patch to avoid leaking to other users.
        if my_id > 0 and uid != my_id:
            return False

        tokens = self._get_nft_username_tokens()
        if not tokens:
            return False

        changed = False

        usernames = get_val(user_obj, "usernames", None)
        if usernames is None:
            try:
                tmp = ArrayList()
                if self._set_field(user_obj, "usernames", tmp):
                    usernames = tmp
                    changed = True
            except:
                usernames = None

        if usernames is not None:
            for token in tokens:
                if self._ensure_username_in_list(usernames, token):
                    changed = True

        for list_name in ["active_usernames", "editable_usernames"]:
            lst = get_val(user_obj, list_name, None)
            if lst is None:
                continue
            for token in tokens:
                if self._ensure_string_in_list(lst, token):
                    changed = True

        return changed

    def _apply_nft_username_to_full_user(self, full_user_obj):
        if full_user_obj is None or not self._is_nft_username_active():
            return False
        my_id = self._get_my_user_id()
        if my_id > 0:
            uid = 0
            try:
                # UserFull usually has nested user.
                nested = get_val(full_user_obj, "user", None)
                if nested is not None:
                    uid = self._extract_user_id_from_obj(nested)
            except:
                uid = 0
            if uid <= 0:
                try:
                    uid = self._extract_user_id_from_obj(full_user_obj)
                except:
                    uid = 0
            if uid != my_id:
                return False
        changed = False
        tokens = self._get_nft_username_tokens()
        if not tokens:
            return False

        usernames = get_val(full_user_obj, "usernames", None)
        if usernames is None:
            try:
                tmp = ArrayList()
                if self._set_field(full_user_obj, "usernames", tmp):
                    usernames = tmp
                    changed = True
            except:
                usernames = None

        if usernames is not None:
            for token in tokens:
                if self._ensure_username_in_list(usernames, token):
                    changed = True
        return changed

    def _apply_nft_number_to_user(self, user_obj):
        if user_obj is None or not self._is_nft_number_active():
            return False

        my_id = self._get_my_user_id()
        uid = self._extract_user_id_from_obj(user_obj)
        # Some UI paths (drawer/account list) may pass a User-like object where id extraction fails.
        # Only block patching when we can confidently detect it's another user.
        if my_id > 0 and uid > 0 and uid != my_id:
            return False

        token = self._get_primary_nft_number()
        if not token:
            return False

        changed = False
        # User.phone usually stores digits only (without '+'). Patch common field names and any string
        # fields that look like phone storage (forks may rename them).
        try:
            if self._set_field(user_obj, "phone", token):
                changed = True
        except:
            pass
        try:
            for f in user_obj.getClass().getFields():
                try:
                    field_name = str(f.getName() or "")
                    low = field_name.lower()
                    typ = f.getType().getName()
                except:
                    continue
                if typ != "java.lang.String":
                    continue
                if ("phone" in low) or (low in ["number", "phone_number", "phoneNumber"]):
                    if self._set_field(user_obj, field_name, token):
                        changed = True
        except:
            pass
        return changed

    def _apply_nft_number_to_full_user(self, full_user_obj):
        if full_user_obj is None or not self._is_nft_number_active():
            return False

        my_id = self._get_my_user_id()
        if my_id > 0:
            uid = 0
            try:
                nested = get_val(full_user_obj, "user", None)
                if nested is not None:
                    uid = self._extract_user_id_from_obj(nested)
            except:
                uid = 0
            if uid <= 0:
                try:
                    uid = self._extract_user_id_from_obj(full_user_obj)
                except:
                    uid = 0
            if uid != my_id:
                return False

        token = self._get_primary_nft_number()
        if not token:
            return False

        changed = False
        # Best-effort: patch any string fields that look like phone storage.
        try:
            for f in full_user_obj.getClass().getFields():
                field_name = f.getName()
                low = field_name.lower()
                typ = f.getType().getName()
                if typ != "java.lang.String":
                    continue
                if "phone" in low:
                    if self._set_field(full_user_obj, field_name, token):
                        changed = True
        except:
            pass
        return changed

    def _apply_nft_number_to_obj(self, obj):
        if obj is None or not self._is_nft_number_active():
            return False
        changed = False
        if self._apply_nft_number_to_user(obj):
            changed = True
        if self._apply_nft_number_to_full_user(obj):
            changed = True
        try:
            nested_user = get_val(obj, "user", None)
            if nested_user and self._apply_nft_number_to_user(nested_user):
                changed = True
        except:
            pass
        return changed

    def _patch_nft_number_in_response(self, response, req_name=""):
        if response is None or not self._is_nft_number_active():
            return 0

        patched = 0
        try:
            if self._apply_nft_number_to_obj(response):
                patched += 1
        except:
            pass

        try:
            for f in response.getClass().getFields():
                val = f.get(response)
                if val is None:
                    continue
                if f.getType() == ArrayList:
                    try:
                        size = val.size()
                    except:
                        size = 0
                    for i in range(size):
                        try:
                            item = val.get(i)
                        except:
                            continue
                        if self._apply_nft_number_to_obj(item):
                            patched += 1
                else:
                    if self._apply_nft_number_to_obj(val):
                        patched += 1
        except:
            pass

        if patched:
            _log(f"NFT number patched in response ({req_name}): {patched}")
        return patched

    def _apply_nft_username_to_obj(self, obj):
        if obj is None or not self._is_nft_username_active():
            return False
        changed = False
        if self._apply_nft_username_to_user(obj):
            changed = True
        if self._apply_nft_username_to_full_user(obj):
            changed = True
        try:
            nested_user = get_val(obj, "user", None)
            if nested_user and self._apply_nft_username_to_user(nested_user):
                changed = True
        except:
            pass
        return changed

    def _patch_nft_username_in_response(self, response, req_name=""):
        if response is None or not self._is_nft_username_active():
            return 0

        patched = 0
        try:
            if self._apply_nft_username_to_obj(response):
                patched += 1
        except:
            pass

        try:
            for f in response.getClass().getFields():
                val = f.get(response)
                if val is None:
                    continue
                if f.getType() == ArrayList:
                    try:
                        size = val.size()
                    except:
                        size = 0
                    for i in range(size):
                        try:
                            item = val.get(i)
                        except:
                            continue
                        if self._apply_nft_username_to_obj(item):
                            patched += 1
                else:
                    if self._apply_nft_username_to_obj(val):
                        patched += 1
        except:
            pass

        if patched:
            _log(f"NFT username patched in response ({req_name}): {patched}")
        return patched

    def _build_my_peer_user(self):
        try:
            my_id = self._get_my_user_id()
            if my_id <= 0:
                return None
            PeerUser = jclass("org.telegram.tgnet.TLRPC$TL_peerUser")
            peer = PeerUser()
            peer.user_id = my_id
            return peer
        except:
            return None

    def _get_my_user_object(self):
        try:
            my_id = self._get_my_user_id()
            if my_id <= 0:
                return None
            account = to_java_int(get_user_config().selectedAccount)
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            ctrl = MessagesController.getInstance(account)
            return ctrl.getUser(my_id)
        except:
            return None

    def _extract_collectible_request_token(self, req):
        if req is None:
            return ""
        managed = [t.lower() for t in self._get_nft_username_tokens()]

        def _pick_from_raw(raw):
            token = self._normalize_nft_username(raw)
            if not token:
                return ""
            if managed and token.lower() in managed:
                return token
            return token

        for field_name in ["username", "slug", "name", "query"]:
            try:
                raw = get_val(req, field_name, None)
                if raw is None:
                    continue
                token = _pick_from_raw(raw)
                if token:
                    return token
            except:
                pass
        try:
            for f in req.getClass().getFields():
                try:
                    if f.getType().getName() != "java.lang.String":
                        continue
                    raw = f.get(req)
                    token = _pick_from_raw(raw)
                    if token:
                        return token
                except:
                    pass
        except:
            pass
        return ""

    def _extract_collectible_request_kind_and_token(self, req):
        """
        Best-effort detection for Fragment collectible info requests.
        Returns ("username", token) or ("number", digits) or ("", "").
        """
        if req is None:
            return ("", "")

        def _iter_strings(obj):
            # Prefer common field names first.
            for field_name in ["phone", "phone_number", "number", "username", "slug", "name", "query"]:
                try:
                    raw = get_val(obj, field_name, None)
                    if raw is not None:
                        yield (field_name, raw)
                except:
                    pass
            try:
                for f in obj.getClass().getFields():
                    try:
                        if f.getType().getName() != "java.lang.String":
                            continue
                        yield (f.getName(), f.get(obj))
                    except:
                        pass
            except:
                pass

        # 1) Phone-like candidates (field name hint).
        for field_name, raw in _iter_strings(req):
            try:
                low = str(field_name or "").lower()
            except:
                low = ""
            if ("phone" in low) or (low == "number") or ("phone_number" in low):
                num = self._normalize_nft_number(raw)
                if num:
                    return ("number", num)

        # 2) Username-like candidates (field name hint).
        for field_name, raw in _iter_strings(req):
            try:
                low = str(field_name or "").lower()
            except:
                low = ""
            if ("user" in low) or (low in ["username", "slug", "name", "query"]):
                token = self._normalize_nft_username(raw)
                if token and re.search(r"[A-Za-z_]", token):
                    return ("username", token)

        # 3) Fallback: scan any string values.
        for _, raw in _iter_strings(req):
            num = self._normalize_nft_number(raw)
            if num:
                return ("number", num)
            token = self._normalize_nft_username(raw)
            if token and re.search(r"[A-Za-z_]", token):
                return ("username", token)

        return ("", "")

    def _create_fake_collectible_response(self, token):
        token = self._normalize_nft_username(token)
        if not token:
            return None

        if self.nft_collectible_template is not None:
            return self.nft_collectible_template

        candidates = [
            "org.telegram.tgnet.tl.TL_fragment$TL_collectibleInfo",
            "org.telegram.tgnet.tl.TL_fragment$TL_collectible_info",
            "org.telegram.tgnet.tl.TL_fragment$TL_fragmentCollectibleInfo",
            "org.telegram.tgnet.tl.TL_fragment$TL_fragment_collectibleInfo",
        ]
        for cls_name in candidates:
            try:
                cls = jclass(cls_name)
                obj = cls()
                return obj
            except:
                pass
        return None

    def _create_fake_collectible_number_response(self, digits):
        digits = self._normalize_nft_number(digits)
        if not digits:
            return None
        if self.nft_number_collectible_template is not None:
            return self.nft_number_collectible_template

        candidates = [
            "org.telegram.tgnet.tl.TL_fragment$TL_collectibleInfo",
            "org.telegram.tgnet.tl.TL_fragment$TL_collectible_info",
            "org.telegram.tgnet.tl.TL_fragment$TL_fragmentCollectibleInfo",
            "org.telegram.tgnet.tl.TL_fragment$TL_fragment_collectibleInfo",
        ]
        for cls_name in candidates:
            try:
                cls = jclass(cls_name)
                obj = cls()
                return obj
            except:
                pass
        return None

    def _patch_collectible_info_object(self, obj, forced_token=""):
        if obj is None or not self._is_nft_username_active():
            return 0

        token = self._normalize_nft_username(forced_token) if forced_token else self._get_primary_nft_username()
        if not token:
            return 0

        my_id = self._get_my_user_id()
        my_peer = self._build_my_peer_user()
        my_user = self._get_my_user_object()
        date_ts = self._parse_nft_username_date_ts()
        if date_ts <= 0:
            date_ts = int(time.time())
        ton_dec = self._to_decimal(self.nft_username_price_ton)
        usd_dec = self._to_decimal(self.nft_username_price_usd)
        ton = float(ton_dec) if ton_dec > 0 else 0.0
        usd = float(usd_dec) if usd_dec > 0 else 0.0
        ton_nano = self._ton_to_nano(ton_dec)
        usd_cents = self._usd_to_cents(usd_dec)
        ton_str = self._dec_to_str(ton_dec)
        usd_str = self._dec_to_str(usd_dec)

        patched = 0
        try:
            # Some builds use generic fields without currency hints. Set common ones up-front.
            try:
                if get_val(obj, "price", None) is not None:
                    self._set_field(obj, "price", int(ton_nano))
                    patched += 1
            except:
                pass
            try:
                if get_val(obj, "price_usd", None) is not None:
                    self._set_field(obj, "price_usd", int(usd_cents))
                    patched += 1
            except:
                pass
            try:
                if get_val(obj, "ton_price", None) is not None:
                    self._set_field(obj, "ton_price", int(ton_nano))
                    patched += 1
            except:
                pass
            try:
                if get_val(obj, "usd_price", None) is not None:
                    self._set_field(obj, "usd_price", int(usd_cents))
                    patched += 1
            except:
                pass

            for f in obj.getClass().getFields():
                field_name = f.getName()
                low = field_name.lower()
                typ = f.getType().getName()

                if "username" in low and typ == "java.lang.String":
                    if self._set_field(obj, field_name, token):
                        patched += 1
                    continue

                if "owner" in low:
                    applied = False
                    if my_peer is not None and ("peer" in typ.lower() or "tlrpc$peer" in typ.lower()):
                        if self._set_field(obj, field_name, my_peer):
                            patched += 1
                            applied = True
                    if (not applied) and my_user is not None and ("tlrpc$user" in typ.lower() or typ.lower().endswith("user")):
                        if self._set_field(obj, field_name, my_user):
                            patched += 1
                            applied = True
                    if (not applied) and my_id > 0 and (typ == "int" or typ == "long"):
                        if self._set_field(obj, field_name, my_id):
                            patched += 1
                            applied = True
                    if applied:
                        continue

                if ("date" in low or "time" in low) and (typ == "int" or typ == "long"):
                    if self._set_field(obj, field_name, date_ts):
                        patched += 1
                    continue

                if ("price" in low or "cost" in low or "amount" in low):
                    is_usd = ("usd" in low) or ("dollar" in low)
                    is_ton = ("ton" in low) or ("nano" in low)
                    if typ == "int" or typ == "long":
                        # Prefer explicit currency in field name; otherwise default to TON nano.
                        if is_usd:
                            value = int(usd_cents)
                        else:
                            value = int(ton_nano)
                        if value > 0 and self._set_field(obj, field_name, value):
                            patched += 1
                    elif typ == "float" or typ == "double":
                        value = usd if is_usd else ton
                        if value > 0 and self._set_field(obj, field_name, value):
                            patched += 1
                    elif typ == "java.lang.String":
                        if is_usd:
                            value = usd_str
                        elif is_ton or ("price" in low):
                            value = ton_str
                        else:
                            value = ton_str
                        if self._set_field(obj, field_name, value):
                            patched += 1

            users = get_val(obj, "users", None)
            if users is not None and my_user is not None and my_id > 0:
                exists = False
                try:
                    for i in range(users.size()):
                        u = users.get(i)
                        uid = self._extract_user_id_from_obj(u)
                        if uid == my_id:
                            exists = True
                            break
                except:
                    exists = True
                if not exists:
                    try:
                        users.add(0, my_user)
                        patched += 1
                    except:
                        pass
        except:
            pass
        return patched

    def _patch_collectible_number_info_object(self, obj, forced_digits=""):
        if obj is None or not self._is_nft_number_active():
            return 0

        digits = self._normalize_nft_number(forced_digits) if forced_digits else self._get_primary_nft_number()
        if not digits:
            return 0
        formatted = self._format_nft_number(digits) or digits

        my_id = self._get_my_user_id()
        my_peer = self._build_my_peer_user()
        my_user = self._get_my_user_object()
        date_ts = self._parse_nft_number_date_ts()
        if date_ts <= 0:
            date_ts = int(time.time())
        ton_dec = self._to_decimal(self.nft_number_price_ton)
        usd_dec = self._to_decimal(self.nft_number_price_usd)
        ton = float(ton_dec) if ton_dec > 0 else 0.0
        usd = float(usd_dec) if usd_dec > 0 else 0.0
        ton_nano = self._ton_to_nano(ton_dec)
        usd_cents = self._usd_to_cents(usd_dec)
        ton_str = self._dec_to_str(ton_dec)
        usd_str = self._dec_to_str(usd_dec)

        patched = 0
        try:
            # Generic pricing fields.
            try:
                if get_val(obj, "price", None) is not None:
                    self._set_field(obj, "price", int(ton_nano))
                    patched += 1
            except:
                pass
            try:
                if get_val(obj, "price_usd", None) is not None:
                    self._set_field(obj, "price_usd", int(usd_cents))
                    patched += 1
            except:
                pass

            for f in obj.getClass().getFields():
                field_name = f.getName()
                low = field_name.lower()
                typ = f.getType().getName()

                # Phone / number string.
                if typ == "java.lang.String" and (("phone" in low) or (low in ["number", "phone_number"])):
                    if self._set_field(obj, field_name, formatted):
                        patched += 1
                    continue

                if "owner" in low:
                    applied = False
                    if my_peer is not None and ("peer" in typ.lower() or "tlrpc$peer" in typ.lower()):
                        if self._set_field(obj, field_name, my_peer):
                            patched += 1
                            applied = True
                    if (not applied) and my_user is not None and ("tlrpc$user" in typ.lower() or typ.lower().endswith("user")):
                        if self._set_field(obj, field_name, my_user):
                            patched += 1
                            applied = True
                    if (not applied) and my_id > 0 and (typ == "int" or typ == "long"):
                        if self._set_field(obj, field_name, my_id):
                            patched += 1
                            applied = True
                    if applied:
                        continue

                if ("date" in low or "time" in low) and (typ == "int" or typ == "long"):
                    if self._set_field(obj, field_name, date_ts):
                        patched += 1
                    continue

                if ("price" in low or "cost" in low or "amount" in low):
                    is_usd = ("usd" in low) or ("dollar" in low)
                    is_ton = ("ton" in low) or ("nano" in low)
                    if typ == "int" or typ == "long":
                        value = int(usd_cents) if is_usd else int(ton_nano)
                        if value > 0 and self._set_field(obj, field_name, value):
                            patched += 1
                    elif typ == "float" or typ == "double":
                        value = usd if is_usd else ton
                        if value > 0 and self._set_field(obj, field_name, value):
                            patched += 1
                    elif typ == "java.lang.String":
                        if is_usd:
                            value = usd_str
                        elif is_ton or ("price" in low):
                            value = ton_str
                        else:
                            value = ton_str
                        if self._set_field(obj, field_name, value):
                            patched += 1

            users = get_val(obj, "users", None)
            if users is not None and my_user is not None and my_id > 0:
                exists = False
                try:
                    for i in range(users.size()):
                        u = users.get(i)
                        uid = self._extract_user_id_from_obj(u)
                        if uid == my_id:
                            exists = True
                            break
                except:
                    exists = True
                if not exists:
                    try:
                        users.add(0, my_user)
                        patched += 1
                    except:
                        pass
        except:
            pass
        return patched

    def _patch_collectible_username_info_response(self, response, req_name="", forced_token=""):
        if response is None or not self._is_nft_username_active():
            return 0

        patched = 0

        def _walk(obj, depth=0):
            nonlocal patched
            if obj is None or depth > 3:
                return
            try:
                cls_name = obj.getClass().getSimpleName().lower()
            except:
                return

            if ("collectible" in cls_name) or ("fragment" in cls_name) or ("username" in cls_name):
                patched += self._patch_collectible_info_object(obj, forced_token)

            try:
                for f in obj.getClass().getFields():
                    val = f.get(obj)
                    if val is None:
                        continue
                    if f.getType() == ArrayList:
                        try:
                            size = val.size()
                        except:
                            size = 0
                        for i in range(size):
                            try:
                                _walk(val.get(i), depth + 1)
                            except:
                                pass
                    else:
                        try:
                            if str(val.getClass().getName()).startswith("org.telegram."):
                                _walk(val, depth + 1)
                        except:
                            pass
            except:
                pass

        _walk(response, 0)
        if patched:
            self.nft_collectible_template = response
            _log(f"Collectible info patched ({req_name}): {patched}")
        return patched

    def _patch_collectible_number_info_response(self, response, req_name="", forced_digits=""):
        if response is None or not self._is_nft_number_active():
            return 0

        patched = 0

        def _walk(obj, depth=0):
            nonlocal patched
            if obj is None or depth > 3:
                return
            try:
                cls_name = obj.getClass().getSimpleName().lower()
            except:
                return

            if ("collectible" in cls_name) or ("fragment" in cls_name) or ("phone" in cls_name) or ("number" in cls_name):
                patched += self._patch_collectible_number_info_object(obj, forced_digits)

            try:
                for f in obj.getClass().getFields():
                    val = f.get(obj)
                    if val is None:
                        continue
                    if f.getType() == ArrayList:
                        try:
                            size = val.size()
                        except:
                            size = 0
                        for i in range(size):
                            try:
                                _walk(val.get(i), depth + 1)
                            except:
                                pass
                    else:
                        try:
                            if str(val.getClass().getName()).startswith("org.telegram."):
                                _walk(val, depth + 1)
                        except:
                            pass
            except:
                pass

        _walk(response, 0)
        if patched:
            self.nft_number_collectible_template = response
            _log(f"Collectible number info patched ({req_name}): {patched}")
        return patched

    def _extract_collectible_id(self, obj, depth=0):
        """Best-effort extraction of collectible_id from TL objects (updateEmojiStatus request)."""
        if obj is None or depth > 3:
            return 0

        try:
            cid = get_val(obj, "collectible_id", None)
            if cid is not None:
                return self._to_int(cid, 0)
        except:
            pass

        for field_name in ["emoji_status", "status", "input_status", "emoticon"]:
            try:
                nested = get_val(obj, field_name, None)
                if nested:
                    cid = self._extract_collectible_id(nested, depth + 1)
                    if cid > 0: return cid
            except:
                pass
        
        if depth > 0:
            return 0

        try:
            for f in obj.getClass().getFields():
                name = f.getName()
                if "emoji" not in name and "status" not in name and "collectible" not in name:
                    continue
                try:
                    nested = f.get(obj)
                    cid = self._extract_collectible_id(nested, depth + 1)
                    if cid > 0: return cid
                except:
                    continue
        except:
            pass
        return 0

    def _create_input_collectible_status(self, collectible_id):
        """Create TL_inputEmojiStatusCollectible (for requests)."""
        if collectible_id <= 0:
            return None
        for cls_name in [
            "org.telegram.tgnet.TLRPC$TL_inputEmojiStatusCollectible",
        ]:
            try:
                Cls = jclass(cls_name)
                st = Cls()
                self._set_field(st, "collectible_id", collectible_id)
                try:
                    self._set_field(st, "until", 0)
                except:
                    pass
                return st
            except:
                continue
        return None

    def _rewrite_update_emoji_status_to_collectible(self, req, collectible_id):
        """If Telegram tries to clear status right after wear, rewrite request back to collectible."""
        if req is None or collectible_id <= 0:
            return False
        try:
            input_st = self._create_input_collectible_status(collectible_id)
            if not input_st:
                return False
            if get_val(req, "emoji_status", None) is not None:
                if self._set_field(req, "emoji_status", input_st):
                    return True
            for name in ["status", "input_status"]:
                if get_val(req, name, None) is not None:
                    if self._set_field(req, name, input_st):
                        return True
        except Exception as e:
            _log(f"_rewrite_update_emoji_status_to_collectible error: {e}")
        return False

    def _create_collectible_status(self, collectible_id):
        if collectible_id <= 0:
            return None
        for cls_name in [
            "org.telegram.tgnet.TLRPC$TL_emojiStatusCollectible",
        ]:
            try:
                Cls = jclass(cls_name)
                st = Cls()
                self._set_field(st, "collectible_id", collectible_id)
                try:
                    self._set_field(st, "until", 0)
                except:
                    pass
                wsd = self.wear_status_data
                if wsd:
                    for color_field in ["center_color", "edge_color", "pattern_color", "text_color"]:
                        val = wsd.get(color_field, 0)
                        if val:
                            self._set_field(st, color_field, int(val))
                    for long_field in ["document_id", "pattern_document_id"]:
                        val = wsd.get(long_field, 0)
                        if val:
                            self._set_field(st, long_field, int(val))
                    for str_field in ["title", "slug"]:
                        val = wsd.get(str_field, "")
                        if val:
                            self._set_field(st, str_field, str(val))
                    _log(f"emojiStatusCollectible filled: colors=[{wsd.get('center_color',0)},{wsd.get('edge_color',0)}], doc={wsd.get('document_id',0)}, title={wsd.get('title','?')}")
                return st
            except:
                continue
        return None

    def _apply_wear_to_user(self, user_obj):
        """Patch TLRPC.User object in-place."""
        if user_obj is None:
            return False
        if not self.wear_active or self.wear_collectible_id <= 0:
            return False
        my_id = self._get_my_user_id()
        if my_id <= 0:
            return False
        try:
            uid = self._to_int(get_val(user_obj, "id", 0), 0)
        except:
            uid = 0
        if uid != my_id:
            return False

        st = self._create_collectible_status(self.wear_collectible_id)
        if not st:
            return False
        if self._set_field(user_obj, "emoji_status", st):
            _log(f"emoji_status set on User(id={uid}) collectible_id={self.wear_collectible_id}")
            return True
        return False

    def _apply_wear_to_obj(self, obj):
        """Patch cached profile objects (username spoof + wearable status)."""
        if obj is None:
            return False
        changed = False
        if self._apply_nft_username_to_obj(obj):
            changed = True
        if self._apply_nft_number_to_obj(obj):
            changed = True
        if self._apply_wear_to_user(obj):
            changed = True
        try:
            nested = get_val(obj, "user", None)
            if nested and self._apply_wear_to_user(nested):
                changed = True
        except:
            pass
        if not self.wear_active or self.wear_collectible_id <= 0:
            return changed
        my_id = self._get_my_user_id()
        if my_id <= 0:
            return changed
        try:
            oid = self._to_int(get_val(obj, "id", 0), 0)
        except:
            oid = 0
        if oid != my_id:
            return changed
        st = self._create_collectible_status(self.wear_collectible_id)
        if not st:
            return changed
        if self._set_field(obj, "emoji_status", st):
            _log(f"emoji_status set on Obj({obj.getClass().getSimpleName()}) id={oid} collectible_id={self.wear_collectible_id}")
            changed = True
        return changed

    def _patch_my_cached_user(self):
        """Force-patch current cached User object so UI updates immediately."""
        if (not self._is_nft_username_active()) and (not self._is_nft_number_active()) and (not self.wear_active or self.wear_collectible_id <= 0):
            return
        try:
            account = get_user_config().selectedAccount
            MC = jclass("org.telegram.messenger.MessagesController")
            ctrl = MC.getInstance(to_java_int(account))
            my_id = self._get_my_user_id()
            if my_id <= 0:
                return
            user_obj = ctrl.getUser(my_id)
            if user_obj:
                has_changes = False
                if self._is_nft_username_active():
                    if self._apply_nft_username_to_user(user_obj):
                        has_changes = True
                if self._is_nft_number_active():
                    if self._apply_nft_number_to_user(user_obj):
                        has_changes = True

                if self.wear_active and self.wear_collectible_id > 0:
                    current_id = self._extract_collectible_id(user_obj)
                    if current_id != self.wear_collectible_id and self._apply_wear_to_obj(user_obj):
                        has_changes = True

                if has_changes:
                    try:
                        ctrl.putUser(user_obj, False)
                        _log(f"UI Forced Update for {my_id}")
                    except:
                        pass
            try:
                self._patch_userconfig_current_user()
            except:
                pass
        except Exception as e:
            _log(f"_patch_my_cached_user error: {e}")

    def _patch_userconfig_current_user(self):
        """Patch UserConfig cached currentUser field so all UI (drawer/account list) is consistent."""
        if (not self._is_nft_username_active()) and (not self._is_nft_number_active()) and (not self.wear_active or self.wear_collectible_id <= 0):
            return False

        my_id = self._get_my_user_id()
        if my_id <= 0:
            return False

        patched_any = False
        try:
            targets = []
            try:
                targets.append(get_user_config())
            except:
                pass

            try:
                UC = jclass("org.telegram.messenger.UserConfig")
                for i in range(0, 4):
                    try:
                        inst = UC.getInstance(to_java_int(i))
                        if inst is not None:
                            targets.append(inst)
                    except:
                        pass
            except:
                pass

            seen = set()
            for uc in targets:
                if uc is None:
                    continue
                try:
                    key = str(uc)
                except:
                    key = None
                if key and key in seen:
                    continue
                if key:
                    seen.add(key)

                u = None
                try:
                    u = uc.getCurrentUser()
                except:
                    u = None
                if u is None:
                    try:
                        u = get_val(uc, "currentUser", None)
                    except:
                        u = None
                if u is None:
                    continue

                try:
                    uid = self._to_int(get_val(u, "id", 0), 0)
                except:
                    uid = 0
                if uid != my_id:
                    continue

                changed = False
                if self._apply_wear_to_obj(u):
                    changed = True

                if changed:
                    # Some UI (drawer header) may take phone number from UserConfig fields, not from user.phone.
                    # Patch any phone-like string fields on UserConfig to keep it consistent.
                    if self._is_nft_number_active():
                        try:
                            token = self._get_primary_nft_number()
                        except:
                            token = ""
                        if token:
                            try:
                                for f in uc.getClass().getDeclaredFields():
                                    try:
                                        f.setAccessible(True)
                                    except:
                                        pass
                                    try:
                                        name = str(f.getName() or "")
                                        low = name.lower()
                                        typ = f.getType().getName()
                                    except:
                                        continue
                                    if typ != "java.lang.String":
                                        continue
                                    if "phone" in low:
                                        try:
                                            self._set_field(uc, name, token)
                                        except:
                                            pass
                            except:
                                pass
                    for field_name in ["currentUser", "user"]:
                        try:
                            if get_val(uc, field_name, None) is not None:
                                self._set_field(uc, field_name, u)
                        except:
                            pass
                    patched_any = True
        except Exception as e:
            _log(f"_patch_userconfig_current_user error: {e}")

        return patched_any

    def _on_update_emoji_status_request(self, req):
        """Persist wearable collectible_id on outgoing updateEmojiStatus."""
        try:
            cid = self._extract_collectible_id(req)
        except:
            cid = 0
        now = time.time()

        if cid > 0:
            changed = (self.wear_collectible_id != cid) or (not self.wear_active)
            self.wear_active = True
            self.wear_collectible_id = cid
            self.wear_ignore_clear_once = True
            self.wear_last_collectible_ts = now
            try:
                self._sync_wear_status_data_from_library(cid)
            except:
                pass
            if changed:
                _log(f"WEAR SET: collectible_id={cid}")
                self._save_cache()
            self._patch_my_cached_user()
            return cid

        if self.wear_ignore_clear_once and (now - self.wear_last_collectible_ts) < 3.0:
            self.wear_ignore_clear_once = False
            _log("WEAR: ignored auto-clear")
            return 0

        self.wear_ignore_clear_once = False
        if self.wear_active or self.wear_collectible_id:
            self.wear_active = False
            self.wear_collectible_id = 0
            _log("WEAR CLEARED (by request)")
            self._save_cache()
        return 0

    def _patch_users_in_container(self, obj, depth=0):
        """Patch any User/UserFull objects inside a TL container (responses)."""
        if obj is None or depth > 3:
            return 0
        if not self.wear_active or self.wear_collectible_id <= 0:
            return 0

        patched = 0
        
        is_list = False
        try:
            if "util.List" in obj.getClass().getInterfaces()[0].getName() or "ArrayList" in obj.getClass().getName():
                is_list = True
        except:
            pass
            
        if is_list:
            try:
                size = obj.size()
                for i in range(size):
                    item = obj.get(i)
                    if self._apply_wear_to_obj(item):
                        patched += 1
                    patched += self._patch_users_in_container(item, depth + 1)
            except:
                pass
            return patched

        if self._apply_wear_to_obj(obj):
            patched += 1

        known_fields = ["users", "chats", "objects", "results"]
        for name in known_fields:
            try:
                f = obj.getClass().getField(name)
                val = f.get(obj)
                if val:
                    patched += self._patch_users_in_container(val, depth + 1)
            except:
                pass
        
        if depth < 1:
            try:
                for f in obj.getClass().getFields():
                    name = f.getName()
                    if name in known_fields: continue
                    
                    if f.getType().isPrimitive() or f.getType().getName() == "java.lang.String":
                        continue
                        
                    try:
                        val = f.get(obj)
                        if val:
                             patched += self._patch_users_in_container(val, depth + 1)
                    except:
                        pass
            except:
                pass
                
        return patched

    def _patch_update_user_emoji_status(self, upd):
        """Rewrite TL_updateUserEmojiStatus for self to our collectible status."""
        if upd is None:
            return False
        if not self.wear_active or self.wear_collectible_id <= 0:
            return False
        my_id = self._get_my_user_id()
        if my_id <= 0:
            return False

        try:
            name_l = upd.getClass().getSimpleName().lower()
        except:
            name_l = ""

        has_emoji_field = False
        try:
            if get_val(upd, "emoji_status", None) is not None:
                has_emoji_field = True
        except:
            pass

        if ("updateuseremojistatus" not in name_l) and (not has_emoji_field):
            return False

        uid = 0
        try:
            uid = self._to_int(get_val(upd, "user_id", 0), 0)
        except:
            uid = 0
        if uid <= 0:
            try:
                uid = self._extract_user_id_from_obj(get_val(upd, "user", None))
            except:
                uid = 0
        if uid != my_id:
            return False

        st = self._create_collectible_status(self.wear_collectible_id)
        if not st:
            return False
        if self._set_field(upd, "emoji_status", st):
            _log(f"updateUserEmojiStatus patched for self collectible_id={self.wear_collectible_id}")
            return True
        return False

    def _patch_wear_in_updates_container(self, obj, depth=0):
        """Patch Updates containers: updateUserEmojiStatus + nested users."""
        if obj is None or depth > 4:
            return 0
        if not self.wear_active or self.wear_collectible_id <= 0:
            return 0

        patched = 0

        if self._patch_update_user_emoji_status(obj):
            patched += 1

        if self._apply_wear_to_obj(obj):
            patched += 1

        try:
            cls_name_l = obj.getClass().getName().lower()
            if "arraylist" in cls_name_l or "java.util" in cls_name_l:
                try:
                    size = obj.size()
                except:
                    size = -1
                if size >= 0:
                    for i in range(size):
                        try:
                            item = obj.get(i)
                        except:
                            continue
                        patched += self._patch_wear_in_updates_container(item, depth + 1)
                    return patched
        except:
            pass

        try:
            for f in obj.getClass().getFields():
                try:
                    val = f.get(obj)
                except:
                    continue
                if val is None:
                    continue
                patched += self._patch_wear_in_updates_container(val, depth + 1)
        except:
            pass
        return patched

    def _hook_updates_wear(self):
        """Patch incoming Updates before Telegram applies them (prevents server from clearing emoji_status)."""
        try:
            MC = jclass("org.telegram.messenger.MessagesController")
        except Exception as e:
            _log(f"Updates wear hook skipped (MessagesController missing): {e}")
            return

        hooked = 0
        seen = set()

        def _sig(m):
            try:
                params = m.getParameterTypes()
                p_names = ",".join([p.getName() for p in params])
                return f"{m.getDeclaringClass().getName()}::{m.getName()}({p_names})"
            except:
                return str(m)

        try:
            for m in MC.getDeclaredMethods():
                try:
                    n = m.getName()
                    if ("processUpdates" not in n) and ("processUpdatesQueue" not in n):
                        continue
                except:
                    continue
                sig = _sig(m)
                if sig in seen:
                    continue
                seen.add(sig)
                try:
                    params = m.getParameterTypes()
                    if not params:
                        continue
                except:
                    continue
                m.setAccessible(True)
                self.hooks_refs.append(self.hook_method(m, ProcessUpdatesWearHook(self)))
                hooked += 1
                _log(f"Updates wear hooked: {sig}")
        except Exception as e:
            _log(f"Updates wear hook scan failed: {e}")

        if hooked:
            _log(f"Updates wear hooks installed: {hooked}")
        else:
            _log("Updates wear hooks: nothing installed")

        try:
            for m in MC.getDeclaredMethods():
                try:
                    n = m.getName()
                except:
                    continue
                if n not in ["userEmojiStatusUpdated", "recentEmojiStatusesUpdate", "updateEmojiStatusUntilUpdate", "updateEmojiStatusUntil"]:
                    continue
                sig = _sig(m)
                if sig in seen:
                    continue
                seen.add(sig)
                try:
                    m.setAccessible(True)
                except:
                    pass
                self.hooks_refs.append(self.hook_method(m, EmojiStatusCallbackHook(self)))
                hooked += 1
                _log(f"Emoji status cb hooked: {sig}")
        except Exception as e:
            _log(f"Emoji status cb hook scan failed: {e}")

    def _hook_userconfig_wear(self):
        """Patch when current user is set, so it can't be overwritten to empty status."""
        try:
            UC = jclass("org.telegram.messenger.UserConfig")
        except Exception as e:
            _log(f"UserConfig wear hooks skipped: {e}")
            return
        hooked = 0
        try:
            for m in UC.getDeclaredMethods():
                try:
                    if m.getName() != "setCurrentUser":
                        continue
                    params = m.getParameterTypes()
                    if len(params) < 1:
                        continue
                    if "org.telegram.tgnet.TLRPC$User" not in params[0].getName():
                        continue
                except:
                    continue
                m.setAccessible(True)
                self.hooks_refs.append(self.hook_method(m, SetCurrentUserWearHook(self)))
                hooked += 1
        except Exception as e:
            _log(f"UserConfig wear hook scan failed: {e}")
        if hooked:
            _log(f"UserConfig setCurrentUser wear hooks installed: {hooked}")

    def _hook_wear_user_cache(self):
        """Patch MessagesController cache access so collectible status survives profile re-open."""
        try:
            MC = jclass("org.telegram.messenger.MessagesController")
        except Exception as e:
            _log(f"MessagesController not found, skip wear hooks: {e}")
            return

        hooked = 0
        seen = set()

        def _sig(m):
            try:
                params = m.getParameterTypes()
                p_names = ",".join([p.getName() for p in params])
                return f"{m.getDeclaringClass().getName()}::{m.getName()}({p_names})"
            except:
                return str(m)

        try:
            for m in MC.getDeclaredMethods():
                name = m.getName()
                sig = _sig(m)
                if sig in seen:
                    continue
                seen.add(sig)

                if name in ["getUser", "getUserOrChat", "getUserFull"]:
                    try:
                        params = m.getParameterTypes()
                        if len(params) < 1:
                            continue
                    except:
                        continue
                    try:
                        ret = m.getReturnType().getName()
                        if ("org.telegram.tgnet.TLRPC$User" not in ret) and ("org.telegram.tgnet.TLRPC$UserFull" not in ret):
                            continue
                    except:
                        pass
                    m.setAccessible(True)
                    self.hooks_refs.append(self.hook_method(m, GetAnyWearHook(self)))
                    hooked += 1
                    continue

                if name in ["putUser", "putUserFull"]:
                    try:
                        params = m.getParameterTypes()
                        if len(params) < 1:
                            continue
                        p0 = params[0].getName()
                        if ("org.telegram.tgnet.TLRPC$User" not in p0) and ("org.telegram.tgnet.TLRPC$UserFull" not in p0):
                            continue
                    except:
                        continue
                    m.setAccessible(True)
                    self.hooks_refs.append(self.hook_method(m, PutAnyWearHook(self)))
                    hooked += 1
                    continue

                if name == "putUsers":
                    try:
                        params = m.getParameterTypes()
                        if len(params) < 1:
                            continue
                        p0 = params[0].getName()
                        if "java.util" not in p0.lower():
                            continue
                    except:
                        continue
                    m.setAccessible(True)
                    self.hooks_refs.append(self.hook_method(m, PutUsersWearHook(self)))
                    hooked += 1
        except Exception as e:
            _log(f"Wear hook scan failed: {e}")

        if hooked:
            _log(f"Wear hooks installed: {hooked}")
        else:
            _log("Wear hooks: nothing installed (no matching methods)")

        try:
            UC = jclass("org.telegram.messenger.UserConfig")
            seen_uc = set()
            for m in UC.getDeclaredMethods():
                try:
                    if m.getName() != "getCurrentUser":
                        continue
                    if len(m.getParameterTypes()) != 0:
                        continue
                except:
                    continue
                try:
                    ret = m.getReturnType().getName()
                    if "org.telegram.tgnet.TLRPC$User" not in ret:
                        continue
                except:
                    pass
                sig = _sig(m)
                if sig in seen_uc:
                    continue
                seen_uc.add(sig)
                m.setAccessible(True)
                self.hooks_refs.append(self.hook_method(m, GetAnyWearHook(self)))
                _log(f"Wear hook installed: {sig}")
        except Exception as e:
            _log(f"UserConfig wear hook skipped: {e}")

    def _get_profile_activity_user_id(self, profile_activity):
        """Best-effort resolve target user_id for ProfileActivity instance."""
        if profile_activity is None:
            return 0
        for name in ["userId", "user_id", "uid", "currentUserId", "current_user_id"]:
            try:
                v = get_val(profile_activity, name, None)
                if v is None:
                    continue
                uid = self._to_int(v, 0)
                if uid > 0:
                    return uid
            except:
                pass
        for name in ["user", "currentUser", "userInfo", "userFull"]:
            try:
                u = get_val(profile_activity, name, None)
                if u is None:
                    continue
                try:
                    nested = get_val(u, "user", None)
                    if nested is not None:
                        u = nested
                except:
                    pass
                uid = self._to_int(get_val(u, "id", 0), 0)
                if uid > 0:
                    return uid
            except:
                pass
        return 0

    def _patch_profile_activity_in_place(self, profile_activity):
        """Patch ProfileActivity fields directly to avoid 'blink' on first render."""
        if profile_activity is None:
            return 0
        patched = 0
        for name in ["user", "currentUser", "userInfo", "userFull"]:
            try:
                obj = get_val(profile_activity, name, None)
                if obj is None:
                    continue
                if self._apply_wear_to_obj(obj):
                    patched += 1
                try:
                    nested = get_val(obj, "user", None)
                    if nested is not None and self._apply_wear_to_obj(nested):
                        patched += 1
                except:
                    pass
            except:
                pass
        return patched

    def _hook_profile_activity_fastpatch(self):
        """Patch on profile open/resume early, so collectible status doesn't appear with delay/blink."""
        try:
            PA = jclass("org.telegram.ui.ProfileActivity")
        except Exception as e:
            _log(f"ProfileActivity hook skipped: {e}")
            return

        hooked = 0
        try:
            for m in PA.getDeclaredMethods():
                try:
                    n = m.getName()
                except:
                    continue
                if n not in ["onFragmentCreate", "createView", "onResume"]:
                    continue
                try:
                    m.setAccessible(True)
                except:
                    pass
                self.hooks_refs.append(self.hook_method(m, ProfileActivityFastPatchHook(self)))
                hooked += 1
        except Exception as e:
            _log(f"ProfileActivity hook scan failed: {e}")
            return

        if hooked:
            _log(f"ProfileActivity fastpatch hooks installed: {hooked}")

    def _hook_gift_three_dots_menu(self):
        """
        Inject two actions into Telegram's gift sheet (three dots menu) for gifts from our library:
        - Изменить в конструкторе
        - Удалить
        Implementation mirrors NUM.plugin (StarGiftSheet.onMenuPressed + ItemOptions.show).
        """
        try:
            JavaClass = jclass("java.lang.Class")
            StarGiftSheet_class = JavaClass.forName("org.telegram.ui.Stars.StarGiftSheet")
            ItemOptions_class = JavaClass.forName("org.telegram.ui.Components.ItemOptions")

            hooked = 0
            for m in StarGiftSheet_class.getDeclaredMethods():
                try:
                    if m.getName() == "onMenuPressed":
                        try:
                            m.setAccessible(True)
                        except:
                            pass
                        self.hooks_refs.append(self.hook_method(m, GiftMenuPressedHook(self)))
                        hooked += 1
                except:
                    continue

            for m in ItemOptions_class.getDeclaredMethods():
                try:
                    if m.getName() == "show":
                        try:
                            m.setAccessible(True)
                        except:
                            pass
                        self.hooks_refs.append(self.hook_method(m, GiftItemOptionsShowHook(self)))
                        hooked += 1
                except:
                    continue

            if hooked:
                _log(f"Gift menu hooks installed: {hooked}")
        except Exception as e:
            _log(f"Gift menu hook error: {e}")

    def _hook_drawer_phone_ui(self):
        """
        Drawer header/account cells may cache phone text and not re-read UserConfig after we patch.
        Hook drawer cells and patch User objects right before UI binds them.
        """
        try:
            if (not self._is_nft_username_active()) and (not self._is_nft_number_active()) and (not self.wear_active or self.wear_collectible_id <= 0):
                # Still install hooks: user may enable later. But keep it cheap.
                pass
        except:
            pass

        candidates = [
            "org.telegram.ui.Cells.DrawerProfileCell",
            "org.telegram.ui.Cells.DrawerUserCell",
            "org.telegram.ui.Cells.DrawerAccountCell",
            "org.telegram.ui.Cells.DrawerActionCell",
        ]

        hooked = 0
        for cls_name in candidates:
            try:
                Cls = jclass(cls_name)
            except:
                continue
            try:
                for m in Cls.getDeclaredMethods():
                    try:
                        name = m.getName()
                    except:
                        continue
                    if name not in ["setUser", "setAccount", "setData", "setDialog", "setInfo"]:
                        continue
                    try:
                        params = m.getParameterTypes()
                    except:
                        params = []
                    if not params:
                        continue
                    # Only hook methods that accept a User as first argument.
                    try:
                        p0 = params[0].getName()
                    except:
                        p0 = ""
                    if "org.telegram.tgnet.TLRPC$User" not in p0:
                        continue
                    try:
                        m.setAccessible(True)
                    except:
                        pass
                    self.hooks_refs.append(self.hook_method(m, DrawerSetUserHook(self)))
                    hooked += 1
            except:
                continue

        if hooked:
            _log(f"Drawer UI hooks installed: {hooked}")

    def _looks_like_saved_gift_wrapper(self, obj):
        if obj is None:
            return False
        try:
            n = str(obj.getClass().getName() or "").lower()
            if "saved" in n and "gift" in n:
                return True
        except:
            pass
        try:
            return get_val(obj, "gift", None) is not None
        except:
            return False

    def _is_my_profile_context(self):
        """
        Best-effort check that the currently opened profile is ours.
        We use this only as a fallback gate when StarGiftSheet doesn't expose saved gift wrapper fields.
        """
        try:
            my_id = int(self._get_my_user_id() or 0)
        except:
            my_id = 0
        if my_id <= 0:
            return False
        try:
            frag = get_last_fragment()
        except:
            frag = None
        if frag is None:
            return False
        try:
            cls_name = str(frag.getClass().getName() or "")
        except:
            cls_name = ""
        if "ProfileActivity" not in cls_name:
            # Conservative: if we can't prove it's our profile, do not show actions.
            return False
        try:
            uid = int(self._extract_profile_user_id(frag) or 0)
        except:
            uid = 0
        return bool(uid > 0 and uid == my_id)

    def _resolve_library_key_from_gift_sheet(self, sheet):
        """
        Best-effort: extract TL_savedStarGift wrapper or gift object from StarGiftSheet instance
        and map it to our library entry key.
        """
        if sheet is None:
            return None

        wrapper = None
        gift = None

        for name in ["savedGift", "saved_gift", "savedStarGift", "saved_star_gift", "saved", "savedGiftItem"]:
            try:
                v = get_val(sheet, name, None)
                if v is not None and self._looks_like_saved_gift_wrapper(v):
                    wrapper = v
                    break
            except:
                pass

        if wrapper is None:
            try:
                cls = sheet.getClass()
                for f in cls.getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    try:
                        v = f.get(sheet)
                    except:
                        continue
                    if v is not None and self._looks_like_saved_gift_wrapper(v):
                        wrapper = v
                        break
            except:
                pass

        entry = None
        if wrapper is not None:
            try:
                sid = int(self._extract_saved_id_from_wrapper(wrapper) or 0)
            except:
                sid = 0
            if sid > 0:
                entry = self._library_find_entry_by_saved_id(sid)
            # Only show menu for "your saved gifts" list items (saved_id match).
            # Do not fall back to slug/unique_id matching when wrapper exists but doesn't match our library.
            if not entry:
                return None
            try:
                return str(entry.get("key"))
            except:
                return entry.get("key")

        # If sheet doesn't expose a saved gift wrapper, fall back only when we're sure
        # we are on our own profile.
        if not self._is_my_profile_context():
            return None

        for name in ["gift", "starGift", "currentGift", "giftUnique", "uniqueGift"]:
            try:
                v = get_val(sheet, name, None)
                if v is not None:
                    gift = v
                    break
            except:
                pass

        if gift is not None:
            try:
                uid = self._to_int(get_val(gift, "id", 0), 0)
            except:
                uid = 0
            if uid > 0:
                entry = self._library_find_entry_by_unique_id(uid)
            if entry is None:
                try:
                    slug = str(get_val(gift, "slug", "") or "")
                except:
                    slug = ""
                if slug:
                    entry = self._library_find_entry_by_slug(slug)

        if not entry:
            return None
        try:
            return str(entry.get("key"))
        except:
            return entry.get("key")

    def _open_constructor_for_library_key(self, key):
        e = self._library_find_entry(key)
        if not e:
            BulletinHelper.show_error("Подарок не найден")
            return False
        self.editing_gift_key = str(key)
        self.cached_gift_id = int(e.get("base_gift_id", 0) or 0)
        try:
            cfg = e.get("build_config", None)
            if isinstance(cfg, dict):
                self.build_config = {
                    "model": int(cfg.get("model", 0) or 0),
                    "pattern": int(cfg.get("pattern", 0) or 0),
                    "backdrop": int(cfg.get("backdrop", 0) or 0),
                    "num": int(cfg.get("num", e.get("num", 1) or 1) or 1),
                }
        except:
            pass
        w = self._library_get_wrapper(key)
        g = self._extract_wrapper_gift(w) if w else None
        if w and g:
            self.stolen_gift_wrapper = w
            self.stolen_gift_inner = g
            try:
                self.cls_saved = w.getClass()
                self.cls_unique = g.getClass()
            except:
                pass
        self._open_constructor(None)
        return True

    def _delete_library_gift_key(self, key):
        e = self._library_find_entry(key)
        if not e:
            BulletinHelper.show_error("Подарок не найден")
            return False
        sid = 0
        try:
            sid = int(e.get("saved_id", 0) or 0)
        except:
            sid = 0
        if sid <= 0:
            try:
                w = self._library_get_wrapper(key)
                sid = int(self._extract_saved_id_from_wrapper(w) or 0) if w else 0
            except:
                sid = 0
        self._library_remove(key)
        self._save_cache()
        try:
            self._save_injection_cache()
        except:
            pass
        try:
            self._try_refresh_saved_gifts_ui_after_delete(sid)
        except:
            pass
        BulletinHelper.show_success("Подарок удален")
        return True

    def _try_refresh_saved_gifts_ui_after_delete(self, saved_id):
        """
        Best-effort remove deleted injected gift from currently visible UI list,
        so user doesn't need to re-open profile.
        """
        try:
            sid = int(saved_id or 0)
        except:
            sid = 0
        if sid <= 0:
            return 0

        try:
            frag = get_last_fragment()
        except:
            frag = None
        if frag is None:
            return 0

        removed = 0
        try:
            removed += int(self._scan_object_and_remove_saved_gift(frag, sid, max_depth=2) or 0)
        except:
            pass

        # Notify adapters / list views if possible.
        try:
            self._scan_object_and_notify_adapters(frag, max_depth=2)
        except:
            pass

        # Close the gift sheet if still open (avoids showing deleted item).
        try:
            sheet = getattr(self, "_gift_menu_sheet_ref", None)
        except:
            sheet = None
        if sheet is not None:
            try:
                sheet.dismiss()
            except:
                pass
            try:
                self._gift_menu_sheet_ref = None
            except:
                pass

        return int(removed or 0)

    def _scan_object_and_remove_saved_gift(self, root, saved_id, max_depth=2):
        try:
            sid = int(saved_id or 0)
        except:
            sid = 0
        if sid <= 0 or root is None:
            return 0

        visited = set()

        def looks_like_list(obj):
            if obj is None:
                return False
            try:
                _ = obj.size()
                _ = obj.get
                return True
            except:
                return False

        def iter_fields(obj):
            out = []
            try:
                cls = obj.getClass()
            except:
                return out
            try:
                for f in cls.getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    out.append(f)
            except:
                pass
            try:
                for f in cls.getFields():
                    out.append(f)
            except:
                pass
            return out

        def remove_from_list(lst):
            r = 0
            try:
                size = int(lst.size() or 0)
            except:
                return 0
            if size <= 0:
                return 0
            for i in range(size - 1, -1, -1):
                try:
                    it = lst.get(i)
                except:
                    continue
                if not self._looks_like_saved_gift_wrapper(it):
                    continue
                try:
                    it_sid = int(self._extract_saved_id_from_wrapper(it) or 0)
                except:
                    it_sid = 0
                if it_sid == sid:
                    try:
                        lst.remove(i)
                        r += 1
                    except:
                        pass
            return r

        def walk(obj, depth):
            if obj is None or depth > max_depth:
                return 0
            try:
                oid = int(obj.hashCode())
            except:
                oid = id(obj)
            if oid in visited:
                return 0
            visited.add(oid)

            total = 0

            if looks_like_list(obj):
                # Only mutate lists that actually contain saved gift wrappers.
                try:
                    if int(obj.size() or 0) > 0:
                        sample = obj.get(0)
                        if self._looks_like_saved_gift_wrapper(sample):
                            total += remove_from_list(obj)
                except:
                    pass

            for f in iter_fields(obj):
                try:
                    v = f.get(obj)
                except:
                    continue
                # Avoid recursing into Views; huge graphs.
                try:
                    if v is not None and "android.view" in str(v.getClass().getName() or ""):
                        continue
                except:
                    pass
                if looks_like_list(v):
                    total += remove_from_list(v)
                else:
                    total += walk(v, depth + 1)
            return total

        return int(walk(root, 0) or 0)

    def _scan_object_and_notify_adapters(self, root, max_depth=2):
        if root is None:
            return 0
        visited = set()
        notified = 0

        def has_method(obj, name):
            try:
                m = getattr(obj, name, None)
                return callable(m)
            except:
                return False

        def iter_fields(obj):
            out = []
            try:
                cls = obj.getClass()
            except:
                return out
            try:
                for f in cls.getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    out.append(f)
            except:
                pass
            try:
                for f in cls.getFields():
                    out.append(f)
            except:
                pass
            return out

        def walk(obj, depth):
            nonlocal notified
            if obj is None or depth > max_depth:
                return
            try:
                oid = int(obj.hashCode())
            except:
                oid = id(obj)
            if oid in visited:
                return
            visited.add(oid)

            # Try notifyDataSetChanged on adapters.
            if has_method(obj, "notifyDataSetChanged"):
                try:
                    obj.notifyDataSetChanged()
                    notified += 1
                except:
                    pass
            # Telegram's custom adapters sometimes expose update(boolean).
            if has_method(obj, "update"):
                try:
                    obj.update(True)
                    notified += 1
                except:
                    pass

            # List views / recycler views: getAdapter().notifyDataSetChanged()
            if has_method(obj, "getAdapter"):
                try:
                    ad = obj.getAdapter()
                    if ad is not None and has_method(ad, "notifyDataSetChanged"):
                        ad.notifyDataSetChanged()
                        notified += 1
                except:
                    pass

            # If it's a View, don't recurse through its internal children; too large.
            try:
                cn = str(obj.getClass().getName() or "")
                if ("android.view" in cn) or ("android.widget" in cn) or ("androidx.recyclerview" in cn):
                    return
            except:
                pass

            for f in iter_fields(obj):
                try:
                    v = f.get(obj)
                except:
                    continue
                walk(v, depth + 1)

        walk(root, 0)
        return int(notified or 0)

    def _to_int(self, value, default=0):
        try:
            if value is None:
                return default
            if isinstance(value, bool):
                return default
            return int(value)
        except:
            try:
                return int(str(value))
            except:
                return default

    def _set_field(self, obj, field_name, value):
        if obj is None:
            return False
        try:
            setattr(obj, field_name, value)
            return True
        except:
            pass
        try:
            f = obj.getClass().getField(field_name)
            t_name = f.getType().getName()
            if t_name == "int":
                f.setInt(obj, self._to_int(value, 0))
            elif t_name == "long":
                f.setLong(obj, self._to_int(value, 0))
            elif t_name == "boolean":
                f.setBoolean(obj, bool(value))
            else:
                f.set(obj, value)
            return True
        except:
            pass
        try:
            f = obj.getClass().getDeclaredField(field_name)
            f.setAccessible(True)
            t_name = f.getType().getName()
            if t_name == "int":
                f.setInt(obj, self._to_int(value, 0))
            elif t_name == "long":
                f.setLong(obj, self._to_int(value, 0))
            elif t_name == "boolean":
                f.setBoolean(obj, bool(value))
            else:
                f.set(obj, value)
            return True
        except:
            return False

    def _extract_doc_id(self, doc):
        try:
            if doc is None:
                return 0
            return self._to_int(get_val(doc, "id", 0), 0)
        except:
            return 0

    def _doc_has_custom_emoji_attr(self, doc):
        """Best-effort check if a Document is a custom emoji (needed for animated emoji status)."""
        if doc is None:
            return False
        try:
            attrs = get_val(doc, "attributes", None)
            if attrs is None:
                return False
            try:
                size = attrs.size()
            except:
                size = 0
            for i in range(size):
                try:
                    a = attrs.get(i)
                except:
                    continue
                if a is None:
                    continue
                try:
                    n = a.getClass().getSimpleName().lower()
                    if "customemoji" in n or "custom_emoji" in n:
                        return True
                except:
                    pass
        except:
            pass
        return False

    def _pick_best_doc_for_collectible_status(self, docs):
        """Pick a Document which is most likely to animate as a collectible emoji status."""
        if not docs:
            return None
        for d in docs:
            try:
                if d is not None and self._doc_has_custom_emoji_attr(d) and self._extract_doc_id(d) > 0:
                    return d
            except:
                pass
        for d in docs:
            try:
                if d is not None and self._extract_doc_id(d) > 0:
                    return d
            except:
                pass
        return None

    def _new_java_instance(self, cls_or_ctor):
        """Create Java object from either java.lang.Class (newInstance) or Chaquopy JavaClass (callable)."""
        if cls_or_ctor is None:
            return None
        try:
            return cls_or_ctor.newInstance()
        except:
            pass
        try:
            return cls_or_ctor()
        except:
            pass
        try:
            name = cls_or_ctor.getName()
            return jclass(str(name))()
        except:
            pass
        return None

    def _sanitize_slug_chunk(self, text):
        if text is None:
            return ""
        s = str(text).strip()
        if not s:
            return ""

        s = s.split("?", 1)[0].split("#", 1)[0]
        if "/" in s:
            s = s.rsplit("/", 1)[-1]

        s = re.sub(r"[^A-Za-z0-9_-]+", "", s)
        s = s.strip("-_")
        return s

    def _title_to_slug_base(self, title):
        parts = re.findall(r"[A-Za-z0-9]+", str(title or ""))
        if not parts:
            return "NFT"
        return "".join(p[0].upper() + p[1:] if p else "" for p in parts)

    def _slug_base_for_custom_link(self, gift_obj):
        if gift_obj is None:
            return ""

        slug = self._sanitize_slug_chunk(get_val(gift_obj, "slug", ""))
        if slug:
            m = re.match(r"^(.*?)-(\d+)$", slug)
            if m and m.group(1):
                return self._sanitize_slug_chunk(m.group(1))
            return slug

        title = get_val(gift_obj, "title", "NFT")
        return self._sanitize_slug_chunk(self._title_to_slug_base(title))

    def _build_custom_slug(self, gift_obj, number):
        base = self._slug_base_for_custom_link(gift_obj)
        if not base:
            base = "NFT"
        num = self._to_int(number, 0)
        if num > 0:
            return f"{base}-{num}"
        return base

    def _resolve_active_gift(self):
        gift = None
        try:
            if self.injection_payload:
                gift = get_val(self.injection_payload, "gift", None)
                if gift:
                    return gift
        except:
            pass
        if self.stolen_gift_inner:
            return self.stolen_gift_inner
        return None

    def _get_my_user_id(self):
        try:
            cfg = get_user_config()
            return self._to_int(cfg.clientUserId, 0)
        except:
            return 0

    def _extract_user_id_from_obj(self, obj, depth=0):
        if obj is None or depth > 3:
            return 0

        direct_id = self._to_int(obj, 0)
        if direct_id > 0:
            return direct_id

        try:
            cls_name = obj.getClass().getSimpleName().lower()
            if "inputuserself" in cls_name or "inputpeerself" in cls_name:
                return self._get_my_user_id()
        except:
            return 0

        for field_name in ["user_id", "peer_id", "dialog_id"]:
            try:
                uid = self._to_int(get_val(obj, field_name, 0), 0)
                if uid > 0:
                    return uid
            except:
                pass

        for field_name in ["peer", "user", "from_id", "to_id", "id"]:
            try:
                nested = get_val(obj, field_name, None)
                if nested is None:
                    continue
                uid = self._extract_user_id_from_obj(nested, depth + 1)
                if uid > 0:
                    return uid
            except:
                pass

        try:
            for f in obj.getClass().getFields():
                name = f.getName().lower()
                if "user" not in name and "peer" not in name and name not in ["id", "from_id", "to_id"]:
                    continue
                try:
                    nested = f.get(obj)
                    if nested is None:
                        continue
                    uid = self._extract_user_id_from_obj(nested, depth + 1)
                    if uid > 0:
                        return uid
                except:
                    pass
        except:
            pass

        return 0

    def _extract_request_user_id(self, req):
        if req is None:
            return -1

        req_name = ""
        try:
            req_name = req.getClass().getSimpleName().lower()
        except:
            pass

        has_target_field = False

        for field_name in ["user_id", "peer", "user", "from_id", "to_id"]:
            try:
                val = get_val(req, field_name, None)
                if val is None:
                    continue
                has_target_field = True
                uid = self._extract_user_id_from_obj(val)
                if uid > 0:
                    return uid
            except:
                pass

        try:
            for f in req.getClass().getFields():
                name = f.getName().lower()
                if "user" not in name and "peer" not in name and name not in ["from_id", "to_id"]:
                    continue
                has_target_field = True
                try:
                    val = f.get(req)
                    uid = self._extract_user_id_from_obj(val)
                    if uid > 0:
                        return uid
                except:
                    pass
        except:
            pass

        if "saved" in req_name and "gift" in req_name and not has_target_field:
            return 0
        return -1

    def _is_non_first_saved_gifts_page(self, req):
        """Detect pagination in getSavedStarGifts-like requests to avoid injecting duplicates into appended pages."""
        if req is None:
            return False

        for name in [
            "offset",
            "offset_id",
            "offset_date",
            "offset_peer",
            "offsetPeer",
            "offsetId",
            "offsetDate",
            "cursor",
            "page",
        ]:
            try:
                v = get_val(req, name, None)
            except:
                v = None
            if v is None:
                continue
            try:
                if isinstance(v, str):
                    if v.strip():
                        return True
                    continue
            except:
                pass
            try:
                n = self._to_int(v, 0)
                if n != 0:
                    return True
                continue
            except:
                pass
            return True

        try:
            fields = []
            try:
                fields.extend(list(req.getClass().getFields()))
            except:
                pass
            try:
                for f in req.getClass().getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    fields.append(f)
            except:
                pass

            seen = set()
            for f in fields:
                try:
                    fname = str(f.getName() or "")
                except:
                    continue
                if fname in seen:
                    continue
                seen.add(fname)
                low = fname.lower()
                if "offset" not in low and low not in ["cursor", "page"]:
                    continue
                try:
                    t = f.getType().getName()
                except:
                    t = ""
                try:
                    if t == "int":
                        if int(f.getInt(req)) != 0:
                            return True
                        continue
                    if t == "long":
                        if int(f.getLong(req)) != 0:
                            return True
                        continue
                    if t == "java.lang.String":
                        vv = f.get(req)
                        if vv is not None and str(vv).strip():
                            return True
                        continue
                    vv = f.get(req)
                    if vv is not None:
                        return True
                except:
                    continue
        except:
            pass

        return False

    def _resolve_saved_gifts_list(self, response):
        fallback_empty = None
        resp_name_l = response.getClass().getSimpleName().lower()

        for f in response.getClass().getFields():
            if f.getType() != ArrayList:
                continue
            try:
                val = f.get(response)
            except:
                continue

            if val is None:
                continue

            size = 0
            try:
                size = val.size()
            except:
                continue

            field_name = f.getName().lower()

            if size <= 0:
                if "saved" in resp_name_l and "gift" in resp_name_l and "collection" not in resp_name_l and "gift" in field_name:
                    fallback_empty = val
                continue

            try:
                item = val.get(0)
                item_name = item.getClass().getSimpleName()
                item_name_l = item_name.lower()
                _log(f"  Found ArrayList: field='{f.getName()}', item[0]={item_name}")
            except:
                continue

            if "collection" in item_name_l:
                continue
            if "saved" in item_name_l and "gift" in item_name_l:
                return val, item

        if fallback_empty is not None:
            _log("  Found empty saved gifts list")
            return fallback_empty, None
        return None, None

    def _get_list_owner_user_id(self, gifts_list):
        if gifts_list is None:
            return 0
        try:
            if gifts_list.size() <= 0:
                return 0
            item = gifts_list.get(0)
            gift = get_val(item, "gift", None)
            if not gift:
                return 0
            owner = get_val(gift, "owner_id", None)
            return self._extract_user_id_from_obj(owner)
        except:
            return 0

    def _normalize_saved_gift_for_actions(self, wrapper=None, force_pin=True, update_date=True, touch_unsaved=True, touch_restrictions=True):
        wrapper_obj = wrapper if wrapper else self.injection_payload
        if not wrapper_obj:
            return

        now_ts = int(time.time())
        my_id = self._get_my_user_id()

        gift = get_val(wrapper_obj, "gift", None)
        if gift is None:
            try:
                gift = wrapper_obj.getClass().getField("gift").get(wrapper_obj)
            except:
                gift = None

        if gift and my_id > 0:
            try:
                PeerUser = jclass("org.telegram.tgnet.TLRPC$TL_peerUser")
                my_peer = PeerUser()
                my_peer.user_id = my_id
                self._set_field(gift, "owner_id", my_peer)
            except Exception as e:
                _log(f"Owner normalize failed: {e}")

        if update_date:
            self._set_field(wrapper_obj, "date", now_ts)
        if force_pin:
            for fn in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
                try:
                    self._set_field(wrapper_obj, fn, True)
                except:
                    pass
        if touch_unsaved:
            try:
                self._set_field(wrapper_obj, "unsaved", False)
            except:
                pass

        try:
            saved_id = self._extract_saved_id_from_wrapper(wrapper_obj)
        except:
            saved_id = 0
        if saved_id <= 0:
            try:
                saved_id = self._new_saved_id()
            except:
                saved_id = random.randint(1600000000, 2147483647)
            self._set_saved_id_on_wrapper(wrapper_obj, saved_id)

        if touch_restrictions:
            self._set_field(wrapper_obj, "can_transfer_at", 0)
            self._set_field(wrapper_obj, "can_resell_at", 0)
            self._set_field(wrapper_obj, "can_upgrade", True)

            transfer_stars = self._to_int(get_val(wrapper_obj, "transfer_stars", 0), 0)
            if transfer_stars <= 0:
                self._set_field(wrapper_obj, "transfer_stars", 1)

            resell_min = self._to_int(get_val(wrapper_obj, "resell_min_stars", 0), 0)
            if resell_min <= 0:
                resell_min = 1
                self._set_field(wrapper_obj, "resell_min_stars", resell_min)

            resell_amount = self._to_int(get_val(wrapper_obj, "resell_amount", 0), 0)
            if resell_amount <= 0:
                self._set_field(wrapper_obj, "resell_amount", resell_min)

    def _remove_existing_gift_by_id(self, gifts_list, target_wrapper):
        """Remove any gift from list that matches target_wrapper's ID."""
        if not gifts_list or not target_wrapper:
            return
        
        target_id = 0
        try:
            target_gift = get_val(target_wrapper, "gift", None)
            target_id = self._to_int(get_val(target_gift, "id", 0), 0)
        except:
            pass
            
        if target_id <= 0:
            return

        try:
            for i in range(gifts_list.size() - 1, -1, -1):
                try:
                    item = gifts_list.get(i)
                    gift = get_val(item, "gift", None)
                    if not gift: continue
                    
                    curr_id = self._to_int(get_val(gift, "id", 0), 0)
                    if curr_id == target_id:
                        gifts_list.remove(i)
                        _log(f"  Removed duplicate gift index={i} id={target_id}")
                except:
                    pass
        except Exception as e:
            _log(f"  Deduplication error: {e}")

    def _saved_gift_is_hidden(self, wrapper):
        for name in ["hidden", "is_hidden", "isHidden", "hidden_to_top", "isHiddenToTop"]:
            try:
                v = get_val(wrapper, name, None)
                if v is None:
                    continue
                return bool(v)
            except:
                continue
        return False

    def _saved_gift_pinned_value(self, wrapper):
        """
        Return (has_value, pinned_bool). Some builds store pin state under different field names.
        """
        for fn in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
            try:
                v = get_val(wrapper, fn, None)
                if v is None:
                    continue
                return True, bool(v)
            except:
                continue
        return False, False

    def _saved_gift_order_hint(self, wrapper):
        # Best-effort: Telegram may store manual ordering here.
        candidates = [
            "order",
            "position",
            "sort",
            "sort_id",
            "sortId",
            "rank",
            "pinned_order",
            "pinnedOrder",
            "pinned_index",
            "pinnedIndex",
        ]
        for name in candidates:
            try:
                v = self._to_int(get_val(wrapper, name, 0), 0)
                if v != 0:
                    return int(v)
            except:
                continue
        return 0

    def _saved_gift_sort_key(self, wrapper):
        # Lower key = earlier in list.
        try:
            _, pinned = self._saved_gift_pinned_value(wrapper)
        except:
            pinned = False
        try:
            hidden = bool(self._saved_gift_is_hidden(wrapper))
        except:
            hidden = False
        try:
            date = int(self._to_int(get_val(wrapper, "date", 0), 0))
        except:
            date = 0
        hint = 0
        try:
            hint = int(self._saved_gift_order_hint(wrapper) or 0)
        except:
            hint = 0
        # If hint is 0, push it after items with explicit order.
        hint_norm = hint if hint != 0 else 1000000000
        # Keep hidden items after visible ones but still stable inside their group.
        return (0 if pinned else 1, 1 if hidden else 0, hint_norm, -int(date))

    def _find_insert_index_by_sort(self, gifts_list, wrapper):
        try:
            w_key = self._saved_gift_sort_key(wrapper)
        except:
            w_key = (0, 1000000000, 0)
        try:
            sz = gifts_list.size()
        except:
            sz = 0
        for i in range(sz):
            try:
                it = gifts_list.get(i)
            except:
                continue
            try:
                it_key = self._saved_gift_sort_key(it)
            except:
                continue
            # Insert before the first item that should go after us.
            try:
                if it_key > w_key:
                    return i
            except:
                continue
        return sz

    def _sync_library_entry_from_wrapper(self, wrapper):
        """
        Persist runtime changes (pin/unpin/hide/order/date) back into library cache,
        so they don't revert after screen re-open or app restart.
        """
        try:
            gift = self._extract_wrapper_gift(wrapper)
            slug = str(get_val(gift, "slug", "")) if gift else ""
            unique_id = int(self._to_int(get_val(gift, "id", 0), 0)) if gift else 0
            entry = None
            if unique_id > 0:
                entry = self._library_find_entry_by_unique_id(unique_id)
            if entry is None and slug:
                entry = self._library_find_entry_by_slug(slug)
            if entry is None:
                return False
            b64 = serialize_tl_object(wrapper)
            if not b64:
                return False
            changed = False
            try:
                prev_b64 = str(entry.get("b64", ""))
            except:
                prev_b64 = ""
            if prev_b64 != str(b64):
                entry["b64"] = b64
                changed = True

            # Keep meta in sync too; pin/hide/order can be stored outside TL b64 on some forks.
            title, slug2, num, bg, uid2 = self._extract_gift_meta(wrapper, entry.get("base_gift_id", 0))
            try:
                if str(entry.get("title", "")) != str(title):
                    entry["title"] = title
                    changed = True
            except:
                entry["title"] = title
                changed = True
            try:
                if str(entry.get("slug", "")) != str(slug2):
                    entry["slug"] = slug2
                    changed = True
            except:
                entry["slug"] = slug2
                changed = True
            try:
                if int(entry.get("num", 0) or 0) != int(num):
                    entry["num"] = int(num)
                    changed = True
            except:
                entry["num"] = int(num)
                changed = True
            if bg:
                try:
                    if int(entry.get("base_gift_id", 0) or 0) != int(bg):
                        entry["base_gift_id"] = int(bg)
                        changed = True
                except:
                    entry["base_gift_id"] = int(bg)
                    changed = True
            if uid2:
                try:
                    if int(entry.get("unique_id", 0) or 0) != int(uid2):
                        entry["unique_id"] = int(uid2)
                        changed = True
                except:
                    entry["unique_id"] = int(uid2)
                    changed = True

            # Persist UI state overrides so pin/unpin/hide don't reset across profile re-open
            # even when TL schema differs across forks/builds.
            try:
                has_pin, pin_val = self._saved_gift_pinned_value(wrapper)
                if has_pin and (entry.get("pinned_override", None) != bool(pin_val)):
                    entry["pinned_override"] = bool(pin_val)
                    changed = True
            except:
                pass
            try:
                hv = bool(self._saved_gift_is_hidden(wrapper))
                if entry.get("hidden_override", None) != hv:
                    entry["hidden_override"] = hv
                    changed = True
            except:
                pass
            try:
                oh = int(self._saved_gift_order_hint(wrapper) or 0)
                if int(entry.get("order_hint", 0) or 0) != int(oh):
                    entry["order_hint"] = int(oh)
                    changed = True
            except:
                pass

            try:
                sid = self._extract_saved_id_from_wrapper(wrapper)
                if sid > 0:
                    prev_sid = int(entry.get("saved_id", 0) or 0)
                    if prev_sid <= 0:
                        entry["saved_id"] = int(sid)
                        changed = True
            except:
                pass

            if not changed:
                return False

            entry["updated_at"] = int(time.time())
            self._library_dirty = True
            return True
        except:
            return False

    def _extract_saved_id_from_req(self, req):
        if req is None:
            return 0
        for name in ["saved_id", "savedId", "savedID", "saved_gift_id", "savedGiftId"]:
            try:
                v = self._to_int(get_val(req, name, 0), 0)
                if v > 0:
                    return int(v)
            except:
                pass
        # Some request variants use plain "id" for saved gift id.
        try:
            v = self._to_int(get_val(req, "id", 0), 0)
            # Our injected saved_id is intentionally a large 32-bit int; use threshold to avoid false positives.
            if v >= 1000000000:
                return int(v)
        except:
            pass
        # Best-effort scan
        try:
            fields = []
            try:
                fields.extend(list(req.getClass().getFields()))
            except:
                pass
            try:
                for f in req.getClass().getDeclaredFields():
                    try:
                        f.setAccessible(True)
                    except:
                        pass
                    fields.append(f)
            except:
                pass
            seen = set()
            for f in fields:
                try:
                    n = str(f.getName() or "")
                except:
                    continue
                if n in seen:
                    continue
                seen.add(n)
                low = n.lower()
                if "saved" not in low or "id" not in low:
                    continue
                try:
                    v = f.get(req)
                    sid = self._to_int(v, 0)
                    if sid > 0:
                        return int(sid)
                except:
                    continue
        except:
            pass
        return 0

    def _extract_unique_id_from_req(self, req):
        if req is None:
            return 0
        for name in ["collectible_id", "unique_id", "gift_unique_id", "giftUniqueId"]:
            try:
                v = self._to_int(get_val(req, name, 0), 0)
                if v > 0:
                    return int(v)
            except:
                pass
        return 0

    def _resolve_library_entry_for_saved_action(self, req):
        sid = self._extract_saved_id_from_req(req)
        if sid > 0:
            e = self._library_find_entry_by_saved_id(sid)
            if e:
                return e
        uid = self._extract_unique_id_from_req(req)
        if uid > 0:
            e = self._library_find_entry_by_unique_id(uid)
            if e:
                return e
        try:
            slug = str(get_val(req, "slug", "") or "")
        except:
            slug = ""
        if slug:
            e = self._library_find_entry_by_slug(slug)
            if e:
                return e
        return None

    def _apply_saved_action_from_req(self, req, entry, req_name_l=""):
        if req is None or entry is None:
            return None
        if not bool(entry.get("inject", False)):
            return None
        key = entry.get("key")
        prev_pinned_override = entry.get("pinned_override", None)
        prev_hidden_override = entry.get("hidden_override", None)
        prev_order_hint = entry.get("order_hint", None)
        w = None
        # Prefer live instance from injection_payloads (UI may have already mutated it).
        try:
            sid = self._extract_saved_id_from_req(req)
        except:
            sid = 0
        if sid > 0:
            try:
                for ww in list(self.injection_payloads or []):
                    try:
                        if self._extract_saved_id_from_wrapper(ww) == sid:
                            w = ww
                            break
                    except:
                        continue
            except:
                w = None
        if w is None:
            w = self._library_get_wrapper(key)
        if not w:
            return None

        # Ensure ids are present before TG builds follow-up actions.
        try:
            self._ensure_saved_id_for_entry(entry, w)
        except:
            pass

        # Copy common action fields if request contains them.
        pinned_from_req = None
        hidden_from_req = None
        for name in [
            "pinned_to_top",
            "pinnedToTop",
            "pinned",
            "is_pinned",
            "isPinned",
            "hidden",
            "is_hidden",
            "isHidden",
            "unsaved",
            "deleted",
        ]:
            try:
                v = get_val(req, name, None)
                if v is not None:
                    self._set_field(w, name, bool(v) if isinstance(v, bool) else v)
                    if pinned_from_req is None and name in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
                        pinned_from_req = bool(v)
                    if hidden_from_req is None and name in ["hidden", "is_hidden", "isHidden"]:
                        hidden_from_req = bool(v)
            except:
                pass
        # Persist explicit action state as overrides too (helps across forks / TL schema differences).
        try:
            if pinned_from_req is not None:
                entry["pinned_override"] = bool(pinned_from_req)
        except:
            pass
        try:
            if hidden_from_req is not None:
                entry["hidden_override"] = bool(hidden_from_req)
        except:
            pass

        # Heuristic based on request name (when explicit fields are missing).
        try:
            if ("hide" in req_name_l) or ("hidden" in req_name_l) or ("unsave" in req_name_l) or ("remove" in req_name_l):
                # Prefer wrapper's existing hidden field name.
                if get_val(w, "hidden", None) is not None:
                    self._set_field(w, "hidden", True)
                elif get_val(w, "is_hidden", None) is not None:
                    self._set_field(w, "is_hidden", True)
                if get_val(w, "unsaved", None) is not None and ("unsave" in req_name_l or "remove" in req_name_l):
                    self._set_field(w, "unsaved", True)
            if "unhide" in req_name_l or ("show" in req_name_l and "hide" not in req_name_l):
                if get_val(w, "hidden", None) is not None:
                    self._set_field(w, "hidden", False)
                elif get_val(w, "is_hidden", None) is not None:
                    self._set_field(w, "is_hidden", False)
                if get_val(w, "unsaved", None) is not None:
                    self._set_field(w, "unsaved", False)

            # Pin/unpin sometimes comes without a pinned_to_top field; infer from request name.
            if ("pin" in req_name_l) and ("unpin" not in req_name_l):
                for fn in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
                    try:
                        self._set_field(w, fn, True)
                    except:
                        pass
                try:
                    entry["pinned_override"] = True
                except:
                    pass
            if "unpin" in req_name_l:
                for fn in ["pinned_to_top", "pinnedToTop", "pinned", "is_pinned", "isPinned"]:
                    try:
                        self._set_field(w, fn, False)
                    except:
                        pass
                try:
                    entry["pinned_override"] = False
                except:
                    pass
        except:
            pass

        # If we changed overrides directly (without TL b64 change), force a save so state persists.
        try:
            if (entry.get("pinned_override", None) != prev_pinned_override) or (entry.get("hidden_override", None) != prev_hidden_override) or (entry.get("order_hint", None) != prev_order_hint):
                entry["updated_at"] = int(time.time())
                self._library_dirty = True
        except:
            pass

        # Persist current wrapper snapshot (so state doesn't revert on profile reopen).
        try:
            self._sync_library_entry_from_wrapper(w)
        except:
            pass
        try:
            self._flush_library_if_dirty()
        except:
            pass
        return str(key) if key else None

    def _flush_library_if_dirty(self, min_interval_sec=2.0):
        try:
            if not self._library_dirty:
                return
            now = time.time()
            last = float(getattr(self, "_library_last_save_ts", 0.0) or 0.0)
            if (now - last) < float(min_interval_sec):
                return
            self._library_last_save_ts = now
            self._library_dirty = False
            # Save immediately (but off the UI thread).
            self._save_cache(delay_ms=0)
        except:
            pass

    def _hook_network(self):
        try:
            cm_class = get_connections_manager().getClass()
            try:
                self.hook_method(
                    cm_class.getMethod("sendRequest",
                                       jclass("org.telegram.tgnet.TLObject"),
                                       jclass("org.telegram.tgnet.RequestDelegate"),
                                       jclass("int")),
                    NetworkHook(self)
                )
                _log("Hooked sendRequest(TLObject, RequestDelegate, int)")
            except:
                self.hook_method(
                    cm_class.getMethod("sendRequest",
                                       jclass("org.telegram.tgnet.TLObject"),
                                       jclass("org.telegram.tgnet.RequestDelegate")),
                    NetworkHook(self)
                )
                _log("Hooked sendRequest(TLObject, RequestDelegate)")
        except Exception as e:
            _log(f"Hook Error: {e}\n{traceback.format_exc()}")

    def process_response(self, response, req_user_id=-1, req_name="", allow_inject=True):
        try:
            resp_name = response.getClass().getSimpleName()
            _log(f"process_response: {resp_name}, req={req_name}, req_user_id={req_user_id}, allow_inject={bool(allow_inject)}")

            gifts_list, sample_item = self._resolve_saved_gifts_list(response)
            if not gifts_list:
                _log(f"  No usable saved gifts list in {resp_name}")
                return

            gifts_size = gifts_list.size()
            _log(f"  gifts_list.size()={gifts_size}")

            if sample_item:
                item_cls = sample_item.getClass()
                self.cls_saved = item_cls
                try:
                    gift_val = item_cls.getField("gift").get(sample_item)
                    if gift_val and "unique" in gift_val.getClass().getSimpleName().lower():
                        self.cls_unique = gift_val.getClass()
                        _log(f"  Classes: saved={self.cls_saved.getName()}, unique={self.cls_unique.getName()}")
                except:
                    pass

            # Fix bogus "X из 0" ribbons for real saved gifts too (not only injected ones).
            try:
                scan_n = min(int(gifts_list.size() or 0), 40)
                for i in range(scan_n):
                    try:
                        it = gifts_list.get(i)
                        g = get_val(it, "gift", None)
                        if g is not None:
                            self._ensure_unique_gift_availability(g, base_gift_id=0)
                    except:
                        continue
            except:
                pass

            if allow_inject and self.inject_active and self.injection_payloads:
                try:
                    my_id = self._get_my_user_id()
                    owner_user_id = self._get_list_owner_user_id(gifts_list)

                    if my_id > 0 and req_user_id > 0 and req_user_id != my_id:
                        _log(f"  Skip inject: чужой профиль req_user_id={req_user_id}, my_id={my_id}")
                        return

                    if my_id > 0 and owner_user_id > 0 and owner_user_id != my_id:
                        _log(f"  Skip inject: список чужого владельца owner_user_id={owner_user_id}, my_id={my_id}")
                        return

                    if req_user_id < 0 and owner_user_id == 0:
                        _log("  Skip inject: target user unresolved")
                        return

                    wrappers = []
                    for w in list(self.injection_payloads or []):
                        try:
                            # Respect user's pin/unpin/order changes.
                            self._normalize_saved_gift_for_actions(
                                w,
                                force_pin=False,
                                update_date=False,
                                touch_unsaved=False,
                                touch_restrictions=False,
                            )
                            try:
                                gift = self._extract_wrapper_gift(w)
                                if gift is not None:
                                    # Keep availability totals sane for UI ("X из Y" ribbon).
                                    self._ensure_unique_gift_availability(gift, base_gift_id=0)
                            except:
                                pass
                            self._remove_existing_gift_by_id(gifts_list, w)
                            # Persist any runtime changes to disk (order/pin/hide).
                            self._sync_library_entry_from_wrapper(w)
                            wrappers.append(w)
                        except:
                            pass

                    try:
                        wrappers.sort(key=lambda ww: self._saved_gift_sort_key(ww))
                    except:
                        pass

                    inserted = 0
                    for w in wrappers:
                        try:
                            idx = self._find_insert_index_by_sort(gifts_list, w)
                            gifts_list.add(idx, w)
                            inserted += 1
                        except:
                            pass

                    self._flush_library_if_dirty()
                    _log(f"  Injection applied. count={inserted}")
                except Exception as e:
                    _log(f"  Inject Error: {e}")

        except Exception as e:
            _log(f"Process Error: {e}\n{traceback.format_exc()}")

    def activate_injection(self, wrapper, wear_override=None):
        self._normalize_saved_gift_for_actions(wrapper, force_pin=True, update_date=True)
        self._library_upsert_wrapper(
            wrapper,
            base_gift_id=self.cached_gift_id or 0,
            key=self.editing_gift_key,
            inject=True,
            make_active=True,
            wear_override=wear_override,
            build_config=(self.build_config.copy() if isinstance(self.build_config, dict) else None),
        )
        self.editing_gift_key = None
        self._save_cache()
        self._save_injection_cache()
        _log("Injection activated and cached to disk")
        BulletinHelper.show_success("Готово! Обновите свой профиль.\nNFT сохранён в библиотеке.")

class GiftMenuPressedHook(MethodHook):
    """
    StarGiftSheet.onMenuPressed hook: mark that the next ItemOptions.show belongs to gift three-dots menu,
    and try to resolve our library key for this gift.
    """
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            try:
                self.plugin._gift_menu_sheet_ref = param.thisObject
            except:
                pass
            self.plugin._inside_gift_menu = True
            self.plugin._gift_menu_injected_once = False
            try:
                self.plugin._gift_menu_token = int(getattr(self.plugin, "_gift_menu_token", 0) or 0) + 1
            except:
                self.plugin._gift_menu_token = 1
            token = int(getattr(self.plugin, "_gift_menu_token", 0) or 0)
            try:
                key = self.plugin._resolve_library_key_from_gift_sheet(param.thisObject)
            except:
                key = None
            self.plugin._gift_menu_entry_key = key

            # Failsafe: clear state shortly after, in case ItemOptions.show fires asynchronously.
            def _clear_later():
                try:
                    if int(getattr(self.plugin, "_gift_menu_token", 0) or 0) != token:
                        return
                    self.plugin._inside_gift_menu = False
                    self.plugin._gift_menu_entry_key = None
                    self.plugin._gift_menu_injected_once = False
                except:
                    pass

            try:
                AndroidUtilities.runOnUIThread(JRunnable(_clear_later), 800)
            except:
                pass
        except:
            pass

    def after_hooked_method(self, param):
        # Intentionally no-op: we clear with a delay to handle async menus.
        return


class GiftItemOptionsShowHook(MethodHook):
    """ItemOptions.show hook: inject our items when we're inside a gift menu."""
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not bool(getattr(self.plugin, "_inside_gift_menu", False)):
                return
            if bool(getattr(self.plugin, "_gift_menu_injected_once", False)):
                return
            key = getattr(self.plugin, "_gift_menu_entry_key", None)
            if not key:
                return

            item_options = param.thisObject

            try:
                R_drawable = jclass("org.telegram.messenger.R$drawable")
                icon_edit = int(getattr(R_drawable, "msg_edit", 0) or 0)
                icon_delete = int(getattr(R_drawable, "msg_delete", 0) or 0)
            except:
                icon_edit, icon_delete = 0, 0

            def _on_edit():
                run_on_ui_thread(lambda: self.plugin._open_constructor_for_library_key(key))

            def _on_delete():
                run_on_ui_thread(lambda: self.plugin._delete_library_gift_key(key))

            # Signature: add(int iconResId, CharSequence text, Runnable action)
            item_options.add(icon_edit, "Изменить в конструкторе", JRunnable(_on_edit))
            item_options.add(icon_delete, "Удалить", JRunnable(_on_delete))

            self.plugin._gift_menu_injected_once = True
            # Reduce risk of affecting other menus.
            self.plugin._inside_gift_menu = False
            self.plugin._gift_menu_entry_key = None
        except Exception as e:
            _log(f"Gift menu inject error: {e}")

class DrawerSetUserHook(MethodHook):
    """Patch drawer-bound User objects so phone/status spoof is reflected in drawer UI."""
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args:
                return
            u = param.args[0]
            if u is None:
                return
            self.plugin._apply_wear_to_obj(u)
        except:
            pass

class NetworkHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            try:
                self.plugin._ensure_user_context(force=False)
            except:
                pass
            req = param.args[0]
            req_name = req.getClass().getSimpleName()
            req_name_l = str(req_name).lower()

            if "gift" in req_name_l and "get" in req_name_l:
                req_user_id = self.plugin._extract_request_user_id(req)
                allow_inject = True
                try:
                    if self.plugin._is_non_first_saved_gifts_page(req):
                        allow_inject = False
                except:
                    allow_inject = True
                _log(f">>> Hooking: {req_name}, req_user_id={req_user_id}")
                param.args[1] = WrapperDelegate(self.plugin, param.args[1], req_user_id, req_name, allow_inject)

            # Actions on saved gifts: hide/unhide/reorder/pin. For injected gifts we fake success to avoid UI errors.
            is_saved_action = ("saved" in req_name_l and "gift" in req_name_l)
            if (not is_saved_action) and ("gift" in req_name_l) and ("get" not in req_name_l):
                for tok in ["hide", "unhide", "pin", "pinned", "unpin", "order", "reorder", "sort", "unsave", "remove", "visible", "show"]:
                    if tok in req_name_l:
                        is_saved_action = True
                        break
            if is_saved_action and ("get" not in req_name_l):
                try:
                    entry = self.plugin._resolve_library_entry_for_saved_action(req)
                    entry_key = None
                    if entry is not None:
                        entry_key = self.plugin._apply_saved_action_from_req(req, entry, req_name_l=req_name_l)
                    if entry_key:
                        _log(f">>> Hooking SAVED_GIFT ACTION: {req_name} key={entry_key}")
                        param.args[1] = SavedGiftActionDelegate(self.plugin, param.args[1], entry_key, req_name)
                except:
                    pass

            if "emojistatus" in req_name_l and "update" in req_name_l:
                cid = self.plugin._on_update_emoji_status_request(req)
                _log(f">>> Hooking STATUS: {req_name}, collectible_id={cid}")
                param.args[1] = StatusWrapperDelegate(self.plugin, param.args[1], cid, req_name)

            if ("getfulluser" in req_name_l) or ("getusers" in req_name_l) or ("getuser" in req_name_l and "gift" not in req_name_l):
                _log(f">>> Hooking USER: {req_name}")
                param.args[1] = UserWrapperDelegate(self.plugin, param.args[1], req_name)

            if self.plugin._is_nft_username_active() or self.plugin._is_nft_number_active():
                if ("collectible" in req_name_l and ("info" in req_name_l or "username" in req_name_l or "phone" in req_name_l or "number" in req_name_l)) or ("fragment" in req_name_l and "collectible" in req_name_l):
                    kind, tok = self.plugin._extract_collectible_request_kind_and_token(req)
                    if not kind:
                        if self.plugin._is_nft_number_active():
                            kind, tok = ("number", self.plugin._get_primary_nft_number())
                        else:
                            kind, tok = ("username", self.plugin._get_primary_nft_username())
                    # Do not interfere with other people's collectible info. Only patch/fake our managed tokens.
                    if kind == "number":
                        norm = self.plugin._normalize_nft_number(tok)
                        if norm and (not self.plugin._is_managed_nft_number(norm)):
                            kind = ""
                    elif kind == "username":
                        norm = self.plugin._normalize_nft_username(tok)
                        if norm and (not self.plugin._is_managed_nft_username(norm)):
                            kind = ""
                    if not kind:
                        return
                    _log(f">>> Hooking COLLECTIBLE INFO: {req_name} kind={kind}")
                    param.args[1] = CollectibleInfoDelegate(self.plugin, param.args[1], req_name, kind, tok)

            if "uniquestargift" in req_name_l and "get" in req_name_l:
                if self.plugin.wear_active and (self.plugin.injection_payloads or self.plugin.injection_payload):
                    try:
                        req_slug = str(get_val(req, "slug", ""))
                        candidates = []
                        if self.plugin.injection_payloads:
                            candidates.extend(list(self.plugin.injection_payloads))
                        if self.plugin.injection_payload:
                            candidates.append(self.plugin.injection_payload)
                        for w in candidates:
                            cached_gift = get_val(w, "gift", None)
                            cached_slug = str(get_val(cached_gift, "slug", "")) if cached_gift else ""
                            if req_slug and cached_slug and req_slug == cached_slug:
                                _log(f">>> Hooking GIFT LOOKUP: {req_name}, slug={req_slug} -> returning cached gift")
                                param.args[1] = GiftLookupDelegate(self.plugin, param.args[1], cached_gift)
                                break
                    except Exception as e:
                        _log(f"Gift lookup hook error: {e}")
        except Exception as e:
            _log(f"NetworkHook error: {e}")

class WrapperDelegate(dynamic_proxy(RequestDelegate)):
    def __init__(self, plugin, original, req_user_id=-1, req_name="", allow_inject=True):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.req_user_id = req_user_id
        self.req_name = req_name
        self.allow_inject = bool(allow_inject)

    def run(self, response, error):
        if not error and response:
            try:
                self.plugin.process_response(response, self.req_user_id, self.req_name, self.allow_inject)
            except Exception as e:
                _log(f"WrapperDelegate error: {e}")
        if self.original:
            self.original.run(response, error)

class StatusWrapperDelegate(dynamic_proxy(RequestDelegate)):
    def __init__(self, plugin, original, collectible_id=0, req_name=""):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.collectible_id = collectible_id
        self.req_name = req_name

    def run(self, response, error):
        try:
            if error and self.collectible_id and self.collectible_id > 0:
                try:
                    BoolTrue = jclass("org.telegram.tgnet.TLRPC$TL_boolTrue")
                    response = BoolTrue()
                    error = None
                    _log(f"STATUS faked success for collectible_id={self.collectible_id}")
                except Exception as e:
                    _log(f"STATUS fake success failed: {e}")
                    error = None

            self.plugin._patch_my_cached_user()
        except Exception as e:
            _log(f"StatusWrapperDelegate error: {e}")

        if self.original:
            self.original.run(response, error)

        if (self.plugin.wear_active and self.plugin.wear_collectible_id > 0) or self.plugin._is_nft_username_active() or self.plugin._is_nft_number_active():
            def _delayed_patch():
                try:
                    self.plugin._patch_my_cached_user()
                except:
                    pass
            for delay_ms in [0, 10, 25, 50, 100, 300, 600, 1500]:
                try:
                    AndroidUtilities.runOnUIThread(JRunnable(_delayed_patch), delay_ms)
                except:
                    pass

class SavedGiftActionDelegate(dynamic_proxy(RequestDelegate)):
    """
    Fake success for actions on injected (plugin) gifts so official TG UI doesn't show errors
    like SAVED_ID_EMPTY / NOT_FOUND. Also persists wrapper changes into library cache.
    """
    def __init__(self, plugin, original, entry_key=None, req_name=""):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.entry_key = entry_key
        self.req_name = req_name

    def run(self, response, error):
        try:
            if error and self.entry_key:
                try:
                    BoolTrue = jclass("org.telegram.tgnet.TLRPC$TL_boolTrue")
                    response = BoolTrue()
                    error = None
                    _log(f"SAVED_GIFT action faked success key={self.entry_key} req={self.req_name}")
                except Exception as e:
                    _log(f"SAVED_GIFT fake success failed: {e}")
                    error = None

            try:
                self.plugin._flush_library_if_dirty(min_interval_sec=0.0)
            except:
                pass
        except:
            pass

        if self.original:
            self.original.run(response, error)

class UserWrapperDelegate(dynamic_proxy(RequestDelegate)):
    def __init__(self, plugin, original, req_name=""):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.req_name = req_name

    def run(self, response, error):
        if not error and response:
            try:
                self.plugin._patch_nft_username_in_response(response, self.req_name)
            except Exception as e:
                _log(f"UserWrapperDelegate nft patch error: {e}")
            try:
                self.plugin._patch_nft_number_in_response(response, self.req_name)
            except Exception as e:
                _log(f"UserWrapperDelegate number patch error: {e}")
            try:
                patched = self.plugin._patch_wear_in_updates_container(response)
                if patched:
                    _log(f"USER response patched ({self.req_name}): {patched}")
            except Exception as e:
                _log(f"UserWrapperDelegate patch error: {e}")
        if self.original:
            self.original.run(response, error)

        if (self.plugin.wear_active and self.plugin.wear_collectible_id > 0) or self.plugin._is_nft_username_active() or self.plugin._is_nft_number_active():
            def _delayed_patch():
                try:
                    self.plugin._patch_my_cached_user()
                except:
                    pass
            for delay_ms in [0, 10, 25, 50, 100, 300, 600, 1500]:
                try:
                    AndroidUtilities.runOnUIThread(JRunnable(_delayed_patch), delay_ms)
                except:
                    pass

class CollectibleInfoDelegate(dynamic_proxy(RequestDelegate)):
    def __init__(self, plugin, original, req_name="", req_kind="", req_token=""):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.req_name = req_name
        self.req_kind = req_kind
        self.req_token = req_token

    def run(self, response, error):
        kind = str(self.req_kind or "").strip().lower()
        raw = str(self.req_token or "")
        token = ""
        digits = ""
        # Infer kind if missing/unknown.
        if kind not in ["username", "number"]:
            if self.plugin._normalize_nft_number(raw):
                kind = "number"
            else:
                kind = "username"

        if kind == "number":
            digits = self.plugin._normalize_nft_number(raw)
        else:
            token = self.plugin._normalize_nft_username(raw)

        # If request explicitly targets someone else's collectible, do not spoof it.
        if kind == "number" and digits and (not self.plugin._is_managed_nft_number(digits)):
            if self.original:
                self.original.run(response, error)
            return
        if kind == "username" and token and (not self.plugin._is_managed_nft_username(token)):
            if self.original:
                self.original.run(response, error)
            return

        err_text = ""
        try:
            err_text = str(get_val(error, "text", error) or "")
        except:
            err_text = str(error or "")

        err_upper = err_text.upper()
        is_collectible_error = error and (("COLLECTIBLE_" in err_upper) or ("PHONE_NUMBER" in err_upper))

        if is_collectible_error:
            try:
                if kind == "number":
                    if (not digits) or (not self.plugin._is_managed_nft_number(digits)):
                        digits = self.plugin._get_primary_nft_number()
                    fake_resp = self.plugin._create_fake_collectible_number_response(digits)
                    if fake_resp is not None:
                        response = fake_resp
                        error = None
                        _log(f"Collectible number info faked ({err_upper}) for {self.plugin._format_nft_number(digits)}")
                else:
                    if not token or not self.plugin._is_managed_nft_username(token):
                        token = self.plugin._get_primary_nft_username()
                    fake_resp = self.plugin._create_fake_collectible_response(token)
                    if fake_resp is not None:
                        response = fake_resp
                        error = None
                        _log(f"Collectible info faked ({err_upper}) for @{token}")
            except Exception as e:
                _log(f"CollectibleInfoDelegate fake error: {e}")

        if not error and response:
            try:
                if kind == "number":
                    self.plugin._patch_collectible_number_info_response(response, self.req_name, digits)
                else:
                    self.plugin._patch_collectible_username_info_response(response, self.req_name, token)
            except Exception as e:
                _log(f"CollectibleInfoDelegate patch error: {e}")
        if self.original:
            self.original.run(response, error)

class GiftLookupDelegate(dynamic_proxy(RequestDelegate)):
    """Intercept getUniqueStarGift and return our cached gift instead of server error."""
    def __init__(self, plugin, original, cached_gift):
        super().__init__()
        self.plugin = plugin
        self.original = original
        self.cached_gift = cached_gift

    def run(self, response, error):
        try:
            if self.cached_gift:
                try:
                    RespCls = jclass("org.telegram.tgnet.tl.TL_stars$TL_payments_uniqueStarGift")
                    fake_resp = RespCls()
                    self.plugin._set_field(fake_resp, "gift", self.cached_gift)
                    response = fake_resp
                    error = None
                    _log(f"GIFT LOOKUP faked: returned cached gift id={get_val(self.cached_gift, 'id', '?')}")
                except Exception as e1:
                    _log(f"GiftLookupDelegate wrapper class not found ({e1}), trying direct gift return")
                    try:
                        response = self.cached_gift
                        error = None
                        _log("GIFT LOOKUP faked: returned cached gift directly")
                    except Exception as e2:
                        _log(f"GiftLookupDelegate fallback failed: {e2}")
        except Exception as e:
            _log(f"GiftLookupDelegate error: {e}")

        if self.original:
            self.original.run(response, error)

class ProfileActivityFastPatchHook(MethodHook):
    """Re-apply wearable status very early during profile open to reduce flicker/delay."""
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            p = self.plugin
            if (not p.wear_active or p.wear_collectible_id <= 0) and (not p._is_nft_username_active()) and (not p._is_nft_number_active()):
                return
            now = time.time()
            if (now - float(getattr(p, "_profile_fastpatch_last_ts", 0.0))) < 0.25:
                return
            p._profile_fastpatch_last_ts = now

            pa = getattr(param, "thisObject", None)
            my_id = p._get_my_user_id()
            target_id = p._get_profile_activity_user_id(pa)
            if my_id > 0 and target_id > 0 and target_id != my_id:
                return

            if p.wear_active and p.wear_collectible_id > 0:
                try:
                    p._sync_wear_status_data_from_library(p.wear_collectible_id)
                except:
                    pass
            patched_local = p._patch_profile_activity_in_place(pa)
            if patched_local <= 0:
                p._patch_my_cached_user()
        except Exception as e:
            _log(f"ProfileActivityFastPatchHook(before) error: {e}")

    def after_hooked_method(self, param):
        try:
            p = self.plugin
            pa = getattr(param, "thisObject", None)
            my_id = p._get_my_user_id()
            target_id = p._get_profile_activity_user_id(pa)
            if my_id > 0 and target_id > 0 and target_id != my_id:
                return

            # Refresh own gifts UI (fix "1 из 0") without any manual actions.
            try:
                now = time.time()
                last = float(getattr(p, "_profile_gifts_refresh_last_ts", 0.0) or 0.0)
                if (now - last) > 1.5:
                    p._profile_gifts_refresh_last_ts = now
                    if bool(getattr(p, "inject_active", False)) or (p.gift_library and len(p.gift_library) > 0):
                        try:
                            p._load_catalog_silent()
                        except:
                            pass
                        for delay_ms in [0, 120, 350, 800, 1400, 2400]:
                            try:
                                AndroidUtilities.runOnUIThread(JRunnable(p._refresh_profile_gifts_ui), delay_ms)
                            except:
                                pass
            except:
                pass

            if (not p.wear_active or p.wear_collectible_id <= 0) and (not p._is_nft_username_active()) and (not p._is_nft_number_active()):
                return
            for delay_ms in [60, 220, 650]:
                try:
                    AndroidUtilities.runOnUIThread(JRunnable(p._patch_my_cached_user), delay_ms)
                except:
                    pass
        except Exception as e:
            _log(f"ProfileActivityFastPatchHook(after) error: {e}")

class GetAnyWearHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            user_obj = param.getResult()
            if self.plugin._apply_wear_to_obj(user_obj):
                param.setResult(user_obj)
        except Exception as e:
            _log(f"GetAnyWearHook error: {e}")

class PutAnyWearHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args or len(param.args) < 1:
                return
            user_obj = param.args[0]
            self.plugin._apply_wear_to_obj(user_obj)
        except Exception as e:
            _log(f"PutAnyWearHook error: {e}")

class PutUsersWearHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args or len(param.args) < 1:
                return
            lst = param.args[0]
            if lst is None:
                return
            try:
                size = lst.size()
            except:
                return
            for i in range(size):
                try:
                    item = lst.get(i)
                except:
                    continue
                self.plugin._apply_wear_to_obj(item)
        except Exception as e:
            _log(f"PutUsersWearHook error: {e}")

class ProcessUpdatesWearHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.wear_active or self.plugin.wear_collectible_id <= 0:
                return
            if not param.args:
                return
            total = 0
            for a in param.args:
                if a is None:
                    continue
                try:
                    _ = a.getClass()
                except:
                    continue
                total += self.plugin._patch_wear_in_updates_container(a)
            if total:
                _log(f"Updates patched before apply: {total}")
        except Exception as e:
            _log(f"ProcessUpdatesWearHook error: {e}")

class EmojiStatusCallbackHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            self.plugin._patch_my_cached_user()
        except Exception as e:
            _log(f"EmojiStatusCallbackHook error: {e}")

class SetCurrentUserWearHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args or len(param.args) < 1:
                return
            self.plugin._apply_wear_to_obj(param.args[0])
        except Exception as e:
            _log(f"SetCurrentUserWearHook error: {e}")

class AttrLoader:
    def __init__(self, plugin, gift_id):
        self.plugin = plugin
        self.gift_id = gift_id
        self.req_callback = None

    def start(self):
        try:
            req = jclass("org.telegram.tgnet.tl.TL_stars$getStarGiftUpgradeAttributes")()
            req.gift_id = self.gift_id
            self.req_callback = JRequestDelegate(self.on_done)
            get_connections_manager().sendRequest(req, self.req_callback)
            _log(f"AttrLoader: requesting gift_id={self.gift_id}")
            BulletinHelper.show_info("Загрузка атрибутов...")
        except Exception as e:
            _log(f"AttrLoader error: {e}\n{traceback.format_exc()}")
            BulletinHelper.show_error(f"Ошибка запроса: {e}")

    def on_done(self, response, error):
        if error:
            _log(f"AttrLoader net error: {error.text}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Ошибка сети: {error.text}"))
            return
        _log("AttrLoader: attributes received")
        run_on_ui_thread(lambda: NftBuilderSheet(self.plugin, self.gift_id, response).show())

class CatalogNftSheet:
    def __init__(self, plugin):
        self.plugin = plugin
        self.fragment = get_last_fragment()
        self.activity = self.fragment.getParentActivity() if self.fragment else None
        self.sheet = None
        self.recycler = None
        self.items = []
        self._last_adapter_kick_ts = 0.0
        self._loading_catalog = False
        self._last_catalog_sig = ""
        self._kick_token = 0
        self._touch_active = False
        try:
            acc = get_user_config().selectedAccount
            self.loader = FileLoader.getInstance(to_java_int(acc))
        except:
            self.loader = None

    def _refresh(self, silent=False):
        self.items = self.plugin._get_catalog_nft_gifts()
        if not silent and not self.items:
            BulletinHelper.show_info("Каталог пуст. Нажмите 'Обновить каталог'.")

    def _schedule_kick(self, delay_ms=450):
        """Schedule a delayed adapter update (avoids re-entrancy while building items)."""
        try:
            self._kick_token = int(self._kick_token or 0) + 1
        except:
            self._kick_token = 1
        token = int(self._kick_token or 0)

        def _do():
            try:
                if int(getattr(self, "_kick_token", 0) or 0) != token:
                    return
                self._kick_adapter(full=False, min_interval=0.0)
            except:
                pass

        try:
            AndroidUtilities.runOnUIThread(JRunnable(_do), int(delay_ms))
        except:
            pass

    def _catalog_signature(self, lst):
        try:
            if not lst:
                return ""
            n = min(10, int(lst.size() if not isinstance(lst, list) else len(lst)))
        except:
            n = 0
        parts = []
        for i in range(n):
            try:
                g = lst[i] if isinstance(lst, list) else lst.get(i)
            except:
                continue
            try:
                parts.append(str(get_val(g, "id", "")))
            except:
                pass
        return "|".join(parts)

    def _kick_adapter(self, full=False, min_interval=0.35):
        # Avoid fighting user scroll; adapter.update() tends to reset layout/position.
        try:
            if bool(getattr(self, "_touch_active", False)):
                return False
        except:
            pass
        try:
            if self._is_scrolling():
                return False
        except:
            pass
        try:
            now = time.time()
            if (now - float(self._last_adapter_kick_ts or 0.0)) < float(min_interval):
                return False
            self._last_adapter_kick_ts = now
        except:
            pass
        try:
            if self.recycler and self.recycler.adapter:
                self.recycler.adapter.update(bool(full))
                return True
        except:
            pass
        return False

    def _install_nested_scroll_fix(self):
        """
        Make sure vertical gestures scroll the list instead of collapsing the bottom sheet.
        Best-effort: enable nested scrolling and disallow parent intercept during touch.
        """
        target = None
        try:
            target = getattr(self.recycler, "listView", None)
        except:
            target = None
        if target is None:
            target = self.recycler
        if target is None:
            return False

        try:
            if hasattr(target, "setNestedScrollingEnabled") and callable(getattr(target, "setNestedScrollingEnabled", None)):
                target.setNestedScrollingEnabled(True)
        except:
            pass
        try:
            if hasattr(target, "setVerticalScrollBarEnabled") and callable(getattr(target, "setVerticalScrollBarEnabled", None)):
                target.setVerticalScrollBarEnabled(True)
        except:
            pass

        try:
            MotionEvent = jclass("android.view.MotionEvent")
            ACTION_DOWN = int(getattr(MotionEvent, "ACTION_DOWN", 0) or 0)
            ACTION_UP = int(getattr(MotionEvent, "ACTION_UP", 1) or 1)
            ACTION_CANCEL = int(getattr(MotionEvent, "ACTION_CANCEL", 3) or 3)
            ACTION_MOVE = int(getattr(MotionEvent, "ACTION_MOVE", 2) or 2)
        except:
            MotionEvent = None
            ACTION_DOWN, ACTION_UP, ACTION_CANCEL, ACTION_MOVE = 0, 1, 3, 2

        def _on_touch(v, ev):
            try:
                act = int(ev.getActionMasked()) if hasattr(ev, "getActionMasked") else int(ev.getAction())
            except:
                act = -1

            try:
                if act == ACTION_DOWN:
                    self._touch_active = True
                elif act in [ACTION_UP, ACTION_CANCEL]:
                    self._touch_active = False
            except:
                pass

            disallow = (act == ACTION_DOWN) or (act == ACTION_MOVE)
            if disallow:
                try:
                    p = v.getParent()
                    for _ in range(6):
                        if p is None:
                            break
                        try:
                            p.requestDisallowInterceptTouchEvent(True)
                        except:
                            pass
                        try:
                            p = p.getParent()
                        except:
                            break
                except:
                    pass
            return False

        try:
            target.setOnTouchListener(JOnTouchListener(_on_touch))
            return True
        except:
            return False

    def _is_scrolling(self):
        try:
            # RecyclerView-like API
            if hasattr(self.recycler, "getScrollState") and callable(getattr(self.recycler, "getScrollState", None)):
                st = int(self.recycler.getScrollState() or 0)
                if st != 0:
                    return True
        except:
            pass
        try:
            # UniversalRecyclerView may wrap a listView field.
            lv = getattr(self.recycler, "listView", None)
            if lv is not None and hasattr(lv, "getScrollState") and callable(getattr(lv, "getScrollState", None)):
                st = int(lv.getScrollState() or 0)
                if st != 0:
                    return True
        except:
            pass
        return False

    def _start_icon_kick_chain(self):
        """
        Coalesced delayed adapter updates so thumbnails appear as FileLoader finishes downloads,
        without constant refreshes that break scrolling.
        """
        try:
            self._kick_token = int(self._kick_token or 0) + 1
        except:
            self._kick_token = 1
        token = int(self._kick_token or 0)

        delays = [350, 900, 1800, 3200, 5200, 8200, 12200]

        def _make(delay):
            def _do():
                try:
                    if int(getattr(self, "_kick_token", 0) or 0) != token:
                        return
                    self._kick_adapter(full=False, min_interval=0.0)
                except:
                    pass
            try:
                AndroidUtilities.runOnUIThread(JRunnable(_do), int(delay))
            except:
                pass

        for d in delays:
            _make(d)

    def _poll_catalog_loaded(self, timeout_sec=12.0, interval_ms=280):
        """Poll StarsController memory until catalog list changes, then refresh UI immediately (background)."""
        try:
            self._kick_token = int(self._kick_token or 0) + 1
        except:
            self._kick_token = 1
        gen = int(self._kick_token or 0)
        started = time.time()
        base_len = 0
        try:
            base_len = len(self.items or [])
        except:
            base_len = 0

        def _ui_apply(new_items, sig):
            try:
                if not self.sheet or not self.recycler:
                    return
                if int(getattr(self, "_kick_token", 0) or 0) != gen:
                    return
                self.items = new_items
                self._last_catalog_sig = sig
                self._loading_catalog = False
                self._kick_adapter(full=True, min_interval=0.0)
                self._start_icon_kick_chain()
            except:
                pass

        def _ui_keepalive():
            try:
                if not self.sheet or not self.recycler:
                    return
                if int(getattr(self, "_kick_token", 0) or 0) != gen:
                    return
                self._kick_adapter(full=False, min_interval=0.0)
            except:
                pass

        def _ui_timeout():
            try:
                if not self.sheet or not self.recycler:
                    return
                if int(getattr(self, "_kick_token", 0) or 0) != gen:
                    return
                self._loading_catalog = False
                self._kick_adapter(full=True, min_interval=0.0)
                self._start_icon_kick_chain()
            except:
                pass

        def _bg_loop():
            try:
                while True:
                    if int(getattr(self, "_kick_token", 0) or 0) != gen:
                        return
                    if (time.time() - started) > float(timeout_sec):
                        try:
                            AndroidUtilities.runOnUIThread(JRunnable(_ui_timeout))
                        except:
                            pass
                        return

                    new_items = self.plugin._get_catalog_nft_gifts()
                    sig = self._catalog_signature(new_items)
                    try:
                        new_len = len(new_items or [])
                    except:
                        new_len = 0

                    # Loaded if signature changed, or list length changed from baseline.
                    try:
                        last_sig = str(getattr(self, "_last_catalog_sig", "") or "")
                    except:
                        last_sig = ""
                    if (sig and sig != last_sig) or (new_len > 0 and new_len != base_len):
                        try:
                            AndroidUtilities.runOnUIThread(JRunnable(lambda: _ui_apply(new_items, sig)))
                        except:
                            pass
                        return
                    if new_len > 0 and (time.time() - started) > 1.2:
                        try:
                            AndroidUtilities.runOnUIThread(JRunnable(lambda: _ui_apply(new_items, sig)))
                        except:
                            pass
                        return

                    # Still loading; keep UI alive but don't do heavy work on UI thread.
                    try:
                        AndroidUtilities.runOnUIThread(JRunnable(_ui_keepalive))
                    except:
                        pass
                    try:
                        time.sleep(float(interval_ms) / 1000.0)
                    except:
                        return
            except:
                return

        # Use a dedicated background Thread so we don't block IO executor.
        try:
            Thread = jclass("java.lang.Thread")
            t = Thread(JRunnable(_bg_loop))
            try:
                t.setDaemon(True)
            except:
                pass
            t.start()
        except:
            # Fallback: run on plugin executor.
            try:
                self.plugin._bg_submit(_bg_loop, delay_ms=0)
            except:
                pass

    def show(self):
        if not self.activity:
            return
        self._refresh(silent=True)

        builder = BottomSheet.Builder(self.activity)
        try:
            # Prevent sheet from overlapping the top status/title area.
            builder.setApplyTopPadding(True)
            builder.setApplyBottomPadding(True)
        except:
            pass
        builder.setTitle("Каталог NFT", True)

        container = LinearLayout(self.activity)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundGray))

        display_metrics = AndroidUtilities.displayMetrics
        # Cap height so sheet never covers the entire screen.
        # Slightly taller by default, but still keeps comfortable top spacing.
        target_height = int(display_metrics.heightPixels * 0.70)
        try:
            # Leave room for status bar + sheet title + comfortable top spacing.
            target_height = min(target_height, int(display_metrics.heightPixels - AndroidUtilities.dp(260)))
            target_height = max(target_height, int(AndroidUtilities.dp(320)))
        except:
            pass

        self.recycler = UniversalRecyclerView(
            self.fragment,
            JCallback2(self.fill_items),
            JCallback5(self.on_click),
            None
        )
        self.recycler.setBackgroundColor(0)
        try:
            lp = LinearLayout.LayoutParams(-1, target_height)
            container.addView(self.recycler, lp)
        except:
            container.addView(self.recycler, LayoutHelper.createLinear(-1, target_height))

        builder.setCustomView(container)
        self.sheet = builder.show()
        try:
            self.sheet.setOnDismissListener(JOnDismissListener(lambda d: self._on_dismiss()))
        except:
            pass
        try:
            run_on_ui_thread(lambda: self.recycler.adapter.update(True))
        except:
            pass
        try:
            self._install_nested_scroll_fix()
        except:
            pass
        try:
            self._last_catalog_sig = self._catalog_signature(self.items)
        except:
            self._last_catalog_sig = ""
        # Start a coalesced kick chain so icons can appear without breaking scroll.
        self._start_icon_kick_chain()

    def _on_dismiss(self):
        try:
            try:
                self._kick_token = int(self._kick_token or 0) + 1
            except:
                pass
            self.sheet = None
            self.recycler = None
            self.items = []
            self.loader = None
            self.activity = None
            self.fragment = None
        except:
            pass

    def _get_best_location(self, document):
        if not document:
            return None
        mime = get_val(document, "mime_type")
        if mime and "svg" in str(mime).lower():
            return ImageLocation.getForDocument(document)
        target_thumb = None
        thumbs = get_val(document, "thumbs")
        if thumbs:
            try:
                for i in range(thumbs.size()):
                    thumb = thumbs.get(i)
                    t_type = str(get_val(thumb, "type"))
                    if t_type == "m" or t_type == "s":
                        target_thumb = thumb
                        break
                    try:
                        if "TL_photoSize" in thumb.getClass().getSimpleName():
                            target_thumb = thumb
                    except:
                        pass
            except:
                pass
        if target_thumb:
            return ImageLocation.getForDocument(target_thumb, document)
        return None

    def _resolve_spannable_with_icon(self, gift):
        name_str = self.plugin._get_gift_title(gift)
        drawable = None
        document = find_document_recursive(gift)

        if document:
            location = self._get_best_location(document)
            if location and self.loader:
                try:
                    f = self.loader.getPathToAttach(location.location, True)
                except:
                    f = None
                if f and f.exists():
                    try:
                        mime = get_val(document, "mime_type")
                        if mime and "svg" in str(mime).lower():
                            bitmap = SvgHelper.getBitmap(f, 64, 64, False)
                            if bitmap:
                                drawable = BitmapDrawable(ApplicationLoader.applicationContext.getResources(), bitmap)
                        else:
                            bitmap = BitmapFactory.decodeFile(f.getAbsolutePath())
                            if bitmap:
                                scaled = Bitmap.createScaledBitmap(bitmap, 64, 64, True)
                                drawable = BitmapDrawable(ApplicationLoader.applicationContext.getResources(), scaled)
                    except:
                        pass
                else:
                    try:
                        self.loader.loadFile(location, None, None, 1, 1)
                        # Kick adapter soon so icon appears as soon as file is downloaded.
                        self._start_icon_kick_chain()
                    except:
                        pass

        if drawable is None:
            try:
                gift_id = get_val(gift, "id", 0)
                colors = [0xFFFF5E5E, 0xFFFFBB5E, 0xFF5EFF8A, 0xFF5EB4FF, 0xFFD85EFF]
                color_int = colors[int(gift_id) % len(colors)]
                drawable = GradientDrawable()
                drawable.setShape(GradientDrawable.OVAL)
                drawable.setColor(to_java_int(color_int))
            except:
                drawable = None

        if drawable is not None:
            try:
                size = AndroidUtilities.dp(18)
                drawable.setBounds(0, 0, size, size)
                span = ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM)
                spannable = SpannableString("  " + name_str)
                spannable.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                return spannable
            except:
                pass

        return name_str

    def _resolve_price_with_star_icon(self, stars_value):
        """Return a CharSequence showing a star icon + numeric value (no emoji)."""
        try:
            v = int(stars_value or 0)
        except:
            v = 0
        try:
            size = AndroidUtilities.dp(14)
        except:
            size = 14

        drawable = None
        try:
            drawable = self.plugin._get_stars_drawable(size)
        except:
            drawable = None

        if drawable is not None:
            try:
                drawable.setBounds(0, 0, size, size)
                span = ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM)
                ss = SpannableString("  " + str(v))
                ss.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                return ss
            except:
                pass
        return f"Stars: {v}"

    def fill_items(self, items, adapter):
        try:
            items.add(UItem.asButton(-10, "Обновить каталог", "Загрузить из магазина").accent())
            items.add(UItem.asShadow(None))
            if self._loading_catalog:
                items.add(UItem.asShadow("Загрузка каталога..."))
                # Still show cached items below if any.
            if not self.items:
                items.add(UItem.asShadow("Список пуст"))
                return
            for idx, g in enumerate(self.items):
                gift_id = int(get_val(g, "id", 0) or 0)
                title = self._resolve_spannable_with_icon(g)
                floor = int(self.plugin._get_gift_floor_stars(g) or 0)
                desc = self._resolve_price_with_star_icon(floor)
                it = UItem.asButton(idx, title, desc)
                it.object = g
                items.add(it)
        except Exception as e:
            items.add(UItem.asShadow(f"Err: {e}"))

    def on_click(self, item, view, pos, x, y):
        try:
            if item.id == -10:
                if self.plugin._force_load_catalog():
                    self._loading_catalog = True
                    try:
                        self._kick_adapter(full=True, min_interval=0.0)
                    except:
                        pass
                    # Poll until StarsController memory updates, then refresh immediately.
                    self._poll_catalog_loaded(timeout_sec=12.0, interval_ms=280)
                return

            g = getattr(item, "object", None)
            if not g:
                return

            gift_id = int(get_val(g, "id", 0) or 0)
            if gift_id <= 0:
                BulletinHelper.show_error("Не удалось определить gift_id")
                return

            if self.sheet:
                self.sheet.dismiss()

            self.plugin.stolen_gift_inner = g
            self.plugin.stolen_gift_wrapper = None
            self.plugin.cached_gift_id = gift_id
            self.plugin.editing_gift_key = None
            self.plugin._ensure_gift_classes()

            AttrLoader(self.plugin, gift_id).start()
        except Exception as e:
            BulletinHelper.show_error(f"Каталог: {e}")

class LiveSelectorDialog:
    def __init__(self, title, items, on_select, label_resolver):
        self.title = title
        self.items = items
        self.all_items = items
        self.on_select = on_select
        self.label_resolver = label_resolver
        self.is_refreshing = False
        self.dialog = None
        self.container_layout = None
        self.text_views = []
        self.query = ""
        self.filtered_indices = []
        self._plain_labels = []
        self.fragment = get_last_fragment()
        self.activity = self.fragment.getParentActivity()
        try:
            # Precompute for fast filtering.
            for obj in list(self.all_items or []):
                self._plain_labels.append(self._plain_label(obj))
        except:
            self._plain_labels = []

    def show(self):
        try:
            builder = AlertDialog.Builder(self.activity)
            builder.setTitle(self.title)
            root = LinearLayout(self.activity)
            root.setOrientation(LinearLayout.VERTICAL)

            # Search (attribute filter)
            search = EditText(self.activity)
            try:
                search.setHint("Поиск...")
            except:
                pass
            try:
                search.setSingleLine(True)
            except:
                pass
            try:
                pad = AndroidUtilities.dp(12)
                search.setPadding(pad, pad, pad, pad)
            except:
                pass
            try:
                search.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
                search.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            except:
                pass

            def _on_query(q):
                try:
                    self.query = str(q or "")
                except:
                    self.query = ""
                self._apply_filter()

            if JTextWatcher is not None:
                try:
                    search.addTextChangedListener(JTextWatcher(_on_query))
                except:
                    pass
            root.addView(search, LayoutHelper.createLinear(-1, -2))

            scroll = ScrollView(self.activity)
            self.container_layout = LinearLayout(self.activity)
            self.container_layout.setOrientation(LinearLayout.VERTICAL)
            scroll.addView(self.container_layout)
            root.addView(scroll, LayoutHelper.createLinear(-1, -1))

            self._apply_filter(initial=True)
            self._build_list()
            builder.setView(root)
            builder.setNegativeButton("Отмена", None)
            self.dialog = builder.show()
            try:
                self.dialog.setOnDismissListener(JOnDismissListener(lambda d: self._on_dismiss()))
            except:
                pass
            self.is_refreshing = True
            self._refresh_loop()
        except Exception as e:
            BulletinHelper.show_error(f"Dialog Err: {e}")

    def _on_dismiss(self):
        try:
            self.is_refreshing = False
            self.dialog = None
            self.container_layout = None
            self.text_views = []
            self.activity = None
            self.fragment = None
        except:
            pass

    def _plain_label(self, obj):
        try:
            for f in obj.getClass().getFields():
                if f.getType().getName() == "java.lang.String":
                    val = f.get(obj)
                    if val and len(str(val)) > 1 and not str(val).startswith("http"):
                        return str(val)
        except:
            pass
        try:
            # Backdrop: show color-ish token so it can be searched by name label_resolver uses.
            cc = get_val(obj, "center_color", None)
            if cc is not None:
                return "Color"
        except:
            pass
        try:
            return str(obj)
        except:
            return ""

    def _apply_filter(self, initial=False):
        q = ""
        try:
            q = str(self.query or "").strip().lower()
        except:
            q = ""

        try:
            n = len(list(self.all_items or []))
        except:
            n = 0

        if not q:
            self.filtered_indices = list(range(n))
        else:
            out = []
            for i in range(n):
                try:
                    label = self._plain_labels[i] if i < len(self._plain_labels) else self._plain_label(self.all_items[i])
                    if q in str(label).lower():
                        out.append(i)
                except:
                    continue
            self.filtered_indices = out

        if not initial:
            try:
                self._build_list()
            except:
                pass

    def _build_list(self):
        self.container_layout.removeAllViews()
        self.text_views = []

        idxs = self.filtered_indices if self.filtered_indices is not None else list(range(len(self.items or [])))
        if not idxs:
            tv = TextView(self.activity)
            try:
                pad = AndroidUtilities.dp(16)
                tv.setPadding(pad, pad, pad, pad)
            except:
                pass
            tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            tv.setText("Ничего не найдено")
            self.container_layout.addView(tv)
            return

        for orig_i in idxs:
            try:
                obj = self.all_items[orig_i]
            except:
                continue
            tv = TextView(self.activity)
            lp = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            )
            tv.setLayoutParams(lp)
            tv.setTextSize(16)
            pad = AndroidUtilities.dp(16)
            tv.setPadding(pad, pad, pad, pad)
            tv.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            tv.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT)

            def make_click(index):
                return JOnClickListener(lambda v: self._on_item_click(index))

            tv.setOnClickListener(make_click(orig_i))
            tv.setTag(obj)
            ss, _ = self.label_resolver(obj, True)
            tv.setText(ss)
            self.container_layout.addView(tv)
            self.text_views.append(tv)

    def _on_item_click(self, index):
        if self.dialog:
            self.dialog.dismiss()
        self.is_refreshing = False
        self.on_select(index)

    def _refresh_loop(self):
        try:
            if not self.dialog or not self.dialog.isShowing():
                self.is_refreshing = False
                return
            any_loading = False
            for tv in self.text_views:
                obj = tv.getTag()
                if not obj:
                    continue
                ss, is_loading = self.label_resolver(obj, True)
                if is_loading:
                    any_loading = True
                tv.setText(ss)
            if not any_loading:
                self.is_refreshing = False
                return
            if self.is_refreshing:
                run_on_ui_thread(lambda: threading.Timer(1.0, self._refresh_loop).start())
        except:
            pass

class NftBuilderSheet:
    def __init__(self, plugin, base_id, attr_response):
        self.plugin = plugin
        self.base_id = base_id
        self.models = []
        self.patterns = []
        self.backdrops = []
        self.loader = None
        self.sheet = None
        self.recycler = None
        self.is_refreshing = False
        self.top_view = None
        self.crop_container = None
        self.layout_listener = None
        self._refresh_gen = 0
        self._refresh_started_ts = 0.0
        self._last_adapter_update_ts = 0.0

        self.fragment = get_last_fragment()
        self.activity = self.fragment.getParentActivity()

        try:
            acc = get_user_config().selectedAccount
            self.loader = FileLoader.getInstance(to_java_int(acc))
        except:
            pass

        if attr_response:
            self._sort_by_classes(attr_response)

        # Keep user's last/active build config (loaded from cache/library).
        self._apply_initial_build_config()

    def _labels_need_refresh(self):
        """True while any selected attribute icon is still loading."""
        try:
            cfg = self.plugin.build_config
        except:
            cfg = {"model": 0, "pattern": 0, "backdrop": 0, "num": 1}

        any_loading = False
        try:
            m_obj = self.models[cfg["model"] % len(self.models)] if self.models else None
            if m_obj:
                _, l = self.resolve_label_public(m_obj, False)
                any_loading = any_loading or bool(l)
        except:
            pass
        try:
            p_obj = self.patterns[cfg["pattern"] % len(self.patterns)] if self.patterns else None
            if p_obj:
                _, l = self.resolve_label_public(p_obj, False)
                any_loading = any_loading or bool(l)
        except:
            pass
        try:
            b_obj = self.backdrops[cfg["backdrop"] % len(self.backdrops)] if self.backdrops else None
            if b_obj:
                _, l = self.resolve_label_public(b_obj, False)
                any_loading = any_loading or bool(l)
        except:
            pass

        return bool(any_loading)

    def _safe_adapter_update(self, full=False):
        """Avoid RecyclerView inconsistency: update only when idle and not computing layout."""
        if not self.recycler or not getattr(self.recycler, "adapter", None):
            return False
        try:
            if self.recycler.isComputingLayout():
                return False
        except:
            pass
        try:
            # RecyclerView.SCROLL_STATE_IDLE == 0
            if int(self.recycler.getScrollState()) != 0:
                return False
        except:
            pass
        try:
            now = time.time()
            if (now - float(self._last_adapter_update_ts or 0.0)) < 0.35:
                return False
            self._last_adapter_update_ts = now
        except:
            pass
        try:
            self.recycler.adapter.update(bool(full))
            return True
        except Exception as e:
            _log(f"NftBuilderSheet adapter.update failed: {e}")
            return False

    def _refresh_loop(self):
        try:
            if not self.is_refreshing:
                return
            if not self.sheet or self.sheet.isDismissed():
                self.is_refreshing = False
                return

            # Hard stop to avoid background refresh running forever.
            try:
                if self._refresh_started_ts and (time.time() - float(self._refresh_started_ts)) > 12.0:
                    self.is_refreshing = False
                    return
            except:
                pass

            needs = False
            try:
                needs = self._labels_need_refresh()
            except:
                needs = False

            did = False
            if needs:
                try:
                    did = self._safe_adapter_update(full=False)
                except:
                    did = False
                if did:
                    try:
                        run_on_ui_thread(lambda: self._update_preview())
                    except:
                        pass
            else:
                # One last update after everything is loaded.
                self._safe_adapter_update(full=False)
                self.is_refreshing = False
                return

            g = int(self._refresh_gen or 0)

            def _later():
                try:
                    if not self.is_refreshing:
                        return
                    if int(self._refresh_gen or 0) != g:
                        return
                    self._refresh_loop()
                except:
                    pass

            try:
                AndroidUtilities.runOnUIThread(JRunnable(_later), 450)
            except:
                run_on_ui_thread(lambda: threading.Timer(0.45, _later).start())
        except:
            pass

    def _sanitize_cfg(self, cfg):
        if not isinstance(cfg, dict):
            cfg = {}
        return {
            "model": int(cfg.get("model", 0) or 0),
            "pattern": int(cfg.get("pattern", 0) or 0),
            "backdrop": int(cfg.get("backdrop", 0) or 0),
            "num": int(cfg.get("num", 1) or 1),
        }

    def _extract_attr_doc_id(self, a):
        try:
            doc = get_val(a, "document", None)
            if doc is None:
                doc = get_val(a, "sticker", None)
            return int(get_val(doc, "id", 0) or 0) if doc is not None else 0
        except:
            return 0

    def _infer_cfg_from_gift(self, gift):
        if gift is None:
            return None
        cfg = {}
        try:
            n = int(get_val(gift, "num", 0) or 0)
            if n > 0:
                cfg["num"] = n
        except:
            pass

        attrs = get_val(gift, "attributes", None)
        if attrs is None:
            return cfg if cfg else None
        try:
            sz = attrs.size()
        except:
            sz = 0

        for i in range(sz):
            try:
                a = attrs.get(i)
            except:
                continue
            if a is None:
                continue
            try:
                cname = str(a.getClass().getName() or "").lower()
            except:
                cname = ""

            if "model" in cname:
                did = self._extract_attr_doc_id(a)
                if did > 0 and self.models:
                    for j, cand in enumerate(self.models):
                        if did == self._extract_attr_doc_id(cand):
                            cfg["model"] = j
                            break
            elif "pattern" in cname:
                did = self._extract_attr_doc_id(a)
                if did > 0 and self.patterns:
                    for j, cand in enumerate(self.patterns):
                        if did == self._extract_attr_doc_id(cand):
                            cfg["pattern"] = j
                            break
            elif "backdrop" in cname:
                try:
                    cc = int(get_val(a, "center_color", 0) or 0)
                    ec = int(get_val(a, "edge_color", 0) or 0)
                except:
                    cc, ec = 0, 0
                if (cc or ec) and self.backdrops:
                    for j, cand in enumerate(self.backdrops):
                        try:
                            if int(get_val(cand, "center_color", 0) or 0) == cc and int(get_val(cand, "edge_color", 0) or 0) == ec:
                                cfg["backdrop"] = j
                                break
                        except:
                            continue

        return cfg if cfg else None

    def _apply_initial_build_config(self):
        # Priority:
        # 1) Library entry being edited (editing_gift_key)
        # 2) Currently worn collectible (wear_collectible_id)
        # 3) Existing plugin.build_config (from cache)
        try:
            current = self._sanitize_cfg(getattr(self.plugin, "build_config", {}))
        except:
            current = {"model": 0, "pattern": 0, "backdrop": 0, "num": 1}

        entry = None
        try:
            k = getattr(self.plugin, "editing_gift_key", None)
            if k:
                entry = self.plugin._library_find_entry(k)
        except:
            entry = None
        if entry is None:
            try:
                cid = int(getattr(self.plugin, "wear_collectible_id", 0) or 0)
            except:
                cid = 0
            if cid > 0:
                try:
                    entry = self.plugin._library_find_entry_by_unique_id(cid)
                except:
                    entry = None

        if entry is not None:
            try:
                cfg2 = entry.get("build_config", None)
                if isinstance(cfg2, dict):
                    current = self._sanitize_cfg(cfg2)
                else:
                    # Legacy entry: at least keep number stable.
                    current["num"] = int(entry.get("num", current.get("num", 1)) or 1)
            except:
                pass

        # If we still don't know indices, infer from active gift attributes (legacy entries).
        try:
            gift = getattr(self.plugin, "stolen_gift_inner", None)
        except:
            gift = None
        inferred = self._infer_cfg_from_gift(gift)
        if isinstance(inferred, dict):
            for k, v in inferred.items():
                try:
                    current[k] = int(v)
                except:
                    pass

        try:
            self.plugin.build_config = current
        except:
            pass

    def _sort_by_classes(self, resp):
        raw_list = None
        try:
            val = get_val(resp, "attributes")
            if val:
                raw_list = val
            else:
                for f in resp.getClass().getFields():
                    type_name = f.getType().getName()
                    if "ArrayList" in type_name or "List" in type_name:
                        raw_list = f.get(resp)
                        break
        except:
            pass
        if not raw_list:
            _log("AttrLoader: no attributes list found")
            return
        try:
            count = raw_list.size()
            _log(f"Sorting {count} attributes")
            for i in range(count):
                obj = raw_list.get(i)
                full_name = obj.getClass().getName().lower()
                if "model" in full_name:
                    self.models.append(obj)
                elif "pattern" in full_name:
                    self.patterns.append(obj)
                elif "backdrop" in full_name:
                    self.backdrops.append(obj)
            _log(f"Sorted: {len(self.models)} models, {len(self.patterns)} patterns, {len(self.backdrops)} backdrops")
        except:
            pass

    def _get_best_location(self, document):
        if not document:
            return None
        mime = get_val(document, "mime_type")
        if mime and "svg" in str(mime).lower():
            return ImageLocation.getForDocument(document)
        target_thumb = None
        thumbs = get_val(document, "thumbs")
        if thumbs:
            for i in range(thumbs.size()):
                thumb = thumbs.get(i)
                t_type = str(get_val(thumb, "type"))
                if t_type == "m" or t_type == "s":
                    target_thumb = thumb
                    break
                try:
                    if "TL_photoSize" in thumb.getClass().getSimpleName():
                        target_thumb = thumb
                except:
                    pass
        if target_thumb:
            return ImageLocation.getForDocument(target_thumb, document)
        return None

    def _get_drawable_from_doc(self, obj):
        try:
            document = get_val(obj, "document")
            if not document:
                return None
            location = self._get_best_location(document)
            if not location:
                return None
            if self.loader:
                f = self.loader.getPathToAttach(location.location, True)
                if f and f.exists():
                    try:
                        with open(f.getAbsolutePath(), "rb") as fl:
                            if fl.read(4).hex().startswith("504b"):
                                return None
                    except:
                        pass
                    try:
                        bitmap = SvgHelper.getBitmap(f, 64, 64, False)
                        if bitmap:
                            ctx = ApplicationLoader.applicationContext
                            return BitmapDrawable(ctx.getResources(), bitmap)
                    except:
                        pass
                    try:
                        bitmap = BitmapFactory.decodeFile(f.getAbsolutePath())
                        if bitmap:
                            scaled = Bitmap.createScaledBitmap(bitmap, 64, 64, True)
                            ctx = ApplicationLoader.applicationContext
                            return BitmapDrawable(ctx.getResources(), scaled)
                    except:
                        pass
                else:
                    self.loader.loadFile(location, None, None, 1, 1)
        except:
            pass
        return None

    def _enforce_clean_ui(self):
        if not self.top_view or not isinstance(self.top_view, ViewGroup):
            return
        try:
            cnt = self.top_view.getChildCount()
            width = self.top_view.getWidth()
            if width <= 0:
                return
            for i in range(cnt):
                child = self.top_view.getChildAt(i)
                if "ImageView" in child.getClass().getSimpleName():
                    if child.getRight() > width - AndroidUtilities.dp(80) and child.getTop() < AndroidUtilities.dp(80):
                        if child.getVisibility() != 8:
                            child.setVisibility(8)
            real_h = self.top_view.getMeasuredHeight()
            min_safe_h = AndroidUtilities.dp(300)
            if real_h > min_safe_h and self.crop_container:
                crop_amount = AndroidUtilities.dp(150)
                target_height = real_h - crop_amount
                lp = self.crop_container.getLayoutParams()
                if lp and lp.height != target_height:
                    lp.height = target_height
                    self.crop_container.setLayoutParams(lp)
        except:
            pass

    def _create_native_preview(self, context):
        try:
            TopViewClass = jclass("org.telegram.ui.Stars.StarGiftSheet$TopView")
            self.top_view = TopViewClass(context, None, None, None, None, None, None, None, None)
            self.top_view.setPadding(0, 0, 0, 0)
            self.crop_container = FrameLayout(context)
            self.crop_container.addView(self.top_view, LayoutHelper.createFrame(-1, -2))
            self.crop_container.setClipChildren(True)
            self.layout_listener = JOnGlobalLayoutListener(self._enforce_clean_ui)
            self.top_view.getViewTreeObserver().addOnGlobalLayoutListener(self.layout_listener)
            return self.crop_container
        except Exception as e:
            _log(f"Preview error: {e}")
            tv = TextView(context)
            tv.setText(f"Preview Error: {e}")
            return tv

    def _update_preview(self):
        if not self.top_view:
            return
        try:
            J = jclass("org.telegram.tgnet.tl.TL_stars$TL_starGiftUnique")
            fake_gift = J()
            fake_gift.id = random.randint(10000000, 99999999)
            fake_gift.gift_id = self.base_id
            fake_gift.num = self.plugin.build_config["num"]
            try:
                src = getattr(self.plugin, "stolen_gift_inner", None)
                t = str(get_val(src, "title", "")) if src else ""
                s = str(get_val(src, "slug", "")) if src else ""
            except:
                t, s = "", ""
            fake_gift.title = t if t else "Preview NFT"
            fake_gift.slug = s if s else f"preview-{fake_gift.num}"
            fake_gift.attributes = ArrayList()

            cfg = self.plugin.build_config

            def get_obj(lst, idx):
                if not lst:
                    return None
                try:
                    if isinstance(lst, list):
                        obj = lst[idx % len(lst)]
                    else:
                        obj = lst.get(idx % lst.size())
                    if isinstance(obj, str):
                        return None
                    return obj
                except:
                    return None

            m = get_obj(self.models, cfg["model"])
            if m:
                fake_gift.attributes.add(m)
            p = get_obj(self.patterns, cfg["pattern"])
            if p:
                fake_gift.attributes.add(p)
            b = get_obj(self.backdrops, cfg["backdrop"])
            if b:
                fake_gift.attributes.add(b)

            try:
                self.top_view.setGift(fake_gift, False, False, False, False, False)
            except:
                methods = self.top_view.getClass().getMethods()
                for m_method in methods:
                    if m_method.getName() == "setGift":
                        m_method.invoke(self.top_view, fake_gift, False, False, False, False, False)
                        break
        except:
            pass

    def resolve_label_public(self, obj, is_dialog=False):
        name_str = "Unknown"
        is_loading = False
        try:
            for f in obj.getClass().getFields():
                if f.getType().getName() == "java.lang.String":
                    val = f.get(obj)
                    if val and len(str(val)) > 1 and not str(val).startswith("http"):
                        name_str = str(val)
                        break
        except:
            pass

        drawable = None
        try:
            raw_val = get_val(obj, "center_color")
            if raw_val is not None:
                val_with_alpha = int(raw_val) | 0xFF000000
                color_int = to_java_int(val_with_alpha)
                drawable = GradientDrawable()
                drawable.setShape(GradientDrawable.OVAL)
                drawable.setColor(color_int)
        except:
            pass

        if drawable is None:
            drawable = self._get_drawable_from_doc(obj)

        if drawable is None:
            is_loading = True
            try:
                color_int = to_java_int(0xFFDDDDDD)
                drawable = GradientDrawable()
                drawable.setShape(GradientDrawable.RECTANGLE)
                drawable.setColor(color_int)
                drawable.setCornerRadius(AndroidUtilities.dp(4))
            except:
                pass

        if drawable is not None:
            size = AndroidUtilities.dp(16)
            shift = 0 if is_dialog else AndroidUtilities.dp(6)
            drawable.setBounds(-shift, 0, size - shift, size)
            try:
                span = ImageSpan(drawable, 2)
            except:
                span = ImageSpan(drawable, 1)
            spannable = SpannableString("  " + name_str)
            spannable.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable, is_loading

        return name_str, False

    def _show_input_dialog(self):
        try:
            container = FrameLayout(self.activity)
            pad = AndroidUtilities.dp(20)
            container.setPadding(pad, 0, pad, 0)
            et = EditText(self.activity)
            et.setText(str(self.plugin.build_config["num"]))
            et.setInputType(2)
            et.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            container.addView(et, LayoutHelper.createFrame(-1, -2))

            builder = AlertDialog.Builder(self.activity)
            builder.setTitle("Укажите номер NFT")
            builder.setView(container)

            def on_confirm(dialog, which):
                txt = str(et.getText())
                if txt.isdigit():
                    self.plugin.build_config["num"] = int(txt)
                    run_on_ui_thread(lambda: self.recycler.adapter.update(True))
                    run_on_ui_thread(lambda: self._update_preview())

            builder.setPositiveButton("Готово", JTelegramListener(lambda d, w: on_confirm(d, w)))
            builder.setNegativeButton("Отмена", None)

            def on_dialog_show(dialog):
                try:
                    win = dialog.getWindow()
                    if win:
                        win.clearFlags(
                            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE
                            | WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM
                        )
                        win.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE)
                    et.requestFocus()
                    InputMethodManager = jclass("android.view.inputmethod.InputMethodManager")
                    imm = cast(InputMethodManager, self.activity.getSystemService("input_method"))
                    imm.showSoftInput(et, 2)
                except:
                    pass

            dialog = builder.create()
            dialog.setOnShowListener(JOnShowListener(on_dialog_show))
            dialog.show()
            et.postDelayed(JRunnable(lambda: on_dialog_show(dialog)), 200)

        except Exception as e:
            BulletinHelper.show_error(f"Dialog Err: {e}")

    def show(self):
        self.fragment = get_last_fragment()
        self.activity = self.fragment.getParentActivity()

        builder = BottomSheet.Builder(self.activity)
        builder.setTitle("Конструктор NFT", True)

        container = LinearLayout(self.activity)
        container.setOrientation(LinearLayout.VERTICAL)
        container.setBackgroundColor(Theme.getColor(Theme.key_windowBackgroundGray))

        self.crop_container = self._create_native_preview(self.activity)
        container.addView(self.crop_container, LayoutHelper.createLinear(-1, -2))

        self.recycler = UniversalRecyclerView(
            self.fragment,
            JCallback2(self.fill_settings),
            JCallback5(self.on_click),
            None
        )
        self.recycler.setBackgroundColor(0)
        container.addView(self.recycler, LayoutHelper.createLinear(-1, -1))

        builder.setCustomView(container)
        self.sheet = builder.show()
        try:
            self.sheet.setOnDismissListener(JOnDismissListener(lambda d: self._on_dismiss()))
        except:
            pass
        try:
            run_on_ui_thread(lambda: self.recycler.adapter.update(True))
        except:
            pass
        run_on_ui_thread(lambda: self._update_preview())
        self.is_refreshing = True
        try:
            self._refresh_gen = int(self._refresh_gen or 0) + 1
        except:
            self._refresh_gen = 1
        try:
            self._refresh_started_ts = time.time()
        except:
            self._refresh_started_ts = 0.0
        try:
            run_on_ui_thread(lambda: self._refresh_loop())
        except:
            pass

    def _on_dismiss(self):
        # Cleanup references and listeners to reduce leaks.
        try:
            if self.top_view and self.layout_listener:
                try:
                    self.top_view.getViewTreeObserver().removeOnGlobalLayoutListener(self.layout_listener)
                except:
                    pass
        except:
            pass
        self.is_refreshing = False
        try:
            self._refresh_gen = int(self._refresh_gen or 0) + 1
        except:
            pass
        self.sheet = None
        self.recycler = None
        self.top_view = None
        self.crop_container = None
        self.layout_listener = None
        self.activity = None
        self.fragment = None

    def fill_settings(self, items, adapter):
        try:
            items.add(UItem.asHeader("Внешний вид"))
            cfg = self.plugin.build_config

            def get_label(obj):
                if not obj:
                    return "Нет"
                res, _ = self.resolve_label_public(obj, False)
                return res

            m_obj = self.models[cfg["model"] % len(self.models)] if self.models else None
            items.add(UItem.asButton(1, "Модель", get_label(m_obj)))

            p_obj = self.patterns[cfg["pattern"] % len(self.patterns)] if self.patterns else None
            items.add(UItem.asButton(2, "Узор", get_label(p_obj)))

            b_obj = self.backdrops[cfg["backdrop"] % len(self.backdrops)] if self.backdrops else None
            items.add(UItem.asButton(3, "Фон", get_label(b_obj)))

            items.add(UItem.asShadow(None))
            items.add(UItem.asHeader("Параметры"))
            items.add(UItem.asButton(4, "Номер NFT", f"#{cfg['num']}"))
            items.add(UItem.asShadow(None))
            items.add(UItem.asButton(99, "Сохранить и внедрить").accent())
        except Exception as e:
            items.add(UItem.asShadow(f"Error: {e}"))

    def on_click(self, item, view, pos, x, y):
        try:
            if item.id == 1:
                self._show_selector("Выберите модель", self.models, "model")
            elif item.id == 2:
                self._show_selector("Выберите узор", self.patterns, "pattern")
            elif item.id == 3:
                self._show_selector("Выберите фон", self.backdrops, "backdrop")
            elif item.id == 4:
                self._show_input_dialog()
            elif item.id == 99:
                self._create_and_inject()
        except Exception as e:
            BulletinHelper.show_error(f"UI Error: {e}")

    def _show_selector(self, title, items_list, config_key):
        if not items_list:
            BulletinHelper.show_error("Список пуст")
            return

        def on_selected(index):
            self.plugin.build_config[config_key] = index
            run_on_ui_thread(lambda: self.recycler.adapter.update(True))
            run_on_ui_thread(lambda: self._update_preview())

        LiveSelectorDialog(title, items_list, on_selected, self.resolve_label_public).show()

    def _create_and_inject(self):
        try:
            stolen = self.plugin.stolen_gift_inner
            if not stolen:
                BulletinHelper.show_error("Нет украденного подарка!")
                return

            if not self.plugin.cls_unique or not self.plugin.cls_saved:
                if not self.plugin._ensure_gift_classes():
                    BulletinHelper.show_error("Нет классов (TL_savedStarGift/TL_starGiftUnique)")
                    return

            _log("Building custom NFT...")

            gift = self.plugin._new_java_instance(self.plugin.cls_unique)
            if not gift:
                BulletinHelper.show_error("Не удалось создать TL_starGiftUnique")
                _log(f"Build error: can't instantiate cls_unique={self.plugin.cls_unique}")
                return

            for name in ["document", "sticker", "attributes", "availability_total", "availability_issued"]:
                try:
                    val = get_val(stolen, name, None)
                    if val is not None:
                        self.plugin._set_field(gift, name, val)
                except:
                    pass

            for name in ["stars", "upgrade_stars", "limited", "limited_count", "pattern_document", "model_document"]:
                try:
                    val = get_val(stolen, name, None)
                    if val is None:
                        continue
                    self.plugin._set_field(gift, name, val)
                except:
                    pass

            cfg = self.plugin.build_config
            try:
                new_id = random.randint(100000000, 2147483647)
                self.plugin._set_field(gift, "id", new_id)

                try:
                    self.plugin._set_field(gift, "gift_id", int(self.base_id))
                except:
                    pass

                self.plugin._set_field(gift, "num", cfg["num"])
                self.plugin._set_field(gift, "title", str(get_val(stolen, "title", "NFT")))
                custom_slug = self.plugin._build_custom_slug(stolen, cfg["num"])
                self.plugin._set_field(gift, "slug", custom_slug)
            except Exception as e:
                _log(f"Custom data error: {e}\n{traceback.format_exc()}")
                BulletinHelper.show_error(f"Ошибка настройки данных: {e}")
                return

            attrs_list = ArrayList()

            def get_obj(lst, idx):
                if not lst:
                    return None
                try:
                    if isinstance(lst, list):
                        return lst[idx % len(lst)]
                    else:
                        return lst.get(idx % lst.size())
                except:
                    return None

            m = get_obj(self.models, cfg["model"])
            if m:
                attrs_list.add(m)
            p = get_obj(self.patterns, cfg["pattern"])
            if p:
                attrs_list.add(p)
            b = get_obj(self.backdrops, cfg["backdrop"])
            if b:
                attrs_list.add(b)

            self.plugin._set_field(gift, "attributes", attrs_list)
            try:
                gift.attributes = attrs_list
            except:
                pass

            try:
                model_doc = None
                if m:
                    model_doc = get_val(m, "sticker", None)
                    if model_doc is None:
                        model_doc = get_val(m, "document", None)
                chosen = self.plugin._pick_best_doc_for_collectible_status([
                    model_doc,
                    get_val(stolen, "sticker", None),
                    get_val(stolen, "document", None),
                    get_val(gift, "sticker", None),
                    get_val(gift, "document", None),
                ])
                if chosen is not None:
                    self.plugin._set_field(gift, "document", chosen)
                    self.plugin._set_field(gift, "sticker", chosen)
            except:
                pass

            wear_override = {}
            try:
                wear_override["collectible_id"] = int(new_id)
            except:
                pass
            try:
                wear_override["title"] = str(get_val(gift, "title", "NFT"))
                wear_override["slug"] = str(get_val(gift, "slug", ""))
            except:
                pass
            if b:
                for color_field in ["center_color", "edge_color", "pattern_color", "text_color"]:
                    try:
                        val = get_val(b, color_field, None)
                        if val is not None:
                            wear_override[color_field] = int(val)
                    except:
                        pass
            if m:
                try:
                    best = self.plugin._pick_best_doc_for_collectible_status([
                        get_val(stolen, "sticker", None),
                        get_val(stolen, "document", None),
                        get_val(gift, "sticker", None),
                        get_val(gift, "document", None),
                        get_val(m, "sticker", None),
                        get_val(m, "document", None),
                    ])
                    best_id = self.plugin._extract_doc_id(best)
                    if best_id:
                        wear_override["document_id"] = int(best_id)
                except:
                    pass
            if p:
                try:
                    pat_doc = get_val(p, "document", None)
                    if pat_doc:
                        pat_doc_id = get_val(pat_doc, "id", 0)
                        if pat_doc_id:
                            wear_override["pattern_document_id"] = int(pat_doc_id)
                except:
                    pass

            try:
                PeerUser = jclass("org.telegram.tgnet.TLRPC$TL_peerUser")
                my_peer = PeerUser()
                config = get_user_config()
                my_peer.user_id = config.clientUserId
                ok = self.plugin._set_field(gift, "owner_id", my_peer)
                if not ok:
                    ok = self.plugin._set_field(gift, "owner", my_peer)
                if not ok:
                    ok = self.plugin._set_field(gift, "ownerId", my_peer)
                _log(f"Owner spoofed to user_id={config.clientUserId}")
            except Exception as e:
                _log(f"Owner spoof failed: {e}")

            # Fix bogus totals for "X из Y" ribbon (availability_total / limited_count).
            try:
                self.plugin._ensure_unique_gift_availability(gift, base_gift_id=int(self.base_id))
            except:
                pass

            wrapper = self.plugin._new_java_instance(self.plugin.cls_saved)
            if not wrapper:
                BulletinHelper.show_error("Не удалось создать TL_savedStarGift")
                _log(f"Build error: can't instantiate cls_saved={self.plugin.cls_saved}")
                return
            try:
                self.plugin._set_field(wrapper, "gift", gift)
                self.plugin._set_field(wrapper, "date", int(time.time()))
                self.plugin._set_field(wrapper, "pinned_to_top", True)
                try:
                    self.plugin._set_field(wrapper, "unsaved", False)
                except:
                    pass
                try:
                    self.plugin._set_field(wrapper, "saved_id", random.randint(1000, 9999))
                except:
                    pass
            except Exception as e:
                _log(f"Wrap error: {e}")
                BulletinHelper.show_error(f"Ошибка упаковки: {e}")
                return

            _log("Build complete, activating injection...")

            try:
                self.plugin.cached_gift_id = int(self.base_id)
            except:
                pass
            self.plugin.activate_injection(wrapper, wear_override=wear_override)

            if self.sheet:
                self.sheet.dismiss()

        except Exception as e:
            BulletinHelper.show_error(f"Глобальная ошибка: {e}")
            _log(f"Build error: {e}\n{traceback.format_exc()}")
