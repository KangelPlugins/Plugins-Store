__id__ = "crypto_analiz"
__name__ = "Crypto Analiz"
__version__ = "1.0"
__author__ = "@Snegovikio, @Exter_aP"
__description__ = "Плагин отслеживает курс криптовалюты .crypthelp"
__min_version__ = "11.9.0"
__icon__ = "cryptovalue/3"

import requests
import json
import os.path
from datetime import datetime, timedelta
from typing import Optional, Tuple
from base_plugin import BasePlugin, HookResult, HookStrategy
from android_utils import log
from java.util import ArrayList
from org.telegram.tgnet import TLRPC
from ui.bulletin import BulletinHelper
from ui.settings import Divider, Header, Switch, Input
from android.content import ClipboardManager
from android.content import Context

class CryptoTracker(BasePlugin):
    def __init__(self):
        super().__init__()
        self.supported_currencies = [
            "USD", "RUB", "EUR", "UAH", "GBP", "JPY", "CNY",
            "AUD", "CAD", "CHF", "INR", "BRL", "MXN", "SGD",
            "HKD", "SEK", "NOK", "KRW", "TRY", "ZAR", "PLN",
            "THB", "IDR", "MYR", "PHP", "ILS", "AED", "SAR",
            "CLP", "COP", "PEN", "ARS", "VND", "NGN", "EGP"
        ]
        self.crypto_api_url = "https://api.coingecko.com/api/v3"
        self.cache_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache")
        self.config_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), "cache/config_crypto_tracker.json")
        os.makedirs(self.cache_dir, exist_ok=True)
        self.lang = self.get_language()
        self.load_settings()

    def get_language(self) -> str:
        try:
            from org.telegram.messenger import LocaleController
            lang = LocaleController.getInstance().getCurrentLocale().getLanguage()
            if lang in ["ru", "uk", "be"]:
                return "ru"
            return "en"
        except:
            return "en"

    def get_text(self, key: str) -> str:
        texts = {
            "help": {
                "ru": (
                    "📊 Crypto Analyz\n\n"
                    "Команды:\n"
                    ".crypt [криптовалюта] - показать изменение цены за 24 часа\n"
                    ".crypthelp - показать это сообщение\n\n"
                    "Примеры:\n"
                    ".crypt btc - изменение цены Bitcoin\n"
                    ".crypt eth - изменение цены Ethereum\n"
                    ".crypt ton - изменение цены TON"
                ),
                "en": (
                    "📊 Crypto Analyz\n\n"
                    "Commands:\n"
                    ".crypt [crypto] - show price change for 24 hours\n"
                    ".crypthelp - show this help message\n\n"
                    "Examples:\n"
                    ".crypt btc - Bitcoin price change\n"
                    ".crypt eth - Ethereum price change\n"
                    ".crypt ton - TON price change"
                )
            },
            "usage": {
                "ru": "Использование: .crypt [криптовалюта]",
                "en": "Usage: .crypt [crypto]"
            },
            "crypto_not_found": {
                "ru": "❌ Криптовалюта '{}' не найдена",
                "en": "❌ Cryptocurrency '{}' not found"
            },
            "currency_not_supported": {
                "ru": "❌ Валюта {} не поддерживается",
                "en": "❌ Currency {} not supported"
            },
            "currency_changed": {
                "ru": "✅ Валюта по умолчанию изменена на {}",
                "en": "✅ Default currency changed to {}"
            },
            "error": {
                "ru": "❌ Ошибка: {}",
                "en": "❌ Error: {}"
            },
            "search_error": {
                "ru": "❌ Ошибка поиска криптовалюты: {}",
                "en": "❌ Cryptocurrency search error: {}"
            },
            "api_error": {
                "ru": "❌ Ошибка API: {}",
                "en": "❌ API error: {}"
            },
            "network_error": {
                "ru": "❌ Ошибка сети: проверьте подключение к интернету",
                "en": "❌ Network error: check your internet connection"
            }
        }
        return texts.get(key, {}).get(self.lang, texts.get(key, {}).get("en", key))

    def on_plugin_load(self):
        self.log(f"Plugin '{self.name}' loaded successfully.")
        self.add_on_send_message_hook()
        self.load_settings()

    def on_plugin_unload(self):
        self.log(f"Plugin '{self.name}' unloaded successfully.")

    def create_settings(self):
        return [
            Header("Настройки валюты" if self.lang == "ru" else "Currency Settings"),
            Input(
                "default_currency",
                "Валюта по умолчанию" if self.lang == "ru" else "Default Currency",
                self.default_currency,
                "Введите код валюты (например, USD, RUB, EUR)" if self.lang == "ru" else "Enter currency code (e.g., USD, RUB, EUR)",
                on_change=lambda value: self.on_currency_change(value.upper())
            )
        ]

    def on_currency_change(self, value):
        if value.upper() in self.supported_currencies:
            self.default_currency = value.upper()
            self.save_settings()
            BulletinHelper.show(self.get_text("currency_changed").format(value.upper()))
        else:
            BulletinHelper.show(self.get_text("currency_not_supported").format(value))

    def copy_to_clipboard(self, text):
        try:
            context = self.get_context()
            clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE)
            clipboard.setText(text)
            BulletinHelper.show("Адрес скопирован в буфер обмена" if self.lang == "ru" else "Address copied to clipboard")
        except Exception as e:
            self.log(f"Error copying to clipboard: {str(e)}")

    def load_settings(self):
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    settings = json.load(f)
                if "default_currency" in settings:
                    currency = settings["default_currency"]
                    if currency in self.supported_currencies:
                        self.default_currency = currency
                    else:
                        self.default_currency = "USD"
                        self.save_settings()
                else:
                    self.default_currency = "USD"
                    self.save_settings()
            else:
                self.default_currency = "USD"
                self.save_settings()
        except Exception as e:
            self.log(f"Error loading settings: {str(e)}")
            self.default_currency = "USD"
            self.save_settings()

    def save_settings(self):
        try:
            settings = {"default_currency": self.default_currency}
            with open(self.config_file, 'w') as f:
                json.dump(settings, f, indent=4)
        except Exception as e:
            self.log(f"Error saving settings: {str(e)}")

    def get_crypto_id(self, crypto: str) -> str:
        try:
            search_response = requests.get(f"{self.crypto_api_url}/search",
                                        params={"query": crypto}, timeout=10)

            if search_response.status_code != 200:
                raise Exception(self.get_text("network_error"))

            data = search_response.json()

            if "coins" not in data or not data["coins"]:
                raise Exception(self.get_text("crypto_not_found").format(crypto))

            return data["coins"][0]["id"]

        except requests.exceptions.RequestException:
            raise Exception(self.get_text("network_error"))
        except Exception as e:
            raise Exception(self.get_text("search_error").format(str(e)))

    def get_price_change_24h(self, crypto: str) -> dict:
        try:
            crypto_id = self.get_crypto_id(crypto)

            response = requests.get(f"{self.crypto_api_url}/simple/price",
                                  params={"ids": crypto_id,
                                         "vs_currencies": self.default_currency.lower(),
                                         "include_24hr_change": "true",
                                         "include_24hr_vol": "true",
                                         "include_market_cap": "true"},
                                  timeout=10)

            if response.status_code != 200:
                raise Exception(self.get_text("network_error"))

            data = response.json()

            if crypto_id not in data:
                raise Exception(self.get_text("crypto_not_found").format(crypto))

            crypto_data = data[crypto_id]
            current_price = crypto_data.get(self.default_currency.lower(), 0)
            price_change_24h = crypto_data.get(f"{self.default_currency.lower()}_24h_change", 0)
            market_cap = crypto_data.get(f"{self.default_currency.lower()}_market_cap", 0)
            volume_24h = crypto_data.get(f"{self.default_currency.lower()}_24h_vol", 0)

            price_change_absolute = (current_price * price_change_24h) / 100 if price_change_24h else 0
            price_24h_ago = current_price - price_change_absolute

            search_response = requests.get(f"{self.crypto_api_url}/search",
                                        params={"query": crypto}, timeout=10)
            if search_response.status_code == 200:
                search_data = search_response.json()
                if "coins" in search_data and search_data["coins"]:
                    coin_info = search_data["coins"][0]
                    name = coin_info.get("name", crypto.upper())
                    symbol = coin_info.get("symbol", "").upper()
                else:
                    name = crypto.upper()
                    symbol = crypto.upper()
            else:
                name = crypto.upper()
                symbol = crypto.upper()

            return {
                "name": name,
                "symbol": symbol,
                "current_price": current_price,
                "price_24h_ago": price_24h_ago,
                "price_change_percent": price_change_24h,
                "price_change_absolute": price_change_absolute,
                "market_cap": market_cap,
                "volume_24h": volume_24h,
                "currency": self.default_currency
            }

        except requests.exceptions.RequestException:
            raise Exception(self.get_text("network_error"))
        except Exception as e:
            raise Exception(self.get_text("error").format(str(e)))

    def on_send_message_hook(self, account, params):
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()

        message = params.message.strip()

        if message.startswith(".crypt "):
            try:
                args = message.split()
                if len(args) != 2:
                    params.message = self.get_text("usage")
                    # Попробуем разные варианты стратегий
                    try:
                        return HookResult(strategy=HookStrategy.REPLACE, params=params)
                    except:
                        try:
                            return HookResult(strategy=HookStrategy.MODIFY, params=params)
                        except:
                            return HookResult(True, params)

                crypto = args[1].lower()

                price_data = self.get_price_change_24h(crypto)

                current_price = price_data["current_price"]
                market_cap = price_data["market_cap"]
                volume_24h = price_data["volume_24h"]

                if current_price >= 1000:
                    price_format = "{:,.0f}"
                elif current_price >= 1:
                    price_format = "{:,.2f}"
                else:
                    price_format = "{:.6f}"

                if market_cap >= 1_000_000_000:
                    market_cap_str = f"{market_cap/1_000_000_000:.2f}B"
                elif market_cap >= 1_000_000:
                    market_cap_str = f"{market_cap/1_000_000:.2f}M"
                else:
                    market_cap_str = f"{market_cap:,.0f}"

                if volume_24h >= 1_000_000_000:
                    volume_str = f"{volume_24h/1_000_000_000:.2f}B"
                elif volume_24h >= 1_000_000:
                    volume_str = f"{volume_24h/1_000_000:.2f}M"
                else:
                    volume_str = f"{volume_24h:,.0f}"

                if self.lang == "ru":
                    change_emoji = "📈" if price_data["price_change_percent"] >= 0 else "📉"
                    change_text = "рост" if price_data["price_change_percent"] >= 0 else "падение"
                    change_color = "🟢" if price_data["price_change_percent"] >= 0 else "🔴"

                    stats = (
                        f"{change_emoji} {price_data['name']} ({price_data['symbol']})\n\n"
                        f"💰 Текущая цена: {price_format.format(current_price)} {price_data['currency']}\n"
                        f"{change_color} Изменение за 24ч: {price_data['price_change_percent']:+.2f}% ({change_text})\n"
                        f"💵 Абсолютное изменение: {price_data['price_change_absolute']:+.2f} {price_data['currency']}\n"
                        f"🏦 Капитализация: {market_cap_str} {price_data['currency']}\n"
                        f"📊 Объем за 24ч: {volume_str} {price_data['currency']}\n\n"
                        f"⏰ Обновлено: {datetime.now().strftime('%H:%M:%S')}"
                    )
                else:
                    change_emoji = "📈" if price_data["price_change_percent"] >= 0 else "📉"
                    change_text = "increase" if price_data["price_change_percent"] >= 0 else "decrease"
                    change_color = "🟢" if price_data["price_change_percent"] >= 0 else "🔴"

                    stats = (
                        f"{change_emoji} {price_data['name']} ({price_data['symbol']})\n\n"
                        f"💰 Current Price: {price_format.format(current_price)} {price_data['currency']}\n"
                        f"{change_color} 24h Change: {price_data['price_change_percent']:+.2f}% ({change_text})\n"
                        f"💵 Absolute Change: {price_data['price_change_absolute']:+.2f} {price_data['currency']}\n"
                        f"🏦 Market Cap: {market_cap_str} {price_data['currency']}\n"
                        f"📊 24h Volume: {volume_str} {price_data['currency']}\n\n"
                        f"⏰ Updated: {datetime.now().strftime('%H:%M:%S')}"
                    )

                params.message = stats
                try:
                    return HookResult(strategy=HookStrategy.REPLACE, params=params)
                except:
                    try:
                        return HookResult(strategy=HookStrategy.MODIFY, params=params)
                    except:
                        return HookResult(True, params)

            except Exception as e:
                params.message = self.get_text("error").format(str(e))
                try:
                    return HookResult(strategy=HookStrategy.REPLACE, params=params)
                except:
                    try:
                        return HookResult(strategy=HookStrategy.MODIFY, params=params)
                    except:
                        return HookResult(True, params)

        elif message == ".crypthelp":
            params.message = self.get_text("help")
            try:
                return HookResult(strategy=HookStrategy.REPLACE, params=params)
            except:
                try:
                    return HookResult(strategy=HookStrategy.MODIFY, params=params)
                except:
                    return HookResult(True, params)

        return HookResult()